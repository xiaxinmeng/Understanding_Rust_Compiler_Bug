{"sha": "e57577314120bb5504d5ce4b180fb6befc86f672", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NzU3NzMxNDEyMGJiNTUwNGQ1Y2U0YjE4MGZiNmJlZmM4NmY2NzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-22T06:56:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-22T06:56:16Z"}, "message": "Auto merge of #49041 - nikomatsakis:issue-46541-impl-trait-hidden-lifetimes, r=cramertj\n\nDetect illegal hidden lifetimes in `impl Trait`\n\nThis branch fixes #46541 -- however, it presently doesn't build because it also *breaks* a number of existing usages of impl Trait. I'm opening it as a WIP for now, just because we want to move on impl Trait, but I'll try to fix the problem in a bit.\n\n~~(The problem is due to the fact that we apparently infer stricter lifetimes in closures that we need to; for example, if you capture a variable of type `&'a &'b u32`, we will put *precisely* those lifetimes into the closure, even if the closure would be happy with `&'a &'a u32`. This causes the present chance to affect things that are not invariant.)~~ fixed\n\nr? @cramertj", "tree": {"sha": "389292e256ec07ce92d3bd4921312af4bc370f49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/389292e256ec07ce92d3bd4921312af4bc370f49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e57577314120bb5504d5ce4b180fb6befc86f672", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e57577314120bb5504d5ce4b180fb6befc86f672", "html_url": "https://github.com/rust-lang/rust/commit/e57577314120bb5504d5ce4b180fb6befc86f672", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e57577314120bb5504d5ce4b180fb6befc86f672/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb8d08d90415d82beedd42e8c6372568d8582acf", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb8d08d90415d82beedd42e8c6372568d8582acf", "html_url": "https://github.com/rust-lang/rust/commit/eb8d08d90415d82beedd42e8c6372568d8582acf"}, {"sha": "2e8a1abc2df44d8e71e52bf92b658438707564ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e8a1abc2df44d8e71e52bf92b658438707564ea", "html_url": "https://github.com/rust-lang/rust/commit/2e8a1abc2df44d8e71e52bf92b658438707564ea"}], "stats": {"total": 511, "additions": 427, "deletions": 84}, "files": [{"sha": "2fd875c3447677b4d841b320535abbfe543b6917", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -2074,6 +2074,58 @@ a (non-transparent) struct containing a single float, while `Grams` is a\n transparent wrapper around a float. This can make a difference for the ABI.\n \"##,\n \n+E0909: r##\"\n+The `impl Trait` return type captures lifetime parameters that do not\n+appear within the `impl Trait` itself.\n+\n+Erroneous code example:\n+\n+```compile-fail,E0909\n+#![feature(conservative_impl_trait)]\n+\n+use std::cell::Cell;\n+\n+trait Trait<'a> { }\n+\n+impl<'a, 'b> Trait<'b> for Cell<&'a u32> { }\n+\n+fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y>\n+where 'x: 'y\n+{\n+    x\n+}\n+```\n+\n+Here, the function `foo` returns a value of type `Cell<&'x u32>`,\n+which references the lifetime `'x`. However, the return type is\n+declared as `impl Trait<'y>` -- this indicates that `foo` returns\n+\"some type that implements `Trait<'y>`\", but it also indicates that\n+the return type **only captures data referencing the lifetime `'y`**.\n+In this case, though, we are referencing data with lifetime `'x`, so\n+this function is in error.\n+\n+To fix this, you must reference the lifetime `'x` from the return\n+type. For example, changing the return type to `impl Trait<'y> + 'x`\n+would work:\n+\n+```\n+#![feature(conservative_impl_trait)]\n+\n+use std::cell::Cell;\n+\n+trait Trait<'a> { }\n+\n+impl<'a,'b> Trait<'b> for Cell<&'a u32> { }\n+\n+fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y> + 'x\n+where 'x: 'y\n+{\n+    x\n+}\n+```\n+\"##,\n+\n+\n }\n \n "}, {"sha": "93e8745af1b57731318feea40405c51953944899", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 185, "deletions": 57, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -14,10 +14,10 @@ use infer::outlives::free_region_map::FreeRegionRelations;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast;\n use traits::{self, PredicateObligation};\n-use ty::{self, Ty};\n-use ty::fold::{BottomUpFolder, TypeFoldable};\n+use ty::{self, Ty, TyCtxt};\n+use ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n use ty::outlives::Component;\n-use ty::subst::{Kind, UnpackedKind, Substs};\n+use ty::subst::{Kind, Substs, UnpackedKind};\n use util::nodemap::DefIdMap;\n \n pub type AnonTypeMap<'tcx> = DefIdMap<AnonTypeDecl<'tcx>>;\n@@ -113,10 +113,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ) -> InferOk<'tcx, (T, AnonTypeMap<'tcx>)> {\n         debug!(\n             \"instantiate_anon_types(value={:?}, parent_def_id={:?}, body_id={:?}, param_env={:?})\",\n-            value,\n-            parent_def_id,\n-            body_id,\n-            param_env,\n+            value, parent_def_id, body_id, param_env,\n         );\n         let mut instantiator = Instantiator {\n             infcx: self,\n@@ -458,55 +455,184 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // Convert the type from the function into a type valid outside\n         // the function, by replacing invalid regions with 'static,\n         // after producing an error for each of them.\n-        let definition_ty = gcx.fold_regions(&instantiated_ty, &mut false, |r, _| {\n-            match *r {\n-                // 'static and early-bound regions are valid.\n-                ty::ReStatic | ty::ReEmpty => r,\n-\n-                // All other regions, we map them appropriately to their adjusted\n-                // indices, erroring if we find any lifetimes that were not mapped\n-                // into the new set.\n-                _ => if let Some(UnpackedKind::Lifetime(r1)) = map.get(&r.into())\n-                                                                  .map(|k| k.unpack()) {\n-                    r1\n-                } else {\n-                    // No mapping was found. This means that\n-                    // it is either a disallowed lifetime,\n-                    // which will be caught by regionck, or it\n-                    // is a region in a non-upvar closure\n-                    // generic, which is explicitly\n-                    // allowed. If that surprises you, read\n-                    // on.\n-                    //\n-                    // The case of closure is a somewhat\n-                    // subtle (read: hacky) consideration. The\n-                    // problem is that our closure types\n-                    // currently include all the lifetime\n-                    // parameters declared on the enclosing\n-                    // function, even if they are unused by\n-                    // the closure itself. We can't readily\n-                    // filter them out, so here we replace\n-                    // those values with `'empty`. This can't\n-                    // really make a difference to the rest of\n-                    // the compiler; those regions are ignored\n-                    // for the outlives relation, and hence\n-                    // don't affect trait selection or auto\n-                    // traits, and they are erased during\n-                    // trans.\n-                    gcx.types.re_empty\n-                },\n-            }\n-        });\n-\n+        let definition_ty =\n+            instantiated_ty.fold_with(&mut ReverseMapper::new(\n+                self.tcx,\n+                self.is_tainted_by_errors(),\n+                def_id,\n+                map,\n+                instantiated_ty,\n+            ));\n         debug!(\n             \"infer_anon_definition_from_instantiation: definition_ty={:?}\",\n             definition_ty\n         );\n \n+        // We can unwrap here because our reverse mapper always\n+        // produces things with 'gcx lifetime, though the type folder\n+        // obscures that.\n+        let definition_ty = gcx.lift(&definition_ty).unwrap();\n+\n         definition_ty\n     }\n }\n \n+struct ReverseMapper<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+\n+    /// If errors have already been reported in this fn, we suppress\n+    /// our own errors because they are sometimes derivative.\n+    tainted_by_errors: bool,\n+\n+    anon_type_def_id: DefId,\n+    map: FxHashMap<Kind<'tcx>, Kind<'gcx>>,\n+    map_missing_regions_to_empty: bool,\n+\n+    /// initially `Some`, set to `None` once error has been reported\n+    hidden_ty: Option<Ty<'tcx>>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> ReverseMapper<'cx, 'gcx, 'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        tainted_by_errors: bool,\n+        anon_type_def_id: DefId,\n+        map: FxHashMap<Kind<'tcx>, Kind<'gcx>>,\n+        hidden_ty: Ty<'tcx>,\n+    ) -> Self {\n+        Self {\n+            tcx,\n+            tainted_by_errors,\n+            anon_type_def_id,\n+            map,\n+            map_missing_regions_to_empty: false,\n+            hidden_ty: Some(hidden_ty),\n+        }\n+    }\n+\n+    fn fold_kind_mapping_missing_regions_to_empty(&mut self, kind: Kind<'tcx>) -> Kind<'tcx> {\n+        assert!(!self.map_missing_regions_to_empty);\n+        self.map_missing_regions_to_empty = true;\n+        let kind = kind.fold_with(self);\n+        self.map_missing_regions_to_empty = false;\n+        kind\n+    }\n+\n+    fn fold_kind_normally(&mut self, kind: Kind<'tcx>) -> Kind<'tcx> {\n+        assert!(!self.map_missing_regions_to_empty);\n+        kind.fold_with(self)\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match r {\n+            // ignore bound regions that appear in the type (e.g., this\n+            // would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n+            ty::ReLateBound(..) => return r,\n+\n+            // ignore `'static`, as that can appear anywhere\n+            ty::ReStatic => return r,\n+\n+            _ => { }\n+        }\n+\n+        match self.map.get(&r.into()).map(|k| k.unpack()) {\n+            Some(UnpackedKind::Lifetime(r1)) => r1,\n+            Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n+            None => {\n+                if !self.map_missing_regions_to_empty && !self.tainted_by_errors {\n+                    if let Some(hidden_ty) = self.hidden_ty.take() {\n+                        let span = self.tcx.def_span(self.anon_type_def_id);\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0909,\n+                            \"hidden type for `impl Trait` captures lifetime that \\\n+                             does not appear in bounds\",\n+                        );\n+\n+                        // Assuming regionck succeeded, then we must\n+                        // be capturing *some* region from the fn\n+                        // header, and hence it must be free, so it's\n+                        // ok to invoke this fn (which doesn't accept\n+                        // all regions, and would ICE if an\n+                        // inappropriate region is given). We check\n+                        // `is_tainted_by_errors` by errors above, so\n+                        // we don't get in here unless regionck\n+                        // succeeded. (Note also that if regionck\n+                        // failed, then the regions we are attempting\n+                        // to map here may well be giving errors\n+                        // *because* the constraints were not\n+                        // satisfiable.)\n+                        self.tcx.note_and_explain_free_region(\n+                            &mut err,\n+                            &format!(\"hidden type `{}` captures \", hidden_ty),\n+                            r,\n+                            \"\"\n+                        );\n+\n+                        err.emit();\n+                    }\n+                }\n+                self.tcx.types.re_empty\n+            },\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match ty.sty {\n+            ty::TyClosure(def_id, substs) => {\n+                // I am a horrible monster and I pray for death. When\n+                // we encounter a closure here, it is always a closure\n+                // from within the function that we are currently\n+                // type-checking -- one that is now being encapsulated\n+                // in an existential abstract type. Ideally, we would\n+                // go through the types/lifetimes that it references\n+                // and treat them just like we would any other type,\n+                // which means we would error out if we find any\n+                // reference to a type/region that is not in the\n+                // \"reverse map\".\n+                //\n+                // **However,** in the case of closures, there is a\n+                // somewhat subtle (read: hacky) consideration. The\n+                // problem is that our closure types currently include\n+                // all the lifetime parameters declared on the\n+                // enclosing function, even if they are unused by the\n+                // closure itself. We can't readily filter them out,\n+                // so here we replace those values with `'empty`. This\n+                // can't really make a difference to the rest of the\n+                // compiler; those regions are ignored for the\n+                // outlives relation, and hence don't affect trait\n+                // selection or auto traits, and they are erased\n+                // during trans.\n+\n+                let generics = self.tcx.generics_of(def_id);\n+                let parent_len = generics.parent_count();\n+                let substs = self.tcx.mk_substs(substs.substs.iter().enumerate().map(\n+                    |(index, &kind)| {\n+                        if index < parent_len {\n+                            // Accommodate missing regions in the parent kinds...\n+                            self.fold_kind_mapping_missing_regions_to_empty(kind)\n+                        } else {\n+                            // ...but not elsewhere.\n+                            self.fold_kind_normally(kind)\n+                        }\n+                    },\n+                ));\n+\n+                self.tcx.mk_closure(def_id, ty::ClosureSubsts { substs })\n+            }\n+\n+            _ => ty.super_fold_with(self),\n+        }\n+    }\n+}\n+\n struct Instantiator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     parent_def_id: DefId,\n@@ -565,12 +691,13 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                             return self.fold_anon_ty(ty, def_id, substs);\n                         }\n \n-                        debug!(\"instantiate_anon_types_in_map: \\\n-                                encountered anon with wrong parent \\\n-                                def_id={:?} \\\n-                                anon_parent_def_id={:?}\",\n-                               def_id,\n-                               anon_parent_def_id);\n+                        debug!(\n+                            \"instantiate_anon_types_in_map: \\\n+                             encountered anon with wrong parent \\\n+                             def_id={:?} \\\n+                             anon_parent_def_id={:?}\",\n+                            def_id, anon_parent_def_id\n+                        );\n                     }\n                 }\n \n@@ -590,8 +717,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n \n         debug!(\n             \"instantiate_anon_types: TyAnon(def_id={:?}, substs={:?})\",\n-            def_id,\n-            substs\n+            def_id, substs\n         );\n \n         // Use the same type variable if the exact same TyAnon appears more\n@@ -600,8 +726,10 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n             return anon_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n-        let ty_var = infcx.next_ty_var(ty::UniverseIndex::ROOT,\n-                                       TypeVariableOrigin::TypeInference(span));\n+        let ty_var = infcx.next_ty_var(\n+            ty::UniverseIndex::ROOT,\n+            TypeVariableOrigin::TypeInference(span),\n+        );\n \n         let predicates_of = tcx.predicates_of(def_id);\n         let bounds = predicates_of.instantiate(tcx, substs);"}, {"sha": "22526c7751d5021dfb4809f3b5a1d061e164aa6f", "filename": "src/librustc/infer/canonical.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -40,6 +40,7 @@ use traits::{Obligation, ObligationCause, PredicateObligation};\n use ty::{self, CanonicalVar, Lift, Region, Slice, Ty, TyCtxt, TypeFlags};\n use ty::subst::{Kind, UnpackedKind};\n use ty::fold::{TypeFoldable, TypeFolder};\n+use util::captures::Captures;\n use util::common::CellUsizeExt;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -382,7 +383,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         unsubstituted_region_constraints: &'a QueryRegionConstraints<'tcx>,\n         result_subst: &'a CanonicalVarValues<'tcx>,\n-    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a {\n+    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + Captures<'gcx> + 'a {\n         let QueryRegionConstraints {\n             region_outlives,\n             ty_outlives,"}, {"sha": "22b07c8cc044f55619255ee7edbfdcff18a4b843", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -157,6 +157,7 @@ pub mod traits;\n pub mod ty;\n \n pub mod util {\n+    pub mod captures;\n     pub mod common;\n     pub mod ppaux;\n     pub mod nodemap;"}, {"sha": "e56a8662f3eb4346747c3ae36e083d49422c6a8d", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -19,6 +19,7 @@ use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::Name;\n+use util::captures::Captures;\n use util::nodemap::{DefIdMap, FxHashMap};\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n@@ -313,9 +314,10 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n-    pub fn items(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                 -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n+    pub fn items(\n+        &self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    ) -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n         tcx.associated_items(self.def_id())\n     }\n \n@@ -367,9 +369,13 @@ impl<'a, 'gcx, 'tcx> Ancestors {\n     /// Search the items from the given ancestors, returning each definition\n     /// with the given name and the given kind.\n     #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n-    pub fn defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, trait_item_name: Name,\n-                trait_item_kind: ty::AssociatedKind, trait_def_id: DefId)\n-                -> impl Iterator<Item = NodeItem<ty::AssociatedItem>> + 'a {\n+    pub fn defs(\n+        self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        trait_item_name: Name,\n+        trait_item_kind: ty::AssociatedKind,\n+        trait_def_id: DefId,\n+    ) -> impl Iterator<Item = NodeItem<ty::AssociatedItem>> + Captures<'gcx> + Captures<'tcx> + 'a {\n         self.flat_map(move |node| {\n             node.items(tcx).filter(move |impl_item| {\n                 impl_item.kind == trait_item_kind &&"}, {"sha": "95c5cd377d71f4c190adf60e2eca2374be9d3f5a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -34,6 +34,7 @@ use ty;\n use ty::subst::{Subst, Substs};\n use ty::util::{IntTypeExt, Discr};\n use ty::walk::TypeWalker;\n+use util::captures::Captures;\n use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use serialize::{self, Encodable, Encoder};\n@@ -1942,8 +1943,10 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn discriminants(&'a self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                         -> impl Iterator<Item=Discr<'tcx>> + 'a {\n+    pub fn discriminants(\n+        &'a self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    ) -> impl Iterator<Item=Discr<'tcx>> + Captures<'gcx> + 'a {\n         let repr_type = self.repr.discr_type();\n         let initial = repr_type.initial_discriminant(tcx.global_tcx());\n         let mut prev_discr = None::<Discr<'tcx>>;\n@@ -2290,7 +2293,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns an iterator of the def-ids for all body-owners in this\n     /// crate. If you would prefer to iterate over the bodies\n     /// themselves, you can do `self.hir.krate().body_ids.iter()`.\n-    pub fn body_owners(self) -> impl Iterator<Item = DefId> + 'a {\n+    pub fn body_owners(\n+        self,\n+    ) -> impl Iterator<Item = DefId> + Captures<'tcx> + Captures<'gcx> + 'a {\n         self.hir.krate()\n                 .body_ids\n                 .iter()\n@@ -2394,11 +2399,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n-    pub fn associated_items(self, def_id: DefId)\n-                            -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n+    pub fn associated_items(\n+        self,\n+        def_id: DefId,\n+    ) -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n         let def_ids = self.associated_item_def_ids(def_id);\n-        (0..def_ids.len()).map(move |i| self.associated_item(def_ids[i]))\n+        Box::new((0..def_ids.len()).map(move |i| self.associated_item(def_ids[i])))\n+            as Box<dyn Iterator<Item = ty::AssociatedItem> + 'a>\n     }\n \n     /// Returns true if the impls are the same polarity and are implementing"}, {"sha": "d7ab6e39ac5f082dbbd4103810abc3266d66a196", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -18,6 +18,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n+use util::captures::Captures;\n \n use std::iter;\n use std::cmp::Ordering;\n@@ -384,9 +385,11 @@ impl<'a, 'gcx, 'tcx> ClosureSubsts<'tcx> {\n     /// This returns the types of the MIR locals which had to be stored across suspension points.\n     /// It is calculated in rustc_mir::transform::generator::StateTransform.\n     /// All the types here must be in the tuple in GeneratorInterior.\n-    pub fn state_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n-        impl Iterator<Item=Ty<'tcx>> + 'a\n-    {\n+    pub fn state_tys(\n+        self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    ) -> impl Iterator<Item=Ty<'tcx>> + Captures<'gcx> + 'a {\n         let state = tcx.generator_layout(def_id).fields.iter();\n         state.map(move |d| d.ty.subst(tcx, self.substs))\n     }\n@@ -403,7 +406,7 @@ impl<'a, 'gcx, 'tcx> ClosureSubsts<'tcx> {\n     /// This is the types of all the fields stored in a generator.\n     /// It includes the upvars, state types and the state discriminant which is u32.\n     pub fn field_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n-        impl Iterator<Item=Ty<'tcx>> + 'a\n+        impl Iterator<Item=Ty<'tcx>> + Captures<'gcx> + 'a\n     {\n         self.pre_transforms_tys(def_id, tcx).chain(self.state_tys(def_id, tcx))\n     }"}, {"sha": "b68cfd278fa9eb0b01f35b3124b94c1822874ce3", "filename": "src/librustc/util/captures.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Futil%2Fcaptures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc%2Futil%2Fcaptures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcaptures.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// \"Signaling\" trait used in impl trait to tag lifetimes that you may\n+/// need to capture but don't really need for other reasons.\n+/// Basically a workaround; see [this comment] for details.\n+///\n+/// [this comment]: https://github.com/rust-lang/rust/issues/34511#issuecomment-373423999\n+pub trait Captures<'a> { }\n+\n+impl<'a, T: ?Sized> Captures<'a> for T { }"}, {"sha": "b0c945fbf2a052f3f1f1027c3d62b03dc2b76451", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -29,6 +29,7 @@ use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::codec::TyDecoder;\n use rustc::mir::Mir;\n+use rustc::util::captures::Captures;\n use rustc::util::nodemap::FxHashMap;\n \n use std::collections::BTreeMap;\n@@ -146,7 +147,10 @@ impl<'a, 'tcx: 'a, T: Decodable> Lazy<T> {\n }\n \n impl<'a, 'tcx: 'a, T: Decodable> LazySeq<T> {\n-    pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> impl Iterator<Item = T> + 'a {\n+    pub fn decode<M: Metadata<'a, 'tcx>>(\n+        self,\n+        meta: M,\n+    ) -> impl Iterator<Item = T> + Captures<'tcx> + 'a {\n         let mut dcx = meta.decoder(self.position);\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         (0..self.len).map(move |_| T::decode(&mut dcx).unwrap())"}, {"sha": "4fc3344dab2a919dd796d84de0e27e70fe9cdf8c", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -217,7 +217,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .upvar_tys(closure_def_id, self.tcx)\n             .zip(final_upvar_tys)\n         {\n-            self.demand_eqtype(span, final_upvar_ty, upvar_ty);\n+            self.demand_suptype(span, upvar_ty, final_upvar_ty);\n         }\n \n         // If we are also inferred the closure kind here,"}, {"sha": "6f24d06844bb4c124ed600787acfe1ec7459e949", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -35,8 +35,9 @@ use rustc::ty::{ToPredicate, ReprOptions};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n-use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::ty::util::Discr;\n+use rustc::util::captures::Captures;\n+use rustc::util::nodemap::{FxHashSet, FxHashMap};\n \n use syntax::{abi, ast};\n use syntax::ast::MetaItemKind;\n@@ -1281,7 +1282,7 @@ fn is_unsized<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ast_generics: &'a hir::Generics)\n-    -> impl Iterator<Item=&'a hir::LifetimeDef>\n+    -> impl Iterator<Item=&'a hir::LifetimeDef> + Captures<'tcx>\n {\n     ast_generics\n         .lifetimes()"}, {"sha": "d621cdb4d58f8c89d5f3791f581963cca37f624d", "filename": "src/test/mir-opt/end_region_8.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_8.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -36,7 +36,7 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //    let _2: &'21_1rs D;\n //    ...\n //    let mut _3: ();\n-//    let mut _4: [closure@NodeId(22) r:&'21_1rs D];\n+//    let mut _4: [closure@NodeId(22) r:&'19s D];\n //    let mut _5: &'21_1rs D;\n //    bb0: {\n //        StorageLive(_1);\n@@ -54,13 +54,15 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //        resume;\n //    }\n //    bb2: {\n+//        EndRegion('19s);\n //        StorageDead(_4);\n //        _0 = ();\n //        EndRegion('21_1rs);\n //        StorageDead(_2);\n //        drop(_1) -> [return: bb4, unwind: bb1];\n //    }\n //    bb3: {\n+//        EndRegion('19s);\n //        EndRegion('21_1rs);\n //        drop(_1) -> bb1;\n //    }\n@@ -72,7 +74,7 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.main.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(22) r:&'21_1rs D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(22) r:&'19s D]) -> i32 {\n //     let mut _0: i32;\n //     let mut _2: i32;\n //"}, {"sha": "dd78baf9275098266074f7a73cae1043dfa1ad87", "filename": "src/test/ui/generator/auto-trait-regions.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -1,15 +1,15 @@\n-error[E0277]: the trait bound `No: Foo` is not satisfied in `[generator@$DIR/auto-trait-regions.rs:35:15: 39:6 x:&&'static OnlyFooIfStaticRef for<'r> {&'r OnlyFooIfStaticRef, ()}]`\n+error[E0277]: the trait bound `No: Foo` is not satisfied in `[generator@$DIR/auto-trait-regions.rs:35:15: 39:6 x:&&OnlyFooIfStaticRef for<'r> {&'r OnlyFooIfStaticRef, ()}]`\n   --> $DIR/auto-trait-regions.rs:40:5\n    |\n LL |     assert_foo(gen); //~ ERROR the trait bound `No: Foo` is not satisfied\n-   |     ^^^^^^^^^^ within `[generator@$DIR/auto-trait-regions.rs:35:15: 39:6 x:&&'static OnlyFooIfStaticRef for<'r> {&'r OnlyFooIfStaticRef, ()}]`, the trait `Foo` is not implemented for `No`\n+   |     ^^^^^^^^^^ within `[generator@$DIR/auto-trait-regions.rs:35:15: 39:6 x:&&OnlyFooIfStaticRef for<'r> {&'r OnlyFooIfStaticRef, ()}]`, the trait `Foo` is not implemented for `No`\n    |\n    = help: the following implementations were found:\n              <No as Foo>\n    = note: required because it appears within the type `OnlyFooIfStaticRef`\n    = note: required because it appears within the type `&OnlyFooIfStaticRef`\n    = note: required because it appears within the type `for<'r> {&'r OnlyFooIfStaticRef, ()}`\n-   = note: required because it appears within the type `[generator@$DIR/auto-trait-regions.rs:35:15: 39:6 x:&&'static OnlyFooIfStaticRef for<'r> {&'r OnlyFooIfStaticRef, ()}]`\n+   = note: required because it appears within the type `[generator@$DIR/auto-trait-regions.rs:35:15: 39:6 x:&&OnlyFooIfStaticRef for<'r> {&'r OnlyFooIfStaticRef, ()}]`\n note: required by `assert_foo`\n   --> $DIR/auto-trait-regions.rs:30:1\n    |"}, {"sha": "f554efe903613390f9103d57d114435a80fe2301", "filename": "src/test/ui/impl-trait/region-escape-via-bound-contravariant-closure.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound-contravariant-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound-contravariant-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound-contravariant-closure.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// In contrast to `region-escape-via-bound-invariant`, in this case we\n+// *can* return a value of type `&'x u32`, even though `'x` does not\n+// appear in the bounds. This is because `&` is contravariant, and so\n+// we are *actually* returning a `&'y u32`.\n+//\n+// See https://github.com/rust-lang/rust/issues/46541 for more details.\n+\n+// run-pass\n+\n+#![allow(dead_code)]\n+#![feature(conservative_impl_trait)]\n+#![feature(in_band_lifetimes)]\n+#![feature(nll)]\n+\n+fn foo(x: &'x u32) -> impl Fn() -> &'y u32\n+where 'x: 'y\n+{\n+    move || x\n+}\n+\n+fn main() { }"}, {"sha": "416bdae517845f4580b1ddad47f134926b4fa213", "filename": "src/test/ui/impl-trait/region-escape-via-bound-contravariant.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound-contravariant.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// In contrast to `region-escape-via-bound-invariant`, in this case we\n+// *can* return a value of type `&'x u32`, even though `'x` does not\n+// appear in the bounds. This is because `&` is contravariant, and so\n+// we are *actually* returning a `&'y u32`.\n+//\n+// See https://github.com/rust-lang/rust/issues/46541 for more details.\n+\n+// run-pass\n+\n+#![allow(dead_code)]\n+#![feature(conservative_impl_trait)]\n+#![feature(in_band_lifetimes)]\n+#![feature(nll)]\n+\n+trait Trait<'a> { }\n+\n+impl Trait<'b> for &'a u32 { }\n+\n+fn foo(x: &'x u32) -> impl Trait<'y>\n+where 'x: 'y\n+{\n+    x\n+}\n+\n+fn main() { }"}, {"sha": "38c18ce61044e79e8008279d1bbcc543e012f052", "filename": "src/test/ui/impl-trait/region-escape-via-bound.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do not allow the region `'x` to escape in the impl\n+// trait **even though** `'y` escapes, which outlives `'x`.\n+//\n+// See https://github.com/rust-lang/rust/issues/46541 for more details.\n+\n+#![allow(dead_code)]\n+#![feature(conservative_impl_trait)]\n+#![feature(in_band_lifetimes)]\n+#![feature(nll)]\n+\n+use std::cell::Cell;\n+\n+trait Trait<'a> { }\n+\n+impl Trait<'b> for Cell<&'a u32> { }\n+\n+fn foo(x: Cell<&'x u32>) -> impl Trait<'y>\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds [E0909]\n+where 'x: 'y\n+{\n+    x\n+}\n+\n+fn main() { }"}, {"sha": "5659fee9bedc6c4411ef9b196ffcbe44cd1f2399", "filename": "src/test/ui/impl-trait/region-escape-via-bound.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e57577314120bb5504d5ce4b180fb6befc86f672/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr?ref=e57577314120bb5504d5ce4b180fb6befc86f672", "patch": "@@ -0,0 +1,20 @@\n+error[E0909]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/region-escape-via-bound.rs:27:29\n+   |\n+LL | fn foo(x: Cell<&'x u32>) -> impl Trait<'y>\n+   |                             ^^^^^^^^^^^^^^\n+   |\n+note: hidden type `std::cell::Cell<&'x u32>` captures the lifetime 'x as defined on the function body at 27:1\n+  --> $DIR/region-escape-via-bound.rs:27:1\n+   |\n+LL | / fn foo(x: Cell<&'x u32>) -> impl Trait<'y>\n+LL | |     //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds [E0909]\n+LL | | where 'x: 'y\n+LL | | {\n+LL | |     x\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0909`."}]}