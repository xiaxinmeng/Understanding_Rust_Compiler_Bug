{"sha": "d70a9945365cbfeab79040d0292a8f41e62c5486", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MGE5OTQ1MzY1Y2JmZWFiNzkwNDBkMDI5MmE4ZjQxZTYyYzU0ODY=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-23T15:35:37Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-24T22:39:31Z"}, "message": "TRPL: deref coercions", "tree": {"sha": "e0f7ccc47b4515aac8665ed4296e5b432cfbfd95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0f7ccc47b4515aac8665ed4296e5b432cfbfd95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d70a9945365cbfeab79040d0292a8f41e62c5486", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d70a9945365cbfeab79040d0292a8f41e62c5486", "html_url": "https://github.com/rust-lang/rust/commit/d70a9945365cbfeab79040d0292a8f41e62c5486", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d70a9945365cbfeab79040d0292a8f41e62c5486/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1114fcd945f6e979660053aeed561bcfb5da669e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1114fcd945f6e979660053aeed561bcfb5da669e", "html_url": "https://github.com/rust-lang/rust/commit/1114fcd945f6e979660053aeed561bcfb5da669e"}], "stats": {"total": 126, "additions": 121, "deletions": 5}, "files": [{"sha": "b7011100971a88a8a4b96bad37bf7934a9714080", "filename": "src/doc/trpl/deref-coercions.md", "status": "modified", "additions": 117, "deletions": 1, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/d70a9945365cbfeab79040d0292a8f41e62c5486/src%2Fdoc%2Ftrpl%2Fderef-coercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/d70a9945365cbfeab79040d0292a8f41e62c5486/src%2Fdoc%2Ftrpl%2Fderef-coercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fderef-coercions.md?ref=d70a9945365cbfeab79040d0292a8f41e62c5486", "patch": "@@ -1,3 +1,119 @@\n % `Deref` coercions\n \n-Coming soon!\n+The standard library provides a special trait, [`Deref`][deref]. It\u2019s normally\n+used to overload `*`, the dereference operator:\n+\n+```rust\n+use std::ops::Deref;\n+\n+struct DerefExample<T> {\n+    value: T,\n+}\n+\n+impl<T> Deref for DerefExample<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &self.value\n+    }\n+}\n+\n+fn main() {\n+    let x = DerefExample { value: 'a' };\n+    assert_eq!('a', *x);\n+}\n+```\n+\n+[deref]: ../std/ops/trait.Deref.html\n+\n+This is useful for writing custom pointer types. However, there\u2019s a language\n+feature related to `Deref`: \u2018deref coercions\u2019. Here\u2019s the rule: If you have a\n+type `U`, and it implements `Deref<Target=T>`, values of `&U` will\n+automatically coerce to a `&T`. Here\u2019s an example:\n+\n+```rust\n+fn foo(s: &str) {\n+    // borrow a string for a second\n+}\n+\n+// String implements Deref<Target=str>\n+let owned = \"Hello\".to_string();\n+\n+// therefore, this works:\n+foo(&owned);\n+```\n+\n+Using an ampersand in front of a value takes a reference to it. So `owned` is a\n+`String`, `&owned` is an `&String`, and since `impl Deref<Target=str> for\n+String`, `&String` will deref to `&str`, which `foo()` takes.\n+\n+That\u2019s it. This rule is one of the only places in which Rust does an automatic\n+conversion for you, but it adds a lot of flexibility. For example, the `Rc<T>`\n+type implements `Deref<Target=T>`, so this works:\n+\n+```rust\n+use std::rc::Rc;\n+\n+fn foo(s: &str) {\n+    // borrow a string for a second\n+}\n+\n+// String implements Deref<Target=str>\n+let owned = \"Hello\".to_string();\n+let counted = Rc::new(owned);\n+\n+// therefore, this works:\n+foo(&counted);\n+```\n+\n+All we\u2019ve done is wrap our `String` in an `Rc<T>`. But we can now pass the\n+`Rc<String>` around anywhere we\u2019d have a `String`. The signature of `foo`\n+didn\u2019t change, but works just as well with either type. This example has two\n+conversions: `Rc<String>` to `String` and then `String` to `&str`. Rust will do\n+this as many times as possible until the types match.\n+\n+Another very common implementation provided by the standard library is:\n+\n+```rust\n+fn foo(s: &[i32]) {\n+    // borrow a slice for a second\n+}\n+\n+// Vec<T> implements Deref<Target=[T]>\n+let owned = vec![1, 2, 3];\n+\n+foo(&owned);\n+```\n+\n+Vectors can `Deref` to a slice.\n+\n+## Deref and method calls\n+\n+`Deref` will also kick in when calling a method. In other words, these are\n+the same two things in Rust:\n+\n+```rust\n+struct Foo;\n+\n+impl Foo {\n+    fn foo(&self) { println!(\"Foo\"); }\n+}\n+\n+let f = Foo;\n+\n+f.foo();\n+```\n+\n+Even though `f` isn\u2019t a reference, and `foo` takes `&self`, this works.\n+That\u2019s because these things are the same:\n+\n+```rust,ignore\n+f.foo();\n+(&f).foo();\n+(&&f).foo();\n+(&&&&&&&&f).foo();\n+```\n+\n+A value of type `&&&&&&&&&&&&&&&&Foo` can still have methods defined on `Foo`\n+called, because the compiler will insert as many * operations as necessary to\n+get it right. And since it\u2019s inserting `*`s, that uses `Deref`."}, {"sha": "1445d39fe873876f48632571c306282c8f1eb155", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d70a9945365cbfeab79040d0292a8f41e62c5486/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/d70a9945365cbfeab79040d0292a8f41e62c5486/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=d70a9945365cbfeab79040d0292a8f41e62c5486", "patch": "@@ -18,7 +18,7 @@ foo.bar().baz();\n Luckily, as you may have guessed with the leading question, you can! Rust provides\n the ability to use this \u2018method call syntax\u2019 via the `impl` keyword.\n \n-## Method calls\n+# Method calls\n \n Here\u2019s how it works:\n \n@@ -83,7 +83,7 @@ impl Circle {\n }\n ```\n \n-## Chaining method calls\n+# Chaining method calls\n \n So, now we know how to call a method, such as `foo.bar()`. But what about our\n original example, `foo.bar().baz()`? This is called \u2018method chaining\u2019, and we\n@@ -127,7 +127,7 @@ fn grow(&self) -> Circle {\n We just say we\u2019re returning a `Circle`. With this method, we can grow a new\n circle to any arbitrary size.\n \n-## Static methods\n+# Static methods\n \n You can also define methods that do not take a `self` parameter. Here\u2019s a\n pattern that\u2019s very common in Rust code:\n@@ -158,7 +158,7 @@ This \u2018static method\u2019 builds a new `Circle` for us. Note that static methods\n are called with the `Struct::method()` syntax, rather than the `ref.method()`\n syntax.\n \n-## Builder Pattern\n+# Builder Pattern\n \n Let\u2019s say that we want our users to be able to create Circles, but we will\n allow them to only set the properties they care about. Otherwise, the `x`"}]}