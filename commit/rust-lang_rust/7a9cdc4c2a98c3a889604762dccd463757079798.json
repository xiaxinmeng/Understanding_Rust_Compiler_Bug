{"sha": "7a9cdc4c2a98c3a889604762dccd463757079798", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhOWNkYzRjMmE5OGMzYTg4OTYwNDc2MmRjY2Q0NjM3NTcwNzk3OTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-25T00:52:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-25T00:52:15Z"}, "message": "Auto merge of #44700 - arielb1:mir-effectck, r=nikomatsakis\n\nMove effect-checking to MIR\n\nThis allows emitting lints from MIR and moves the effect-checking pass to work on it.\n\nI'll make `repr(packed)` misuse unsafe in a separate PR.\n\nr? @eddyb", "tree": {"sha": "03cda00ac7f79b231036fc4de37af657cbb209a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03cda00ac7f79b231036fc4de37af657cbb209a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a9cdc4c2a98c3a889604762dccd463757079798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a9cdc4c2a98c3a889604762dccd463757079798", "html_url": "https://github.com/rust-lang/rust/commit/7a9cdc4c2a98c3a889604762dccd463757079798", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a9cdc4c2a98c3a889604762dccd463757079798/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48c1c548e1a61d1c27cdfb3425db4bbdecf6f303", "url": "https://api.github.com/repos/rust-lang/rust/commits/48c1c548e1a61d1c27cdfb3425db4bbdecf6f303", "html_url": "https://github.com/rust-lang/rust/commit/48c1c548e1a61d1c27cdfb3425db4bbdecf6f303"}, {"sha": "516534ffdf2d267d5706443d5bd2bd7987d7498e", "url": "https://api.github.com/repos/rust-lang/rust/commits/516534ffdf2d267d5706443d5bd2bd7987d7498e", "html_url": "https://github.com/rust-lang/rust/commit/516534ffdf2d267d5706443d5bd2bd7987d7498e"}], "stats": {"total": 1340, "additions": 908, "deletions": 432}, "files": [{"sha": "7a78765365db047e86492d36d152343cc0083bf5", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -445,6 +445,7 @@ define_dep_nodes!( <'tcx>\n     [] BorrowCheckKrate,\n     [] BorrowCheck(DefId),\n     [] MirBorrowCheck(DefId),\n+    [] UnsafetyViolations(DefId),\n \n     [] RvalueCheck(DefId),\n     [] Reachability,"}, {"sha": "6b79f0cde1a8f4a26b5c9ceee1b430413726c9c4", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -479,40 +479,6 @@ fn main() {\n ```\n \"##,\n \n-E0133: r##\"\n-Unsafe code was used outside of an unsafe function or block.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0133\n-unsafe fn f() { return; } // This is the unsafe code\n-\n-fn main() {\n-    f(); // error: call to unsafe function requires unsafe function or block\n-}\n-```\n-\n-Using unsafe functionality is potentially dangerous and disallowed by safety\n-checks. Examples:\n-\n-* Dereferencing raw pointers\n-* Calling functions via FFI\n-* Calling functions marked unsafe\n-\n-These safety checks can be relaxed for a section of the code by wrapping the\n-unsafe instructions with an `unsafe` block. For instance:\n-\n-```\n-unsafe fn f() { return; }\n-\n-fn main() {\n-    unsafe { f(); } // ok!\n-}\n-```\n-\n-See also https://doc.rust-lang.org/book/first-edition/unsafe.html\n-\"##,\n-\n // This shouldn't really ever trigger since the repeated value error comes first\n E0136: r##\"\n A binary can only have one entry point, and by default that entry point is the"}, {"sha": "4bda89690b7a9b8a1c64498e4a6420295babb95c", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -28,10 +28,12 @@ impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n     name,\n     source_info,\n     internal,\n+    lexical_scope,\n     is_user_variable\n });\n impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n+impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, lint_node_id });\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::Terminator<'gcx> {\n@@ -75,6 +77,22 @@ for mir::Terminator<'gcx> {\n     }\n }\n \n+impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for mir::ClearOnDecode<T>\n+    where T: HashStable<StableHashingContext<'gcx>>\n+{\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::ClearOnDecode::Clear => {}\n+            mir::ClearOnDecode::Set(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Local {\n     #[inline]\n@@ -347,6 +365,26 @@ for mir::ProjectionElem<'gcx, V, T>\n }\n \n impl_stable_hash_for!(struct mir::VisibilityScopeData { span, parent_scope });\n+impl_stable_hash_for!(struct mir::VisibilityScopeInfo {\n+    lint_root, safety\n+});\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Safety {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::Safety::Safe |\n+            mir::Safety::BuiltinUnsafe |\n+            mir::Safety::FnUnsafe => {}\n+            mir::Safety::ExplicitUnsafe(node_id) => {\n+                node_id.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Operand<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "1e90aa47267ff18b5388dd9182bccc5ca07f0536", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -111,7 +111,6 @@ pub mod middle {\n     pub mod dataflow;\n     pub mod dead;\n     pub mod dependency_format;\n-    pub mod effect;\n     pub mod entry;\n     pub mod exported_symbols;\n     pub mod free_region;"}, {"sha": "4bc37747f2a76b1dc01c4c3ad23fedf0727b0f04", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -384,6 +384,11 @@ impl LintLevelMap {\n             self.sets.get_lint_level(lint, *idx, None)\n         })\n     }\n+\n+    /// Returns if this `id` has lint level information.\n+    pub fn lint_level_set(&self, id: HirId) -> Option<u32> {\n+        self.id_to_set.get(&id).cloned()\n+    }\n }\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>> for LintLevelMap {"}, {"sha": "7290353e48b0c379b04756512b6e84bfc80f7e12", "filename": "src/librustc/middle/effect.rs", "status": "removed", "additions": 0, "deletions": 316, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/48c1c548e1a61d1c27cdfb3425db4bbdecf6f303/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c1c548e1a61d1c27cdfb3425db4bbdecf6f303/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=48c1c548e1a61d1c27cdfb3425db4bbdecf6f303", "patch": "@@ -1,316 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Enforces the Rust effect system. Currently there is just one effect,\n-//! `unsafe`.\n-use self::RootUnsafeContext::*;\n-\n-use ty::{self, TyCtxt};\n-use lint;\n-use lint::builtin::UNUSED_UNSAFE;\n-\n-use hir::def::Def;\n-use hir::intravisit::{self, FnKind, Visitor, NestedVisitorMap};\n-use hir::{self, PatKind};\n-use syntax::ast;\n-use syntax_pos::Span;\n-use util::nodemap::FxHashSet;\n-\n-#[derive(Copy, Clone)]\n-struct UnsafeContext {\n-    push_unsafe_count: usize,\n-    root: RootUnsafeContext,\n-}\n-\n-impl UnsafeContext {\n-    fn new(root: RootUnsafeContext) -> UnsafeContext {\n-        UnsafeContext { root: root, push_unsafe_count: 0 }\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-enum RootUnsafeContext {\n-    SafeContext,\n-    UnsafeFn,\n-    UnsafeBlock(ast::NodeId),\n-}\n-\n-struct EffectCheckVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n-    body_id: hir::BodyId,\n-\n-    /// Whether we're in an unsafe context.\n-    unsafe_context: UnsafeContext,\n-    used_unsafe: FxHashSet<ast::NodeId>,\n-}\n-\n-impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n-    fn require_unsafe_ext(&mut self, node_id: ast::NodeId, span: Span,\n-                          description: &str, is_lint: bool) {\n-        if self.unsafe_context.push_unsafe_count > 0 { return; }\n-        match self.unsafe_context.root {\n-            SafeContext => {\n-                if is_lint {\n-                    self.tcx.lint_node(lint::builtin::SAFE_EXTERN_STATICS,\n-                                       node_id,\n-                                       span,\n-                                       &format!(\"{} requires unsafe function or \\\n-                                                 block (error E0133)\", description));\n-                } else {\n-                    // Report an error.\n-                    struct_span_err!(\n-                        self.tcx.sess, span, E0133,\n-                        \"{} requires unsafe function or block\", description)\n-                        .span_label(span, description)\n-                        .emit();\n-                }\n-            }\n-            UnsafeBlock(block_id) => {\n-                // OK, but record this.\n-                debug!(\"effect: recording unsafe block as used: {}\", block_id);\n-                self.used_unsafe.insert(block_id);\n-            }\n-            UnsafeFn => {}\n-        }\n-    }\n-\n-    fn require_unsafe(&mut self, span: Span, description: &str) {\n-        self.require_unsafe_ext(ast::DUMMY_NODE_ID, span, description, false)\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_tables = self.tables;\n-        let old_body_id = self.body_id;\n-        self.tables = self.tcx.body_tables(body);\n-        self.body_id = body;\n-        let body = self.tcx.hir.body(body);\n-        self.visit_body(body);\n-        self.tables = old_tables;\n-        self.body_id = old_body_id;\n-    }\n-\n-    fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, fn_decl: &'tcx hir::FnDecl,\n-                body_id: hir::BodyId, span: Span, id: ast::NodeId) {\n-\n-        let (is_item_fn, is_unsafe_fn) = match fn_kind {\n-            FnKind::ItemFn(_, _, unsafety, ..) =>\n-                (true, unsafety == hir::Unsafety::Unsafe),\n-            FnKind::Method(_, sig, ..) =>\n-                (true, sig.unsafety == hir::Unsafety::Unsafe),\n-            _ => (false, false),\n-        };\n-\n-        let old_unsafe_context = self.unsafe_context;\n-        if is_unsafe_fn {\n-            self.unsafe_context = UnsafeContext::new(UnsafeFn)\n-        } else if is_item_fn {\n-            self.unsafe_context = UnsafeContext::new(SafeContext)\n-        }\n-\n-        intravisit::walk_fn(self, fn_kind, fn_decl, body_id, span, id);\n-\n-        self.unsafe_context = old_unsafe_context\n-    }\n-\n-    fn visit_block(&mut self, block: &'tcx hir::Block) {\n-        let old_unsafe_context = self.unsafe_context;\n-        match block.rules {\n-            hir::UnsafeBlock(source) => {\n-                // By default only the outermost `unsafe` block is\n-                // \"used\" and so nested unsafe blocks are pointless\n-                // (the inner ones are unnecessary and we actually\n-                // warn about them). As such, there are two cases when\n-                // we need to create a new context, when we're\n-                // - outside `unsafe` and found a `unsafe` block\n-                //   (normal case)\n-                // - inside `unsafe`, found an `unsafe` block\n-                //   created internally to the compiler\n-                //\n-                // The second case is necessary to ensure that the\n-                // compiler `unsafe` blocks don't accidentally \"use\"\n-                // external blocks (e.g. `unsafe { println(\"\") }`,\n-                // expands to `unsafe { ... unsafe { ... } }` where\n-                // the inner one is compiler generated).\n-                if self.unsafe_context.root == SafeContext || source == hir::CompilerGenerated {\n-                    self.unsafe_context.root = UnsafeBlock(block.id)\n-                }\n-            }\n-            hir::PushUnsafeBlock(..) => {\n-                self.unsafe_context.push_unsafe_count =\n-                    self.unsafe_context.push_unsafe_count.checked_add(1).unwrap();\n-            }\n-            hir::PopUnsafeBlock(..) => {\n-                self.unsafe_context.push_unsafe_count =\n-                    self.unsafe_context.push_unsafe_count.checked_sub(1).unwrap();\n-            }\n-            hir::DefaultBlock => {}\n-        }\n-\n-        intravisit::walk_block(self, block);\n-\n-        self.unsafe_context = old_unsafe_context;\n-\n-        // Don't warn about generated blocks, that'll just pollute the output.\n-        match block.rules {\n-            hir::UnsafeBlock(hir::UserProvided) => {}\n-            _ => return,\n-        }\n-        if self.used_unsafe.contains(&block.id) {\n-            return\n-        }\n-\n-        /// Return the NodeId for an enclosing scope that is also `unsafe`\n-        fn is_enclosed(tcx: TyCtxt,\n-                       used_unsafe: &FxHashSet<ast::NodeId>,\n-                       id: ast::NodeId) -> Option<(String, ast::NodeId)> {\n-            let parent_id = tcx.hir.get_parent_node(id);\n-            if parent_id != id {\n-                if used_unsafe.contains(&parent_id) {\n-                    Some((\"block\".to_string(), parent_id))\n-                } else if let Some(hir::map::NodeItem(&hir::Item {\n-                    node: hir::ItemFn(_, hir::Unsafety::Unsafe, _, _, _, _),\n-                    ..\n-                })) = tcx.hir.find(parent_id) {\n-                    Some((\"fn\".to_string(), parent_id))\n-                } else {\n-                    is_enclosed(tcx, used_unsafe, parent_id)\n-                }\n-            } else {\n-                None\n-            }\n-        }\n-\n-        let mut db = self.tcx.struct_span_lint_node(UNUSED_UNSAFE,\n-                                                    block.id,\n-                                                    block.span,\n-                                                    \"unnecessary `unsafe` block\");\n-        db.span_label(block.span, \"unnecessary `unsafe` block\");\n-        if let Some((kind, id)) = is_enclosed(self.tcx, &self.used_unsafe, block.id) {\n-            db.span_note(self.tcx.hir.span(id),\n-                         &format!(\"because it's nested under this `unsafe` {}\", kind));\n-        }\n-        db.emit();\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        match expr.node {\n-            hir::ExprMethodCall(..) => {\n-                let def_id = self.tables.type_dependent_defs()[expr.hir_id].def_id();\n-                let sig = self.tcx.fn_sig(def_id);\n-                debug!(\"effect: method call case, signature is {:?}\",\n-                        sig);\n-\n-                if sig.0.unsafety == hir::Unsafety::Unsafe {\n-                    self.require_unsafe(expr.span,\n-                                        \"invocation of unsafe method\")\n-                }\n-            }\n-            hir::ExprCall(ref base, _) => {\n-                let base_type = self.tables.expr_ty_adjusted(base);\n-                debug!(\"effect: call case, base type is {:?}\",\n-                        base_type);\n-                match base_type.sty {\n-                    ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-                        if base_type.fn_sig(self.tcx).unsafety() == hir::Unsafety::Unsafe {\n-                            self.require_unsafe(expr.span, \"call to unsafe function\")\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            hir::ExprUnary(hir::UnDeref, ref base) => {\n-                let base_type = self.tables.expr_ty_adjusted(base);\n-                debug!(\"effect: unary case, base type is {:?}\",\n-                        base_type);\n-                if let ty::TyRawPtr(_) = base_type.sty {\n-                    self.require_unsafe(expr.span, \"dereference of raw pointer\")\n-                }\n-            }\n-            hir::ExprInlineAsm(..) => {\n-                self.require_unsafe(expr.span, \"use of inline assembly\");\n-            }\n-            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n-                if let Def::Static(def_id, mutbl) = path.def {\n-                    if mutbl {\n-                        self.require_unsafe(expr.span, \"use of mutable static\");\n-                    } else if match self.tcx.hir.get_if_local(def_id) {\n-                        Some(hir::map::NodeForeignItem(..)) => true,\n-                        Some(..) => false,\n-                        None => self.tcx.is_foreign_item(def_id),\n-                    } {\n-                        self.require_unsafe_ext(expr.id, expr.span, \"use of extern static\", true);\n-                    }\n-                }\n-            }\n-            hir::ExprField(ref base_expr, field) => {\n-                if let ty::TyAdt(adt, ..) = self.tables.expr_ty_adjusted(base_expr).sty {\n-                    if adt.is_union() {\n-                        self.require_unsafe(field.span, \"access to union field\");\n-                    }\n-                }\n-            }\n-            hir::ExprAssign(ref lhs, ref rhs) => {\n-                if let hir::ExprField(ref base_expr, field) = lhs.node {\n-                    if let ty::TyAdt(adt, ..) = self.tables.expr_ty_adjusted(base_expr).sty {\n-                        if adt.is_union() {\n-                            let field_ty = self.tables.expr_ty_adjusted(lhs);\n-                            let owner_def_id = self.tcx.hir.body_owner_def_id(self.body_id);\n-                            let param_env = self.tcx.param_env(owner_def_id);\n-                            if field_ty.moves_by_default(self.tcx, param_env, field.span) {\n-                                self.require_unsafe(field.span,\n-                                                    \"assignment to non-`Copy` union field\");\n-                            }\n-                            // Do not walk the field expr again.\n-                            intravisit::walk_expr(self, base_expr);\n-                            intravisit::walk_expr(self, rhs);\n-                            return\n-                        }\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n-        if let PatKind::Struct(_, ref fields, _) = pat.node {\n-            if let ty::TyAdt(adt, ..) = self.tables.pat_ty(pat).sty {\n-                if adt.is_union() {\n-                    for field in fields {\n-                        self.require_unsafe(field.span, \"matching on union field\");\n-                    }\n-                }\n-            }\n-        }\n-\n-        intravisit::walk_pat(self, pat);\n-    }\n-}\n-\n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let mut visitor = EffectCheckVisitor {\n-        tcx,\n-        tables: &ty::TypeckTables::empty(None),\n-        body_id: hir::BodyId { node_id: ast::CRATE_NODE_ID },\n-        unsafe_context: UnsafeContext::new(SafeContext),\n-        used_unsafe: FxHashSet(),\n-    };\n-\n-    tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n-}"}, {"sha": "ba221ef6ae10b03f9e487d6bdfb599ec0becc62b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -18,6 +18,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n+use rustc_serialize as serialize;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n use ty::subst::{Subst, Substs};\n@@ -33,7 +34,7 @@ use std::fmt::{self, Debug, Formatter, Write};\n use std::{iter, u32};\n use std::ops::{Index, IndexMut};\n use std::vec::IntoIter;\n-use syntax::ast::Name;\n+use syntax::ast::{self, Name};\n use syntax_pos::Span;\n \n mod cache;\n@@ -96,6 +97,10 @@ pub struct Mir<'tcx> {\n     /// and used (eventually) for debuginfo. Indexed by a `VisibilityScope`.\n     pub visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n \n+    /// Crate-local information for each visibility scope, that can't (and\n+    /// needn't) be tracked across crates.\n+    pub visibility_scope_info: ClearOnDecode<IndexVec<VisibilityScope, VisibilityScopeInfo>>,\n+\n     /// Rvalues promoted from this function, such as borrows of constants.\n     /// Each of them is the Mir of a constant with the fn's type parameters\n     /// in scope, but a separate set of locals.\n@@ -151,6 +156,8 @@ pub const START_BLOCK: BasicBlock = BasicBlock(0);\n impl<'tcx> Mir<'tcx> {\n     pub fn new(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n                visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n+               visibility_scope_info: ClearOnDecode<IndexVec<VisibilityScope,\n+                                                             VisibilityScopeInfo>>,\n                promoted: IndexVec<Promoted, Mir<'tcx>>,\n                return_ty: Ty<'tcx>,\n                yield_ty: Option<Ty<'tcx>>,\n@@ -167,6 +174,7 @@ impl<'tcx> Mir<'tcx> {\n         Mir {\n             basic_blocks,\n             visibility_scopes,\n+            visibility_scope_info,\n             promoted,\n             return_ty,\n             yield_ty,\n@@ -278,9 +286,29 @@ impl<'tcx> Mir<'tcx> {\n     }\n }\n \n+#[derive(Clone, Debug)]\n+pub struct VisibilityScopeInfo {\n+    /// A NodeId with lint levels equivalent to this scope's lint levels.\n+    pub lint_root: ast::NodeId,\n+    /// The unsafe block that contains this node.\n+    pub safety: Safety,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum Safety {\n+    Safe,\n+    /// Unsafe because of a PushUnsafeBlock\n+    BuiltinUnsafe,\n+    /// Unsafe because of an unsafe fn\n+    FnUnsafe,\n+    /// Unsafe because of an `unsafe` block\n+    ExplicitUnsafe(ast::NodeId)\n+}\n+\n impl_stable_hash_for!(struct Mir<'tcx> {\n     basic_blocks,\n     visibility_scopes,\n+    visibility_scope_info,\n     promoted,\n     return_ty,\n     yield_ty,\n@@ -310,10 +338,28 @@ impl<'tcx> IndexMut<BasicBlock> for Mir<'tcx> {\n     }\n }\n \n+#[derive(Clone, Debug)]\n+pub enum ClearOnDecode<T> {\n+    Clear,\n+    Set(T)\n+}\n+\n+impl<T> serialize::Encodable for ClearOnDecode<T> {\n+    fn encode<S: serialize::Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        serialize::Encodable::encode(&(), s)\n+    }\n+}\n+\n+impl<T> serialize::Decodable for ClearOnDecode<T> {\n+    fn decode<D: serialize::Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+        serialize::Decodable::decode(d).map(|()| ClearOnDecode::Clear)\n+    }\n+}\n+\n /// Grouped information about the source code origin of a MIR entity.\n /// Intended to be inspected by diagnostics and debuginfo.\n /// Most passes can work with it as a whole, within a single function.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct SourceInfo {\n     /// Source span for the AST pertaining to this MIR entity.\n     pub span: Span,\n@@ -414,14 +460,17 @@ pub struct LocalDecl<'tcx> {\n     /// True if this is an internal local\n     ///\n     /// These locals are not based on types in the source code and are only used\n-    /// for drop flags at the moment.\n+    /// for a few desugarings at the moment.\n     ///\n     /// The generator transformation will sanity check the locals which are live\n     /// across a suspension point against the type components of the generator\n     /// which type checking knows are live across a suspension point. We need to\n     /// flag drop flags to avoid triggering this check as they are introduced\n     /// after typeck.\n     ///\n+    /// Unsafety checking will also ignore dereferences of these locals,\n+    /// so they can be used for raw pointers only used in a desugaring.\n+    ///\n     /// This should be sound because the drop flags are fully algebraic, and\n     /// therefore don't affect the OIBIT or outlives properties of the\n     /// generator.\n@@ -438,6 +487,12 @@ pub struct LocalDecl<'tcx> {\n \n     /// Source info of the local.\n     pub source_info: SourceInfo,\n+\n+    /// The *lexical* visibility scope the local is defined\n+    /// in. If the local was defined in a let-statement, this\n+    /// is *within* the let-statement, rather than outside\n+    /// of it.\n+    pub lexical_scope: VisibilityScope,\n }\n \n impl<'tcx> LocalDecl<'tcx> {\n@@ -452,6 +507,7 @@ impl<'tcx> LocalDecl<'tcx> {\n                 span,\n                 scope: ARGUMENT_VISIBILITY_SCOPE\n             },\n+            lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n             internal: false,\n             is_user_variable: false\n         }\n@@ -468,6 +524,7 @@ impl<'tcx> LocalDecl<'tcx> {\n                 span,\n                 scope: ARGUMENT_VISIBILITY_SCOPE\n             },\n+            lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n             internal: true,\n             is_user_variable: false\n         }\n@@ -485,6 +542,7 @@ impl<'tcx> LocalDecl<'tcx> {\n                 span,\n                 scope: ARGUMENT_VISIBILITY_SCOPE\n             },\n+            lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n             internal: false,\n             name: None,     // FIXME maybe we do want some name here?\n             is_user_variable: false\n@@ -1592,6 +1650,13 @@ impl Location {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct UnsafetyViolation {\n+    pub source_info: SourceInfo,\n+    pub description: &'static str,\n+    pub lint_node_id: Option<ast::NodeId>,\n+}\n+\n /// The layout of generator state\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct GeneratorLayout<'tcx> {\n@@ -1607,6 +1672,7 @@ impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n         Mir {\n             basic_blocks: self.basic_blocks.fold_with(folder),\n             visibility_scopes: self.visibility_scopes.clone(),\n+            visibility_scope_info: self.visibility_scope_info.clone(),\n             promoted: self.promoted.fold_with(folder),\n             return_ty: self.return_ty.fold_with(folder),\n             yield_ty: self.yield_ty.fold_with(folder),"}, {"sha": "63652980f9b4b68372e2a179978c10eea58634f7", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -690,11 +690,13 @@ macro_rules! make_mir_visitor {\n                     name: _,\n                     ref $($mutability)* source_info,\n                     internal: _,\n+                    ref $($mutability)* lexical_scope,\n                     is_user_variable: _,\n                 } = *local_decl;\n \n                 self.visit_ty(ty, Lookup::Src(*source_info));\n                 self.visit_source_info(source_info);\n+                self.visit_visibility_scope(lexical_scope);\n             }\n \n             fn super_visibility_scope(&mut self,"}, {"sha": "4bd2d5be6d716f09a66d51cd6134190f8b9af034", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -159,6 +159,10 @@ define_maps! { <'tcx>\n     /// expression defining the closure.\n     [] fn closure_kind: ClosureKind(DefId) -> ty::ClosureKind,\n \n+    /// Unsafety violations for this def ID.\n+    [] fn unsafety_violations: UnsafetyViolations(DefId)\n+        -> Rc<[mir::UnsafetyViolation]>,\n+\n     /// The signature of functions and closures.\n     [] fn fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n "}, {"sha": "d9df2e1f9ad501542cf37859c19a24ebbb7d35f2", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -1005,19 +1005,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     // What we need to run borrowck etc.\n \n     passes.push_pass(MIR_VALIDATED, mir::transform::qualify_consts::QualifyAndPromoteConstants);\n-\n-    // FIXME: ariel points SimplifyBranches should run after\n-    // mir-borrowck; otherwise code within `if false { ... }` would\n-    // not be checked.\n-    passes.push_pass(MIR_VALIDATED,\n-                     mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n     passes.push_pass(MIR_VALIDATED, mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));\n     passes.push_pass(MIR_VALIDATED, mir::transform::nll::NLL);\n \n     // borrowck runs between MIR_VALIDATED and MIR_OPTIMIZED.\n \n-    // These next passes must be executed together\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n+    passes.push_pass(MIR_OPTIMIZED,\n+                     mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n+\n+    // These next passes must be executed together\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::CriticalCallEdges);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::elaborate_drops::ElaborateDrops);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n@@ -1080,10 +1077,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"intrinsic checking\",\n              || middle::intrinsicck::check_crate(tcx));\n \n-        time(time_passes,\n-             \"effect checking\",\n-             || middle::effect::check_crate(tcx));\n-\n         time(time_passes,\n              \"match checking\",\n              || check_match::check_crate(tcx));\n@@ -1104,6 +1097,11 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"MIR borrow checking\",\n              || for def_id in tcx.body_owners() { tcx.mir_borrowck(def_id) });\n \n+        time(time_passes,\n+             \"MIR effect checking\",\n+             || for def_id in tcx.body_owners() {\n+                 mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n+             });\n         // Avoid overwhelming user with errors if type checking failed.\n         // I'm not sure how helpful this is, to be honest, but it avoids\n         // a"}, {"sha": "1fc96dbf451972eae1b440dcdea88dfe9a0df029", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 74, "deletions": 9, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -21,22 +21,32 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                      ast_block: &'tcx hir::Block,\n                      source_info: SourceInfo)\n                      -> BlockAnd<()> {\n-        let Block { region_scope, opt_destruction_scope, span, stmts, expr, targeted_by_break } =\n+        let Block {\n+            region_scope,\n+            opt_destruction_scope,\n+            span,\n+            stmts,\n+            expr,\n+            targeted_by_break,\n+            safety_mode\n+        } =\n             self.hir.mirror(ast_block);\n         self.in_opt_scope(opt_destruction_scope.map(|de|(de, source_info)), block, move |this| {\n-            this.in_scope((region_scope, source_info), block, move |this| {\n+            this.in_scope((region_scope, source_info), LintLevel::Inherited, block, move |this| {\n                 if targeted_by_break {\n                     // This is a `break`-able block (currently only `catch { ... }`)\n                     let exit_block = this.cfg.start_new_block();\n                     let block_exit = this.in_breakable_scope(\n                         None, exit_block, destination.clone(), |this| {\n-                            this.ast_block_stmts(destination, block, span, stmts, expr)\n+                            this.ast_block_stmts(destination, block, span, stmts, expr,\n+                                                 safety_mode)\n                         });\n                     this.cfg.terminate(unpack!(block_exit), source_info,\n                                        TerminatorKind::Goto { target: exit_block });\n                     exit_block.unit()\n                 } else {\n-                    this.ast_block_stmts(destination, block, span, stmts, expr)\n+                    this.ast_block_stmts(destination, block, span, stmts, expr,\n+                                         safety_mode)\n                 }\n             })\n         })\n@@ -47,7 +57,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                        mut block: BasicBlock,\n                        span: Span,\n                        stmts: Vec<StmtRef<'tcx>>,\n-                       expr: Option<ExprRef<'tcx>>)\n+                       expr: Option<ExprRef<'tcx>>,\n+                       safety_mode: BlockSafety)\n                        -> BlockAnd<()> {\n         let this = self;\n \n@@ -69,34 +80,46 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // First we build all the statements in the block.\n         let mut let_scope_stack = Vec::with_capacity(8);\n         let outer_visibility_scope = this.visibility_scope;\n+        let outer_push_unsafe_count = this.push_unsafe_count;\n+        let outer_unpushed_unsafe = this.unpushed_unsafe;\n+        this.update_visibility_scope_for_safety_mode(span, safety_mode);\n+\n         let source_info = this.source_info(span);\n         for stmt in stmts {\n             let Stmt { kind, opt_destruction_scope } = this.hir.mirror(stmt);\n             match kind {\n                 StmtKind::Expr { scope, expr } => {\n                     unpack!(block = this.in_opt_scope(\n                         opt_destruction_scope.map(|de|(de, source_info)), block, |this| {\n-                            this.in_scope((scope, source_info), block, |this| {\n+                            let si = (scope, source_info);\n+                            this.in_scope(si, LintLevel::Inherited, block, |this| {\n                                 let expr = this.hir.mirror(expr);\n                                 this.stmt_expr(block, expr)\n                             })\n                         }));\n                 }\n-                StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n+                StmtKind::Let {\n+                    remainder_scope,\n+                    init_scope,\n+                    pattern,\n+                    initializer,\n+                    lint_level\n+                } => {\n                     // Enter the remainder scope, i.e. the bindings' destruction scope.\n                     this.push_scope((remainder_scope, source_info));\n                     let_scope_stack.push(remainder_scope);\n \n                     // Declare the bindings, which may create a visibility scope.\n                     let remainder_span = remainder_scope.span(this.hir.tcx(),\n                                                               &this.hir.region_scope_tree);\n-                    let scope = this.declare_bindings(None, remainder_span, &pattern);\n+                    let scope = this.declare_bindings(None, remainder_span, lint_level, &pattern);\n \n                     // Evaluate the initializer, if present.\n                     if let Some(init) = initializer {\n                         unpack!(block = this.in_opt_scope(\n                             opt_destruction_scope.map(|de|(de, source_info)), block, move |this| {\n-                                this.in_scope((init_scope, source_info), block, move |this| {\n+                                let scope = (init_scope, source_info);\n+                                this.in_scope(scope, lint_level, block, move |this| {\n                                     // FIXME #30046                             ^~~~\n                                     this.expr_into_pattern(block, pattern, init)\n                                 })\n@@ -129,6 +152,48 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n         // Restore the original visibility scope.\n         this.visibility_scope = outer_visibility_scope;\n+        this.push_unsafe_count = outer_push_unsafe_count;\n+        this.unpushed_unsafe = outer_unpushed_unsafe;\n         block.unit()\n     }\n+\n+    /// If we are changing the safety mode, create a new visibility scope\n+    fn update_visibility_scope_for_safety_mode(&mut self,\n+                                               span: Span,\n+                                               safety_mode: BlockSafety)\n+    {\n+        debug!(\"update_visibility_scope_for({:?}, {:?})\", span, safety_mode);\n+        let new_unsafety = match safety_mode {\n+            BlockSafety::Safe => None,\n+            BlockSafety::ExplicitUnsafe(node_id) => {\n+                assert_eq!(self.push_unsafe_count, 0);\n+                match self.unpushed_unsafe {\n+                    Safety::Safe => {}\n+                    _ => return\n+                }\n+                self.unpushed_unsafe = Safety::ExplicitUnsafe(node_id);\n+                Some(Safety::ExplicitUnsafe(node_id))\n+            }\n+            BlockSafety::PushUnsafe => {\n+                self.push_unsafe_count += 1;\n+                Some(Safety::BuiltinUnsafe)\n+            }\n+            BlockSafety::PopUnsafe => {\n+                self.push_unsafe_count =\n+                    self.push_unsafe_count.checked_sub(1).unwrap_or_else(|| {\n+                        span_bug!(span, \"unsafe count underflow\")\n+                    });\n+                if self.push_unsafe_count == 0 {\n+                    Some(self.unpushed_unsafe)\n+                } else {\n+                    None\n+                }\n+            }\n+        };\n+\n+        if let Some(unsafety) = new_unsafety {\n+            self.visibility_scope = self.new_visibility_scope(\n+                span, LintLevel::Inherited, Some(unsafety));\n+        }\n+    }\n }"}, {"sha": "a57f1b95494855ca36d814b7ae7b2b3e1caec134", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -29,7 +29,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let Expr { ty, temp_lifetime: _, span, kind }\n             = expr;\n         match kind {\n-            ExprKind::Scope { region_scope: _, value } =>\n+            ExprKind::Scope { region_scope: _, lint_level: _, value } =>\n                 this.as_constant(value),\n             ExprKind::Literal { literal } =>\n                 Constant { span: span, ty: ty, literal: literal },"}, {"sha": "69d0dd992281ed86e3aec2ba18db9ef71c1a5de1", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -39,8 +39,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n         match expr.kind {\n-            ExprKind::Scope { region_scope, value } => {\n-                this.in_scope((region_scope, source_info), block, |this| {\n+            ExprKind::Scope { region_scope, lint_level, value } => {\n+                this.in_scope((region_scope, source_info), lint_level, block, |this| {\n                     this.as_lvalue(block, value)\n                 })\n             }"}, {"sha": "ea6e4342098bc6061ab78cd52c219b5af14ef3f7", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -55,10 +55,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"expr_as_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n-        if let ExprKind::Scope { region_scope, value } = expr.kind {\n+        if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n             let source_info = this.source_info(expr.span);\n             let region_scope = (region_scope, source_info);\n-            return this.in_scope(region_scope, block, |this| {\n+            return this.in_scope(region_scope, lint_level, block, |this| {\n                 this.as_operand(block, scope, value)\n             });\n         }"}, {"sha": "d17f00b489c318bb4a6bd3c99510983e374d0217", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -58,9 +58,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let source_info = this.source_info(expr_span);\n \n         match expr.kind {\n-            ExprKind::Scope { region_scope, value } => {\n+            ExprKind::Scope { region_scope, lint_level, value } => {\n                 let region_scope = (region_scope, source_info);\n-                this.in_scope(region_scope, block, |this| this.as_rvalue(block, scope, value))\n+                this.in_scope(region_scope, lint_level, block,\n+                              |this| this.as_rvalue(block, scope, value))\n             }\n             ExprKind::Repeat { value, count } => {\n                 let value_operand = unpack!(block = this.as_operand(block, scope, value));"}, {"sha": "ba422a8183160fd3d5eacd3e8526c5354232d24b", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -41,8 +41,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n-        if let ExprKind::Scope { region_scope, value } = expr.kind {\n-            return this.in_scope((region_scope, source_info), block, |this| {\n+        if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n+            return this.in_scope((region_scope, source_info), lint_level, block, |this| {\n                 this.as_temp(block, temp_lifetime, value)\n             });\n         }"}, {"sha": "cdbcb43370fe0e6eb91f0d5829e53bfaa201bbc7", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -38,9 +38,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let source_info = this.source_info(expr_span);\n \n         match expr.kind {\n-            ExprKind::Scope { region_scope, value } => {\n+            ExprKind::Scope { region_scope, lint_level, value } => {\n                 let region_scope = (region_scope, source_info);\n-                this.in_scope(region_scope, block, |this| this.into(destination, block, value))\n+                this.in_scope(region_scope, lint_level, block,\n+                              |this| this.into(destination, block, value))\n             }\n             ExprKind::Block { body: ast_block } => {\n                 this.ast_block(destination, block, ast_block, source_info)\n@@ -227,9 +228,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let val = args.next().expect(\"1 argument to `move_val_init`\");\n                     assert!(args.next().is_none(), \">2 arguments to `move_val_init`\");\n \n-                    let topmost_scope = this.topmost_scope();\n-                    let ptr = unpack!(block = this.as_temp(block, Some(topmost_scope), ptr));\n-                    this.into(&Lvalue::Local(ptr).deref(), block, val)\n+                    let ptr = this.hir.mirror(ptr);\n+                    let ptr_ty = ptr.ty;\n+                    // Create an *internal* temp for the pointer, so that unsafety\n+                    // checking won't complain about the raw pointer assignment.\n+                    let ptr_temp = this.local_decls.push(LocalDecl {\n+                        mutability: Mutability::Mut,\n+                        ty: ptr_ty,\n+                        name: None,\n+                        source_info,\n+                        lexical_scope: source_info.scope,\n+                        internal: true,\n+                        is_user_variable: false\n+                    });\n+                    let ptr_temp = Lvalue::Local(ptr_temp);\n+                    let block = unpack!(this.into(&ptr_temp, block, ptr));\n+                    this.into(&ptr_temp.deref(), block, val)\n                 } else {\n                     let args: Vec<_> =\n                         args.into_iter()"}, {"sha": "3cfb0ff4010da753d3ad7fc32828eb258437ef2a", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -22,9 +22,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // Handle a number of expressions that don't need a destination at all. This\n         // avoids needing a mountain of temporary `()` variables.\n         match expr.kind {\n-            ExprKind::Scope { region_scope, value } => {\n+            ExprKind::Scope { region_scope, lint_level, value } => {\n                 let value = this.hir.mirror(value);\n-                this.in_scope((region_scope, source_info), block, |this| {\n+                this.in_scope((region_scope, source_info), lint_level, block, |this| {\n                     this.stmt_expr(block, value)\n                 })\n             }"}, {"sha": "f04dede6e4005d55271442a332a63be99522dba7", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -46,8 +46,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Get the arm bodies and their scopes, while declaring bindings.\n         let arm_bodies: Vec<_> = arms.iter().map(|arm| {\n+            // BUG: use arm lint level\n             let body = self.hir.mirror(arm.body.clone());\n-            let scope = self.declare_bindings(None, body.span, &arm.patterns[0]);\n+            let scope = self.declare_bindings(None, body.span,\n+                                              LintLevel::Inherited,\n+                                              &arm.patterns[0]);\n             (body, scope.unwrap_or(self.visibility_scope))\n         }).collect();\n \n@@ -171,18 +174,33 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn declare_bindings(&mut self,\n                             mut var_scope: Option<VisibilityScope>,\n                             scope_span: Span,\n+                            lint_level: LintLevel,\n                             pattern: &Pattern<'tcx>)\n                             -> Option<VisibilityScope> {\n+        assert!(!(var_scope.is_some() && lint_level.is_explicit()),\n+               \"can't have both a var and a lint scope at the same time\");\n         self.visit_bindings(pattern, &mut |this, mutability, name, var, span, ty| {\n             if var_scope.is_none() {\n-                var_scope = Some(this.new_visibility_scope(scope_span));\n+                var_scope = Some(this.new_visibility_scope(scope_span,\n+                                                           LintLevel::Inherited,\n+                                                           None));\n+                // If we have lints, create a new visibility scope\n+                // that marks the lints for the locals.\n+                if lint_level.is_explicit() {\n+                    this.visibility_scope =\n+                        this.new_visibility_scope(scope_span, lint_level, None);\n+                }\n             }\n             let source_info = SourceInfo {\n                 span,\n                 scope: var_scope.unwrap()\n             };\n             this.declare_binding(source_info, mutability, name, var, ty);\n         });\n+        // Pop any scope we created for the locals.\n+        if let Some(var_scope) = var_scope {\n+            self.visibility_scope = var_scope;\n+        }\n         var_scope\n     }\n \n@@ -712,6 +730,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ty: var_ty.clone(),\n             name: Some(name),\n             source_info,\n+            lexical_scope: self.visibility_scope,\n             internal: false,\n             is_user_variable: true,\n         });"}, {"sha": "68ef646184c2c3a577624bece4aca793c8ef13d3", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 43, "deletions": 12, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -11,6 +11,7 @@\n \n use build;\n use hair::cx::Cx;\n+use hair::LintLevel;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n@@ -71,14 +72,14 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             // is a constant \"initializer\" expression.\n             match expr.node {\n                 hir::ExprClosure(_, _, body, _, _) => body,\n-                _ => hir::BodyId { node_id: expr.id }\n+                _ => hir::BodyId { node_id: expr.id },\n             }\n         }\n         hir::map::NodeVariant(variant) =>\n             return create_constructor_shim(tcx, id, &variant.node.data),\n         hir::map::NodeStructCtor(ctor) =>\n             return create_constructor_shim(tcx, id, ctor),\n-        _ => unsupported()\n+        _ => unsupported(),\n     };\n \n     let src = MirSource::from_node(tcx, id);\n@@ -108,6 +109,12 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                 _ => None,\n             };\n \n+            // FIXME: safety in closures\n+            let safety = match fn_sig.unsafety {\n+                hir::Unsafety::Normal => Safety::Safe,\n+                hir::Unsafety::Unsafe => Safety::FnUnsafe,\n+            };\n+\n             let body = tcx.hir.body(body_id);\n             let explicit_arguments =\n                 body.arguments\n@@ -126,7 +133,8 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                 (None, fn_sig.output())\n             };\n \n-            build::construct_fn(cx, id, arguments, abi, return_ty, yield_ty, body)\n+            build::construct_fn(cx, id, arguments, safety, abi,\n+                                return_ty, yield_ty, body)\n         } else {\n             build::construct_const(cx, body_id)\n         };\n@@ -270,13 +278,21 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// see the `scope` module for more details\n     scopes: Vec<scope::Scope<'tcx>>,\n \n+    /// The current unsafe block in scope, even if it is hidden by\n+    /// a PushUnsafeBlock\n+    unpushed_unsafe: Safety,\n+\n+    /// The number of `push_unsafe_block` levels in scope\n+    push_unsafe_count: usize,\n+\n     /// the current set of breakables; see the `scope` module for more\n     /// details\n     breakable_scopes: Vec<scope::BreakableScope<'tcx>>,\n \n     /// the vector of all scopes that we have created thus far;\n     /// we track this for debuginfo later\n     visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n+    visibility_scope_info: IndexVec<VisibilityScope, VisibilityScopeInfo>,\n     visibility_scope: VisibilityScope,\n \n     /// Maps node ids of variable bindings to the `Local`s created for them.\n@@ -358,6 +374,7 @@ macro_rules! unpack {\n fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    fn_id: ast::NodeId,\n                                    arguments: A,\n+                                   safety: Safety,\n                                    abi: Abi,\n                                    return_ty: Ty<'gcx>,\n                                    yield_ty: Option<Ty<'gcx>>,\n@@ -372,14 +389,17 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let mut builder = Builder::new(hir.clone(),\n         span,\n         arguments.len(),\n+        safety,\n         return_ty);\n \n     let call_site_scope = region::Scope::CallSite(body.value.hir_id.local_id);\n     let arg_scope = region::Scope::Arguments(body.value.hir_id.local_id);\n     let mut block = START_BLOCK;\n     let source_info = builder.source_info(span);\n-    unpack!(block = builder.in_scope((call_site_scope, source_info), block, |builder| {\n-        unpack!(block = builder.in_scope((arg_scope, source_info), block, |builder| {\n+    let call_site_s = (call_site_scope, source_info);\n+    unpack!(block = builder.in_scope(call_site_s, LintLevel::Inherited, block, |builder| {\n+        let arg_scope_s = (arg_scope, source_info);\n+        unpack!(block = builder.in_scope(arg_scope_s, LintLevel::Inherited, block, |builder| {\n             builder.args_and_body(block, &arguments, arg_scope, &body.value)\n         }));\n         // Attribute epilogue to function's closing brace\n@@ -440,7 +460,7 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let ty = hir.tables().expr_ty_adjusted(ast_expr);\n     let owner_id = tcx.hir.body_owner(body_id);\n     let span = tcx.hir.span(owner_id);\n-    let mut builder = Builder::new(hir.clone(), span, 0, ty);\n+    let mut builder = Builder::new(hir.clone(), span, 0, Safety::Safe, ty);\n \n     let mut block = START_BLOCK;\n     let expr = builder.hir.mirror(ast_expr);\n@@ -456,11 +476,12 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n }\n \n fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n-                                       body_id: hir::BodyId)\n-                                       -> Mir<'tcx> {\n-    let span = hir.tcx().hir.span(hir.tcx().hir.body_owner(body_id));\n+                                   body_id: hir::BodyId)\n+                                   -> Mir<'tcx> {\n+    let owner_id = hir.tcx().hir.body_owner(body_id);\n+    let span = hir.tcx().hir.span(owner_id);\n     let ty = hir.tcx().types.err;\n-    let mut builder = Builder::new(hir, span, 0, ty);\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n     builder.finish(vec![], ty, None)\n@@ -470,8 +491,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn new(hir: Cx<'a, 'gcx, 'tcx>,\n            span: Span,\n            arg_count: usize,\n+           safety: Safety,\n            return_ty: Ty<'tcx>)\n            -> Builder<'a, 'gcx, 'tcx> {\n+        let lint_level = LintLevel::Explicit(hir.root_lint_level);\n         let mut builder = Builder {\n             hir,\n             cfg: CFG { basic_blocks: IndexVec::new() },\n@@ -480,6 +503,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             scopes: vec![],\n             visibility_scopes: IndexVec::new(),\n             visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n+            visibility_scope_info: IndexVec::new(),\n+            push_unsafe_count: 0,\n+            unpushed_unsafe: safety,\n             breakable_scopes: vec![],\n             local_decls: IndexVec::from_elem_n(LocalDecl::new_return_pointer(return_ty,\n                                                                              span), 1),\n@@ -490,7 +516,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n-        assert_eq!(builder.new_visibility_scope(span), ARGUMENT_VISIBILITY_SCOPE);\n+        assert_eq!(\n+            builder.new_visibility_scope(span, lint_level, Some(safety)),\n+            ARGUMENT_VISIBILITY_SCOPE);\n         builder.visibility_scopes[ARGUMENT_VISIBILITY_SCOPE].parent_scope = None;\n \n         builder\n@@ -509,6 +537,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         Mir::new(self.cfg.basic_blocks,\n                  self.visibility_scopes,\n+                 ClearOnDecode::Set(self.visibility_scope_info),\n                  IndexVec::new(),\n                  return_ty,\n                  yield_ty,\n@@ -543,6 +572,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     scope: ARGUMENT_VISIBILITY_SCOPE,\n                     span: pattern.map_or(self.fn_span, |pat| pat.span)\n                 },\n+                lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n                 name,\n                 internal: false,\n                 is_user_variable: false,\n@@ -557,7 +587,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             if let Some(pattern) = pattern {\n                 let pattern = self.hir.pattern_from_hir(pattern);\n-                scope = self.declare_bindings(scope, ast_body.span, &pattern);\n+                scope = self.declare_bindings(scope, ast_body.span,\n+                                              LintLevel::Inherited, &pattern);\n                 unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n             }\n "}, {"sha": "20d3efdfffc3d5af66181aba6fe40ac71073911d", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -88,8 +88,10 @@ should go to.\n */\n \n use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n+use hair::LintLevel;\n use rustc::middle::region;\n use rustc::ty::{Ty, TyCtxt};\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use syntax_pos::{Span};\n@@ -304,15 +306,38 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// to build its contents, popping the scope afterwards.\n     pub fn in_scope<F, R>(&mut self,\n                           region_scope: (region::Scope, SourceInfo),\n+                          lint_level: LintLevel,\n                           mut block: BasicBlock,\n                           f: F)\n                           -> BlockAnd<R>\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(region_scope={:?}, block={:?})\", region_scope, block);\n+        let visibility_scope = self.visibility_scope;\n+        let tcx = self.hir.tcx();\n+        if let LintLevel::Explicit(node_id) = lint_level {\n+            let same_lint_scopes = tcx.dep_graph.with_ignore(|| {\n+                let sets = tcx.lint_levels(LOCAL_CRATE);\n+                let parent_hir_id =\n+                    tcx.hir.definitions().node_to_hir_id(\n+                        self.visibility_scope_info[visibility_scope].lint_root\n+                            );\n+                let current_hir_id =\n+                    tcx.hir.definitions().node_to_hir_id(node_id);\n+                sets.lint_level_set(parent_hir_id) ==\n+                    sets.lint_level_set(current_hir_id)\n+            });\n+\n+            if !same_lint_scopes {\n+                self.visibility_scope =\n+                    self.new_visibility_scope(region_scope.1.span, lint_level,\n+                                              None);\n+            }\n+        }\n         self.push_scope(region_scope);\n         let rv = unpack!(block = f(self));\n         unpack!(block = self.pop_scope(region_scope, block));\n+        self.visibility_scope = visibility_scope;\n         debug!(\"in_scope: exiting region_scope={:?} block={:?}\", region_scope, block);\n         block.and(rv)\n     }\n@@ -474,13 +499,29 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     /// Creates a new visibility scope, nested in the current one.\n-    pub fn new_visibility_scope(&mut self, span: Span) -> VisibilityScope {\n+    pub fn new_visibility_scope(&mut self,\n+                                span: Span,\n+                                lint_level: LintLevel,\n+                                safety: Option<Safety>) -> VisibilityScope {\n         let parent = self.visibility_scope;\n-        let scope = VisibilityScope::new(self.visibility_scopes.len());\n-        self.visibility_scopes.push(VisibilityScopeData {\n+        debug!(\"new_visibility_scope({:?}, {:?}, {:?}) - parent({:?})={:?}\",\n+               span, lint_level, safety,\n+               parent, self.visibility_scope_info.get(parent));\n+        let scope = self.visibility_scopes.push(VisibilityScopeData {\n             span,\n             parent_scope: Some(parent),\n         });\n+        let scope_info = VisibilityScopeInfo {\n+            lint_root: if let LintLevel::Explicit(lint_root) = lint_level {\n+                lint_root\n+            } else {\n+                self.visibility_scope_info[parent].lint_root\n+            },\n+            safety: safety.unwrap_or_else(|| {\n+                self.visibility_scope_info[parent].safety\n+            })\n+        };\n+        self.visibility_scope_info.push(scope_info);\n         scope\n     }\n "}, {"sha": "2c4afb0aa0e045f26e7c2883e032bee685ccf376", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -195,6 +195,40 @@ instead of using a `const fn`, or refactoring the code to a functional style to\n avoid mutation if possible.\n \"##,\n \n+E0133: r##\"\n+Unsafe code was used outside of an unsafe function or block.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0133\n+unsafe fn f() { return; } // This is the unsafe code\n+\n+fn main() {\n+    f(); // error: call to unsafe function requires unsafe function or block\n+}\n+```\n+\n+Using unsafe functionality is potentially dangerous and disallowed by safety\n+checks. Examples:\n+\n+* Dereferencing raw pointers\n+* Calling functions via FFI\n+* Calling functions marked unsafe\n+\n+These safety checks can be relaxed for a section of the code by wrapping the\n+unsafe instructions with an `unsafe` block. For instance:\n+\n+```\n+unsafe fn f() { return; }\n+\n+fn main() {\n+    unsafe { f(); } // ok!\n+}\n+```\n+\n+See also https://doc.rust-lang.org/book/first-edition/unsafe.html\n+\"##,\n+\n E0381: r##\"\n It is not allowed to use or capture an uninitialized variable. For example:\n "}, {"sha": "a8172a60174fa2a7c9b2c8fd20614e79161a1b08", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -30,6 +30,16 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n             span: self.span,\n             stmts,\n             expr: self.expr.to_ref(),\n+            safety_mode: match self.rules {\n+                hir::BlockCheckMode::DefaultBlock =>\n+                    BlockSafety::Safe,\n+                hir::BlockCheckMode::UnsafeBlock(..) =>\n+                    BlockSafety::ExplicitUnsafe(self.id),\n+                hir::BlockCheckMode::PushUnsafeBlock(..) =>\n+                    BlockSafety::PushUnsafe,\n+                hir::BlockCheckMode::PopUnsafeBlock(..) =>\n+                    BlockSafety::PopUnsafe\n+            },\n         }\n     }\n }\n@@ -71,6 +81,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 init_scope: region::Scope::Node(hir_id.local_id),\n                                 pattern,\n                                 initializer: local.init.to_ref(),\n+                                lint_level: cx.lint_level_of(local.id),\n                             },\n                             opt_destruction_scope: opt_dxn_ext,\n                         })));"}, {"sha": "f5a53e2aa8eed92a11cff1df9e2298533160f4fa", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -48,22 +48,24 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             kind: ExprKind::Scope {\n                 region_scope: expr_scope,\n                 value: expr.to_ref(),\n+                lint_level: cx.lint_level_of(self.id),\n             },\n         };\n \n         // Finally, create a destruction scope, if any.\n         if let Some(region_scope) =\n-                cx.region_scope_tree.opt_destruction_scope(self.hir_id.local_id) {\n-            expr = Expr {\n-                temp_lifetime,\n-                ty: expr.ty,\n-                span: self.span,\n-                kind: ExprKind::Scope {\n-                    region_scope,\n-                    value: expr.to_ref(),\n-                },\n-            };\n-        }\n+            cx.region_scope_tree.opt_destruction_scope(self.hir_id.local_id) {\n+                expr = Expr {\n+                    temp_lifetime,\n+                    ty: expr.ty,\n+                    span: self.span,\n+                    kind: ExprKind::Scope {\n+                        region_scope,\n+                        value: expr.to_ref(),\n+                        lint_level: LintLevel::Inherited,\n+                    },\n+                };\n+            }\n \n         // OK, all done!\n         expr\n@@ -619,6 +621,8 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm)\n         patterns: arm.pats.iter().map(|p| cx.pattern_from_hir(p)).collect(),\n         guard: arm.guard.to_ref(),\n         body: arm.body.to_ref(),\n+        // BUG: fix this\n+        lint_level: LintLevel::Inherited,\n     }\n }\n "}, {"sha": "4434df0ac3e9bfaa36483d555eea4f78a599439f", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -20,13 +20,14 @@ use rustc::mir::transform::MirSource;\n use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n use rustc_const_eval::ConstContext;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::region;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n+use syntax::ast;\n use syntax::symbol::Symbol;\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n@@ -37,6 +38,7 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n \n+    pub root_lint_level: ast::NodeId,\n     pub param_env: ty::ParamEnv<'gcx>,\n \n     /// Identity `Substs` for use with const-evaluation.\n@@ -57,7 +59,8 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, src: MirSource) -> Cx<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+               src: MirSource) -> Cx<'a, 'gcx, 'tcx> {\n         let constness = match src {\n             MirSource::Const(_) |\n             MirSource::Static(..) => hir::Constness::Const,\n@@ -87,9 +90,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Constants and const fn's always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;\n \n+        let lint_level = lint_level_for_hir_id(tcx, src_id);\n         Cx {\n             tcx,\n             infcx,\n+            root_lint_level: lint_level,\n             param_env: tcx.param_env(src_def_id),\n             identity_substs: Substs::identity_for_item(tcx.global_tcx(), src_def_id),\n             region_scope_tree: tcx.region_scope_tree(src_def_id),\n@@ -99,6 +104,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             check_overflow,\n         }\n     }\n+\n }\n \n impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n@@ -229,6 +235,19 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         ty.needs_drop(self.tcx.global_tcx(), param_env)\n     }\n \n+    fn lint_level_of(&self, node_id: ast::NodeId) -> LintLevel {\n+        let hir_id = self.tcx.hir.definitions().node_to_hir_id(node_id);\n+        let has_lint_level = self.tcx.dep_graph.with_ignore(|| {\n+            self.tcx.lint_levels(LOCAL_CRATE).lint_level_set(hir_id).is_some()\n+        });\n+\n+        if has_lint_level {\n+            LintLevel::Explicit(node_id)\n+        } else {\n+            LintLevel::Inherited\n+        }\n+    }\n+\n     pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.tcx\n     }\n@@ -242,6 +261,31 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n }\n \n+fn lint_level_for_hir_id(tcx: TyCtxt, mut id: ast::NodeId) -> ast::NodeId {\n+    // Right now we insert a `with_ignore` node in the dep graph here to\n+    // ignore the fact that `lint_levels` below depends on the entire crate.\n+    // For now this'll prevent false positives of recompiling too much when\n+    // anything changes.\n+    //\n+    // Once red/green incremental compilation lands we should be able to\n+    // remove this because while the crate changes often the lint level map\n+    // will change rarely.\n+    tcx.dep_graph.with_ignore(|| {\n+        let sets = tcx.lint_levels(LOCAL_CRATE);\n+        loop {\n+            let hir_id = tcx.hir.definitions().node_to_hir_id(id);\n+            if sets.lint_level_set(hir_id).is_some() {\n+                return id\n+            }\n+            let next = tcx.hir.get_parent_node(id);\n+            if next == id {\n+                bug!(\"lint traversal reached the root of the crate\");\n+            }\n+            id = next;\n+        }\n+    })\n+}\n+\n mod block;\n mod expr;\n mod to_ref;"}, {"sha": "09a31f9ab8fa55d1c753d34ecf9bb429f0cc7f64", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -29,6 +29,21 @@ pub mod cx;\n \n pub use rustc_const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPattern};\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum LintLevel {\n+    Inherited,\n+    Explicit(ast::NodeId)\n+}\n+\n+impl LintLevel {\n+    pub fn is_explicit(self) -> bool {\n+        match self {\n+            LintLevel::Inherited => false,\n+            LintLevel::Explicit(_) => true\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub struct Block<'tcx> {\n     pub targeted_by_break: bool,\n@@ -37,6 +52,15 @@ pub struct Block<'tcx> {\n     pub span: Span,\n     pub stmts: Vec<StmtRef<'tcx>>,\n     pub expr: Option<ExprRef<'tcx>>,\n+    pub safety_mode: BlockSafety,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum BlockSafety {\n+    Safe,\n+    ExplicitUnsafe(ast::NodeId),\n+    PushUnsafe,\n+    PopUnsafe\n }\n \n #[derive(Clone, Debug)]\n@@ -73,7 +97,10 @@ pub enum StmtKind<'tcx> {\n         pattern: Pattern<'tcx>,\n \n         /// let pat = <INIT> ...\n-        initializer: Option<ExprRef<'tcx>>\n+        initializer: Option<ExprRef<'tcx>>,\n+\n+        /// the lint level for this let-statement\n+        lint_level: LintLevel,\n     },\n }\n \n@@ -111,6 +138,7 @@ pub struct Expr<'tcx> {\n pub enum ExprKind<'tcx> {\n     Scope {\n         region_scope: region::Scope,\n+        lint_level: LintLevel,\n         value: ExprRef<'tcx>,\n     },\n     Box {\n@@ -275,6 +303,7 @@ pub struct Arm<'tcx> {\n     pub patterns: Vec<Pattern<'tcx>>,\n     pub guard: Option<ExprRef<'tcx>>,\n     pub body: ExprRef<'tcx>,\n+    pub lint_level: LintLevel,\n }\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "a3a986918a4fd6395d06b2849d414335de364002", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -140,6 +140,7 @@ fn temp_decl(mutability: Mutability, ty: Ty, span: Span) -> LocalDecl {\n     LocalDecl {\n         mutability, ty, name: None,\n         source_info: SourceInfo { scope: ARGUMENT_VISIBILITY_SCOPE, span },\n+        lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n         internal: false,\n         is_user_variable: false\n     }\n@@ -195,6 +196,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         IndexVec::from_elem_n(\n             VisibilityScopeData { span: span, parent_scope: None }, 1\n         ),\n+        ClearOnDecode::Clear,\n         IndexVec::new(),\n         sig.output(),\n         None,\n@@ -342,6 +344,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             IndexVec::from_elem_n(\n                 VisibilityScopeData { span: self.span, parent_scope: None }, 1\n             ),\n+            ClearOnDecode::Clear,\n             IndexVec::new(),\n             self.sig.output(),\n             None,\n@@ -804,6 +807,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         IndexVec::from_elem_n(\n             VisibilityScopeData { span: span, parent_scope: None }, 1\n         ),\n+        ClearOnDecode::Clear,\n         IndexVec::new(),\n         sig.output(),\n         None,\n@@ -876,6 +880,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         IndexVec::from_elem_n(\n             VisibilityScopeData { span: span, parent_scope: None }, 1\n         ),\n+        ClearOnDecode::Clear,\n         IndexVec::new(),\n         sig.output(),\n         None,"}, {"sha": "49ce36223994b56f53c8825da2773078532edd79", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -0,0 +1,387 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+\n+use rustc::ty::maps::Providers;\n+use rustc::ty::{self, TyCtxt};\n+use rustc::hir;\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::map::{DefPathData, Node};\n+use rustc::lint::builtin::{SAFE_EXTERN_STATICS, UNUSED_UNSAFE};\n+use rustc::mir::*;\n+use rustc::mir::visit::{LvalueContext, Visitor};\n+\n+use syntax::ast;\n+\n+use std::rc::Rc;\n+\n+\n+pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    visibility_scope_info: &'a IndexVec<VisibilityScope, VisibilityScopeInfo>,\n+    violations: Vec<UnsafetyViolation>,\n+    source_info: SourceInfo,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    used_unsafe: FxHashSet<ast::NodeId>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> UnsafetyChecker<'a, 'tcx> {\n+    fn new(mir: &'a Mir<'tcx>,\n+           visibility_scope_info: &'a IndexVec<VisibilityScope, VisibilityScopeInfo>,\n+           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+           param_env: ty::ParamEnv<'tcx>) -> Self {\n+        Self {\n+            mir,\n+            visibility_scope_info,\n+            violations: vec![],\n+            source_info: SourceInfo {\n+                span: mir.span,\n+                scope: ARGUMENT_VISIBILITY_SCOPE\n+            },\n+            tcx,\n+            param_env,\n+            used_unsafe: FxHashSet(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n+    fn visit_terminator(&mut self,\n+                        block: BasicBlock,\n+                        terminator: &Terminator<'tcx>,\n+                        location: Location)\n+    {\n+        self.source_info = terminator.source_info;\n+        match terminator.kind {\n+            TerminatorKind::Goto { .. } |\n+            TerminatorKind::SwitchInt { .. } |\n+            TerminatorKind::Drop { .. } |\n+            TerminatorKind::Yield { .. } |\n+            TerminatorKind::Assert { .. } |\n+            TerminatorKind::DropAndReplace { .. } |\n+            TerminatorKind::GeneratorDrop |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Return |\n+            TerminatorKind::Unreachable => {\n+                                // safe (at least as emitted during MIR construction)\n+            }\n+\n+            TerminatorKind::Call { ref func, .. } => {\n+                let func_ty = func.ty(self.mir, self.tcx);\n+                let sig = func_ty.fn_sig(self.tcx);\n+                if let hir::Unsafety::Unsafe = sig.unsafety() {\n+                    self.require_unsafe(\"call to unsafe function\")\n+                }\n+            }\n+        }\n+        self.super_terminator(block, terminator, location);\n+    }\n+\n+    fn visit_statement(&mut self,\n+                       block: BasicBlock,\n+                       statement: &Statement<'tcx>,\n+                       location: Location)\n+    {\n+        self.source_info = statement.source_info;\n+        match statement.kind {\n+            StatementKind::Assign(..) |\n+            StatementKind::SetDiscriminant { .. } |\n+            StatementKind::StorageLive(..) |\n+            StatementKind::StorageDead(..) |\n+            StatementKind::EndRegion(..) |\n+            StatementKind::Validate(..) |\n+            StatementKind::Nop => {\n+                // safe (at least as emitted during MIR construction)\n+            }\n+\n+            StatementKind::InlineAsm { .. } => {\n+                self.require_unsafe(\"use of inline assembly\")\n+            },\n+        }\n+        self.super_statement(block, statement, location);\n+    }\n+\n+    fn visit_rvalue(&mut self,\n+                    rvalue: &Rvalue<'tcx>,\n+                    location: Location)\n+    {\n+        if let &Rvalue::Aggregate(\n+            box AggregateKind::Closure(def_id, _),\n+            _\n+        ) = rvalue {\n+            let unsafety_violations = self.tcx.unsafety_violations(def_id);\n+            self.register_violations(&unsafety_violations);\n+        }\n+        self.super_rvalue(rvalue, location);\n+    }\n+\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n+        match lvalue {\n+            &Lvalue::Projection(box Projection {\n+                ref base, ref elem\n+            }) => {\n+                let old_source_info = self.source_info;\n+                if let &Lvalue::Local(local) = base {\n+                    if self.mir.local_decls[local].internal {\n+                        // Internal locals are used in the `move_val_init` desugaring.\n+                        // We want to check unsafety against the source info of the\n+                        // desugaring, rather than the source info of the RHS.\n+                        self.source_info = self.mir.local_decls[local].source_info;\n+                    }\n+                }\n+                let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                match base_ty.sty {\n+                    ty::TyRawPtr(..) => {\n+                        self.require_unsafe(\"dereference of raw pointer\")\n+                    }\n+                    ty::TyAdt(adt, _) if adt.is_union() => {\n+                        if context == LvalueContext::Store ||\n+                            context == LvalueContext::Drop\n+                        {\n+                            let elem_ty = match elem {\n+                                &ProjectionElem::Field(_, ty) => ty,\n+                                _ => span_bug!(\n+                                    self.source_info.span,\n+                                    \"non-field projection {:?} from union?\",\n+                                    lvalue)\n+                            };\n+                            if elem_ty.moves_by_default(self.tcx, self.param_env,\n+                                                        self.source_info.span) {\n+                                self.require_unsafe(\n+                                    \"assignment to non-`Copy` union field\")\n+                            } else {\n+                                // write to non-move union, safe\n+                            }\n+                        } else {\n+                            self.require_unsafe(\"access to union field\")\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+                self.source_info = old_source_info;\n+            }\n+            &Lvalue::Local(..) => {\n+                // locals are safe\n+            }\n+            &Lvalue::Static(box Static { def_id, ty: _ }) => {\n+                if self.is_static_mut(def_id) {\n+                    self.require_unsafe(\"use of mutable static\");\n+                } else if self.tcx.is_foreign_item(def_id) {\n+                    let source_info = self.source_info;\n+                    let lint_root =\n+                        self.visibility_scope_info[source_info.scope].lint_root;\n+                    self.register_violations(&[UnsafetyViolation {\n+                        source_info,\n+                        description: \"use of extern static\",\n+                        lint_node_id: Some(lint_root)\n+                    }]);\n+                }\n+            }\n+        }\n+        self.super_lvalue(lvalue, context, location);\n+    }\n+}\n+\n+impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n+    fn is_static_mut(&self, def_id: DefId) -> bool {\n+        if let Some(node) = self.tcx.hir.get_if_local(def_id) {\n+            match node {\n+                Node::NodeItem(&hir::Item {\n+                    node: hir::ItemStatic(_, hir::MutMutable, _), ..\n+                }) => true,\n+                Node::NodeForeignItem(&hir::ForeignItem {\n+                    node: hir::ForeignItemStatic(_, mutbl), ..\n+                }) => mutbl,\n+                _ => false\n+            }\n+        } else {\n+            match self.tcx.describe_def(def_id) {\n+                Some(Def::Static(_, mutbl)) => mutbl,\n+                _ => false\n+            }\n+        }\n+    }\n+    fn require_unsafe(&mut self,\n+                      description: &'static str)\n+    {\n+        let source_info = self.source_info;\n+        self.register_violations(&[UnsafetyViolation {\n+            source_info, description, lint_node_id: None\n+        }]);\n+    }\n+\n+    fn register_violations(&mut self, violations: &[UnsafetyViolation]) {\n+        match self.visibility_scope_info[self.source_info.scope].safety {\n+            Safety::Safe => {\n+                for violation in violations {\n+                    if !self.violations.contains(violation) {\n+                        self.violations.push(violation.clone())\n+                    }\n+                }\n+            }\n+            Safety::BuiltinUnsafe | Safety::FnUnsafe => {}\n+            Safety::ExplicitUnsafe(node_id) => {\n+                if !violations.is_empty() {\n+                    self.used_unsafe.insert(node_id);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub(crate) fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        unsafety_violations,\n+        ..*providers\n+    };\n+}\n+\n+struct UnusedUnsafeVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    used_unsafe: FxHashSet<ast::NodeId>\n+}\n+\n+impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) ->\n+        hir::intravisit::NestedVisitorMap<'this, 'tcx>\n+    {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_block(&mut self, block: &'tcx hir::Block) {\n+        hir::intravisit::walk_block(self, block);\n+\n+        if let hir::UnsafeBlock(hir::UserProvided) = block.rules {\n+            if !self.used_unsafe.contains(&block.id) {\n+                self.report_unused_unsafe(block);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> UnusedUnsafeVisitor<'a, 'tcx> {\n+    /// Return the NodeId for an enclosing scope that is also `unsafe`\n+    fn is_enclosed(&self, id: ast::NodeId) -> Option<(String, ast::NodeId)> {\n+        let parent_id = self.tcx.hir.get_parent_node(id);\n+        if parent_id != id {\n+            if self.used_unsafe.contains(&parent_id) {\n+                Some((\"block\".to_string(), parent_id))\n+            } else if let Some(hir::map::NodeItem(&hir::Item {\n+                node: hir::ItemFn(_, hir::Unsafety::Unsafe, _, _, _, _),\n+                ..\n+            })) = self.tcx.hir.find(parent_id) {\n+                Some((\"fn\".to_string(), parent_id))\n+            } else {\n+                self.is_enclosed(parent_id)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn report_unused_unsafe(&self, block: &'tcx hir::Block) {\n+        let mut db = self.tcx.struct_span_lint_node(UNUSED_UNSAFE,\n+                                                    block.id,\n+                                                    block.span,\n+                                                    \"unnecessary `unsafe` block\");\n+        db.span_label(block.span, \"unnecessary `unsafe` block\");\n+        if let Some((kind, id)) = self.is_enclosed(block.id) {\n+            db.span_note(self.tcx.hir.span(id),\n+                         &format!(\"because it's nested under this `unsafe` {}\", kind));\n+        }\n+        db.emit();\n+    }\n+}\n+\n+fn check_unused_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 def_id: DefId,\n+                                 used_unsafe: FxHashSet<ast::NodeId>)\n+{\n+    let body_id =\n+        tcx.hir.as_local_node_id(def_id).and_then(|node_id| {\n+            tcx.hir.maybe_body_owned_by(node_id)\n+        });\n+\n+    let body_id = match body_id {\n+        Some(body) => body,\n+        None => {\n+            debug!(\"check_unused_unsafe({:?}) - no body found\", def_id);\n+            return\n+        }\n+    };\n+    let body = tcx.hir.body(body_id);\n+    debug!(\"check_unused_unsafe({:?}, body={:?}, used_unsafe={:?})\",\n+           def_id, body, used_unsafe);\n+\n+    hir::intravisit::Visitor::visit_body(\n+        &mut UnusedUnsafeVisitor { tcx, used_unsafe },\n+        body);\n+}\n+\n+fn unsafety_violations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) ->\n+    Rc<[UnsafetyViolation]>\n+{\n+    debug!(\"unsafety_violations({:?})\", def_id);\n+\n+    // NB: this borrow is valid because all the consumers of\n+    // `mir_const` force this.\n+    let mir = &tcx.mir_const(def_id).borrow();\n+\n+    let visibility_scope_info = match mir.visibility_scope_info {\n+        ClearOnDecode::Set(ref data) => data,\n+        ClearOnDecode::Clear => {\n+            debug!(\"unsafety_violations: {:?} - remote, skipping\", def_id);\n+            return Rc::new([])\n+        }\n+    };\n+\n+    let param_env = tcx.param_env(def_id);\n+    let mut checker = UnsafetyChecker::new(\n+        mir, visibility_scope_info, tcx, param_env);\n+    checker.visit_mir(mir);\n+\n+    check_unused_unsafe(tcx, def_id, checker.used_unsafe);\n+    checker.violations.into()\n+}\n+\n+pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    debug!(\"check_unsafety({:?})\", def_id);\n+    match tcx.def_key(def_id).disambiguated_data.data {\n+        // closures are handled by their parent fn.\n+        DefPathData::ClosureExpr => return,\n+        _ => {}\n+    };\n+\n+    for &UnsafetyViolation {\n+        source_info, description, lint_node_id\n+    } in &*tcx.unsafety_violations(def_id) {\n+        // Report an error.\n+        if let Some(lint_node_id) = lint_node_id {\n+            tcx.lint_node(SAFE_EXTERN_STATICS,\n+                          lint_node_id,\n+                          source_info.span,\n+                          &format!(\"{} requires unsafe function or \\\n+                                    block (error E0133)\", description));\n+        } else {\n+            struct_span_err!(\n+                tcx.sess, source_info.span, E0133,\n+                \"{} requires unsafe function or block\", description)\n+                .span_label(source_info.span, description)\n+                .emit();\n+        }\n+    }\n+}"}, {"sha": "729fe46ef37ecc7704db57216b2c7d2d3e08e269", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -301,6 +301,7 @@ fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n         ty: ret_ty,\n         name: None,\n         source_info: source_info(mir),\n+        lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n         internal: false,\n         is_user_variable: false,\n     };\n@@ -559,6 +560,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n         ty: tcx.mk_nil(),\n         name: None,\n         source_info,\n+        lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n         internal: false,\n         is_user_variable: false,\n     };\n@@ -574,6 +576,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n         }),\n         name: None,\n         source_info,\n+        lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n         internal: false,\n         is_user_variable: false,\n     };"}, {"sha": "7245b2daa126081b57cd0329e55e3ec754ed9de6", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -26,6 +26,7 @@ use transform;\n \n pub mod add_validation;\n pub mod clean_end_regions;\n+pub mod check_unsafety;\n pub mod simplify_branches;\n pub mod simplify;\n pub mod erase_regions;\n@@ -46,6 +47,7 @@ pub mod nll;\n \n pub(crate) fn provide(providers: &mut Providers) {\n     self::qualify_consts::provide(providers);\n+    self::check_unsafety::provide(providers);\n     *providers = Providers {\n         mir_keys,\n         mir_const,\n@@ -116,6 +118,7 @@ fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         // directly need the result or `mir_const_qualif`, so we can just force it.\n         ty::queries::mir_const_qualif::force(tcx, DUMMY_SP, def_id);\n     }\n+    ty::queries::unsafety_violations::force(tcx, DUMMY_SP, def_id);\n \n     let mut mir = tcx.mir_const(def_id).steal();\n     transform::run_suite(tcx, source, MIR_VALIDATED, &mut mir);"}, {"sha": "339ea8a414b1e982da421159723a48c6463482ee", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -380,10 +380,10 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n         let mut promoter = Promoter {\n             promoted: Mir::new(\n                 IndexVec::new(),\n-                Some(VisibilityScopeData {\n-                    span,\n-                    parent_scope: None\n-                }).into_iter().collect(),\n+                // FIXME: maybe try to filter this to avoid blowing up\n+                // memory usage?\n+                mir.visibility_scopes.clone(),\n+                mir.visibility_scope_info.clone(),\n                 IndexVec::new(),\n                 ty,\n                 None,"}, {"sha": "6fe49644fe81ece9ddeedc181c1d226e397bebfd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -2236,7 +2236,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                adjusted_ty,\n                index_ty);\n \n-\n         // First, try built-in indexing.\n         match (adjusted_ty.builtin_index(), &index_ty.sty) {\n             (Some(ty), &ty::TyUint(ast::UintTy::Us)) | (Some(ty), &ty::TyInfer(ty::IntVar(_))) => {"}, {"sha": "9a39ff6206bfb5b6c0f3a6ef9505bcca29745a09", "filename": "src/test/compile-fail/borrowck/borrowck-move-from-unsafe-ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-from-unsafe-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-from-unsafe-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-from-unsafe-ptr.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n \n-fn foo(x: *const Box<isize>) -> Box<isize> {\n-    let y = *x; //~ ERROR dereference of raw pointer requires unsafe function or block\n+unsafe fn foo(x: *const Box<isize>) -> Box<isize> {\n+    let y = *x; //~ ERROR cannot move out of dereference of raw pointer\n     return y;\n }\n "}, {"sha": "90ccc589b4ea7378667a788541a1285349209a00", "filename": "src/test/compile-fail/issue-43733.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -9,11 +9,13 @@\n // except according to those terms.\n \n #![feature(const_fn)]\n+#![feature(thread_local)]\n #![feature(cfg_target_thread_local, thread_local_internals)]\n \n type Foo = std::cell::RefCell<String>;\n \n #[cfg(target_thread_local)]\n+#[thread_local]\n static __KEY: std::thread::__FastLocalKeyInner<Foo> =\n     std::thread::__FastLocalKeyInner::new();\n \n@@ -25,7 +27,7 @@ fn __getit() -> std::option::Option<\n     &'static std::cell::UnsafeCell<\n         std::option::Option<Foo>>>\n {\n-    __KEY.get() //~ ERROR  invocation of unsafe method requires unsafe\n+    __KEY.get() //~ ERROR call to unsafe function requires unsafe\n }\n \n static FOO: std::thread::LocalKey<Foo> ="}, {"sha": "e57d65dcb891f7b5b1439969f12ac5e80e617be9", "filename": "src/test/compile-fail/union/union-unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -42,8 +42,8 @@ fn main() {\n     let mut u1 = U1 { a: 10 }; // OK\n     let a = u1.a; //~ ERROR access to union field requires unsafe\n     u1.a = 11; // OK\n-    let U1 { a } = u1; //~ ERROR matching on union field requires unsafe\n-    if let U1 { a: 12 } = u1 {} //~ ERROR matching on union field requires unsafe\n+    let U1 { a } = u1; //~ ERROR access to union field requires unsafe\n+    if let U1 { a: 12 } = u1 {} //~ ERROR access to union field requires unsafe\n     // let U1 { .. } = u1; // OK\n \n     let mut u2 = U2 { a: String::from(\"old\") }; // OK"}, {"sha": "f30da250f6ac80f2eb8a0ec66d429a4d17c6d077", "filename": "src/test/compile-fail/unsafe-fn-assign-deref-ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -1,3 +1,4 @@\n+\n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -9,7 +10,7 @@\n // except according to those terms.\n \n \n-fn f(p: *const u8) {\n+fn f(p: *mut u8) {\n     *p = 0; //~ ERROR dereference of raw pointer requires unsafe function or block\n     return;\n }"}, {"sha": "84a8c84a0dbd203ae46cf6ca2e64a06e097b4fb6", "filename": "src/test/compile-fail/unsafe-move-val-init.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Ftest%2Fcompile-fail%2Funsafe-move-val-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9cdc4c2a98c3a889604762dccd463757079798/src%2Ftest%2Fcompile-fail%2Funsafe-move-val-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-move-val-init.rs?ref=7a9cdc4c2a98c3a889604762dccd463757079798", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core_intrinsics)]\n+\n+use std::intrinsics;\n+\n+// `move_val_init` has an odd desugaring, check that it is still treated\n+// as unsafe.\n+fn main() {\n+    intrinsics::move_val_init(1 as *mut u32, 1);\n+    //~^ ERROR dereference of raw pointer requires unsafe function or block\n+}"}]}