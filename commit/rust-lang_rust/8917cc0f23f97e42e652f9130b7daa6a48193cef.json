{"sha": "8917cc0f23f97e42e652f9130b7daa6a48193cef", "node_id": "C_kwDOAAsO6NoAKDg5MTdjYzBmMjNmOTdlNDJlNjUyZjkxMzBiN2RhYTZhNDgxOTNjZWY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-13T00:17:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-13T00:17:09Z"}, "message": "Rollup merge of #105332 - estebank:iterator-chains, r=oli-obk\n\nPoint out the type of associated types in every method call of iterator chains\n\nPartially address #105184 by pointing out the type of associated types in every method call of iterator chains:\n\n```\nnote: the expression is of type `Map<std::slice::Iter<'_, {integer}>, [closure@src/test/ui/iterators/invalid-iterator-chain.rs:12:18: 12:21]>`\n    --> src/test/ui/iterators/invalid-iterator-chain.rs:12:14\n     |\n10   |         vec![0, 1]\n     |         ---------- this expression has type `Vec<{integer}>`\n11   |             .iter()\n     |              ------ associated type `std::iter::Iterator::Item` is `&{integer}` here\n12   |             .map(|x| { x; })\n     |              ^^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` is `()` here\n```\n\nWe also reduce the number of impls we mention when any of the candidates is an \"exact match\". This benefits the output of cases with numerics greatly.\n\nOutstanding work would be to provide a structured suggestion for appropriate changes, like in this case detecting the spurious `;` in the closure.", "tree": {"sha": "a1e2eb311bc21a165bb3612b180035dda68fde22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1e2eb311bc21a165bb3612b180035dda68fde22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8917cc0f23f97e42e652f9130b7daa6a48193cef", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjl8SFCRBK7hj4Ov3rIwAADIQIAJjHuciJ2zb17K62j8alwVmx\njJN+Y6RdDn5BNxYArtw8h1cQVpFhWusgakt5xT5T2jZ9OOqr5bxigVOOX8lcK95x\nQyD71kv9jhZsTyjds3T7bJVRv58V7FSO4CMCRKKXvYNGVtrsOov8MksqrxJsDSkP\ncXqtmkkmqKBMMJ+Lz2Z8ftTG4CDJfnDVNaLPUq37weRtdY2DqYaGJUYkNB4xzoMI\n1nZIj02d1tkXyS9D/U2Z+zdTSEPvPNCDoapIuCPMVliAYnUkgcjVJWSpizqpUB7h\n83NLgLGmwNVz/9ybdRGFY0yJ9vPoUT7T1vy4coXrh2UDlsbFH1spFxeON2jiJu4=\n=1CA4\n-----END PGP SIGNATURE-----\n", "payload": "tree a1e2eb311bc21a165bb3612b180035dda68fde22\nparent 6dbaf86672397081f4b946b18acc37d1a27611d8\nparent f4ed2d1cca0106eb4aec99b61670ecac378ca087\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1670890629 +0100\ncommitter GitHub <noreply@github.com> 1670890629 +0100\n\nRollup merge of #105332 - estebank:iterator-chains, r=oli-obk\n\nPoint out the type of associated types in every method call of iterator chains\n\nPartially address #105184 by pointing out the type of associated types in every method call of iterator chains:\n\n```\nnote: the expression is of type `Map<std::slice::Iter<'_, {integer}>, [closure@src/test/ui/iterators/invalid-iterator-chain.rs:12:18: 12:21]>`\n    --> src/test/ui/iterators/invalid-iterator-chain.rs:12:14\n     |\n10   |         vec![0, 1]\n     |         ---------- this expression has type `Vec<{integer}>`\n11   |             .iter()\n     |              ------ associated type `std::iter::Iterator::Item` is `&{integer}` here\n12   |             .map(|x| { x; })\n     |              ^^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` is `()` here\n```\n\nWe also reduce the number of impls we mention when any of the candidates is an \"exact match\". This benefits the output of cases with numerics greatly.\n\nOutstanding work would be to provide a structured suggestion for appropriate changes, like in this case detecting the spurious `;` in the closure.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8917cc0f23f97e42e652f9130b7daa6a48193cef", "html_url": "https://github.com/rust-lang/rust/commit/8917cc0f23f97e42e652f9130b7daa6a48193cef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8917cc0f23f97e42e652f9130b7daa6a48193cef/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dbaf86672397081f4b946b18acc37d1a27611d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dbaf86672397081f4b946b18acc37d1a27611d8", "html_url": "https://github.com/rust-lang/rust/commit/6dbaf86672397081f4b946b18acc37d1a27611d8"}, {"sha": "f4ed2d1cca0106eb4aec99b61670ecac378ca087", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4ed2d1cca0106eb4aec99b61670ecac378ca087", "html_url": "https://github.com/rust-lang/rust/commit/f4ed2d1cca0106eb4aec99b61670ecac378ca087"}], "stats": {"total": 929, "additions": 744, "deletions": 185}, "files": [{"sha": "6bc0c2615654952873f464f2b34b272e5169b4d5", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -370,7 +370,11 @@ impl Diagnostic {\n         self.set_span(after);\n         for span_label in before.span_labels() {\n             if let Some(label) = span_label.label {\n-                self.span.push_span_label(after, label);\n+                if span_label.is_primary {\n+                    self.span.push_span_label(after, label);\n+                } else {\n+                    self.span.push_span_label(span_label.span, label);\n+                }\n             }\n         }\n         self"}, {"sha": "cb373d657721bf53758eff0aa91355bf5eaf8b9a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/method_chain.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -0,0 +1,74 @@\n+use crate::infer::InferCtxt;\n+\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+\n+pub struct CollectAllMismatches<'a, 'tcx> {\n+    pub infcx: &'a InferCtxt<'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n+    pub errors: Vec<TypeError<'tcx>>,\n+}\n+\n+impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n+    fn tag(&self) -> &'static str {\n+        \"CollectAllMismatches\"\n+    }\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    } // irrelevant\n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        _: ty::Variance,\n+        _: ty::VarianceDiagInfo<'tcx>,\n+        a: T,\n+        b: T,\n+    ) -> RelateResult<'tcx, T> {\n+        self.relate(a, b)\n+    }\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        _b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        Ok(a)\n+    }\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        if a == b || matches!(a.kind(), ty::Infer(_)) || matches!(b.kind(), ty::Infer(_)) {\n+            return Ok(a);\n+        }\n+        relate::super_relate_tys(self, a, b).or_else(|e| {\n+            self.errors.push(e);\n+            Ok(a)\n+        })\n+    }\n+    fn consts(\n+        &mut self,\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n+        if a == b {\n+            return Ok(a);\n+        }\n+        relate::super_relate_consts(self, a, b) // could do something similar here for constants!\n+    }\n+    fn binders<T: Relate<'tcx>>(\n+        &mut self,\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>> {\n+        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n+    }\n+}"}, {"sha": "30ff07ee6c372b6df900d11c4f980d5adefe268f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,4 +1,5 @@\n mod ambiguity;\n+pub mod method_chain;\n pub mod on_unimplemented;\n pub mod suggestions;\n \n@@ -536,7 +537,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             |err| {\n                 self.note_obligation_cause_code(\n                     err,\n-                    &predicate,\n+                    predicate,\n                     obligation.param_env,\n                     obligation.cause.code(),\n                     &mut vec![],\n@@ -1587,7 +1588,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 {\n                     self.note_obligation_cause_code(\n                         &mut diag,\n-                        &error.obligation.predicate,\n+                        error.obligation.predicate,\n                         error.obligation.param_env,\n                         code,\n                         &mut vec![],\n@@ -2602,7 +2603,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         if !self.maybe_note_obligation_cause_for_async_await(err, obligation) {\n             self.note_obligation_cause_code(\n                 err,\n-                &obligation.predicate,\n+                obligation.predicate,\n                 obligation.param_env,\n                 obligation.cause.code(),\n                 &mut vec![],"}, {"sha": "40c8102547112956468b8c18f39e5dc2ce9a85b3", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 342, "deletions": 59, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,8 +1,9 @@\n+// ignore-tidy-filelength\n use super::{DefIdOrName, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation};\n \n use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n-use crate::traits::NormalizeExt;\n+use crate::traits::{NormalizeExt, ObligationCtxt};\n \n use hir::def::CtorOf;\n use hir::HirId;\n@@ -22,17 +23,20 @@ use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{InferOk, LateBoundRegionConversionTime};\n use rustc_middle::hir::map;\n+use rustc_middle::ty::error::TypeError::{self, Sorts};\n+use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n-    GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, IsSuggestable,\n-    ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+    GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, InternalSubsts,\n+    IsSuggestable, ToPredicate, Ty, TyCtxt, TypeAndMut, TypeFoldable, TypeFolder,\n+    TypeSuperFoldable, TypeVisitable, TypeckResults,\n };\n-use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{BytePos, DesugaringKind, ExpnKind, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n-use std::fmt;\n+use std::ops::Deref;\n \n+use super::method_chain::CollectAllMismatches;\n use super::InferCtxtPrivExt;\n use crate::infer::InferCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -292,13 +296,13 @@ pub trait TypeErrCtxtExt<'tcx> {\n     fn note_obligation_cause_code<T>(\n         &self,\n         err: &mut Diagnostic,\n-        predicate: &T,\n+        predicate: T,\n         param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n         obligated_types: &mut Vec<Ty<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n     ) where\n-        T: fmt::Display + ToPredicate<'tcx>;\n+        T: ToPredicate<'tcx>;\n \n     /// Suggest to await before try: future? => future.await?\n     fn suggest_await_before_try(\n@@ -329,6 +333,23 @@ pub trait TypeErrCtxtExt<'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n+    fn function_argument_obligation(\n+        &self,\n+        arg_hir_id: HirId,\n+        err: &mut Diagnostic,\n+        parent_code: &ObligationCauseCode<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: ty::Predicate<'tcx>,\n+        call_hir_id: HirId,\n+    );\n+    fn point_at_chain(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        typeck_results: &TypeckResults<'tcx>,\n+        type_diffs: Vec<TypeError<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        err: &mut Diagnostic,\n+    );\n }\n \n fn predicate_constraint(generics: &hir::Generics<'_>, pred: ty::Predicate<'_>) -> (Span, String) {\n@@ -2336,7 +2357,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         debug!(?next_code);\n         self.note_obligation_cause_code(\n             err,\n-            &obligation.predicate,\n+            obligation.predicate,\n             obligation.param_env,\n             next_code.unwrap(),\n             &mut Vec::new(),\n@@ -2347,15 +2368,16 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn note_obligation_cause_code<T>(\n         &self,\n         err: &mut Diagnostic,\n-        predicate: &T,\n+        predicate: T,\n         param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n         obligated_types: &mut Vec<Ty<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n     ) where\n-        T: fmt::Display + ToPredicate<'tcx>,\n+        T: ToPredicate<'tcx>,\n     {\n         let tcx = self.tcx;\n+        let predicate = predicate.to_predicate(tcx);\n         match *cause_code {\n             ObligationCauseCode::ExprAssignable\n             | ObligationCauseCode::MatchExpressionArm { .. }\n@@ -2390,12 +2412,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 err.note(\"only the last element of a tuple may have a dynamically sized type\");\n             }\n             ObligationCauseCode::ProjectionWf(data) => {\n-                err.note(&format!(\"required so that the projection `{}` is well-formed\", data,));\n+                err.note(&format!(\"required so that the projection `{data}` is well-formed\"));\n             }\n             ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n                 err.note(&format!(\n-                    \"required so that reference `{}` does not outlive its referent\",\n-                    ref_ty,\n+                    \"required so that reference `{ref_ty}` does not outlive its referent\"\n                 ));\n             }\n             ObligationCauseCode::ObjectTypeBound(object_ty, region) => {\n@@ -2689,7 +2710,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     ensure_sufficient_stack(|| {\n                         self.note_obligation_cause_code(\n                             err,\n-                            &parent_predicate,\n+                            parent_predicate,\n                             param_env,\n                             &data.parent_code,\n                             obligated_types,\n@@ -2700,7 +2721,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     ensure_sufficient_stack(|| {\n                         self.note_obligation_cause_code(\n                             err,\n-                            &parent_predicate,\n+                            parent_predicate,\n                             param_env,\n                             cause_code.peel_derives(),\n                             obligated_types,\n@@ -2809,7 +2830,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n                         err,\n-                        &parent_predicate,\n+                        parent_predicate,\n                         param_env,\n                         &data.parent_code,\n                         obligated_types,\n@@ -2824,7 +2845,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n                         err,\n-                        &parent_predicate,\n+                        parent_predicate,\n                         param_env,\n                         &data.parent_code,\n                         obligated_types,\n@@ -2837,43 +2858,14 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 call_hir_id,\n                 ref parent_code,\n             } => {\n-                let hir = self.tcx.hir();\n-                if let Some(Node::Expr(expr @ hir::Expr { kind: hir::ExprKind::Block(..), .. })) =\n-                    hir.find(arg_hir_id)\n-                {\n-                    let parent_id = hir.get_parent_item(arg_hir_id);\n-                    let typeck_results: &TypeckResults<'tcx> = match &self.typeck_results {\n-                        Some(t) if t.hir_owner == parent_id => t,\n-                        _ => self.tcx.typeck(parent_id.def_id),\n-                    };\n-                    let expr = expr.peel_blocks();\n-                    let ty = typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error());\n-                    let span = expr.span;\n-                    if Some(span) != err.span.primary_span() {\n-                        err.span_label(\n-                            span,\n-                            if ty.references_error() {\n-                                String::new()\n-                            } else {\n-                                format!(\"this tail expression is of type `{:?}`\", ty)\n-                            },\n-                        );\n-                    }\n-                }\n-                if let Some(Node::Expr(hir::Expr {\n-                    kind:\n-                        hir::ExprKind::Call(hir::Expr { span, .. }, _)\n-                        | hir::ExprKind::MethodCall(\n-                            hir::PathSegment { ident: Ident { span, .. }, .. },\n-                            ..,\n-                        ),\n-                    ..\n-                })) = hir.find(call_hir_id)\n-                {\n-                    if Some(*span) != err.span.primary_span() {\n-                        err.span_label(*span, \"required by a bound introduced by this call\");\n-                    }\n-                }\n+                self.function_argument_obligation(\n+                    arg_hir_id,\n+                    err,\n+                    parent_code,\n+                    param_env,\n+                    predicate,\n+                    call_hir_id,\n+                );\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n                         err,\n@@ -2888,9 +2880,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             ObligationCauseCode::CompareImplItemObligation { trait_item_def_id, kind, .. } => {\n                 let item_name = self.tcx.item_name(trait_item_def_id);\n                 let msg = format!(\n-                    \"the requirement `{}` appears on the `impl`'s {kind} `{}` but not on the \\\n-                     corresponding trait's {kind}\",\n-                    predicate, item_name,\n+                    \"the requirement `{predicate}` appears on the `impl`'s {kind} \\\n+                     `{item_name}` but not on the corresponding trait's {kind}\",\n                 );\n                 let sp = self\n                     .tcx\n@@ -2900,7 +2891,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 let mut assoc_span: MultiSpan = sp.into();\n                 assoc_span.push_span_label(\n                     sp,\n-                    format!(\"this trait's {kind} doesn't have the requirement `{}`\", predicate),\n+                    format!(\"this trait's {kind} doesn't have the requirement `{predicate}`\"),\n                 );\n                 if let Some(ident) = self\n                     .tcx\n@@ -2919,7 +2910,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n             ObligationCauseCode::OpaqueReturnType(expr_info) => {\n                 if let Some((expr_ty, expr_span)) = expr_info {\n-                    let expr_ty = self.resolve_vars_if_possible(expr_ty);\n+                    let expr_ty = with_forced_trimmed_paths!(self.ty_to_string(expr_ty));\n                     err.span_label(\n                         expr_span,\n                         format!(\"return type was inferred to be `{expr_ty}` here\"),\n@@ -3099,6 +3090,298 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             );\n         }\n     }\n+    fn function_argument_obligation(\n+        &self,\n+        arg_hir_id: HirId,\n+        err: &mut Diagnostic,\n+        parent_code: &ObligationCauseCode<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: ty::Predicate<'tcx>,\n+        call_hir_id: HirId,\n+    ) {\n+        let tcx = self.tcx;\n+        let hir = tcx.hir();\n+        if let Some(Node::Expr(expr)) = hir.find(arg_hir_id) {\n+            let parent_id = hir.get_parent_item(arg_hir_id);\n+            let typeck_results: &TypeckResults<'tcx> = match &self.typeck_results {\n+                Some(t) if t.hir_owner == parent_id => t,\n+                _ => self.tcx.typeck(parent_id.def_id),\n+            };\n+            if let hir::Expr { kind: hir::ExprKind::Block(..), .. } = expr {\n+                let expr = expr.peel_blocks();\n+                let ty = typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error());\n+                let span = expr.span;\n+                if Some(span) != err.span.primary_span() {\n+                    err.span_label(\n+                        span,\n+                        if ty.references_error() {\n+                            String::new()\n+                        } else {\n+                            let ty = with_forced_trimmed_paths!(self.ty_to_string(ty));\n+                            format!(\"this tail expression is of type `{ty}`\")\n+                        },\n+                    );\n+                }\n+            }\n+\n+            // FIXME: visit the ty to see if there's any closure involved, and if there is,\n+            // check whether its evaluated return type is the same as the one corresponding\n+            // to an associated type (as seen from `trait_pred`) in the predicate. Like in\n+            // trait_pred `S: Sum<<Self as Iterator>::Item>` and predicate `i32: Sum<&()>`\n+            let mut type_diffs = vec![];\n+\n+            if let ObligationCauseCode::ExprBindingObligation(def_id, _, _, idx) = parent_code.deref()\n+                && let predicates = self.tcx.predicates_of(def_id).instantiate_identity(self.tcx)\n+                && let Some(pred) = predicates.predicates.get(*idx)\n+                && let Ok(trait_pred) = pred.kind().try_map_bound(|pred| match pred {\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n+                    _ => Err(()),\n+                })\n+            {\n+                let mut c = CollectAllMismatches {\n+                    infcx: self.infcx,\n+                    param_env,\n+                    errors: vec![],\n+                };\n+                if let Ok(trait_predicate) = predicate.kind().try_map_bound(|pred| match pred {\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n+                    _ => Err(()),\n+                }) {\n+                    if let Ok(_) = c.relate(trait_pred, trait_predicate) {\n+                        type_diffs = c.errors;\n+                    }\n+                }\n+            }\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n+                && let hir::Path { res: hir::def::Res::Local(hir_id), .. } = path\n+                && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(*hir_id)\n+                && let parent_hir_id = self.tcx.hir().get_parent_node(binding.hir_id)\n+                && let Some(hir::Node::Local(local)) = self.tcx.hir().find(parent_hir_id)\n+                && let Some(binding_expr) = local.init\n+            {\n+                // If the expression we're calling on is a binding, we want to point at the\n+                // `let` when talking about the type. Otherwise we'll point at every part\n+                // of the method chain with the type.\n+                self.point_at_chain(binding_expr, typeck_results, type_diffs, param_env, err);\n+            } else {\n+                self.point_at_chain(expr, typeck_results, type_diffs, param_env, err);\n+            }\n+        }\n+        let call_node = hir.find(call_hir_id);\n+        if let Some(Node::Expr(hir::Expr {\n+            kind: hir::ExprKind::MethodCall(path, rcvr, ..), ..\n+        })) = call_node\n+        {\n+            if Some(rcvr.span) == err.span.primary_span() {\n+                err.replace_span_with(path.ident.span);\n+            }\n+        }\n+        if let Some(Node::Expr(hir::Expr {\n+            kind:\n+                hir::ExprKind::Call(hir::Expr { span, .. }, _)\n+                | hir::ExprKind::MethodCall(hir::PathSegment { ident: Ident { span, .. }, .. }, ..),\n+            ..\n+        })) = hir.find(call_hir_id)\n+        {\n+            if Some(*span) != err.span.primary_span() {\n+                err.span_label(*span, \"required by a bound introduced by this call\");\n+            }\n+        }\n+    }\n+\n+    fn point_at_chain(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        typeck_results: &TypeckResults<'tcx>,\n+        type_diffs: Vec<TypeError<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        err: &mut Diagnostic,\n+    ) {\n+        let mut primary_spans = vec![];\n+        let mut span_labels = vec![];\n+\n+        let tcx = self.tcx;\n+\n+        let mut assocs = vec![];\n+        // We still want to point at the different methods even if there hasn't\n+        // been a change of assoc type.\n+        let mut call_spans = vec![];\n+        let mut expr = expr;\n+        let mut prev_ty = self.resolve_vars_if_possible(\n+            typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n+        );\n+        while let hir::ExprKind::MethodCall(_path_segment, rcvr_expr, _args, span) = expr.kind {\n+            // Point at every method call in the chain with the resulting type.\n+            // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n+            //               ^^^^^^ ^^^^^^^^^^^\n+            expr = rcvr_expr;\n+            let mut assocs_in_this_method = Vec::with_capacity(type_diffs.len());\n+            call_spans.push(span);\n+\n+            let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n+            for diff in &type_diffs {\n+                let Sorts(expected_found) = diff else { continue; };\n+                let ty::Projection(proj) = expected_found.expected.kind() else { continue; };\n+\n+                let origin =\n+                    TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span };\n+                let trait_def_id = proj.trait_def_id(self.tcx);\n+                // Make `Self` be equivalent to the type of the call chain\n+                // expression we're looking at now, so that we can tell what\n+                // for example `Iterator::Item` is at this point in the chain.\n+                let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n+                    match param.kind {\n+                        ty::GenericParamDefKind::Type { .. } => {\n+                            if param.index == 0 {\n+                                return prev_ty.into();\n+                            }\n+                        }\n+                        ty::GenericParamDefKind::Lifetime\n+                        | ty::GenericParamDefKind::Const { .. } => {}\n+                    }\n+                    self.var_for_def(span, param)\n+                });\n+                // This will hold the resolved type of the associated type, if the\n+                // current expression implements the trait that associated type is\n+                // in. For example, this would be what `Iterator::Item` is here.\n+                let ty_var = self.infcx.next_ty_var(origin);\n+                // This corresponds to `<ExprTy as Iterator>::Item = _`.\n+                let trait_ref = ty::Binder::dummy(ty::PredicateKind::Clause(\n+                    ty::Clause::Projection(ty::ProjectionPredicate {\n+                        projection_ty: ty::ProjectionTy { substs, item_def_id: proj.item_def_id },\n+                        term: ty_var.into(),\n+                    }),\n+                ));\n+                // Add `<ExprTy as Iterator>::Item = _` obligation.\n+                ocx.register_obligation(Obligation::misc(\n+                    self.tcx,\n+                    span,\n+                    expr.hir_id,\n+                    param_env,\n+                    trait_ref,\n+                ));\n+                if ocx.select_where_possible().is_empty() {\n+                    // `ty_var` now holds the type that `Item` is for `ExprTy`.\n+                    let ty_var = self.resolve_vars_if_possible(ty_var);\n+                    assocs_in_this_method.push(Some((span, (proj.item_def_id, ty_var))));\n+                } else {\n+                    // `<ExprTy as Iterator>` didn't select, so likely we've\n+                    // reached the end of the iterator chain, like the originating\n+                    // `Vec<_>`.\n+                    // Keep the space consistent for later zipping.\n+                    assocs_in_this_method.push(None);\n+                }\n+            }\n+            assocs.push(assocs_in_this_method);\n+            prev_ty = self.resolve_vars_if_possible(\n+                typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n+            );\n+\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n+                && let hir::Path { res: hir::def::Res::Local(hir_id), .. } = path\n+                && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(*hir_id)\n+                && let parent_hir_id = self.tcx.hir().get_parent_node(binding.hir_id)\n+                && let Some(hir::Node::Local(local)) = self.tcx.hir().find(parent_hir_id)\n+                && let Some(binding_expr) = local.init\n+            {\n+                // We've reached the root of the method call chain and it is a\n+                // binding. Get the binding creation and try to continue the chain.\n+                expr = binding_expr;\n+            }\n+        }\n+        // We want the type before deref coercions, otherwise we talk about `&[_]`\n+        // instead of `Vec<_>`.\n+        if let Some(ty) = typeck_results.expr_ty_opt(expr) {\n+            let ty = with_forced_trimmed_paths!(self.ty_to_string(ty));\n+            // Point at the root expression\n+            // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n+            // ^^^^^^^^^^^^^\n+            span_labels.push((expr.span, format!(\"this expression has type `{ty}`\")));\n+        };\n+        // Only show this if it is not a \"trivial\" expression (not a method\n+        // chain) and there are associated types to talk about.\n+        let mut assocs = assocs.into_iter().peekable();\n+        while let Some(assocs_in_method) = assocs.next() {\n+            let Some(prev_assoc_in_method) = assocs.peek() else {\n+                for entry in assocs_in_method {\n+                    let Some((span, (assoc, ty))) = entry else { continue; };\n+                    if type_diffs.iter().any(|diff| {\n+                        let Sorts(expected_found) = diff else { return false; };\n+                        self.can_eq(param_env, expected_found.found, ty).is_ok()\n+                    }) {\n+                        // FIXME: this doesn't quite work for `Iterator::collect`\n+                        // because we have `Vec<i32>` and `()`, but we'd want `i32`\n+                        // to point at the `.into_iter()` call, but as long as we\n+                        // still point at the other method calls that might have\n+                        // introduced the issue, this is fine for now.\n+                        primary_spans.push(span);\n+                    }\n+                    span_labels.push((\n+                        span,\n+                        with_forced_trimmed_paths!(format!(\n+                            \"`{}` is `{ty}` here\",\n+                            self.tcx.def_path_str(assoc),\n+                        )),\n+                    ));\n+                }\n+                break;\n+            };\n+            for (entry, prev_entry) in\n+                assocs_in_method.into_iter().zip(prev_assoc_in_method.into_iter())\n+            {\n+                match (entry, prev_entry) {\n+                    (Some((span, (assoc, ty))), Some((_, (_, prev_ty)))) => {\n+                        let ty_str = with_forced_trimmed_paths!(self.ty_to_string(ty));\n+\n+                        let assoc = with_forced_trimmed_paths!(self.tcx.def_path_str(assoc));\n+                        if ty != *prev_ty {\n+                            if type_diffs.iter().any(|diff| {\n+                                let Sorts(expected_found) = diff else { return false; };\n+                                self.can_eq(param_env, expected_found.found, ty).is_ok()\n+                            }) {\n+                                primary_spans.push(span);\n+                            }\n+                            span_labels\n+                                .push((span, format!(\"`{assoc}` changed to `{ty_str}` here\")));\n+                        } else {\n+                            span_labels.push((span, format!(\"`{assoc}` remains `{ty_str}` here\")));\n+                        }\n+                    }\n+                    (Some((span, (assoc, ty))), None) => {\n+                        span_labels.push((\n+                            span,\n+                            with_forced_trimmed_paths!(format!(\n+                                \"`{}` is `{}` here\",\n+                                self.tcx.def_path_str(assoc),\n+                                self.ty_to_string(ty),\n+                            )),\n+                        ));\n+                    }\n+                    (None, Some(_)) | (None, None) => {}\n+                }\n+            }\n+        }\n+        for span in call_spans {\n+            if span_labels.iter().find(|(s, _)| *s == span).is_none() {\n+                // Ensure we are showing the entire chain, even if the assoc types\n+                // haven't changed.\n+                span_labels.push((span, String::new()));\n+            }\n+        }\n+        if !primary_spans.is_empty() {\n+            let mut multi_span: MultiSpan = primary_spans.into();\n+            for (span, label) in span_labels {\n+                multi_span.push_span_label(span, label);\n+            }\n+            err.span_note(\n+                multi_span,\n+                format!(\n+                    \"the method call chain might not have had the expected \\\n+                                     associated types\",\n+                ),\n+            );\n+        }\n+    }\n }\n \n /// Collect all the returned expressions within the input expression."}, {"sha": "c7ed8e0de384ce5eb3655f8b9bc8e2f39e99429a", "filename": "src/test/ui/expr/malformed_closure/ruby_style_closure.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -14,7 +14,7 @@ LL |       let p = Some(45).and_then({\n LL | |\n LL | |         |x| println!(\"doubling {}\", x);\n LL | |         Some(x * 2)\n-   | |         ----------- this tail expression is of type `std::option::Option<_>`\n+   | |         ----------- this tail expression is of type `Option<_>`\n LL | |\n LL | |     });\n    | |_____^ expected an `FnOnce<({integer},)>` closure, found `Option<_>`"}, {"sha": "422ac5484271d519b82c04d253ef709720b9178a", "filename": "src/test/ui/generic-associated-types/issue-101020.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-101020.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-101020.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-101020.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `for<'a> &'a mut (): Foo<&'a mut ()>` is not satisfied\n-  --> $DIR/issue-101020.rs:31:5\n+  --> $DIR/issue-101020.rs:31:22\n    |\n LL |     (&mut EmptyIter).consume(());\n-   |     ^^^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |     |\n-   |     the trait `for<'a> Foo<&'a mut ()>` is not implemented for `&'a mut ()`\n+   |                      ^^^^^^^ the trait `for<'a> Foo<&'a mut ()>` is not implemented for `&'a mut ()`\n    |\n note: required for `&'a mut ()` to implement `for<'a> FuncInput<'a, &'a mut ()>`\n   --> $DIR/issue-101020.rs:27:20"}, {"sha": "d70bf6e1d921c3618744544c4763648cd8057d27", "filename": "src/test/ui/issues/issue-20162.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fissues%2Fissue-20162.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fissues%2Fissue-20162.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20162.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `X: Ord` is not satisfied\n-  --> $DIR/issue-20162.rs:5:5\n+  --> $DIR/issue-20162.rs:5:7\n    |\n LL |     b.sort();\n-   |     ^ ---- required by a bound introduced by this call\n-   |     |\n-   |     the trait `Ord` is not implemented for `X`\n+   |       ^^^^ the trait `Ord` is not implemented for `X`\n    |\n note: required by a bound in `slice::<impl [T]>::sort`\n   --> $SRC_DIR/alloc/src/slice.rs:LL:COL"}, {"sha": "f678df5b42b60d927cf4386889a745d7a553e73a", "filename": "src/test/ui/issues/issue-31173.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fissues%2Fissue-31173.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fissues%2Fissue-31173.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31173.rs?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -4,12 +4,11 @@ pub fn get_tok(it: &mut IntoIter<u8>) {\n     let mut found_e = false;\n \n     let temp: Vec<u8> = it\n-        //~^ ERROR to be an iterator that yields `&_`, but it yields `u8`\n         .take_while(|&x| {\n             found_e = true;\n             false\n         })\n-        .cloned()\n+        .cloned() //~ ERROR to be an iterator that yields `&_`, but it yields `u8`\n         .collect(); //~ ERROR the method\n }\n "}, {"sha": "62d841f37893f67f80161657c81bfe4b59179eb9", "filename": "src/test/ui/issues/issue-31173.stderr", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,16 +1,8 @@\n-error[E0271]: expected `TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:8:21: 8:25]>` to be an iterator that yields `&_`, but it yields `u8`\n-  --> $DIR/issue-31173.rs:6:25\n-   |\n-LL |       let temp: Vec<u8> = it\n-   |  _________________________^\n-LL | |\n-LL | |         .take_while(|&x| {\n-LL | |             found_e = true;\n-LL | |             false\n-LL | |         })\n-   | |__________^ expected reference, found `u8`\n-LL |           .cloned()\n-   |            ------ required by a bound introduced by this call\n+error[E0271]: expected `TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>` to be an iterator that yields `&_`, but it yields `u8`\n+  --> $DIR/issue-31173.rs:11:10\n+   |\n+LL |         .cloned()\n+   |          ^^^^^^ expected reference, found `u8`\n    |\n    = note: expected reference `&_`\n                    found type `u8`\n@@ -20,11 +12,11 @@ note: required by a bound in `cloned`\n LL |         Self: Sized + Iterator<Item = &'a T>,\n    |                                ^^^^^^^^^^^^ required by this bound in `Iterator::cloned`\n \n-error[E0599]: the method `collect` exists for struct `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:8:21: 8:25]>>`, but its trait bounds were not satisfied\n-  --> $DIR/issue-31173.rs:13:10\n+error[E0599]: the method `collect` exists for struct `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>`, but its trait bounds were not satisfied\n+  --> $DIR/issue-31173.rs:12:10\n    |\n LL |         .collect();\n-   |          ^^^^^^^ method cannot be called on `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:8:21: 8:25]>>` due to unsatisfied trait bounds\n+   |          ^^^^^^^ method cannot be called on `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>` due to unsatisfied trait bounds\n    |\n   ::: $SRC_DIR/core/src/iter/adapters/take_while.rs:LL:COL\n    |\n@@ -37,10 +29,10 @@ LL | pub struct Cloned<I> {\n    | -------------------- doesn't satisfy `_: Iterator`\n    |\n    = note: the following trait bounds were not satisfied:\n-           `<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:8:21: 8:25]> as Iterator>::Item = &_`\n-           which is required by `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:8:21: 8:25]>>: Iterator`\n-           `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:8:21: 8:25]>>: Iterator`\n-           which is required by `&mut Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:8:21: 8:25]>>: Iterator`\n+           `<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]> as Iterator>::Item = &_`\n+           which is required by `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>: Iterator`\n+           `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>: Iterator`\n+           which is required by `&mut Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>: Iterator`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "73a9b786fe2b580d41982b38056ebb58474f42fe", "filename": "src/test/ui/issues/issue-33941.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0271]: expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n-  --> $DIR/issue-33941.rs:6:14\n+  --> $DIR/issue-33941.rs:6:36\n    |\n LL |     for _ in HashMap::new().iter().cloned() {}\n-   |              ^^^^^^^^^^^^^^^^^^^^^ ------ required by a bound introduced by this call\n-   |              |\n-   |              expected reference, found tuple\n+   |                                    ^^^^^^ expected reference, found tuple\n    |\n    = note: expected reference `&_`\n                   found tuple `(&_, &_)`"}, {"sha": "b610e5c1366683b2838d0946fe4b01dbdeefdda4", "filename": "src/test/ui/issues/issue-34334.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -13,15 +13,23 @@ LL |     let sr: Vec<(u32, _, _)> = vec![];\n    |                            +\n \n error[E0277]: a value of type `Vec<(u32, _, _)>` cannot be built from an iterator over elements of type `()`\n-  --> $DIR/issue-34334.rs:5:33\n+  --> $DIR/issue-34334.rs:5:87\n    |\n LL |     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_receiver)| {}).collect();\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |                                 |\n-   |                                 value of type `Vec<(u32, _, _)>` cannot be built from `std::iter::Iterator<Item=()>`\n+   |                                                                                       ^^^^^^^ value of type `Vec<(u32, _, _)>` cannot be built from `std::iter::Iterator<Item=()>`\n    |\n    = help: the trait `FromIterator<()>` is not implemented for `Vec<(u32, _, _)>`\n    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/issue-34334.rs:5:43\n+   |\n+LL |     let sr: Vec<(u32, _, _) = vec![];\n+   |                               ------ this expression has type `Vec<(_, _, _)>`\n+...\n+LL |     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_receiver)| {}).collect();\n+   |                                    ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Iterator::Item` changed to `()` here\n+   |                                    |\n+   |                                    `Iterator::Item` is `&(_, _, _)` here\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |"}, {"sha": "c6352978613aa553849af5fb8938b41e80ce9cf9", "filename": "src/test/ui/issues/issue-66923-show-error-for-correct-call.stderr", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,29 +1,40 @@\n error[E0277]: a value of type `Vec<f64>` cannot be built from an iterator over elements of type `&f64`\n-  --> $DIR/issue-66923-show-error-for-correct-call.rs:8:24\n+  --> $DIR/issue-66923-show-error-for-correct-call.rs:8:39\n    |\n LL |     let x2: Vec<f64> = x1.into_iter().collect();\n-   |                        ^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |                        |\n-   |                        value of type `Vec<f64>` cannot be built from `std::iter::Iterator<Item=&f64>`\n+   |                                       ^^^^^^^ value of type `Vec<f64>` cannot be built from `std::iter::Iterator<Item=&f64>`\n    |\n    = help: the trait `FromIterator<&f64>` is not implemented for `Vec<f64>`\n    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/issue-66923-show-error-for-correct-call.rs:8:27\n+   |\n+LL |     let x1: &[f64] = &v;\n+   |                      -- this expression has type `&Vec<f64>`\n+LL |     let x2: Vec<f64> = x1.into_iter().collect();\n+   |                           ^^^^^^^^^^^ `Iterator::Item` is `&f64` here\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |\n LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n \n error[E0277]: a value of type `Vec<f64>` cannot be built from an iterator over elements of type `&f64`\n-  --> $DIR/issue-66923-show-error-for-correct-call.rs:12:14\n+  --> $DIR/issue-66923-show-error-for-correct-call.rs:12:29\n    |\n LL |     let x3 = x1.into_iter().collect::<Vec<f64>>();\n-   |              ^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |              |\n-   |              value of type `Vec<f64>` cannot be built from `std::iter::Iterator<Item=&f64>`\n+   |                             ^^^^^^^ value of type `Vec<f64>` cannot be built from `std::iter::Iterator<Item=&f64>`\n    |\n    = help: the trait `FromIterator<&f64>` is not implemented for `Vec<f64>`\n    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/issue-66923-show-error-for-correct-call.rs:12:17\n+   |\n+LL |     let x1: &[f64] = &v;\n+   |                      -- this expression has type `&Vec<f64>`\n+...\n+LL |     let x3 = x1.into_iter().collect::<Vec<f64>>();\n+   |                 ^^^^^^^^^^^ `Iterator::Item` is `&f64` here\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |"}, {"sha": "99d0d9bd735532bfc8a299ba1a7d9cde7a42dc0d", "filename": "src/test/ui/iterators/collect-into-array.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.rs?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -3,5 +3,4 @@ fn main() {\n     //~^ ERROR an array of type `[u32; 10]` cannot be built directly from an iterator\n     //~| NOTE try collecting into a `Vec<{integer}>`, then using `.try_into()`\n     //~| NOTE required by a bound in `collect`\n-    //~| NOTE required by a bound introduced by this call\n }"}, {"sha": "7a07fed1fae3af7ec3bdcd4188ed7e89b1454569", "filename": "src/test/ui/iterators/collect-into-array.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: an array of type `[u32; 10]` cannot be built directly from an iterator\n-  --> $DIR/collect-into-array.rs:2:31\n+  --> $DIR/collect-into-array.rs:2:39\n    |\n LL |     let whatever: [u32; 10] = (0..10).collect();\n-   |                               ^^^^^^^ ------- required by a bound introduced by this call\n-   |                               |\n-   |                               try collecting into a `Vec<{integer}>`, then using `.try_into()`\n+   |                                       ^^^^^^^ try collecting into a `Vec<{integer}>`, then using `.try_into()`\n    |\n    = help: the trait `FromIterator<{integer}>` is not implemented for `[u32; 10]`\n note: required by a bound in `collect`"}, {"sha": "5a8aacb1a6df0bc392290c051c300d638525cb7f", "filename": "src/test/ui/iterators/collect-into-slice.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -13,6 +13,5 @@ fn main() {\n     //~| NOTE all local variables must have a statically known size\n     //~| NOTE doesn't have a size known at compile-time\n     //~| NOTE doesn't have a size known at compile-time\n-    //~| NOTE required by a bound introduced by this call\n     process_slice(&some_generated_vec);\n }"}, {"sha": "58da222e0397b4172d442f259546c4f0f067e9be", "filename": "src/test/ui/iterators/collect-into-slice.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -22,12 +22,10 @@ LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n    |                ^ required by this bound in `Iterator::collect`\n \n error[E0277]: a slice of type `[i32]` cannot be built since `[i32]` has no definite size\n-  --> $DIR/collect-into-slice.rs:6:30\n+  --> $DIR/collect-into-slice.rs:6:38\n    |\n LL |     let some_generated_vec = (0..10).collect();\n-   |                              ^^^^^^^ ------- required by a bound introduced by this call\n-   |                              |\n-   |                              try explicitly collecting into a `Vec<{integer}>`\n+   |                                      ^^^^^^^ try explicitly collecting into a `Vec<{integer}>`\n    |\n    = help: the trait `FromIterator<{integer}>` is not implemented for `[i32]`\n note: required by a bound in `collect`"}, {"sha": "87116e49245703805c9867ac9db2dce04c287ac1", "filename": "src/test/ui/iterators/invalid-iterator-chain.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.rs?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -0,0 +1,41 @@\n+fn main() {\n+    let scores = vec![(0, 0)]\n+        .iter()\n+        .map(|(a, b)| {\n+            a + b;\n+        });\n+    println!(\"{}\", scores.sum::<i32>()); //~ ERROR E0277\n+    println!(\n+        \"{}\",\n+        vec![0, 1]\n+            .iter()\n+            .map(|x| x * 2)\n+            .map(|x| x as f64)\n+            .map(|x| x as i64)\n+            .filter(|x| *x > 0)\n+            .map(|x| { x + 1 })\n+            .map(|x| { x; })\n+            .sum::<i32>(), //~ ERROR E0277\n+    );\n+    println!(\n+        \"{}\",\n+        vec![0, 1]\n+            .iter()\n+            .map(|x| x * 2)\n+            .map(|x| x as f64)\n+            .filter(|x| *x > 0.0)\n+            .map(|x| { x + 1.0 })\n+            .sum::<i32>(), //~ ERROR E0277\n+    );\n+    println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>()); //~ ERROR E0277\n+    println!(\"{}\", vec![(), ()].iter().sum::<i32>()); //~ ERROR E0277\n+    let a = vec![0];\n+    let b = a.into_iter();\n+    let c = b.map(|x| x + 1);\n+    let d = c.filter(|x| *x > 10 );\n+    let e = d.map(|x| {\n+        x + 1;\n+    });\n+    let f = e.filter(|_| false);\n+    let g: Vec<i32> = f.collect(); //~ ERROR E0277\n+}"}, {"sha": "49651b20fb16db3403dce5bc8e96263475abf338", "filename": "src/test/ui/iterators/invalid-iterator-chain.stderr", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -0,0 +1,176 @@\n+error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `()`\n+  --> $DIR/invalid-iterator-chain.rs:7:27\n+   |\n+LL |     println!(\"{}\", scores.sum::<i32>());\n+   |                           ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=()>`\n+   |\n+   = help: the trait `Sum<()>` is not implemented for `i32`\n+   = help: the following other types implement trait `Sum<A>`:\n+             <i32 as Sum<&'a i32>>\n+             <i32 as Sum>\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:4:10\n+   |\n+LL |       let scores = vec![(0, 0)]\n+   |                    ------------ this expression has type `Vec<({integer}, {integer})>`\n+LL |           .iter()\n+   |            ------ `Iterator::Item` is `&({integer}, {integer})` here\n+LL |           .map(|(a, b)| {\n+   |  __________^\n+LL | |             a + b;\n+LL | |         });\n+   | |__________^ `Iterator::Item` changed to `()` here\n+note: required by a bound in `std::iter::Iterator::sum`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |         S: Sum<Self::Item>,\n+   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n+\n+error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `()`\n+  --> $DIR/invalid-iterator-chain.rs:18:14\n+   |\n+LL |             .sum::<i32>(),\n+   |              ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=()>`\n+   |\n+   = help: the trait `Sum<()>` is not implemented for `i32`\n+   = help: the following other types implement trait `Sum<A>`:\n+             <i32 as Sum<&'a i32>>\n+             <i32 as Sum>\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:12:14\n+   |\n+LL |         vec![0, 1]\n+   |         ---------- this expression has type `Vec<{integer}>`\n+LL |             .iter()\n+   |              ------ `Iterator::Item` is `&{integer}` here\n+LL |             .map(|x| x * 2)\n+   |              ^^^^^^^^^^^^^^ `Iterator::Item` changed to `{integer}` here\n+LL |             .map(|x| x as f64)\n+   |              ----------------- `Iterator::Item` changed to `f64` here\n+LL |             .map(|x| x as i64)\n+   |              ----------------- `Iterator::Item` changed to `i64` here\n+LL |             .filter(|x| *x > 0)\n+   |              ------------------ `Iterator::Item` remains `i64` here\n+LL |             .map(|x| { x + 1 })\n+   |              ------------------ `Iterator::Item` remains `i64` here\n+LL |             .map(|x| { x; })\n+   |              ^^^^^^^^^^^^^^^ `Iterator::Item` changed to `()` here\n+note: required by a bound in `std::iter::Iterator::sum`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |         S: Sum<Self::Item>,\n+   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n+\n+error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `f64`\n+  --> $DIR/invalid-iterator-chain.rs:28:14\n+   |\n+LL |             .sum::<i32>(),\n+   |              ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=f64>`\n+   |\n+   = help: the trait `Sum<f64>` is not implemented for `i32`\n+   = help: the following other types implement trait `Sum<A>`:\n+             <i32 as Sum<&'a i32>>\n+             <i32 as Sum>\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:24:14\n+   |\n+LL |         vec![0, 1]\n+   |         ---------- this expression has type `Vec<{integer}>`\n+LL |             .iter()\n+   |              ------ `Iterator::Item` is `&{integer}` here\n+LL |             .map(|x| x * 2)\n+   |              ^^^^^^^^^^^^^^ `Iterator::Item` changed to `{integer}` here\n+LL |             .map(|x| x as f64)\n+   |              ^^^^^^^^^^^^^^^^^ `Iterator::Item` changed to `f64` here\n+LL |             .filter(|x| *x > 0.0)\n+   |              -------------------- `Iterator::Item` remains `f64` here\n+LL |             .map(|x| { x + 1.0 })\n+   |              -------------------- `Iterator::Item` remains `f64` here\n+note: required by a bound in `std::iter::Iterator::sum`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |         S: Sum<Self::Item>,\n+   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n+\n+error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `()`\n+  --> $DIR/invalid-iterator-chain.rs:30:54\n+   |\n+LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n+   |                                                      ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=()>`\n+   |\n+   = help: the trait `Sum<()>` is not implemented for `i32`\n+   = help: the following other types implement trait `Sum<A>`:\n+             <i32 as Sum<&'a i32>>\n+             <i32 as Sum>\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:30:38\n+   |\n+LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n+   |                    ---------- ------ ^^^^^^^^^^^^^^^ `Iterator::Item` changed to `()` here\n+   |                    |          |\n+   |                    |          `Iterator::Item` is `&{integer}` here\n+   |                    this expression has type `Vec<{integer}>`\n+note: required by a bound in `std::iter::Iterator::sum`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |         S: Sum<Self::Item>,\n+   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n+\n+error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `&()`\n+  --> $DIR/invalid-iterator-chain.rs:31:40\n+   |\n+LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());\n+   |                                        ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=&()>`\n+   |\n+   = help: the trait `Sum<&()>` is not implemented for `i32`\n+   = help: the following other types implement trait `Sum<A>`:\n+             <i32 as Sum<&'a i32>>\n+             <i32 as Sum>\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:31:33\n+   |\n+LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());\n+   |                    ------------ ^^^^^^ `Iterator::Item` is `&()` here\n+   |                    |\n+   |                    this expression has type `Vec<()>`\n+note: required by a bound in `std::iter::Iterator::sum`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |         S: Sum<Self::Item>,\n+   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n+\n+error[E0277]: a value of type `Vec<i32>` cannot be built from an iterator over elements of type `()`\n+  --> $DIR/invalid-iterator-chain.rs:40:25\n+   |\n+LL |     let g: Vec<i32> = f.collect();\n+   |                         ^^^^^^^ value of type `Vec<i32>` cannot be built from `std::iter::Iterator<Item=()>`\n+   |\n+   = help: the trait `FromIterator<()>` is not implemented for `Vec<i32>`\n+   = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:36:15\n+   |\n+LL |       let a = vec![0];\n+   |               ------- this expression has type `Vec<{integer}>`\n+LL |       let b = a.into_iter();\n+   |                 ----------- `Iterator::Item` is `{integer}` here\n+LL |       let c = b.map(|x| x + 1);\n+   |                 -------------- `Iterator::Item` remains `{integer}` here\n+LL |       let d = c.filter(|x| *x > 10 );\n+   |                 -------------------- `Iterator::Item` remains `{integer}` here\n+LL |       let e = d.map(|x| {\n+   |  _______________^\n+LL | |         x + 1;\n+LL | |     });\n+   | |______^ `Iterator::Item` changed to `()` here\n+LL |       let f = e.filter(|_| false);\n+   |                 ----------------- `Iterator::Item` remains `()` here\n+note: required by a bound in `collect`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c66069c4d2570b7fd3e40d962d53c985215aff40", "filename": "src/test/ui/lazy-type-alias-impl-trait/branches.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: a value of type `Bar` cannot be built from an iterator over elements of type `_`\n-  --> $DIR/branches.rs:19:9\n+  --> $DIR/branches.rs:19:28\n    |\n LL |         std::iter::empty().collect()\n-   |         ^^^^^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |         |\n-   |         value of type `Bar` cannot be built from `std::iter::Iterator<Item=_>`\n+   |                            ^^^^^^^ value of type `Bar` cannot be built from `std::iter::Iterator<Item=_>`\n    |\n    = help: the trait `FromIterator<_>` is not implemented for `Bar`\n note: required by a bound in `collect`"}, {"sha": "a92c3a6809eae634d0e44c0d5904c3d3230e04a6", "filename": "src/test/ui/lazy-type-alias-impl-trait/recursion4.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: a value of type `Foo` cannot be built from an iterator over elements of type `_`\n-  --> $DIR/recursion4.rs:10:9\n+  --> $DIR/recursion4.rs:10:28\n    |\n LL |     x = std::iter::empty().collect();\n-   |         ^^^^^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |         |\n-   |         value of type `Foo` cannot be built from `std::iter::Iterator<Item=_>`\n+   |                            ^^^^^^^ value of type `Foo` cannot be built from `std::iter::Iterator<Item=_>`\n    |\n    = help: the trait `FromIterator<_>` is not implemented for `Foo`\n note: required by a bound in `collect`\n@@ -14,12 +12,10 @@ LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n \n error[E0277]: a value of type `impl Debug` cannot be built from an iterator over elements of type `_`\n-  --> $DIR/recursion4.rs:19:9\n+  --> $DIR/recursion4.rs:19:28\n    |\n LL |     x = std::iter::empty().collect();\n-   |         ^^^^^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |         |\n-   |         value of type `impl Debug` cannot be built from `std::iter::Iterator<Item=_>`\n+   |                            ^^^^^^^ value of type `impl Debug` cannot be built from `std::iter::Iterator<Item=_>`\n    |\n    = help: the trait `FromIterator<_>` is not implemented for `impl Debug`\n note: required by a bound in `collect`"}, {"sha": "c2515c40b1d778373235367e02fdfaefb501fb0b", "filename": "src/test/ui/mismatched_types/method-help-unsatisfied-bound.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: `Foo` doesn't implement `Debug`\n-  --> $DIR/method-help-unsatisfied-bound.rs:5:5\n+  --> $DIR/method-help-unsatisfied-bound.rs:5:7\n    |\n LL |     a.unwrap();\n-   |     ^ ------ required by a bound introduced by this call\n-   |     |\n-   |     `Foo` cannot be formatted using `{:?}`\n+   |       ^^^^^^ `Foo` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `Foo`\n    = note: add `#[derive(Debug)]` to `Foo` or manually `impl Debug for Foo`"}, {"sha": "2db1cc4b776905e8fdb3c0086602a1057a91e607", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -5,7 +5,7 @@ LL |     foo(panic!())\n    |     --- ^^^^^^^^\n    |     |   |\n    |     |   the trait `T` is not implemented for `()`\n-   |     |   this tail expression is of type `_`\n+   |     |   this tail expression is of type `()`\n    |     required by a bound introduced by this call\n    |\n note: required by a bound in `foo`"}, {"sha": "37d94cf0ebd8c515e7c1d1db7fb7a01ad1276c34", "filename": "src/test/ui/not-clone-closure.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fnot-clone-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fnot-clone-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnot-clone-closure.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,13 +1,11 @@\n error[E0277]: the trait bound `S: Clone` is not satisfied in `[closure@$DIR/not-clone-closure.rs:7:17: 7:24]`\n-  --> $DIR/not-clone-closure.rs:11:17\n+  --> $DIR/not-clone-closure.rs:11:23\n    |\n LL |     let hello = move || {\n    |                 ------- within this `[closure@$DIR/not-clone-closure.rs:7:17: 7:24]`\n ...\n LL |     let hello = hello.clone();\n-   |                 ^^^^^ ----- required by a bound introduced by this call\n-   |                 |\n-   |                 within `[closure@$DIR/not-clone-closure.rs:7:17: 7:24]`, the trait `Clone` is not implemented for `S`\n+   |                       ^^^^^ within `[closure@$DIR/not-clone-closure.rs:7:17: 7:24]`, the trait `Clone` is not implemented for `S`\n    |\n note: required because it's used within this closure\n   --> $DIR/not-clone-closure.rs:7:17"}, {"sha": "70706541ad650e83391cd526d65c331802c6537d", "filename": "src/test/ui/on-unimplemented/sum.stderr", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fon-unimplemented%2Fsum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fon-unimplemented%2Fsum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fsum.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,33 +1,43 @@\n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `&()`\n-  --> $DIR/sum.rs:4:5\n+  --> $DIR/sum.rs:4:25\n    |\n LL |     vec![(), ()].iter().sum::<i32>();\n-   |     ^^^^^^^^^^^^^^^^^^^ --- required by a bound introduced by this call\n-   |     |\n-   |     value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=&()>`\n+   |                         ^^^ value of type `i32` cannot be made by summing a `std::iter::Iterator<Item=&()>`\n    |\n    = help: the trait `Sum<&()>` is not implemented for `i32`\n    = help: the following other types implement trait `Sum<A>`:\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/sum.rs:4:18\n+   |\n+LL |     vec![(), ()].iter().sum::<i32>();\n+   |     ------------ ^^^^^^ `Iterator::Item` is `&()` here\n+   |     |\n+   |     this expression has type `Vec<()>`\n note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |\n LL |         S: Sum<Self::Item>,\n    |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n \n error[E0277]: a value of type `i32` cannot be made by multiplying all elements of type `&()` from an iterator\n-  --> $DIR/sum.rs:7:5\n+  --> $DIR/sum.rs:7:25\n    |\n LL |     vec![(), ()].iter().product::<i32>();\n-   |     ^^^^^^^^^^^^^^^^^^^ ------- required by a bound introduced by this call\n-   |     |\n-   |     value of type `i32` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&()>`\n+   |                         ^^^^^^^ value of type `i32` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&()>`\n    |\n    = help: the trait `Product<&()>` is not implemented for `i32`\n    = help: the following other types implement trait `Product<A>`:\n              <i32 as Product<&'a i32>>\n              <i32 as Product>\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/sum.rs:7:18\n+   |\n+LL |     vec![(), ()].iter().product::<i32>();\n+   |     ------------ ^^^^^^ `Iterator::Item` is `&()` here\n+   |     |\n+   |     this expression has type `Vec<()>`\n note: required by a bound in `std::iter::Iterator::product`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |"}, {"sha": "f9d0d1f7875fb891b4016ed2078de369beeecca8", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-default-method-bodies.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `NonConstImpl: ~const ConstDefaultFn` is not satisfied\n-  --> $DIR/const-default-method-bodies.rs:24:5\n+  --> $DIR/const-default-method-bodies.rs:24:18\n    |\n LL |     NonConstImpl.a();\n-   |     ^^^^^^^^^^^^ - required by a bound introduced by this call\n-   |     |\n-   |     the trait `~const ConstDefaultFn` is not implemented for `NonConstImpl`\n+   |                  ^ the trait `~const ConstDefaultFn` is not implemented for `NonConstImpl`\n    |\n note: the trait `ConstDefaultFn` is implemented for `NonConstImpl`, but that implementation is not `const`\n   --> $DIR/const-default-method-bodies.rs:24:5"}, {"sha": "633b7cc255a52a817a20a02d03afbdf079247331", "filename": "src/test/ui/rfc-2632-const-trait-impl/cross-crate.gatednc.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.gatednc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.gatednc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.gatednc.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `cross_crate::NonConst: ~const cross_crate::MyTrait` is not satisfied\n-  --> $DIR/cross-crate.rs:17:5\n+  --> $DIR/cross-crate.rs:17:14\n    |\n LL |     NonConst.func();\n-   |     ^^^^^^^^ ---- required by a bound introduced by this call\n-   |     |\n-   |     the trait `~const cross_crate::MyTrait` is not implemented for `cross_crate::NonConst`\n+   |              ^^^^ the trait `~const cross_crate::MyTrait` is not implemented for `cross_crate::NonConst`\n    |\n note: the trait `cross_crate::MyTrait` is implemented for `cross_crate::NonConst`, but that implementation is not `const`\n   --> $DIR/cross-crate.rs:17:5"}, {"sha": "9e97d3f11376014a3f08bd9eb596d664e70c0e4a", "filename": "src/test/ui/rfc-2632-const-trait-impl/cross-crate.stocknc.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.stocknc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.stocknc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.stocknc.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `cross_crate::NonConst: cross_crate::MyTrait` is not satisfied\n-  --> $DIR/cross-crate.rs:17:5\n+  --> $DIR/cross-crate.rs:17:14\n    |\n LL |     NonConst.func();\n-   |     ^^^^^^^^ ---- required by a bound introduced by this call\n-   |     |\n-   |     the trait `~const cross_crate::MyTrait` is not implemented for `cross_crate::NonConst`\n+   |              ^^^^ the trait `~const cross_crate::MyTrait` is not implemented for `cross_crate::NonConst`\n    |\n note: the trait `cross_crate::MyTrait` is implemented for `cross_crate::NonConst`, but that implementation is not `const`\n   --> $DIR/cross-crate.rs:17:5"}, {"sha": "21ecddaffbb6517c64933d1c5114bed8bd42eb38", "filename": "src/test/ui/rfc-2632-const-trait-impl/default-method-body-is-const-same-trait-ck.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `(): ~const Tr` is not satisfied\n-  --> $DIR/default-method-body-is-const-same-trait-ck.rs:8:9\n+  --> $DIR/default-method-body-is-const-same-trait-ck.rs:8:12\n    |\n LL |         ().a()\n-   |         ^^ - required by a bound introduced by this call\n-   |         |\n-   |         the trait `~const Tr` is not implemented for `()`\n+   |            ^ the trait `~const Tr` is not implemented for `()`\n    |\n note: the trait `Tr` is implemented for `()`, but that implementation is not `const`\n   --> $DIR/default-method-body-is-const-same-trait-ck.rs:8:9"}, {"sha": "13fc719f28c5c2ad681a357c78c1df7170f691d7", "filename": "src/test/ui/rfc-2632-const-trait-impl/super-traits-fail-2.yn.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.yn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.yn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.yn.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `T: ~const Foo` is not satisfied\n-  --> $DIR/super-traits-fail-2.rs:15:5\n+  --> $DIR/super-traits-fail-2.rs:15:7\n    |\n LL |     x.a();\n-   |     ^ - required by a bound introduced by this call\n-   |     |\n-   |     the trait `~const Foo` is not implemented for `T`\n+   |       ^ the trait `~const Foo` is not implemented for `T`\n    |\n note: the trait `Foo` is implemented for `T`, but that implementation is not `const`\n   --> $DIR/super-traits-fail-2.rs:15:5"}, {"sha": "13fc719f28c5c2ad681a357c78c1df7170f691d7", "filename": "src/test/ui/rfc-2632-const-trait-impl/super-traits-fail-2.yy.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.yy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.yy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsuper-traits-fail-2.yy.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `T: ~const Foo` is not satisfied\n-  --> $DIR/super-traits-fail-2.rs:15:5\n+  --> $DIR/super-traits-fail-2.rs:15:7\n    |\n LL |     x.a();\n-   |     ^ - required by a bound introduced by this call\n-   |     |\n-   |     the trait `~const Foo` is not implemented for `T`\n+   |       ^ the trait `~const Foo` is not implemented for `T`\n    |\n note: the trait `Foo` is implemented for `T`, but that implementation is not `const`\n   --> $DIR/super-traits-fail-2.rs:15:5"}, {"sha": "a5e6f5b5ffcb0a40fa7a4041ea1baff58bdd7042", "filename": "src/test/ui/suggestions/issue-71394-no-from-impl.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `&[i8]: From<&[u8]>` is not satisfied\n-  --> $DIR/issue-71394-no-from-impl.rs:3:20\n+  --> $DIR/issue-71394-no-from-impl.rs:3:25\n    |\n LL |     let _: &[i8] = data.into();\n-   |                    ^^^^ ---- required by a bound introduced by this call\n-   |                    |\n-   |                    the trait `From<&[u8]>` is not implemented for `&[i8]`\n+   |                         ^^^^ the trait `From<&[u8]>` is not implemented for `&[i8]`\n    |\n    = help: the following other types implement trait `From<T>`:\n              <[T; LANES] as From<Simd<T, LANES>>>"}, {"sha": "9062a0fab630a3103d5e8ac839e5b1a54dd90b40", "filename": "src/test/ui/traits/issue-97576.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Ftraits%2Fissue-97576.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Ftraits%2Fissue-97576.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-97576.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `String: From<impl ToString>` is not satisfied\n-  --> $DIR/issue-97576.rs:8:18\n+  --> $DIR/issue-97576.rs:8:22\n    |\n LL |             bar: bar.into(),\n-   |                  ^^^ ---- required by a bound introduced by this call\n-   |                  |\n-   |                  the trait `From<impl ToString>` is not implemented for `String`\n+   |                      ^^^^ the trait `From<impl ToString>` is not implemented for `String`\n    |\n    = note: required for `impl ToString` to implement `Into<String>`\n "}, {"sha": "d7b95f55769fdc600f7b37ff9ec22b43e9844215", "filename": "src/test/ui/unsized/issue-71659.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Funsized%2Fissue-71659.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8917cc0f23f97e42e652f9130b7daa6a48193cef/src%2Ftest%2Fui%2Funsized%2Fissue-71659.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fissue-71659.stderr?ref=8917cc0f23f97e42e652f9130b7daa6a48193cef", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `dyn Foo: CastTo<[i32]>` is not satisfied\n-  --> $DIR/issue-71659.rs:30:13\n+  --> $DIR/issue-71659.rs:30:15\n    |\n LL |     let x = x.cast::<[i32]>();\n-   |             ^ ---- required by a bound introduced by this call\n-   |             |\n-   |             the trait `CastTo<[i32]>` is not implemented for `dyn Foo`\n+   |               ^^^^ the trait `CastTo<[i32]>` is not implemented for `dyn Foo`\n    |\n note: required by a bound in `Cast::cast`\n   --> $DIR/issue-71659.rs:19:15"}]}