{"sha": "f479404b12ad5ca9b163a591a708ae7be63f402d", "node_id": "C_kwDOAAsO6NoAKGY0Nzk0MDRiMTJhZDVjYTliMTYzYTU5MWE3MDhhZTdiZTYzZjQwMmQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-26T12:22:19Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-26T23:03:07Z"}, "message": "!Unpin retags must still be reads, to check dereferenceable\n\nalso fix ICE on deallocation error and avoid redundant find_granting on retag", "tree": {"sha": "37977977d85f6767323f8d82b04d1ad78ba2215c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37977977d85f6767323f8d82b04d1ad78ba2215c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f479404b12ad5ca9b163a591a708ae7be63f402d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f479404b12ad5ca9b163a591a708ae7be63f402d", "html_url": "https://github.com/rust-lang/rust/commit/f479404b12ad5ca9b163a591a708ae7be63f402d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f479404b12ad5ca9b163a591a708ae7be63f402d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d0db1efdb3aafcfcd1864654ea4d58024b579f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d0db1efdb3aafcfcd1864654ea4d58024b579f2", "html_url": "https://github.com/rust-lang/rust/commit/7d0db1efdb3aafcfcd1864654ea4d58024b579f2"}], "stats": {"total": 208, "additions": 151, "deletions": 57}, "files": [{"sha": "9970b79f8c7f17838822938cba38c4dbd3a541b2", "filename": "src/tools/miri/src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f479404b12ad5ca9b163a591a708ae7be63f402d/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f479404b12ad5ca9b163a591a708ae7be63f402d/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs?ref=f479404b12ad5ca9b163a591a708ae7be63f402d", "patch": "@@ -353,10 +353,12 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n \n     /// Report a descriptive error when `new` could not be granted from `derived_from`.\n     #[inline(never)] // This is only called on fatal code paths\n-    pub(super) fn grant_error(&self, perm: Permission, stack: &Stack) -> InterpError<'tcx> {\n+    pub(super) fn grant_error(&self, stack: &Stack) -> InterpError<'tcx> {\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"grant_error should only be called during a retag\")\n         };\n+        let perm =\n+            op.permission.expect(\"`start_grant` must be called before calling `grant_error`\");\n         let action = format!(\n             \"trying to retag from {:?} for {:?} permission at {:?}[{:#x}]\",\n             op.orig_tag,\n@@ -374,8 +376,11 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n     /// Report a descriptive error when `access` is not permitted based on `tag`.\n     #[inline(never)] // This is only called on fatal code paths\n     pub(super) fn access_error(&self, stack: &Stack) -> InterpError<'tcx> {\n-        let Operation::Access(op) = &self.operation  else {\n-            unreachable!(\"access_error should only be called during an access\")\n+        // Deallocation and retagging also do an access as part of their thing, so handle that here, too.\n+        let op = match &self.operation {\n+            Operation::Access(op) => op,\n+            Operation::Retag(_) => return self.grant_error(stack),\n+            Operation::Dealloc(_) => return self.dealloc_error(stack),\n         };\n         let action = format!(\n             \"attempting a {access} using {tag:?} at {alloc_id:?}[{offset:#x}]\",\n@@ -428,14 +433,16 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n     }\n \n     #[inline(never)] // This is only called on fatal code paths\n-    pub fn dealloc_error(&self) -> InterpError<'tcx> {\n+    pub fn dealloc_error(&self, stack: &Stack) -> InterpError<'tcx> {\n         let Operation::Dealloc(op) = &self.operation else {\n             unreachable!(\"dealloc_error should only be called during a deallocation\")\n         };\n         err_sb_ub(\n             format!(\n-                \"no item granting write access for deallocation to tag {:?} at {:?} found in borrow stack\",\n-                op.tag, self.history.id,\n+                \"attempting deallocation using {tag:?} at {alloc_id:?}{cause}\",\n+                tag = op.tag,\n+                alloc_id = self.history.id,\n+                cause = error_cause(stack, op.tag),\n             ),\n             None,\n             op.tag.and_then(|tag| self.get_logs_relevant_to(tag, None)),"}, {"sha": "1759eee35855ed9a8bad9663bd0e78e615c521aa", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 47, "deletions": 49, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f479404b12ad5ca9b163a591a708ae7be63f402d/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f479404b12ad5ca9b163a591a708ae7be63f402d/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=f479404b12ad5ca9b163a591a708ae7be63f402d", "patch": "@@ -392,7 +392,7 @@ impl<'tcx> Stack {\n \n         // Step 1: Find granting item.\n         let granting_idx =\n-            self.find_granting(access, tag, exposed_tags).map_err(|_| dcx.access_error(self))?;\n+            self.find_granting(access, tag, exposed_tags).map_err(|()| dcx.access_error(self))?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n@@ -476,8 +476,7 @@ impl<'tcx> Stack {\n     ) -> InterpResult<'tcx> {\n         // Step 1: Make a write access.\n         // As part of this we do regular protector checking, i.e. even weakly protected items cause UB when popped.\n-        self.access(AccessKind::Write, tag, global, dcx, exposed_tags)\n-            .map_err(|_| dcx.dealloc_error())?;\n+        self.access(AccessKind::Write, tag, global, dcx, exposed_tags)?;\n \n         // Step 2: Pretend we remove the remaining items, checking if any are strongly protected.\n         for idx in (0..self.len()).rev() {\n@@ -489,39 +488,42 @@ impl<'tcx> Stack {\n     }\n \n     /// Derive a new pointer from one with the given tag.\n-    /// `weak` controls whether this operation is weak or strong: weak granting does not act as\n-    /// an access, and they add the new item directly on top of the one it is derived\n-    /// from instead of all the way at the top of the stack.\n-    /// `range` refers the entire operation, and `offset` refers to the specific location in\n-    /// `range` that we are currently checking.\n+    ///\n+    /// `access` indicates which kind of memory access this retag itself should correspond to.\n     fn grant(\n         &mut self,\n         derived_from: ProvenanceExtra,\n         new: Item,\n+        access: Option<AccessKind>,\n         global: &GlobalStateInner,\n         dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         dcx.start_grant(new.perm());\n \n-        // Figure out which access `perm` corresponds to.\n-        let access =\n-            if new.perm().grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n-\n-        // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n-        // We use that to determine where to put the new item.\n-        let granting_idx = self\n-            .find_granting(access, derived_from, exposed_tags)\n-            .map_err(|_| dcx.grant_error(new.perm(), self))?;\n-\n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between\n         // `derived_from` and the new one, there are only items *compatible with* `derived_from`.\n-        let new_idx = if new.perm() == Permission::SharedReadWrite {\n-            assert!(\n-                access == AccessKind::Write,\n-                \"this case only makes sense for stack-like accesses\"\n-            );\n+        let new_idx = if let Some(access) = access {\n+            // Simple case: We are just a regular memory access, and then push our thing on top,\n+            // like a regular stack.\n+            // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n+            self.access(access, derived_from, global, dcx, exposed_tags)?;\n+\n+            // We insert \"as far up as possible\": We know only compatible items are remaining\n+            // on top of `derived_from`, and we want the new item at the top so that we\n+            // get the strongest possible guarantees.\n+            // This ensures U1 and F1.\n+            self.len()\n+        } else {\n+            // The tricky case: creating a new SRW permission without actually being an access.\n+            assert!(new.perm() == Permission::SharedReadWrite);\n+\n+            // First we figure out which item grants our parent (`derived_from`) this kind of access.\n+            // We use that to determine where to put the new item.\n+            let granting_idx = self\n+                .find_granting(AccessKind::Write, derived_from, exposed_tags)\n+                .map_err(|()| dcx.grant_error(self))?;\n \n             let (Some(granting_idx), ProvenanceExtra::Concrete(_)) = (granting_idx, derived_from) else {\n                 // The parent is a wildcard pointer or matched the unknown bottom.\n@@ -538,17 +540,6 @@ impl<'tcx> Stack {\n             // be popped to (i.e., we insert it above all the write-compatible items).\n             // This ensures F2b by adding the new item below any potentially existing `SharedReadOnly`.\n             self.find_first_write_incompatible(granting_idx)\n-        } else {\n-            // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n-            // Here, creating a reference actually counts as an access.\n-            // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n-            self.access(access, derived_from, global, dcx, exposed_tags)?;\n-\n-            // We insert \"as far up as possible\": We know only compatible items are remaining\n-            // on top of `derived_from`, and we want the new item at the top so that we\n-            // get the strongest possible guarantees.\n-            // This ensures U1 and F1.\n-            self.len()\n         };\n \n         // Put the new item there.\n@@ -864,18 +855,22 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n-        let perm = match kind {\n-            RefKind::Unique { two_phase: false }\n-                if place.layout.ty.is_unpin(*this.tcx, this.param_env()) =>\n-            {\n-                // Only if the type is unpin do we actually enforce uniqueness\n-                Permission::Unique\n+        let (perm, access) = match kind {\n+            RefKind::Unique { two_phase } => {\n+                // Permission is Unique only if the type is `Unpin` and this is not twophase\n+                let perm = if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n+                    Permission::Unique\n+                } else {\n+                    Permission::SharedReadWrite\n+                };\n+                // We do an access for all full borrows, even if `!Unpin`.\n+                let access = if !two_phase { Some(AccessKind::Write) } else { None };\n+                (perm, access)\n             }\n-            RefKind::Unique { .. } => {\n-                // Two-phase references and !Unpin references are treated as SharedReadWrite\n-                Permission::SharedReadWrite\n+            RefKind::Raw { mutable: true } => {\n+                // Creating a raw ptr does not count as an access\n+                (Permission::SharedReadWrite, None)\n             }\n-            RefKind::Raw { mutable: true } => Permission::SharedReadWrite,\n             RefKind::Shared | RefKind::Raw { mutable: false } => {\n                 // Shared references and *const are a whole different kind of game, the\n                 // permission is not uniform across the entire range!\n@@ -892,10 +887,13 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     // Adjust range.\n                     range.start += base_offset;\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n-                    let perm = if frozen {\n-                        Permission::SharedReadOnly\n+                    let (perm, access) = if frozen {\n+                        (Permission::SharedReadOnly, Some(AccessKind::Read))\n                     } else {\n-                        Permission::SharedReadWrite\n+                        // Inside UnsafeCell, this does *not* count as an access, as there\n+                        // might actually be mutable references further up the stack that\n+                        // we have to keep alive.\n+                        (Permission::SharedReadWrite, None)\n                     };\n                     let protected = if frozen {\n                         protect.is_some()\n@@ -914,7 +912,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                         alloc_range(base_offset, size),\n                     );\n                     stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-                        stack.grant(orig_tag, item, &global, dcx, exposed_tags)\n+                        stack.grant(orig_tag, item, access, &global, dcx, exposed_tags)\n                     })\n                 })?;\n                 return Ok(Some(alloc_id));\n@@ -941,7 +939,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             alloc_range(base_offset, size),\n         );\n         stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-            stack.grant(orig_tag, item, &global, dcx, exposed_tags)\n+            stack.grant(orig_tag, item, access, &global, dcx, exposed_tags)\n         })?;\n \n         Ok(Some(alloc_id))"}, {"sha": "51a6fba6df01144d50b166bddd2f9f5a6b5033d1", "filename": "src/tools/miri/src/stacked_borrows/stack.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f479404b12ad5ca9b163a591a708ae7be63f402d/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f479404b12ad5ca9b163a591a708ae7be63f402d/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs?ref=f479404b12ad5ca9b163a591a708ae7be63f402d", "patch": "@@ -367,10 +367,10 @@ impl<'tcx> Stack {\n \n     /// Find all `Unique` elements in this borrow stack above `granting_idx`, pass a copy of them\n     /// to the `visitor`, then set their `Permission` to `Disabled`.\n-    pub fn disable_uniques_starting_at<V: FnMut(Item) -> crate::InterpResult<'tcx>>(\n+    pub fn disable_uniques_starting_at(\n         &mut self,\n         disable_start: usize,\n-        mut visitor: V,\n+        mut visitor: impl FnMut(Item) -> crate::InterpResult<'tcx>,\n     ) -> crate::InterpResult<'tcx> {\n         #[cfg(feature = \"stack-cache\")]\n         let unique_range = self.unique_range.clone();"}, {"sha": "670dd4baad8bc675d69194a61842009bb19578c3", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_dealloc1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f479404b12ad5ca9b163a591a708ae7be63f402d/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f479404b12ad5ca9b163a591a708ae7be63f402d/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.rs?ref=f479404b12ad5ca9b163a591a708ae7be63f402d", "patch": "@@ -0,0 +1,14 @@\n+//@error-pattern: /deallocation .* tag does not exist in the borrow stack/\n+use std::alloc::{alloc, dealloc, Layout};\n+\n+fn main() {\n+    unsafe {\n+        let x = alloc(Layout::from_size_align_unchecked(1, 1));\n+        let ptr1 = (&mut *x) as *mut u8;\n+        let ptr2 = (&mut *ptr1) as *mut u8;\n+        // Invalidate ptr2 by writing to ptr1.\n+        ptr1.write(0);\n+        // Deallocate through ptr2.\n+        dealloc(ptr2, Layout::from_size_align_unchecked(1, 1));\n+    }\n+}"}, {"sha": "3b7802901a54eb723ddf23ae38b9b557d1772a2c", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_dealloc1.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f479404b12ad5ca9b163a591a708ae7be63f402d/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f479404b12ad5ca9b163a591a708ae7be63f402d/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr?ref=f479404b12ad5ca9b163a591a708ae7be63f402d", "patch": "@@ -0,0 +1,30 @@\n+error: Undefined Behavior: attempting deallocation using <TAG> at ALLOC, but that tag does not exist in the borrow stack for this location\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempting deallocation using <TAG> at ALLOC, but that tag does not exist in the borrow stack for this location\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x1]\n+  --> $DIR/illegal_deALLOC.rs:LL:CC\n+   |\n+LL |         let ptr2 = (&mut *ptr1) as *mut u8;\n+   |                    ^^^^^^^^^^^^\n+help: <TAG> was later invalidated at offsets [0x0..0x1] by a write access\n+  --> $DIR/illegal_deALLOC.rs:LL:CC\n+   |\n+LL |         ptr1.write(0);\n+   |         ^^^^^^^^^^^^^\n+   = note: BACKTRACE:\n+   = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+note: inside `main` at $DIR/illegal_deALLOC.rs:LL:CC\n+  --> $DIR/illegal_deALLOC.rs:LL:CC\n+   |\n+LL |         dealloc(ptr2, Layout::from_size_align_unchecked(1, 1));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "d660921bfe6e2d4755bb18e3c79e8da602fd707a", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f479404b12ad5ca9b163a591a708ae7be63f402d/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f479404b12ad5ca9b163a591a708ae7be63f402d/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs?ref=f479404b12ad5ca9b163a591a708ae7be63f402d", "patch": "@@ -0,0 +1,17 @@\n+//! Reborrowing a `&mut !Unpin` must still act like a (fake) read.\n+use std::marker::PhantomPinned;\n+\n+struct NotUnpin(i32, PhantomPinned);\n+\n+fn main() {\n+    unsafe {\n+        let mut x = NotUnpin(0, PhantomPinned);\n+        // Mutable borrow of `Unpin` field (with lifetime laundering)\n+        let fieldref = &mut *(&mut x.0 as *mut i32);\n+        // Mutable reborrow of the entire `x`, which is `!Unpin` but should\n+        // still count as a read since we would add `dereferenceable`.\n+        let _xref = &mut x;\n+        // That read should have invalidated `fieldref`.\n+        *fieldref = 0; //~ ERROR: /write access .* tag does not exist in the borrow stack/\n+    }\n+}"}, {"sha": "3ef8a8e0e9c6a8939975bc3829fbd16e50092577", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f479404b12ad5ca9b163a591a708ae7be63f402d/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f479404b12ad5ca9b163a591a708ae7be63f402d/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr?ref=f479404b12ad5ca9b163a591a708ae7be63f402d", "patch": "@@ -0,0 +1,28 @@\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+   |\n+LL |         *fieldref = 0;\n+   |         ^^^^^^^^^^^^^\n+   |         |\n+   |         attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |         this error occurs as part of an access at ALLOC[0x0..0x4]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n+  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+   |\n+LL |         let fieldref = &mut *(&mut x.0 as *mut i32);\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a SharedReadWrite retag\n+  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+   |\n+LL |         let _xref = &mut x;\n+   |                     ^^^^^^\n+   = note: BACKTRACE:\n+   = note: inside `main` at $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}]}