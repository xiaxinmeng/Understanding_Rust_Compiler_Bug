{"sha": "b4c340e4bb246572029d235e46850faa9823d312", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YzM0MGU0YmIyNDY1NzIwMjlkMjM1ZTQ2ODUwZmFhOTgyM2QzMTI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-14T20:00:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-14T20:00:13Z"}, "message": "Rollup merge of #60444 - nikomatsakis:issue-60010-cycle-error-investigation, r=pnkfelix\n\nforego caching for all participants in cycles, apart from root node\n\nThis is a targeted fix for #60010, which uncovered a pretty bad failure of our caching strategy in the face of coinductive cycles. The problem is explained in the comment in the PR on the new field, `in_cycle`, but I'll reproduce it here:\n\n> Starts out as false -- if, during evaluation, we encounter a\n> cycle, then we will set this flag to true for all participants\n> in the cycle (apart from the \"head\" node). These participants\n> will then forego caching their results. This is not the most\n> efficient solution, but it addresses #60010. The problem we\n> are trying to prevent:\n>\n> - If you have `A: AutoTrait` requires `B: AutoTrait` and `C: NonAutoTrait`\n> - `B: AutoTrait` requires `A: AutoTrait` (coinductive cycle, ok)\n> - `C: NonAutoTrait` requires `A: AutoTrait` (non-coinductive cycle, not ok)\n>\n> you don't want to cache that `B: AutoTrait` or `A: AutoTrait`\n> is `EvaluatedToOk`; this is because they were only considered\n> ok on the premise that if `A: AutoTrait` held, but we indeed\n> encountered a problem (later on) with `A: AutoTrait. So we\n> currently set a flag on the stack node for `B: AutoTrait` (as\n> well as the second instance of `A: AutoTrait`) to supress\n> caching.\n>\n> This is a simple, targeted fix. The correct fix requires\n> deeper changes, but would permit more caching: we could\n> basically defer caching until we have fully evaluated the\n> tree, and then cache the entire tree at once.\n\nI'm not sure what the impact of this fix will be in terms of existing crates or performance: we were accepting incorrect code before, so there will perhaps be some regressions, and we are now caching less.\n\nAs the comment above notes, we could do a lot better than this fix, but that would involve more invasive rewrites. I thought it best to start with something simple.\n\nr? @pnkfelix -- but let's do crater/perf run\ncc @arielb1", "tree": {"sha": "6d4a00e80c0285020fe513ec4c0f9ec1bb39a34f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d4a00e80c0285020fe513ec4c0f9ec1bb39a34f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4c340e4bb246572029d235e46850faa9823d312", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc2x5NCRBK7hj4Ov3rIwAAdHIIAGYz83lMqW0d6f4gsB7JbiMH\n9GzFIIIOEaUE45OYtnD4xFXhCSasX99ZvpOa36vtAZ2rOhf6VY3LRfybPG4XmCk+\nqfQZp1jHabJa0nn2cfdV6pXa5m/yURDCncRqnYmXOtSEB5ivjuEqzAFvz4U1l3v5\njlTDrF0mwcqn/nkQErrv3qIX0uhWrJ1tfswAU6K3tDbEvwjf3Q4/jVec90rTlrZD\n+NfBzxVpT0Vm63Ylnb3vndBY9Zvd/IMYhRmB8G35yHDIig9Zvqwfk8rlhXZhuTrt\nwNokrWO/dOlfpVx8fB1Rs0+2iJCHLzlB79fuaz6QPcWHca/xPxJGw2UDziIsQwE=\n=qcHH\n-----END PGP SIGNATURE-----\n", "payload": "tree 6d4a00e80c0285020fe513ec4c0f9ec1bb39a34f\nparent 088c99410b8516a4fc639507ab6c27184875d005\nparent decd6d366018823a8b1116b346bc778eb010accd\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1557864013 +0200\ncommitter GitHub <noreply@github.com> 1557864013 +0200\n\nRollup merge of #60444 - nikomatsakis:issue-60010-cycle-error-investigation, r=pnkfelix\n\nforego caching for all participants in cycles, apart from root node\n\nThis is a targeted fix for #60010, which uncovered a pretty bad failure of our caching strategy in the face of coinductive cycles. The problem is explained in the comment in the PR on the new field, `in_cycle`, but I'll reproduce it here:\n\n> Starts out as false -- if, during evaluation, we encounter a\n> cycle, then we will set this flag to true for all participants\n> in the cycle (apart from the \"head\" node). These participants\n> will then forego caching their results. This is not the most\n> efficient solution, but it addresses #60010. The problem we\n> are trying to prevent:\n>\n> - If you have `A: AutoTrait` requires `B: AutoTrait` and `C: NonAutoTrait`\n> - `B: AutoTrait` requires `A: AutoTrait` (coinductive cycle, ok)\n> - `C: NonAutoTrait` requires `A: AutoTrait` (non-coinductive cycle, not ok)\n>\n> you don't want to cache that `B: AutoTrait` or `A: AutoTrait`\n> is `EvaluatedToOk`; this is because they were only considered\n> ok on the premise that if `A: AutoTrait` held, but we indeed\n> encountered a problem (later on) with `A: AutoTrait. So we\n> currently set a flag on the stack node for `B: AutoTrait` (as\n> well as the second instance of `A: AutoTrait`) to supress\n> caching.\n>\n> This is a simple, targeted fix. The correct fix requires\n> deeper changes, but would permit more caching: we could\n> basically defer caching until we have fully evaluated the\n> tree, and then cache the entire tree at once.\n\nI'm not sure what the impact of this fix will be in terms of existing crates or performance: we were accepting incorrect code before, so there will perhaps be some regressions, and we are now caching less.\n\nAs the comment above notes, we could do a lot better than this fix, but that would involve more invasive rewrites. I thought it best to start with something simple.\n\nr? @pnkfelix -- but let's do crater/perf run\ncc @arielb1\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4c340e4bb246572029d235e46850faa9823d312", "html_url": "https://github.com/rust-lang/rust/commit/b4c340e4bb246572029d235e46850faa9823d312", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4c340e4bb246572029d235e46850faa9823d312/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "088c99410b8516a4fc639507ab6c27184875d005", "url": "https://api.github.com/repos/rust-lang/rust/commits/088c99410b8516a4fc639507ab6c27184875d005", "html_url": "https://github.com/rust-lang/rust/commit/088c99410b8516a4fc639507ab6c27184875d005"}, {"sha": "decd6d366018823a8b1116b346bc778eb010accd", "url": "https://api.github.com/repos/rust-lang/rust/commits/decd6d366018823a8b1116b346bc778eb010accd", "html_url": "https://github.com/rust-lang/rust/commit/decd6d366018823a8b1116b346bc778eb010accd"}], "stats": {"total": 146, "additions": 144, "deletions": 2}, "files": [{"sha": "c4be85050dbc2a04b9a82ef2c70bc419458ca0c9", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b4c340e4bb246572029d235e46850faa9823d312/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4c340e4bb246572029d235e46850faa9823d312/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b4c340e4bb246572029d235e46850faa9823d312", "patch": "@@ -43,6 +43,7 @@ use crate::hir;\n use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::Lock;\n use rustc_target::spec::abi::Abi;\n+use std::cell::Cell;\n use std::cmp;\n use std::fmt::{self, Display};\n use std::iter;\n@@ -153,6 +154,36 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n     /// selection-context's freshener. Used to check for recursion.\n     fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n \n+    /// Starts out as false -- if, during evaluation, we encounter a\n+    /// cycle, then we will set this flag to true for all participants\n+    /// in the cycle (apart from the \"head\" node). These participants\n+    /// will then forego caching their results. This is not the most\n+    /// efficient solution, but it addresses #60010. The problem we\n+    /// are trying to prevent:\n+    ///\n+    /// - If you have `A: AutoTrait` requires `B: AutoTrait` and `C: NonAutoTrait`\n+    /// - `B: AutoTrait` requires `A: AutoTrait` (coinductive cycle, ok)\n+    /// - `C: NonAutoTrait` requires `A: AutoTrait` (non-coinductive cycle, not ok)\n+    ///\n+    /// you don't want to cache that `B: AutoTrait` or `A: AutoTrait`\n+    /// is `EvaluatedToOk`; this is because they were only considered\n+    /// ok on the premise that if `A: AutoTrait` held, but we indeed\n+    /// encountered a problem (later on) with `A: AutoTrait. So we\n+    /// currently set a flag on the stack node for `B: AutoTrait` (as\n+    /// well as the second instance of `A: AutoTrait`) to supress\n+    /// caching.\n+    ///\n+    /// This is a simple, targeted fix. A more-performant fix requires\n+    /// deeper changes, but would permit more caching: we could\n+    /// basically defer caching until we have fully evaluated the\n+    /// tree, and then cache the entire tree at once. In any case, the\n+    /// performance impact here shouldn't be so horrible: every time\n+    /// this is hit, we do cache at least one trait, so we only\n+    /// evaluate each member of a cycle up to N times, where N is the\n+    /// length of the cycle. This means the performance impact is\n+    /// bounded and we shouldn't have any terrible worst-cases.\n+    in_cycle: Cell<bool>,\n+\n     previous: TraitObligationStackList<'prev, 'tcx>,\n }\n \n@@ -840,8 +871,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let (result, dep_node) = self.in_task(|this| this.evaluate_stack(&stack));\n         let result = result?;\n \n-        debug!(\"CACHE MISS: EVAL({:?})={:?}\", fresh_trait_ref, result);\n-        self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n+        if !stack.in_cycle.get() {\n+            debug!(\"CACHE MISS: EVAL({:?})={:?}\", fresh_trait_ref, result);\n+            self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n+        } else {\n+            debug!(\n+                \"evaluate_trait_predicate_recursively: skipping cache because {:?} \\\n+                 is a cycle participant\",\n+                fresh_trait_ref,\n+            );\n+        }\n \n         Ok(result)\n     }\n@@ -948,6 +987,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         {\n             debug!(\"evaluate_stack({:?}) --> recursive\", stack.fresh_trait_ref);\n \n+            // If we have a stack like `A B C D E A`, where the top of\n+            // the stack is the final `A`, then this will iterate over\n+            // `A, E, D, C, B` -- i.e., all the participants apart\n+            // from the cycle head. We mark them as participating in a\n+            // cycle. This suppresses caching for those nodes. See\n+            // `in_cycle` field for more details.\n+            for item in stack.iter().take(rec_index + 1) {\n+                debug!(\"evaluate_stack: marking {:?} as cycle participant\", item.fresh_trait_ref);\n+                item.in_cycle.set(true);\n+            }\n+\n             // Subtle: when checking for a coinductive cycle, we do\n             // not compare using the \"freshened trait refs\" (which\n             // have erased regions) but rather the fully explicit\n@@ -3690,6 +3740,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         TraitObligationStack {\n             obligation,\n             fresh_trait_ref,\n+            in_cycle: Cell::new(false),\n             previous: previous_stack,\n         }\n     }"}, {"sha": "45aa1b3c52239e5ebe5f923c3f381951545fd8b7", "filename": "src/test/ui/traits/cycle-cache-err-60010.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b4c340e4bb246572029d235e46850faa9823d312/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4c340e4bb246572029d235e46850faa9823d312/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs?ref=b4c340e4bb246572029d235e46850faa9823d312", "patch": "@@ -0,0 +1,71 @@\n+// Test that we properly detect the cycle amongst the traits\n+// here and report an error.\n+\n+use std::panic::RefUnwindSafe;\n+\n+trait Database {\n+    type Storage;\n+}\n+trait HasQueryGroup {}\n+trait Query<DB> {\n+    type Data;\n+}\n+trait SourceDatabase {\n+    fn parse(&self) {\n+        loop {}\n+    }\n+}\n+\n+struct ParseQuery;\n+struct RootDatabase {\n+    _runtime: Runtime<RootDatabase>,\n+}\n+struct Runtime<DB: Database> {\n+    _storage: Box<DB::Storage>,\n+}\n+struct SalsaStorage {\n+    _parse: <ParseQuery as Query<RootDatabase>>::Data, //~ ERROR overflow\n+}\n+\n+impl Database for RootDatabase { //~ ERROR overflow\n+    type Storage = SalsaStorage;\n+}\n+impl HasQueryGroup for RootDatabase {}\n+impl<DB> Query<DB> for ParseQuery\n+where\n+    DB: SourceDatabase,\n+    DB: Database,\n+{\n+    type Data = RootDatabase;\n+}\n+impl<T> SourceDatabase for T\n+where\n+    T: RefUnwindSafe,\n+    T: HasQueryGroup,\n+{\n+}\n+\n+pub(crate) fn goto_implementation(db: &RootDatabase) -> u32 {\n+    // This is not satisfied:\n+    //\n+    // - `RootDatabase: SourceDatabase`\n+    //   - requires `RootDatabase: RefUnwindSafe` + `RootDatabase: HasQueryGroup`\n+    // - `RootDatabase: RefUnwindSafe`\n+    //   - requires `Runtime<RootDatabase>: RefUnwindSafe`\n+    // - `Runtime<RootDatabase>: RefUnwindSafe`\n+    //   - requires `DB::Storage: RefUnwindSafe` (`SalsaStorage: RefUnwindSafe`)\n+    // - `SalsaStorage: RefUnwindSafe`\n+    //    - requires `<ParseQuery as Query<RootDatabase>>::Data: RefUnwindSafe`,\n+    //      which means `ParseQuery: Query<RootDatabase>`\n+    // - `ParseQuery: Query<RootDatabase>`\n+    //    - requires `RootDatabase: SourceDatabase`,\n+    // - `RootDatabase: SourceDatabase` is already on the stack, so we have a\n+    //   cycle with non-coinductive participants\n+    //\n+    // we used to fail to report an error here because we got the\n+    // caching wrong.\n+    SourceDatabase::parse(db);\n+    22\n+}\n+\n+fn main() {}"}, {"sha": "9192f7ba2e3b0af8092cdf72376babfdd9fb5b80", "filename": "src/test/ui/traits/cycle-cache-err-60010.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b4c340e4bb246572029d235e46850faa9823d312/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4c340e4bb246572029d235e46850faa9823d312/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr?ref=b4c340e4bb246572029d235e46850faa9823d312", "patch": "@@ -0,0 +1,20 @@\n+error[E0275]: overflow evaluating the requirement `RootDatabase: SourceDatabase`\n+  --> $DIR/cycle-cache-err-60010.rs:27:5\n+   |\n+LL |     _parse: <ParseQuery as Query<RootDatabase>>::Data,\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: required because of the requirements on the impl of `Query<RootDatabase>` for `ParseQuery`\n+\n+error[E0275]: overflow evaluating the requirement `RootDatabase: SourceDatabase`\n+  --> $DIR/cycle-cache-err-60010.rs:30:6\n+   |\n+LL | impl Database for RootDatabase {\n+   |      ^^^^^^^^\n+   |\n+   = note: required because of the requirements on the impl of `Query<RootDatabase>` for `ParseQuery`\n+   = note: required because it appears within the type `SalsaStorage`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0275`."}]}