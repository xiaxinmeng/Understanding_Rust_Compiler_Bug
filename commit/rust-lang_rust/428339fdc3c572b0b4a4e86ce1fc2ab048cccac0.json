{"sha": "428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyODMzOWZkYzNjNTcyYjBiNGE0ZTg2Y2UxZmMyYWIwNDhjY2NhYzA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-01-30T19:28:48Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-01-30T19:35:23Z"}, "message": "Refactor indent and width into Shape struct", "tree": {"sha": "a6f024f772b19db996ada08783190c50aced0b5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6f024f772b19db996ada08783190c50aced0b5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "html_url": "https://github.com/rust-lang/rust/commit/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6054f28bd2c2b617d4d494c5e27e09b4b16db1d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6054f28bd2c2b617d4d494c5e27e09b4b16db1d2", "html_url": "https://github.com/rust-lang/rust/commit/6054f28bd2c2b617d4d494c5e27e09b4b16db1d2"}], "stats": {"total": 1752, "additions": 866, "deletions": 886}, "files": [{"sha": "38f6fad1166d402d978195931123be08fb1a719e", "filename": "src/chains.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -81,7 +81,7 @@\n /// true, then we allow the last method call to spill over multiple lines without\n /// forcing the rest of the chain to be split.\n \n-use Indent;\n+use {Indent, Shape};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{wrap_str, first_line_width};\n use expr::rewrite_call;\n@@ -92,24 +92,20 @@ use std::iter;\n use syntax::{ast, ptr};\n use syntax::codemap::{mk_sp, Span};\n \n-pub fn rewrite_chain(expr: &ast::Expr,\n-                     context: &RewriteContext,\n-                     width: usize,\n-                     offset: Indent)\n-                     -> Option<String> {\n+pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n     let total_span = expr.span;\n     let (parent, subexpr_list) = make_subexpr_list(expr, context);\n \n     // Bail out if the chain is just try sugar, i.e., an expression followed by\n     // any number of `?`s.\n     if chain_only_try(&subexpr_list) {\n-        return rewrite_try(&parent, subexpr_list.len(), context, width, offset);\n+        return rewrite_try(&parent, subexpr_list.len(), context, shape);\n     }\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n-    let parent_block_indent = chain_base_indent(context, offset);\n+    let parent_block_indent = chain_base_indent(context, shape.indent);\n     let parent_context = &RewriteContext { block_indent: parent_block_indent, ..*context };\n-    let parent_rewrite = try_opt!(parent.rewrite(parent_context, width, offset));\n+    let parent_rewrite = try_opt!(parent.rewrite(parent_context, shape));\n \n     // Decide how to layout the rest of the chain. `extend` is true if we can\n     // put the first non-parent item on the same line as the parent.\n@@ -119,7 +115,7 @@ pub fn rewrite_chain(expr: &ast::Expr,\n         let indent = if let ast::ExprKind::Try(..) = subexpr_list.last().unwrap().node {\n             parent_block_indent.block_indent(context.config)\n         } else {\n-            chain_indent(context, offset + Indent::new(0, parent_rewrite.len()))\n+            chain_indent(context, shape.indent + Indent::new(0, parent_rewrite.len()))\n         };\n         (indent, true)\n     } else if is_block_expr(&parent, &parent_rewrite) {\n@@ -129,13 +125,13 @@ pub fn rewrite_chain(expr: &ast::Expr,\n     } else if parent_rewrite.contains('\\n') {\n         (chain_indent(context, parent_block_indent.block_indent(context.config)), false)\n     } else {\n-        (chain_indent_newline(context, offset + Indent::new(0, parent_rewrite.len())), false)\n+        (chain_indent_newline(context, shape.indent + Indent::new(0, parent_rewrite.len())), false)\n     };\n \n-    let max_width = try_opt!((width + offset.width()).checked_sub(indent.width()));\n+    let max_width = try_opt!((shape.width + shape.indent.width()).checked_sub(indent.width()));\n     let mut rewrites = try_opt!(subexpr_list.iter()\n         .rev()\n-        .map(|e| rewrite_chain_subexpr(e, total_span, context, max_width, indent))\n+        .map(|e| rewrite_chain_subexpr(e, total_span, context, Shape::legacy(max_width, indent)))\n         .collect::<Option<Vec<_>>>());\n \n     // Total of all items excluding the last.\n@@ -156,7 +152,7 @@ pub fn rewrite_chain(expr: &ast::Expr,\n         false\n     };\n \n-    let mut fits_single_line = !veto_single_line && total_width <= width;\n+    let mut fits_single_line = !veto_single_line && total_width <= shape.width;\n     if fits_single_line {\n         let len = rewrites.len();\n         let (init, last) = rewrites.split_at_mut(len - 1);\n@@ -168,10 +164,9 @@ pub fn rewrite_chain(expr: &ast::Expr,\n                     rewrite_method_call_with_overflow(e,\n                                                       &mut last[0],\n                                                       almost_total,\n-                                                      width,\n                                                       total_span,\n                                                       context,\n-                                                      offset)\n+                                                      shape)\n                 }\n                 _ => !last[0].contains('\\n'),\n             }\n@@ -199,8 +194,7 @@ pub fn rewrite_chain(expr: &ast::Expr,\n                      first_connector,\n                      join_rewrites(&rewrites, &subexpr_list, &connector)),\n              context.config.max_width,\n-             width,\n-             offset)\n+             shape)\n }\n \n // True if the chain is only `?`s.\n@@ -215,10 +209,9 @@ fn chain_only_try(exprs: &[ast::Expr]) -> bool {\n pub fn rewrite_try(expr: &ast::Expr,\n                    try_count: usize,\n                    context: &RewriteContext,\n-                   width: usize,\n-                   offset: Indent)\n+                   shape: Shape)\n                    -> Option<String> {\n-    let sub_expr = try_opt!(expr.rewrite(context, width - try_count, offset));\n+    let sub_expr = try_opt!(expr.rewrite(context, shape.sub_width(try_count)));\n     Some(format!(\"{}{}\",\n                  sub_expr,\n                  iter::repeat(\"?\").take(try_count).collect::<String>()))\n@@ -305,13 +298,12 @@ fn chain_indent_newline(context: &RewriteContext, _offset: Indent) -> Indent {\n fn rewrite_method_call_with_overflow(expr_kind: &ast::ExprKind,\n                                      last: &mut String,\n                                      almost_total: usize,\n-                                     width: usize,\n                                      total_span: Span,\n                                      context: &RewriteContext,\n-                                     offset: Indent)\n+                                     shape: Shape)\n                                      -> bool {\n     if let &ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions) = expr_kind {\n-        let budget = match width.checked_sub(almost_total) {\n+        let budget = match shape.width.checked_sub(almost_total) {\n             Some(b) => b,\n             None => return false,\n         };\n@@ -320,8 +312,8 @@ fn rewrite_method_call_with_overflow(expr_kind: &ast::ExprKind,\n                                                    expressions,\n                                                    total_span,\n                                                    context,\n-                                                   budget,\n-                                                   offset + almost_total);\n+                                                   Shape::legacy(budget,\n+                                                                 shape.indent + almost_total));\n \n         if let Some(ref mut s) = last_rewrite {\n             ::std::mem::swap(s, last);\n@@ -366,29 +358,36 @@ fn convert_try(expr: &ast::Expr, context: &RewriteContext) -> ast::Expr {\n fn rewrite_chain_subexpr(expr: &ast::Expr,\n                          span: Span,\n                          context: &RewriteContext,\n-                         width: usize,\n-                         offset: Indent)\n+                         shape: Shape)\n                          -> Option<String> {\n     match expr.node {\n         ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions) => {\n-            let inner = &RewriteContext { block_indent: offset, ..*context };\n-            rewrite_method_call(method_name.node,\n-                                types,\n-                                expressions,\n-                                span,\n-                                inner,\n-                                width,\n-                                offset)\n+            let inner = &RewriteContext { block_indent: shape.indent, ..*context };\n+            rewrite_method_call(method_name.node, types, expressions, span, inner, shape)\n         }\n         ast::ExprKind::Field(_, ref field) => {\n             let s = format!(\".{}\", field.node);\n-            if s.len() <= width { Some(s) } else { None }\n+            if s.len() <= shape.width {\n+                Some(s)\n+            } else {\n+                None\n+            }\n         }\n         ast::ExprKind::TupField(_, ref field) => {\n             let s = format!(\".{}\", field.node);\n-            if s.len() <= width { Some(s) } else { None }\n+            if s.len() <= shape.width {\n+                Some(s)\n+            } else {\n+                None\n+            }\n+        }\n+        ast::ExprKind::Try(_) => {\n+            if shape.width >= 1 {\n+                Some(\"?\".into())\n+            } else {\n+                None\n+            }\n         }\n-        ast::ExprKind::Try(_) => if width >= 1 { Some(\"?\".into()) } else { None },\n         _ => unreachable!(),\n     }\n }\n@@ -406,14 +405,13 @@ fn rewrite_method_call(method_name: ast::Ident,\n                        args: &[ptr::P<ast::Expr>],\n                        span: Span,\n                        context: &RewriteContext,\n-                       width: usize,\n-                       offset: Indent)\n+                       shape: Shape)\n                        -> Option<String> {\n     let (lo, type_str) = if types.is_empty() {\n         (args[0].span.hi, String::new())\n     } else {\n         let type_list: Vec<_> = try_opt!(types.iter()\n-            .map(|ty| ty.rewrite(context, width, offset))\n+            .map(|ty| ty.rewrite(context, shape))\n             .collect());\n \n         let type_str = if context.config.spaces_within_angle_brackets && type_list.len() > 0 {\n@@ -428,5 +426,5 @@ fn rewrite_method_call(method_name: ast::Ident,\n     let callee_str = format!(\".{}{}\", method_name, type_str);\n     let span = mk_sp(lo, span.hi);\n \n-    rewrite_call(context, &callee_str, &args[1..], span, width, offset)\n+    rewrite_call(context, &callee_str, &args[1..], span, shape)\n }"}, {"sha": "b7549f10c2de57df29ecaf4e37e93e7f5efe5156", "filename": "src/comment.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -14,7 +14,7 @@ use std::{self, iter};\n \n use syntax::codemap::Span;\n \n-use Indent;\n+use {Indent, Shape};\n use config::Config;\n use rewrite::RewriteContext;\n use string::{StringFormat, rewrite_string};\n@@ -34,8 +34,7 @@ fn is_custom_comment(comment: &str) -> bool {\n \n pub fn rewrite_comment(orig: &str,\n                        block_style: bool,\n-                       width: usize,\n-                       offset: Indent,\n+                       shape: Shape,\n                        config: &Config)\n                        -> Option<String> {\n     // If there are lines without a starting sigil, we won't format them correctly\n@@ -50,7 +49,7 @@ pub fn rewrite_comment(orig: &str,\n     }\n \n     if !config.normalize_comments && !config.wrap_comments {\n-        return light_rewrite_comment(orig, offset, config);\n+        return light_rewrite_comment(orig, shape.indent, config);\n     }\n \n     let (opener, closer, line_start) =\n@@ -85,15 +84,14 @@ pub fn rewrite_comment(orig: &str,\n             (\"// \", \"\", \"// \")\n         };\n \n-    let max_chars = width.checked_sub(closer.len() + opener.len()).unwrap_or(1);\n-    let indent_str = offset.to_string(config);\n+    let max_chars = shape.width.checked_sub(closer.len() + opener.len()).unwrap_or(1);\n+    let indent_str = shape.indent.to_string(config);\n     let fmt = StringFormat {\n         opener: \"\",\n         closer: \"\",\n         line_start: line_start,\n         line_end: \"\",\n-        width: max_chars,\n-        offset: offset + (opener.len() - line_start.len()),\n+        shape: Shape::legacy(max_chars, shape.indent + (opener.len() - line_start.len())),\n         trim_end: true,\n         config: config,\n     };\n@@ -574,14 +572,13 @@ impl<'a> Iterator for CommentCodeSlices<'a> {\n pub fn recover_comment_removed(new: String,\n                                span: Span,\n                                context: &RewriteContext,\n-                               width: usize,\n-                               offset: Indent)\n+                               shape: Shape)\n                                -> Option<String> {\n     let snippet = context.snippet(span);\n     if changed_comment_content(&snippet, &new) {\n         // We missed some comments\n         // Keep previous formatting if it satisfies the constrains\n-        wrap_str(snippet, context.config.max_width, width, offset)\n+        wrap_str(snippet, context.config.max_width, shape)\n     } else {\n         Some(new)\n     }\n@@ -678,7 +675,7 @@ fn remove_comment_header(comment: &str) -> &str {\n mod test {\n     use super::{CharClasses, CodeCharKind, FullCodeCharKind, contains_comment, rewrite_comment,\n                 FindUncommented, CommentCodeSlices};\n-    use Indent;\n+    use {Indent, Shape};\n \n     #[test]\n     fn char_classes() {\n@@ -735,33 +732,36 @@ mod test {\n         config.wrap_comments = true;\n         config.normalize_comments = true;\n \n-        let comment = rewrite_comment(\" //test\", true, 100, Indent::new(0, 100), &config).unwrap();\n+        let comment = rewrite_comment(\" //test\",\n+                                      true,\n+                                      Shape::legacy(100, Indent::new(0, 100)),\n+                                      &config).unwrap();\n         assert_eq!(\"/* test */\", comment);\n \n         let comment = rewrite_comment(\"// comment on a\",\n                                       false,\n-                                      10,\n-                                      Indent::empty(),\n+                                      Shape::legacy(10, Indent::empty()),\n                                       &config).unwrap();\n         assert_eq!(\"// comment\\n// on a\", comment);\n \n         let comment = rewrite_comment(\"//  A multi line comment\\n             // between args.\",\n                                       false,\n-                                      60,\n-                                      Indent::new(0, 12),\n+                                      Shape::legacy(60, Indent::new(0, 12)),\n                                       &config).unwrap();\n         assert_eq!(\"//  A multi line comment\\n            // between args.\", comment);\n \n         let input = \"// comment\";\n         let expected =\n             \"/* comment */\";\n-        let comment = rewrite_comment(input, true, 9, Indent::new(0, 69), &config).unwrap();\n+        let comment = rewrite_comment(input,\n+                                      true,\n+                                      Shape::legacy(9, Indent::new(0, 69)),\n+                                      &config).unwrap();\n         assert_eq!(expected, comment);\n \n         let comment = rewrite_comment(\"/*   trimmed    */\",\n                                       true,\n-                                      100,\n-                                      Indent::new(0, 100),\n+                                      Shape::legacy(100, Indent::new(0, 100)),\n                                       &config).unwrap();\n         assert_eq!(\"/* trimmed */\", comment);\n     }"}, {"sha": "ba7c05b652856cb2219b494ff715305686b347d2", "filename": "src/expr.rs", "status": "modified", "additions": 306, "deletions": 357, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -15,7 +15,7 @@ use std::ops::Deref;\n use std::iter::ExactSizeIterator;\n use std::fmt::Write;\n \n-use {Indent, Spanned};\n+use {Indent, Shape, Spanned};\n use codemap::SpanUtils;\n use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic,\n@@ -36,8 +36,8 @@ use syntax::codemap::{CodeMap, Span, BytePos, mk_sp};\n use syntax::parse::classify;\n \n impl Rewrite for ast::Expr {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        format_expr(self, ExprType::SubExpression, context, width, offset)\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        format_expr(self, ExprType::SubExpression, context, shape)\n     }\n }\n \n@@ -50,35 +50,28 @@ enum ExprType {\n fn format_expr(expr: &ast::Expr,\n                expr_type: ExprType,\n                context: &RewriteContext,\n-               width: usize,\n-               offset: Indent)\n+               shape: Shape)\n                -> Option<String> {\n     let result = match expr.node {\n         ast::ExprKind::Array(ref expr_vec) => {\n             rewrite_array(expr_vec.iter().map(|e| &**e),\n                           mk_sp(context.codemap.span_after(expr.span, \"[\"), expr.span.hi),\n                           context,\n-                          width,\n-                          offset)\n+                          shape)\n         }\n         ast::ExprKind::Lit(ref l) => {\n             match l.node {\n                 ast::LitKind::Str(_, ast::StrStyle::Cooked) => {\n-                    rewrite_string_lit(context, l.span, width, offset)\n-                }\n-                _ => {\n-                    wrap_str(context.snippet(expr.span),\n-                             context.config.max_width,\n-                             width,\n-                             offset)\n+                    rewrite_string_lit(context, l.span, shape)\n                 }\n+                _ => wrap_str(context.snippet(expr.span), context.config.max_width, shape),\n             }\n         }\n         ast::ExprKind::Call(ref callee, ref args) => {\n             let inner_span = mk_sp(callee.span.hi, expr.span.hi);\n-            rewrite_call(context, &**callee, args, inner_span, width, offset)\n+            rewrite_call(context, &**callee, args, inner_span, shape)\n         }\n-        ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, width, offset),\n+        ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, shape),\n         ast::ExprKind::Binary(ref op, ref lhs, ref rhs) => {\n             // FIXME: format comments between operands and operator\n             rewrite_pair(&**lhs,\n@@ -87,43 +80,33 @@ fn format_expr(expr: &ast::Expr,\n                          &format!(\" {} \", context.snippet(op.span)),\n                          \"\",\n                          context,\n-                         width,\n-                         offset)\n-        }\n-        ast::ExprKind::Unary(ref op, ref subexpr) => {\n-            rewrite_unary_op(context, op, subexpr, width, offset)\n+                         shape)\n         }\n+        ast::ExprKind::Unary(ref op, ref subexpr) => rewrite_unary_op(context, op, subexpr, shape),\n         ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n             rewrite_struct_lit(context,\n                                path,\n                                fields,\n                                base.as_ref().map(|e| &**e),\n                                expr.span,\n-                               width,\n-                               offset)\n+                               shape)\n         }\n         ast::ExprKind::Tup(ref items) => {\n-            rewrite_tuple(context,\n-                          items.iter().map(|x| &**x),\n-                          expr.span,\n-                          width,\n-                          offset)\n+            rewrite_tuple(context, items.iter().map(|x| &**x), expr.span, shape)\n         }\n         ast::ExprKind::While(ref cond, ref block, label) => {\n-            ControlFlow::new_while(None, cond, block, label, expr.span)\n-                .rewrite(context, width, offset)\n+            ControlFlow::new_while(None, cond, block, label, expr.span).rewrite(context, shape)\n         }\n         ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => {\n-            ControlFlow::new_while(Some(pat), cond, block, label, expr.span)\n-                .rewrite(context, width, offset)\n+            ControlFlow::new_while(Some(pat), cond, block, label, expr.span).rewrite(context, shape)\n         }\n         ast::ExprKind::ForLoop(ref pat, ref cond, ref block, label) => {\n-            ControlFlow::new_for(pat, cond, block, label, expr.span).rewrite(context, width, offset)\n+            ControlFlow::new_for(pat, cond, block, label, expr.span).rewrite(context, shape)\n         }\n         ast::ExprKind::Loop(ref block, label) => {\n-            ControlFlow::new_loop(block, label, expr.span).rewrite(context, width, offset)\n+            ControlFlow::new_loop(block, label, expr.span).rewrite(context, shape)\n         }\n-        ast::ExprKind::Block(ref block) => block.rewrite(context, width, offset),\n+        ast::ExprKind::Block(ref block) => block.rewrite(context, shape),\n         ast::ExprKind::If(ref cond, ref if_block, ref else_block) => {\n             ControlFlow::new_if(cond,\n                                 None,\n@@ -132,7 +115,7 @@ fn format_expr(expr: &ast::Expr,\n                                 expr_type == ExprType::SubExpression,\n                                 false,\n                                 expr.span)\n-                .rewrite(context, width, offset)\n+                .rewrite(context, shape)\n         }\n         ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n             ControlFlow::new_if(cond,\n@@ -142,24 +125,19 @@ fn format_expr(expr: &ast::Expr,\n                                 expr_type == ExprType::SubExpression,\n                                 false,\n                                 expr.span)\n-                .rewrite(context, width, offset)\n+                .rewrite(context, shape)\n         }\n         ast::ExprKind::Match(ref cond, ref arms) => {\n-            rewrite_match(context, cond, arms, width, offset, expr.span)\n+            rewrite_match(context, cond, arms, shape, expr.span)\n         }\n         ast::ExprKind::Path(ref qself, ref path) => {\n-            rewrite_path(context,\n-                         PathContext::Expr,\n-                         qself.as_ref(),\n-                         path,\n-                         width,\n-                         offset)\n+            rewrite_path(context, PathContext::Expr, qself.as_ref(), path, shape)\n         }\n         ast::ExprKind::Assign(ref lhs, ref rhs) => {\n-            rewrite_assignment(context, lhs, rhs, None, width, offset)\n+            rewrite_assignment(context, lhs, rhs, None, shape)\n         }\n         ast::ExprKind::AssignOp(ref op, ref lhs, ref rhs) => {\n-            rewrite_assignment(context, lhs, rhs, Some(op), width, offset)\n+            rewrite_assignment(context, lhs, rhs, Some(op), shape)\n         }\n         ast::ExprKind::Continue(ref opt_ident) => {\n             let id_str = match *opt_ident {\n@@ -168,8 +146,7 @@ fn format_expr(expr: &ast::Expr,\n             };\n             wrap_str(format!(\"continue{}\", id_str),\n                      context.config.max_width,\n-                     width,\n-                     offset)\n+                     shape)\n         }\n         ast::ExprKind::Break(ref opt_ident, ref opt_expr) => {\n             let id_str = match *opt_ident {\n@@ -178,64 +155,48 @@ fn format_expr(expr: &ast::Expr,\n             };\n \n             if let Some(ref expr) = *opt_expr {\n-                rewrite_unary_prefix(context,\n-                                     &format!(\"break{} \", id_str),\n-                                     &**expr,\n-                                     width,\n-                                     offset)\n+                rewrite_unary_prefix(context, &format!(\"break{} \", id_str), &**expr, shape)\n             } else {\n-                wrap_str(format!(\"break{}\", id_str),\n-                         context.config.max_width,\n-                         width,\n-                         offset)\n+                wrap_str(format!(\"break{}\", id_str), context.config.max_width, shape)\n             }\n         }\n         ast::ExprKind::Closure(capture, ref fn_decl, ref body, _) => {\n-            rewrite_closure(capture, fn_decl, body, expr.span, context, width, offset)\n+            rewrite_closure(capture, fn_decl, body, expr.span, context, shape)\n         }\n         ast::ExprKind::Try(..) |\n         ast::ExprKind::Field(..) |\n         ast::ExprKind::TupField(..) |\n-        ast::ExprKind::MethodCall(..) => rewrite_chain(expr, context, width, offset),\n+        ast::ExprKind::MethodCall(..) => rewrite_chain(expr, context, shape),\n         ast::ExprKind::Mac(ref mac) => {\n             // Failure to rewrite a marco should not imply failure to\n             // rewrite the expression.\n-            rewrite_macro(mac, None, context, width, offset, MacroPosition::Expression)\n-                .or_else(|| {\n-                    wrap_str(context.snippet(expr.span),\n-                             context.config.max_width,\n-                             width,\n-                             offset)\n-                })\n-        }\n-        ast::ExprKind::Ret(None) => {\n-            wrap_str(\"return\".to_owned(), context.config.max_width, width, offset)\n+            rewrite_macro(mac, None, context, shape, MacroPosition::Expression)\n+                .or_else(|| wrap_str(context.snippet(expr.span), context.config.max_width, shape))\n         }\n+        ast::ExprKind::Ret(None) => wrap_str(\"return\".to_owned(), context.config.max_width, shape),\n         ast::ExprKind::Ret(Some(ref expr)) => {\n-            rewrite_unary_prefix(context, \"return \", &**expr, width, offset)\n-        }\n-        ast::ExprKind::Box(ref expr) => {\n-            rewrite_unary_prefix(context, \"box \", &**expr, width, offset)\n+            rewrite_unary_prefix(context, \"return \", &**expr, shape)\n         }\n+        ast::ExprKind::Box(ref expr) => rewrite_unary_prefix(context, \"box \", &**expr, shape),\n         ast::ExprKind::AddrOf(mutability, ref expr) => {\n-            rewrite_expr_addrof(context, mutability, expr, width, offset)\n+            rewrite_expr_addrof(context, mutability, expr, shape)\n         }\n         ast::ExprKind::Cast(ref expr, ref ty) => {\n-            rewrite_pair(&**expr, &**ty, \"\", \" as \", \"\", context, width, offset)\n+            rewrite_pair(&**expr, &**ty, \"\", \" as \", \"\", context, shape)\n         }\n         ast::ExprKind::Type(ref expr, ref ty) => {\n-            rewrite_pair(&**expr, &**ty, \"\", \": \", \"\", context, width, offset)\n+            rewrite_pair(&**expr, &**ty, \"\", \": \", \"\", context, shape)\n         }\n         ast::ExprKind::Index(ref expr, ref index) => {\n-            rewrite_index(&**expr, &**index, context, width, offset)\n+            rewrite_index(&**expr, &**index, context, shape)\n         }\n         ast::ExprKind::Repeat(ref expr, ref repeats) => {\n             let (lbr, rbr) = if context.config.spaces_within_square_brackets {\n                 (\"[ \", \" ]\")\n             } else {\n                 (\"[\", \"]\")\n             };\n-            rewrite_pair(&**expr, &**repeats, lbr, \"; \", rbr, context, width, offset)\n+            rewrite_pair(&**expr, &**repeats, lbr, \"; \", rbr, context, shape)\n         }\n         ast::ExprKind::Range(ref lhs, ref rhs, limits) => {\n             let delim = match limits {\n@@ -250,38 +211,35 @@ fn format_expr(expr: &ast::Expr,\n                     } else {\n                         delim.into()\n                     };\n-                    rewrite_pair(&**lhs, &**rhs, \"\", &sp_delim, \"\", context, width, offset)\n+                    rewrite_pair(&**lhs, &**rhs, \"\", &sp_delim, \"\", context, shape)\n                 }\n                 (None, Some(ref rhs)) => {\n                     let sp_delim = if context.config.spaces_around_ranges {\n                         format!(\"{} \", delim)\n                     } else {\n                         delim.into()\n                     };\n-                    rewrite_unary_prefix(context, &sp_delim, &**rhs, width, offset)\n+                    rewrite_unary_prefix(context, &sp_delim, &**rhs, shape)\n                 }\n                 (Some(ref lhs), None) => {\n                     let sp_delim = if context.config.spaces_around_ranges {\n                         format!(\" {}\", delim)\n                     } else {\n                         delim.into()\n                     };\n-                    rewrite_unary_suffix(context, &sp_delim, &**lhs, width, offset)\n+                    rewrite_unary_suffix(context, &sp_delim, &**lhs, shape)\n                 }\n-                (None, None) => wrap_str(delim.into(), context.config.max_width, width, offset),\n+                (None, None) => wrap_str(delim.into(), context.config.max_width, shape),\n             }\n         }\n         // We do not format these expressions yet, but they should still\n         // satisfy our width restrictions.\n         ast::ExprKind::InPlace(..) |\n         ast::ExprKind::InlineAsm(..) => {\n-            wrap_str(context.snippet(expr.span),\n-                     context.config.max_width,\n-                     width,\n-                     offset)\n+            wrap_str(context.snippet(expr.span), context.config.max_width, shape)\n         }\n     };\n-    result.and_then(|res| recover_comment_removed(res, expr.span, context, width, offset))\n+    result.and_then(|res| recover_comment_removed(res, expr.span, context, shape))\n }\n \n pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n@@ -290,31 +248,31 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n                               infix: &str,\n                               suffix: &str,\n                               context: &RewriteContext,\n-                              width: usize,\n-                              offset: Indent)\n+                              shape: Shape)\n                               -> Option<String>\n     where LHS: Rewrite,\n           RHS: Rewrite\n {\n-    let lhs_budget = try_opt!(width.checked_sub(prefix.len() + infix.len()));\n-    let rhs_budget = try_opt!(width.checked_sub(suffix.len()));\n+    let lhs_budget = try_opt!(shape.width.checked_sub(prefix.len() + infix.len()));\n+    let rhs_budget = try_opt!(shape.width.checked_sub(suffix.len()));\n \n     // Get \"full width\" rhs and see if it fits on the current line. This\n     // usually works fairly well since it tends to place operands of\n     // operations with high precendence close together.\n     // Note that this is non-conservative, but its just to see if it's even\n     // worth trying to put everything on one line.\n-    let rhs_result = rhs.rewrite(context, rhs_budget, offset);\n+    let rhs_result = rhs.rewrite(context, Shape::legacy(rhs_budget, shape.indent));\n \n     if let Some(rhs_result) = rhs_result {\n         // This is needed in case of line break not caused by a\n         // shortage of space, but by end-of-line comments, for example.\n         if !rhs_result.contains('\\n') {\n-            let lhs_result = lhs.rewrite(context, lhs_budget, offset);\n+            let lhs_result = lhs.rewrite(context, Shape::legacy(lhs_budget, shape.indent));\n             if let Some(lhs_result) = lhs_result {\n                 let mut result = format!(\"{}{}{}\", prefix, lhs_result, infix);\n \n-                let remaining_width = width.checked_sub(last_line_width(&result)).unwrap_or(0);\n+                let remaining_width =\n+                    shape.width.checked_sub(last_line_width(&result)).unwrap_or(0);\n \n                 if rhs_result.len() <= remaining_width {\n                     result.push_str(&rhs_result);\n@@ -324,7 +282,9 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n \n                 // Try rewriting the rhs into the remaining space.\n                 let rhs_budget = try_opt!(remaining_width.checked_sub(suffix.len()));\n-                if let Some(rhs_result) = rhs.rewrite(context, rhs_budget, offset + result.len()) {\n+                if let Some(rhs_result) = rhs.rewrite(context,\n+                                                      Shape::legacy(rhs_budget,\n+                                                                    shape.indent + result.len())) {\n                     if rhs_result.len() <= remaining_width {\n                         result.push_str(&rhs_result);\n                         result.push_str(suffix);\n@@ -339,13 +299,14 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n \n     // Re-evaluate the rhs because we have more space now:\n     let infix = infix.trim_right();\n-    let lhs_budget =\n-        try_opt!(context.config.max_width.checked_sub(offset.width() + prefix.len() + infix.len()));\n+    let lhs_budget = try_opt!(context.config\n+        .max_width\n+        .checked_sub(shape.indent.width() + prefix.len() + infix.len()));\n     let rhs_budget = try_opt!(rhs_budget.checked_sub(prefix.len()));\n-    let rhs_offset = offset + prefix.len();\n+    let rhs_offset = shape.indent + prefix.len();\n \n-    let rhs_result = try_opt!(rhs.rewrite(context, rhs_budget, rhs_offset));\n-    let lhs_result = try_opt!(lhs.rewrite(context, lhs_budget, offset));\n+    let rhs_result = try_opt!(rhs.rewrite(context, Shape::legacy(rhs_budget, rhs_offset)));\n+    let lhs_result = try_opt!(lhs.rewrite(context, Shape::legacy(lhs_budget, shape.indent)));\n     Some(format!(\"{}{}{}\\n{}{}{}\",\n                  prefix,\n                  lhs_result,\n@@ -358,8 +319,7 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n pub fn rewrite_array<'a, I>(expr_iter: I,\n                             span: Span,\n                             context: &RewriteContext,\n-                            width: usize,\n-                            offset: Indent)\n+                            shape: Shape)\n                             -> Option<String>\n     where I: Iterator<Item = &'a ast::Expr>\n {\n@@ -368,18 +328,19 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n     } else {\n         1 // \"[\"\n     };\n-    let offset = offset + bracket_size;\n+    let offset = shape.indent + bracket_size;\n     let inner_context = &RewriteContext { block_indent: offset, ..*context };\n-    let max_item_width = try_opt!(width.checked_sub(bracket_size * 2));\n-    let items = itemize_list(context.codemap,\n-                             expr_iter,\n-                             \"]\",\n-                             |item| item.span.lo,\n-                             |item| item.span.hi,\n-                             |item| item.rewrite(inner_context, max_item_width, offset),\n-                             span.lo,\n-                             span.hi)\n-        .collect::<Vec<_>>();\n+    let max_item_width = try_opt!(shape.width.checked_sub(bracket_size * 2));\n+    let items =\n+        itemize_list(context.codemap,\n+                     expr_iter,\n+                     \"]\",\n+                     |item| item.span.lo,\n+                     |item| item.span.hi,\n+                     |item| item.rewrite(inner_context, Shape::legacy(max_item_width, offset)),\n+                     span.lo,\n+                     span.hi)\n+            .collect::<Vec<_>>();\n \n     let has_long_item = try_opt!(items.iter()\n         .map(|li| li.item.as_ref().map(|s| s.len() > 10))\n@@ -395,8 +356,7 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n-        indent: offset,\n-        width: max_item_width,\n+        shape: Shape::legacy(max_item_width, offset),\n         ends_with_newline: false,\n         config: context.config,\n     };\n@@ -410,7 +370,7 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n }\n \n // This functions is pretty messy because of the rules around closures and blocks:\n-// TODO\n+// FIXME - the below is probably no longer true in full.\n //   * if there is a return type, then there must be braces,\n //   * given a closure with braces, whether that is parsed to give an inner block\n //     or not depends on if there is a return type and if there are statements\n@@ -423,34 +383,34 @@ fn rewrite_closure(capture: ast::CaptureBy,\n                    body: &ast::Expr,\n                    span: Span,\n                    context: &RewriteContext,\n-                   width: usize,\n-                   offset: Indent)\n+                   shape: Shape)\n                    -> Option<String> {\n     let mover = if capture == ast::CaptureBy::Value {\n         \"move \"\n     } else {\n         \"\"\n     };\n-    let offset = offset + mover.len();\n+    let offset = shape.indent + mover.len();\n \n     // 4 = \"|| {\".len(), which is overconservative when the closure consists of\n     // a single expression.\n-    let budget = try_opt!(width.checked_sub(4 + mover.len()));\n+    let budget = try_opt!(shape.width.checked_sub(4 + mover.len()));\n     // 1 = |\n     let argument_offset = offset + 1;\n-    let ret_str = try_opt!(fn_decl.output.rewrite(context, budget, argument_offset));\n+    let ret_str = try_opt!(fn_decl.output.rewrite(context, Shape::legacy(budget, argument_offset)));\n \n     // 1 = space between arguments and return type.\n     let horizontal_budget = budget.checked_sub(ret_str.len() + 1).unwrap_or(0);\n \n-    let arg_items = itemize_list(context.codemap,\n-                                 fn_decl.inputs.iter(),\n-                                 \"|\",\n-                                 |arg| span_lo_for_arg(arg),\n-                                 |arg| span_hi_for_arg(arg),\n-                                 |arg| arg.rewrite(context, budget, argument_offset),\n-                                 context.codemap.span_after(span, \"|\"),\n-                                 body.span.lo);\n+    let arg_items =\n+        itemize_list(context.codemap,\n+                     fn_decl.inputs.iter(),\n+                     \"|\",\n+                     |arg| span_lo_for_arg(arg),\n+                     |arg| span_hi_for_arg(arg),\n+                     |arg| arg.rewrite(context, Shape::legacy(budget, argument_offset)),\n+                     context.codemap.span_after(span, \"|\"),\n+                     body.span.lo);\n     let item_vec = arg_items.collect::<Vec<_>>();\n     let tactic = definitive_tactic(&item_vec, ListTactic::HorizontalVertical, horizontal_budget);\n     let budget = match tactic {\n@@ -462,8 +422,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n-        indent: argument_offset,\n-        width: budget,\n+        shape: Shape::legacy(budget, argument_offset),\n         ends_with_newline: false,\n         config: context.config,\n     };\n@@ -482,7 +441,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n \n     // 1 = space between `|...|` and body.\n     let extra_offset = extra_offset(&prefix, offset) + 1;\n-    let budget = try_opt!(width.checked_sub(extra_offset));\n+    let budget = try_opt!(shape.width.checked_sub(extra_offset));\n     let total_offset = offset + extra_offset;\n \n     if let ast::ExprKind::Block(ref block) = body.node {\n@@ -502,8 +461,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n                 if let Some(rw) = rewrite_closure_expr(expr,\n                                                        &prefix,\n                                                        context,\n-                                                       budget,\n-                                                       total_offset) {\n+                                                       Shape::legacy(budget, total_offset)) {\n                     return Some(rw);\n                 }\n             }\n@@ -513,7 +471,9 @@ fn rewrite_closure(capture: ast::CaptureBy,\n             // We need braces, but we might still prefer a one-liner.\n             let stmt = &block.stmts[0];\n             // 4 = braces and spaces.\n-            let mut rewrite = stmt.rewrite(context, try_opt!(budget.checked_sub(4)), total_offset);\n+            let mut rewrite = stmt.rewrite(context,\n+                                           Shape::legacy(try_opt!(budget.checked_sub(4)),\n+                                                         total_offset));\n \n             // Checks if rewrite succeeded and fits on a single line.\n             rewrite = and_one_line(rewrite);\n@@ -527,7 +487,10 @@ fn rewrite_closure(capture: ast::CaptureBy,\n         return rewrite_closure_block(&block, prefix, context, budget);\n     }\n \n-    if let Some(rw) = rewrite_closure_expr(body, &prefix, context, budget, total_offset) {\n+    if let Some(rw) = rewrite_closure_expr(body,\n+                                           &prefix,\n+                                           context,\n+                                           Shape::legacy(budget, total_offset)) {\n         return Some(rw);\n     }\n \n@@ -548,10 +511,9 @@ fn rewrite_closure(capture: ast::CaptureBy,\n     fn rewrite_closure_expr(expr: &ast::Expr,\n                             prefix: &str,\n                             context: &RewriteContext,\n-                            budget: usize,\n-                            offset: Indent)\n+                            shape: Shape)\n                             -> Option<String> {\n-        let mut rewrite = expr.rewrite(context, budget, offset);\n+        let mut rewrite = expr.rewrite(context, shape);\n         if classify::expr_requires_semi_to_be_stmt(left_most_sub_expr(expr)) {\n             rewrite = and_one_line(rewrite);\n         }\n@@ -565,7 +527,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n                              -> Option<String> {\n         // Start with visual indent, then fall back to block indent if the\n         // closure is large.\n-        let rewrite = try_opt!(block.rewrite(&context, budget, Indent::empty()));\n+        let rewrite = try_opt!(block.rewrite(&context, Shape::legacy(budget, Indent::empty())));\n \n         let block_threshold = context.config.closure_block_indent_threshold;\n         if block_threshold < 0 || rewrite.matches('\\n').count() <= block_threshold as usize {\n@@ -576,7 +538,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n         // means we must re-format.\n         let mut context = context.clone();\n         context.block_indent.alignment = 0;\n-        let rewrite = try_opt!(block.rewrite(&context, budget, Indent::empty()));\n+        let rewrite = try_opt!(block.rewrite(&context, Shape::legacy(budget, Indent::empty())));\n         Some(format!(\"{} {}\", prefix, rewrite))\n     }\n }\n@@ -597,11 +559,12 @@ fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String\n }\n \n impl Rewrite for ast::Block {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        // width is used only for the single line case: either the empty block `{}`,\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        // shape.width is used only for the single line case: either the empty block `{}`,\n         // or an unsafe expression `unsafe { e }`.\n \n-        if self.stmts.is_empty() && !block_contains_comment(self, context.codemap) && width >= 2 {\n+        if self.stmts.is_empty() && !block_contains_comment(self, context.codemap) &&\n+           shape.width >= 2 {\n             return Some(\"{}\".to_owned());\n         }\n \n@@ -611,7 +574,8 @@ impl Rewrite for ast::Block {\n         if user_str.starts_with('{') && user_str.ends_with('}') {\n             let comment_str = user_str[1..user_str.len() - 1].trim();\n             if self.stmts.is_empty() && !comment_str.contains('\\n') &&\n-               !comment_str.starts_with(\"//\") && comment_str.len() + 4 <= width {\n+               !comment_str.starts_with(\"//\") &&\n+               comment_str.len() + 4 <= shape.width {\n                 return Some(format!(\"{{ {} }}\", comment_str));\n             }\n         }\n@@ -630,22 +594,23 @@ impl Rewrite for ast::Block {\n \n                 let prefix = if !trimmed.is_empty() {\n                     // 9 = \"unsafe  {\".len(), 7 = \"unsafe \".len()\n-                    let budget = try_opt!(width.checked_sub(9));\n+                    let budget = try_opt!(shape.width.checked_sub(9));\n                     format!(\"unsafe {} \",\n                             try_opt!(rewrite_comment(trimmed,\n                                                      true,\n-                                                     budget,\n-                                                     offset + 7,\n+                                                     Shape::legacy(budget, shape.indent + 7),\n                                                      context.config)))\n                 } else {\n                     \"unsafe \".to_owned()\n                 };\n \n-                if is_simple_block(self, context.codemap) && prefix.len() < width {\n-                    let expr_str = self.stmts[0].rewrite(context, width - prefix.len(), offset);\n+                if is_simple_block(self, context.codemap) && prefix.len() < shape.width {\n+                    let expr_str = self.stmts[0].rewrite(context,\n+                                                         Shape::legacy(shape.width - prefix.len(),\n+                                                                       shape.indent));\n                     let expr_str = try_opt!(expr_str);\n                     let result = format!(\"{}{{ {} }}\", prefix, expr_str);\n-                    if result.len() <= width && !result.contains('\\n') {\n+                    if result.len() <= shape.width && !result.contains('\\n') {\n                         return Some(result);\n                     }\n                 }\n@@ -666,10 +631,11 @@ impl Rewrite for ast::Block {\n }\n \n impl Rewrite for ast::Stmt {\n-    fn rewrite(&self, context: &RewriteContext, _width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         let result = match self.node {\n             ast::StmtKind::Local(ref local) => {\n-                local.rewrite(context, context.config.max_width, offset)\n+                local.rewrite(context,\n+                              Shape::legacy(context.config.max_width, shape.indent))\n             }\n             ast::StmtKind::Expr(ref ex) |\n             ast::StmtKind::Semi(ref ex) => {\n@@ -682,14 +648,15 @@ impl Rewrite for ast::Stmt {\n                                 _ => unreachable!(),\n                             },\n                             context,\n-                            context.config.max_width - offset.width() - suffix.len(),\n-                            offset)\n+                            Shape::legacy(context.config.max_width - shape.indent.width() -\n+                                          suffix.len(),\n+                                          shape.indent))\n                     .map(|s| s + suffix)\n             }\n             ast::StmtKind::Mac(..) |\n             ast::StmtKind::Item(..) => None,\n         };\n-        result.and_then(|res| recover_comment_removed(res, self.span, context, _width, offset))\n+        result.and_then(|res| recover_comment_removed(res, self.span, context, shape))\n     }\n }\n \n@@ -819,11 +786,12 @@ impl<'a> ControlFlow<'a> {\n \n             let new_width = try_opt!(width.checked_sub(pat_expr_str.len() + fixed_cost));\n             let expr = &self.block.stmts[0];\n-            let if_str = try_opt!(expr.rewrite(context, new_width, Indent::empty()));\n+            let if_str = try_opt!(expr.rewrite(context, Shape::legacy(new_width, Indent::empty())));\n \n             let new_width = try_opt!(new_width.checked_sub(if_str.len()));\n             let else_expr = &else_node.stmts[0];\n-            let else_str = try_opt!(else_expr.rewrite(context, new_width, Indent::empty()));\n+            let else_str =\n+                try_opt!(else_expr.rewrite(context, Shape::legacy(new_width, Indent::empty())));\n \n             if if_str.contains('\\n') || else_str.contains('\\n') {\n                 return None;\n@@ -845,14 +813,14 @@ impl<'a> ControlFlow<'a> {\n }\n \n impl<'a> Rewrite for ControlFlow<'a> {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        debug!(\"ControlFlow::rewrite {:?} {} {:?}\", self, width, offset);\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        debug!(\"ControlFlow::rewrite {:?} {:?}\", self, shape);\n         let (budget, indent) = if self.nested_if {\n             // We are part of an if-elseif-else chain. Our constraints are tightened.\n             // 7 = \"} else \" .len()\n-            (try_opt!(width.checked_sub(7)), offset + 7)\n+            (try_opt!(shape.width.checked_sub(7)), shape.indent + 7)\n         } else {\n-            (width, offset)\n+            (shape.width, shape.indent)\n         };\n \n         let label_string = rewrite_label(self.label);\n@@ -872,15 +840,14 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                                           cond,\n                                           self.matcher,\n                                           self.connector,\n-                                          inner_width,\n-                                          inner_offset))\n+                                          Shape::legacy(inner_width, inner_offset)))\n             }\n             None => String::new(),\n         };\n \n         // Try to format if-else on single line.\n         if self.allow_single_line && context.config.single_line_if_else_max_width > 0 {\n-            let trial = self.rewrite_single_line(&pat_expr_string, context, width);\n+            let trial = self.rewrite_single_line(&pat_expr_string, context, shape.width);\n \n             if trial.is_some() &&\n                trial.as_ref().unwrap().len() <= context.config.single_line_if_else_max_width {\n@@ -891,16 +858,18 @@ impl<'a> Rewrite for ControlFlow<'a> {\n         // This is used only for the empty block case: `{}`. So, we use 1 if we know\n         // we should avoid the single line case.\n         // 2 = spaces after keyword and condition.\n-        let block_width = try_opt!(width.checked_sub(label_string.len() + self.keyword.len() +\n-                                                     extra_offset(&pat_expr_string, inner_offset) +\n-                                                     2));\n+        let block_width = try_opt!(shape.width\n+            .checked_sub(label_string.len() + self.keyword.len() +\n+                         extra_offset(&pat_expr_string, inner_offset) +\n+                         2));\n         let block_width = if self.else_block.is_some() || self.nested_if {\n             min(1, block_width)\n         } else {\n             block_width\n         };\n \n-        let block_str = try_opt!(self.block.rewrite(context, block_width, offset));\n+        let block_str = try_opt!(self.block\n+            .rewrite(context, Shape::legacy(block_width, shape.indent)));\n \n         let cond_span = if let Some(cond) = self.cond {\n             cond.span\n@@ -917,12 +886,10 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                       context.codemap.span_before(self.span, self.matcher.trim())\n                   }));\n \n-        let between_kwd_cond_comment = extract_comment(between_kwd_cond, context, offset, width);\n+        let between_kwd_cond_comment = extract_comment(between_kwd_cond, context, shape);\n \n-        let after_cond_comment = extract_comment(mk_sp(cond_span.hi, self.block.span.lo),\n-                                                 context,\n-                                                 offset,\n-                                                 width);\n+        let after_cond_comment =\n+            extract_comment(mk_sp(cond_span.hi, self.block.span.lo), context, shape);\n \n         let alt_block_sep = String::from(\"\\n\") + &context.block_indent.to_string(context.config);\n         let block_sep = if self.cond.is_none() && between_kwd_cond_comment.is_some() {\n@@ -949,7 +916,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             let rewrite = match else_block.node {\n                 // If the else expression is another if-else expression, prevent it\n                 // from being formatted on a single line.\n-                // Note how we're passing the original width and offset, as the\n+                // Note how we're passing the original shape, as the\n                 // cost of \"else\" should not cascade.\n                 ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref next_else_block) => {\n                     ControlFlow::new_if(cond,\n@@ -959,7 +926,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                                         false,\n                                         true,\n                                         mk_sp(else_block.span.lo, self.span.hi))\n-                        .rewrite(context, width, offset)\n+                        .rewrite(context, shape)\n                 }\n                 ast::ExprKind::If(ref cond, ref if_block, ref next_else_block) => {\n                     ControlFlow::new_if(cond,\n@@ -969,13 +936,13 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                                         false,\n                                         true,\n                                         mk_sp(else_block.span.lo, self.span.hi))\n-                        .rewrite(context, width, offset)\n+                        .rewrite(context, shape)\n                 }\n                 _ => {\n                     last_in_chain = true;\n                     // When rewriting a block, the width is only used for single line\n                     // blocks, passing 1 lets us avoid that.\n-                    else_block.rewrite(context, min(1, width), offset)\n+                    else_block.rewrite(context, Shape::legacy(min(1, shape.width), shape.indent))\n                 }\n             };\n \n@@ -984,13 +951,13 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                       context.codemap\n                           .span_before(mk_sp(self.block.span.hi, else_block.span.lo), \"else\"));\n             let between_kwd_else_block_comment =\n-                extract_comment(between_kwd_else_block, context, offset, width);\n+                extract_comment(between_kwd_else_block, context, shape);\n \n             let after_else = mk_sp(context.codemap\n                                        .span_after(mk_sp(self.block.span.hi, else_block.span.lo),\n                                                    \"else\"),\n                                    else_block.span.lo);\n-            let after_else_comment = extract_comment(after_else, context, offset, width);\n+            let after_else_comment = extract_comment(after_else, context, shape);\n \n             let between_sep = match context.config.control_brace_style {\n                 ControlBraceStyle::AlwaysNextLine |\n@@ -1021,18 +988,13 @@ fn rewrite_label(label: Option<ast::SpannedIdent>) -> String {\n     }\n }\n \n-fn extract_comment(span: Span,\n-                   context: &RewriteContext,\n-                   offset: Indent,\n-                   width: usize)\n-                   -> Option<String> {\n+fn extract_comment(span: Span, context: &RewriteContext, shape: Shape) -> Option<String> {\n     let comment_str = context.snippet(span);\n     if contains_comment(&comment_str) {\n-        let comment =\n-            try_opt!(rewrite_comment(comment_str.trim(), false, width, offset, context.config));\n+        let comment = try_opt!(rewrite_comment(comment_str.trim(), false, shape, context.config));\n         Some(format!(\"\\n{indent}{}\\n{indent}\",\n                      comment,\n-                     indent = offset.to_string(context.config)))\n+                     indent = shape.indent.to_string(context.config)))\n     } else {\n         None\n     }\n@@ -1081,8 +1043,7 @@ fn is_unsafe_block(block: &ast::Block) -> bool {\n //    are about the second arm\n fn rewrite_match_arm_comment(context: &RewriteContext,\n                              missed_str: &str,\n-                             width: usize,\n-                             arm_indent: Indent,\n+                             shape: Shape,\n                              arm_indent_str: &str)\n                              -> Option<String> {\n     // The leading \",\" is not part of the arm-comment\n@@ -1105,8 +1066,7 @@ fn rewrite_match_arm_comment(context: &RewriteContext,\n     }\n     let missed_str = missed_str[first..].trim();\n     if !missed_str.is_empty() {\n-        let comment =\n-            try_opt!(rewrite_comment(&missed_str, false, width, arm_indent, context.config));\n+        let comment = try_opt!(rewrite_comment(&missed_str, false, shape, context.config));\n         result.push('\\n');\n         result.push_str(arm_indent_str);\n         result.push_str(&comment);\n@@ -1118,17 +1078,16 @@ fn rewrite_match_arm_comment(context: &RewriteContext,\n fn rewrite_match(context: &RewriteContext,\n                  cond: &ast::Expr,\n                  arms: &[ast::Arm],\n-                 width: usize,\n-                 offset: Indent,\n+                 shape: Shape,\n                  span: Span)\n                  -> Option<String> {\n     if arms.is_empty() {\n         return None;\n     }\n \n     // `match `cond` {`\n-    let cond_budget = try_opt!(width.checked_sub(8));\n-    let cond_str = try_opt!(cond.rewrite(context, cond_budget, offset + 6));\n+    let cond_budget = try_opt!(shape.width.checked_sub(8));\n+    let cond_str = try_opt!(cond.rewrite(context, Shape::legacy(cond_budget, shape.indent + 6)));\n     let alt_block_sep = String::from(\"\\n\") + &context.block_indent.to_string(context.config);\n     let block_sep = match context.config.control_brace_style {\n         ControlBraceStyle::AlwaysSameLine => \" \",\n@@ -1152,16 +1111,15 @@ fn rewrite_match(context: &RewriteContext,\n         };\n         let comment = try_opt!(rewrite_match_arm_comment(context,\n                                                          &missed_str,\n-                                                         width,\n-                                                         arm_indent,\n+                                                         Shape::legacy(shape.width, arm_indent),\n                                                          &arm_indent_str));\n         result.push_str(&comment);\n         result.push('\\n');\n         result.push_str(&arm_indent_str);\n \n         let arm_str = arm.rewrite(&nested_context,\n-                                  context.config.max_width - arm_indent.width(),\n-                                  arm_indent);\n+                                  Shape::legacy(context.config.max_width - arm_indent.width(),\n+                                                arm_indent));\n         if let Some(ref arm_str) = arm_str {\n             result.push_str(arm_str);\n         } else {\n@@ -1176,8 +1134,7 @@ fn rewrite_match(context: &RewriteContext,\n     let last_comment = context.snippet(last_span);\n     let comment = try_opt!(rewrite_match_arm_comment(context,\n                                                      &last_comment,\n-                                                     width,\n-                                                     arm_indent,\n+                                                     Shape::legacy(shape.width, arm_indent),\n                                                      &arm_indent_str));\n     result.push_str(&comment);\n     result.push('\\n');\n@@ -1221,8 +1178,8 @@ fn arm_comma(config: &Config, arm: &ast::Arm, body: &ast::Expr) -> &'static str\n \n // Match arms.\n impl Rewrite for ast::Arm {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        debug!(\"Arm::rewrite {:?} {} {:?}\", self, width, offset);\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        debug!(\"Arm::rewrite {:?} {:?}\", self, shape);\n         let &ast::Arm { ref attrs, ref pats, ref guard, ref body } = self;\n \n         // FIXME this is all a bit grotty, would be nice to abstract out the\n@@ -1245,9 +1202,9 @@ impl Rewrite for ast::Arm {\n \n         // Patterns\n         // 5 = ` => {`\n-        let pat_budget = try_opt!(width.checked_sub(5));\n+        let pat_budget = try_opt!(shape.width.checked_sub(5));\n         let pat_strs = try_opt!(pats.iter()\n-            .map(|p| p.rewrite(context, pat_budget, offset))\n+            .map(|p| p.rewrite(context, Shape::legacy(pat_budget, shape.indent)))\n             .collect::<Option<Vec<_>>>());\n \n         let all_simple = pat_strs.iter().all(|p| pat_is_simple(p));\n@@ -1260,30 +1217,28 @@ impl Rewrite for ast::Arm {\n             },\n             separator: \" |\",\n             trailing_separator: SeparatorTactic::Never,\n-            indent: offset,\n-            width: pat_budget,\n+            shape: Shape::legacy(pat_budget, shape.indent),\n             ends_with_newline: false,\n             config: context.config,\n         };\n         let pats_str = try_opt!(write_list(items, &fmt));\n \n         let budget = if pats_str.contains('\\n') {\n-            context.config.max_width - offset.width()\n+            context.config.max_width - shape.indent.width()\n         } else {\n-            width\n+            shape.width\n         };\n \n         let guard_str = try_opt!(rewrite_guard(context,\n                                                guard,\n-                                               budget,\n-                                               offset,\n+                                               Shape::legacy(budget, shape.indent),\n                                                trimmed_last_line_width(&pats_str)));\n \n         let pats_str = format!(\"{}{}\", pats_str, guard_str);\n         // Where the next text can start.\n         let mut line_start = last_line_width(&pats_str);\n         if !pats_str.contains('\\n') {\n-            line_start += offset.width();\n+            line_start += shape.indent.width();\n         }\n \n         let body = match body.node {\n@@ -1306,8 +1261,10 @@ impl Rewrite for ast::Arm {\n         // 4 = ` => `.len()\n         if context.config.max_width > line_start + comma.len() + 4 {\n             let budget = context.config.max_width - line_start - comma.len() - 4;\n-            let offset = Indent::new(offset.block_indent, line_start + 4 - offset.block_indent);\n-            let rewrite = nop_block_collapse(body.rewrite(context, budget, offset), budget);\n+            let offset = Indent::new(shape.indent.block_indent,\n+                                     line_start + 4 - shape.indent.block_indent);\n+            let rewrite = nop_block_collapse(body.rewrite(context, Shape::legacy(budget, offset)),\n+                                             budget);\n             let is_block = if let ast::ExprKind::Block(..) = body.node {\n                 true\n             } else {\n@@ -1335,13 +1292,14 @@ impl Rewrite for ast::Arm {\n \n         // FIXME: we're doing a second rewrite of the expr; This may not be\n         // necessary.\n-        let body_budget = try_opt!(width.checked_sub(context.config.tab_spaces));\n+        let body_budget = try_opt!(shape.width.checked_sub(context.config.tab_spaces));\n         let indent = context.block_indent.block_indent(context.config);\n         let inner_context = &RewriteContext { block_indent: indent, ..*context };\n-        let next_line_body =\n-            try_opt!(nop_block_collapse(body.rewrite(inner_context, body_budget, indent),\n-                                        body_budget));\n-        let indent_str = offset.block_indent(context.config).to_string(context.config);\n+        let next_line_body = try_opt!(nop_block_collapse(body.rewrite(inner_context,\n+                                                                      Shape::legacy(body_budget,\n+                                                                                    indent)),\n+                                                         body_budget));\n+        let indent_str = shape.indent.block_indent(context.config).to_string(context.config);\n         let (body_prefix, body_suffix) = if context.config.wrap_match_arms {\n             if context.config.match_block_trailing_comma {\n                 (\"{\", \"},\")\n@@ -1362,7 +1320,7 @@ impl Rewrite for ast::Arm {\n                      block_sep,\n                      indent_str,\n                      next_line_body,\n-                     offset.to_string(context.config),\n+                     shape.indent.to_string(context.config),\n                      body_suffix))\n     }\n }\n@@ -1377,8 +1335,7 @@ fn pat_is_simple(pat_str: &str) -> bool {\n // The `if ...` guard on a match arm.\n fn rewrite_guard(context: &RewriteContext,\n                  guard: &Option<ptr::P<ast::Expr>>,\n-                 width: usize,\n-                 offset: Indent,\n+                 shape: Shape,\n                  // The amount of space used up on this line for the pattern in\n                  // the arm (excludes offset).\n                  pattern_width: usize)\n@@ -1387,23 +1344,28 @@ fn rewrite_guard(context: &RewriteContext,\n         // First try to fit the guard string on the same line as the pattern.\n         // 4 = ` if `, 5 = ` => {`\n         let overhead = pattern_width + 4 + 5;\n-        if overhead < width {\n-            let cond_str = guard.rewrite(context, width - overhead, offset + pattern_width + 4);\n+        if overhead < shape.width {\n+            let cond_str = guard.rewrite(context,\n+                                         Shape::legacy(shape.width - overhead,\n+                                                       shape.indent + pattern_width + 4));\n             if let Some(cond_str) = cond_str {\n                 return Some(format!(\" if {}\", cond_str));\n             }\n         }\n \n         // Not enough space to put the guard after the pattern, try a newline.\n-        let overhead = offset.block_indent(context.config).width() + 4 + 5;\n-        if overhead < width {\n+        let overhead = shape.indent.block_indent(context.config).width() + 4 + 5;\n+        if overhead < shape.width {\n             let cond_str = guard.rewrite(context,\n-                                         width - overhead,\n-                                         // 3 == `if `\n-                                         offset.block_indent(context.config) + 3);\n+                                         Shape::legacy(shape.width - overhead,\n+                                                       // 3 == `if `\n+                                                       shape.indent.block_indent(context.config) +\n+                                                       3));\n             if let Some(cond_str) = cond_str {\n                 return Some(format!(\"\\n{}if {}\",\n-                                    offset.block_indent(context.config).to_string(context.config),\n+                                    shape.indent\n+                                        .block_indent(context.config)\n+                                        .to_string(context.config),\n                                     cond_str));\n             }\n         }\n@@ -1421,8 +1383,7 @@ fn rewrite_pat_expr(context: &RewriteContext,\n                     // Connecting piece between pattern and expression,\n                     // *without* trailing space.\n                     connector: &str,\n-                    width: usize,\n-                    offset: Indent)\n+                    shape: Shape)\n                     -> Option<String> {\n     let mut result = match pat {\n         Some(pat) => {\n@@ -1431,29 +1392,33 @@ fn rewrite_pat_expr(context: &RewriteContext,\n             } else {\n                 format!(\"{} \", matcher)\n             };\n-            let pat_budget = try_opt!(width.checked_sub(connector.len() + matcher.len()));\n-            let pat_offset = offset + matcher.len();\n-            let pat_string = try_opt!(pat.rewrite(context, pat_budget, pat_offset));\n+            let pat_budget = try_opt!(shape.width.checked_sub(connector.len() + matcher.len()));\n+            let pat_offset = shape.indent + matcher.len();\n+            let pat_string = try_opt!(pat.rewrite(context, Shape::legacy(pat_budget, pat_offset)));\n             format!(\"{}{}{}\", matcher, pat_string, connector)\n         }\n         None => String::new(),\n     };\n \n     // Consider only the last line of the pat string.\n-    let extra_offset = extra_offset(&result, offset);\n+    let extra_offset = extra_offset(&result, shape.indent);\n \n     // The expression may (partionally) fit on the current line.\n-    if width > extra_offset + 1 {\n+    if shape.width > extra_offset + 1 {\n         let spacer = if pat.is_some() { \" \" } else { \"\" };\n \n         let expr_rewrite = expr.rewrite(context,\n-                                        try_opt!(width.checked_sub(extra_offset + spacer.len())),\n-                                        offset + extra_offset + spacer.len());\n+                                        Shape::legacy(try_opt!(shape.width\n+                                                          .checked_sub(extra_offset +\n+                                                                       spacer.len())),\n+                                                      shape.indent + extra_offset + spacer.len()));\n \n         if let Some(expr_string) = expr_rewrite {\n-            let pat_simple =\n-                pat.and_then(|p| p.rewrite(context, context.config.max_width, Indent::empty()))\n-                    .map(|s| pat_is_simple(&s));\n+            let pat_simple = pat.and_then(|p| {\n+                    p.rewrite(context,\n+                              Shape::legacy(context.config.max_width, Indent::empty()))\n+                })\n+                .map(|s| pat_is_simple(&s));\n \n             if pat.is_none() || pat_simple.unwrap_or(false) || !expr_string.contains('\\n') {\n                 result.push_str(spacer);\n@@ -1469,28 +1434,25 @@ fn rewrite_pat_expr(context: &RewriteContext,\n     result.push('\\n');\n     result.push_str(&nested.block_indent.to_string(context.config));\n \n-    let expr_rewrite =\n-        expr.rewrite(&nested,\n-                     try_opt!(context.config.max_width.checked_sub(nested.block_indent.width())),\n-                     nested.block_indent);\n+    let expr_rewrite = expr.rewrite(&nested,\n+                                    Shape::legacy(try_opt!(context.config\n+                                                      .max_width\n+                                                      .checked_sub(nested.block_indent.width())),\n+                                                  nested.block_indent));\n     result.push_str(&try_opt!(expr_rewrite));\n \n     Some(result)\n }\n \n-fn rewrite_string_lit(context: &RewriteContext,\n-                      span: Span,\n-                      width: usize,\n-                      offset: Indent)\n-                      -> Option<String> {\n+fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Option<String> {\n     let string_lit = context.snippet(span);\n \n     if !context.config.format_strings && !context.config.force_format_strings {\n         return Some(string_lit);\n     }\n \n     if !context.config.force_format_strings &&\n-       !string_requires_rewrite(context, span, &string_lit, width, offset) {\n+       !string_requires_rewrite(context, span, &string_lit, shape) {\n         return Some(string_lit);\n     }\n \n@@ -1499,8 +1461,7 @@ fn rewrite_string_lit(context: &RewriteContext,\n         closer: \"\\\"\",\n         line_start: \" \",\n         line_end: \"\\\\\",\n-        width: width,\n-        offset: offset,\n+        shape: shape,\n         trim_end: false,\n         config: context.config,\n     };\n@@ -1514,20 +1475,19 @@ fn rewrite_string_lit(context: &RewriteContext,\n fn string_requires_rewrite(context: &RewriteContext,\n                            span: Span,\n                            string: &str,\n-                           width: usize,\n-                           offset: Indent)\n+                           shape: Shape)\n                            -> bool {\n-    if context.codemap.lookup_char_pos(span.lo).col.0 != offset.width() {\n+    if context.codemap.lookup_char_pos(span.lo).col.0 != shape.indent.width() {\n         return true;\n     }\n \n     for (i, line) in string.lines().enumerate() {\n         if i == 0 {\n-            if line.len() > width {\n+            if line.len() > shape.width {\n                 return true;\n             }\n         } else {\n-            if line.len() > width + offset.width() {\n+            if line.len() > shape.width + shape.indent.width() {\n                 return true;\n             }\n         }\n@@ -1540,17 +1500,15 @@ pub fn rewrite_call<R>(context: &RewriteContext,\n                        callee: &R,\n                        args: &[ptr::P<ast::Expr>],\n                        span: Span,\n-                       width: usize,\n-                       offset: Indent)\n+                       shape: Shape)\n                        -> Option<String>\n     where R: Rewrite\n {\n-    let closure = |callee_max_width| {\n-        rewrite_call_inner(context, callee, callee_max_width, args, span, width, offset)\n-    };\n+    let closure =\n+        |callee_max_width| rewrite_call_inner(context, callee, callee_max_width, args, span, shape);\n \n     // 2 is for parens\n-    let max_width = try_opt!(width.checked_sub(2));\n+    let max_width = try_opt!(shape.width.checked_sub(2));\n     binary_search(1, max_width, closure)\n }\n \n@@ -1559,15 +1517,14 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n                          max_callee_width: usize,\n                          args: &[ptr::P<ast::Expr>],\n                          span: Span,\n-                         width: usize,\n-                         offset: Indent)\n+                         shape: Shape)\n                          -> Result<String, Ordering>\n     where R: Rewrite\n {\n     let callee = callee.borrow();\n     // FIXME using byte lens instead of char lens (and probably all over the\n     // place too)\n-    let callee_str = match callee.rewrite(context, max_callee_width, offset) {\n+    let callee_str = match callee.rewrite(context, Shape::legacy(max_callee_width, shape.indent)) {\n         Some(string) => {\n             if !string.contains('\\n') && string.len() > max_callee_width {\n                 panic!(\"{:?} {}\", string, max_callee_width);\n@@ -1581,13 +1538,13 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     let span_lo = context.codemap.span_after(span, \"(\");\n     let span = mk_sp(span_lo, span.hi);\n \n-    let extra_offset = extra_offset(&callee_str, offset);\n+    let extra_offset = extra_offset(&callee_str, shape.indent);\n     // 2 is for parens.\n-    let remaining_width = match width.checked_sub(extra_offset + 2) {\n+    let remaining_width = match shape.width.checked_sub(extra_offset + 2) {\n         Some(str) => str,\n         None => return Err(Ordering::Greater),\n     };\n-    let offset = offset + extra_offset + 1;\n+    let offset = shape.indent + extra_offset + 1;\n     let arg_count = args.len();\n     let block_indent = if arg_count == 1 {\n         context.block_indent\n@@ -1596,14 +1553,15 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     };\n     let inner_context = &RewriteContext { block_indent: block_indent, ..*context };\n \n-    let items = itemize_list(context.codemap,\n-                             args.iter(),\n-                             \")\",\n-                             |item| item.span.lo,\n-                             |item| item.span.hi,\n-                             |item| item.rewrite(inner_context, remaining_width, offset),\n-                             span.lo,\n-                             span.hi);\n+    let items =\n+        itemize_list(context.codemap,\n+                     args.iter(),\n+                     \")\",\n+                     |item| item.span.lo,\n+                     |item| item.span.hi,\n+                     |item| item.rewrite(inner_context, Shape::legacy(remaining_width, offset)),\n+                     span.lo,\n+                     span.hi);\n     let mut item_vec: Vec<_> = items.collect();\n \n     // Try letting the last argument overflow to the next line with block\n@@ -1622,7 +1580,8 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     // first arguments.\n     if overflow_last {\n         let inner_context = &RewriteContext { block_indent: context.block_indent, ..*context };\n-        let rewrite = args.last().unwrap().rewrite(inner_context, remaining_width, offset);\n+        let rewrite =\n+            args.last().unwrap().rewrite(inner_context, Shape::legacy(remaining_width, offset));\n \n         if let Some(rewrite) = rewrite {\n             let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n@@ -1654,8 +1613,7 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n-        indent: offset,\n-        width: width,\n+        shape: Shape::legacy(shape.width, offset),\n         ends_with_newline: false,\n         config: context.config,\n     };\n@@ -1672,15 +1630,13 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     })\n }\n \n-fn rewrite_paren(context: &RewriteContext,\n-                 subexpr: &ast::Expr,\n-                 width: usize,\n-                 offset: Indent)\n-                 -> Option<String> {\n-    debug!(\"rewrite_paren, width: {}, offset: {:?}\", width, offset);\n+fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, shape: Shape) -> Option<String> {\n+    debug!(\"rewrite_paren, shape: {:?}\", shape);\n     // 1 is for opening paren, 2 is for opening+closing, we want to keep the closing\n     // paren on the same line as the subexpr.\n-    let subexpr_str = subexpr.rewrite(context, try_opt!(width.checked_sub(2)), offset + 1);\n+    let subexpr_str = subexpr.rewrite(context,\n+                                      Shape::legacy(try_opt!(shape.width.checked_sub(2)),\n+                                                    shape.indent + 1));\n     debug!(\"rewrite_paren, subexpr_str: `{:?}`\", subexpr_str);\n \n     subexpr_str.map(|s| if context.config.spaces_within_parens && s.len() > 0 {\n@@ -1693,30 +1649,29 @@ fn rewrite_paren(context: &RewriteContext,\n fn rewrite_index(expr: &ast::Expr,\n                  index: &ast::Expr,\n                  context: &RewriteContext,\n-                 width: usize,\n-                 offset: Indent)\n+                 shape: Shape)\n                  -> Option<String> {\n-    let expr_str = try_opt!(expr.rewrite(context, width, offset));\n+    let expr_str = try_opt!(expr.rewrite(context, shape));\n \n     let (lbr, rbr) = if context.config.spaces_within_square_brackets {\n         (\"[ \", \" ]\")\n     } else {\n         (\"[\", \"]\")\n     };\n \n-    let budget = width.checked_sub(expr_str.len() + lbr.len() + rbr.len()).unwrap_or(0);\n-    let index_str = index.rewrite(context, budget, offset);\n+    let budget = shape.width.checked_sub(expr_str.len() + lbr.len() + rbr.len()).unwrap_or(0);\n+    let index_str = index.rewrite(context, Shape::legacy(budget, shape.indent));\n     if let Some(index_str) = index_str {\n         return Some(format!(\"{}{}{}{}\", expr_str, lbr, index_str, rbr));\n     }\n \n-    let indent = offset.block_indent(&context.config);\n+    let indent = shape.indent.block_indent(&context.config);\n     let indent = indent.to_string(&context.config);\n-    // FIXME this is not right, since we don't take into account that width\n+    // FIXME this is not right, since we don't take into account that shape.width\n     // might be reduced from max_width by something on the right.\n     let budget =\n         try_opt!(context.config.max_width.checked_sub(indent.len() + lbr.len() + rbr.len()));\n-    let index_str = try_opt!(index.rewrite(context, budget, offset));\n+    let index_str = try_opt!(index.rewrite(context, Shape::legacy(budget, shape.indent)));\n     Some(format!(\"{}\\n{}{}{}{}\", expr_str, indent, lbr, index_str, rbr))\n }\n \n@@ -1725,26 +1680,28 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                           fields: &'a [ast::Field],\n                           base: Option<&'a ast::Expr>,\n                           span: Span,\n-                          width: usize,\n-                          offset: Indent)\n+                          shape: Shape)\n                           -> Option<String> {\n-    debug!(\"rewrite_struct_lit: width {}, offset {:?}\", width, offset);\n+    debug!(\"rewrite_struct_lit: shape {:?}\", shape);\n \n     enum StructLitField<'a> {\n         Regular(&'a ast::Field),\n         Base(&'a ast::Expr),\n     }\n \n     // 2 = \" {\".len()\n-    let path_budget = try_opt!(width.checked_sub(2));\n-    let path_str =\n-        try_opt!(rewrite_path(context, PathContext::Expr, None, path, path_budget, offset));\n+    let path_budget = try_opt!(shape.width.checked_sub(2));\n+    let path_str = try_opt!(rewrite_path(context,\n+                                         PathContext::Expr,\n+                                         None,\n+                                         path,\n+                                         Shape::legacy(path_budget, shape.indent)));\n \n     // Foo { a: Foo } - indent is +3, width is -5.\n-    let h_budget = width.checked_sub(path_str.len() + 5).unwrap_or(0);\n+    let h_budget = shape.width.checked_sub(path_str.len() + 5).unwrap_or(0);\n     // The 1 taken from the v_budget is for the comma.\n     let (indent, v_budget) = match context.config.struct_lit_style {\n-        StructLitStyle::Visual => (offset + path_str.len() + 3, h_budget),\n+        StructLitStyle::Visual => (shape.indent + path_str.len() + 3, h_budget),\n         StructLitStyle::Block => {\n             // If we are all on one line, then we'll ignore the indent, and we\n             // have a smaller budget.\n@@ -1783,12 +1740,12 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n             StructLitField::Regular(field) => {\n                 rewrite_field(inner_context,\n                               field,\n-                              v_budget.checked_sub(1).unwrap_or(0),\n-                              indent)\n+                              Shape::legacy(v_budget.checked_sub(1).unwrap_or(0), indent))\n             }\n             StructLitField::Base(expr) => {\n                 // 2 = ..\n-                expr.rewrite(inner_context, try_opt!(v_budget.checked_sub(2)), indent + 2)\n+                expr.rewrite(inner_context,\n+                             Shape::legacy(try_opt!(v_budget.checked_sub(2)), indent + 2))\n                     .map(|s| format!(\"..{}\", s))\n             }\n         }\n@@ -1826,8 +1783,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         } else {\n             context.config.struct_lit_trailing_comma\n         },\n-        indent: indent,\n-        width: budget,\n+        shape: Shape::legacy(budget, indent),\n         ends_with_newline: ends_with_newline,\n         config: context.config,\n     };\n@@ -1870,27 +1826,23 @@ pub fn type_annotation_separator(config: &Config) -> &str {\n     }\n }\n \n-fn rewrite_field(context: &RewriteContext,\n-                 field: &ast::Field,\n-                 width: usize,\n-                 offset: Indent)\n-                 -> Option<String> {\n+fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) -> Option<String> {\n     let name = &field.ident.node.to_string();\n     let separator = type_annotation_separator(context.config);\n     let overhead = name.len() + separator.len();\n     let expr = field.expr.rewrite(context,\n-                                  try_opt!(width.checked_sub(overhead)),\n-                                  offset + overhead);\n+                                  Shape::legacy(try_opt!(shape.width.checked_sub(overhead)),\n+                                                shape.indent + overhead));\n \n     match expr {\n         Some(e) => Some(format!(\"{}{}{}\", name, separator, e)),\n         None => {\n-            let expr_offset = offset.block_indent(context.config);\n+            let expr_offset = shape.indent.block_indent(context.config);\n             let expr = field.expr.rewrite(context,\n-                                          try_opt!(context.config\n-                                              .max_width\n-                                              .checked_sub(expr_offset.width())),\n-                                          expr_offset);\n+                                          Shape::legacy(try_opt!(context.config\n+                                                            .max_width\n+                                                            .checked_sub(expr_offset.width())),\n+                                                        expr_offset));\n             expr.map(|s| format!(\"{}:\\n{}{}\", name, expr_offset.to_string(&context.config), s))\n         }\n     }\n@@ -1899,23 +1851,22 @@ fn rewrite_field(context: &RewriteContext,\n pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n                             mut items: I,\n                             span: Span,\n-                            width: usize,\n-                            offset: Indent)\n+                            shape: Shape)\n                             -> Option<String>\n     where I: ExactSizeIterator,\n           <I as Iterator>::Item: Deref,\n           <I::Item as Deref>::Target: Rewrite + Spanned + 'a\n {\n-    let indent = offset + 1;\n+    let indent = shape.indent + 1;\n     let aligned = RewriteContext { block_indent: indent, ..context.clone() };\n \n     // In case of length 1, need a trailing comma\n     if items.len() == 1 {\n         // 3 = \"(\" + \",)\"\n-        let budget = try_opt!(width.checked_sub(3));\n+        let budget = try_opt!(shape.width.checked_sub(3));\n         return items.next()\n             .unwrap()\n-            .rewrite(&aligned, budget, indent)\n+            .rewrite(&aligned, Shape::legacy(budget, indent))\n             .map(|s| if context.config.spaces_within_parens {\n                 format!(\"( {}, )\", s)\n             } else {\n@@ -1924,16 +1875,16 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n     }\n \n     let list_lo = context.codemap.span_after(span, \"(\");\n-    let budget = try_opt!(width.checked_sub(2));\n+    let budget = try_opt!(shape.width.checked_sub(2));\n     let items = itemize_list(context.codemap,\n                              items,\n                              \")\",\n                              |item| item.span().lo,\n                              |item| item.span().hi,\n-                             |item| item.rewrite(&aligned, budget, indent),\n+                             |item| item.rewrite(&aligned, Shape::legacy(budget, indent)),\n                              list_lo,\n                              span.hi - BytePos(1));\n-    let list_str = try_opt!(format_item_list(items, budget, indent, context.config));\n+    let list_str = try_opt!(format_item_list(items, Shape::legacy(budget, indent), context.config));\n \n     if context.config.spaces_within_parens && list_str.len() > 0 {\n         Some(format!(\"( {} )\", list_str))\n@@ -1945,12 +1896,11 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n pub fn rewrite_unary_prefix<R: Rewrite>(context: &RewriteContext,\n                                         prefix: &str,\n                                         rewrite: &R,\n-                                        width: usize,\n-                                        offset: Indent)\n+                                        shape: Shape)\n                                         -> Option<String> {\n     rewrite.rewrite(context,\n-                 try_opt!(width.checked_sub(prefix.len())),\n-                 offset + prefix.len())\n+                 Shape::legacy(try_opt!(shape.width.checked_sub(prefix.len())),\n+                               shape.indent + prefix.len()))\n         .map(|r| format!(\"{}{}\", prefix, r))\n }\n \n@@ -1959,10 +1909,11 @@ pub fn rewrite_unary_prefix<R: Rewrite>(context: &RewriteContext,\n pub fn rewrite_unary_suffix<R: Rewrite>(context: &RewriteContext,\n                                         suffix: &str,\n                                         rewrite: &R,\n-                                        width: usize,\n-                                        offset: Indent)\n+                                        shape: Shape)\n                                         -> Option<String> {\n-    rewrite.rewrite(context, try_opt!(width.checked_sub(suffix.len())), offset)\n+    rewrite.rewrite(context,\n+                 Shape::legacy(try_opt!(shape.width.checked_sub(suffix.len())),\n+                               shape.indent))\n         .map(|mut r| {\n             r.push_str(suffix);\n             r\n@@ -1972,57 +1923,55 @@ pub fn rewrite_unary_suffix<R: Rewrite>(context: &RewriteContext,\n fn rewrite_unary_op(context: &RewriteContext,\n                     op: &ast::UnOp,\n                     expr: &ast::Expr,\n-                    width: usize,\n-                    offset: Indent)\n+                    shape: Shape)\n                     -> Option<String> {\n     // For some reason, an UnOp is not spanned like BinOp!\n     let operator_str = match *op {\n         ast::UnOp::Deref => \"*\",\n         ast::UnOp::Not => \"!\",\n         ast::UnOp::Neg => \"-\",\n     };\n-    rewrite_unary_prefix(context, operator_str, expr, width, offset)\n+    rewrite_unary_prefix(context, operator_str, expr, shape)\n }\n \n fn rewrite_assignment(context: &RewriteContext,\n                       lhs: &ast::Expr,\n                       rhs: &ast::Expr,\n                       op: Option<&ast::BinOp>,\n-                      width: usize,\n-                      offset: Indent)\n+                      shape: Shape)\n                       -> Option<String> {\n     let operator_str = match op {\n         Some(op) => context.snippet(op.span),\n         None => \"=\".to_owned(),\n     };\n \n     // 1 = space between lhs and operator.\n-    let max_width = try_opt!(width.checked_sub(operator_str.len() + 1));\n+    let max_width = try_opt!(shape.width.checked_sub(operator_str.len() + 1));\n     let lhs_str = format!(\"{} {}\",\n-                          try_opt!(lhs.rewrite(context, max_width, offset)),\n+                          try_opt!(lhs.rewrite(context, Shape::legacy(max_width, shape.indent))),\n                           operator_str);\n \n-    rewrite_assign_rhs(context, lhs_str, rhs, width, offset)\n+    rewrite_assign_rhs(context, lhs_str, rhs, shape)\n }\n \n // The left hand side must contain everything up to, and including, the\n // assignment operator.\n pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n                                            lhs: S,\n                                            ex: &ast::Expr,\n-                                           width: usize,\n-                                           offset: Indent)\n+                                           shape: Shape)\n                                            -> Option<String> {\n     let mut result = lhs.into();\n     let last_line_width = last_line_width(&result) -\n                           if result.contains('\\n') {\n-        offset.width()\n+        shape.indent.width()\n     } else {\n         0\n     };\n     // 1 = space between operator and rhs.\n-    let max_width = try_opt!(width.checked_sub(last_line_width + 1));\n-    let rhs = ex.rewrite(context, max_width, offset + last_line_width + 1);\n+    let max_width = try_opt!(shape.width.checked_sub(last_line_width + 1));\n+    let rhs = ex.rewrite(context,\n+                         Shape::legacy(max_width, shape.indent + last_line_width + 1));\n \n     fn count_line_breaks(src: &str) -> usize {\n         src.chars().filter(|&x| x == '\\n').count()\n@@ -2037,10 +1986,11 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n             // Expression did not fit on the same line as the identifier or is\n             // at least three lines big. Try splitting the line and see\n             // if that works better.\n-            let new_offset = offset.block_indent(context.config);\n-            let max_width = try_opt!((width + offset.width()).checked_sub(new_offset.width()));\n+            let new_offset = shape.indent.block_indent(context.config);\n+            let max_width = try_opt!((shape.width + shape.indent.width())\n+                .checked_sub(new_offset.width()));\n             let inner_context = context.nested_context();\n-            let new_rhs = ex.rewrite(&inner_context, max_width, new_offset);\n+            let new_rhs = ex.rewrite(&inner_context, Shape::legacy(max_width, new_offset));\n \n             // FIXME: DRY!\n             match (rhs, new_rhs) {\n@@ -2069,12 +2019,11 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n fn rewrite_expr_addrof(context: &RewriteContext,\n                        mutability: ast::Mutability,\n                        expr: &ast::Expr,\n-                       width: usize,\n-                       offset: Indent)\n+                       shape: Shape)\n                        -> Option<String> {\n     let operator_str = match mutability {\n         ast::Mutability::Immutable => \"&\",\n         ast::Mutability::Mutable => \"&mut \",\n     };\n-    rewrite_unary_prefix(context, operator_str, expr, width, offset)\n+    rewrite_unary_prefix(context, operator_str, expr, shape)\n }"}, {"sha": "6e7c2d0f7e2d273f05113c60909ed11e389965cf", "filename": "src/imports.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use Indent;\n+use Shape;\n use utils;\n use syntax::codemap::{self, BytePos, Span};\n use codemap::SpanUtils;\n@@ -125,19 +125,19 @@ fn compare_use_items(a: &ast::Item, b: &ast::Item) -> Option<Ordering> {\n \n impl Rewrite for ast::ViewPath {\n     // Returns an empty string when the ViewPath is empty (like foo::bar::{})\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match self.node {\n             ast::ViewPath_::ViewPathList(_, ref path_list) if path_list.is_empty() => {\n                 Some(String::new())\n             }\n             ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n-                rewrite_use_list(width, offset, path, path_list, self.span, context)\n+                rewrite_use_list(shape, path, path_list, self.span, context)\n             }\n             ast::ViewPath_::ViewPathGlob(_) => None,\n             ast::ViewPath_::ViewPathSimple(ident, ref path) => {\n                 let ident_str = ident.to_string();\n                 // 4 = \" as \".len()\n-                let budget = try_opt!(width.checked_sub(ident_str.len() + 4));\n+                let budget = try_opt!(shape.width.checked_sub(ident_str.len() + 4));\n \n                 let path_str = if path.segments.last().unwrap().identifier.to_string() == \"self\" &&\n                                   path.segments.len() > 1 {\n@@ -149,10 +149,13 @@ impl Rewrite for ast::ViewPath {\n                                           PathContext::Import,\n                                           None,\n                                           &path,\n-                                          budget,\n-                                          offset))\n+                                          Shape::legacy(budget, shape.indent)))\n                 } else {\n-                    try_opt!(rewrite_path(context, PathContext::Import, None, path, budget, offset))\n+                    try_opt!(rewrite_path(context,\n+                                          PathContext::Import,\n+                                          None,\n+                                          path,\n+                                          Shape::legacy(budget, shape.indent)))\n                 };\n \n                 Some(if path.segments.last().unwrap().identifier == ident {\n@@ -225,8 +228,7 @@ impl<'a> FmtVisitor<'a> {\n         offset.alignment += vis.len() + \"use \".len();\n         // 1 = \";\"\n         match vp.rewrite(&self.get_context(),\n-                         self.config.max_width - offset.width() - 1,\n-                         offset) {\n+                         Shape::legacy(self.config.max_width - offset.width() - 1, offset)) {\n             Some(ref s) if s.is_empty() => {\n                 // Format up to last newline\n                 let prev_span = codemap::mk_sp(self.last_pos, source!(self, span).lo);\n@@ -283,15 +285,14 @@ fn append_alias(path_item_str: String, vpi: &ast::PathListItem) -> String {\n \n // Pretty prints a multi-item import.\n // Assumes that path_list.len() > 0.\n-pub fn rewrite_use_list(width: usize,\n-                        offset: Indent,\n+pub fn rewrite_use_list(shape: Shape,\n                         path: &ast::Path,\n                         path_list: &[ast::PathListItem],\n                         span: Span,\n                         context: &RewriteContext)\n                         -> Option<String> {\n     // Returns a different option to distinguish `::foo` and `foo`\n-    let path_str = try_opt!(rewrite_path(context, PathContext::Import, None, path, width, offset));\n+    let path_str = try_opt!(rewrite_path(context, PathContext::Import, None, path, shape));\n \n     match path_list.len() {\n         0 => unreachable!(),\n@@ -300,7 +301,7 @@ pub fn rewrite_use_list(width: usize,\n     }\n \n     // 2 = {}\n-    let remaining_width = width.checked_sub(path_str.len() + 2).unwrap_or(0);\n+    let remaining_width = shape.width.checked_sub(path_str.len() + 2).unwrap_or(0);\n \n     let mut items = {\n         // Dummy value, see explanation below.\n@@ -336,11 +337,11 @@ pub fn rewrite_use_list(width: usize,\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n-        indent: offset + path_str.len() + 1 + colons_offset,\n         // FIXME This is too conservative, and will not use all width\n         // available\n         // (loose 1 column (\";\"))\n-        width: remaining_width,\n+        shape: Shape::legacy(remaining_width,\n+                             shape.indent + path_str.len() + 1 + colons_offset),\n         ends_with_newline: false,\n         config: context.config,\n     };"}, {"sha": "3c5bf3ce6ceeda2fc759cd5eef24385290bdb984", "filename": "src/items.rs", "status": "modified", "additions": 160, "deletions": 142, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -10,7 +10,7 @@\n \n // Formatting top-level items - functions, structs, enums, traits, impls.\n \n-use Indent;\n+use {Indent, Shape};\n use codemap::SpanUtils;\n use utils::{format_mutability, format_visibility, contains_skip, end_typaram, wrap_str,\n             last_line_width, format_unsafety, trim_newlines, stmt_expr, semicolon_for_expr};\n@@ -30,14 +30,18 @@ use syntax::ast::ImplItem;\n // Statements of the form\n // let pat: ty = init;\n impl Rewrite for ast::Local {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        debug!(\"Local::rewrite {:?} {} {:?}\", self, width, offset);\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        debug!(\"Local::rewrite {:?} {} {:?}\",\n+               self,\n+               shape.width,\n+               shape.indent);\n         let mut result = \"let \".to_owned();\n-        let pattern_offset = offset + result.len();\n+        let pattern_offset = shape.indent + result.len();\n         // 1 = ;\n-        let pattern_width = try_opt!(width.checked_sub(pattern_offset.width() + 1));\n+        let pattern_width = try_opt!(shape.width.checked_sub(pattern_offset.width() + 1));\n \n-        let pat_str = try_opt!(self.pat.rewrite(&context, pattern_width, pattern_offset));\n+        let pat_str = try_opt!(self.pat\n+            .rewrite(&context, Shape::legacy(pattern_width, pattern_offset)));\n         result.push_str(&pat_str);\n \n         // String that is placed within the assignment pattern and expression.\n@@ -46,10 +50,10 @@ impl Rewrite for ast::Local {\n \n             if let Some(ref ty) = self.ty {\n                 let separator = type_annotation_separator(context.config);\n-                let indent = offset + last_line_width(&result) + separator.len();\n+                let indent = shape.indent + last_line_width(&result) + separator.len();\n                 // 1 = ;\n-                let budget = try_opt!(width.checked_sub(indent.width() + 1));\n-                let rewrite = try_opt!(ty.rewrite(context, budget, indent));\n+                let budget = try_opt!(shape.width.checked_sub(indent.width() + 1));\n+                let rewrite = try_opt!(ty.rewrite(context, Shape::legacy(budget, indent)));\n \n                 infix.push_str(separator);\n                 infix.push_str(&rewrite);\n@@ -66,10 +70,12 @@ impl Rewrite for ast::Local {\n \n         if let Some(ref ex) = self.init {\n             // 1 = trailing semicolon;\n-            let budget = try_opt!(width.checked_sub(context.block_indent.width() + 1));\n+            let budget = try_opt!(shape.width.checked_sub(context.block_indent.width() + 1));\n \n-            result =\n-                try_opt!(rewrite_assign_rhs(&context, result, ex, budget, context.block_indent));\n+            result = try_opt!(rewrite_assign_rhs(&context,\n+                                                 result,\n+                                                 ex,\n+                                                 Shape::legacy(budget, context.block_indent)));\n         }\n \n         result.push(';');\n@@ -200,7 +206,7 @@ impl<'a> FmtVisitor<'a> {\n                 let offset = self.block_indent + prefix.len();\n                 // 1 = ;\n                 let width = self.config.max_width - offset.width() - 1;\n-                let rewrite = ty.rewrite(&self.get_context(), width, offset);\n+                let rewrite = ty.rewrite(&self.get_context(), Shape::legacy(width, offset));\n \n                 match rewrite {\n                     Some(result) => {\n@@ -321,15 +327,17 @@ impl<'a> FmtVisitor<'a> {\n                             let suffix = if semicolon_for_expr(e) { \";\" } else { \"\" };\n \n                             e.rewrite(&self.get_context(),\n-                                         self.config.max_width - self.block_indent.width(),\n-                                         self.block_indent)\n+                                         Shape::legacy(self.config.max_width -\n+                                                       self.block_indent.width(),\n+                                                       self.block_indent))\n                                 .map(|s| s + suffix)\n                                 .or_else(|| Some(self.snippet(e.span)))\n                         }\n                         None => {\n                             stmt.rewrite(&self.get_context(),\n-                                         self.config.max_width - self.block_indent.width(),\n-                                         self.block_indent)\n+                                         Shape::legacy(self.config.max_width -\n+                                                       self.block_indent.width(),\n+                                                       self.block_indent))\n                         }\n                     }\n                 } else {\n@@ -426,8 +434,7 @@ impl<'a> FmtVisitor<'a> {\n             tactic: DefinitiveListTactic::Vertical,\n             separator: \",\",\n             trailing_separator: SeparatorTactic::from_bool(self.config.enum_trailing_comma),\n-            indent: self.block_indent,\n-            width: budget,\n+            shape: Shape::legacy(budget, self.block_indent),\n             ends_with_newline: true,\n             config: self.config,\n         };\n@@ -450,8 +457,7 @@ impl<'a> FmtVisitor<'a> {\n         let mut result = try_opt!(field.node\n             .attrs\n             .rewrite(&self.get_context(),\n-                     self.config.max_width - indent.width(),\n-                     indent));\n+                     Shape::legacy(self.config.max_width - indent.width(), indent)));\n         if !result.is_empty() {\n             result.push('\\n');\n             result.push_str(&indent.to_string(self.config));\n@@ -481,8 +487,7 @@ impl<'a> FmtVisitor<'a> {\n \n                 wrap_str(tag,\n                          self.config.max_width,\n-                         self.config.max_width - indent.width(),\n-                         indent)\n+                         Shape::legacy(self.config.max_width - indent.width(), indent))\n             }\n         };\n \n@@ -514,8 +519,8 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n                                                              &generics.where_clause,\n                                                              context.config,\n                                                              context.config.item_brace_style,\n-                                                             context.block_indent,\n-                                                             where_budget,\n+                                                             Shape::legacy(where_budget,\n+                                                                           context.block_indent),\n                                                              context.config.where_density,\n                                                              \"{\",\n                                                              true,\n@@ -628,8 +633,8 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n         };\n         let generics_str = try_opt!(rewrite_generics(context,\n                                                      generics,\n-                                                     offset,\n-                                                     context.config.max_width,\n+                                                     Shape::legacy(context.config.max_width,\n+                                                                   offset),\n                                                      offset + result.len(),\n                                                      mk_sp(lo, hi)));\n         result.push_str(&generics_str);\n@@ -643,7 +648,7 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n             }\n             let budget = try_opt!(context.config.max_width.checked_sub(result.len()));\n             let indent = offset + result.len();\n-            result.push_str(&*try_opt!(trait_ref.rewrite(context, budget, indent)));\n+            result.push_str(&*try_opt!(trait_ref.rewrite(context, Shape::legacy(budget, indent))));\n \n             if split_at_for {\n                 result.push('\\n');\n@@ -673,7 +678,7 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n         // 1 = space before the type.\n         let budget = try_opt!(context.config.max_width.checked_sub(used_space + 1));\n         let indent = offset + result.len() + 1;\n-        let self_ty_str = self_ty.rewrite(context, budget, indent);\n+        let self_ty_str = self_ty.rewrite(context, Shape::legacy(budget, indent));\n         if let Some(self_ty_str) = self_ty_str {\n             result.push_str(\" \");\n             result.push_str(&self_ty_str);\n@@ -684,7 +689,7 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n         let indent = offset.block_indent(context.config);\n         result.push_str(&format!(\"\\n{}\", indent.to_string(context.config)));\n         let budget = try_opt!(context.config.max_width.checked_sub(indent.width()));\n-        result.push_str(&*try_opt!(self_ty.rewrite(context, budget, indent)));\n+        result.push_str(&*try_opt!(self_ty.rewrite(context, Shape::legacy(budget, indent))));\n         Some(result)\n     } else {\n         unreachable!();\n@@ -742,16 +747,16 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n \n         let generics_str = try_opt!(rewrite_generics(context,\n                                                      generics,\n-                                                     offset,\n-                                                     context.config.max_width,\n+                                                     Shape::legacy(context.config.max_width,\n+                                                                   offset),\n                                                      offset + result.len(),\n                                                      mk_sp(item.span.lo, body_lo)));\n         result.push_str(&generics_str);\n \n-        let trait_bound_str = try_opt!(rewrite_trait_bounds(context,\n-                                                            type_param_bounds,\n-                                                            offset,\n-                                                            context.config.max_width));\n+        let trait_bound_str =\n+            try_opt!(rewrite_trait_bounds(context,\n+                                          type_param_bounds,\n+                                          Shape::legacy(context.config.max_width, offset)));\n         // If the trait, generics, and trait bound cannot fit on the same line,\n         // put the trait bounds on an indented new line\n         if offset.width() + last_line_width(&result) + trait_bound_str.len() >\n@@ -783,8 +788,8 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                                                              &generics.where_clause,\n                                                              context.config,\n                                                              context.config.item_brace_style,\n-                                                             context.block_indent,\n-                                                             where_budget,\n+                                                             Shape::legacy(where_budget,\n+                                                                           context.block_indent),\n                                                              where_density,\n                                                              \"{\",\n                                                              has_body,\n@@ -916,22 +921,23 @@ fn format_struct_struct(context: &RewriteContext,\n     // 1 = \",\"\n     let item_budget = try_opt!(context.config.max_width.checked_sub(item_indent.width() + 1));\n \n-    let items = itemize_list(context.codemap,\n-                             fields.iter(),\n-                             \"}\",\n-                             |field| {\n-        // Include attributes and doc comments, if present\n-        if !field.attrs.is_empty() {\n-            field.attrs[0].span.lo\n-        } else {\n-            field.span.lo\n-        }\n-    },\n-                             |field| field.ty.span.hi,\n-                             |field| field.rewrite(context, item_budget, item_indent),\n-                             context.codemap.span_after(span, \"{\"),\n-                             span.hi)\n-        .collect::<Vec<_>>();\n+    let items =\n+        itemize_list(context.codemap,\n+                     fields.iter(),\n+                     \"}\",\n+                     |field| {\n+            // Include attributes and doc comments, if present\n+            if !field.attrs.is_empty() {\n+                field.attrs[0].span.lo\n+            } else {\n+                field.span.lo\n+            }\n+        },\n+                     |field| field.ty.span.hi,\n+                     |field| field.rewrite(context, Shape::legacy(item_budget, item_indent)),\n+                     context.codemap.span_after(span, \"{\"),\n+                     span.hi)\n+            .collect::<Vec<_>>();\n     // 1 = ,\n     let budget = context.config.max_width - offset.width() + context.config.tab_spaces - 1;\n \n@@ -944,8 +950,7 @@ fn format_struct_struct(context: &RewriteContext,\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: context.config.struct_trailing_comma,\n-        indent: item_indent,\n-        width: budget,\n+        shape: Shape::legacy(budget, item_indent),\n         ends_with_newline: true,\n         config: context.config,\n     };\n@@ -986,8 +991,8 @@ fn format_tuple_struct(context: &RewriteContext,\n         Some(generics) => {\n             let generics_str = try_opt!(rewrite_generics(context,\n                                                          generics,\n-                                                         offset,\n-                                                         context.config.max_width,\n+                                                         Shape::legacy(context.config.max_width,\n+                                                                       offset),\n                                                          offset + header_str.len(),\n                                                          mk_sp(span.lo, body_lo)));\n             result.push_str(&generics_str);\n@@ -999,8 +1004,7 @@ fn format_tuple_struct(context: &RewriteContext,\n                                           &generics.where_clause,\n                                           context.config,\n                                           context.config.item_brace_style,\n-                                          context.block_indent,\n-                                          where_budget,\n+                                          Shape::legacy(where_budget, context.block_indent),\n                                           Density::Compressed,\n                                           \";\",\n                                           false,\n@@ -1014,22 +1018,25 @@ fn format_tuple_struct(context: &RewriteContext,\n     // 2 = \");\"\n     let item_budget = try_opt!(context.config.max_width.checked_sub(item_indent.width() + 2));\n \n-    let items = itemize_list(context.codemap,\n-                             fields.iter(),\n-                             \")\",\n-                             |field| {\n-        // Include attributes and doc comments, if present\n-        if !field.attrs.is_empty() {\n-            field.attrs[0].span.lo\n-        } else {\n-            field.span.lo\n-        }\n-    },\n-                             |field| field.ty.span.hi,\n-                             |field| field.rewrite(context, item_budget, item_indent),\n-                             context.codemap.span_after(span, \"(\"),\n-                             span.hi);\n-    let body = try_opt!(format_item_list(items, item_budget, item_indent, context.config));\n+    let items =\n+        itemize_list(context.codemap,\n+                     fields.iter(),\n+                     \")\",\n+                     |field| {\n+            // Include attributes and doc comments, if present\n+            if !field.attrs.is_empty() {\n+                field.attrs[0].span.lo\n+            } else {\n+                field.span.lo\n+            }\n+        },\n+                     |field| field.ty.span.hi,\n+                     |field| field.rewrite(context, Shape::legacy(item_budget, item_indent)),\n+                     context.codemap.span_after(span, \"(\"),\n+                     span.hi);\n+    let body = try_opt!(format_item_list(items,\n+                                         Shape::legacy(item_budget, item_indent),\n+                                         context.config));\n \n     if context.config.spaces_within_parens && body.len() > 0 {\n         result.push(' ');\n@@ -1077,8 +1084,7 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n     let generics_width = context.config.max_width - \" =\".len();\n     let generics_str = try_opt!(rewrite_generics(context,\n                                                  generics,\n-                                                 indent,\n-                                                 generics_width,\n+                                                 Shape::legacy(generics_width, indent),\n                                                  generics_indent,\n                                                  generics_span));\n \n@@ -1091,8 +1097,7 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n                                                          &generics.where_clause,\n                                                          context.config,\n                                                          context.config.item_brace_style,\n-                                                         indent,\n-                                                         where_budget,\n+                                                         Shape::legacy(where_budget, indent),\n                                                          context.config.where_density,\n                                                          \"=\",\n                                                          false,\n@@ -1109,7 +1114,7 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n         .unwrap_or(0);\n     let type_indent = indent + line_width;\n     // Try to fit the type on the same line\n-    let ty_str = try_opt!(ty.rewrite(context, budget, type_indent)\n+    let ty_str = try_opt!(ty.rewrite(context, Shape::legacy(budget, type_indent))\n         .or_else(|| {\n             // The line was too short, try to put the type on the next line\n \n@@ -1121,7 +1126,7 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n             let budget = try_opt!(context.config\n                 .max_width\n                 .checked_sub(type_indent.width() + \";\".len()));\n-            ty.rewrite(context, budget, type_indent)\n+            ty.rewrite(context, Shape::legacy(budget, type_indent))\n         }));\n     result.push_str(&ty_str);\n     result.push_str(\";\");\n@@ -1142,19 +1147,21 @@ fn type_annotation_spacing(config: &Config) -> (&str, &str) {\n }\n \n impl Rewrite for ast::StructField {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if contains_skip(&self.attrs) {\n             let span = context.snippet(mk_sp(self.attrs[0].span.lo, self.span.hi));\n-            return wrap_str(span, context.config.max_width, width, offset);\n+            return wrap_str(span, context.config.max_width, shape);\n         }\n \n         let name = self.ident;\n         let vis = format_visibility(&self.vis);\n         let mut attr_str = try_opt!(self.attrs\n-            .rewrite(context, context.config.max_width - offset.width(), offset));\n+            .rewrite(context,\n+                     Shape::legacy(context.config.max_width - shape.indent.width(),\n+                                   shape.indent)));\n         if !attr_str.is_empty() {\n             attr_str.push('\\n');\n-            attr_str.push_str(&offset.to_string(context.config));\n+            attr_str.push_str(&shape.indent.to_string(context.config));\n         }\n \n         let type_annotation_spacing = type_annotation_spacing(context.config);\n@@ -1171,8 +1178,10 @@ impl Rewrite for ast::StructField {\n         };\n \n         let last_line_width = last_line_width(&result);\n-        let budget = try_opt!(width.checked_sub(last_line_width));\n-        let rewrite = try_opt!(self.ty.rewrite(context, budget, offset + last_line_width));\n+        let budget = try_opt!(shape.width.checked_sub(last_line_width));\n+        let rewrite = try_opt!(self.ty.rewrite(context,\n+                                               Shape::legacy(budget,\n+                                                             shape.indent + last_line_width)));\n         Some(result + &rewrite)\n     }\n }\n@@ -1195,15 +1204,20 @@ pub fn rewrite_static(prefix: &str,\n                          type_annotation_spacing.1);\n     // 2 = \" =\".len()\n     let ty_str = try_opt!(ty.rewrite(context,\n-                                     context.config.max_width - context.block_indent.width() -\n-                                     prefix.len() - 2,\n-                                     context.block_indent));\n+                                     Shape::legacy(context.config.max_width -\n+                                                   context.block_indent.width() -\n+                                                   prefix.len() -\n+                                                   2,\n+                                                   context.block_indent)));\n \n     if let Some(expr) = expr_opt {\n         let lhs = format!(\"{}{} =\", prefix, ty_str);\n         // 1 = ;\n         let remaining_width = context.config.max_width - context.block_indent.width() - 1;\n-        rewrite_assign_rhs(context, lhs, expr, remaining_width, context.block_indent)\n+        rewrite_assign_rhs(context,\n+                           lhs,\n+                           expr,\n+                           Shape::legacy(remaining_width, context.block_indent))\n             .map(|s| s + \";\")\n     } else {\n         let lhs = format!(\"{}{};\", prefix, ty_str);\n@@ -1222,7 +1236,9 @@ pub fn rewrite_associated_type(ident: ast::Ident,\n     let type_bounds_str = if let Some(ty_param_bounds) = ty_param_bounds_opt {\n         let bounds: &[_] = ty_param_bounds;\n         let bound_str = try_opt!(bounds.iter()\n-            .map(|ty_bound| ty_bound.rewrite(context, context.config.max_width, indent))\n+            .map(|ty_bound| {\n+                ty_bound.rewrite(context, Shape::legacy(context.config.max_width, indent))\n+            })\n             .intersperse(Some(\" + \".to_string()))\n             .collect::<Option<String>>());\n         if bounds.len() > 0 {\n@@ -1236,32 +1252,35 @@ pub fn rewrite_associated_type(ident: ast::Ident,\n \n     if let Some(ty) = ty_opt {\n         let ty_str = try_opt!(ty.rewrite(context,\n-                                         context.config.max_width - context.block_indent.width() -\n-                                         prefix.len() -\n-                                         2,\n-                                         context.block_indent));\n+                                         Shape::legacy(context.config.max_width -\n+                                                       context.block_indent.width() -\n+                                                       prefix.len() -\n+                                                       2,\n+                                                       context.block_indent)));\n         Some(format!(\"{} = {};\", prefix, ty_str))\n     } else {\n         Some(format!(\"{}{};\", prefix, type_bounds_str))\n     }\n }\n \n impl Rewrite for ast::FunctionRetTy {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match *self {\n             ast::FunctionRetTy::Default(_) => Some(String::new()),\n             ast::FunctionRetTy::Ty(ref ty) => {\n-                let inner_width = try_opt!(width.checked_sub(3));\n-                ty.rewrite(context, inner_width, offset + 3).map(|r| format!(\"-> {}\", r))\n+                let inner_width = try_opt!(shape.width.checked_sub(3));\n+                ty.rewrite(context, Shape::legacy(inner_width, shape.indent + 3))\n+                    .map(|r| format!(\"-> {}\", r))\n             }\n         }\n     }\n }\n \n impl Rewrite for ast::Arg {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if is_named_arg(self) {\n-            let mut result = try_opt!(self.pat.rewrite(context, width, offset));\n+            let mut result = try_opt!(self.pat\n+                .rewrite(context, Shape::legacy(shape.width, shape.indent)));\n \n             if self.ty.node != ast::TyKind::Infer {\n                 if context.config.space_before_type_annotation {\n@@ -1271,14 +1290,16 @@ impl Rewrite for ast::Arg {\n                 if context.config.space_after_type_annotation_colon {\n                     result.push_str(\" \");\n                 }\n-                let max_width = try_opt!(width.checked_sub(result.len()));\n-                let ty_str = try_opt!(self.ty.rewrite(context, max_width, offset + result.len()));\n+                let max_width = try_opt!(shape.width.checked_sub(result.len()));\n+                let ty_str = try_opt!(self.ty.rewrite(context,\n+                                                      Shape::legacy(max_width,\n+                                                                    shape.indent + result.len())));\n                 result.push_str(&ty_str);\n             }\n \n             Some(result)\n         } else {\n-            self.ty.rewrite(context, width, offset)\n+            self.ty.rewrite(context, shape)\n         }\n     }\n }\n@@ -1292,8 +1313,8 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf,\n             let mut_str = format_mutability(m);\n             match lt {\n                 Some(ref l) => {\n-                    let lifetime_str =\n-                        try_opt!(l.rewrite(context, usize::max_value(), Indent::empty()));\n+                    let lifetime_str = try_opt!(l.rewrite(context,\n+                                           Shape::legacy(usize::max_value(), Indent::empty())));\n                     Some(format!(\"&{} {}self\", lifetime_str, mut_str))\n                 }\n                 None => Some(format!(\"&{}self\", mut_str)),\n@@ -1303,7 +1324,8 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf,\n             assert!(!args.is_empty(), \"&[ast::Arg] shouldn't be empty.\");\n \n             let mutability = explicit_self_mutability(&args[0]);\n-            let type_str = try_opt!(ty.rewrite(context, usize::max_value(), Indent::empty()));\n+            let type_str =\n+                try_opt!(ty.rewrite(context, Shape::legacy(usize::max_value(), Indent::empty())));\n \n             Some(format!(\"{}self: {}\", format_mutability(mutability), type_str))\n         }\n@@ -1427,16 +1449,16 @@ fn rewrite_fn_base(context: &RewriteContext,\n     let generics_span = mk_sp(span.lo, span_for_return(&fd.output).lo);\n     let generics_str = try_opt!(rewrite_generics(context,\n                                                  generics,\n-                                                 indent,\n-                                                 context.config.max_width,\n+                                                 Shape::legacy(context.config.max_width, indent),\n                                                  generics_indent,\n                                                  generics_span));\n     result.push_str(&generics_str);\n \n     // Note that if the width and indent really matter, we'll re-layout the\n     // return type later anyway.\n     let ret_str = try_opt!(fd.output\n-        .rewrite(&context, context.config.max_width - indent.width(), indent));\n+        .rewrite(&context,\n+                 Shape::legacy(context.config.max_width - indent.width(), indent)));\n \n     let multi_line_ret_str = ret_str.contains('\\n');\n     let ret_str_len = if multi_line_ret_str { 0 } else { ret_str.len() };\n@@ -1571,7 +1593,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n             // Now that we know the proper indent and width, we need to\n             // re-layout the return type.\n             let budget = try_opt!(context.config.max_width.checked_sub(ret_indent.width()));\n-            let ret_str = try_opt!(fd.output.rewrite(context, budget, ret_indent));\n+            let ret_str = try_opt!(fd.output.rewrite(context, Shape::legacy(budget, ret_indent)));\n             result.push_str(&ret_str);\n         } else {\n             result.push_str(&ret_str);\n@@ -1612,8 +1634,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n                                                          where_clause,\n                                                          context.config,\n                                                          context.config.fn_brace_style,\n-                                                         indent,\n-                                                         where_budget,\n+                                                         Shape::legacy(where_budget, indent),\n                                                          where_density,\n                                                          \"{\",\n                                                          has_body,\n@@ -1640,7 +1661,7 @@ fn rewrite_args(context: &RewriteContext,\n                 variadic: bool)\n                 -> Option<String> {\n     let mut arg_item_strs = try_opt!(args.iter()\n-        .map(|arg| arg.rewrite(&context, multi_line_budget, arg_indent))\n+        .map(|arg| arg.rewrite(&context, Shape::legacy(multi_line_budget, arg_indent)))\n         .collect::<Option<Vec<_>>>());\n \n     // Account for sugary self.\n@@ -1744,8 +1765,7 @@ fn rewrite_args(context: &RewriteContext,\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n-        indent: indent,\n-        width: budget,\n+        shape: Shape::legacy(budget, indent),\n         ends_with_newline: end_with_newline,\n         config: context.config,\n     };\n@@ -1812,8 +1832,8 @@ fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause) -> bool {\n \n fn rewrite_generics(context: &RewriteContext,\n                     generics: &ast::Generics,\n-                    offset: Indent,\n-                    width: usize,\n+                    shape: Shape,\n+                    // TODO shouldn't need this\n                     generics_offset: Indent,\n                     span: Span)\n                     -> Option<String> {\n@@ -1826,18 +1846,19 @@ fn rewrite_generics(context: &RewriteContext,\n     }\n \n     let offset = match context.config.generics_indent {\n-        BlockIndentStyle::Inherit => offset,\n-        BlockIndentStyle::Tabbed => offset.block_indent(context.config),\n+        BlockIndentStyle::Inherit => shape.indent,\n+        BlockIndentStyle::Tabbed => shape.indent.block_indent(context.config),\n         // 1 = <\n         BlockIndentStyle::Visual => generics_offset + 1,\n     };\n \n-    let h_budget = try_opt!(width.checked_sub(generics_offset.width() + 2));\n+    let h_budget = try_opt!(shape.width.checked_sub(generics_offset.width() + 2));\n     // FIXME: might need to insert a newline if the generics are really long.\n \n     // Strings for the generics.\n-    let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(context, h_budget, offset));\n-    let ty_strs = tys.iter().map(|ty_param| ty_param.rewrite(context, h_budget, offset));\n+    let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(context, Shape::legacy(h_budget, offset)));\n+    let ty_strs = tys.iter()\n+        .map(|ty_param| ty_param.rewrite(context, Shape::legacy(h_budget, offset)));\n \n     // Extract comments between generics.\n     let lt_spans = lifetimes.iter().map(|l| {\n@@ -1859,7 +1880,8 @@ fn rewrite_generics(context: &RewriteContext,\n                              |&(_, ref str)| str.clone(),\n                              context.codemap.span_after(span, \"<\"),\n                              span.hi);\n-    let list_str = try_opt!(format_item_list(items, h_budget, offset, context.config));\n+    let list_str =\n+        try_opt!(format_item_list(items, Shape::legacy(h_budget, offset), context.config));\n \n     Some(if context.config.spaces_within_angle_brackets {\n         format!(\"< {} >\", list_str)\n@@ -1870,8 +1892,7 @@ fn rewrite_generics(context: &RewriteContext,\n \n fn rewrite_trait_bounds(context: &RewriteContext,\n                         type_param_bounds: &ast::TyParamBounds,\n-                        indent: Indent,\n-                        width: usize)\n+                        shape: Shape)\n                         -> Option<String> {\n     let bounds: &[_] = type_param_bounds;\n \n@@ -1880,7 +1901,7 @@ fn rewrite_trait_bounds(context: &RewriteContext,\n     }\n \n     let bound_str = try_opt!(bounds.iter()\n-        .map(|ty_bound| ty_bound.rewrite(&context, width, indent))\n+        .map(|ty_bound| ty_bound.rewrite(&context, shape))\n         .intersperse(Some(\" + \".to_string()))\n         .collect::<Option<String>>());\n \n@@ -1894,8 +1915,7 @@ fn rewrite_where_clause(context: &RewriteContext,\n                         where_clause: &ast::WhereClause,\n                         config: &Config,\n                         brace_style: BraceStyle,\n-                        indent: Indent,\n-                        width: usize,\n+                        shape: Shape,\n                         density: Density,\n                         terminator: &str,\n                         allow_trailing_comma: bool,\n@@ -1911,10 +1931,10 @@ fn rewrite_where_clause(context: &RewriteContext,\n     };\n \n     let offset = match context.config.where_pred_indent {\n-        BlockIndentStyle::Inherit => indent + extra_indent,\n-        BlockIndentStyle::Tabbed => indent + extra_indent.block_indent(config),\n+        BlockIndentStyle::Inherit => shape.indent + extra_indent,\n+        BlockIndentStyle::Tabbed => shape.indent + extra_indent.block_indent(config),\n         // 6 = \"where \".len()\n-        BlockIndentStyle::Visual => indent + extra_indent + 6,\n+        BlockIndentStyle::Visual => shape.indent + extra_indent + 6,\n     };\n     // FIXME: if where_pred_indent != Visual, then the budgets below might\n     // be out by a char or two.\n@@ -1931,7 +1951,7 @@ fn rewrite_where_clause(context: &RewriteContext,\n                              terminator,\n                              |pred| span_for_where_pred(pred).lo,\n                              |pred| span_for_where_pred(pred).hi,\n-                             |pred| pred.rewrite(context, budget, offset),\n+                             |pred| pred.rewrite(context, Shape::legacy(budget, offset)),\n                              span_start,\n                              span_end);\n     let item_vec = items.collect::<Vec<_>>();\n@@ -1944,8 +1964,7 @@ fn rewrite_where_clause(context: &RewriteContext,\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::from_bool(use_trailing_comma),\n-        indent: offset,\n-        width: budget,\n+        shape: Shape::legacy(budget, offset),\n         ends_with_newline: true,\n         config: context.config,\n     };\n@@ -1965,9 +1984,9 @@ fn rewrite_where_clause(context: &RewriteContext,\n         terminator.len()\n     };\n     if density == Density::Tall || preds_str.contains('\\n') ||\n-       indent.width() + \" where \".len() + preds_str.len() + end_length > width {\n+       shape.indent.width() + \" where \".len() + preds_str.len() + end_length > shape.width {\n         Some(format!(\"\\n{}where {}\",\n-                     (indent + extra_indent).to_string(context.config),\n+                     (shape.indent + extra_indent).to_string(context.config),\n                      preds_str))\n     } else {\n         Some(format!(\" where {}\", preds_str))\n@@ -1990,8 +2009,7 @@ fn format_generics(context: &RewriteContext,\n                    -> Option<String> {\n     let mut result = try_opt!(rewrite_generics(context,\n                                                generics,\n-                                               offset,\n-                                               context.config.max_width,\n+                                               Shape::legacy(context.config.max_width, offset),\n                                                generics_offset,\n                                                span));\n \n@@ -2001,8 +2019,8 @@ fn format_generics(context: &RewriteContext,\n                                                              &generics.where_clause,\n                                                              context.config,\n                                                              brace_style,\n-                                                             context.block_indent,\n-                                                             budget,\n+                                                             Shape::legacy(budget,\n+                                                                           context.block_indent),\n                                                              Density::Tall,\n                                                              terminator,\n                                                              true,"}, {"sha": "3caeaf92ebb3718323d25c41c350e4cac0186015", "filename": "src/lib.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -201,6 +201,50 @@ impl Sub<usize> for Indent {\n     }\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct Shape {\n+    pub width: usize,\n+    pub indent: Indent,\n+}\n+\n+impl Shape {\n+    pub fn indented(indent: Indent, config: &Config) -> Shape {\n+        Shape {\n+            width: config.max_width,\n+            indent: indent,\n+        }\n+    }\n+\n+    /// `indent` is the indentation of the first line. The next lines\n+    /// should begin with at least `indent` spaces (except backwards\n+    /// indentation). The first line should not begin with indentation.\n+    /// `width` is the maximum number of characters on the last line\n+    /// (excluding `indent`). The width of other lines is not limited by\n+    /// `width`.\n+    /// Note that in reality, we sometimes use width for lines other than the\n+    /// last (i.e., we are conservative).\n+    // .......*-------*\n+    //        |       |\n+    //        |     *-*\n+    //        *-----|\n+    // |<------------>|  max width\n+    // |<---->|          indent\n+    //        |<--->|    width\n+    pub fn legacy(width: usize, indent: Indent) -> Shape {\n+        Shape {\n+            width: width,\n+            indent: indent,\n+        }\n+    }\n+\n+    pub fn sub_width(self, width: usize) -> Shape {\n+        Shape {\n+            width: self.width - width,\n+            indent: self.indent,\n+        }\n+    }\n+}\n+\n pub enum ErrorKind {\n     // Line has exceeded character limit (found, maximum)\n     LineOverflow(usize, usize),"}, {"sha": "2c78a1040c868684847b53234709027034219abb", "filename": "src/lists.rs", "status": "modified", "additions": 24, "deletions": 38, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -13,7 +13,7 @@ use std::iter::Peekable;\n \n use syntax::codemap::{self, CodeMap, BytePos};\n \n-use Indent;\n+use {Indent, Shape};\n use comment::{FindUncommented, rewrite_comment, find_comment_end};\n use config::Config;\n \n@@ -59,50 +59,38 @@ pub struct ListFormatting<'a> {\n     pub tactic: DefinitiveListTactic,\n     pub separator: &'a str,\n     pub trailing_separator: SeparatorTactic,\n-    pub indent: Indent,\n-    pub width: usize,\n+    pub shape: Shape,\n     // Non-expressions, e.g. items, will have a new line at the end of the list.\n     // Important for comment styles.\n     pub ends_with_newline: bool,\n     pub config: &'a Config,\n }\n \n-pub fn format_fn_args<I>(items: I, width: usize, offset: Indent, config: &Config) -> Option<String>\n+pub fn format_fn_args<I>(items: I, shape: Shape, config: &Config) -> Option<String>\n     where I: Iterator<Item = ListItem>\n {\n     list_helper(items,\n-                width,\n-                offset,\n+                shape,\n                 config,\n                 ListTactic::LimitedHorizontalVertical(config.fn_call_width))\n }\n \n-pub fn format_item_list<I>(items: I,\n-                           width: usize,\n-                           offset: Indent,\n-                           config: &Config)\n-                           -> Option<String>\n+pub fn format_item_list<I>(items: I, shape: Shape, config: &Config) -> Option<String>\n     where I: Iterator<Item = ListItem>\n {\n-    list_helper(items, width, offset, config, ListTactic::HorizontalVertical)\n+    list_helper(items, shape, config, ListTactic::HorizontalVertical)\n }\n \n-pub fn list_helper<I>(items: I,\n-                      width: usize,\n-                      offset: Indent,\n-                      config: &Config,\n-                      tactic: ListTactic)\n-                      -> Option<String>\n+pub fn list_helper<I>(items: I, shape: Shape, config: &Config, tactic: ListTactic) -> Option<String>\n     where I: Iterator<Item = ListItem>\n {\n     let item_vec: Vec<_> = items.collect();\n-    let tactic = definitive_tactic(&item_vec, tactic, width);\n+    let tactic = definitive_tactic(&item_vec, tactic, shape.width);\n     let fmt = ListFormatting {\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n-        indent: offset,\n-        width: width,\n+        shape: shape,\n         ends_with_newline: false,\n         config: config,\n     };\n@@ -201,7 +189,7 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n     let mut iter = items.into_iter().enumerate().peekable();\n \n     let mut line_len = 0;\n-    let indent_str = &formatting.indent.to_string(formatting.config);\n+    let indent_str = &formatting.shape.indent.to_string(formatting.config);\n     while let Some((i, item)) = iter.next() {\n         let item = item.as_ref();\n         let inner_item = try_opt!(item.item.as_ref());\n@@ -234,7 +222,7 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n                 let total_width = total_item_width(item) + item_sep_len;\n \n                 // 1 is space between separator and item.\n-                if line_len > 0 && line_len + 1 + total_width > formatting.width {\n+                if line_len > 0 && line_len + 1 + total_width > formatting.shape.width {\n                     result.push('\\n');\n                     result.push_str(indent_str);\n                     line_len = 0;\n@@ -255,12 +243,8 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n             // Block style in non-vertical mode.\n             let block_mode = tactic != DefinitiveListTactic::Vertical;\n             // Width restriction is only relevant in vertical mode.\n-            let max_width = formatting.width;\n-            let comment = try_opt!(rewrite_comment(comment,\n-                                                   block_mode,\n-                                                   max_width,\n-                                                   formatting.indent,\n-                                                   formatting.config));\n+            let comment =\n+                try_opt!(rewrite_comment(comment, block_mode, formatting.shape, formatting.config));\n             result.push_str(&comment);\n \n             if tactic == DefinitiveListTactic::Vertical {\n@@ -276,11 +260,11 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n         // Post-comments\n         if tactic != DefinitiveListTactic::Vertical && item.post_comment.is_some() {\n             let comment = item.post_comment.as_ref().unwrap();\n-            let formatted_comment = try_opt!(rewrite_comment(comment,\n-                                                             true,\n-                                                             formatting.width,\n-                                                             Indent::empty(),\n-                                                             formatting.config));\n+            let formatted_comment =\n+                try_opt!(rewrite_comment(comment,\n+                                         true,\n+                                         Shape::legacy(formatting.shape.width, Indent::empty()),\n+                                         formatting.config));\n \n             result.push(' ');\n             result.push_str(&formatted_comment);\n@@ -292,8 +276,8 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n \n         if tactic == DefinitiveListTactic::Vertical && item.post_comment.is_some() {\n             // 1 = space between item and comment.\n-            let width = formatting.width.checked_sub(item_last_line_width + 1).unwrap_or(1);\n-            let mut offset = formatting.indent;\n+            let width = formatting.shape.width.checked_sub(item_last_line_width + 1).unwrap_or(1);\n+            let mut offset = formatting.shape.indent;\n             offset.alignment += item_last_line_width + 1;\n             let comment = item.post_comment.as_ref().unwrap();\n \n@@ -303,8 +287,10 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n                               comment.trim().contains('\\n') ||\n                               comment.trim().len() > width;\n \n-            let formatted_comment =\n-                try_opt!(rewrite_comment(comment, block_style, width, offset, formatting.config));\n+            let formatted_comment = try_opt!(rewrite_comment(comment,\n+                                                             block_style,\n+                                                             Shape::legacy(width, offset),\n+                                                             formatting.config));\n \n             result.push(' ');\n             result.push_str(&formatted_comment);"}, {"sha": "3a184d242ef5fe267cfa3450c677b3799e996245", "filename": "src/macros.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -26,7 +26,7 @@ use syntax::parse::tts_to_parser;\n use syntax::symbol;\n use syntax::util::ThinVec;\n \n-use Indent;\n+use Shape;\n use codemap::SpanUtils;\n use rewrite::{Rewrite, RewriteContext};\n use expr::{rewrite_call, rewrite_array};\n@@ -62,13 +62,12 @@ impl MacroStyle {\n pub fn rewrite_macro(mac: &ast::Mac,\n                      extra_ident: Option<ast::Ident>,\n                      context: &RewriteContext,\n-                     width: usize,\n-                     offset: Indent,\n+                     shape: Shape,\n                      position: MacroPosition)\n                      -> Option<String> {\n     if context.config.use_try_shorthand {\n         if let Some(expr) = convert_try_mac(mac, context) {\n-            return expr.rewrite(context, width, offset);\n+            return expr.rewrite(context, shape);\n         }\n     }\n \n@@ -146,11 +145,12 @@ pub fn rewrite_macro(mac: &ast::Mac,\n     match style {\n         MacroStyle::Parens => {\n             // Format macro invocation as function call.\n-            rewrite_call(context, &macro_name, &expr_vec, mac.span, width, offset)\n-                .map(|rw| match position {\n+            rewrite_call(context, &macro_name, &expr_vec, mac.span, shape).map(|rw| {\n+                match position {\n                     MacroPosition::Item => format!(\"{};\", rw),\n                     _ => rw,\n-                })\n+                }\n+            })\n         }\n         MacroStyle::Brackets => {\n             // Format macro invocation as array literal.\n@@ -161,8 +161,9 @@ pub fn rewrite_macro(mac: &ast::Mac,\n                                                                        original_style.opener()),\n                                                        mac.span.hi - BytePos(1)),\n                                                  context,\n-                                                 try_opt!(width.checked_sub(extra_offset)),\n-                                                 offset + extra_offset));\n+                                                 Shape::legacy(try_opt!(shape.width\n+                                                                   .checked_sub(extra_offset)),\n+                                                               shape.indent + extra_offset)));\n \n             Some(format!(\"{}{}\", macro_name, rewrite))\n         }"}, {"sha": "9967a8a4ab86d359283b0b37f0c2d099ef1e0480", "filename": "src/missed_spans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -12,6 +12,7 @@ use config::WriteMode;\n use visitor::FmtVisitor;\n use syntax::codemap::{self, BytePos, Span, Pos};\n use comment::{CodeCharKind, CommentCodeSlices, rewrite_comment};\n+use Shape;\n \n impl<'a> FmtVisitor<'a> {\n     fn output_at_start(&self) -> bool {\n@@ -143,8 +144,8 @@ impl<'a> FmtVisitor<'a> {\n \n                     self.buffer.push_str(&rewrite_comment(subslice,\n                                                           false,\n-                                                          comment_width,\n-                                                          self.block_indent,\n+                                                          Shape::legacy(comment_width,\n+                                                                        self.block_indent),\n                                                           self.config)\n                         .unwrap());\n "}, {"sha": "7346dc08010c6326a5d5dac88846dbe8477791fb", "filename": "src/patterns.rs", "status": "modified", "additions": 58, "deletions": 65, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use Indent;\n+use Shape;\n use codemap::SpanUtils;\n use rewrite::{Rewrite, RewriteContext};\n use utils::{wrap_str, format_mutability};\n@@ -23,9 +23,9 @@ use syntax::ptr;\n use syntax::codemap::{self, BytePos, Span};\n \n impl Rewrite for Pat {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match self.node {\n-            PatKind::Box(ref pat) => rewrite_unary_prefix(context, \"box \", &**pat, width, offset),\n+            PatKind::Box(ref pat) => rewrite_unary_prefix(context, \"box \", &**pat, shape),\n             PatKind::Ident(binding_mode, ident, ref sub_pat) => {\n                 let (prefix, mutability) = match binding_mode {\n                     BindingMode::ByRef(mutability) => (\"ref \", mutability),\n@@ -36,60 +36,54 @@ impl Rewrite for Pat {\n                 let sub_pat = match *sub_pat {\n                     Some(ref p) => {\n                         // 3 - ` @ `.\n-                        let width = try_opt!(width.checked_sub(prefix.len() + mut_infix.len() +\n-                                                               id_str.len() +\n-                                                               3));\n-                        format!(\" @ {}\", try_opt!(p.rewrite(context, width, offset)))\n+                        let width = try_opt!(shape.width\n+                            .checked_sub(prefix.len() + mut_infix.len() + id_str.len() + 3));\n+                        format!(\" @ {}\",\n+                                try_opt!(p.rewrite(context, Shape::legacy(width, shape.indent))))\n                     }\n                     None => \"\".to_owned(),\n                 };\n \n                 let result = format!(\"{}{}{}{}\", prefix, mut_infix, id_str, sub_pat);\n-                wrap_str(result, context.config.max_width, width, offset)\n+                wrap_str(result, context.config.max_width, shape)\n             }\n             PatKind::Wild => {\n-                if 1 <= width {\n+                if 1 <= shape.width {\n                     Some(\"_\".to_owned())\n                 } else {\n                     None\n                 }\n             }\n             PatKind::Range(ref lhs, ref rhs) => {\n-                rewrite_pair(&**lhs, &**rhs, \"\", \"...\", \"\", context, width, offset)\n+                rewrite_pair(&**lhs, &**rhs, \"\", \"...\", \"\", context, shape)\n             }\n             PatKind::Ref(ref pat, mutability) => {\n                 let prefix = format!(\"&{}\", format_mutability(mutability));\n-                rewrite_unary_prefix(context, &prefix, &**pat, width, offset)\n+                rewrite_unary_prefix(context, &prefix, &**pat, shape)\n             }\n             PatKind::Tuple(ref items, dotdot_pos) => {\n-                rewrite_tuple_pat(items, dotdot_pos, None, self.span, context, width, offset)\n+                rewrite_tuple_pat(items, dotdot_pos, None, self.span, context, shape)\n             }\n             PatKind::Path(ref q_self, ref path) => {\n-                rewrite_path(context,\n-                             PathContext::Expr,\n-                             q_self.as_ref(),\n-                             path,\n-                             width,\n-                             offset)\n+                rewrite_path(context, PathContext::Expr, q_self.as_ref(), path, shape)\n             }\n             PatKind::TupleStruct(ref path, ref pat_vec, dotdot_pos) => {\n                 let path_str =\n-                    try_opt!(rewrite_path(context, PathContext::Expr, None, path, width, offset));\n+                    try_opt!(rewrite_path(context, PathContext::Expr, None, path, shape));\n                 rewrite_tuple_pat(pat_vec,\n                                   dotdot_pos,\n                                   Some(path_str),\n                                   self.span,\n                                   context,\n-                                  width,\n-                                  offset)\n+                                  shape)\n             }\n-            PatKind::Lit(ref expr) => expr.rewrite(context, width, offset),\n+            PatKind::Lit(ref expr) => expr.rewrite(context, shape),\n             PatKind::Slice(ref prefix, ref slice_pat, ref suffix) => {\n                 // Rewrite all the sub-patterns.\n-                let prefix = prefix.iter().map(|p| p.rewrite(context, width, offset));\n+                let prefix = prefix.iter().map(|p| p.rewrite(context, shape));\n                 let slice_pat = slice_pat.as_ref()\n-                    .map(|p| Some(format!(\"{}..\", try_opt!(p.rewrite(context, width, offset)))));\n-                let suffix = suffix.iter().map(|p| p.rewrite(context, width, offset));\n+                    .map(|p| Some(format!(\"{}..\", try_opt!(p.rewrite(context, shape)))));\n+                let suffix = suffix.iter().map(|p| p.rewrite(context, shape));\n \n                 // Munge them together.\n                 let pats: Option<Vec<String>> = prefix.chain(slice_pat.into_iter())\n@@ -105,32 +99,33 @@ impl Rewrite for Pat {\n                 } else {\n                     format!(\"[{}]\", pats.join(\", \"))\n                 };\n-                wrap_str(result, context.config.max_width, width, offset)\n+                wrap_str(result, context.config.max_width, shape)\n             }\n             PatKind::Struct(ref path, ref fields, elipses) => {\n-                let path =\n-                    try_opt!(rewrite_path(context, PathContext::Expr, None, path, width, offset));\n+                let path = try_opt!(rewrite_path(context, PathContext::Expr, None, path, shape));\n \n                 let (elipses_str, terminator) = if elipses { (\", ..\", \"..\") } else { (\"\", \"}\") };\n \n                 // 5 = `{` plus space before and after plus `}` plus space before.\n-                let budget = try_opt!(width.checked_sub(path.len() + 5 + elipses_str.len()));\n+                let budget = try_opt!(shape.width.checked_sub(path.len() + 5 + elipses_str.len()));\n                 // FIXME Using visual indenting, should use block or visual to match\n                 // struct lit preference (however, in practice I think it is rare\n                 // for struct patterns to be multi-line).\n                 // 3 = `{` plus space before and after.\n-                let offset = offset + path.len() + 3;\n+                let offset = shape.indent + path.len() + 3;\n \n-                let items = itemize_list(context.codemap,\n-                                         fields.iter(),\n-                                         terminator,\n-                                         |f| f.span.lo,\n-                                         |f| f.span.hi,\n-                                         |f| f.node.rewrite(context, budget, offset),\n-                                         context.codemap.span_after(self.span, \"{\"),\n-                                         self.span.hi);\n-                let mut field_string =\n-                    try_opt!(format_item_list(items, budget, offset, context.config));\n+                let items =\n+                    itemize_list(context.codemap,\n+                                 fields.iter(),\n+                                 terminator,\n+                                 |f| f.span.lo,\n+                                 |f| f.span.hi,\n+                                 |f| f.node.rewrite(context, Shape::legacy(budget, offset)),\n+                                 context.codemap.span_after(self.span, \"{\"),\n+                                 self.span.hi);\n+                let mut field_string = try_opt!(format_item_list(items,\n+                                                                 Shape::legacy(budget, offset),\n+                                                                 context.config));\n                 if elipses {\n                     if field_string.contains('\\n') {\n                         field_string.push_str(\",\\n\");\n@@ -152,25 +147,21 @@ impl Rewrite for Pat {\n             }\n             // FIXME(#819) format pattern macros.\n             PatKind::Mac(..) => {\n-                wrap_str(context.snippet(self.span),\n-                         context.config.max_width,\n-                         width,\n-                         offset)\n+                wrap_str(context.snippet(self.span), context.config.max_width, shape)\n             }\n         }\n     }\n }\n \n impl Rewrite for FieldPat {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        let pat = self.pat.rewrite(context, width, offset);\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        let pat = self.pat.rewrite(context, shape);\n         if self.is_shorthand {\n             pat\n         } else {\n             wrap_str(format!(\"{}: {}\", self.ident.to_string(), try_opt!(pat)),\n                      context.config.max_width,\n-                     width,\n-                     offset)\n+                     shape)\n         }\n     }\n }\n@@ -182,9 +173,9 @@ enum TuplePatField<'a> {\n }\n \n impl<'a> Rewrite for TuplePatField<'a> {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match *self {\n-            TuplePatField::Pat(ref p) => p.rewrite(context, width, offset),\n+            TuplePatField::Pat(ref p) => p.rewrite(context, shape),\n             TuplePatField::Dotdot(_) => Some(\"..\".to_string()),\n         }\n     }\n@@ -204,8 +195,7 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n                      path_str: Option<String>,\n                      span: Span,\n                      context: &RewriteContext,\n-                     width: usize,\n-                     offset: Indent)\n+                     shape: Shape)\n                      -> Option<String> {\n     let mut pat_vec: Vec<_> = pats.into_iter().map(|x| TuplePatField::Pat(x)).collect();\n \n@@ -230,18 +220,19 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n \n         let path_len = path_str.as_ref().map(|p| p.len()).unwrap_or(0);\n         // 2 = \"()\".len(), 3 = \"(,)\".len()\n-        let width = try_opt!(width.checked_sub(path_len + if add_comma { 3 } else { 2 }));\n+        let width = try_opt!(shape.width.checked_sub(path_len + if add_comma { 3 } else { 2 }));\n         // 1 = \"(\".len()\n-        let offset = offset + path_len + 1;\n-        let mut items: Vec<_> = itemize_list(context.codemap,\n-                                             pat_vec.iter(),\n-                                             if add_comma { \",)\" } else { \")\" },\n-                                             |item| item.span().lo,\n-                                             |item| item.span().hi,\n-                                             |item| item.rewrite(context, width, offset),\n-                                             context.codemap.span_after(span, \"(\"),\n-                                             span.hi - BytePos(1))\n-            .collect();\n+        let offset = shape.indent + path_len + 1;\n+        let mut items: Vec<_> =\n+            itemize_list(context.codemap,\n+                         pat_vec.iter(),\n+                         if add_comma { \",)\" } else { \")\" },\n+                         |item| item.span().lo,\n+                         |item| item.span().hi,\n+                         |item| item.rewrite(context, Shape::legacy(width, offset)),\n+                         context.codemap.span_after(span, \"(\"),\n+                         span.hi - BytePos(1))\n+                .collect();\n \n         // Condense wildcard string suffix into a single ..\n         let wildcard_suffix_len = count_wildcard_suffix_len(&items);\n@@ -251,9 +242,11 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n             items[new_item_count - 1].item = Some(\"..\".to_owned());\n \n             let da_iter = items.into_iter().take(new_item_count);\n-            try_opt!(format_item_list(da_iter, width, offset, context.config))\n+            try_opt!(format_item_list(da_iter, Shape::legacy(width, offset), context.config))\n         } else {\n-            try_opt!(format_item_list(items.into_iter(), width, offset, context.config))\n+            try_opt!(format_item_list(items.into_iter(),\n+                                      Shape::legacy(width, offset),\n+                                      context.config))\n         };\n \n         match path_str {"}, {"sha": "3c69e2c3c451f94b1ff184947d3617bb02a4caf0", "filename": "src/rewrite.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -13,18 +13,12 @@\n use syntax::codemap::{CodeMap, Span};\n use syntax::parse::ParseSess;\n \n-use Indent;\n+use {Indent, Shape};\n use config::Config;\n \n pub trait Rewrite {\n-    /// Rewrite self into offset and width.\n-    /// `offset` is the indentation of the first line. The next lines\n-    /// should begin with a least `offset` spaces (except backwards\n-    /// indentation). The first line should not begin with indentation.\n-    /// `width` is the maximum number of characters on the last line\n-    /// (excluding offset). The width of other lines is not limited by\n-    /// `width`.\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String>;\n+    /// Rewrite self into shape.\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String>;\n }\n \n #[derive(Clone)]"}, {"sha": "014830a9155a4ebf50bdb83979851803e53b84f8", "filename": "src/string.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -13,7 +13,7 @@\n use unicode_segmentation::UnicodeSegmentation;\n use regex::Regex;\n \n-use Indent;\n+use Shape;\n use config::Config;\n use utils::wrap_str;\n \n@@ -24,8 +24,7 @@ pub struct StringFormat<'a> {\n     pub closer: &'a str,\n     pub line_start: &'a str,\n     pub line_end: &'a str,\n-    pub width: usize,\n-    pub offset: Indent,\n+    pub shape: Shape,\n     pub trim_end: bool,\n     pub config: &'a Config,\n }\n@@ -37,7 +36,7 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     let stripped_str = re.replace_all(orig, \"$1\");\n \n     let graphemes = UnicodeSegmentation::graphemes(&*stripped_str, false).collect::<Vec<&str>>();\n-    let indent = fmt.offset.to_string(fmt.config);\n+    let indent = fmt.shape.indent.to_string(fmt.config);\n     let punctuation = \":,;.\";\n \n     // `cur_start` is the position in `orig` of the start of the current line.\n@@ -50,7 +49,7 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     let ender_length = fmt.line_end.len();\n     // If we cannot put at least a single character per line, the rewrite won't\n     // succeed.\n-    let max_chars = try_opt!(fmt.width.checked_sub(fmt.opener.len() + ender_length + 1)) + 1;\n+    let max_chars = try_opt!(fmt.shape.width.checked_sub(fmt.opener.len() + ender_length + 1)) + 1;\n \n     // Snip a line at a time from `orig` until it is used up. Push the snippet\n     // onto result.\n@@ -118,7 +117,7 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     }\n \n     result.push_str(fmt.closer);\n-    wrap_str(result, fmt.config.max_width, fmt.width, fmt.offset)\n+    wrap_str(result, fmt.config.max_width, fmt.shape)\n }\n \n #[cfg(test)]\n@@ -133,8 +132,7 @@ mod test {\n             closer: \"\\\"\",\n             line_start: \" \",\n             line_end: \"\\\\\",\n-            width: 2,\n-            offset: ::Indent::empty(),\n+            shape: ::Shape::legacy(2, ::Indent::empty()),\n             trim_end: false,\n             config: &config,\n         };"}, {"sha": "cce487cb2ea8fd96fa83de5daf91f10981b862fa", "filename": "src/types.rs", "status": "modified", "additions": 151, "deletions": 156, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -17,7 +17,7 @@ use syntax::codemap::{self, Span, BytePos};\n use syntax::print::pprust;\n use syntax::symbol::keywords;\n \n-use {Indent, Spanned};\n+use {Shape, Spanned};\n use codemap::SpanUtils;\n use lists::{format_item_list, itemize_list, format_fn_args};\n use rewrite::{Rewrite, RewriteContext};\n@@ -38,8 +38,7 @@ pub fn rewrite_path(context: &RewriteContext,\n                     path_context: PathContext,\n                     qself: Option<&ast::QSelf>,\n                     path: &ast::Path,\n-                    width: usize,\n-                    offset: Indent)\n+                    shape: Shape)\n                     -> Option<String> {\n     let skip_count = qself.map_or(0, |x| x.position);\n \n@@ -58,7 +57,7 @@ pub fn rewrite_path(context: &RewriteContext,\n             result.push_str(\" \")\n         }\n \n-        let fmt_ty = try_opt!(qself.ty.rewrite(context, width, offset));\n+        let fmt_ty = try_opt!(qself.ty.rewrite(context, shape));\n         result.push_str(&fmt_ty);\n \n         if skip_count > 0 {\n@@ -67,18 +66,18 @@ pub fn rewrite_path(context: &RewriteContext,\n                 result.push_str(\"::\");\n             }\n \n-            let extra_offset = extra_offset(&result, offset);\n+            let extra_offset = extra_offset(&result, shape.indent);\n             // 3 = \">::\".len()\n-            let budget = try_opt!(width.checked_sub(extra_offset + 3));\n+            let budget = try_opt!(shape.width.checked_sub(extra_offset + 3));\n \n             result = try_opt!(rewrite_path_segments(PathContext::Type,\n                                                     result,\n                                                     path.segments.iter().take(skip_count),\n                                                     span_lo,\n                                                     path.span.hi,\n                                                     context,\n-                                                    budget,\n-                                                    offset + extra_offset));\n+                                                    Shape::legacy(budget,\n+                                                                  shape.indent + extra_offset)));\n         }\n \n         if context.config.spaces_within_angle_brackets {\n@@ -89,16 +88,15 @@ pub fn rewrite_path(context: &RewriteContext,\n         span_lo = qself.ty.span.hi + BytePos(1);\n     }\n \n-    let extra_offset = extra_offset(&result, offset);\n-    let budget = try_opt!(width.checked_sub(extra_offset));\n+    let extra_offset = extra_offset(&result, shape.indent);\n+    let budget = try_opt!(shape.width.checked_sub(extra_offset));\n     rewrite_path_segments(path_context,\n                           result,\n                           path.segments.iter().skip(skip_count),\n                           span_lo,\n                           path.span.hi,\n                           context,\n-                          budget,\n-                          offset + extra_offset)\n+                          Shape::legacy(budget, shape.indent + extra_offset))\n }\n \n fn rewrite_path_segments<'a, I>(path_context: PathContext,\n@@ -107,8 +105,7 @@ fn rewrite_path_segments<'a, I>(path_context: PathContext,\n                                 mut span_lo: BytePos,\n                                 span_hi: BytePos,\n                                 context: &RewriteContext,\n-                                width: usize,\n-                                offset: Indent)\n+                                shape: Shape)\n                                 -> Option<String>\n     where I: Iterator<Item = &'a ast::PathSegment>\n {\n@@ -125,16 +122,15 @@ fn rewrite_path_segments<'a, I>(path_context: PathContext,\n             buffer.push_str(\"::\");\n         }\n \n-        let extra_offset = extra_offset(&buffer, offset);\n-        let remaining_width = try_opt!(width.checked_sub(extra_offset));\n-        let new_offset = offset + extra_offset;\n+        let extra_offset = extra_offset(&buffer, shape.indent);\n+        let remaining_width = try_opt!(shape.width.checked_sub(extra_offset));\n+        let new_offset = shape.indent + extra_offset;\n         let segment_string = try_opt!(rewrite_segment(path_context,\n                                                       segment,\n                                                       &mut span_lo,\n                                                       span_hi,\n                                                       context,\n-                                                      remaining_width,\n-                                                      new_offset));\n+                                                      Shape::legacy(remaining_width, new_offset)));\n \n         buffer.push_str(&segment_string);\n     }\n@@ -160,14 +156,15 @@ impl<'a> SegmentParam<'a> {\n }\n \n impl<'a> Rewrite for SegmentParam<'a> {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match *self {\n-            SegmentParam::LifeTime(lt) => lt.rewrite(context, width, offset),\n-            SegmentParam::Type(ty) => ty.rewrite(context, width, offset),\n+            SegmentParam::LifeTime(lt) => lt.rewrite(context, shape),\n+            SegmentParam::Type(ty) => ty.rewrite(context, shape),\n             SegmentParam::Binding(binding) => {\n                 let mut result = format!(\"{} = \", binding.ident);\n-                let budget = try_opt!(width.checked_sub(result.len()));\n-                let rewrite = try_opt!(binding.ty.rewrite(context, budget, offset + result.len()));\n+                let budget = try_opt!(shape.width.checked_sub(result.len()));\n+                let rewrite = try_opt!(binding.ty\n+                    .rewrite(context, Shape::legacy(budget, shape.indent + result.len())));\n                 result.push_str(&rewrite);\n                 Some(result)\n             }\n@@ -190,12 +187,11 @@ fn rewrite_segment(path_context: PathContext,\n                    span_lo: &mut BytePos,\n                    span_hi: BytePos,\n                    context: &RewriteContext,\n-                   width: usize,\n-                   offset: Indent)\n+                   shape: Shape)\n                    -> Option<String> {\n     let ident_len = segment.identifier.to_string().len();\n-    let width = try_opt!(width.checked_sub(ident_len));\n-    let offset = offset + ident_len;\n+    let width = try_opt!(shape.width.checked_sub(ident_len));\n+    let offset = shape.indent + ident_len;\n \n     let params = if let Some(ref params) = segment.parameters {\n         match **params {\n@@ -222,18 +218,21 @@ fn rewrite_segment(path_context: PathContext,\n                 // 1 for >\n                 let list_width = try_opt!(width.checked_sub(extra_offset + 1));\n \n-                let items =\n-                    itemize_list(context.codemap,\n-                                 param_list.into_iter(),\n-                                 \">\",\n-                                 |param| param.get_span().lo,\n-                                 |param| param.get_span().hi,\n-                                 |seg| seg.rewrite(context, list_width, offset + extra_offset),\n-                                 list_lo,\n-                                 span_hi);\n+                let items = itemize_list(context.codemap,\n+                                         param_list.into_iter(),\n+                                         \">\",\n+                                         |param| param.get_span().lo,\n+                                         |param| param.get_span().hi,\n+                                         |seg| {\n+                                             seg.rewrite(context,\n+                                                         Shape::legacy(list_width,\n+                                                                       offset + extra_offset))\n+                                         },\n+                                         list_lo,\n+                                         span_hi);\n                 let list_str = try_opt!(format_item_list(items,\n-                                                         list_width,\n-                                                         offset + extra_offset,\n+                                                         Shape::legacy(list_width,\n+                                                                       offset + extra_offset),\n                                                          context.config));\n \n                 // Update position of last bracket.\n@@ -255,8 +254,7 @@ fn rewrite_segment(path_context: PathContext,\n                                               false,\n                                               data.span,\n                                               context,\n-                                              width,\n-                                              offset))\n+                                              Shape::legacy(width, offset)))\n             }\n             _ => String::new(),\n         }\n@@ -272,8 +270,7 @@ fn format_function_type<'a, I>(inputs: I,\n                                variadic: bool,\n                                span: Span,\n                                context: &RewriteContext,\n-                               width: usize,\n-                               offset: Indent)\n+                               shape: Shape)\n                                -> Option<String>\n     where I: ExactSizeIterator,\n           <I as Iterator>::Item: Deref,\n@@ -297,44 +294,45 @@ fn format_function_type<'a, I>(inputs: I,\n     };\n \n     // 2 for ()\n-    let budget = try_opt!(width.checked_sub(2));\n+    let budget = try_opt!(shape.width.checked_sub(2));\n     // 1 for (\n-    let offset = offset + 1;\n+    let offset = shape.indent + 1;\n     let list_lo = context.codemap.span_after(span, \"(\");\n-    let items =\n-        itemize_list(context.codemap,\n-                     // FIXME Would be nice to avoid this allocation,\n-                     // but I couldn't get the types to work out.\n-                     inputs.map(|i| ArgumentKind::Regular(Box::new(i)))\n-                         .chain(variadic_arg),\n-                     \")\",\n-                     |arg| match *arg {\n-                         ArgumentKind::Regular(ref ty) => ty.span().lo,\n-                         ArgumentKind::Variadic(start) => start,\n-                     },\n-                     |arg| match *arg {\n-                         ArgumentKind::Regular(ref ty) => ty.span().hi,\n-                         ArgumentKind::Variadic(start) => start + BytePos(3),\n-                     },\n-                     |arg| match *arg {\n-                         ArgumentKind::Regular(ref ty) => ty.rewrite(context, budget, offset),\n-                         ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n-                     },\n-                     list_lo,\n-                     span.hi);\n-\n-    let list_str = try_opt!(format_fn_args(items, budget, offset, context.config));\n+    let items = itemize_list(context.codemap,\n+                             // FIXME Would be nice to avoid this allocation,\n+                             // but I couldn't get the types to work out.\n+                             inputs.map(|i| ArgumentKind::Regular(Box::new(i)))\n+                                 .chain(variadic_arg),\n+                             \")\",\n+                             |arg| match *arg {\n+                                 ArgumentKind::Regular(ref ty) => ty.span().lo,\n+                                 ArgumentKind::Variadic(start) => start,\n+                             },\n+                             |arg| match *arg {\n+                                 ArgumentKind::Regular(ref ty) => ty.span().hi,\n+                                 ArgumentKind::Variadic(start) => start + BytePos(3),\n+                             },\n+                             |arg| match *arg {\n+                                 ArgumentKind::Regular(ref ty) => {\n+                                     ty.rewrite(context, Shape::legacy(budget, offset))\n+                                 }\n+                                 ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n+                             },\n+                             list_lo,\n+                             span.hi);\n+\n+    let list_str = try_opt!(format_fn_args(items, Shape::legacy(budget, offset), context.config));\n \n     let output = match *output {\n         FunctionRetTy::Ty(ref ty) => {\n-            let budget = try_opt!(width.checked_sub(4));\n-            let type_str = try_opt!(ty.rewrite(context, budget, offset + 4));\n+            let budget = try_opt!(shape.width.checked_sub(4));\n+            let type_str = try_opt!(ty.rewrite(context, Shape::legacy(budget, offset + 4)));\n             format!(\" -> {}\", type_str)\n         }\n         FunctionRetTy::Default(..) => String::new(),\n     };\n \n-    let infix = if !output.is_empty() && output.len() + list_str.len() > width {\n+    let infix = if !output.is_empty() && output.len() + list_str.len() > shape.width {\n         format!(\"\\n{}\", (offset - 1).to_string(context.config))\n     } else {\n         String::new()\n@@ -357,35 +355,33 @@ fn type_bound_colon(context: &RewriteContext) -> &'static str {\n }\n \n impl Rewrite for ast::WherePredicate {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         // TODO: dead spans?\n         let result = match *self {\n             ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate { ref bound_lifetimes,\n                                                                            ref bounded_ty,\n                                                                            ref bounds,\n                                                                            .. }) => {\n-                let type_str = try_opt!(bounded_ty.rewrite(context, width, offset));\n+                let type_str = try_opt!(bounded_ty.rewrite(context, shape));\n \n                 let colon = type_bound_colon(context);\n \n                 if !bound_lifetimes.is_empty() {\n                     let lifetime_str: String = try_opt!(bound_lifetimes.iter()\n                                                                .map(|lt| {\n-                                                                   lt.rewrite(context,\n-                                                                              width,\n-                                                                              offset)\n+                                                                   lt.rewrite(context, shape)\n                                                                })\n                                                                .intersperse(Some(\", \".to_string()))\n                                                                .collect());\n \n                     // 6 = \"for<> \".len()\n                     let used_width = lifetime_str.len() + type_str.len() + colon.len() + 6;\n-                    let budget = try_opt!(width.checked_sub(used_width));\n+                    let budget = try_opt!(shape.width.checked_sub(used_width));\n                     let bounds_str: String = try_opt!(bounds.iter()\n                                                     .map(|ty_bound| {\n                                                         ty_bound.rewrite(context,\n-                                                                         budget,\n-                                                                         offset + used_width)\n+                                                                         Shape::legacy(budget,\n+                                                                         shape.indent + used_width))\n                                                     })\n                                                     .intersperse(Some(\" + \".to_string()))\n                                                     .collect());\n@@ -397,12 +393,12 @@ impl Rewrite for ast::WherePredicate {\n                     }\n                 } else {\n                     let used_width = type_str.len() + colon.len();\n-                    let budget = try_opt!(width.checked_sub(used_width));\n+                    let budget = try_opt!(shape.width.checked_sub(used_width));\n                     let bounds_str: String = try_opt!(bounds.iter()\n                                                     .map(|ty_bound| {\n                                                         ty_bound.rewrite(context,\n-                                                                         budget,\n-                                                                         offset + used_width)\n+                                                                         Shape::legacy(budget,\n+                                                                         shape.indent + used_width))\n                                                     })\n                                                     .intersperse(Some(\" + \".to_string()))\n                                                     .collect());\n@@ -413,91 +409,92 @@ impl Rewrite for ast::WherePredicate {\n             ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate { ref lifetime,\n                                                                              ref bounds,\n                                                                              .. }) => {\n-                try_opt!(rewrite_bounded_lifetime(lifetime, bounds.iter(), context, width, offset))\n+                try_opt!(rewrite_bounded_lifetime(lifetime, bounds.iter(), context, shape))\n             }\n             ast::WherePredicate::EqPredicate(ast::WhereEqPredicate { ref lhs_ty,\n                                                                      ref rhs_ty,\n                                                                      .. }) => {\n-                let lhs_ty_str = try_opt!(lhs_ty.rewrite(context, width, offset));\n+                let lhs_ty_str = try_opt!(lhs_ty.rewrite(context, shape));\n                 // 3 = \" = \".len()\n                 let used_width = 3 + lhs_ty_str.len();\n-                let budget = try_opt!(width.checked_sub(used_width));\n-                let rhs_ty_str = try_opt!(rhs_ty.rewrite(context, budget, offset + used_width));\n+                let budget = try_opt!(shape.width.checked_sub(used_width));\n+                let rhs_ty_str = try_opt!(rhs_ty.rewrite(context,\n+                                            Shape::legacy(budget, shape.indent + used_width)));\n                 format!(\"{} = {}\", lhs_ty_str, rhs_ty_str)\n             }\n         };\n \n-        wrap_str(result, context.config.max_width, width, offset)\n+        wrap_str(result, context.config.max_width, shape)\n     }\n }\n \n impl Rewrite for ast::LifetimeDef {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        rewrite_bounded_lifetime(&self.lifetime, self.bounds.iter(), context, width, offset)\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        rewrite_bounded_lifetime(&self.lifetime, self.bounds.iter(), context, shape)\n     }\n }\n \n fn rewrite_bounded_lifetime<'b, I>(lt: &ast::Lifetime,\n                                    bounds: I,\n                                    context: &RewriteContext,\n-                                   width: usize,\n-                                   offset: Indent)\n+                                   shape: Shape)\n                                    -> Option<String>\n     where I: ExactSizeIterator<Item = &'b ast::Lifetime>\n {\n-    let result = try_opt!(lt.rewrite(context, width, offset));\n+    let result = try_opt!(lt.rewrite(context, shape));\n \n     if bounds.len() == 0 {\n         Some(result)\n     } else {\n         let appendix: Vec<_> = try_opt!(bounds.into_iter()\n-            .map(|b| b.rewrite(context, width, offset))\n+            .map(|b| b.rewrite(context, shape))\n             .collect());\n         let colon = type_bound_colon(context);\n         let result = format!(\"{}{}{}\", result, colon, appendix.join(\" + \"));\n-        wrap_str(result, context.config.max_width, width, offset)\n+        wrap_str(result, context.config.max_width, shape)\n     }\n }\n \n impl Rewrite for ast::TyParamBound {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match *self {\n             ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::None) => {\n-                tref.rewrite(context, width, offset)\n+                tref.rewrite(context, shape)\n             }\n             ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::Maybe) => {\n-                let budget = try_opt!(width.checked_sub(1));\n-                Some(format!(\"?{}\", try_opt!(tref.rewrite(context, budget, offset + 1))))\n+                let budget = try_opt!(shape.width.checked_sub(1));\n+                Some(format!(\"?{}\",\n+                             try_opt!(tref.rewrite(context,\n+                                                   Shape::legacy(budget, shape.indent + 1)))))\n             }\n-            ast::TyParamBound::RegionTyParamBound(ref l) => l.rewrite(context, width, offset),\n+            ast::TyParamBound::RegionTyParamBound(ref l) => l.rewrite(context, shape),\n         }\n     }\n }\n \n impl Rewrite for ast::Lifetime {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         wrap_str(pprust::lifetime_to_string(self),\n                  context.config.max_width,\n-                 width,\n-                 offset)\n+                 shape)\n     }\n }\n \n impl Rewrite for ast::TyParamBounds {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         let joiner = match context.config.type_punctuation_density {\n             TypeDensity::Compressed => \"+\",\n             TypeDensity::Wide => \" + \",\n         };\n         let strs: Vec<_> = try_opt!(self.iter()\n-            .map(|b| b.rewrite(context, width, offset))\n+            .map(|b| b.rewrite(context, shape))\n             .collect());\n-        wrap_str(strs.join(joiner), context.config.max_width, width, offset)\n+        wrap_str(strs.join(joiner), context.config.max_width, shape)\n     }\n }\n \n impl Rewrite for ast::TyParam {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         let mut result = String::with_capacity(128);\n         result.push_str(&self.ident.to_string());\n         if !self.bounds.is_empty() {\n@@ -511,7 +508,7 @@ impl Rewrite for ast::TyParam {\n \n             let bounds: String = try_opt!(self.bounds\n                 .iter()\n-                .map(|ty_bound| ty_bound.rewrite(context, width, offset))\n+                .map(|ty_bound| ty_bound.rewrite(context, shape))\n                 .intersperse(Some(\" + \".to_string()))\n                 .collect());\n \n@@ -524,88 +521,96 @@ impl Rewrite for ast::TyParam {\n                 TypeDensity::Wide => \" = \",\n             };\n             result.push_str(eq_str);\n-            let budget = try_opt!(width.checked_sub(result.len()));\n-            let rewrite = try_opt!(def.rewrite(context, budget, offset + result.len()));\n+            let budget = try_opt!(shape.width.checked_sub(result.len()));\n+            let rewrite =\n+                try_opt!(def.rewrite(context, Shape::legacy(budget, shape.indent + result.len())));\n             result.push_str(&rewrite);\n         }\n \n-        wrap_str(result, context.config.max_width, width, offset)\n+        wrap_str(result, context.config.max_width, shape)\n     }\n }\n \n impl Rewrite for ast::PolyTraitRef {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if !self.bound_lifetimes.is_empty() {\n             let lifetime_str: String = try_opt!(self.bound_lifetimes\n                 .iter()\n-                .map(|lt| lt.rewrite(context, width, offset))\n+                .map(|lt| lt.rewrite(context, shape))\n                 .intersperse(Some(\", \".to_string()))\n                 .collect());\n \n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;\n-            let max_path_width = try_opt!(width.checked_sub(extra_offset));\n+            let max_path_width = try_opt!(shape.width.checked_sub(extra_offset));\n             let path_str = try_opt!(self.trait_ref\n-                .rewrite(context, max_path_width, offset + extra_offset));\n+                .rewrite(context,\n+                         Shape::legacy(max_path_width, shape.indent + extra_offset)));\n \n             Some(if context.config.spaces_within_angle_brackets && lifetime_str.len() > 0 {\n                 format!(\"for< {} > {}\", lifetime_str, path_str)\n             } else {\n                 format!(\"for<{}> {}\", lifetime_str, path_str)\n             })\n         } else {\n-            self.trait_ref.rewrite(context, width, offset)\n+            self.trait_ref.rewrite(context, shape)\n         }\n     }\n }\n \n impl Rewrite for ast::TraitRef {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        rewrite_path(context, PathContext::Type, None, &self.path, width, offset)\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        rewrite_path(context, PathContext::Type, None, &self.path, shape)\n     }\n }\n \n impl Rewrite for ast::Ty {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match self.node {\n-            ast::TyKind::TraitObject(ref bounds) => bounds.rewrite(context, width, offset),\n+            ast::TyKind::TraitObject(ref bounds) => bounds.rewrite(context, shape),\n             ast::TyKind::Ptr(ref mt) => {\n                 let prefix = match mt.mutbl {\n                     Mutability::Mutable => \"*mut \",\n                     Mutability::Immutable => \"*const \",\n                 };\n \n-                rewrite_unary_prefix(context, prefix, &*mt.ty, width, offset)\n+                rewrite_unary_prefix(context, prefix, &*mt.ty, shape)\n             }\n             ast::TyKind::Rptr(ref lifetime, ref mt) => {\n                 let mut_str = format_mutability(mt.mutbl);\n                 let mut_len = mut_str.len();\n                 Some(match *lifetime {\n                     Some(ref lifetime) => {\n-                        let lt_budget = try_opt!(width.checked_sub(2 + mut_len));\n-                        let lt_str =\n-                            try_opt!(lifetime.rewrite(context, lt_budget, offset + 2 + mut_len));\n+                        let lt_budget = try_opt!(shape.width.checked_sub(2 + mut_len));\n+                        let lt_str = try_opt!(lifetime.rewrite(context,\n+                                                               Shape::legacy(lt_budget,\n+                                                                             shape.indent + 2 +\n+                                                                             mut_len)));\n                         let lt_len = lt_str.len();\n-                        let budget = try_opt!(width.checked_sub(2 + mut_len + lt_len));\n+                        let budget = try_opt!(shape.width.checked_sub(2 + mut_len + lt_len));\n                         format!(\"&{} {}{}\",\n                                 lt_str,\n                                 mut_str,\n                                 try_opt!(mt.ty\n-                                    .rewrite(context, budget, offset + 2 + mut_len + lt_len)))\n+                                    .rewrite(context,\n+                                             Shape::legacy(budget,\n+                                                           shape.indent + 2 + mut_len + lt_len))))\n                     }\n                     None => {\n-                        let budget = try_opt!(width.checked_sub(1 + mut_len));\n+                        let budget = try_opt!(shape.width.checked_sub(1 + mut_len));\n                         format!(\"&{}{}\",\n                                 mut_str,\n-                                try_opt!(mt.ty.rewrite(context, budget, offset + 1 + mut_len)))\n+                                try_opt!(mt.ty.rewrite(context,\n+                                                       Shape::legacy(budget,\n+                                                                     shape.indent + 1 + mut_len))))\n                     }\n                 })\n             }\n             // FIXME: we drop any comments here, even though it's a silly place to put\n             // comments.\n             ast::TyKind::Paren(ref ty) => {\n-                let budget = try_opt!(width.checked_sub(2));\n-                ty.rewrite(context, budget, offset + 1)\n+                let budget = try_opt!(shape.width.checked_sub(2));\n+                ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n                     .map(|ty_str| if context.config.spaces_within_parens {\n                         format!(\"( {} )\", ty_str)\n                     } else {\n@@ -614,53 +619,42 @@ impl Rewrite for ast::Ty {\n             }\n             ast::TyKind::Slice(ref ty) => {\n                 let budget = if context.config.spaces_within_square_brackets {\n-                    try_opt!(width.checked_sub(4))\n+                    try_opt!(shape.width.checked_sub(4))\n                 } else {\n-                    try_opt!(width.checked_sub(2))\n+                    try_opt!(shape.width.checked_sub(2))\n                 };\n-                ty.rewrite(context, budget, offset + 1)\n+                ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n                     .map(|ty_str| if context.config.spaces_within_square_brackets {\n                         format!(\"[ {} ]\", ty_str)\n                     } else {\n                         format!(\"[{}]\", ty_str)\n                     })\n             }\n             ast::TyKind::Tup(ref items) => {\n-                rewrite_tuple(context,\n-                              items.iter().map(|x| &**x),\n-                              self.span,\n-                              width,\n-                              offset)\n+                rewrite_tuple(context, items.iter().map(|x| &**x), self.span, shape)\n             }\n             ast::TyKind::Path(ref q_self, ref path) => {\n-                rewrite_path(context,\n-                             PathContext::Type,\n-                             q_self.as_ref(),\n-                             path,\n-                             width,\n-                             offset)\n+                rewrite_path(context, PathContext::Type, q_self.as_ref(), path, shape)\n             }\n             ast::TyKind::Array(ref ty, ref repeats) => {\n                 let use_spaces = context.config.spaces_within_square_brackets;\n                 let lbr = if use_spaces { \"[ \" } else { \"[\" };\n                 let rbr = if use_spaces { \" ]\" } else { \"]\" };\n-                rewrite_pair(&**ty, &**repeats, lbr, \"; \", rbr, context, width, offset)\n+                rewrite_pair(&**ty, &**repeats, lbr, \"; \", rbr, context, shape)\n             }\n             ast::TyKind::Infer => {\n-                if width >= 1 {\n+                if shape.width >= 1 {\n                     Some(\"_\".to_owned())\n                 } else {\n                     None\n                 }\n             }\n-            ast::TyKind::BareFn(ref bare_fn) => {\n-                rewrite_bare_fn(bare_fn, self.span, context, width, offset)\n-            }\n+            ast::TyKind::BareFn(ref bare_fn) => rewrite_bare_fn(bare_fn, self.span, context, shape),\n             ast::TyKind::Never => Some(String::from(\"!\")),\n             ast::TyKind::Mac(..) => None,\n             ast::TyKind::ImplicitSelf => Some(String::from(\"\")),\n             ast::TyKind::ImplTrait(ref it) => {\n-                it.rewrite(context, width, offset).map(|it_str| format!(\"impl {}\", it_str))\n+                it.rewrite(context, shape).map(|it_str| format!(\"impl {}\", it_str))\n             }\n             ast::TyKind::Typeof(..) => unreachable!(),\n         }\n@@ -670,8 +664,7 @@ impl Rewrite for ast::Ty {\n fn rewrite_bare_fn(bare_fn: &ast::BareFnTy,\n                    span: Span,\n                    context: &RewriteContext,\n-                   width: usize,\n-                   offset: Indent)\n+                   shape: Shape)\n                    -> Option<String> {\n     let mut result = String::with_capacity(128);\n \n@@ -682,7 +675,10 @@ fn rewrite_bare_fn(bare_fn: &ast::BareFnTy,\n         // rightward drift. If that is a problem, we could use the list stuff.\n         result.push_str(&try_opt!(bare_fn.lifetimes\n             .iter()\n-            .map(|l| l.rewrite(context, try_opt!(width.checked_sub(6)), offset + 4))\n+            .map(|l| {\n+                l.rewrite(context,\n+                          Shape::legacy(try_opt!(shape.width.checked_sub(6)), shape.indent + 4))\n+            })\n             .intersperse(Some(\", \".to_string()))\n             .collect::<Option<String>>()));\n         result.push_str(\"> \");\n@@ -696,16 +692,15 @@ fn rewrite_bare_fn(bare_fn: &ast::BareFnTy,\n \n     result.push_str(\"fn\");\n \n-    let budget = try_opt!(width.checked_sub(result.len()));\n-    let indent = offset + result.len();\n+    let budget = try_opt!(shape.width.checked_sub(result.len()));\n+    let indent = shape.indent + result.len();\n \n     let rewrite = try_opt!(format_function_type(bare_fn.decl.inputs.iter(),\n                                                 &bare_fn.decl.output,\n                                                 bare_fn.decl.variadic,\n                                                 span,\n                                                 context,\n-                                                budget,\n-                                                indent));\n+                                                Shape::legacy(budget, indent)));\n \n     result.push_str(&rewrite);\n "}, {"sha": "c90175710251127f845e1663ba76cb48c42afffb", "filename": "src/utils.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -18,7 +18,7 @@ use syntax::ast::{self, Visibility, Attribute, MetaItem, MetaItemKind, NestedMet\n use syntax::codemap::BytePos;\n use syntax::abi;\n \n-use Indent;\n+use {Indent, Shape};\n use rewrite::{Rewrite, RewriteContext};\n \n use SKIP_ANNOTATION;\n@@ -253,18 +253,18 @@ macro_rules! source {\n \n // Wraps string-like values in an Option. Returns Some when the string adheres\n // to the Rewrite constraints defined for the Rewrite trait and else otherwise.\n-pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: Indent) -> Option<S> {\n+pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, shape: Shape) -> Option<S> {\n     {\n         let snippet = s.as_ref();\n \n-        if !snippet.contains('\\n') && snippet.len() > width {\n+        if !snippet.contains('\\n') && snippet.len() > shape.width {\n             return None;\n         } else {\n             let mut lines = snippet.lines();\n \n-            // The caller of this function has already placed `offset`\n+            // The caller of this function has already placed `shape.offset`\n             // characters on the first line.\n-            let first_line_max_len = try_opt!(max_width.checked_sub(offset.width()));\n+            let first_line_max_len = try_opt!(max_width.checked_sub(shape.indent.width()));\n             if lines.next().unwrap().len() > first_line_max_len {\n                 return None;\n             }\n@@ -278,7 +278,7 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: Ind\n             // indentation.\n             // A special check for the last line, since the caller may\n             // place trailing characters on this line.\n-            if snippet.lines().rev().next().unwrap().len() > offset.width() + width {\n+            if snippet.lines().rev().next().unwrap().len() > shape.indent.width() + shape.width {\n                 return None;\n             }\n         }\n@@ -288,8 +288,8 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: Ind\n }\n \n impl Rewrite for String {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        wrap_str(self, context.config.max_width, width, offset).map(ToOwned::to_owned)\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        wrap_str(self, context.config.max_width, shape).map(ToOwned::to_owned)\n     }\n }\n "}, {"sha": "fd0a1f1ed21e0818cb8dc4b40199ef87315871a6", "filename": "src/visitor.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428339fdc3c572b0b4a4e86ce1fc2ab048cccac0/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=428339fdc3c572b0b4a4e86ce1fc2ab048cccac0", "patch": "@@ -14,7 +14,7 @@ use syntax::parse::ParseSess;\n \n use strings::string_buffer::StringBuffer;\n \n-use Indent;\n+use {Indent, Shape};\n use utils;\n use codemap::{LineRangeUtils, SpanUtils};\n use config::Config;\n@@ -59,8 +59,9 @@ impl<'a> FmtVisitor<'a> {\n             ast::StmtKind::Expr(..) |\n             ast::StmtKind::Semi(..) => {\n                 let rewrite = stmt.rewrite(&self.get_context(),\n-                                           self.config.max_width - self.block_indent.width(),\n-                                           self.block_indent);\n+                                           Shape::legacy(self.config.max_width -\n+                                                         self.block_indent.width(),\n+                                                         self.block_indent));\n                 self.push_rewrite(stmt.span, rewrite);\n             }\n             ast::StmtKind::Mac(ref mac) => {\n@@ -425,8 +426,7 @@ impl<'a> FmtVisitor<'a> {\n         let rewrite = rewrite_macro(mac,\n                                     ident,\n                                     &self.get_context(),\n-                                    width,\n-                                    self.block_indent,\n+                                    Shape::legacy(width, self.block_indent),\n                                     pos);\n         self.push_rewrite(mac.span, rewrite);\n     }\n@@ -482,8 +482,8 @@ impl<'a> FmtVisitor<'a> {\n         self.format_missing_with_indent(source!(self, first.span).lo);\n \n         let rewrite = outers.rewrite(&self.get_context(),\n-                     self.config.max_width - self.block_indent.width(),\n-                     self.block_indent)\n+                     Shape::legacy(self.config.max_width - self.block_indent.width(),\n+                                   self.block_indent))\n             .unwrap();\n         self.buffer.push_str(&rewrite);\n         let last = outers.last().unwrap();\n@@ -566,12 +566,12 @@ impl<'a> FmtVisitor<'a> {\n }\n \n impl<'a> Rewrite for [ast::Attribute] {\n-    fn rewrite(&self, context: &RewriteContext, _: usize, offset: Indent) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         let mut result = String::new();\n         if self.is_empty() {\n             return Some(result);\n         }\n-        let indent = offset.to_string(context.config);\n+        let indent = shape.indent.to_string(context.config);\n \n         for (i, a) in self.iter().enumerate() {\n             let mut a_str = context.snippet(a.span);\n@@ -587,9 +587,10 @@ impl<'a> Rewrite for [ast::Attribute] {\n                 if !comment.is_empty() {\n                     let comment = try_opt!(rewrite_comment(comment,\n                                                            false,\n-                                                           context.config.ideal_width -\n-                                                           offset.width(),\n-                                                           offset,\n+                                                           Shape::legacy(context.config\n+                                                                             .ideal_width -\n+                                                                         shape.indent.width(),\n+                                                                         shape.indent),\n                                                            context.config));\n                     result.push_str(&indent);\n                     result.push_str(&comment);\n@@ -603,8 +604,9 @@ impl<'a> Rewrite for [ast::Attribute] {\n             if a_str.starts_with(\"//\") {\n                 a_str = try_opt!(rewrite_comment(&a_str,\n                                                  false,\n-                                                 context.config.ideal_width - offset.width(),\n-                                                 offset,\n+                                                 Shape::legacy(context.config.ideal_width -\n+                                                               shape.indent.width(),\n+                                                               shape.indent),\n                                                  context.config));\n             }\n "}]}