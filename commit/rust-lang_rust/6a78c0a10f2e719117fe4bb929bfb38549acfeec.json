{"sha": "6a78c0a10f2e719117fe4bb929bfb38549acfeec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNzhjMGExMGYyZTcxOTExN2ZlNGJiOTI5YmZiMzg1NDlhY2ZlZWM=", "commit": {"author": {"name": "Brad Gibson", "email": "b2b@humanenginuity.com", "date": "2018-05-06T14:56:53Z"}, "committer": {"name": "Brad Gibson", "email": "b2b@humanenginuity.com", "date": "2018-05-06T14:56:53Z"}, "message": "resolved conflict with upstream commit", "tree": {"sha": "0089dcdd34bfa5ba430ed33163264b147677be59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0089dcdd34bfa5ba430ed33163264b147677be59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a78c0a10f2e719117fe4bb929bfb38549acfeec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a78c0a10f2e719117fe4bb929bfb38549acfeec", "html_url": "https://github.com/rust-lang/rust/commit/6a78c0a10f2e719117fe4bb929bfb38549acfeec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a78c0a10f2e719117fe4bb929bfb38549acfeec/comments", "author": {"login": "Xandkeeper", "id": 124085026, "node_id": "U_kgDOB2VjIg", "avatar_url": "https://avatars.githubusercontent.com/u/124085026?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xandkeeper", "html_url": "https://github.com/Xandkeeper", "followers_url": "https://api.github.com/users/Xandkeeper/followers", "following_url": "https://api.github.com/users/Xandkeeper/following{/other_user}", "gists_url": "https://api.github.com/users/Xandkeeper/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xandkeeper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xandkeeper/subscriptions", "organizations_url": "https://api.github.com/users/Xandkeeper/orgs", "repos_url": "https://api.github.com/users/Xandkeeper/repos", "events_url": "https://api.github.com/users/Xandkeeper/events{/privacy}", "received_events_url": "https://api.github.com/users/Xandkeeper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xandkeeper", "id": 124085026, "node_id": "U_kgDOB2VjIg", "avatar_url": "https://avatars.githubusercontent.com/u/124085026?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xandkeeper", "html_url": "https://github.com/Xandkeeper", "followers_url": "https://api.github.com/users/Xandkeeper/followers", "following_url": "https://api.github.com/users/Xandkeeper/following{/other_user}", "gists_url": "https://api.github.com/users/Xandkeeper/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xandkeeper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xandkeeper/subscriptions", "organizations_url": "https://api.github.com/users/Xandkeeper/orgs", "repos_url": "https://api.github.com/users/Xandkeeper/repos", "events_url": "https://api.github.com/users/Xandkeeper/events{/privacy}", "received_events_url": "https://api.github.com/users/Xandkeeper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1d5509bf381d978a1894b6ba869c3b56dd3eeca", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d5509bf381d978a1894b6ba869c3b56dd3eeca", "html_url": "https://github.com/rust-lang/rust/commit/e1d5509bf381d978a1894b6ba869c3b56dd3eeca"}, {"sha": "6f721f54c6fb1de9cf00eb9d2d050f818c882871", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f721f54c6fb1de9cf00eb9d2d050f818c882871", "html_url": "https://github.com/rust-lang/rust/commit/6f721f54c6fb1de9cf00eb9d2d050f818c882871"}], "stats": {"total": 15733, "additions": 10871, "deletions": 4862}, "files": [{"sha": "34fcc755b3a49509d6f893e34df1b1988d94581c", "filename": "config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -346,6 +346,9 @@\n # Whether to deny warnings in crates\n #deny-warnings = true\n \n+# Print backtrace on internal compiler errors during bootstrap\n+#backtrace-on-ice = false\n+\n # =============================================================================\n # Options for specific targets\n #"}, {"sha": "a2767bd290d5e882f0ab3ea8622db283b8ce4f8c", "filename": "src/Cargo.lock", "status": "modified", "additions": 71, "deletions": 53, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -390,10 +390,12 @@ dependencies = [\n  \"env_logger 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miow 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustfix 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -996,9 +998,10 @@ dependencies = [\n \n [[package]]\n name = \"languageserver-types\"\n-version = \"0.36.0\"\n+version = \"0.39.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n+ \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1325,16 +1328,16 @@ dependencies = [\n \n [[package]]\n name = \"parking_lot\"\n-version = \"0.5.4\"\n+version = \"0.5.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot_core 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot_core 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"parking_lot_core\"\n-version = \"0.2.13\"\n+version = \"0.2.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"libc 0.2.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1623,7 +1626,7 @@ dependencies = [\n \n [[package]]\n name = \"rls\"\n-version = \"0.126.0\"\n+version = \"0.127.0\"\n dependencies = [\n  \"cargo 0.28.0\",\n  \"cargo_metadata 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1632,7 +1635,7 @@ dependencies = [\n  \"failure 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"json 0.11.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jsonrpc-core 8.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"languageserver-types 0.36.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"languageserver-types 0.39.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1644,7 +1647,7 @@ dependencies = [\n  \"rls-rustc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-vfs 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustfmt-nightly 0.6.0\",\n+ \"rustfmt-nightly 0.6.1\",\n  \"serde 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1728,7 +1731,6 @@ dependencies = [\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n- \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_target 0.0.0\",\n@@ -1740,70 +1742,84 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_cratesio_shim\"\n-version = \"110.0.0\"\n+version = \"113.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"110.0.0\"\n+version = \"113.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot_core 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot_core 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_cratesio_shim 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"110.0.0\"\n+version = \"113.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"atty 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax_pos 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax_pos 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"termcolor 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rustc-ap-rustc_target\"\n+version = \"113.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_cratesio_shim 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustc-ap-serialize\"\n-version = \"110.0.0\"\n+version = \"113.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"rustc-ap-syntax\"\n-version = \"110.0.0\"\n+version = \"113.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_cratesio_shim 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_errors 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax_pos 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_errors 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_target 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax_pos 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scoped-tls 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-syntax_pos\"\n-version = \"110.0.0\"\n+version = \"113.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-ap-rustc_data_structures 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scoped-tls 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1872,15 +1888,6 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n-[[package]]\n-name = \"rustc_const_math\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"rustc_apfloat 0.0.0\",\n- \"serialize 0.0.0\",\n- \"syntax 0.0.0\",\n-]\n-\n [[package]]\n name = \"rustc_cratesio_shim\"\n version = \"0.0.0\"\n@@ -1896,8 +1903,8 @@ dependencies = [\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot_core 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot_core 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n  \"serialize 0.0.0\",\n  \"stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2026,7 +2033,6 @@ dependencies = [\n  \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n- \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_target 0.0.0\",\n@@ -2053,7 +2059,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_mir 0.0.0\",\n@@ -2154,7 +2159,6 @@ dependencies = [\n  \"rustc-demangle 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n- \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n@@ -2205,7 +2209,6 @@ dependencies = [\n  \"fmt_macros 0.0.0\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_platform_intrinsics 0.0.0\",\n@@ -2233,22 +2236,35 @@ dependencies = [\n  \"rustdoc 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustfix\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"quick-error 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"0.6.0\"\n+version = \"0.6.1\"\n dependencies = [\n  \"assert_cli 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargo_metadata 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"derive-new 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_target 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3063,7 +3079,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum json 0.11.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9ad0485404155f45cce53a40d4b2d6ac356418300daed05273d9e26f91c390be\"\n \"checksum jsonrpc-core 8.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddf83704f4e79979a424d1082dd2c1e52683058056c9280efa19ac5f6bc9033c\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n-\"checksum languageserver-types 0.36.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"174cdfb8bed13225bb419bec66ee1c970099c875688645f9c4a82e3af43ba69d\"\n+\"checksum languageserver-types 0.39.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad4cdd5e52d71aca47050e5b25f03082609c63a1e76b7362ebdd010895b3f854\"\n \"checksum lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76f033c7ad61445c5b347c7382dd1237847eb1bce590fe50365dcb33d546be73\"\n \"checksum lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c8f31047daa365f19be14b47c29df4f7c3b581832407daabe6ae77397619237d\"\n \"checksum lazycell 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a6f08839bc70ef4a3fe1d566d5350f519c5912ea86be0df1740a7d247c7fc0ef\"\n@@ -3096,8 +3112,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum openssl-sys 0.9.28 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0bbd90640b148b46305c1691eed6039b5c8509bed16991e3562a01eeb76902a3\"\n \"checksum ordermap 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a86ed3f5f244b372d6b1a00b72ef7f8876d0bc6a78a4c9985c53614041512063\"\n \"checksum owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdf84f41639e037b484f93433aa3897863b561ed65c6e59c7073d7c561710f37\"\n-\"checksum parking_lot 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9fd9d732f2de194336fb02fe11f9eed13d9e76f13f4315b4d88a14ca411750cd\"\n-\"checksum parking_lot_core 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"538ef00b7317875071d5e00f603f24d16f0b474c1a5fc0ccb8b454ca72eafa79\"\n+\"checksum parking_lot 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4d05f1349491390b1730afba60bb20d55761bef489a954546b58b4b34e1e2ac\"\n+\"checksum parking_lot_core 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4db1a8ccf734a7bce794cc19b3df06ed87ab2f3907036b693c68f56b4d4537fa\"\n \"checksum percent-encoding 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"31010dd2e1ac33d5b46a5b413495239882813e0369f8ed8a5e266f173602f831\"\n \"checksum pest 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0fce5d8b5cc33983fc74f78ad552b5522ab41442c4ca91606e4236eb4b5ceefc\"\n \"checksum pest_derive 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab94faafeb93f4c5e3ce81ca0e5a779529a602ad5d09ae6d21996bfb8b6a52bf\"\n@@ -3134,14 +3150,16 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rls-rustc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"885f66b92757420572cbb02e033d4a9558c7413ca9b7ac206f28fd58ffdb44ea\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n \"checksum rls-vfs 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be231e1e559c315bc60ced5ad2cc2d7a9c208ed7d4e2c126500149836fda19bb\"\n-\"checksum rustc-ap-rustc_cratesio_shim 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0256e318ad99c467d24bd7188f2d4a3028360621bb92d769b4b65fc44717d514\"\n-\"checksum rustc-ap-rustc_data_structures 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"83430df7f76ea85c1f70fe145041576eee8fd5d77053bf426df24b480918d185\"\n-\"checksum rustc-ap-rustc_errors 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2b03f874277103039816f6467b1ff30a81b1d6a29d4de6efccefe4c488f6535a\"\n-\"checksum rustc-ap-serialize 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a2e47cf949f06b0c7ab7566c2f69d49f28cb3ecf1bb8bf0bda48b1ba5b7945ae\"\n-\"checksum rustc-ap-syntax 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"625e6fb41fde299082cda3bceb08f81c9ba56b14a2ec737b4366f9c3c9be07d8\"\n-\"checksum rustc-ap-syntax_pos 110.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"474a23ef1a1245ae02c5fd6a1e9a0725ce6fd25ca2294703c03bddce041f867b\"\n+\"checksum rustc-ap-rustc_cratesio_shim 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a01334797c5c4cf56cc40bb9636d7b4c4a076665b9b9b7f100fd666cf0a02ffc\"\n+\"checksum rustc-ap-rustc_data_structures 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"03d6f8f7da0de905f6ef80dc14dce3bbc372430622b6aeb421cf13190bc70e8a\"\n+\"checksum rustc-ap-rustc_errors 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3dfd6183804a685c48601651d8c8c7b0daa8f83b0b5e24edfbcb6a0337085127\"\n+\"checksum rustc-ap-rustc_target 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5f223157f51bf0e0621bef099de862468892ee4c4b83056f48f63e1bc00ccb72\"\n+\"checksum rustc-ap-serialize 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2104a55a87d65cba8a845656f1f19a35da52af403863cd2a4bd5876ba522d879\"\n+\"checksum rustc-ap-syntax 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b50671adb9b0a7c57a4690ac6a40cb614879f543b64aada42f55b66212492323\"\n+\"checksum rustc-ap-syntax_pos 113.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"55793c2a775230c42661194c48d44b35d4c8439d79ad8528e56651e854c48c63\"\n \"checksum rustc-demangle 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11fb43a206a04116ffd7cfcf9bcb941f8eb6cc7ff667272246b0a1c74259a3cb\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n+\"checksum rustfix 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"165a212dd11124d7070892da20f71d82970ef1d1dd41cd804b70f39740a21c85\"\n \"checksum same-file 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d931a44fdaa43b8637009e7632a02adc4f2b2e0733c08caa4cf00e8da4a117a7\"\n \"checksum same-file 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cfb6eded0b06a0b512c8ddbcf04089138c9b4362c2f696f3c3d76039d68f3637\"\n \"checksum schannel 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"85fd9df495640643ad2d00443b3d78aae69802ad488debab4f1dd52fc1806ade\""}, {"sha": "35858ee286838c5b8d7563e2fb295e29036322be", "filename": "src/Cargo.toml", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -40,14 +40,6 @@ members = [\n   \"tools/rls/test_data/workspace_symbol\",\n ]\n \n-# Curiously, compiletest will segfault if compiled with opt-level=3 on 64-bit\n-# MSVC when running the compile-fail test suite when a should-fail test panics.\n-# But hey if this is removed and it gets past the bots, sounds good to me.\n-[profile.release]\n-opt-level = 2\n-[profile.bench]\n-opt-level = 2\n-\n # These options are controlled from our rustc wrapper script, so turn them off\n # here and have them controlled elsewhere.\n [profile.dev]"}, {"sha": "98c353eb6ec8c3fa967b317693d261948d0ed0b3", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -64,6 +64,10 @@ The script accepts commands, flags, and arguments to determine what to do:\n   # execute tests in the standard library in stage0\n   ./x.py test --stage 0 src/libstd\n \n+  # execute tests in the core and standard library in stage0,\n+  # without running doc tests (thus avoid depending on building the compiler)\n+  ./x.py test --stage 0 --no-doc src/libcore src/libstd\n+\n   # execute all doc tests\n   ./x.py test src/doc\n   ```"}, {"sha": "3f97accaa4d84088ecbd8524e359d653dda4aa6c", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -107,6 +107,13 @@ fn main() {\n              env::join_paths(&dylib_path).unwrap());\n     let mut maybe_crate = None;\n \n+    // Print backtrace in case of ICE\n+    if env::var(\"RUSTC_BACKTRACE_ON_ICE\").is_ok() && env::var(\"RUST_BACKTRACE\").is_err() {\n+        cmd.env(\"RUST_BACKTRACE\", \"1\");\n+    }\n+\n+    cmd.env(\"RUSTC_BREAK_ON_ICE\", \"1\");\n+\n     if let Some(target) = target {\n         // The stage0 compiler has a special sysroot distinct from what we\n         // actually downloaded, so we just always pass the `--sysroot` option."}, {"sha": "9c35cb7f506f970a8370bf427a3bf1fe513e02ab", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -25,7 +25,7 @@ use compile;\n use install;\n use dist;\n use util::{exe, libdir, add_lib_path};\n-use {Build, Mode};\n+use {Build, Mode, DocTests};\n use cache::{INTERNER, Interned, Cache};\n use check;\n use test;\n@@ -323,15 +323,15 @@ impl<'a> Builder<'a> {\n                 test::Cargotest, test::Cargo, test::Rls, test::ErrorIndex, test::Distcheck,\n                 test::RunMakeFullDeps,\n                 test::Nomicon, test::Reference, test::RustdocBook, test::RustByExample,\n-                test::TheBook, test::UnstableBook,\n+                test::TheBook, test::UnstableBook, test::RustcBook,\n                 test::Rustfmt, test::Miri, test::Clippy, test::RustdocJS, test::RustdocTheme,\n                 // Run run-make last, since these won't pass without make on Windows\n                 test::RunMake, test::RustdocUi),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n                 doc::Standalone, doc::Std, doc::Test, doc::WhitelistedRustc, doc::Rustc,\n                 doc::ErrorIndex, doc::Nomicon, doc::Reference, doc::Rustdoc, doc::RustByExample,\n-                doc::CargoBook),\n+                doc::RustcBook, doc::CargoBook),\n             Kind::Dist => describe!(dist::Docs, dist::RustcDocs, dist::Mingw, dist::Rustc,\n                 dist::DebuggerScripts, dist::Std, dist::Analysis, dist::Src,\n                 dist::PlainSourceTarball, dist::Cargo, dist::Rls, dist::Rustfmt, dist::Extended,\n@@ -591,6 +591,8 @@ impl<'a> Builder<'a> {\n                 format!(\"{} {}\", env::var(\"RUSTFLAGS\").unwrap_or_default(), extra_args));\n         }\n \n+        let want_rustdoc = self.doc_tests != DocTests::No;\n+\n         // Customize the compiler we're running. Specify the compiler to cargo\n         // as our shim and then pass it some various options used to configure\n         // how the actual compiler itself is called.\n@@ -607,7 +609,7 @@ impl<'a> Builder<'a> {\n              .env(\"RUSTC_LIBDIR\", self.rustc_libdir(compiler))\n              .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n              .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n-             .env(\"RUSTDOC_REAL\", if cmd == \"doc\" || cmd == \"test\" {\n+             .env(\"RUSTDOC_REAL\", if cmd == \"doc\" || (cmd == \"test\" && want_rustdoc) {\n                  self.rustdoc(compiler.host)\n              } else {\n                  PathBuf::from(\"/path/to/nowhere/rustdoc/not/required\")\n@@ -624,7 +626,7 @@ impl<'a> Builder<'a> {\n         if let Some(ref error_format) = self.config.rustc_error_format {\n             cargo.env(\"RUSTC_ERROR_FORMAT\", error_format);\n         }\n-        if cmd != \"build\" && cmd != \"check\" {\n+        if cmd != \"build\" && cmd != \"check\" && want_rustdoc {\n             cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(self.compiler(2, self.config.build)));\n         }\n \n@@ -706,6 +708,10 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_PRINT_STEP_TIMINGS\", \"1\");\n         }\n \n+        if self.config.backtrace_on_ice {\n+            cargo.env(\"RUSTC_BACKTRACE_ON_ICE\", \"1\");\n+        }\n+\n         cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", self.verbosity));\n \n         // in std, we want to avoid denying warnings for stage 0 as that makes cfg's painful.\n@@ -1403,4 +1409,39 @@ mod __test {\n             },\n         ]);\n     }\n+\n+    #[test]\n+    fn test_with_no_doc_stage0() {\n+        let mut config = configure(&[], &[]);\n+        config.stage = Some(0);\n+        config.cmd = Subcommand::Test {\n+            paths: vec![\"src/libstd\".into()],\n+            test_args: vec![],\n+            rustc_args: vec![],\n+            fail_fast: true,\n+            doc_tests: DocTests::No,\n+        };\n+\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+\n+        let host = INTERNER.intern_str(\"A\");\n+\n+        builder.run_step_descriptions(\n+            &[StepDescription::from::<test::Crate>()],\n+            &[\"src/libstd\".into()],\n+        );\n+\n+        // Ensure we don't build any compiler artifacts.\n+        assert!(builder.cache.all::<compile::Rustc>().is_empty());\n+        assert_eq!(first(builder.cache.all::<test::Crate>()), &[\n+            test::Crate {\n+                compiler: Compiler { host, stage: 0 },\n+                target: host,\n+                mode: Mode::Libstd,\n+                test_kind: test::TestKind::Test,\n+                krate: INTERNER.intern_str(\"std\"),\n+            },\n+        ]);\n+    }\n }"}, {"sha": "6dd6291be2397cbb08960729a7584762b452ed43", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -72,6 +72,7 @@ pub struct Config {\n     pub dry_run: bool,\n \n     pub deny_warnings: bool,\n+    pub backtrace_on_ice: bool,\n \n     // llvm codegen options\n     pub llvm_enabled: bool,\n@@ -306,6 +307,7 @@ struct Rust {\n     wasm_syscall: Option<bool>,\n     lld: Option<bool>,\n     deny_warnings: Option<bool>,\n+    backtrace_on_ice: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -325,6 +327,14 @@ struct TomlTarget {\n }\n \n impl Config {\n+    fn path_from_python(var_key: &str) -> PathBuf {\n+        match env::var_os(var_key) {\n+            // Do not trust paths from Python and normalize them slightly (#49785).\n+            Some(var_val) => Path::new(&var_val).components().collect(),\n+            _ => panic!(\"expected '{}' to be set\", var_key),\n+        }\n+    }\n+\n     pub fn default_opts() -> Config {\n         let mut config = Config::default();\n         config.llvm_enabled = true;\n@@ -348,9 +358,9 @@ impl Config {\n         config.deny_warnings = true;\n \n         // set by bootstrap.py\n-        config.src = env::var_os(\"SRC\").map(PathBuf::from).expect(\"'SRC' to be set\");\n         config.build = INTERNER.intern_str(&env::var(\"BUILD\").expect(\"'BUILD' to be set\"));\n-        config.out = env::var_os(\"BUILD_DIR\").map(PathBuf::from).expect(\"'BUILD_DIR' set\");\n+        config.src = Config::path_from_python(\"SRC\");\n+        config.out = Config::path_from_python(\"BUILD_DIR\");\n \n         let stage0_root = config.out.join(&config.build).join(\"stage0/bin\");\n         config.initial_rustc = stage0_root.join(exe(\"rustc\", &config.build));\n@@ -523,6 +533,7 @@ impl Config {\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n             config.save_toolstates = rust.save_toolstates.clone().map(PathBuf::from);\n             set(&mut config.deny_warnings, rust.deny_warnings.or(flags.warnings));\n+            set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n \n             if let Some(ref backends) = rust.codegen_backends {\n                 config.rust_codegen_backends = backends.iter()"}, {"sha": "3574b7d210a2d3b641931660eee488aad45f1068", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -120,6 +120,8 @@ def v(*args):\n   \"arm-unknown-linux-musleabi install directory\")\n v(\"musl-root-armhf\", \"target.arm-unknown-linux-musleabihf.musl-root\",\n   \"arm-unknown-linux-musleabihf install directory\")\n+v(\"musl-root-armv5te\", \"target.armv5te-unknown-linux-musleabi.musl-root\",\n+  \"armv5te-unknown-linux-musleabi install directory\")\n v(\"musl-root-armv7\", \"target.armv7-unknown-linux-musleabihf.musl-root\",\n   \"armv7-unknown-linux-musleabihf install directory\")\n v(\"musl-root-aarch64\", \"target.aarch64-unknown-linux-musl.musl-root\","}, {"sha": "16f4b29dcceefbeefc643e889246654c7a89464c", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -71,6 +71,7 @@ book!(\n     Nomicon, \"src/doc/nomicon\", \"nomicon\";\n     Reference, \"src/doc/reference\", \"reference\";\n     Rustdoc, \"src/doc/rustdoc\", \"rustdoc\";\n+    RustcBook, \"src/doc/rustc\", \"rustc\";\n     RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\";\n );\n "}, {"sha": "5315a3028ffa9c05fa8d3839ff52b223ddad9a4d", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -19,7 +19,7 @@ use std::process;\n \n use getopts::Options;\n \n-use Build;\n+use {Build, DocTests};\n use config::Config;\n use metadata;\n use builder::Builder;\n@@ -62,7 +62,7 @@ pub enum Subcommand {\n         test_args: Vec<String>,\n         rustc_args: Vec<String>,\n         fail_fast: bool,\n-        doc_tests: bool,\n+        doc_tests: DocTests,\n     },\n     Bench {\n         paths: Vec<PathBuf>,\n@@ -171,7 +171,8 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n                     \"extra options to pass the compiler when running tests\",\n                     \"ARGS\",\n                 );\n-                opts.optflag(\"\", \"doc\", \"run doc tests\");\n+                opts.optflag(\"\", \"no-doc\", \"do not run doc tests\");\n+                opts.optflag(\"\", \"doc\", \"only run doc tests\");\n             },\n             \"bench\" => { opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\"); },\n             \"clean\" => { opts.optflag(\"\", \"all\", \"clean all build artifacts\"); },\n@@ -324,7 +325,13 @@ Arguments:\n                     test_args: matches.opt_strs(\"test-args\"),\n                     rustc_args: matches.opt_strs(\"rustc-args\"),\n                     fail_fast: !matches.opt_present(\"no-fail-fast\"),\n-                    doc_tests: matches.opt_present(\"doc\"),\n+                    doc_tests: if matches.opt_present(\"doc\") {\n+                        DocTests::Only\n+                    } else if matches.opt_present(\"no-doc\") {\n+                        DocTests::No\n+                    } else {\n+                        DocTests::Yes\n+                    }\n                 }\n             }\n             \"bench\" => {\n@@ -411,10 +418,10 @@ impl Subcommand {\n         }\n     }\n \n-    pub fn doc_tests(&self) -> bool {\n+    pub fn doc_tests(&self) -> DocTests {\n         match *self {\n             Subcommand::Test { doc_tests, .. } => doc_tests,\n-            _ => false,\n+            _ => DocTests::Yes,\n         }\n     }\n }"}, {"sha": "6445ce8da332ea95904fb6b8a7ebbfd16f09d029", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -122,12 +122,10 @@ struct JOBOBJECT_BASIC_LIMIT_INFORMATION {\n }\n \n pub unsafe fn setup(build: &mut Build) {\n-    // Tell Windows to not show any UI on errors (such as not finding a required dll\n-    // during startup or terminating abnormally).  This is important for running tests,\n-    // since some of them use abnormal termination by design.\n-    // This mode is inherited by all child processes.\n-    let mode = SetErrorMode(SEM_NOGPFAULTERRORBOX); // read inherited flags\n-    SetErrorMode(mode | SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);\n+    // Enable the Windows Error Reporting dialog which msys disables,\n+    // so we can JIT debug rustc\n+    let mode = SetErrorMode(0);\n+    SetErrorMode(mode & !SEM_NOGPFAULTERRORBOX);\n \n     // Create a new job object for us to use\n     let job = CreateJobObjectW(0 as *mut _, 0 as *const _);"}, {"sha": "e53fef06786130e03c26611efb51998211c60b76", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -210,6 +210,16 @@ pub struct Compiler {\n     host: Interned<String>,\n }\n \n+#[derive(PartialEq, Eq, Copy, Clone, Debug)]\n+pub enum DocTests {\n+    // Default, run normal tests and doc tests.\n+    Yes,\n+    // Do not run any doc tests.\n+    No,\n+    // Only run doc tests.\n+    Only,\n+}\n+\n /// Global configuration for the build system.\n ///\n /// This structure transitively contains all configuration for the build system.\n@@ -233,7 +243,7 @@ pub struct Build {\n     rustfmt_info: channel::GitInfo,\n     local_rebuild: bool,\n     fail_fast: bool,\n-    doc_tests: bool,\n+    doc_tests: DocTests,\n     verbosity: usize,\n \n     // Targets for which to build.\n@@ -294,7 +304,7 @@ impl Crate {\n ///\n /// These entries currently correspond to the various output directories of the\n /// build system, with each mod generating output in a different directory.\n-#[derive(Debug, Hash, Clone, Copy, PartialEq, Eq)]\n+#[derive(Debug, Hash, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub enum Mode {\n     /// Build the standard library, placing output in the \"stageN-std\" directory.\n     Libstd,"}, {"sha": "cbb952bab61b2c2ee6221f161a49a1d76037dd5b", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -32,13 +32,13 @@ use dist;\n use native;\n use tool::{self, Tool};\n use util::{self, dylib_path, dylib_path_var};\n-use Mode;\n+use {Mode, DocTests};\n use toolstate::ToolState;\n \n const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n \n /// The two modes of the test runner; tests or benchmarks.\n-#[derive(Debug, PartialEq, Eq, Hash, Copy, Clone)]\n+#[derive(Debug, PartialEq, Eq, Hash, Copy, Clone, PartialOrd, Ord)]\n pub enum TestKind {\n     /// Run `cargo test`\n     Test,\n@@ -1212,6 +1212,7 @@ test_book!(\n     Nomicon, \"src/doc/nomicon\", \"nomicon\", default=false;\n     Reference, \"src/doc/reference\", \"reference\", default=false;\n     RustdocBook, \"src/doc/rustdoc\", \"rustdoc\", default=true;\n+    RustcBook, \"src/doc/rustc\", \"rustc\", default=true;\n     RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", default=false;\n     TheBook, \"src/doc/book\", \"book\", default=false;\n     UnstableBook, \"src/doc/unstable-book\", \"unstable-book\", default=true;\n@@ -1406,13 +1407,13 @@ impl Step for CrateNotDefault {\n }\n \n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Crate {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: Mode,\n-    test_kind: TestKind,\n-    krate: Interned<String>,\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n+    pub mode: Mode,\n+    pub test_kind: TestKind,\n+    pub krate: Interned<String>,\n }\n \n impl Step for Crate {\n@@ -1518,8 +1519,14 @@ impl Step for Crate {\n         if test_kind.subcommand() == \"test\" && !builder.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n         }\n-        if builder.doc_tests {\n-            cargo.arg(\"--doc\");\n+        match builder.doc_tests {\n+            DocTests::Only => {\n+                cargo.arg(\"--doc\");\n+            }\n+            DocTests::No => {\n+                cargo.args(&[\"--lib\", \"--bins\", \"--examples\", \"--tests\", \"--benches\"]);\n+            }\n+            DocTests::Yes => {}\n         }\n \n         cargo.arg(\"-p\").arg(krate);"}, {"sha": "b195decfcf57421f4df8e22bc938c15db52199a0", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -43,6 +43,10 @@ ENV STAGING_DIR=/tmp\n \n COPY scripts/musl.sh /build\n RUN env \\\n+    CC=arm-linux-gnueabi-gcc CFLAGS=\"-march=armv5te -marm -mfloat-abi=soft\" \\\n+    CXX=arm-linux-gnueabi-g++ CXXFLAGS=\"-march=armv5te -marm -mfloat-abi=soft\" \\\n+    bash musl.sh armv5te && \\\n+    env \\\n     CC=arm-linux-gnueabi-gcc CFLAGS=\"-march=armv6 -marm\" \\\n     CXX=arm-linux-gnueabi-g++ CXXFLAGS=\"-march=armv6 -marm\" \\\n     bash musl.sh arm && \\\n@@ -84,6 +88,7 @@ ENV TARGETS=$TARGETS,mipsel-unknown-linux-musl\n ENV TARGETS=$TARGETS,arm-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,arm-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,armv5te-unknown-linux-gnueabi\n+ENV TARGETS=$TARGETS,armv5te-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n@@ -100,9 +105,12 @@ ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_sparc64_unknown_linux_gnu=sparc64-linux-gnu-gcc \\\n     CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc \\\n     CC_armv5te_unknown_linux_gnueabi=arm-linux-gnueabi-gcc \\\n-    CFLAGS_armv5te_unknown_linux_gnueabi=\"-march=armv5te -marm -mfloat-abi=soft\"\n+    CFLAGS_armv5te_unknown_linux_gnueabi=\"-march=armv5te -marm -mfloat-abi=soft\" \\\n+    CC_armv5te_unknown_linux_musleabi=arm-linux-gnueabi-gcc \\\n+    CFLAGS_armv5te_unknown_linux_musleabi=\"-march=armv5te -marm -mfloat-abi=soft\"\n \n ENV RUST_CONFIGURE_ARGS \\\n+      --musl-root-armv5te=/musl-armv5te \\\n       --musl-root-arm=/musl-arm \\\n       --musl-root-armhf=/musl-armhf \\\n       --musl-root-armv7=/musl-armv7 \\"}, {"sha": "aab339f399c598504021faf3a444175324a91185", "filename": "src/ci/docker/mingw-check/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -19,4 +19,5 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n ENV SCRIPT python2.7 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu"}, {"sha": "bdde7ad7fe854a0d29fad01b0a012433e82c9e54", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -16,7 +16,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENV PARALLEL_CHECK 1\n+ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-debug \\"}, {"sha": "456f8cc7317e78cb7802bd2b2cf602c473517db3", "filename": "src/ci/run.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -78,9 +78,9 @@ fi\n # sccache server at the start of the build, but no need to worry if this fails.\n SCCACHE_IDLE_TIMEOUT=10800 sccache --start-server || true\n \n-if [ \"$PARALLEL_CHECK\" != \"\" ]; then\n+if [ \"$RUN_CHECK_WITH_PARALLEL_QUERIES\" != \"\" ]; then\n   $SRC/configure --enable-experimental-parallel-queries\n-  python2.7 ../x.py check\n+  CARGO_INCREMENTAL=0 python2.7 ../x.py check\n   rm -f config.toml\n   rm -rf build\n fi"}, {"sha": "f51127530d46b9acbf4747c859da185e771cfcf3", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1 +1 @@\n-Subproject commit b889e1e30c5e9953834aa9fa6c982bb28df46ac9\n+Subproject commit f51127530d46b9acbf4747c859da185e771cfcf3"}, {"sha": "3a4f51069fc3b7f1534b7a5505633f5cfc04f90f", "filename": "src/doc/index.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -43,6 +43,10 @@ Rust's standard library has [extensive API documentation](std/index.html),\n with explanations of how to use various things, as well as example code for\n accomplishing various tasks.\n \n+## The Rustc Book\n+\n+[The Rustc Book](rustc/index.html) describes the Rust compiler, `rustc`.\n+\n ## The Cargo Book\n \n [The Cargo Book](cargo/index.html) is a guide to Cargo, Rust's build tool and dependency manager."}, {"sha": "748a5e6742db4a21c4c630a58087f818828e8a0a", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1 +1 @@\n-Subproject commit 3c56329d1bd9038e5341f1962bcd8d043312a712\n+Subproject commit 748a5e6742db4a21c4c630a58087f818828e8a0a"}, {"sha": "134f419ee62714590b04712fe6072253bc2a7822", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1 +1 @@\n-Subproject commit 76296346e97c3702974d3398fdb94af9e10111a2\n+Subproject commit 134f419ee62714590b04712fe6072253bc2a7822"}, {"sha": "eebda16e4b45f2eed4310cf7b9872cc752278163", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1 +1 @@\n-Subproject commit d5ec87eabe5733cc2348c7dada89fc67c086f391\n+Subproject commit eebda16e4b45f2eed4310cf7b9872cc752278163"}, {"sha": "7585238efedfc33acdd9494b0269951aaf3909ec", "filename": "src/doc/rustc/.gitignore", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2F.gitignore?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1 @@\n+book"}, {"sha": "8adc05c5137206ddefc284b601d47d8b85ab0dcb", "filename": "src/doc/rustc/book.toml", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fbook.toml?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,5 @@\n+[book]\n+authors = [\"The Rust Project Developers\"]\n+multilingual = false\n+src = \"src\"\n+title = \"The rustc book\""}, {"sha": "e4c0939fd46369d4ad9102b58dcdb4e59a4d9a02", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,16 @@\n+# The Rustc Book\n+\n+- [What is rustc?](what-is-rustc.md)\n+- [Command-line arguments](command-line-arguments.md)\n+- [Lints](lints/index.md)\n+    - [Lint levels](lints/levels.md)\n+    - [Lint Groups](lints/groups.md)\n+    - [Lint listing](lints/listing/index.md)\n+        - [Allowed-by-default lints](lints/listing/allowed-by-default.md)\n+        - [Warn-by-default lints](lints/listing/warn-by-default.md)\n+        - [Deny-by-default lints](lints/listing/deny-by-default.md)\n+- [Codegen options](codegen-options/index.md)\n+- [Targets](targets/index.md)\n+    - [Built-in Targets](targets/built-in.md)\n+    - [Custom Targets](targets/custom.md)\n+- [Contributing to `rustc`](contributing.md)\n\\ No newline at end of file"}, {"sha": "eff09428902e8012669b88ddc87266e06894f238", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,209 @@\n+# Codegen options\n+\n+All of these options are passed to `rustc` via the `-C` flag, short for \"codegen.\" You can see\n+a version of this list for your exact compiler by running `rustc -C help`.\n+\n+## ar\n+\n+This option is deprecated and does nothing.\n+\n+## linker\n+\n+This flag lets you control which linker `rustc` invokes to link your code.\n+\n+## link-arg=val\n+\n+This flag lets you append a single extra argument to the linker invocation.\n+\n+\"Append\" is significant; you can pass this flag multiple times to add multiple arguments.\n+\n+## link-args\n+\n+This flag lets you append multiple extra arguments to the linker invocation. The\n+options should be separated by spaces.\n+\n+## link-dead-code\n+\n+Normally, the linker will remove dead code. This flag disables this behavior.\n+\n+An example of when this flag might be useful is when trying to construct code coverage\n+metrics.\n+\n+## lto\n+\n+This flag instructs LLVM to use [link time\n+optimizations](https://llvm.org/docs/LinkTimeOptimization.html).\n+\n+It takes one of two values, `thin` and `fat`. 'thin' LTO [is a new feature of\n+LLVM](http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html),\n+'fat' referring to the classic version of LTO.\n+\n+## target-cpu\n+\n+This instructs `rustc` to generate code specifically for a particular processor.\n+\n+You can run `rustc --print target-cpus` to see the valid options to pass\n+here. Additionally, `native` can be passed to use the processor of the host\n+machine.\n+\n+## target-feature\n+\n+Individual targets will support different features; this flag lets you control\n+enabling or disabling a feature.\n+\n+To see the valid options and an example of use, run `rustc --print\n+target-features`.\n+\n+## passes\n+\n+This flag can be used to add extra LLVM passes to the compilation.\n+\n+The list must be separated by spaces.\n+\n+## llvm-args\n+\n+This flag can be used to pass a list of arguments directly to LLVM.\n+\n+The list must be separated by spaces.\n+\n+## save-temps\n+\n+`rustc` will generate temporary files during compilation; normally it will\n+delete them after it's done with its work. This option will cause them to be\n+preserved instead of removed.\n+\n+## rpath\n+\n+This option allows you to set the value of\n+[`rpath`](https://en.wikipedia.org/wiki/Rpath).\n+\n+## overflow-checks\n+\n+This flag allows you to control the behavior of integer overflow. This flag\n+can be passed many options:\n+\n+* To turn overflow checks on: `y`, `yes`, or `on`.\n+* To turn overflow checks off: `n`, `no`, or `off`.\n+\n+## no-prepopulate-passes\n+\n+The pass manager comes pre-populated with a list of passes; this flag\n+ensures that list is empty.\n+\n+## no-vectorize-loops\n+\n+By default, `rustc` will attempt to [vectorize\n+loops](https://llvm.org/docs/Vectorizers.html#the-loop-vectorizer). This\n+flag will turn that behavior off.\n+\n+## no-vectorize-slp\n+\n+By default, `rustc` will attempt to vectorize loops using [superword-level\n+parallelism](https://llvm.org/docs/Vectorizers.html#the-slp-vectorizer). This\n+flag will turn that behavior off.\n+\n+## soft-float\n+\n+This option will make `rustc` generate code using \"soft floats.\" By default,\n+a lot of hardware supports floating point instructions, and so the code generated\n+will take advantage of this. \"soft floats\" emulate floating point instructions\n+in software.\n+\n+## prefer-dynamic\n+\n+By default, `rustc` prefers to statically link dependencies. This option will\n+make it use dynamic linking instead.\n+\n+## no-integrated-as\n+\n+LLVM comes with an internal assembler; this option will let you use an\n+external assembler instead.\n+\n+## no-redzone\n+\n+This flag allows you to disable [the\n+red zone](https://en.wikipedia.org/wiki/Red_zone_\\(computing\\)). This flag can\n+be passed many options:\n+\n+* To enable the red zone: `y`, `yes`, or `on`.\n+* To disable it: `n`, `no`, or `off`.\n+\n+## relocation-model\n+\n+This option lets you choose which relocation model to use.\n+\n+To find the valid options for this flag, run `rustc --print relocation-models`.\n+\n+## code-model=val\n+\n+This option lets you choose which code model to use.\n+\n+To find the valid options for this flag, run `rustc --print code-models`.\n+\n+## metadata\n+\n+This option allows you to control the metadata used for symbol mangling.\n+\n+## extra-filename\n+\n+This option allows you to put extra data in each output filename.\n+\n+## codegen-units\n+\n+This flag lets you control how many threads are used when doing\n+code generation.\n+\n+Increasing paralellism may speed up compile times, but may also\n+produce slower code.\n+\n+## remark\n+\n+This flag lets you print remarks for these optimization passes.\n+\n+The list of passes should be separated by spaces.\n+\n+`all` will remark on every pass.\n+\n+## no-stack-check\n+\n+This option is deprecated and does nothing.\n+\n+## debuginfo\n+\n+This flag lets you control debug information:\n+\n+* `0`: no debug info at all\n+* `1`: line tables only\n+* `2`: full debug info\n+\n+## opt-level\n+\n+This flag lets you control the optimization level.\n+\n+* `0`: no optimizations\n+* `1`: basic optimizations\n+* `2`: some optimizations\n+* `3`: all optimizations\n+* `s`: optimize for binary size\n+* `z`: optimize for binary size, but also turn off loop vectorization.\n+\n+## debug-assertions\n+\n+This flag lets you turn `cfg(debug_assertions)` on or off.\n+\n+## inline-threshold\n+\n+This option lets you set the threshold for inlining a function.\n+\n+The default is 225.\n+\n+## panic\n+\n+This option lets you control what happens when the code panics.\n+\n+* `abort`: terminate the process upon panic\n+* `unwind`: unwind the stack upon panic\n+\n+## incremental\n+\n+This flag allows you to enable incremental compilation."}, {"sha": "e2b001832fe31f5e6872e18961168123e5890a74", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,116 @@\n+# Command-line arguments\n+\n+Here's a list of command-line arguments to `rustc` and what they do.\n+\n+## `-h`/`--help`: get help\n+\n+This flag will print out help information for `rustc`.\n+\n+## `--cfg`: configure the compilation environment\n+\n+This flag can turn on or off various `#[cfg]` settings.\n+\n+## `-L`: add a directory to the library search path\n+\n+When looking for external crates, a directory passed to this flag will be searched.\n+\n+## `-l`: link the generated crate to a native library\n+\n+This flag allows you to specify linking to a specific native library when building\n+a crate.\n+\n+## `--crate-type`: a list of types of crates for the compiler to emit\n+\n+This instructs `rustc` on which crate type to build.\n+\n+## `--crate-name`: specify the name of the crate being built\n+\n+This informs `rustc` of the name of your crate.\n+\n+## `--emit`: emit output other than a crate\n+\n+Instead of producing a crate, this flag can print out things like the assembly or LLVM-IR.\n+\n+## `--print`: print compiler information\n+\n+This flag prints out various information about the compiler.\n+\n+## `-g`: include debug information\n+\n+A synonym for `-C debug-level=2`.\n+\n+## `-O`: optimize your code\n+\n+A synonym for `-C opt-level=2`.\n+\n+## `-o`: filename of the output\n+\n+This flag controls the output filename.\n+\n+## `--out-dir`: directory to write the output in\n+\n+The outputted crate will be written to this directory.\n+\n+## `--explain`: provide a detailed explanation of an error message\n+\n+Each error of `rustc`'s comes with an error code; this will print\n+out a longer explanation of a given error.\n+\n+## `--test`: build a test harness\n+\n+When compiling this crate, `rustc` will ignore your `main` function\n+and instead produce a test harness.\n+\n+## `--target`: select a target triple to build\n+\n+This controls which [target](targets/index.html) to produce.\n+\n+## `-W`: set lint warnings\n+\n+This flag will set which lints should be set to the [warn level](lints/levels.html#warn).\n+\n+## `-A`: set lint allowed\n+\n+This flag will set which lints should be set to the [allow level](lints/levels.html#allow).\n+\n+## `-D`: set lint denied\n+\n+This flag will set which lints should be set to the [deny level](lints/levels.html#deny).\n+\n+## `-F`: set lint forbidden\n+\n+This flag will set which lints should be set to the [forbid level](lints/levels.html#forbid).\n+\n+## `--cap-lints`: set the most restrictive lint level\n+\n+This flag lets you 'cap' lints, for more, [see here](lints/levels.html#capping-lints).\n+\n+## `-C`/`--codegen`: code generation options\n+\n+This flag will allow you to set [codegen options](codegen-options/index.html).\n+\n+## `-V`/`--version`: print a version\n+\n+This flag will print out `rustc`'s version.\n+\n+## `-v`/`--verbose`: use verbose output\n+\n+This flag, when combined with other flags, makes them produce extra output.\n+\n+## `--extern`: specify where an external library is located\n+\n+This flag allows you to pass the name and location of an external crate that will\n+be linked into the crate you're buildling.\n+\n+## `--sysroot`: Override the system root\n+\n+The \"sysroot\" is where `rustc` looks for the crates that come with the Rust\n+distribution; this flag allows that to be overridden.\n+\n+## `--error-format`: control how errors are produced\n+\n+This flag lets you control the format of errors.\n+\n+## `--color`: configure coloring of output\n+\n+This flag lets you control color settings of the output."}, {"sha": "fcb8e6b27dbf0d9d56522df277ee0b20778eb42d", "filename": "src/doc/rustc/src/contributing.md", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Fcontributing.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Fcontributing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcontributing.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,6 @@\n+# Contributing to rustc\n+\n+We'd love to have your help improving `rustc`! To that end, we've written [a\n+whole book](https://rust-lang-nursery.github.io/rustc-guide/) on its\n+internals, how it works, and how to get started working on it. To learn\n+more, you'll want to check that out.\n\\ No newline at end of file"}, {"sha": "46b717f3387d2ce95cb4c0d4d7f25ed0c1deac78", "filename": "src/doc/rustc/src/lints/groups.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,29 @@\n+# Lint Groups\n+\n+`rustc` has the concept of a \"lint group\", where you can toggle several warnings\n+through one name.\n+\n+For example, the `nonstandard-style` lint sets `non-camel-case-types`,\n+`non-snake-case`, and `non-upper-case-globals` all at once. So these are\n+equivalent:\n+\n+```bash\n+$ rustc -D nonstandard-style\n+$ rustc -D non-camel-case-types -D non-snake-case -D non-upper-case-globals\n+```\n+\n+Here's a list of each lint group, and the lints that they are made up of:\n+\n+| group               | description                                                   | lints                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n+|---------------------|---------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| nonstandard-style   | Violation of standard naming conventions                      | non-camel-case-types, non-snake-case, non-upper-case-globals                                                                                                                                                                                                                                                                                                                                                                                                                           |\n+| warnings            | all lints that would be issuing warnings                      | all lints that would be issuing warnings                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n+| edition-2018        | Lints that will be turned into errors in Rust 2018            | tyvar-behind-raw-pointer                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n+| rust-2018-idioms    | Lints to nudge you toward idiomatic features of Rust 2018     | bare-trait-object, unreachable-pub                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n+| unused              | These lints detect things being declared but not used         | unused-imports, unused-variables, unused-assignments, dead-code, unused-mut, unreachable-code, unreachable-patterns, unused-must-use, unused-unsafe, path-statements, unused-attributes, unused-macros, unused-allocation, unused-doc-comment, unused-extern-crates, unused-features, unused-parens                                                                                                                                                                                    |\n+| future-incompatible | Lints that detect code that has future-compatibility problems | private-in-public, pub-use-of-private-extern-crate, patterns-in-fns-without-body, safe-extern-statics, invalid-type-param-default, legacy-directory-ownership, legacy-imports, legacy-constructor-visibility, missing-fragment-specifier, illegal-floating-point-literal-pattern, anonymous-parameters, parenthesized-params-in-types-and-modules, late-bound-lifetime-arguments, safe-packed-borrows, incoherent-fundamental-impls, tyvar-behind-raw-pointer, unstable-name-collision |\n+\n+Additionally, there's a `bad-style` lint group that's a deprecated alias for `nonstandard-style`.\n+\n+Finally, you can also see the table above by invoking `rustc -W help`. This will give you the exact values for the specific\n+compiler you have installed.\n\\ No newline at end of file"}, {"sha": "bf345a24389d2bebc9d62b6777e64cf53a231e01", "filename": "src/doc/rustc/src/lints/index.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,28 @@\n+# Lints\n+\n+In software, a \"lint\" is a tool used to help improve your source code. The\n+Rust compiler contains a number of lints, and when it compiles your code, it will\n+also run the lints. These lints may produce a warning, an error, or nothing at all,\n+depending on how you've configured things.\n+\n+Here's a small example:\n+\n+```bash\n+$ cat main.rs\n+fn main() {\n+    let x = 5;\n+}\n+> rustc main.rs\n+warning: unused variable: `x`\n+ --> main.rs:2:9\n+  |\n+2 |     let x = 5;\n+  |         ^\n+  |\n+  = note: #[warn(unused_variables)] on by default\n+  = note: to avoid this warning, consider using `_x` instead\n+```\n+\n+This is the `unused_variables` lint, and it tells you that you've introduced\n+a variable that you don't use in your code. That's not *wrong*, so it's not\n+an error, but it might be a bug, so you get a warning."}, {"sha": "19bb6707d2285ffe357011e4a6f4796d6703a60b", "filename": "src/doc/rustc/src/lints/levels.md", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,252 @@\n+# Lint levels\n+\n+In `rustc`, lints are divided into four *levels*:\n+\n+1. allow\n+2. warn\n+3. deny\n+4. forbid\n+\n+Each lint has a default level (explained in the lint listing later in this\n+chapter), and the compiler has a default warning level. First, let's explain\n+what these levels mean, and then we'll talk about configuration.\n+\n+## allow\n+\n+These lints exist, but by default, do nothing. For example, consider this\n+source:\n+\n+```rust\n+pub fn foo() {}\n+```\n+\n+Compiling this file produces no warnings:\n+\n+```bash\n+$ rustc lib.rs --crate-type=lib\n+$\n+```\n+\n+But this code violates the `missing_docs` lint.\n+\n+These lints exist mostly to be manually turned on via configuration, as we'll\n+talk about later in this section.\n+\n+## warn\n+\n+The 'warn' lint level will produce a warning if you violate the lint. For example,\n+this code runs afoul of the `unused_variable` lint:\n+\n+```rust\n+pub fn foo() {\n+    let x = 5;\n+}\n+```\n+\n+This will produce this warning:\n+\n+```console\n+$ rustc lib.rs --crate-type=lib\n+warning: unused variable: `x`\n+ --> lib.rs:2:9\n+  |\n+2 |     let x = 5;\n+  |         ^\n+  |\n+  = note: #[warn(unused_variables)] on by default\n+  = note: to avoid this warning, consider using `_x` instead\n+```\n+\n+## deny\n+\n+A 'deny' lint produces an error if you violate it. For example, this code\n+runs into the `exceeding_bitshifts` lint.\n+\n+```rust,ignore\n+fn main() {\n+    100u8 << 10;\n+}\n+```\n+\n+```bash\n+> rustc main.rs\n+error: bitshift exceeds the type's number of bits\n+ --> main.rs:2:13\n+  |\n+2 |     100u8 << 10;\n+  |     ^^^^^^^^^^^\n+  |\n+  = note: #[deny(exceeding_bitshifts)] on by default\n+```\n+\n+What's the difference between an error from a lint and a regular old error?\n+Lints are configurable via levels, so in a similar way to 'allow' lints,\n+warnings that are 'deny' by default let you allow them. Similarly, you may\n+wish to set up a lint that is `warn` by default to produce an error instead.\n+This lint level gives you that.\n+\n+## forbid\n+\n+'forbid' is a special lint level that's stronger than 'deny'. It's the same\n+as 'deny' in that a lint at this level will produce an error, but unlike the\n+'deny' level, the 'forbid' level can not be overridden to be anything lower\n+than an error.\n+\n+## Configuring warning levels\n+\n+Remember our `missing_docs` example from the 'allow' lint level?\n+\n+```bash\n+$ cat lib.rs\n+pub fn foo() {}\n+$ rustc lib.rs --crate-type=lib\n+$\n+```\n+\n+We can configure this lint to operate at a higher level, both with\n+compiler flags, as well as with an attribute in the source code.\n+\n+You can also \"cap\" lints so that the compiler can choose to ignore\n+certain lint levels. We'll talk about that last.\n+\n+### Via compiler flag\n+\n+The `-A`, `-W`, `-D`, and `-F` flags let you turn one or more lints\n+into allowed, warning, deny, or forbid levels, like this:\n+\n+```bash\n+$ rustc lib.rs --crate-type=lib -W missing-docs\n+warning: missing documentation for crate\n+ --> lib.rs:1:1\n+  |\n+1 | pub fn foo() {}\n+  | ^^^^^^^^^^^^\n+  |\n+  = note: requested on the command line with `-W missing-docs`\n+\n+warning: missing documentation for a function\n+ --> lib.rs:1:1\n+  |\n+1 | pub fn foo() {}\n+  | ^^^^^^^^^^^^\n+> rustc lib.rs --crate-type=lib -D missing-docs\n+error: missing documentation for crate\n+ --> lib.rs:1:1\n+  |\n+1 | pub fn foo() {}\n+  | ^^^^^^^^^^^^\n+  |\n+  = note: requested on the command line with `-D missing-docs`\n+\n+error: missing documentation for a function\n+ --> lib.rs:1:1\n+  |\n+1 | pub fn foo() {}\n+  | ^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+```\n+\n+You can also pass each flag more than once for changing multiple lints:\n+\n+```bash\n+rustc lib.rs --crate-type=lib -D missing-docs -D unused-variables\n+```\n+\n+And of course, you can mix these four flags together:\n+\n+```bash\n+rustc lib.rs --crate-type=lib -D missing-docs -A unused-variables\n+```\n+\n+### Via an attribute\n+\n+You can also modify the lint level with a crate-wide attribute:\n+\n+```bash\n+> cat lib.rs\n+#![warn(missing_docs)]\n+\n+pub fn foo() {}\n+$ rustc lib.rs --crate-type=lib\n+warning: missing documentation for crate\n+ --> lib.rs:1:1\n+  |\n+1 | / #![warn(missing_docs)]\n+2 | |\n+3 | | pub fn foo() {}\n+  | |_______________^\n+  |\n+note: lint level defined here\n+ --> lib.rs:1:9\n+  |\n+1 | #![warn(missing_docs)]\n+  |         ^^^^^^^^^^^^\n+\n+warning: missing documentation for a function\n+ --> lib.rs:3:1\n+  |\n+3 | pub fn foo() {}\n+  | ^^^^^^^^^^^^\n+```\n+\n+All four, `warn`, `allow`, `deny`, and `forbid` all work this way.\n+\n+You can also pass in multiple lints per attribute:\n+\n+```rust\n+#![warn(missing_docs, unused_variables)]\n+\n+pub fn foo() {}\n+```\n+\n+And use multiple attributes together:\n+\n+```rust\n+#![warn(missing_docs)]\n+#![deny(unused_variables)]\n+\n+pub fn foo() {}\n+```\n+\n+### Capping lints\n+\n+`rustc` supports a flag, `--cap-lints LEVEL` that sets the \"lint cap level.\"\n+This is the maximum level for all lints. So for example, if we take our\n+code sample from the \"deny\" lint level above:\n+\n+```rust,ignore\n+fn main() {\n+    100u8 << 10;\n+}\n+```\n+\n+And we compile it, capping lints to warn:\n+\n+```bash\n+$ rustc lib.rs --cap-lints warn\n+warning: bitshift exceeds the type's number of bits\n+ --> lib.rs:2:5\n+  |\n+2 |     100u8 << 10;\n+  |     ^^^^^^^^^^^\n+  |\n+  = note: #[warn(exceeding_bitshifts)] on by default\n+\n+warning: this expression will panic at run-time\n+ --> lib.rs:2:5\n+  |\n+2 |     100u8 << 10;\n+  |     ^^^^^^^^^^^ attempt to shift left with overflow\n+```\n+\n+It now only warns, rather than errors. We can go further and allow all lints:\n+\n+```bash\n+$ rustc lib.rs --cap-lints allow\n+$\n+```\n+\n+This feature is used heavily by Cargo; it will pass `--cap-lints allow` when\n+compiling your dependencies, so that if they have any warnings, they do not\n+pollute the output of your build."}, {"sha": "e1a3f96a6fe6e320c3001a12b8a9d579f45a8d14", "filename": "src/doc/rustc/src/lints/listing/allowed-by-default.md", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,453 @@\n+# Allowed-by-default lints\n+\n+These lints are all set to the 'allow' level by default. As such, they won't show up\n+unless you set them to a higher lint level with a flag or attribute.\n+\n+## anonymous-parameters\n+\n+This lint detects anonymous parameters. Some example code that triggers this lint:\n+\n+```rust\n+trait Foo {\n+    fn foo(usize);\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: use of deprecated anonymous parameter\n+ --> src/lib.rs:5:11\n+  |\n+5 |     fn foo(usize);\n+  |           ^\n+  |\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #41686 <https://github.com/rust-lang/rust/issues/41686>\n+```\n+\n+This syntax is mostly a historical accident, and can be worked around quite\n+easily:\n+\n+```rust\n+trait Foo {\n+    fn foo(_: usize);\n+}\n+```\n+\n+## bare-trait-object\n+\n+This lint suggests using `dyn Trait` for trait objects. Some example code\n+that triggers this lint:\n+\n+```rust\n+#![feature(dyn_trait)]\n+\n+trait Trait { }\n+\n+fn takes_trait_object(_: Box<Trait>) {\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: trait objects without an explicit `dyn` are deprecated\n+ --> src/lib.rs:7:30\n+  |\n+7 | fn takes_trait_object(_: Box<Trait>) {\n+  |                              ^^^^^ help: use `dyn`: `dyn Trait`\n+  |\n+```\n+\n+To fix it, do as the help message suggests:\n+\n+```rust\n+#![feature(dyn_trait)]\n+#![deny(bare_trait_object)]\n+\n+trait Trait { }\n+\n+fn takes_trait_object(_: Box<dyn Trait>) {\n+}\n+```\n+\n+## box-pointers\n+\n+This lints use of the Box type. Some example code that triggers this lint:\n+\n+```rust\n+struct Foo {\n+    x: Box<isize>,\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: type uses owned (Box type) pointers: std::boxed::Box<isize>\n+ --> src/lib.rs:6:5\n+  |\n+6 |     x: Box<isize> //~ ERROR type uses owned\n+  |     ^^^^^^^^^^^^^\n+  |\n+```\n+\n+This lint is mostly historical, and not particularly useful. `Box<T>` used to\n+be built into the language, and the only way to do heap allocation. Today's\n+Rust can call into other allocators, etc.\n+\n+## elided-lifetime-in-path\n+\n+This lint detects the use of hidden lifetime parameters. Some example code\n+that triggers this lint:\n+\n+```rust\n+struct Foo<'a> {\n+    x: &'a u32\n+}\n+\n+fn foo(x: &Foo) {\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: hidden lifetime parameters are deprecated, try `Foo<'_>`\n+ --> src/lib.rs:5:12\n+  |\n+5 | fn foo(x: &Foo) {\n+  |            ^^^\n+  |\n+```\n+\n+Lifetime elision elides this lifetime, but that is being deprecated.\n+\n+## missing-copy-implementations\n+\n+This lint detects potentially-forgotten implementations of `Copy`. Some\n+example code that triggers this lint:\n+\n+```rust\n+pub struct Foo {\n+    pub field: i32\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: type could implement `Copy`; consider adding `impl Copy`\n+ --> src/main.rs:3:1\n+  |\n+3 | / pub struct Foo { //~ ERROR type could implement `Copy`; consider adding `impl Copy`\n+4 | |     pub field: i32\n+5 | | }\n+  | |_^\n+  |\n+```\n+\n+You can fix the lint by deriving `Copy`.\n+\n+This lint is set to 'allow' because this code isn't bad; it's common to write\n+newtypes like this specifically so that a `Copy` type is no longer `Copy`.\n+\n+## missing-debug-implementations\n+\n+This lint detects missing implementations of `fmt::Debug`. Some example code\n+that triggers this lint:\n+\n+```rust\n+pub struct Foo;\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: type does not implement `fmt::Debug`; consider adding #[derive(Debug)] or a manual implementation\n+ --> src/main.rs:3:1\n+  |\n+3 | pub struct Foo;\n+  | ^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+You can fix the lint by deriving `Debug`.\n+\n+## missing-docs\n+\n+This lint detects missing documentation for public items. Some example code\n+that triggers this lint:\n+\n+```rust\n+pub fn foo() {}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: missing documentation for crate\n+ --> src/main.rs:1:1\n+  |\n+1 | / #![deny(missing_docs)]\n+2 | |\n+3 | | pub fn foo() {}\n+4 | |\n+5 | | fn main() {}\n+  | |____________^\n+  |\n+\n+error: missing documentation for a function\n+ --> src/main.rs:3:1\n+  |\n+3 | pub fn foo() {}\n+  | ^^^^^^^^^^^^\n+\n+```\n+\n+To fix the lint, add documentation to all items.\n+\n+## single-use-lifetime\n+\n+This lint detects lifetimes that are only used once. Some example code that\n+triggers this lint:\n+\n+```rust\n+struct Foo<'x> {\n+    x: &'x u32\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: lifetime name `'x` only used once\n+ --> src/main.rs:3:12\n+  |\n+3 | struct Foo<'x> {\n+  |            ^^\n+  |\n+```\n+\n+## trivial-casts\n+\n+This lint detects trivial casts which could be removed. Some example code\n+that triggers this lint:\n+\n+```rust\n+let x: &u32 = &42;\n+let _ = x as *const u32;\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: trivial cast: `&u32` as `*const u32`. Cast can be replaced by coercion, this might require type ascription or a temporary variable\n+ --> src/main.rs:5:13\n+  |\n+5 |     let _ = x as *const u32;\n+  |             ^^^^^^^^^^^^^^^\n+  |\n+note: lint level defined here\n+ --> src/main.rs:1:9\n+  |\n+1 | #![deny(trivial_casts)]\n+  |         ^^^^^^^^^^^^^\n+```\n+\n+## trivial-numeric-casts\n+\n+This lint detects trivial casts of numeric types which could be removed. Some\n+example code that triggers this lint:\n+\n+```rust\n+let x = 42i32 as i32;\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: trivial numeric cast: `i32` as `i32`. Cast can be replaced by coercion, this might require type ascription or a temporary variable\n+ --> src/main.rs:4:13\n+  |\n+4 |     let x = 42i32 as i32;\n+  |             ^^^^^^^^^^^^\n+  |\n+```\n+\n+## unreachable-pub\n+\n+This lint triggers for `pub` items not reachable from the crate root. Some\n+example code that triggers this lint:\n+\n+```rust\n+mod foo {\n+    pub mod bar {\n+        \n+    }\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: unreachable `pub` item\n+ --> src/main.rs:4:5\n+  |\n+4 |     pub mod bar {\n+  |     ---^^^^^^^^\n+  |     |\n+  |     help: consider restricting its visibility: `pub(crate)`\n+  |\n+```\n+\n+## unsafe-code\n+\n+This lint catches usage of `unsafe` code. Some example code that triggers this lint:\n+\n+```rust\n+fn main() {\n+    unsafe {\n+\n+    }\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: usage of an `unsafe` block\n+ --> src/main.rs:4:5\n+  |\n+4 | /     unsafe {\n+5 | |         \n+6 | |     }\n+  | |_____^\n+  |\n+```\n+\n+## unstable-features\n+\n+This lint is deprecated and no longer used.\n+\n+## unused-extern-crates\n+\n+This lint guards against `extern crate` items that are never used. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+extern crate semver;\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: unused extern crate\n+ --> src/main.rs:3:1\n+  |\n+3 | extern crate semver;\n+  | ^^^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## unused-import-braces\n+\n+This lint catches unnecessary braces around an imported item. Some example\n+code that triggers this lint:\n+\n+```rust\n+use test::{A};\n+\n+pub mod test {\n+    pub struct A;\n+}\n+# fn main() {}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: braces around A is unnecessary\n+ --> src/main.rs:3:1\n+  |\n+3 | use test::{A};\n+  | ^^^^^^^^^^^^^^\n+  |\n+```\n+\n+To fix it, `use test::A;`\n+\n+## unused-qualifications\n+\n+This lint detects unnecessarily qualified names. Some example code that triggers this lint:\n+\n+```rust\n+mod foo {\n+    pub fn bar() {}\n+}\n+\n+fn main() {\n+    use foo::bar;\n+    foo::bar();\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: unnecessary qualification\n+ --> src/main.rs:9:5\n+  |\n+9 |     foo::bar();\n+  |     ^^^^^^^^\n+  |\n+```\n+\n+You can call `bar()` directly, without the `foo::`.\n+\n+## unused-results\n+\n+This lint checks for the unused result of an expression in a statement. Some\n+example code that triggers this lint:\n+\n+```rust,no_run\n+fn foo<T>() -> T { panic!() }\n+\n+fn main() {\n+    foo::<usize>();\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: unused result\n+ --> src/main.rs:6:5\n+  |\n+6 |     foo::<usize>();\n+  |     ^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## variant-size-differences\n+\n+This lint detects enums with widely varying variant sizes. Some example code that triggers this lint:\n+\n+```rust\n+enum En {\n+    V0(u8),\n+    VBig([u8; 1024]),\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: enum variant is more than three times larger (1024 bytes) than the next largest\n+ --> src/main.rs:5:5\n+  |\n+5 |     VBig([u8; 1024]),   //~ ERROR variant is more than three times larger\n+  |     ^^^^^^^^^^^^^^^^\n+  |\n+```"}, {"sha": "e7ec6af8be1e3752a89a2a1e5bc0eb8f2e05151f", "filename": "src/doc/rustc/src/lints/listing/deny-by-default.md", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,241 @@\n+# Deny-by-default lints\n+\n+These lints are all set to the 'deny' level by default.\n+\n+## exceeding-bitshifts\n+\n+This lint detects that a shift exceeds the type's number of bits. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+1_i32 << 32;\n+```\n+\n+This will produce:\n+\n+```text\n+error: bitshift exceeds the type's number of bits\n+ --> src/main.rs:2:5\n+  |\n+2 |     1_i32 << 32;\n+  |     ^^^^^^^^^^^\n+  |\n+```\n+\n+## invalid-type-param-default\n+\n+This lint detects type parameter default erroneously allowed in invalid location. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+fn foo<T=i32>(t: T) {}\n+```\n+\n+This will produce:\n+\n+```text\n+error: defaults for type parameters are only allowed in `struct`, `enum`, `type`, or `trait` definitions.\n+ --> src/main.rs:4:8\n+  |\n+4 | fn foo<T=i32>(t: T) {}\n+  |        ^\n+  |\n+  = note: #[deny(invalid_type_param_default)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #36887 <https://github.com/rust-lang/rust/issues/36887>\n+```\n+\n+## legacy-constructor-visibility\n+\n+[RFC 1506](https://github.com/rust-lang/rfcs/blob/master/text/1506-adt-kinds.md) modified some\n+visibility rules, and changed the visibility of struct constructors. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+mod m {\n+    pub struct S(u8);\n+    \n+    fn f() {\n+        // this is trying to use S from the 'use' line, but becuase the `u8` is\n+        // not pub, it is private\n+        ::S;\n+    }\n+}\n+\n+use m::S;\n+```\n+\n+This will produce:\n+\n+```text\n+error: private struct constructors are not usable through re-exports in outer modules\n+ --> src/main.rs:5:9\n+  |\n+5 |         ::S;\n+  |         ^^^\n+  |\n+  = note: #[deny(legacy_constructor_visibility)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #39207 <https://github.com/rust-lang/rust/issues/39207>\n+```\n+\n+\n+## legacy-directory-ownership\n+\n+The legacy_directory_ownership warning is issued when\n+\n+* There is a non-inline module with a #[path] attribute (e.g. #[path = \"foo.rs\"] mod bar;),\n+* The module's file (\"foo.rs\" in the above example) is not named \"mod.rs\", and\n+* The module's file contains a non-inline child module without a #[path] attribute.\n+\n+The warning can be fixed by renaming the parent module to \"mod.rs\" and moving\n+it into its own directory if appropriate.\n+\n+## legacy-imports\n+\n+This lint detects names that resolve to ambiguous glob imports. Some example\n+code that triggers this lint:\n+\n+```rust,ignore\n+pub struct Foo;\n+\n+mod bar {\n+    struct Foo;\n+\n+    mod baz {\n+        use *;\n+        use bar::*;\n+        fn f(_: Foo) {}\n+    }\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+error: `Foo` is ambiguous\n+ --> src/main.rs:9:17\n+  |\n+7 |         use *;\n+  |             - `Foo` could refer to the name imported here\n+8 |         use bar::*;\n+  |             ------ `Foo` could also refer to the name imported here\n+9 |         fn f(_: Foo) {}\n+  |                 ^^^\n+  |\n+  = note: #[deny(legacy_imports)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #38260 <https://github.com/rust-lang/rust/issues/38260>\n+```\n+\n+\n+## missing-fragment-specifier\n+\n+The missing_fragment_specifier warning is issued when an unused pattern in a\n+`macro_rules!` macro definition has a meta-variable (e.g. `$e`) that is not\n+followed by a fragment specifier (e.g. `:expr`).\n+\n+This warning can always be fixed by removing the unused pattern in the\n+`macro_rules!` macro definition.\n+\n+## mutable-transmutes\n+\n+This lint catches transmuting from `&T` to `&mut T` becuase it is undefined\n+behavior. Some example code that triggers this lint:\n+\n+```rust,ignore\n+unsafe {\n+    let y = std::mem::transmute::<&i32, &mut i32>(&5);\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+error: mutating transmuted &mut T from &T may cause undefined behavior, consider instead using an UnsafeCell\n+ --> src/main.rs:3:17\n+  |\n+3 |         let y = std::mem::transmute::<&i32, &mut i32>(&5);\n+  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+\n+## no-mangle-const-items\n+\n+This lint detects any `const` items with the `#[no_mangle]` attribute.\n+Constants do not have their symbols exported, and therefore, this probably\n+means you meant to use a `static`, not a `const`. Some example code that\n+triggers this lint:\n+\n+```rust,ignore\n+#[no_mangle]\n+const FOO: i32 = 5;\n+```\n+\n+This will produce:\n+\n+```text\n+error: const items should never be #[no_mangle]\n+ --> src/main.rs:3:1\n+  |\n+3 | const FOO: i32 = 5;\n+  | -----^^^^^^^^^^^^^^\n+  | |\n+  | help: try a static value: `pub static`\n+  |\n+```\n+\n+## parenthesized-params-in-types-and-modules\n+\n+This lint detects incorrect parentheses. Some example code that triggers this\n+lint:\n+\n+```rust,ignore\n+let x = 5 as usize();\n+```\n+\n+This will produce:\n+\n+```text\n+error: parenthesized parameters may only be used with a trait\n+ --> src/main.rs:2:21\n+  |\n+2 |   let x = 5 as usize();\n+  |                     ^^\n+  |\n+  = note: #[deny(parenthesized_params_in_types_and_modules)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #42238 <https://github.com/rust-lang/rust/issues/42238>\n+```\n+\n+To fix it, remove the `()`s.\n+\n+## pub-use-of-private-extern-crate\n+\n+This lint detects a specific situation of re-exporting a private `extern crate`;\n+\n+## safe-extern-statics\n+\n+In older versions of Rust, there was a soundness issue where `extern static`s were allowed\n+to be accessed in safe code. This lint now catches and denies this kind of code.\n+\n+## unknown-crate-types\n+\n+This lint detects an unknown crate type found in a `#[crate_type]` directive. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+#![crate_type=\"lol\"]\n+```\n+\n+This will produce:\n+\n+```text\n+error: invalid `crate_type` value\n+ --> src/lib.rs:1:1\n+  |\n+1 | #![crate_type=\"lol\"]\n+  | ^^^^^^^^^^^^^^^^^^^^\n+  |\n+```"}, {"sha": "18cd2fe32a3cc75707effe23e285c4d187d5373f", "filename": "src/doc/rustc/src/lints/listing/index.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Findex.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,5 @@\n+# Lint listing\n+\n+This section lists out all of the lints, grouped by their default lint levels.\n+\n+You can also see this list by running `rustc -W help`.\n\\ No newline at end of file"}, {"sha": "1171f75caa1fdf69ac32e2c02ee562a85df2f7a4", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "added", "additions": 1039, "deletions": 0, "changes": 1039, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,1039 @@\n+# Warn-by-default lints\n+\n+These lints are all set to the 'warn' level by default.\n+\n+## const-err\n+\n+This lint detects an erroneous expression while doing constant evaluation. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+let b = 200u8 + 200u8;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: attempt to add with overflow\n+ --> src/main.rs:2:9\n+  |\n+2 | let b = 200u8 + 200u8;\n+  |         ^^^^^^^^^^^^^\n+  |\n+```\n+\n+## dead-code\n+\n+This lint detects detect unused, unexported items. Some\n+example code that triggers this lint:\n+\n+```rust\n+fn foo() {}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: function is never used: `foo`\n+ --> src/lib.rs:2:1\n+  |\n+2 | fn foo() {}\n+  | ^^^^^^^^\n+  |\n+```\n+\n+## deprecated\n+\n+This lint detects detects use of deprecated items. Some\n+example code that triggers this lint:\n+\n+```rust\n+#[deprecated]\n+fn foo() {}\n+\n+fn bar() {\n+    foo();\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: use of deprecated item 'foo'\n+ --> src/lib.rs:7:5\n+  |\n+7 |     foo();\n+  |     ^^^\n+  |\n+```\n+\n+## illegal-floating-point-literal-pattern\n+\n+This lint detects floating-point literals used in patterns. Some example code\n+that triggers this lint:\n+\n+```rust\n+let x = 42.0;\n+\n+match x {\n+    5.0 => {},\n+    _ => {},\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: floating-point literals cannot be used in patterns\n+ --> src/main.rs:4:9\n+  |\n+4 |         5.0 => {},\n+  |         ^^^\n+  |\n+  = note: #[warn(illegal_floating_point_literal_pattern)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n+```\n+\n+## improper-ctypes\n+\n+This lint detects proper use of libc types in foreign modules. Some\n+example code that triggers this lint:\n+\n+```rust\n+extern \"C\" {\n+    static STATIC: String;\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: found struct without foreign-function-safe representation annotation in foreign module, consider adding a #[repr(C)] attribute to the type\n+ --> src/main.rs:2:20\n+  |\n+2 |     static STATIC: String;\n+  |                    ^^^^^^\n+  |\n+```\n+\n+## incoherent-fundamental-impls\n+\n+This lint detects potentially-conflicting impls that were erroneously allowed. Some\n+example code that triggers this lint:\n+\n+```rust\n+pub trait Trait1<X> {\n+    type Output;\n+}\n+\n+pub trait Trait2<X> {}\n+\n+pub struct A;\n+\n+impl<X, T> Trait1<X> for T where T: Trait2<X> {\n+    type Output = ();\n+}\n+\n+impl<X> Trait1<Box<X>> for A {\n+    type Output = i32;\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: conflicting implementations of trait `Trait1<std::boxed::Box<_>>` for type `A`: (E0119)\n+  --> src/main.rs:13:1\n+   |\n+9  | impl<X, T> Trait1<X> for T where T: Trait2<X> {\n+   | --------------------------------------------- first implementation here\n+...\n+13 | impl<X> Trait1<Box<X>> for A {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `A`\n+   |\n+   = note: #[warn(incoherent_fundamental_impls)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #46205 <https://github.com/rust-lang/rust/issues/46205>\n+   = note: downstream crates may implement trait `Trait2<std::boxed::Box<_>>` for type `A`\n+```\n+\n+## late-bound-lifetime-arguments\n+\n+This lint detects detects generic lifetime arguments in path segments with\n+late bound lifetime parameters. Some example code that triggers this lint:\n+\n+```rust\n+struct S;\n+\n+impl S {\n+    fn late<'a, 'b>(self, _: &'a u8, _: &'b u8) {}\n+}\n+\n+fn main() {\n+    S.late::<'static>(&0, &0);\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n+ --> src/main.rs:8:14\n+  |\n+4 |     fn late<'a, 'b>(self, _: &'a u8, _: &'b u8) {}\n+  |             -- the late bound lifetime parameter is introduced here\n+...\n+8 |     S.late::<'static>(&0, &0);\n+  |              ^^^^^^^\n+  |\n+  = note: #[warn(late_bound_lifetime_arguments)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #42868 <https://github.com/rust-lang/rust/issues/42868>\n+```\n+\n+## non-camel-case-types\n+\n+This lint detects types, variants, traits and type parameters that don't have\n+camel case names. Some example code that triggers this lint:\n+\n+```rust\n+struct s;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: type `s` should have a camel case name such as `S`\n+ --> src/main.rs:1:1\n+  |\n+1 | struct s;\n+  | ^^^^^^^^^\n+  |\n+```\n+\n+## non-shorthand-field-patterns\n+\n+This lint detects using `Struct { x: x }` instead of `Struct { x }` in a pattern. Some\n+example code that triggers this lint:\n+\n+```rust\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+\n+fn main() {\n+    let p = Point {\n+        x: 5,\n+        y: 5,\n+    };\n+\n+    match p {\n+        Point { x: x, y: y } => (),\n+    }\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: the `x:` in this pattern is redundant\n+  --> src/main.rs:14:17\n+   |\n+14 |         Point { x: x, y: y } => (),\n+   |                 --^^\n+   |                 |\n+   |                 help: remove this\n+   |\n+\n+warning: the `y:` in this pattern is redundant\n+  --> src/main.rs:14:23\n+   |\n+14 |         Point { x: x, y: y } => (),\n+   |                       --^^\n+   |                       |\n+   |                       help: remove this\n+\n+```\n+\n+## non-snake-case\n+\n+This lint detects variables, methods, functions, lifetime parameters and\n+modules that don't have snake case names. Some example code that triggers\n+this lint:\n+\n+```rust\n+let X = 5;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: variable `X` should have a snake case name such as `x`\n+ --> src/main.rs:2:9\n+  |\n+2 |     let X = 5;\n+  |         ^\n+  |\n+```\n+\n+## non-upper-case-globals\n+\n+This lint detects static constants that don't have uppercase identifiers.\n+Some example code that triggers this lint:\n+\n+```rust\n+static x: i32 = 5;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: static variable `x` should have an upper case name such as `X`\n+ --> src/main.rs:1:1\n+  |\n+1 | static x: i32 = 5;\n+  | ^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## no-mangle-generic-items\n+\n+This lint detects generic items must be mangled. Some\n+example code that triggers this lint:\n+\n+```rust\n+#[no_mangle]\n+fn foo<T>(t: T) {\n+\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: functions generic over types must be mangled\n+ --> src/main.rs:2:1\n+  |\n+1 |   #[no_mangle]\n+  |   ------------ help: remove this attribute\n+2 | / fn foo<T>(t: T) {\n+3 | |     \n+4 | | }\n+  | |_^\n+  |\n+```\n+\n+## overflowing-literals\n+\n+This lint detects literal out of range for its type. Some\n+example code that triggers this lint:\n+\n+```rust\n+let x: u8 = 1000;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: literal out of range for u8\n+ --> src/main.rs:2:17\n+  |\n+2 |     let x: u8 = 1000;\n+  |                 ^^^^\n+  |\n+```\n+\n+## path-statements\n+\n+This lint detects path statements with no effect. Some example code that\n+triggers this lint:\n+\n+```rust\n+let x = 42;\n+\n+x;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: path statement with no effect\n+ --> src/main.rs:3:5\n+  |\n+3 |     x;\n+  |     ^^\n+  |\n+```\n+\n+## patterns-in-fns-without-body\n+\n+This lint detects patterns in functions without body were that were\n+previously erroneously allowed. Some example code that triggers this lint:\n+\n+```rust\n+trait Trait {\n+    fn foo(mut arg: u8);\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: patterns aren't allowed in methods without bodies\n+ --> src/main.rs:2:12\n+  |\n+2 |     fn foo(mut arg: u8);\n+  |            ^^^^^^^\n+  |\n+  = note: #[warn(patterns_in_fns_without_body)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #35203 <https://github.com/rust-lang/rust/issues/35203>\n+```\n+\n+To fix this, remove the pattern; it can be used in the implementation without\n+being used in the definition. That is:\n+\n+```rust\n+trait Trait {\n+    fn foo(arg: u8);\n+}\n+\n+impl Trait for i32 {\n+    fn foo(mut arg: u8) {\n+\n+    }\n+}\n+```\n+\n+## plugin-as-library\n+\n+This lint detects when compiler plugins are used as ordinary library in\n+non-plugin crate. Some example code that triggers this lint:\n+\n+```rust,ignore\n+#![feature(plugin)]\n+#![plugin(macro_crate_test)]\n+\n+extern crate macro_crate_test;\n+```\n+\n+## private-in-public\n+\n+This lint detects detect private items in public interfaces not caught by the old implementation. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+pub trait Trait {\n+    type A;\n+}\n+\n+pub struct S;\n+\n+mod foo {\n+    struct Z;\n+\n+    impl ::Trait for ::S {\n+        type A = Z;\n+    }\n+}\n+# fn main() {}\n+```\n+\n+This will produce:\n+\n+```text\n+error[E0446]: private type `foo::Z` in public interface\n+  --> src/main.rs:11:9\n+   |\n+11 |         type A = Z;\n+   |         ^^^^^^^^^^^ can't leak private type\n+```\n+\n+## private-no-mangle-fns\n+\n+This lint detects functions marked `#[no_mangle]` that are also private.\n+Given that private functions aren't exposed publicly, and `#[no_mangle]`\n+controls the public symbol, this combination is erroneous. Some example code\n+that triggers this lint:\n+\n+```rust\n+#[no_mangle]\n+fn foo() {}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: function is marked #[no_mangle], but not exported\n+ --> src/main.rs:2:1\n+  |\n+2 | fn foo() {}\n+  | -^^^^^^^^^^\n+  | |\n+  | help: try making it public: `pub`\n+  |\n+```\n+\n+To fix this, either make it public or remove the `#[no_mangle]`.\n+\n+## private-no-mangle-statics\n+\n+This lint detects any statics marked `#[no_mangle]` that are private.\n+Given that private statics aren't exposed publicly, and `#[no_mangle]`\n+controls the public symbol, this combination is erroneous. Some example code\n+that triggers this lint:\n+\n+```rust\n+#[no_mangle]\n+static X: i32 = 4;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: static is marked #[no_mangle], but not exported\n+ --> src/main.rs:2:1\n+  |\n+2 | static X: i32 = 4;\n+  | -^^^^^^^^^^^^^^^^^\n+  | |\n+  | help: try making it public: `pub`\n+  |\n+```\n+\n+To fix this, either make it public or remove the `#[no_mangle]`.\n+\n+## renamed-and-removed-lints\n+\n+This lint detects lints that have been renamed or removed. Some\n+example code that triggers this lint:\n+\n+```rust\n+#![deny(raw_pointer_derive)]\n+```\n+\n+This will produce:\n+\n+```text\n+warning: lint raw_pointer_derive has been removed: using derive with raw pointers is ok\n+ --> src/main.rs:1:9\n+  |\n+1 | #![deny(raw_pointer_derive)]\n+  |         ^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+To fix this, either remove the lint or use the new name.\n+\n+## safe-packed-borrows\n+\n+This lint detects borrowing a field in the interior of a packed structure\n+with alignment other than 1. Some example code that triggers this lint:\n+\n+```rust\n+#[repr(packed)]\n+pub struct Unaligned<T>(pub T);\n+\n+pub struct Foo {\n+    start: u8,\n+    data: Unaligned<u32>,\n+}\n+\n+fn main() {\n+    let x = Foo { start: 0, data: Unaligned(1) };\n+    let y = &x.data.0;\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: borrow of packed field requires unsafe function or block (error E0133)\n+  --> src/main.rs:11:13\n+   |\n+11 |     let y = &x.data.0; \n+   |             ^^^^^^^^^\n+   |\n+   = note: #[warn(safe_packed_borrows)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+```\n+\n+## stable-features\n+\n+This lint detects a `#[feature]` attribute that's since been made stable. Some\n+example code that triggers this lint:\n+\n+```rust\n+#![feature(test_accepted_feature)]\n+```\n+\n+This will produce:\n+\n+```text\n+warning: this feature has been stable since 1.0.0. Attribute no longer needed\n+ --> src/main.rs:1:12\n+  |\n+1 | #![feature(test_accepted_feature)]\n+  |            ^^^^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+To fix, simply remove the `#![feature]` attribute, as it's no longer needed.\n+\n+## type-alias-bounds\n+\n+This lint detects bounds in type aliases. These are not currently enforced.\n+Some example code that triggers this lint:\n+\n+```rust\n+type SendVec<T: Send> = Vec<T>;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: type alias is never used: `SendVec`\n+ --> src/main.rs:1:1\n+  |\n+1 | type SendVec<T: Send> = Vec<T>;\n+  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## tyvar-behind-raw-pointer\n+\n+This lint detects raw pointer to an inference variable. Some\n+example code that triggers this lint:\n+\n+```rust\n+let data = std::ptr::null();\n+let _ = &data as *const *const ();\n+\n+if data.is_null() {}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: type annotations needed\n+ --> src/main.rs:4:13\n+  |\n+4 |     if data.is_null() {}\n+  |             ^^^^^^^\n+  |\n+  = note: #[warn(tyvar_behind_raw_pointer)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+  = note: for more information, see issue #46906 <https://github.com/rust-lang/rust/issues/46906>\n+```\n+\n+## unconditional-recursion\n+\n+This lint detects functions that cannot return without calling themselves.\n+Some example code that triggers this lint:\n+\n+```rust\n+fn foo() {\n+    foo();\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: function cannot return without recurring\n+ --> src/main.rs:1:1\n+  |\n+1 | fn foo() {\n+  | ^^^^^^^^ cannot return without recurring\n+2 |     foo();\n+  |     ----- recursive call site\n+  |\n+```\n+\n+## unions-with-drop-fields\n+\n+This lint detects use of unions that contain fields with possibly non-trivial drop code. Some\n+example code that triggers this lint:\n+\n+```rust\n+#![feature(untagged_unions)]\n+\n+union U {\n+    s: String,\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n+ --> src/main.rs:4:5\n+  |\n+4 |     s: String,\n+  |     ^^^^^^^^^\n+  |\n+```\n+\n+## unknown-lints\n+\n+This lint detects unrecognized lint attribute. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+#[allow(not_a_real_lint)]\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unknown lint: `not_a_real_lint`\n+ --> src/main.rs:1:10\n+  |\n+1 | #![allow(not_a_real_lint)]\n+  |          ^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## unreachable-code\n+\n+This lint detects detects unreachable code paths. Some example code that\n+triggers this lint:\n+\n+```rust,no_run\n+panic!(\"we never go past here!\");\n+\n+let x = 5;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unreachable statement\n+ --> src/main.rs:4:5\n+  |\n+4 |     let x = 5;\n+  |     ^^^^^^^^^^\n+  |\n+```\n+\n+## unreachable-patterns\n+\n+This lint detects detects unreachable patterns. Some\n+example code that triggers this lint:\n+\n+```rust\n+let x = 5;\n+match x {\n+    y => (),\n+    5 => (),\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unreachable pattern\n+ --> src/main.rs:5:5\n+  |\n+5 |     5 => (),\n+  |     ^\n+  |\n+```\n+\n+The `y` pattern will always match, so the five is impossible to reach.\n+Remember, match arms match in order, you probably wanted to put the `5` case\n+above the `y` case.\n+\n+## unstable-name-collision\n+\n+This lint detects that you've used a name that the standard library plans to\n+add in the future, which means that your code may fail to compile without\n+additional type annotations in the future. Either rename, or add those\n+annotations now.\n+\n+## unused-allocation\n+\n+This lint detects detects unnecessary allocations that can be eliminated.\n+\n+## unused-assignments\n+\n+This lint detects detect assignments that will never be read. Some\n+example code that triggers this lint:\n+\n+```rust\n+let mut x = 5;\n+x = 6;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: value assigned to `x` is never read\n+ --> src/main.rs:4:5\n+  |\n+4 |     x = 6;\n+  |     ^\n+  |\n+```\n+\n+## unused-attributes\n+\n+This lint detects detects attributes that were not used by the compiler. Some\n+example code that triggers this lint:\n+\n+```rust\n+#![feature(custom_attribute)]\n+\n+#![mutable_doc]\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unused attribute\n+ --> src/main.rs:4:1\n+  |\n+4 | #![mutable_doc]\n+  | ^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## unused-comparisons\n+\n+This lint detects comparisons made useless by limits of the types involved. Some\n+example code that triggers this lint:\n+\n+```rust\n+fn foo(x: u8) {\n+    x >= 0;\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: comparison is useless due to type limits\n+ --> src/main.rs:6:5\n+  |\n+6 |     x >= 0;\n+  |     ^^^^^^\n+  |\n+```\n+\n+## unused-doc-comment\n+\n+This lint detects detects doc comments that aren't used by rustdoc. Some\n+example code that triggers this lint:\n+\n+```rust\n+/// docs for x\n+let x = 12;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: doc comment not used by rustdoc\n+ --> src/main.rs:2:5\n+  |\n+2 |     /// docs for x\n+  |     ^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## unused-features\n+\n+This lint detects unused or unknown features found in crate-level #[feature] directives.\n+To fix this, simply remove the feature flag.\n+\n+## unused-imports\n+\n+This lint detects imports that are never used. Some\n+example code that triggers this lint:\n+\n+```rust\n+use std::collections::HashMap;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unused import: `std::collections::HashMap`\n+ --> src/main.rs:1:5\n+  |\n+1 | use std::collections::HashMap;\n+  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## unused-macros\n+\n+This lint detects detects macros that were not used. Some example code that\n+triggers this lint:\n+\n+```rust\n+macro_rules! unused {\n+    () => {};\n+}\n+\n+fn main() {\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unused macro definition\n+ --> src/main.rs:1:1\n+  |\n+1 | / macro_rules! unused {\n+2 | |     () => {};\n+3 | | }\n+  | |_^\n+  |\n+```\n+\n+## unused-must-use\n+\n+This lint detects unused result of a type flagged as #[must_use]. Some\n+example code that triggers this lint:\n+\n+```rust\n+fn returns_result() -> Result<(), ()> {\n+    Ok(())\n+}\n+\n+fn main() {\n+    returns_result();\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unused `std::result::Result` which must be used\n+ --> src/main.rs:6:5\n+  |\n+6 |     returns_result();\n+  |     ^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## unused-mut\n+\n+This lint detects detect mut variables which don't need to be mutable. Some\n+example code that triggers this lint:\n+\n+```rust\n+let mut x = 5;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: variable does not need to be mutable\n+ --> src/main.rs:2:9\n+  |\n+2 |     let mut x = 5;\n+  |         ----^\n+  |         |\n+  |         help: remove this `mut`\n+  |\n+```\n+\n+## unused-parens\n+\n+This lint detects `if`, `match`, `while` and `return` with parentheses; they\n+do not need them. Some example code that triggers this lint:\n+\n+```rust\n+if(true) {}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unnecessary parentheses around `if` condition\n+ --> src/main.rs:2:7\n+  |\n+2 |     if(true) {}\n+  |       ^^^^^^ help: remove these parentheses\n+  |\n+```\n+\n+## unused-unsafe\n+\n+This lint detects unnecessary use of an `unsafe` block. Some\n+example code that triggers this lint:\n+\n+```rust\n+unsafe {}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unnecessary `unsafe` block\n+ --> src/main.rs:2:5\n+  |\n+2 |     unsafe {}\n+  |     ^^^^^^ unnecessary `unsafe` block\n+  |\n+```\n+\n+## unused-variables\n+\n+This lint detects detect variables which are not used in any way. Some\n+example code that triggers this lint:\n+\n+```rust\n+let x = 5;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unused variable: `x`\n+ --> src/main.rs:2:9\n+  |\n+2 |     let x = 5;\n+  |         ^ help: consider using `_x` instead\n+  |\n+```\n+\n+## warnings\n+\n+This lint is a bit special; by changing its level, you change every other warning\n+that would produce a warning to whatever value you'd like:\n+\n+```rust\n+#![deny(warnings)]\n+```\n+\n+As such, you won't ever trigger this lint in your code directly.\n+\n+## while-true\n+\n+This lint detects `while true { }`. Some example code that triggers this\n+lint:\n+\n+```rust,no_run\n+while true {\n+\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: denote infinite loops with `loop { ... }`\n+ --> src/main.rs:2:5\n+  |\n+2 |     while true {\n+  |     ^^^^^^^^^^ help: use `loop`\n+  |\n+```"}, {"sha": "8620346e5b7480fcb5eb5240fdfc9ee6c9c42a17", "filename": "src/doc/rustc/src/targets/built-in.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fbuilt-in.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fbuilt-in.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fbuilt-in.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,10 @@\n+# Built-in Targets\n+\n+`rustc` ships with the ability to compile to many targets automatically, we\n+call these \"built-in\" targets, and they generally correspond to targets that\n+the team is supporting directly.\n+\n+To see the list of built-in targets, you can run `rustc --print target-list`,\n+or look at [the API\n+docs](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_back/target/#modules).\n+Each module there defines a builder for a particular target.\n\\ No newline at end of file"}, {"sha": "0691afc60eae12c5b4dcb860aa586b2be92cd2ca", "filename": "src/doc/rustc/src/targets/custom.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fcustom.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fcustom.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fcustom.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,17 @@\n+# Custom Targets\n+\n+If you'd like to build for a target that is not yet supported by `rustc`, you can use a\n+\"custom target specification\" to define a target. These target specification files\n+are JSON. To see the JSON for the host target, you can run:\n+\n+```bash\n+$ rustc +nightly -Z unstable-options --print target-spec-json\n+```\n+\n+To see it for a different target, add the `--target` flag:\n+\n+```bash\n+$ rustc +nightly -Z unstable-options --target=wasm32-unknown-unknown --print target-spec-json\n+```\n+\n+To use a custom target, see [`xargo`](https://github.com/japaric/xargo).\n\\ No newline at end of file"}, {"sha": "07e3a79471f5b5f4d877ed2129ef782df76fbdc9", "filename": "src/doc/rustc/src/targets/index.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,13 @@\n+# Targets\n+\n+`rustc` is a cross-compiler by default. This means that you can use any compiler to build for any\n+architecture. The list of *targets* are the possible architectures that you can build for.\n+\n+To see all the options that you can set with a target, see the docs\n+[here](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_back/target/struct.Target.html).\n+\n+To compile to a particular target, use the `--target` flag:\n+\n+```bash\n+$ rustc src/main.rs --target=wasm32-unknown-unknown\n+```"}, {"sha": "bed1b71c24e00132f7211802645949d8a2e081c2", "filename": "src/doc/rustc/src/what-is-rustc.md", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Fwhat-is-rustc.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Frustc%2Fsrc%2Fwhat-is-rustc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fwhat-is-rustc.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,68 @@\n+# What is rustc?\n+\n+Welcome to \"The rustc book\"! `rustc` is the compiler for the Rust programming\n+language, provided by the project itself. Compilers take your source code and\n+produce binary code, either as a library or executable.\n+\n+Most Rust programmers don't invoke `rustc` directly, but instead do it through\n+[Cargo](../cargo/index.html). It's all in service of `rustc` though! If you\n+want to see how Cargo calls `rustc`, you can\n+\n+```bash\n+$ cargo build --verbose\n+```\n+\n+And it will print out each `rustc` invocation. This book can help you\n+understand what each of these options does. Additionally, while most\n+Rustaceans use Cargo, not all do: sometimes they integrate `rustc` into other\n+build systems. This book should provide a guide to all of the options you'd\n+need to do so.\n+\n+## Basic usage\n+\n+Let's say you've got a little hello world program in a file `hello.rs`:\n+\n+```rust\n+fn main() {\n+    println!(\"Hello, world!\");\n+}\n+```\n+\n+To turn this source code into an executable, you can use `rustc`:\n+\n+```bash\n+$ rustc hello.rs\n+$ ./hello # on a *NIX\n+$ .\\hello.exe # on Windows\n+```\n+\n+Note that we only ever pass `rustc` the *crate root*, not every file we wish\n+to compile. For example, if we had a `main.rs` that looked like this:\n+\n+```rust,ignore\n+mod foo;\n+\n+fn main() {\n+    foo::hello();\n+}\n+```\n+\n+And a `foo.rs` that had this:\n+\n+```rust,ignore\n+fn hello() {\n+    println!(\"Hello, world!\");\n+}\n+```\n+\n+To compile this, we'd run this command:\n+\n+```bash\n+$ rustc main.rs\n+```\n+\n+No need to tell `rustc` about `foo.rs`; the `mod` statements give it\n+everything that it needs. This is different than how you would use a C\n+compiler, where you invoke the compiler on each file, and then link\n+everything together. In other words, the *crate* is a translation unit, not a\n+particular module.\n\\ No newline at end of file"}, {"sha": "71b6cd663a0833a129e33e83a4317a2d49af91ef", "filename": "src/doc/unstable-book/src/language-features/fn-must-use.md", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e1d5509bf381d978a1894b6ba869c3b56dd3eeca/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ffn-must-use.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1d5509bf381d978a1894b6ba869c3b56dd3eeca/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ffn-must-use.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ffn-must-use.md?ref=e1d5509bf381d978a1894b6ba869c3b56dd3eeca", "patch": "@@ -1,30 +0,0 @@\n-# `fn_must_use`\n-\n-The tracking issue for this feature is [#43302].\n-\n-[#43302]: https://github.com/rust-lang/rust/issues/43302\n-\n-------------------------\n-\n-The `fn_must_use` feature allows functions and methods to be annotated with\n-`#[must_use]`, indicating that the `unused_must_use` lint should require their\n-return values to be used (similarly to how types annotated with `must_use`,\n-most notably `Result`, are linted if not used).\n-\n-## Examples\n-\n-```rust\n-#![feature(fn_must_use)]\n-\n-#[must_use]\n-fn double(x: i32) -> i32 {\n-    2 * x\n-}\n-\n-fn main() {\n-    double(4); // warning: unused return value of `double` which must be used\n-\n-    let _ = double(4); // (no warning)\n-}\n-\n-```"}, {"sha": "15fc84a3e2a3dad17eb2f2a2115c6c6f45fc6f02", "filename": "src/doc/unstable-book/src/language-features/tool-attributes.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-attributes.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-attributes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-attributes.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,26 @@\n+# `tool_attributes`\n+\n+The tracking issue for this feature is: [#44690]\n+\n+[#44690]: https://github.com/rust-lang/rust/issues/44690\n+\n+------------------------\n+\n+Tool attributes let you use scoped attributes to control the behavior\n+of certain tools.\n+\n+Currently tool names which can be appear in scoped attributes are restricted to\n+`clippy` and `rustfmt`.\n+\n+## An example\n+\n+```rust\n+#![feature(tool_attributes)]\n+\n+#[rustfmt::skip]\n+fn foo() { println!(\"hello, world\"); }\n+\n+fn main() {\n+    foo();\n+}\n+```"}, {"sha": "f59c9f7fd61cb586dc472b9938949aa761819884", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -16,7 +16,7 @@\n             issue = \"32838\")]\n \n use core::intrinsics::{min_align_of_val, size_of_val};\n-use core::ptr::NonNull;\n+use core::ptr::{NonNull, Unique};\n use core::usize;\n \n #[doc(inline)]\n@@ -152,9 +152,17 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     }\n }\n \n-#[cfg_attr(not(test), lang = \"box_free\")]\n+#[cfg(stage0)]\n+#[lang = \"box_free\"]\n+#[inline]\n+unsafe fn old_box_free<T: ?Sized>(ptr: *mut T) {\n+    box_free(Unique::new_unchecked(ptr))\n+}\n+\n+#[cfg_attr(not(any(test, stage0)), lang = \"box_free\")]\n #[inline]\n-pub(crate) unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n+pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n+    let ptr = ptr.as_ptr();\n     let size = size_of_val(&*ptr);\n     let align = min_align_of_val(&*ptr);\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary."}, {"sha": "d0950bff9ce8092a38b5c53616f86c0dfaad83bc", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -566,7 +566,8 @@ impl<T: ?Sized> Arc<T> {\n \n     fn from_box(v: Box<T>) -> Arc<T> {\n         unsafe {\n-            let bptr = Box::into_raw(v);\n+            let box_unique = Box::into_unique(v);\n+            let bptr = box_unique.as_ptr();\n \n             let value_size = size_of_val(&*bptr);\n             let ptr = Self::allocate_for_ptr(bptr);\n@@ -578,7 +579,7 @@ impl<T: ?Sized> Arc<T> {\n                 value_size);\n \n             // Free the allocation without dropping its contents\n-            box_free(bptr);\n+            box_free(box_unique);\n \n             Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n         }"}, {"sha": "1b4f86dcfac1c07174e3efc4c8217b7824435a68", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -184,6 +184,7 @@ impl<T: ?Sized> Box<T> {\n \n     #[unstable(feature = \"ptr_internals\", issue = \"0\", reason = \"use into_raw_non_null instead\")]\n     #[inline]\n+    #[doc(hidden)]\n     pub fn into_unique(b: Box<T>) -> Unique<T> {\n         let unique = b.0;\n         mem::forget(b);"}, {"sha": "da4b76a4d527d41ee755812ffae464e780e2e4c4", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -96,7 +96,7 @@\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n-#![feature(fn_must_use)]\n+#![cfg_attr(stage0, feature(fn_must_use))]\n #![feature(from_ref)]\n #![feature(fundamental)]\n #![feature(lang_items)]\n@@ -122,8 +122,9 @@\n #![feature(on_unimplemented)]\n #![feature(exact_chunks)]\n #![feature(pointer_methods)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n #![cfg_attr(stage0, feature(generic_param_attrs))]\n+#![feature(rustc_const_unstable)]\n \n #![cfg_attr(not(test), feature(fn_traits, i128))]\n #![cfg_attr(test, feature(test))]"}, {"sha": "eb25ae17511707064c110b2dfca3ea2b439faede", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -56,14 +56,16 @@ pub struct RawVec<T, A: Alloc = Global> {\n impl<T, A: Alloc> RawVec<T, A> {\n     /// Like `new` but parameterized over the choice of allocator for\n     /// the returned RawVec.\n-    pub fn new_in(a: A) -> Self {\n+    pub const fn new_in(a: A) -> Self {\n         // !0 is usize::MAX. This branch should be stripped at compile time.\n-        let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n+        // FIXME(mark-i-m): use this line when `if`s are allowed in `const`\n+        //let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n \n         // Unique::empty() doubles as \"unallocated\" and \"zero-sized allocation\"\n         RawVec {\n             ptr: Unique::empty(),\n-            cap,\n+            // FIXME(mark-i-m): use `cap` when ifs are allowed in const\n+            cap: [0, !0][(mem::size_of::<T>() == 0) as usize],\n             a,\n         }\n     }\n@@ -120,7 +122,7 @@ impl<T> RawVec<T, Global> {\n     /// RawVec with capacity 0. If T has 0 size, then it makes a\n     /// RawVec with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n-    pub fn new() -> Self {\n+    pub const fn new() -> Self {\n         Self::new_in(Global)\n     }\n "}, {"sha": "d0188c6e8285800193380dfd6a138e9c3535dead", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -681,7 +681,8 @@ impl<T: ?Sized> Rc<T> {\n \n     fn from_box(v: Box<T>) -> Rc<T> {\n         unsafe {\n-            let bptr = Box::into_raw(v);\n+            let box_unique = Box::into_unique(v);\n+            let bptr = box_unique.as_ptr();\n \n             let value_size = size_of_val(&*bptr);\n             let ptr = Self::allocate_for_ptr(bptr);\n@@ -693,7 +694,7 @@ impl<T: ?Sized> Rc<T> {\n                 value_size);\n \n             // Free the allocation without dropping its contents\n-            box_free(bptr);\n+            box_free(box_unique);\n \n             Rc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n         }"}, {"sha": "1c8ff316e55aab6fdaf4aae5ff8872ad835c9f5d", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -25,7 +25,7 @@\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(exact_chunks)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n \n extern crate alloc_system;\n extern crate core;"}, {"sha": "6fd0b33f02a60a9632249c6be29dac951d248ea7", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1282,6 +1282,7 @@ fn test_box_slice_clone() {\n }\n \n #[test]\n+#[allow(unused_must_use)] // here, we care about the side effects of `.clone()`\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n fn test_box_slice_clone_panics() {\n     use std::sync::Arc;"}, {"sha": "35d0a69a05abe846942a0caad8d47b5bf08a48e6", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -322,7 +322,8 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> Vec<T> {\n+    #[rustc_const_unstable(feature = \"const_vec_new\")]\n+    pub const fn new() -> Vec<T> {\n         Vec {\n             buf: RawVec::new(),\n             len: 0,"}, {"sha": "13e838773a5875faf0a0da4117644d9f45776c94", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -106,6 +106,8 @@ use self::Ordering::*;\n /// ```\n #[lang = \"eq\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(alias = \"==\")]\n+#[doc(alias = \"!=\")]\n #[rustc_on_unimplemented = \"can't compare `{Self}` with `{Rhs}`\"]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used\n@@ -160,6 +162,8 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// }\n /// impl Eq for Book {}\n /// ```\n+#[doc(alias = \"==\")]\n+#[doc(alias = \"!=\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Eq: PartialEq<Self> {\n     // this method is used solely by #[deriving] to assert\n@@ -428,6 +432,10 @@ impl<T: Ord> Ord for Reverse<T> {\n /// }\n /// ```\n #[lang = \"ord\"]\n+#[doc(alias = \"<\")]\n+#[doc(alias = \">\")]\n+#[doc(alias = \"<=\")]\n+#[doc(alias = \">=\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n     /// This method returns an `Ordering` between `self` and `other`.\n@@ -599,6 +607,10 @@ impl PartialOrd for Ordering {\n /// ```\n #[lang = \"partial_ord\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(alias = \">\")]\n+#[doc(alias = \"<\")]\n+#[doc(alias = \"<=\")]\n+#[doc(alias = \">=\")]\n #[rustc_on_unimplemented = \"can't compare `{Self}` with `{Rhs}`\"]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values if one exists."}, {"sha": "5820fe58932c6967b5797ca8112dd808e813d270", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -542,11 +542,12 @@ impl<'a> Display for Arguments<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n-    on(crate_local, label=\"`{Self}` cannot be formatted using `:?`; \\\n-                            add `#[derive(Debug)]` or manually implement `{Debug}`\"),\n+    on(crate_local, label=\"`{Self}` cannot be formatted using `{{:?}}`\",\n+                    note=\"add `#[derive(Debug)]` or manually implement `{Debug}`\"),\n     message=\"`{Self}` doesn't implement `{Debug}`\",\n-    label=\"`{Self}` cannot be formatted using `:?` because it doesn't implement `{Debug}`\",\n+    label=\"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\",\n )]\n+#[doc(alias = \"{:?}\")]\n #[lang = \"debug_trait\"]\n pub trait Debug {\n     /// Formats the value using the given formatter.\n@@ -609,9 +610,11 @@ pub trait Debug {\n /// ```\n #[rustc_on_unimplemented(\n     message=\"`{Self}` doesn't implement `{Display}`\",\n-    label=\"`{Self}` cannot be formatted with the default formatter; \\\n-           try using `:?` instead if you are using a format string\",\n+    label=\"`{Self}` cannot be formatted with the default formatter\",\n+    note=\"in format strings you may be able to use `{{:?}}` \\\n+          (or {{:#?}} for pretty-print) instead\",\n )]\n+#[doc(alias = \"{}\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Display {\n     /// Formats the value using the given formatter."}, {"sha": "b27bd3142e1ed915ac2d2c83d7077f6bbfb50b10", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1094,6 +1094,8 @@ pub trait Iterator {\n     /// `flatten()` a three-dimensional array the result will be\n     /// two-dimensional and not one-dimensional. To get a one-dimensional\n     /// structure, you have to `flatten()` again.\n+    ///\n+    /// [`flat_map()`]: #method.flat_map\n     #[inline]\n     #[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n     fn flatten(self) -> Flatten<Self>"}, {"sha": "54f35d17974fb2412db5e25bdcb802d350ef96e6", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -50,6 +50,15 @@\n \n // Since libcore defines many fundamental lang items, all tests live in a\n // separate crate, libcoretest, to avoid bizarre issues.\n+//\n+// Here we explicitly #[cfg]-out this whole crate when testing. If we don't do\n+// this, both the generated test artifact and the linked libtest (which\n+// transitively includes libcore) will both define the same set of lang items,\n+// and this will cause the E0152 \"duplicate lang item found\" error. See\n+// discussion in #50466 for details.\n+//\n+// This cfg won't affect doc tests.\n+#![cfg(not(test))]\n \n #![stable(feature = \"core\", since = \"1.6.0\")]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -76,7 +85,6 @@\n #![feature(doc_cfg)]\n #![feature(doc_spotlight)]\n #![feature(extern_types)]\n-#![feature(fn_must_use)]\n #![feature(fundamental)]\n #![feature(intrinsics)]\n #![feature(iterator_flatten)]\n@@ -103,6 +111,7 @@\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n #![feature(doc_alias)]\n+#![feature(inclusive_range_methods)]\n \n #![cfg_attr(not(stage0), feature(mmx_target_feature))]\n #![cfg_attr(not(stage0), feature(tbm_target_feature))]\n@@ -114,6 +123,7 @@\n \n #![cfg_attr(stage0, feature(target_feature))]\n #![cfg_attr(stage0, feature(cfg_target_feature))]\n+#![cfg_attr(stage0, feature(fn_must_use))]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "c830c22ee5f50b1c58a46732cbe56036882756c2", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -606,8 +606,8 @@ mod builtin {\n     #[macro_export]\n     #[cfg(dox)]\n     macro_rules! concat_idents {\n-        ($($e:ident),*) => ({ /* compiler built-in */ });\n-        ($($e:ident,)*) => ({ /* compiler built-in */ });\n+        ($($e:ident),+) => ({ /* compiler built-in */ });\n+        ($($e:ident,)+) => ({ /* compiler built-in */ });\n     }\n \n     /// Concatenates literals into a static string slice."}, {"sha": "c074adfd570e339adaa765b09080eb750fe4e44c", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -602,6 +602,8 @@ unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n /// `Pin` pointer.\n ///\n /// This trait is automatically implemented for almost every type.\n+///\n+/// [`Pin`]: ../mem/struct.Pin.html\n #[unstable(feature = \"pin\", issue = \"49150\")]\n pub unsafe auto trait Unpin {}\n "}, {"sha": "a1bc5463f7333dfa114105b2a6489ff2e28e220e", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -94,6 +94,7 @@ pub trait Add<RHS=Self> {\n     type Output;\n \n     /// Performs the `+` operation.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn add(self, rhs: RHS) -> Self::Output;\n }\n@@ -191,6 +192,7 @@ pub trait Sub<RHS=Self> {\n     type Output;\n \n     /// Performs the `-` operation.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sub(self, rhs: RHS) -> Self::Output;\n }\n@@ -310,6 +312,7 @@ pub trait Mul<RHS=Self> {\n     type Output;\n \n     /// Performs the `*` operation.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn mul(self, rhs: RHS) -> Self::Output;\n }\n@@ -433,6 +436,7 @@ pub trait Div<RHS=Self> {\n     type Output;\n \n     /// Performs the `/` operation.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn div(self, rhs: RHS) -> Self::Output;\n }\n@@ -517,6 +521,7 @@ pub trait Rem<RHS=Self> {\n     type Output = Self;\n \n     /// Performs the `%` operation.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rem(self, rhs: RHS) -> Self::Output;\n }\n@@ -601,6 +606,7 @@ pub trait Neg {\n     type Output;\n \n     /// Performs the unary `-` operation.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn neg(self) -> Self::Output;\n }"}, {"sha": "3900f365b0ab197364bb2f3c47b190c9b8507d82", "filename": "src/libcore/ops/bit.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -46,6 +46,7 @@ pub trait Not {\n     type Output;\n \n     /// Performs the unary `!` operation.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn not(self) -> Self::Output;\n }\n@@ -119,6 +120,7 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// assert_eq!(bv1 & bv2, expected);\n /// ```\n #[lang = \"bitand\"]\n+#[doc(alias = \"&\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(message=\"no implementation for `{Self} & {RHS}`\",\n                          label=\"no implementation for `{Self} & {RHS}`\")]\n@@ -128,6 +130,7 @@ pub trait BitAnd<RHS=Self> {\n     type Output;\n \n     /// Performs the `&` operation.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitand(self, rhs: RHS) -> Self::Output;\n }\n@@ -201,6 +204,7 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// assert_eq!(bv1 | bv2, expected);\n /// ```\n #[lang = \"bitor\"]\n+#[doc(alias = \"|\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(message=\"no implementation for `{Self} | {RHS}`\",\n                          label=\"no implementation for `{Self} | {RHS}`\")]\n@@ -210,6 +214,7 @@ pub trait BitOr<RHS=Self> {\n     type Output;\n \n     /// Performs the `|` operation.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitor(self, rhs: RHS) -> Self::Output;\n }\n@@ -286,6 +291,7 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// assert_eq!(bv1 ^ bv2, expected);\n /// ```\n #[lang = \"bitxor\"]\n+#[doc(alias = \"^\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(message=\"no implementation for `{Self} ^ {RHS}`\",\n                          label=\"no implementation for `{Self} ^ {RHS}`\")]\n@@ -295,6 +301,7 @@ pub trait BitXor<RHS=Self> {\n     type Output;\n \n     /// Performs the `^` operation.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitxor(self, rhs: RHS) -> Self::Output;\n }\n@@ -372,6 +379,7 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///            SpinVector { vec: vec![2, 3, 4, 0, 1] });\n /// ```\n #[lang = \"shl\"]\n+#[doc(alias = \"<<\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(message=\"no implementation for `{Self} << {RHS}`\",\n                          label=\"no implementation for `{Self} << {RHS}`\")]\n@@ -381,6 +389,7 @@ pub trait Shl<RHS=Self> {\n     type Output;\n \n     /// Performs the `<<` operation.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shl(self, rhs: RHS) -> Self::Output;\n }\n@@ -479,6 +488,7 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n ///            SpinVector { vec: vec![3, 4, 0, 1, 2] });\n /// ```\n #[lang = \"shr\"]\n+#[doc(alias = \">>\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(message=\"no implementation for `{Self} >> {RHS}`\",\n                          label=\"no implementation for `{Self} >> {RHS}`\")]\n@@ -488,6 +498,7 @@ pub trait Shr<RHS=Self> {\n     type Output;\n \n     /// Performs the `>>` operation.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shr(self, rhs: RHS) -> Self::Output;\n }\n@@ -593,6 +604,7 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n /// assert_eq!(bv, expected);\n /// ```\n #[lang = \"bitand_assign\"]\n+#[doc(alias = \"&=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented(message=\"no implementation for `{Self} &= {Rhs}`\",\n                          label=\"no implementation for `{Self} &= {Rhs}`\")]\n@@ -641,6 +653,7 @@ bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// assert_eq!(prefs, PersonalPreferences { likes_cats: true, likes_dogs: true });\n /// ```\n #[lang = \"bitor_assign\"]\n+#[doc(alias = \"|=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented(message=\"no implementation for `{Self} |= {Rhs}`\",\n                          label=\"no implementation for `{Self} |= {Rhs}`\")]\n@@ -689,6 +702,7 @@ bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// assert_eq!(personality, Personality { has_soul: true, likes_knitting: false});\n /// ```\n #[lang = \"bitxor_assign\"]\n+#[doc(alias = \"^=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented(message=\"no implementation for `{Self} ^= {Rhs}`\",\n                          label=\"no implementation for `{Self} ^= {Rhs}`\")]\n@@ -735,6 +749,7 @@ bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// assert_eq!(scalar, Scalar(16));\n /// ```\n #[lang = \"shl_assign\"]\n+#[doc(alias = \"<<=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented(message=\"no implementation for `{Self} <<= {Rhs}`\",\n                          label=\"no implementation for `{Self} <<= {Rhs}`\")]\n@@ -802,6 +817,7 @@ shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n /// assert_eq!(scalar, Scalar(4));\n /// ```\n #[lang = \"shr_assign\"]\n+#[doc(alias = \">>=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented(message=\"no implementation for `{Self} >>= {Rhs}`\",\n                          label=\"no implementation for `{Self} >>= {Rhs}`\")]"}, {"sha": "54eecc82e19ef4325e52ed7ec39b207f153313e1", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -68,13 +68,16 @@\n /// assert_eq!('a', *x);\n /// ```\n #[lang = \"deref\"]\n+#[doc(alias = \"*\")]\n+#[doc(alias = \"&*\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Deref {\n     /// The resulting type after dereferencing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Target: ?Sized;\n \n     /// Dereferences the value.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn deref(&self) -> &Self::Target;\n }\n@@ -162,6 +165,7 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n /// assert_eq!('b', *x);\n /// ```\n #[lang = \"deref_mut\"]\n+#[doc(alias = \"*\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DerefMut: Deref {\n     /// Mutably dereferences the value."}, {"sha": "b01a769eda7fd4201e7239003425d93cbb26e937", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 82, "deletions": 2, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -45,6 +45,7 @@ use fmt;\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n /// [`Iterator`]: ../iter/trait.IntoIterator.html\n /// [slicing index]: ../slice/trait.SliceIndex.html\n+#[doc(alias = \"..\")]\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFull;\n@@ -74,6 +75,7 @@ impl fmt::Debug for RangeFull {\n /// assert_eq!(arr[1.. ], [     'b', 'c', 'd']);\n /// assert_eq!(arr[1..3], [     'b', 'c'     ]);  // Range\n /// ```\n+#[doc(alias = \"..\")]\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Range<Idx> {\n@@ -175,6 +177,7 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n /// ```\n ///\n /// [`Iterator`]: ../iter/trait.IntoIterator.html\n+#[doc(alias = \"..\")]\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n@@ -256,6 +259,7 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n /// [`Iterator`]: ../iter/trait.IntoIterator.html\n /// [slicing index]: ../slice/trait.SliceIndex.html\n+#[doc(alias = \"..\")]\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeTo<Idx> {\n@@ -314,26 +318,101 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// # Examples\n ///\n /// ```\n-/// #![feature(inclusive_range_fields)]\n+/// #![feature(inclusive_range_methods)]\n ///\n-/// assert_eq!((3..=5), std::ops::RangeInclusive { start: 3, end: 5 });\n+/// assert_eq!((3..=5), std::ops::RangeInclusive::new(3, 5));\n /// assert_eq!(3 + 4 + 5, (3..=5).sum());\n ///\n /// let arr = [0, 1, 2, 3];\n /// assert_eq!(arr[ ..=2], [0,1,2  ]);\n /// assert_eq!(arr[1..=2], [  1,2  ]);  // RangeInclusive\n /// ```\n+#[doc(alias = \"..=\")]\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub struct RangeInclusive<Idx> {\n+    // FIXME: The current representation follows RFC 1980,\n+    // but it is known that LLVM is not able to optimize loops following that RFC.\n+    // Consider adding an extra `bool` field to indicate emptiness of the range.\n+    // See #45222 for performance test cases.\n+    #[cfg(not(stage0))]\n+    pub(crate) start: Idx,\n+    #[cfg(not(stage0))]\n+    pub(crate) end: Idx,\n     /// The lower bound of the range (inclusive).\n+    #[cfg(stage0)]\n     #[unstable(feature = \"inclusive_range_fields\", issue = \"49022\")]\n     pub start: Idx,\n     /// The upper bound of the range (inclusive).\n+    #[cfg(stage0)]\n     #[unstable(feature = \"inclusive_range_fields\", issue = \"49022\")]\n     pub end: Idx,\n }\n \n+impl<Idx> RangeInclusive<Idx> {\n+    /// Creates a new inclusive range. Equivalent to writing `start..=end`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inclusive_range_methods)]\n+    /// use std::ops::RangeInclusive;\n+    ///\n+    /// assert_eq!(3..=5, RangeInclusive::new(3, 5));\n+    /// ```\n+    #[unstable(feature = \"inclusive_range_methods\", issue = \"49022\")]\n+    #[inline]\n+    pub const fn new(start: Idx, end: Idx) -> Self {\n+        Self { start, end }\n+    }\n+\n+    /// Returns the lower bound of the range (inclusive).\n+    ///\n+    /// When using an inclusive range for iteration, the values of `start()` and\n+    /// [`end()`] are unspecified after the iteration ended. To determine\n+    /// whether the inclusive range is empty, use the [`is_empty()`] method\n+    /// instead of comparing `start() > end()`.\n+    ///\n+    /// [`end()`]: #method.end\n+    /// [`is_empty()`]: #method.is_empty\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inclusive_range_methods)]\n+    ///\n+    /// assert_eq!((3..=5).start(), &3);\n+    /// ```\n+    #[unstable(feature = \"inclusive_range_methods\", issue = \"49022\")]\n+    #[inline]\n+    pub fn start(&self) -> &Idx {\n+        &self.start\n+    }\n+\n+    /// Returns the upper bound of the range (inclusive).\n+    ///\n+    /// When using an inclusive range for iteration, the values of [`start()`]\n+    /// and `end()` are unspecified after the iteration ended. To determine\n+    /// whether the inclusive range is empty, use the [`is_empty()`] method\n+    /// instead of comparing `start() > end()`.\n+    ///\n+    /// [`start()`]: #method.start\n+    /// [`is_empty()`]: #method.is_empty\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inclusive_range_methods)]\n+    ///\n+    /// assert_eq!((3..=5).end(), &5);\n+    /// ```\n+    #[unstable(feature = \"inclusive_range_methods\", issue = \"49022\")]\n+    #[inline]\n+    pub fn end(&self) -> &Idx {\n+        &self.end\n+    }\n+}\n+\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n@@ -449,6 +528,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n /// [`Iterator`]: ../iter/trait.IntoIterator.html\n /// [slicing index]: ../slice/trait.SliceIndex.html\n+#[doc(alias = \"..=\")]\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub struct RangeToInclusive<Idx> {"}, {"sha": "5d0b675e8e4c53639b95e6eae1fa7f0305ca0a43", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -2513,6 +2513,7 @@ impl<T: ?Sized> PartialOrd for *mut T {\n            reason = \"use NonNull instead and consider PhantomData<T> \\\n                      (if you also use #[may_dangle]), Send, and/or Sync\")]\n #[allow(deprecated)]\n+#[doc(hidden)]\n pub struct Unique<T: ?Sized> {\n     pointer: NonZero<*const T>,\n     // NOTE: this marker has no consequences for variance, but is necessary\n@@ -2551,10 +2552,9 @@ impl<T: Sized> Unique<T> {\n     /// This is useful for initializing types which lazily allocate, like\n     /// `Vec::new` does.\n     // FIXME: rename to dangling() to match NonNull?\n-    pub fn empty() -> Self {\n+    pub const fn empty() -> Self {\n         unsafe {\n-            let ptr = mem::align_of::<T>() as *mut T;\n-            Unique::new_unchecked(ptr)\n+            Unique::new_unchecked(mem::align_of::<T>() as *mut T)\n         }\n     }\n }"}, {"sha": "7b62e7b0620fd4ddd51348f523139004d2a4a0ed", "filename": "src/libcore/slice/memchr.rs", "status": "modified", "additions": 2, "deletions": 95, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -39,21 +39,10 @@ fn repeat_byte(b: u8) -> usize {\n     (b as usize) << 8 | b as usize\n }\n \n-#[cfg(target_pointer_width = \"32\")]\n+#[cfg(not(target_pointer_width = \"16\"))]\n #[inline]\n fn repeat_byte(b: u8) -> usize {\n-    let mut rep = (b as usize) << 8 | b as usize;\n-    rep = rep << 16 | rep;\n-    rep\n-}\n-\n-#[cfg(target_pointer_width = \"64\")]\n-#[inline]\n-fn repeat_byte(b: u8) -> usize {\n-    let mut rep = (b as usize) << 8 | b as usize;\n-    rep = rep << 16 | rep;\n-    rep = rep << 32 | rep;\n-    rep\n+    (b as usize) * (::usize::MAX / 255)\n }\n \n /// Return the first index matching the byte `x` in `text`.\n@@ -146,85 +135,3 @@ pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n     // find the byte before the point the body loop stopped\n     text[..offset].iter().rposition(|elt| *elt == x)\n }\n-\n-// test fallback implementations on all platforms\n-#[test]\n-fn matches_one() {\n-    assert_eq!(Some(0), memchr(b'a', b\"a\"));\n-}\n-\n-#[test]\n-fn matches_begin() {\n-    assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n-}\n-\n-#[test]\n-fn matches_end() {\n-    assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n-}\n-\n-#[test]\n-fn matches_nul() {\n-    assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n-}\n-\n-#[test]\n-fn matches_past_nul() {\n-    assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n-}\n-\n-#[test]\n-fn no_match_empty() {\n-    assert_eq!(None, memchr(b'a', b\"\"));\n-}\n-\n-#[test]\n-fn no_match() {\n-    assert_eq!(None, memchr(b'a', b\"xyz\"));\n-}\n-\n-#[test]\n-fn matches_one_reversed() {\n-    assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n-}\n-\n-#[test]\n-fn matches_begin_reversed() {\n-    assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n-}\n-\n-#[test]\n-fn matches_end_reversed() {\n-    assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n-}\n-\n-#[test]\n-fn matches_nul_reversed() {\n-    assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n-}\n-\n-#[test]\n-fn matches_past_nul_reversed() {\n-    assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n-}\n-\n-#[test]\n-fn no_match_empty_reversed() {\n-    assert_eq!(None, memrchr(b'a', b\"\"));\n-}\n-\n-#[test]\n-fn no_match_reversed() {\n-    assert_eq!(None, memrchr(b'a', b\"xyz\"));\n-}\n-\n-#[test]\n-fn each_alignment_reversed() {\n-    let mut data = [1u8; 64];\n-    let needle = 2;\n-    let pos = 40;\n-    data[pos] = needle;\n-    for start in 0..16 {\n-        assert_eq!(Some(pos - start), memrchr(needle, &data[start..]));\n-    }\n-}"}, {"sha": "83e8a6e4b683a93f59e3fcd8d01b9409e5fee1f6", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -880,7 +880,6 @@ macro_rules! slice_core_methods { () => {\n     #[inline]\n     pub fn split_last(&self) -> Option<(&T, &[T])> {\n         SliceExt::split_last(self)\n-\n     }\n \n     /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty."}, {"sha": "28dac02654b4c82d2e2ce0fb53b669d3279cd160", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -44,9 +44,10 @@\n #![feature(exact_chunks)]\n #![cfg_attr(stage0, feature(atomic_nand))]\n #![feature(reverse_bits)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n #![feature(iterator_find_map)]\n #![feature(inner_deref)]\n+#![feature(slice_internals)]\n \n extern crate core;\n extern crate test;\n@@ -75,4 +76,5 @@ mod result;\n mod slice;\n mod str;\n mod str_lossy;\n+mod time;\n mod tuple;"}, {"sha": "257f6ea20d4eab7aa12a87ab53874d44bbefc86c", "filename": "src/libcore/tests/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -98,6 +98,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg(not(stage0))]\n     fn test_reverse_bits() {\n         assert_eq!(A.reverse_bits().reverse_bits(), A);\n         assert_eq!(B.reverse_bits().reverse_bits(), B);"}, {"sha": "d66193b1687c86c921687f589862cbbf2cd94815", "filename": "src/libcore/tests/ops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -50,21 +50,21 @@ fn test_full_range() {\n \n #[test]\n fn test_range_inclusive() {\n-    let mut r = RangeInclusive { start: 1i8, end: 2 };\n+    let mut r = RangeInclusive::new(1i8, 2);\n     assert_eq!(r.next(), Some(1));\n     assert_eq!(r.next(), Some(2));\n     assert_eq!(r.next(), None);\n \n-    r = RangeInclusive { start: 127i8, end: 127 };\n+    r = RangeInclusive::new(127i8, 127);\n     assert_eq!(r.next(), Some(127));\n     assert_eq!(r.next(), None);\n \n-    r = RangeInclusive { start: -128i8, end: -128 };\n+    r = RangeInclusive::new(-128i8, -128);\n     assert_eq!(r.next_back(), Some(-128));\n     assert_eq!(r.next_back(), None);\n \n     // degenerate\n-    r = RangeInclusive { start: 1, end: -1 };\n+    r = RangeInclusive::new(1, -1);\n     assert_eq!(r.size_hint(), (0, Some(0)));\n     assert_eq!(r.next(), None);\n }"}, {"sha": "c81e5e97cbb7acc5c43927e8d2fae22c14fa2969", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -550,3 +550,89 @@ fn sort_unstable() {\n     v.sort_unstable();\n     assert!(v == [0xDEADBEEF]);\n }\n+\n+pub mod memchr {\n+    use core::slice::memchr::{memchr, memrchr};\n+\n+    // test fallback implementations on all platforms\n+    #[test]\n+    fn matches_one() {\n+        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin() {\n+        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end() {\n+        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul() {\n+        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul() {\n+        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty() {\n+        assert_eq!(None, memchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match() {\n+        assert_eq!(None, memchr(b'a', b\"xyz\"));\n+    }\n+\n+    #[test]\n+    fn matches_one_reversed() {\n+        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin_reversed() {\n+        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul_reversed() {\n+        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n+    }\n+\n+    #[test]\n+    fn each_alignment_reversed() {\n+        let mut data = [1u8; 64];\n+        let needle = 2;\n+        let pos = 40;\n+        data[pos] = needle;\n+        for start in 0..16 {\n+            assert_eq!(Some(pos - start), memrchr(needle, &data[start..]));\n+        }\n+    }\n+}"}, {"sha": "042c523f25f25badec26e7737654afeb65de94ee", "filename": "src/libcore/tests/time.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::time::Duration;\n+\n+#[test]\n+fn creation() {\n+    assert!(Duration::from_secs(1) != Duration::from_secs(0));\n+    assert_eq!(Duration::from_secs(1) + Duration::from_secs(2),\n+               Duration::from_secs(3));\n+    assert_eq!(Duration::from_millis(10) + Duration::from_secs(4),\n+               Duration::new(4, 10 * 1_000_000));\n+    assert_eq!(Duration::from_millis(4000), Duration::new(4, 0));\n+}\n+\n+#[test]\n+fn secs() {\n+    assert_eq!(Duration::new(0, 0).as_secs(), 0);\n+    assert_eq!(Duration::from_secs(1).as_secs(), 1);\n+    assert_eq!(Duration::from_millis(999).as_secs(), 0);\n+    assert_eq!(Duration::from_millis(1001).as_secs(), 1);\n+}\n+\n+#[test]\n+fn nanos() {\n+    assert_eq!(Duration::new(0, 0).subsec_nanos(), 0);\n+    assert_eq!(Duration::new(0, 5).subsec_nanos(), 5);\n+    assert_eq!(Duration::new(0, 1_000_000_001).subsec_nanos(), 1);\n+    assert_eq!(Duration::from_secs(1).subsec_nanos(), 0);\n+    assert_eq!(Duration::from_millis(999).subsec_nanos(), 999 * 1_000_000);\n+    assert_eq!(Duration::from_millis(1001).subsec_nanos(), 1 * 1_000_000);\n+}\n+\n+#[test]\n+fn add() {\n+    assert_eq!(Duration::new(0, 0) + Duration::new(0, 1),\n+               Duration::new(0, 1));\n+    assert_eq!(Duration::new(0, 500_000_000) + Duration::new(0, 500_000_001),\n+               Duration::new(1, 1));\n+}\n+\n+#[test]\n+fn checked_add() {\n+    assert_eq!(Duration::new(0, 0).checked_add(Duration::new(0, 1)),\n+               Some(Duration::new(0, 1)));\n+    assert_eq!(Duration::new(0, 500_000_000).checked_add(Duration::new(0, 500_000_001)),\n+               Some(Duration::new(1, 1)));\n+    assert_eq!(Duration::new(1, 0).checked_add(Duration::new(::core::u64::MAX, 0)), None);\n+}\n+\n+#[test]\n+fn sub() {\n+    assert_eq!(Duration::new(0, 1) - Duration::new(0, 0),\n+               Duration::new(0, 1));\n+    assert_eq!(Duration::new(0, 500_000_001) - Duration::new(0, 500_000_000),\n+               Duration::new(0, 1));\n+    assert_eq!(Duration::new(1, 0) - Duration::new(0, 1),\n+               Duration::new(0, 999_999_999));\n+}\n+\n+#[test]\n+fn checked_sub() {\n+    let zero = Duration::new(0, 0);\n+    let one_nano = Duration::new(0, 1);\n+    let one_sec = Duration::new(1, 0);\n+    assert_eq!(one_nano.checked_sub(zero), Some(Duration::new(0, 1)));\n+    assert_eq!(one_sec.checked_sub(one_nano),\n+               Some(Duration::new(0, 999_999_999)));\n+    assert_eq!(zero.checked_sub(one_nano), None);\n+    assert_eq!(zero.checked_sub(one_sec), None);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn sub_bad1() {\n+    let _ = Duration::new(0, 0) - Duration::new(0, 1);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn sub_bad2() {\n+    let _ = Duration::new(0, 0) - Duration::new(1, 0);\n+}\n+\n+#[test]\n+fn mul() {\n+    assert_eq!(Duration::new(0, 1) * 2, Duration::new(0, 2));\n+    assert_eq!(Duration::new(1, 1) * 3, Duration::new(3, 3));\n+    assert_eq!(Duration::new(0, 500_000_001) * 4, Duration::new(2, 4));\n+    assert_eq!(Duration::new(0, 500_000_001) * 4000,\n+               Duration::new(2000, 4000));\n+}\n+\n+#[test]\n+fn checked_mul() {\n+    assert_eq!(Duration::new(0, 1).checked_mul(2), Some(Duration::new(0, 2)));\n+    assert_eq!(Duration::new(1, 1).checked_mul(3), Some(Duration::new(3, 3)));\n+    assert_eq!(Duration::new(0, 500_000_001).checked_mul(4), Some(Duration::new(2, 4)));\n+    assert_eq!(Duration::new(0, 500_000_001).checked_mul(4000),\n+               Some(Duration::new(2000, 4000)));\n+    assert_eq!(Duration::new(::core::u64::MAX - 1, 0).checked_mul(2), None);\n+}\n+\n+#[test]\n+fn div() {\n+    assert_eq!(Duration::new(0, 1) / 2, Duration::new(0, 0));\n+    assert_eq!(Duration::new(1, 1) / 3, Duration::new(0, 333_333_333));\n+    assert_eq!(Duration::new(99, 999_999_000) / 100,\n+               Duration::new(0, 999_999_990));\n+}\n+\n+#[test]\n+fn checked_div() {\n+    assert_eq!(Duration::new(2, 0).checked_div(2), Some(Duration::new(1, 0)));\n+    assert_eq!(Duration::new(1, 0).checked_div(2), Some(Duration::new(0, 500_000_000)));\n+    assert_eq!(Duration::new(2, 0).checked_div(0), None);\n+}"}, {"sha": "8e8b1691c657a3bc0edaa12e336332e82f55a3db", "filename": "src/libcore/time.rs", "status": "modified", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -481,119 +481,3 @@ impl<'a> Sum<&'a Duration> for Duration {\n         iter.fold(Duration::new(0, 0), |a, b| a + *b)\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::Duration;\n-\n-    #[test]\n-    fn creation() {\n-        assert!(Duration::from_secs(1) != Duration::from_secs(0));\n-        assert_eq!(Duration::from_secs(1) + Duration::from_secs(2),\n-                   Duration::from_secs(3));\n-        assert_eq!(Duration::from_millis(10) + Duration::from_secs(4),\n-                   Duration::new(4, 10 * 1_000_000));\n-        assert_eq!(Duration::from_millis(4000), Duration::new(4, 0));\n-    }\n-\n-    #[test]\n-    fn secs() {\n-        assert_eq!(Duration::new(0, 0).as_secs(), 0);\n-        assert_eq!(Duration::from_secs(1).as_secs(), 1);\n-        assert_eq!(Duration::from_millis(999).as_secs(), 0);\n-        assert_eq!(Duration::from_millis(1001).as_secs(), 1);\n-    }\n-\n-    #[test]\n-    fn nanos() {\n-        assert_eq!(Duration::new(0, 0).subsec_nanos(), 0);\n-        assert_eq!(Duration::new(0, 5).subsec_nanos(), 5);\n-        assert_eq!(Duration::new(0, 1_000_000_001).subsec_nanos(), 1);\n-        assert_eq!(Duration::from_secs(1).subsec_nanos(), 0);\n-        assert_eq!(Duration::from_millis(999).subsec_nanos(), 999 * 1_000_000);\n-        assert_eq!(Duration::from_millis(1001).subsec_nanos(), 1 * 1_000_000);\n-    }\n-\n-    #[test]\n-    fn add() {\n-        assert_eq!(Duration::new(0, 0) + Duration::new(0, 1),\n-                   Duration::new(0, 1));\n-        assert_eq!(Duration::new(0, 500_000_000) + Duration::new(0, 500_000_001),\n-                   Duration::new(1, 1));\n-    }\n-\n-    #[test]\n-    fn checked_add() {\n-        assert_eq!(Duration::new(0, 0).checked_add(Duration::new(0, 1)),\n-                   Some(Duration::new(0, 1)));\n-        assert_eq!(Duration::new(0, 500_000_000).checked_add(Duration::new(0, 500_000_001)),\n-                   Some(Duration::new(1, 1)));\n-        assert_eq!(Duration::new(1, 0).checked_add(Duration::new(::u64::MAX, 0)), None);\n-    }\n-\n-    #[test]\n-    fn sub() {\n-        assert_eq!(Duration::new(0, 1) - Duration::new(0, 0),\n-                   Duration::new(0, 1));\n-        assert_eq!(Duration::new(0, 500_000_001) - Duration::new(0, 500_000_000),\n-                   Duration::new(0, 1));\n-        assert_eq!(Duration::new(1, 0) - Duration::new(0, 1),\n-                   Duration::new(0, 999_999_999));\n-    }\n-\n-    #[test]\n-    fn checked_sub() {\n-        let zero = Duration::new(0, 0);\n-        let one_nano = Duration::new(0, 1);\n-        let one_sec = Duration::new(1, 0);\n-        assert_eq!(one_nano.checked_sub(zero), Some(Duration::new(0, 1)));\n-        assert_eq!(one_sec.checked_sub(one_nano),\n-                   Some(Duration::new(0, 999_999_999)));\n-        assert_eq!(zero.checked_sub(one_nano), None);\n-        assert_eq!(zero.checked_sub(one_sec), None);\n-    }\n-\n-    #[test] #[should_panic]\n-    fn sub_bad1() {\n-        Duration::new(0, 0) - Duration::new(0, 1);\n-    }\n-\n-    #[test] #[should_panic]\n-    fn sub_bad2() {\n-        Duration::new(0, 0) - Duration::new(1, 0);\n-    }\n-\n-    #[test]\n-    fn mul() {\n-        assert_eq!(Duration::new(0, 1) * 2, Duration::new(0, 2));\n-        assert_eq!(Duration::new(1, 1) * 3, Duration::new(3, 3));\n-        assert_eq!(Duration::new(0, 500_000_001) * 4, Duration::new(2, 4));\n-        assert_eq!(Duration::new(0, 500_000_001) * 4000,\n-                   Duration::new(2000, 4000));\n-    }\n-\n-    #[test]\n-    fn checked_mul() {\n-        assert_eq!(Duration::new(0, 1).checked_mul(2), Some(Duration::new(0, 2)));\n-        assert_eq!(Duration::new(1, 1).checked_mul(3), Some(Duration::new(3, 3)));\n-        assert_eq!(Duration::new(0, 500_000_001).checked_mul(4), Some(Duration::new(2, 4)));\n-        assert_eq!(Duration::new(0, 500_000_001).checked_mul(4000),\n-                   Some(Duration::new(2000, 4000)));\n-        assert_eq!(Duration::new(::u64::MAX - 1, 0).checked_mul(2), None);\n-    }\n-\n-    #[test]\n-    fn div() {\n-        assert_eq!(Duration::new(0, 1) / 2, Duration::new(0, 0));\n-        assert_eq!(Duration::new(1, 1) / 3, Duration::new(0, 333_333_333));\n-        assert_eq!(Duration::new(99, 999_999_000) / 100,\n-                   Duration::new(0, 999_999_990));\n-    }\n-\n-    #[test]\n-    fn checked_div() {\n-        assert_eq!(Duration::new(2, 0).checked_div(2), Some(Duration::new(1, 0)));\n-        assert_eq!(Duration::new(1, 0).checked_div(2), Some(Duration::new(0, 500_000_000)));\n-        assert_eq!(Duration::new(2, 0).checked_div(0), None);\n-    }\n-}"}, {"sha": "0e6437fded594c3a18a8a5a5ed6b0fc474026ab3", "filename": "src/libcore/unicode/bool_trie.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Funicode%2Fbool_trie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibcore%2Funicode%2Fbool_trie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fbool_trie.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -42,15 +42,15 @@ pub struct BoolTrie {\n }\n impl BoolTrie {\n     pub fn lookup(&self, c: char) -> bool {\n-        let c = c as usize;\n+        let c = c as u32;\n         if c < 0x800 {\n-            trie_range_leaf(c, self.r1[c >> 6])\n+            trie_range_leaf(c, self.r1[(c >> 6) as usize])\n         } else if c < 0x10000 {\n-            let child = self.r2[(c >> 6) - 0x20];\n+            let child = self.r2[(c >> 6) as usize - 0x20];\n             trie_range_leaf(c, self.r3[child as usize])\n         } else {\n-            let child = self.r4[(c >> 12) - 0x10];\n-            let leaf = self.r5[((child as usize) << 6) + ((c >> 6) & 0x3f)];\n+            let child = self.r4[(c >> 12) as usize - 0x10];\n+            let leaf = self.r5[((child as usize) << 6) + ((c >> 6) as usize & 0x3f)];\n             trie_range_leaf(c, self.r6[leaf as usize])\n         }\n     }\n@@ -63,14 +63,14 @@ pub struct SmallBoolTrie {\n \n impl SmallBoolTrie {\n     pub fn lookup(&self, c: char) -> bool {\n-        let c = c as usize;\n-        match self.r1.get(c >> 6) {\n+        let c = c as u32;\n+        match self.r1.get((c >> 6) as usize) {\n             Some(&child) => trie_range_leaf(c, self.r2[child as usize]),\n             None => false,\n         }\n     }\n }\n \n-fn trie_range_leaf(c: usize, bitmap_chunk: u64) -> bool {\n+fn trie_range_leaf(c: u32, bitmap_chunk: u64) -> bool {\n     ((bitmap_chunk >> (c & 63)) & 1) != 0\n }"}, {"sha": "8451e5987e908d1a77067729428622723691395d", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -74,13 +74,23 @@ use syntax_pos::hygiene::Mark;\n #[derive(Clone)]\n pub struct TokenStream(tokenstream::TokenStream);\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for TokenStream {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for TokenStream {}\n+\n /// Error returned from `TokenStream::from_str`.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n #[derive(Debug)]\n pub struct LexError {\n     _inner: (),\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for LexError {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for LexError {}\n+\n impl TokenStream {\n     /// Returns an empty `TokenStream`.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n@@ -231,6 +241,11 @@ pub fn quote_span(span: Span) -> TokenStream {\n #[derive(Copy, Clone)]\n pub struct Span(syntax_pos::Span);\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for Span {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for Span {}\n+\n macro_rules! diagnostic_method {\n     ($name:ident, $level:expr) => (\n         /// Create a new `Diagnostic` with the given `message` at the span\n@@ -270,7 +285,7 @@ impl Span {\n     /// `self` was generated from, if any.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn parent(&self) -> Option<Span> {\n-        self.0.ctxt().outer().expn_info().map(|i| Span(i.call_site))\n+        self.0.parent().map(Span)\n     }\n \n     /// The span for the origin source code that `self` was generated from. If\n@@ -363,6 +378,11 @@ pub struct LineColumn {\n     pub column: usize\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for LineColumn {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for LineColumn {}\n+\n /// The source file of a given `Span`.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n #[derive(Clone)]\n@@ -393,7 +413,7 @@ impl SourceFile {\n \n     /// Returns `true` if this source file is a real source file, and not generated by an external\n     /// macro's expansion.\n-    # [unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn is_real(&self) -> bool {\n         // This is a hack until intercrate spans are implemented and we can have real source files\n         // for spans generated in external macros.\n@@ -450,6 +470,11 @@ pub enum TokenTree {\n     Literal(Literal),\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for TokenTree {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for TokenTree {}\n+\n impl TokenTree {\n     /// Returns the span of this token, accessing the `span` method of each of\n     /// the internal tokens.\n@@ -546,6 +571,11 @@ pub struct Group {\n     span: Span,\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for Group {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for Group {}\n+\n /// Describes how a sequence of token trees is delimited.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n@@ -628,6 +658,11 @@ pub struct Op {\n     span: Span,\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for Op {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for Op {}\n+\n /// Whether an `Op` is either followed immediately by another `Op` or followed by whitespace.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n@@ -694,6 +729,11 @@ pub struct Term {\n     span: Span,\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for Term {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for Term {}\n+\n impl Term {\n     /// Creates a new `Term` with the given `string` as well as the specified\n     /// `span`.\n@@ -752,6 +792,11 @@ pub struct Literal {\n     span: Span,\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for Literal {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for Literal {}\n+\n macro_rules! suffixed_int_literals {\n     ($($name:ident => $kind:ident,)*) => ($(\n         /// Creates a new suffixed integer literal with the specified value."}, {"sha": "af108188ce0f476b5d40da5a697701b1be49b65c", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -19,7 +19,6 @@ log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n proc_macro = { path = \"../libproc_macro\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n-rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "e4f432e7caf494d789bd520299e6774db9cb22bd", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -70,7 +70,8 @@ use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use std::fmt;\n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n-use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal};\n+use traits::query::{CanonicalProjectionGoal,\n+                    CanonicalTyGoal, CanonicalPredicateGoal};\n use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n use ty::subst::Substs;\n \n@@ -643,6 +644,7 @@ define_dep_nodes!( <'tcx>\n     [] NormalizeProjectionTy(CanonicalProjectionGoal<'tcx>),\n     [] NormalizeTyAfterErasingRegions(ParamEnvAnd<'tcx, Ty<'tcx>>),\n     [] DropckOutlives(CanonicalTyGoal<'tcx>),\n+    [] EvaluateObligation(CanonicalPredicateGoal<'tcx>),\n \n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n "}, {"sha": "24a1256c9d35bdf16bdaccd11a99c563f1a99f33", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -30,6 +30,8 @@ enum Target {\n     ForeignMod,\n     Expression,\n     Statement,\n+    Closure,\n+    Static,\n     Other,\n }\n \n@@ -42,6 +44,7 @@ impl Target {\n             hir::ItemEnum(..) => Target::Enum,\n             hir::ItemConst(..) => Target::Const,\n             hir::ItemForeignMod(..) => Target::ForeignMod,\n+            hir::ItemStatic(..) => Target::Static,\n             _ => Target::Other,\n         }\n     }\n@@ -101,16 +104,17 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         }\n \n         self.check_repr(item, target);\n+        self.check_used(item, target);\n     }\n \n-    /// Check if an `#[inline]` is applied to a function.\n+    /// Check if an `#[inline]` is applied to a function or a closure.\n     fn check_inline(&self, attr: &hir::Attribute, span: &Span, target: Target) {\n-        if target != Target::Fn {\n+        if target != Target::Fn && target != Target::Closure {\n             struct_span_err!(self.tcx.sess,\n                              attr.span,\n                              E0518,\n-                             \"attribute should be applied to function\")\n-                .span_label(*span, \"not a function\")\n+                             \"attribute should be applied to function or closure\")\n+                .span_label(*span, \"not a function or closure\")\n                 .emit();\n         }\n     }\n@@ -149,10 +153,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         // ```\n         let hints: Vec<_> = item.attrs\n             .iter()\n-            .filter(|attr| match attr.name() {\n-                Some(name) => name == \"repr\",\n-                None => false,\n-            })\n+            .filter(|attr| attr.name() == \"repr\")\n             .filter_map(|attr| attr.meta_item_list())\n             .flat_map(|hints| hints)\n             .collect();\n@@ -286,9 +287,13 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     }\n \n     fn check_expr_attributes(&self, expr: &hir::Expr) {\n+        let target = match expr.node {\n+            hir::ExprClosure(..) => Target::Closure,\n+            _ => Target::Expression,\n+        };\n         for attr in expr.attrs.iter() {\n             if attr.check_name(\"inline\") {\n-                self.check_inline(attr, &expr.span, Target::Expression);\n+                self.check_inline(attr, &expr.span, target);\n             }\n             if attr.check_name(\"repr\") {\n                 self.emit_repr_error(\n@@ -300,6 +305,15 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn check_used(&self, item: &hir::Item, target: Target) {\n+        for attr in &item.attrs {\n+            if attr.name() == \"used\" && target != Target::Static {\n+                self.tcx.sess\n+                    .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckAttrVisitor<'a, 'tcx> {"}, {"sha": "3e5dcee113a4ed80e47af327c29306f228b84c95", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -404,7 +404,7 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     // Intentionally visiting the expr first - the initialization expr\n     // dominates the local's definition.\n     walk_list!(visitor, visit_expr, &local.init);\n-\n+    walk_list!(visitor, visit_attribute, local.attrs.iter());\n     visitor.visit_id(local.id);\n     visitor.visit_pat(&local.pat);\n     walk_list!(visitor, visit_ty, &local.ty);\n@@ -731,6 +731,7 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n             visitor.visit_name(ty_param.span, ty_param.name);\n             walk_list!(visitor, visit_ty_param_bound, &ty_param.bounds);\n             walk_list!(visitor, visit_ty, &ty_param.default);\n+            walk_list!(visitor, visit_attribute, ty_param.attrs.iter());\n         }\n     }\n }"}, {"sha": "51f0c1d7047c91613c76e3ece8213546ec6db877", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -655,7 +655,7 @@ impl<'a> LoweringContext<'a> {\n                 self.resolver.definitions().create_def_with_parent(\n                     parent_id.index,\n                     def_node_id,\n-                    DefPathData::LifetimeDef(str_name),\n+                    DefPathData::LifetimeDef(str_name.as_interned_str()),\n                     DefIndexAddressSpace::High,\n                     Mark::root(),\n                     span,\n@@ -1302,7 +1302,7 @@ impl<'a> LoweringContext<'a> {\n                     self.context.resolver.definitions().create_def_with_parent(\n                         self.parent,\n                         def_node_id,\n-                        DefPathData::LifetimeDef(name.name().as_str()),\n+                        DefPathData::LifetimeDef(name.name().as_interned_str()),\n                         DefIndexAddressSpace::High,\n                         Mark::root(),\n                         lifetime.span,\n@@ -3119,6 +3119,20 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Index(ref el, ref er) => {\n                 hir::ExprIndex(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }\n+            // Desugar `<start>..=<end>` to `std::ops::RangeInclusive::new(<start>, <end>)`\n+            ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n+                // FIXME: Use e.span directly after RangeInclusive::new() is stabilized in stage0.\n+                let span = self.allow_internal_unstable(CompilerDesugaringKind::DotFill, e.span);\n+                let id = self.next_id();\n+                let e1 = self.lower_expr(e1);\n+                let e2 = self.lower_expr(e2);\n+                let ty_path = P(self.std_path(span, &[\"ops\", \"RangeInclusive\"], false));\n+                let ty = self.ty_path(id, span, hir::QPath::Resolved(None, ty_path));\n+                let new_seg = P(hir::PathSegment::from_name(Symbol::intern(\"new\")));\n+                let new_path = hir::QPath::TypeRelative(ty, new_seg);\n+                let new = P(self.expr(span, hir::ExprPath(new_path), ThinVec::new()));\n+                hir::ExprCall(new, hir_vec![e1, e2])\n+            }\n             ExprKind::Range(ref e1, ref e2, lims) => {\n                 use syntax::ast::RangeLimits::*;\n \n@@ -3128,7 +3142,7 @@ impl<'a> LoweringContext<'a> {\n                     (&None, &Some(..), HalfOpen) => \"RangeTo\",\n                     (&Some(..), &Some(..), HalfOpen) => \"Range\",\n                     (&None, &Some(..), Closed) => \"RangeToInclusive\",\n-                    (&Some(..), &Some(..), Closed) => \"RangeInclusive\",\n+                    (&Some(..), &Some(..), Closed) => unreachable!(),\n                     (_, &None, Closed) => self.diagnostic()\n                         .span_fatal(e.span, \"inclusive range with no end\")\n                         .raise(),\n@@ -4107,15 +4121,13 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn maybe_lint_bare_trait(&self, span: Span, id: NodeId, is_global: bool) {\n-        if self.sess.features_untracked().dyn_trait {\n-            self.sess.buffer_lint_with_diagnostic(\n-                builtin::BARE_TRAIT_OBJECT,\n-                id,\n-                span,\n-                \"trait objects without an explicit `dyn` are deprecated\",\n-                builtin::BuiltinLintDiagnostics::BareTraitObject(span, is_global),\n-            )\n-        }\n+        self.sess.buffer_lint_with_diagnostic(\n+            builtin::BARE_TRAIT_OBJECT,\n+            id,\n+            span,\n+            \"trait objects without an explicit `dyn` are deprecated\",\n+            builtin::BuiltinLintDiagnostics::BareTraitObject(span, is_global),\n+        )\n     }\n \n     fn wrap_in_try_constructor("}, {"sha": "ebd8e6235825cd4c67d2b18637a2943df72e9c75", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -107,18 +107,18 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         // information we encapsulate into\n         let def_data = match i.node {\n             ItemKind::Impl(..) => DefPathData::Impl,\n-            ItemKind::Trait(..) => DefPathData::Trait(i.ident.name.as_str()),\n+            ItemKind::Trait(..) => DefPathData::Trait(i.ident.name.as_interned_str()),\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) |\n             ItemKind::TraitAlias(..) |\n             ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n-                DefPathData::TypeNs(i.ident.name.as_str()),\n+                DefPathData::TypeNs(i.ident.name.as_interned_str()),\n             ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n                 return visit::walk_item(self, i);\n             }\n-            ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_str()),\n+            ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_interned_str()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n-                DefPathData::ValueNs(i.ident.name.as_str()),\n-            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name.as_str()),\n+                DefPathData::ValueNs(i.ident.name.as_interned_str()),\n+            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name.as_interned_str()),\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id, false),\n             ItemKind::GlobalAsm(..) => DefPathData::Misc,\n             ItemKind::Use(..) => {\n@@ -133,15 +133,16 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     for v in &enum_definition.variants {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.ident.name.as_str()),\n+                                            DefPathData::EnumVariant(v.node.ident\n+                                                                      .name.as_interned_str()),\n                                             REGULAR_SPACE,\n                                             v.span);\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n                                 let name = field.ident.map(|ident| ident.name)\n                                     .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n                                 this.create_def(field.id,\n-                                                DefPathData::Field(name.as_str()),\n+                                                DefPathData::Field(name.as_interned_str()),\n                                                 REGULAR_SPACE,\n                                                 field.span);\n                             }\n@@ -165,7 +166,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                         let name = field.ident.map(|ident| ident.name)\n                             .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n                         this.create_def(field.id,\n-                                        DefPathData::Field(name.as_str()),\n+                                        DefPathData::Field(name.as_interned_str()),\n                                         REGULAR_SPACE,\n                                         field.span);\n                     }\n@@ -187,7 +188,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         }\n \n         let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.ident.name.as_str()),\n+                                  DefPathData::ValueNs(foreign_item.ident.name.as_interned_str()),\n                                   REGULAR_SPACE,\n                                   foreign_item.span);\n \n@@ -201,15 +202,15 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             GenericParam::Lifetime(ref lifetime_def) => {\n                 self.create_def(\n                     lifetime_def.lifetime.id,\n-                    DefPathData::LifetimeDef(lifetime_def.lifetime.ident.name.as_str()),\n+                    DefPathData::LifetimeDef(lifetime_def.lifetime.ident.name.as_interned_str()),\n                     REGULAR_SPACE,\n                     lifetime_def.lifetime.ident.span\n                 );\n             }\n             GenericParam::Type(ref ty_param) => {\n                 self.create_def(\n                     ty_param.id,\n-                    DefPathData::TypeParam(ty_param.ident.name.as_str()),\n+                    DefPathData::TypeParam(ty_param.ident.name.as_interned_str()),\n                     REGULAR_SPACE,\n                     ty_param.ident.span\n                 );\n@@ -222,8 +223,10 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n         let def_data = match ti.node {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n-                DefPathData::ValueNs(ti.ident.name.as_str()),\n-            TraitItemKind::Type(..) => DefPathData::AssocTypeInTrait(ti.ident.name.as_str()),\n+                DefPathData::ValueNs(ti.ident.name.as_interned_str()),\n+            TraitItemKind::Type(..) => {\n+                DefPathData::AssocTypeInTrait(ti.ident.name.as_interned_str())\n+            },\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id, false),\n         };\n \n@@ -240,8 +243,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.ident.name.as_str()),\n-            ImplItemKind::Type(..) => DefPathData::AssocTypeInImpl(ii.ident.name.as_str()),\n+                DefPathData::ValueNs(ii.ident.name.as_interned_str()),\n+            ImplItemKind::Type(..) => DefPathData::AssocTypeInImpl(ii.ident.name.as_interned_str()),\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id, false),\n         };\n "}, {"sha": "616dc22486d92a4a4ecb4eda686383cb659d89f3", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -701,7 +701,7 @@ impl DefPathData {\n             Typeof => \"{{typeof}}\",\n         };\n \n-        Symbol::intern(s).as_str()\n+        Symbol::intern(s).as_interned_str()\n     }\n \n     pub fn to_string(&self) -> String {\n@@ -731,7 +731,7 @@ macro_rules! define_global_metadata_kind {\n                     definitions.create_def_with_parent(\n                         CRATE_DEF_INDEX,\n                         ast::DUMMY_NODE_ID,\n-                        DefPathData::GlobalMetaData(instance.name().as_str()),\n+                        DefPathData::GlobalMetaData(instance.name().as_interned_str()),\n                         GLOBAL_MD_ADDRESS_SPACE,\n                         Mark::root(),\n                         DUMMY_SP\n@@ -746,7 +746,7 @@ macro_rules! define_global_metadata_kind {\n                 let def_key = DefKey {\n                     parent: Some(CRATE_DEF_INDEX),\n                     disambiguated_data: DisambiguatedDefPathData {\n-                        data: DefPathData::GlobalMetaData(self.name().as_str()),\n+                        data: DefPathData::GlobalMetaData(self.name().as_interned_str()),\n                         disambiguator: 0,\n                     }\n                 };"}, {"sha": "5f3ff461c0c7ec5a28309a77c093c019c9e6bc5f", "filename": "src/librustc/ich/impls_const_math.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e1d5509bf381d978a1894b6ba869c3b56dd3eeca/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d5509bf381d978a1894b6ba869c3b56dd3eeca/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_const_math.rs?ref=e1d5509bf381d978a1894b6ba869c3b56dd3eeca", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This module contains `HashStable` implementations for various data types\n-//! from `rustc_const_math` in no particular order.\n-\n-impl_stable_hash_for!(struct ::rustc_const_math::ConstFloat {\n-    ty,\n-    bits\n-});\n-\n-impl_stable_hash_for!(enum ::rustc_const_math::ConstMathErr {\n-    NotInRange,\n-    CmpBetweenUnequalTypes,\n-    UnequalTypes(op),\n-    Overflow(op),\n-    ShiftNegative,\n-    DivisionByZero,\n-    RemainderByZero,\n-    UnsignedNegation,\n-    ULitOutOfRange(int_ty),\n-    LitOutOfRange(int_ty)\n-});\n-\n-impl_stable_hash_for!(enum ::rustc_const_math::Op {\n-    Add,\n-    Sub,\n-    Mul,\n-    Div,\n-    Rem,\n-    Shr,\n-    Shl,\n-    Neg,\n-    BitAnd,\n-    BitOr,\n-    BitXor\n-});"}, {"sha": "33f43e53394f59905335e50ed4420360a052ea97", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -227,27 +227,6 @@ for mir::TerminatorKind<'gcx> {\n     }\n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for mir::AssertMessage<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n-                len.hash_stable(hcx, hasher);\n-                index.hash_stable(hcx, hasher);\n-            }\n-            mir::AssertMessage::Math(ref const_math_err) => {\n-                const_math_err.hash_stable(hcx, hasher);\n-            }\n-            mir::AssertMessage::GeneratorResumedAfterReturn => (),\n-            mir::AssertMessage::GeneratorResumedAfterPanic => (),\n-        }\n-    }\n-}\n-\n impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n \n impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n@@ -563,6 +542,11 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Literal<'gcx> {\n \n impl_stable_hash_for!(struct mir::Location { block, statement_index });\n \n+impl_stable_hash_for!(struct mir::BorrowCheckResult<'tcx> {\n+    closure_requirements,\n+    used_mut_upvars\n+});\n+\n impl_stable_hash_for!(struct mir::ClosureRegionRequirements<'tcx> {\n     num_external_vids,\n     outlives_requirements"}, {"sha": "1cf9b7bf4780e785a8a2b52a4035201fc7e465ce", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -19,7 +19,7 @@ use std::mem;\n use syntax::ast;\n use syntax::feature_gate;\n use syntax::parse::token;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::{InternedString, LocalInternedString};\n use syntax::tokenstream;\n use syntax_pos::FileMap;\n \n@@ -34,8 +34,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for InternedString {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        let s: &str = &**self;\n-        s.hash_stable(hcx, hasher);\n+        self.with(|s| s.hash_stable(hcx, hasher))\n     }\n }\n \n@@ -50,6 +49,27 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for InternedString {\n     }\n }\n \n+impl<'a> HashStable<StableHashingContext<'a>> for LocalInternedString {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let s: &str = &**self;\n+        s.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for LocalInternedString {\n+    type KeyType = LocalInternedString;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self,\n+                          _: &StableHashingContext<'a>)\n+                          -> LocalInternedString {\n+        self.clone()\n+    }\n+}\n+\n impl<'a> HashStable<StableHashingContext<'a>> for ast::Name {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -66,7 +86,7 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::Name {\n     fn to_stable_hash_key(&self,\n                           _: &StableHashingContext<'a>)\n                           -> InternedString {\n-        self.as_str()\n+        self.as_interned_str()\n     }\n }\n \n@@ -179,8 +199,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n         let filtered: AccumulateVec<[&ast::Attribute; 8]> = self\n             .iter()\n             .filter(|attr| {\n-                !attr.is_sugared_doc &&\n-                attr.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true)\n+                !attr.is_sugared_doc && !hcx.is_ignored_attr(attr.name())\n             })\n             .collect();\n \n@@ -191,12 +210,23 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n     }\n }\n \n+impl<'a> HashStable<StableHashingContext<'a>> for ast::Path {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.segments.len().hash_stable(hcx, hasher);\n+        for segment in &self.segments {\n+            segment.ident.name.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         // Make sure that these have been filtered out.\n-        debug_assert!(self.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true));\n+        debug_assert!(!hcx.is_ignored_attr(self.name()));\n         debug_assert!(!self.is_sugared_doc);\n \n         let ast::Attribute {\n@@ -209,10 +239,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n         } = *self;\n \n         style.hash_stable(hcx, hasher);\n-        path.segments.len().hash_stable(hcx, hasher);\n-        for segment in &path.segments {\n-            segment.ident.name.hash_stable(hcx, hasher);\n-        }\n+        path.hash_stable(hcx, hasher);\n         for tt in tokens.trees() {\n             tt.hash_stable(hcx, hasher);\n         }"}, {"sha": "a40d8e09277406397ec1415f75e77afb8fb7b002", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -505,9 +505,6 @@ for ::middle::const_val::ErrKind<'gcx> {\n                 len.hash_stable(hcx, hasher);\n                 index.hash_stable(hcx, hasher);\n             }\n-            Math(ref const_math_err) => {\n-                const_math_err.hash_stable(hcx, hasher);\n-            }\n             LayoutError(ref layout_error) => {\n                 layout_error.hash_stable(hcx, hasher);\n             }\n@@ -528,16 +525,26 @@ impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     predicates\n });\n \n+\n impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ::mir::interpret::EvalError<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.kind.hash_stable(hcx, hasher)\n+    }\n+}\n+\n+impl<'a, 'gcx, O: HashStable<StableHashingContext<'a>>> HashStable<StableHashingContext<'a>>\n+for ::mir::interpret::EvalErrorKind<'gcx, O> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use mir::interpret::EvalErrorKind::*;\n \n-        mem::discriminant(&self.kind).hash_stable(hcx, hasher);\n+        mem::discriminant(&self).hash_stable(hcx, hasher);\n \n-        match self.kind {\n+        match *self {\n             DanglingPointerDeref |\n             DoubleFree |\n             InvalidMemoryAccess |\n@@ -568,8 +575,12 @@ for ::mir::interpret::EvalError<'gcx> {\n             TypeckError |\n             DerefFunctionPointer |\n             ExecuteMemory |\n-            ReferencedConstant |\n-            OverflowingMath => {}\n+            OverflowNeg |\n+            RemainderByZero |\n+            DivisionByZero |\n+            GeneratorResumedAfterReturn |\n+            GeneratorResumedAfterPanic |\n+            ReferencedConstant => {}\n             MachineError(ref err) => err.hash_stable(hcx, hasher),\n             FunctionPointerTyMismatch(a, b) => {\n                 a.hash_stable(hcx, hasher);\n@@ -588,14 +599,9 @@ for ::mir::interpret::EvalError<'gcx> {\n             },\n             InvalidBoolOp(bop) => bop.hash_stable(hcx, hasher),\n             Unimplemented(ref s) => s.hash_stable(hcx, hasher),\n-            ArrayIndexOutOfBounds(sp, a, b) => {\n-                sp.hash_stable(hcx, hasher);\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher)\n-            },\n-            Math(sp, ref err) => {\n-                sp.hash_stable(hcx, hasher);\n-                err.hash_stable(hcx, hasher)\n+            BoundsCheck { ref len, ref index } => {\n+                len.hash_stable(hcx, hasher);\n+                index.hash_stable(hcx, hasher)\n             },\n             Intrinsic(ref s) => s.hash_stable(hcx, hasher),\n             InvalidChar(c) => c.hash_stable(hcx, hasher),\n@@ -668,6 +674,7 @@ for ::mir::interpret::EvalError<'gcx> {\n             Layout(lay) => lay.hash_stable(hcx, hasher),\n             HeapAllocNonPowerOfTwoAlignment(n) => n.hash_stable(hcx, hasher),\n             PathNotFound(ref v) => v.hash_stable(hcx, hasher),\n+            Overflow(op) => op.hash_stable(hcx, hasher),\n         }\n     }\n }"}, {"sha": "a0c6bbbb2393f83929c88980f2740ac515d6f4dc", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -18,7 +18,6 @@ mod fingerprint;\n mod caching_codemap_view;\n mod hcx;\n \n-mod impls_const_math;\n mod impls_cstore;\n mod impls_hir;\n mod impls_mir;"}, {"sha": "ccba5a09cf6cc92433f3430288ad30cb567d4389", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -407,7 +407,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                             drop(variables);\n                             self.relate(&u, &u)\n                         }\n-                        TypeVariableValue::Unknown { .. } => {\n+                        TypeVariableValue::Unknown { universe } => {\n                             match self.ambient_variance {\n                                 // Invariant: no need to make a fresh type variable.\n                                 ty::Invariant => return Ok(t),\n@@ -424,7 +424,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                             }\n \n                             let origin = *variables.var_origin(vid);\n-                            let new_var_id = variables.new_var(false, origin);\n+                            let new_var_id = variables.new_var(universe, false, origin);\n                             let u = self.tcx().mk_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n                                    vid, u);"}, {"sha": "b8437e39ddca48c6118fbbc91ba5e0b52fed6297", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -19,7 +19,7 @@ use super::{CombinedSnapshot,\n use super::combine::CombineFields;\n use super::region_constraints::{TaintDirections};\n \n-use std::collections::BTreeMap;\n+use rustc_data_structures::lazy_btree_map::LazyBTreeMap;\n use ty::{self, TyCtxt, Binder, TypeFoldable};\n use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n@@ -62,7 +62,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // Second, we instantiate each bound region in the supertype with a\n             // fresh concrete region.\n             let (b_prime, skol_map) =\n-                self.infcx.skolemize_late_bound_regions(b, snapshot);\n+                self.infcx.skolemize_late_bound_regions(b);\n \n             debug!(\"a_prime={:?}\", a_prime);\n             debug!(\"b_prime={:?}\", b_prime);\n@@ -114,7 +114,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // First, we instantiate each bound region in the matcher\n             // with a skolemized region.\n             let ((a_match, a_value), skol_map) =\n-                self.infcx.skolemize_late_bound_regions(a_pair, snapshot);\n+                self.infcx.skolemize_late_bound_regions(a_pair);\n \n             debug!(\"higher_ranked_match: a_match={:?}\", a_match);\n             debug!(\"higher_ranked_match: skol_map={:?}\", skol_map);\n@@ -247,7 +247,8 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot<'a, 'tcx>,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n+                                             a_map: &LazyBTreeMap<ty::BoundRegion,\n+                                                                  ty::Region<'tcx>>,\n                                              r0: ty::Region<'tcx>)\n                                              -> ty::Region<'tcx> {\n             // Regions that pre-dated the LUB computation stay as they are.\n@@ -343,7 +344,8 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot<'a, 'tcx>,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n+                                             a_map: &LazyBTreeMap<ty::BoundRegion,\n+                                                                  ty::Region<'tcx>>,\n                                              a_vars: &[ty::RegionVid],\n                                              b_vars: &[ty::RegionVid],\n                                              r0: ty::Region<'tcx>)\n@@ -412,7 +414,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn rev_lookup<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                       span: Span,\n-                                      a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n+                                      a_map: &LazyBTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n                                       r: ty::Region<'tcx>) -> ty::Region<'tcx>\n         {\n             for (a_br, a_r) in a_map {\n@@ -435,7 +437,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n }\n \n fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n-                           map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+                           map: &LazyBTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n                            -> Vec<ty::RegionVid> {\n     map.iter()\n        .map(|(_, &r)| match *r {\n@@ -585,14 +587,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-hrtb.html\n     pub fn skolemize_late_bound_regions<T>(&self,\n-                                           binder: &ty::Binder<T>,\n-                                           snapshot: &CombinedSnapshot<'a, 'tcx>)\n+                                           binder: &ty::Binder<T>)\n                                            -> (T, SkolemizationMap<'tcx>)\n         where T : TypeFoldable<'tcx>\n     {\n         let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n-            self.borrow_region_constraints()\n-                .push_skolemized(self.tcx, br, &snapshot.region_constraints_snapshot)\n+            self.universe.set(self.universe().subuniverse());\n+            self.tcx.mk_region(ty::ReSkolemized(self.universe(), br))\n         });\n \n         debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n@@ -777,7 +778,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"pop_skolemized({:?})\", skol_map);\n         let skol_regions: FxHashSet<_> = skol_map.values().cloned().collect();\n         self.borrow_region_constraints()\n-            .pop_skolemized(self.tcx, &skol_regions, &snapshot.region_constraints_snapshot);\n+            .pop_skolemized(self.universe(), &skol_regions, &snapshot.region_constraints_snapshot);\n+        self.universe.set(snapshot.universe);\n         if !skol_map.is_empty() {\n             self.projection_cache.borrow_mut().rollback_skolemized(\n                 &snapshot.projection_cache_snapshot);"}, {"sha": "5984a831e6fa0eeb4028a539040af99763d2de31", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -15,7 +15,7 @@ use infer::RegionVariableOrigin;\n use infer::region_constraints::Constraint;\n use infer::region_constraints::GenericKind;\n use infer::region_constraints::RegionConstraintData;\n-use infer::region_constraints::VarOrigins;\n+use infer::region_constraints::VarInfos;\n use infer::region_constraints::VerifyBound;\n use middle::free_region::RegionRelations;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -37,7 +37,7 @@ mod graphviz;\n /// all the variables as well as a set of errors that must be reported.\n pub fn resolve<'tcx>(\n     region_rels: &RegionRelations<'_, '_, 'tcx>,\n-    var_origins: VarOrigins,\n+    var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n ) -> (\n     LexicalRegionResolutions<'tcx>,\n@@ -47,7 +47,7 @@ pub fn resolve<'tcx>(\n     let mut errors = vec![];\n     let mut resolver = LexicalResolver {\n         region_rels,\n-        var_origins,\n+        var_infos,\n         data,\n     };\n     let values = resolver.infer_variable_values(&mut errors);\n@@ -103,7 +103,7 @@ type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n \n struct LexicalResolver<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     region_rels: &'cx RegionRelations<'cx, 'gcx, 'tcx>,\n-    var_origins: VarOrigins,\n+    var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n }\n \n@@ -132,7 +132,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     }\n \n     fn num_vars(&self) -> usize {\n-        self.var_origins.len()\n+        self.var_infos.len()\n     }\n \n     /// Initially, the value for all variables is set to `'empty`, the\n@@ -279,7 +279,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n             (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n                 span_bug!(\n-                    self.var_origins[v_id].span(),\n+                    self.var_infos[v_id].origin.span(),\n                     \"lub_concrete_regions invoked with non-concrete \\\n                      regions: {:?}, {:?}\",\n                     a,\n@@ -576,7 +576,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                 if !self.region_rels\n                     .is_subregion_of(lower_bound.region, upper_bound.region)\n                 {\n-                    let origin = self.var_origins[node_idx].clone();\n+                    let origin = self.var_infos[node_idx].origin.clone();\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n                          sup: {:?}\",\n@@ -598,7 +598,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         }\n \n         span_bug!(\n-            self.var_origins[node_idx].span(),\n+            self.var_infos[node_idx].origin.span(),\n             \"collect_error_for_expanding_node() could not find \\\n              error for var {:?}, lower_bounds={:?}, \\\n              upper_bounds={:?}\","}, {"sha": "c62e7f8d9b6350a8a20350625a08c0b9f8039909", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -28,9 +28,9 @@ use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::TypeFoldable;\n use ty::relate::RelateResult;\n use traits::{self, ObligationCause, PredicateObligations};\n+use rustc_data_structures::lazy_btree_map::LazyBTreeMap;\n use rustc_data_structures::unify as ut;\n use std::cell::{Cell, RefCell, Ref, RefMut};\n-use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n@@ -42,7 +42,7 @@ use arena::SyncDroplessArena;\n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n-use self::region_constraints::{GenericKind, VerifyBound, RegionConstraintData, VarOrigins};\n+use self::region_constraints::{GenericKind, VerifyBound, RegionConstraintData, VarInfos};\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n use self::type_variable::TypeVariableOrigin;\n@@ -183,11 +183,22 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // obligations within. This is expected to be done 'late enough'\n     // that all type inference variables have been bound and so forth.\n     pub region_obligations: RefCell<Vec<(ast::NodeId, RegionObligation<'tcx>)>>,\n+\n+    /// What is the innermost universe we have created? Starts out as\n+    /// `UniverseIndex::root()` but grows from there as we enter\n+    /// universal quantifiers.\n+    ///\n+    /// NB: At present, we exclude the universal quantifiers on the\n+    /// item we are type-checking, and just consider those names as\n+    /// part of the root universe. So this would only get incremented\n+    /// when we enter into a higher-ranked (`for<..>`) type or trait\n+    /// bound.\n+    universe: Cell<ty::UniverseIndex>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n /// region that each late-bound region was replaced with.\n-pub type SkolemizationMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n+pub type SkolemizationMap<'tcx> = LazyBTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n \n /// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n@@ -455,6 +466,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             err_count_on_creation: tcx.sess.err_count(),\n             in_snapshot: Cell::new(false),\n             region_obligations: RefCell::new(vec![]),\n+            universe: Cell::new(ty::UniverseIndex::ROOT),\n         }))\n     }\n }\n@@ -489,6 +501,7 @@ pub struct CombinedSnapshot<'a, 'tcx:'a> {\n     float_snapshot: ut::Snapshot<ut::InPlace<ty::FloatVid>>,\n     region_constraints_snapshot: RegionSnapshot,\n     region_obligations_snapshot: usize,\n+    universe: ty::UniverseIndex,\n     was_in_snapshot: bool,\n     _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n }\n@@ -618,6 +631,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n             region_constraints_snapshot: self.borrow_region_constraints().start_snapshot(),\n             region_obligations_snapshot: self.region_obligations.borrow().len(),\n+            universe: self.universe(),\n             was_in_snapshot: in_snapshot,\n             // Borrow tables \"in progress\" (i.e. during typeck)\n             // to ban writes from within a snapshot to them.\n@@ -635,10 +649,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                float_snapshot,\n                                region_constraints_snapshot,\n                                region_obligations_snapshot,\n+                               universe,\n                                was_in_snapshot,\n                                _in_progress_tables } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n+        self.universe.set(universe);\n \n         self.projection_cache\n             .borrow_mut()\n@@ -667,6 +683,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                float_snapshot,\n                                region_constraints_snapshot,\n                                region_obligations_snapshot: _,\n+                               universe: _,\n                                was_in_snapshot,\n                                _in_progress_tables } = snapshot;\n \n@@ -811,7 +828,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         Some(self.commit_if_ok(|snapshot| {\n             let (ty::SubtypePredicate { a_is_expected, a, b}, skol_map) =\n-                self.skolemize_late_bound_regions(predicate, snapshot);\n+                self.skolemize_late_bound_regions(predicate);\n \n             let cause_span = cause.span;\n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n@@ -828,7 +845,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n-                self.skolemize_late_bound_regions(predicate, snapshot);\n+                self.skolemize_late_bound_regions(predicate);\n             let origin =\n                 SubregionOrigin::from_obligation_cause(cause,\n                                                        || RelateRegionParamBound(cause.span));\n@@ -841,7 +858,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n         self.type_variables\n             .borrow_mut()\n-            .new_var(diverging, origin)\n+            .new_var(self.universe(), diverging, origin)\n     }\n \n     pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n@@ -872,12 +889,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///   during diagnostics / error-reporting.\n     pub fn next_region_var(&self, origin: RegionVariableOrigin)\n                            -> ty::Region<'tcx> {\n-        self.tcx.mk_region(ty::ReVar(self.borrow_region_constraints().new_region_var(origin)))\n+        let region_var = self.borrow_region_constraints()\n+            .new_region_var(self.universe(), origin);\n+        self.tcx.mk_region(ty::ReVar(region_var))\n     }\n \n     /// Number of region variables created so far.\n     pub fn num_region_vars(&self) -> usize {\n-        self.borrow_region_constraints().var_origins().len()\n+        self.borrow_region_constraints().num_region_vars()\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n@@ -909,7 +928,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             -> Ty<'tcx> {\n         let ty_var_id = self.type_variables\n                             .borrow_mut()\n-                            .new_var(false,\n+                            .new_var(self.universe(),\n+                                     false,\n                                      TypeVariableOrigin::TypeParameterDefinition(span, def.name));\n \n         self.tcx.mk_var(ty_var_id)\n@@ -1004,12 +1024,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                 region_context,\n                                                 region_map,\n                                                 outlives_env.free_region_map());\n-        let (var_origins, data) = self.region_constraints.borrow_mut()\n+        let (var_infos, data) = self.region_constraints.borrow_mut()\n                                                          .take()\n                                                          .expect(\"regions already resolved\")\n-                                                         .into_origins_and_data();\n+                                                         .into_infos_and_data();\n         let (lexical_region_resolutions, errors) =\n-            lexical_region_resolve::resolve(region_rels, var_origins, data);\n+            lexical_region_resolve::resolve(region_rels, var_infos, data);\n \n         let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());\n@@ -1057,13 +1077,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// hence that `resolve_regions_and_report_errors` can never be\n     /// called. This is used only during NLL processing to \"hand off\" ownership\n     /// of the set of region vairables into the NLL region context.\n-    pub fn take_region_var_origins(&self) -> VarOrigins {\n-        let (var_origins, data) = self.region_constraints.borrow_mut()\n+    pub fn take_region_var_origins(&self) -> VarInfos {\n+        let (var_infos, data) = self.region_constraints.borrow_mut()\n                                                          .take()\n                                                          .expect(\"regions already resolved\")\n-                                                         .into_origins_and_data();\n+                                                         .into_infos_and_data();\n         assert!(data.is_empty());\n-        var_origins\n+        var_infos\n     }\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n@@ -1216,7 +1236,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n         value: &ty::Binder<T>)\n-        -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+        -> (T, LazyBTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where T : TypeFoldable<'tcx>\n     {\n         self.tcx.replace_late_bound_regions(\n@@ -1356,6 +1376,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.evaluation_cache.clear();\n         self.projection_cache.borrow_mut().clear();\n     }\n+\n+    fn universe(&self) -> ty::UniverseIndex {\n+        self.universe.get()\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {"}, {"sha": "c388fa21371923ae3e23e3fd25c2bbf86c4e31e6", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 67, "deletions": 97, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -22,18 +22,16 @@ use rustc_data_structures::unify as ut;\n use ty::{self, Ty, TyCtxt};\n use ty::{Region, RegionVid};\n use ty::ReStatic;\n-use ty::{BrFresh, ReLateBound, ReSkolemized, ReVar};\n+use ty::{BrFresh, ReLateBound, ReVar};\n \n use std::collections::BTreeMap;\n-use std::fmt;\n-use std::mem;\n-use std::u32;\n+use std::{cmp, fmt, mem, u32};\n \n mod taint;\n \n pub struct RegionConstraintCollector<'tcx> {\n     /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.\n-    var_origins: IndexVec<RegionVid, RegionVariableOrigin>,\n+    var_infos: IndexVec<RegionVid, RegionVariableInfo>,\n \n     data: RegionConstraintData<'tcx>,\n \n@@ -47,9 +45,6 @@ pub struct RegionConstraintCollector<'tcx> {\n     /// exist). This prevents us from making many such regions.\n     glbs: CombineMap<'tcx>,\n \n-    /// Number of skolemized variables currently active.\n-    skolemization_count: u32,\n-\n     /// Global counter used during the GLB algorithm to create unique\n     /// names for fresh bound regions\n     bound_count: u32,\n@@ -76,7 +71,7 @@ pub struct RegionConstraintCollector<'tcx> {\n     unification_table: ut::UnificationTable<ut::InPlace<ty::RegionVid>>,\n }\n \n-pub type VarOrigins = IndexVec<RegionVid, RegionVariableOrigin>;\n+pub type VarInfos = IndexVec<RegionVid, RegionVariableInfo>;\n \n /// The full set of region constraints gathered up by the collector.\n /// Describes constraints between the region variables and other\n@@ -230,10 +225,15 @@ enum CombineMapType {\n \n type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n+#[derive(Debug, Clone, Copy)]\n+pub struct RegionVariableInfo {\n+    pub origin: RegionVariableOrigin,\n+    pub universe: ty::UniverseIndex,\n+}\n+\n pub struct RegionSnapshot {\n     length: usize,\n     region_snapshot: ut::Snapshot<ut::InPlace<ty::RegionVid>>,\n-    skolemization_count: u32,\n }\n \n /// When working with skolemized regions, we often wish to find all of\n@@ -273,19 +273,18 @@ impl TaintDirections {\n impl<'tcx> RegionConstraintCollector<'tcx> {\n     pub fn new() -> RegionConstraintCollector<'tcx> {\n         RegionConstraintCollector {\n-            var_origins: VarOrigins::default(),\n+            var_infos: VarInfos::default(),\n             data: RegionConstraintData::default(),\n             lubs: FxHashMap(),\n             glbs: FxHashMap(),\n-            skolemization_count: 0,\n             bound_count: 0,\n             undo_log: Vec::new(),\n             unification_table: ut::UnificationTable::new(),\n         }\n     }\n \n-    pub fn var_origins(&self) -> &VarOrigins {\n-        &self.var_origins\n+    pub fn num_region_vars(&self) -> usize {\n+        self.var_infos.len()\n     }\n \n     pub fn region_constraint_data(&self) -> &RegionConstraintData<'tcx> {\n@@ -295,9 +294,9 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// Once all the constraints have been gathered, extract out the final data.\n     ///\n     /// Not legal during a snapshot.\n-    pub fn into_origins_and_data(self) -> (VarOrigins, RegionConstraintData<'tcx>) {\n+    pub fn into_infos_and_data(self) -> (VarInfos, RegionConstraintData<'tcx>) {\n         assert!(!self.in_snapshot());\n-        (self.var_origins, self.data)\n+        (self.var_infos, self.data)\n     }\n \n     /// Takes (and clears) the current set of constraints. Note that\n@@ -319,18 +318,15 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         // should think carefully about whether it needs to be cleared\n         // or updated in some way.\n         let RegionConstraintCollector {\n-            var_origins,\n+            var_infos,\n             data,\n             lubs,\n             glbs,\n-            skolemization_count,\n             bound_count: _,\n             undo_log: _,\n             unification_table,\n         } = self;\n \n-        assert_eq!(*skolemization_count, 0);\n-\n         // Clear the tables of (lubs, glbs), so that we will create\n         // fresh regions if we do a LUB operation. As it happens,\n         // LUB/GLB are not performed by the MIR type-checker, which is\n@@ -343,7 +339,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         // also insert `a <= b` and a `b <= a` edges, so the\n         // `RegionConstraintData` contains the relationship here.\n         *unification_table = ut::UnificationTable::new();\n-        for vid in var_origins.indices() {\n+        for vid in var_infos.indices() {\n             unification_table.new_key(unify_key::RegionVidKey { min_vid: vid });\n         }\n \n@@ -365,20 +361,13 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         RegionSnapshot {\n             length,\n             region_snapshot: self.unification_table.snapshot(),\n-            skolemization_count: self.skolemization_count,\n         }\n     }\n \n     pub fn commit(&mut self, snapshot: RegionSnapshot) {\n         debug!(\"RegionConstraintCollector: commit({})\", snapshot.length);\n         assert!(self.undo_log.len() > snapshot.length);\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n-        assert!(\n-            self.skolemization_count == snapshot.skolemization_count,\n-            \"failed to pop skolemized regions: {} now vs {} at start\",\n-            self.skolemization_count,\n-            snapshot.skolemization_count\n-        );\n \n         if snapshot.length == 0 {\n             self.undo_log.truncate(0);\n@@ -398,7 +387,6 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n         let c = self.undo_log.pop().unwrap();\n         assert!(c == OpenSnapshot);\n-        self.skolemization_count = snapshot.skolemization_count;\n         self.unification_table.rollback_to(snapshot.region_snapshot);\n     }\n \n@@ -411,8 +399,8 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n                 // nothing to do here\n             }\n             AddVar(vid) => {\n-                self.var_origins.pop().unwrap();\n-                assert_eq!(self.var_origins.len(), vid.index() as usize);\n+                self.var_infos.pop().unwrap();\n+                assert_eq!(self.var_infos.len(), vid.index() as usize);\n             }\n             AddConstraint(ref constraint) => {\n                 self.data.constraints.remove(constraint);\n@@ -433,8 +421,13 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n-    pub fn new_region_var(&mut self, origin: RegionVariableOrigin) -> RegionVid {\n-        let vid = self.var_origins.push(origin.clone());\n+    pub fn new_region_var(&mut self,\n+                          universe: ty::UniverseIndex,\n+                          origin: RegionVariableOrigin) -> RegionVid {\n+        let vid = self.var_infos.push(RegionVariableInfo {\n+            origin,\n+            universe,\n+        });\n \n         let u_vid = self.unification_table\n             .new_key(unify_key::RegionVidKey { min_vid: vid });\n@@ -450,44 +443,14 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         return vid;\n     }\n \n-    /// Returns the origin for the given variable.\n-    pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n-        self.var_origins[vid].clone()\n+    /// Returns the universe for the given variable.\n+    pub fn var_universe(&self, vid: RegionVid) -> ty::UniverseIndex {\n+        self.var_infos[vid].universe\n     }\n \n-    /// Creates a new skolemized region. Skolemized regions are fresh\n-    /// regions used when performing higher-ranked computations. They\n-    /// must be used in a very particular way and are never supposed\n-    /// to \"escape\" out into error messages or the code at large.\n-    ///\n-    /// The idea is to always create a snapshot. Skolemized regions\n-    /// can be created in the context of this snapshot, but before the\n-    /// snapshot is committed or rolled back, they must be popped\n-    /// (using `pop_skolemized_regions`), so that their numbers can be\n-    /// recycled. Normally you don't have to think about this: you use\n-    /// the APIs in `higher_ranked/mod.rs`, such as\n-    /// `skolemize_late_bound_regions` and `plug_leaks`, which will\n-    /// guide you on this path (ensure that the `SkolemizationMap` is\n-    /// consumed and you are good). For more info on how skolemization\n-    /// for HRTBs works, see the [rustc guide].\n-    ///\n-    /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-hrtb.html\n-    ///\n-    /// The `snapshot` argument to this function is not really used;\n-    /// it's just there to make it explicit which snapshot bounds the\n-    /// skolemized region that results. It should always be the top-most snapshot.\n-    pub fn push_skolemized(\n-        &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        br: ty::BoundRegion,\n-        snapshot: &RegionSnapshot,\n-    ) -> Region<'tcx> {\n-        assert!(self.in_snapshot());\n-        assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n-\n-        let sc = self.skolemization_count;\n-        self.skolemization_count = sc + 1;\n-        tcx.mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n+    /// Returns the origin for the given variable.\n+    pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n+        self.var_infos[vid].origin\n     }\n \n     /// Removes all the edges to/from the skolemized regions that are\n@@ -496,7 +459,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// created in that time.\n     pub fn pop_skolemized(\n         &mut self,\n-        _tcx: TyCtxt<'_, '_, 'tcx>,\n+        skolemization_count: ty::UniverseIndex,\n         skols: &FxHashSet<ty::Region<'tcx>>,\n         snapshot: &RegionSnapshot,\n     ) {\n@@ -505,36 +468,28 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n         assert!(\n-            self.skolemization_count as usize >= skols.len(),\n+            skolemization_count.as_usize() >= skols.len(),\n             \"popping more skolemized variables than actually exist, \\\n-             sc now = {}, skols.len = {}\",\n-            self.skolemization_count,\n+             sc now = {:?}, skols.len = {:?}\",\n+            skolemization_count,\n             skols.len()\n         );\n \n-        let last_to_pop = self.skolemization_count;\n-        let first_to_pop = last_to_pop - (skols.len() as u32);\n+        let last_to_pop = skolemization_count.subuniverse();\n+        let first_to_pop = ty::UniverseIndex::from(last_to_pop.as_u32() - skols.len() as u32);\n \n-        assert!(\n-            first_to_pop >= snapshot.skolemization_count,\n-            \"popping more regions than snapshot contains, \\\n-             sc now = {}, sc then = {}, skols.len = {}\",\n-            self.skolemization_count,\n-            snapshot.skolemization_count,\n-            skols.len()\n-        );\n         debug_assert! {\n             skols.iter()\n                  .all(|&k| match *k {\n-                     ty::ReSkolemized(index, _) =>\n-                         index.index >= first_to_pop &&\n-                         index.index < last_to_pop,\n+                     ty::ReSkolemized(universe, _) =>\n+                         universe >= first_to_pop &&\n+                         universe < last_to_pop,\n                      _ =>\n                          false\n                  }),\n-            \"invalid skolemization keys or keys out of range ({}..{}): {:?}\",\n-            snapshot.skolemization_count,\n-            self.skolemization_count,\n+            \"invalid skolemization keys or keys out of range ({:?}..{:?}): {:?}\",\n+            first_to_pop,\n+            last_to_pop,\n             skols\n         }\n \n@@ -551,7 +506,6 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             self.rollback_undo_entry(undo_entry);\n         }\n \n-        self.skolemization_count = snapshot.skolemization_count;\n         return;\n \n         fn kill_constraint<'tcx>(\n@@ -805,7 +759,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         if let Some(&c) = self.combine_map(t).get(&vars) {\n             return tcx.mk_region(ReVar(c));\n         }\n-        let c = self.new_region_var(MiscVariable(origin.span()));\n+        let a_universe = self.universe(a);\n+        let b_universe = self.universe(b);\n+        let c_universe = cmp::max(a_universe, b_universe);\n+        let c = self.new_region_var(c_universe, MiscVariable(origin.span()));\n         self.combine_map(t).insert(vars, c);\n         if self.in_snapshot() {\n             self.undo_log.push(AddCombination(t, vars));\n@@ -821,6 +778,24 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         new_r\n     }\n \n+    fn universe(&self, region: Region<'tcx>) -> ty::UniverseIndex {\n+        match *region {\n+            ty::ReScope(..) |\n+            ty::ReStatic |\n+            ty::ReEmpty |\n+            ty::ReErased |\n+            ty::ReFree(..) |\n+            ty::ReEarlyBound(..) => ty::UniverseIndex::ROOT,\n+            ty::ReSkolemized(universe, _) => universe,\n+            ty::ReClosureBound(vid) |\n+            ty::ReVar(vid) => self.var_universe(vid),\n+            ty::ReLateBound(..) =>\n+                bug!(\"universe(): encountered bound region {:?}\", region),\n+            ty::ReCanonical(..) =>\n+                bug!(\"region_universe(): encountered canonical region {:?}\", region),\n+        }\n+    }\n+\n     pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot) -> Vec<RegionVid> {\n         self.undo_log[mark.length..]\n             .iter()\n@@ -865,12 +840,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n impl fmt::Debug for RegionSnapshot {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(\n-            f,\n-            \"RegionSnapshot(length={},skolemization={})\",\n-            self.length,\n-            self.skolemization_count\n-        )\n+        write!(f, \"RegionSnapshot(length={})\", self.length)\n     }\n }\n "}, {"sha": "d40e1b3760f0361a2bcf62877c1f528d46159269", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -78,10 +78,12 @@ struct TypeVariableData {\n #[derive(Copy, Clone, Debug)]\n pub enum TypeVariableValue<'tcx> {\n     Known { value: Ty<'tcx> },\n-    Unknown,\n+    Unknown { universe: ty::UniverseIndex },\n }\n \n impl<'tcx> TypeVariableValue<'tcx> {\n+    /// If this value is known, returns the type it is known to be.\n+    /// Otherwise, `None`.\n     pub fn known(&self) -> Option<Ty<'tcx>> {\n         match *self {\n             TypeVariableValue::Unknown { .. } => None,\n@@ -181,10 +183,11 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///   The code in this module doesn't care, but it can be useful\n     ///   for improving error messages.\n     pub fn new_var(&mut self,\n+                   universe: ty::UniverseIndex,\n                    diverging: bool,\n                    origin: TypeVariableOrigin)\n                    -> ty::TyVid {\n-        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown);\n+        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown { universe });\n \n         let sub_key = self.sub_relations.new_key(());\n         assert_eq!(eq_key.vid, sub_key);\n@@ -437,7 +440,16 @@ impl<'tcx> ut::UnifyValue for TypeVariableValue<'tcx> {\n             (&TypeVariableValue::Unknown { .. }, &TypeVariableValue::Known { .. }) => Ok(*value2),\n \n             // If both sides are *unknown*, it hardly matters, does it?\n-            (&TypeVariableValue::Unknown, &TypeVariableValue::Unknown) => Ok(*value1),\n+            (&TypeVariableValue::Unknown { universe: universe1 },\n+             &TypeVariableValue::Unknown { universe: universe2 }) =>  {\n+                // If we unify two unbound variables, ?T and ?U, then whatever\n+                // value they wind up taking (which must be the same value) must\n+                // be nameable by both universes. Therefore, the resulting\n+                // universe is the minimum of the two universes, because that is\n+                // the one which contains the fewest names in scope.\n+                let universe = cmp::min(universe1, universe2);\n+                Ok(TypeVariableValue::Unknown { universe })\n+            }\n         }\n     }\n }"}, {"sha": "879d38c4894435613efa148027289b1f64281672", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -45,8 +45,8 @@\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n-#![feature(dyn_trait)]\n #![feature(entry_or_default)]\n+#![cfg_attr(stage0, feature(dyn_trait))]\n #![feature(from_ref)]\n #![feature(fs_read_write)]\n #![cfg_attr(windows, feature(libc))]\n@@ -58,6 +58,7 @@\n #![feature(nonzero)]\n #![feature(proc_macro_internals)]\n #![feature(quote)]\n+#![feature(optin_builtin_traits)]\n #![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n@@ -68,7 +69,7 @@\n #![feature(trusted_len)]\n #![feature(catch_expr)]\n #![feature(test)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n \n #![recursion_limit=\"512\"]\n \n@@ -84,7 +85,6 @@ extern crate libc;\n extern crate rustc_target;\n #[macro_use] extern crate rustc_data_structures;\n extern crate serialize;\n-extern crate rustc_const_math;\n extern crate rustc_errors as errors;\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "d158f52c643ceca2c2896acabe6c8cf02bd21add", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -198,7 +198,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                       \"malformed lint attribute\");\n         };\n         for attr in attrs {\n-            let level = match attr.name().and_then(|name| Level::from_str(&name.as_str())) {\n+            let level = match Level::from_str(&attr.name().as_str()) {\n                 None => continue,\n                 Some(lvl) => lvl,\n             };\n@@ -221,7 +221,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                         continue\n                     }\n                 };\n-                let name = word.ident.name;\n+                let name = word.name();\n                 match store.check_lint_name(&name.as_str()) {\n                     CheckLintNameResult::Ok(ids) => {\n                         let src = LintSource::Node(name, li.span);\n@@ -260,7 +260,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                                                 Some(li.span.into()),\n                                                 &msg);\n                         if name.as_str().chars().any(|c| c.is_uppercase()) {\n-                            let name_lower = name.as_str().to_lowercase();\n+                            let name_lower = name.as_str().to_lowercase().to_string();\n                             if let CheckLintNameResult::NoLint =\n                                     store.check_lint_name(&name_lower) {\n                                 db.emit();"}, {"sha": "d6c6f9dc0f61a0b1e5c72fee9af09b4b2634d6e3", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -507,7 +507,7 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n \n         let explanation = if lint_id == LintId::of(::lint::builtin::UNSTABLE_NAME_COLLISION) {\n             \"once this method is added to the standard library, \\\n-             there will be ambiguity here, which will cause a hard error!\"\n+             the ambiguity may cause an error or change in behavior!\"\n                 .to_owned()\n         } else if let Some(edition) = future_incompatible.edition {\n             format!(\"{} in the {} edition!\", STANDARD_MESSAGE, edition)"}, {"sha": "0ecab50dda22989faeb57d53f0bc642ff068e37d", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -11,7 +11,6 @@\n use hir::def_id::DefId;\n use ty::{self, TyCtxt, layout};\n use ty::subst::Substs;\n-use rustc_const_math::*;\n use mir::interpret::{Value, PrimVal};\n use errors::DiagnosticBuilder;\n \n@@ -62,7 +61,6 @@ pub enum ErrKind<'tcx> {\n     UnimplementedConstVal(&'static str),\n     IndexOutOfBounds { len: u64, index: u64 },\n \n-    Math(ConstMathErr),\n     LayoutError(layout::LayoutError<'tcx>),\n \n     TypeckError,\n@@ -76,15 +74,6 @@ pub struct FrameInfo {\n     pub location: String,\n }\n \n-impl<'tcx> From<ConstMathErr> for ErrKind<'tcx> {\n-    fn from(err: ConstMathErr) -> ErrKind<'tcx> {\n-        match err {\n-            ConstMathErr::UnsignedNegation => ErrKind::TypeckError,\n-            _ => ErrKind::Math(err)\n-        }\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub enum ConstEvalErrDescription<'a, 'tcx: 'a> {\n     Simple(Cow<'a, str>),\n@@ -122,7 +111,6 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n                         len, index)\n             }\n \n-            Math(ref err) => Simple(err.description().into_cow()),\n             LayoutError(ref err) => Simple(err.to_string().into_cow()),\n \n             TypeckError => simple!(\"type-checking failed\"),"}, {"sha": "725fcf1e6463b988fe11f84fff449b0d86b29cbd", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -28,6 +28,7 @@ use ty::{self, TyCtxt, adjustment};\n \n use hir::{self, PatKind};\n use rustc_data_structures::sync::Lrc;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n@@ -44,7 +45,7 @@ pub trait Delegate<'tcx> {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                consume_span: Span,\n-               cmt: mc::cmt<'tcx>,\n+               cmt: &mc::cmt_<'tcx>,\n                mode: ConsumeMode);\n \n     // The value found at `cmt` has been determined to match the\n@@ -61,22 +62,22 @@ pub trait Delegate<'tcx> {\n     // called on a subpart of an input passed to `matched_pat).\n     fn matched_pat(&mut self,\n                    matched_pat: &hir::Pat,\n-                   cmt: mc::cmt<'tcx>,\n+                   cmt: &mc::cmt_<'tcx>,\n                    mode: MatchMode);\n \n     // The value found at `cmt` is either copied or moved via the\n     // pattern binding `consume_pat`, depending on mode.\n     fn consume_pat(&mut self,\n                    consume_pat: &hir::Pat,\n-                   cmt: mc::cmt<'tcx>,\n+                   cmt: &mc::cmt_<'tcx>,\n                    mode: ConsumeMode);\n \n     // The value found at `borrow` is being borrowed at the point\n     // `borrow_id` for the region `loan_region` with kind `bk`.\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n-              cmt: mc::cmt<'tcx>,\n+              cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: LoanCause);\n@@ -90,7 +91,7 @@ pub trait Delegate<'tcx> {\n     fn mutate(&mut self,\n               assignment_id: ast::NodeId,\n               assignment_span: Span,\n-              assignee_cmt: mc::cmt<'tcx>,\n+              assignee_cmt: &mc::cmt_<'tcx>,\n               mode: MutateMode);\n }\n \n@@ -316,11 +317,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n             let fn_body_scope_r =\n                 self.tcx().mk_region(ty::ReScope(region::Scope::Node(body.value.hir_id.local_id)));\n-            let arg_cmt = self.mc.cat_rvalue(\n+            let arg_cmt = Rc::new(self.mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n                 fn_body_scope_r, // Args live only as long as the fn body.\n-                arg_ty);\n+                arg_ty));\n \n             self.walk_irrefutable_pat(arg_cmt, &arg.pat);\n         }\n@@ -335,11 +336,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn delegate_consume(&mut self,\n                         consume_id: ast::NodeId,\n                         consume_span: Span,\n-                        cmt: mc::cmt<'tcx>) {\n+                        cmt: &mc::cmt_<'tcx>) {\n         debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n                consume_id, cmt);\n \n-        let mode = copy_or_move(&self.mc, self.param_env, &cmt, DirectRefMove);\n+        let mode = copy_or_move(&self.mc, self.param_env, cmt, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n@@ -353,7 +354,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"consume_expr(expr={:?})\", expr);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate_consume(expr.id, expr.span, cmt);\n+        self.delegate_consume(expr.id, expr.span, &cmt);\n         self.walk_expr(expr);\n     }\n \n@@ -362,7 +363,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                    expr: &hir::Expr,\n                    mode: MutateMode) {\n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.mutate(assignment_expr.id, assignment_expr.span, cmt, mode);\n+        self.delegate.mutate(assignment_expr.id, assignment_expr.span, &cmt, mode);\n         self.walk_expr(expr);\n     }\n \n@@ -375,7 +376,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                expr, r, bk);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.borrow(expr.id, expr.span, cmt, r, bk, cause);\n+        self.delegate.borrow(expr.id, expr.span, &cmt, r, bk, cause);\n \n         self.walk_expr(expr)\n     }\n@@ -435,7 +436,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprMatch(ref discr, ref arms, _) => {\n-                let discr_cmt = return_if_err!(self.mc.cat_expr(&discr));\n+                let discr_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&discr)));\n                 let r = self.tcx().types.re_empty;\n                 self.borrow_expr(&discr, r, ty::ImmBorrow, MatchDiscriminant);\n \n@@ -619,7 +620,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // \"assigns\", which is handled by\n                 // `walk_pat`:\n                 self.walk_expr(&expr);\n-                let init_cmt = return_if_err!(self.mc.cat_expr(&expr));\n+                let init_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&expr)));\n                 self.walk_irrefutable_pat(init_cmt, &local.pat);\n             }\n         }\n@@ -652,7 +653,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             None => { return; }\n         };\n \n-        let with_cmt = return_if_err!(self.mc.cat_expr(&with_expr));\n+        let with_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&with_expr)));\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n@@ -671,7 +672,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                             with_field.name,\n                             with_field.ty(self.tcx(), substs)\n                         );\n-                        self.delegate_consume(with_expr.id, with_expr.span, cmt_field);\n+                        self.delegate_consume(with_expr.id, with_expr.span, &cmt_field);\n                     }\n                 }\n             }\n@@ -710,7 +711,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 adjustment::Adjust::Unsize => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n-                    self.delegate_consume(expr.id, expr.span, cmt.clone());\n+                    self.delegate_consume(expr.id, expr.span, &cmt);\n                 }\n \n                 adjustment::Adjust::Deref(None) => {}\n@@ -722,12 +723,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // this is an autoref of `x`.\n                 adjustment::Adjust::Deref(Some(ref deref)) => {\n                     let bk = ty::BorrowKind::from_mutbl(deref.mutbl);\n-                    self.delegate.borrow(expr.id, expr.span, cmt.clone(),\n-                                         deref.region, bk, AutoRef);\n+                    self.delegate.borrow(expr.id, expr.span, &cmt, deref.region, bk, AutoRef);\n                 }\n \n                 adjustment::Adjust::Borrow(ref autoref) => {\n-                    self.walk_autoref(expr, cmt.clone(), autoref);\n+                    self.walk_autoref(expr, &cmt, autoref);\n                 }\n             }\n             cmt = return_if_err!(self.mc.cat_expr_adjusted(expr, cmt, &adjustment));\n@@ -739,7 +739,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     /// after all relevant autoderefs have occurred.\n     fn walk_autoref(&mut self,\n                     expr: &hir::Expr,\n-                    cmt_base: mc::cmt<'tcx>,\n+                    cmt_base: &mc::cmt_<'tcx>,\n                     autoref: &adjustment::AutoBorrow<'tcx>) {\n         debug!(\"walk_autoref(expr.id={} cmt_base={:?} autoref={:?})\",\n                expr.id,\n@@ -852,7 +852,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n                 let def = Def::Local(canonical_id);\n-                if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty, def) {\n+                if let Ok(ref binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n                 }\n \n@@ -861,13 +861,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     ty::BindByReference(m) => {\n                         if let ty::TyRef(r, _) = pat_ty.sty {\n                             let bk = ty::BorrowKind::from_mutbl(m);\n-                            delegate.borrow(pat.id, pat.span, cmt_pat, r, bk, RefBinding);\n+                            delegate.borrow(pat.id, pat.span, &cmt_pat, r, bk, RefBinding);\n                         }\n                     }\n                     ty::BindByValue(..) => {\n                         let mode = copy_or_move(mc, param_env, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n-                        delegate.consume_pat(pat, cmt_pat, mode);\n+                        delegate.consume_pat(pat, &cmt_pat, mode);\n                     }\n                 }\n             }\n@@ -891,12 +891,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n \n                     debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n-                    delegate.matched_pat(pat, downcast_cmt, match_mode);\n+                    delegate.matched_pat(pat, &downcast_cmt, match_mode);\n                 }\n                 Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n                 Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n-                    delegate.matched_pat(pat, cmt_pat, match_mode);\n+                    delegate.matched_pat(pat, &cmt_pat, match_mode);\n                 }\n                 _ => {}\n             }\n@@ -924,12 +924,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                                 self.param_env,\n                                                 &cmt_var,\n                                                 CaptureMove);\n-                        self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n+                        self.delegate.consume(closure_expr.id, freevar.span, &cmt_var, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n                         self.delegate.borrow(closure_expr.id,\n                                              fn_decl_span,\n-                                             cmt_var,\n+                                             &cmt_var,\n                                              upvar_borrow.region,\n                                              upvar_borrow.kind,\n                                              ClosureCapture(freevar.span));\n@@ -943,7 +943,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         closure_id: ast::NodeId,\n                         closure_span: Span,\n                         upvar: &hir::Freevar)\n-                        -> mc::McResult<mc::cmt<'tcx>> {\n+                        -> mc::McResult<mc::cmt_<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n         let var_hir_id = self.tcx().hir.node_to_hir_id(upvar.var_id());\n@@ -954,7 +954,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n fn copy_or_move<'a, 'gcx, 'tcx>(mc: &mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n                                 param_env: ty::ParamEnv<'tcx>,\n-                                cmt: &mc::cmt<'tcx>,\n+                                cmt: &mc::cmt_<'tcx>,\n                                 move_reason: MoveReason)\n                                 -> ConsumeMode\n {"}, {"sha": "d1a46f5f155637f02624592f1e9d127436a87425", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -111,6 +111,7 @@ use ty::{self, TyCtxt};\n use lint;\n use util::nodemap::{NodeMap, NodeSet};\n \n+use std::collections::VecDeque;\n use std::{fmt, usize};\n use std::io::prelude::*;\n use std::io;\n@@ -412,18 +413,43 @@ fn visit_local<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, local: &'tcx hir::Local) {\n }\n \n fn visit_arm<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, arm: &'tcx hir::Arm) {\n-    for pat in &arm.pats {\n-        // for struct patterns, take note of which fields used shorthand (`x` rather than `x: x`)\n+    for mut pat in &arm.pats {\n+        // For struct patterns, take note of which fields used shorthand\n+        // (`x` rather than `x: x`).\n         //\n-        // FIXME: according to the rust-lang-nursery/rustc-guide book, `NodeId`s are to be phased\n-        // out in favor of `HirId`s; however, we need to match the signature of `each_binding`,\n-        // which uses `NodeIds`.\n+        // FIXME: according to the rust-lang-nursery/rustc-guide book, `NodeId`s are to be\n+        // phased out in favor of `HirId`s; however, we need to match the signature of\n+        // `each_binding`, which uses `NodeIds`.\n         let mut shorthand_field_ids = NodeSet();\n-        if let hir::PatKind::Struct(_, ref fields, _) = pat.node {\n-            for field in fields {\n-                if field.node.is_shorthand {\n-                    shorthand_field_ids.insert(field.node.pat.id);\n+        let mut pats = VecDeque::new();\n+        pats.push_back(pat);\n+        while let Some(pat) = pats.pop_front() {\n+            use hir::PatKind::*;\n+            match pat.node {\n+                Binding(_, _, _, ref inner_pat) => {\n+                    pats.extend(inner_pat.iter());\n                 }\n+                Struct(_, ref fields, _) => {\n+                    for field in fields {\n+                        if field.node.is_shorthand {\n+                            shorthand_field_ids.insert(field.node.pat.id);\n+                        }\n+                    }\n+                }\n+                Ref(ref inner_pat, _) |\n+                Box(ref inner_pat) => {\n+                    pats.push_back(inner_pat);\n+                }\n+                TupleStruct(_, ref inner_pats, _) |\n+                Tuple(ref inner_pats, _) => {\n+                    pats.extend(inner_pats.iter());\n+                }\n+                Slice(ref pre_pats, ref inner_pat, ref post_pats) => {\n+                    pats.extend(pre_pats.iter());\n+                    pats.extend(inner_pat.iter());\n+                    pats.extend(post_pats.iter());\n+                }\n+                _ => {}\n             }\n         }\n "}, {"sha": "f40a41cd299247cf15e9836eebf5bd25223251a0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -572,13 +572,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         Ok(ret_ty)\n     }\n \n-    pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n+    pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt_<'tcx>> {\n         // This recursion helper avoids going through *too many*\n         // adjustments, since *only* non-overloaded deref recurses.\n         fn helper<'a, 'gcx, 'tcx>(mc: &MemCategorizationContext<'a, 'gcx, 'tcx>,\n                                   expr: &hir::Expr,\n                                   adjustments: &[adjustment::Adjustment<'tcx>])\n-                                   -> McResult<cmt<'tcx>> {\n+                                   -> McResult<cmt_<'tcx>> {\n             match adjustments.split_last() {\n                 None => mc.cat_expr_unadjusted(expr),\n                 Some((adjustment, previous)) => {\n@@ -591,32 +591,32 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn cat_expr_adjusted(&self, expr: &hir::Expr,\n-                             previous: cmt<'tcx>,\n+                             previous: cmt_<'tcx>,\n                              adjustment: &adjustment::Adjustment<'tcx>)\n-                             -> McResult<cmt<'tcx>> {\n+                             -> McResult<cmt_<'tcx>> {\n         self.cat_expr_adjusted_with(expr, || Ok(previous), adjustment)\n     }\n \n     fn cat_expr_adjusted_with<F>(&self, expr: &hir::Expr,\n                                  previous: F,\n                                  adjustment: &adjustment::Adjustment<'tcx>)\n-                                 -> McResult<cmt<'tcx>>\n-        where F: FnOnce() -> McResult<cmt<'tcx>>\n+                                 -> McResult<cmt_<'tcx>>\n+        where F: FnOnce() -> McResult<cmt_<'tcx>>\n     {\n         debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n         let target = self.resolve_type_vars_if_possible(&adjustment.target);\n         match adjustment.kind {\n             adjustment::Adjust::Deref(overloaded) => {\n                 // Equivalent to *expr or something similar.\n-                let base = if let Some(deref) = overloaded {\n+                let base = Rc::new(if let Some(deref) = overloaded {\n                     let ref_ty = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n                         ty: target,\n                         mutbl: deref.mutbl,\n                     });\n                     self.cat_rvalue_node(expr.id, expr.span, ref_ty)\n                 } else {\n                     previous()?\n-                };\n+                });\n                 self.cat_deref(expr, base, false)\n             }\n \n@@ -633,7 +633,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n+    pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<cmt_<'tcx>> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n@@ -642,13 +642,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             if self.tables.is_method_call(expr) {\n                 self.cat_overloaded_place(expr, e_base, false)\n             } else {\n-                let base_cmt = self.cat_expr(&e_base)?;\n+                let base_cmt = Rc::new(self.cat_expr(&e_base)?);\n                 self.cat_deref(expr, base_cmt, false)\n             }\n           }\n \n           hir::ExprField(ref base, f_name) => {\n-            let base_cmt = self.cat_expr(&base)?;\n+            let base_cmt = Rc::new(self.cat_expr(&base)?);\n             debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n                    expr.id,\n                    expr,\n@@ -666,7 +666,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 // dereferencing.\n                 self.cat_overloaded_place(expr, base, true)\n             } else {\n-                let base_cmt = self.cat_expr(&base)?;\n+                let base_cmt = Rc::new(self.cat_expr(&base)?);\n                 self.cat_index(expr, base_cmt, expr_ty, InteriorOffsetKind::Index)\n             }\n           }\n@@ -701,7 +701,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                    span: Span,\n                    expr_ty: Ty<'tcx>,\n                    def: Def)\n-                   -> McResult<cmt<'tcx>> {\n+                   -> McResult<cmt_<'tcx>> {\n         debug!(\"cat_def: id={} expr={:?} def={:?}\",\n                id, expr_ty, def);\n \n@@ -718,29 +718,29 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                     return Ok(self.cat_rvalue_node(id, span, expr_ty));\n                 }\n             }\n-              Ok(Rc::new(cmt_ {\n+              Ok(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:Categorization::StaticItem,\n                   mutbl: if mutbl { McDeclared } else { McImmutable},\n                   ty:expr_ty,\n                   note: NoteNone\n-              }))\n+              })\n           }\n \n           Def::Upvar(var_id, _, fn_node_id) => {\n               self.cat_upvar(id, span, var_id, fn_node_id)\n           }\n \n           Def::Local(vid) => {\n-            Ok(Rc::new(cmt_ {\n+            Ok(cmt_ {\n                 id,\n                 span,\n                 cat: Categorization::Local(vid),\n                 mutbl: MutabilityCategory::from_local(self.tcx, self.tables, vid),\n                 ty: expr_ty,\n                 note: NoteNone\n-            }))\n+            })\n           }\n \n           def => span_bug!(span, \"unexpected definition in memory categorization: {:?}\", def)\n@@ -754,7 +754,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                  span: Span,\n                  var_id: ast::NodeId,\n                  fn_node_id: ast::NodeId)\n-                 -> McResult<cmt<'tcx>>\n+                 -> McResult<cmt_<'tcx>>\n     {\n         let fn_hir_id = self.tcx.hir.node_to_hir_id(fn_node_id);\n \n@@ -861,7 +861,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let ret = Rc::new(cmt_result);\n+        let ret = cmt_result;\n         debug!(\"cat_upvar ret={:?}\", ret);\n         Ok(ret)\n     }\n@@ -938,7 +938,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                            id: ast::NodeId,\n                            span: Span,\n                            expr_ty: Ty<'tcx>)\n-                           -> cmt<'tcx> {\n+                           -> cmt_<'tcx> {\n         let hir_id = self.tcx.hir.node_to_hir_id(id);\n         let promotable = self.rvalue_promotable_map.as_ref().map(|m| m.contains(&hir_id.local_id))\n                                                             .unwrap_or(false);\n@@ -966,15 +966,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                       cmt_id: ast::NodeId,\n                       span: Span,\n                       temp_scope: ty::Region<'tcx>,\n-                      expr_ty: Ty<'tcx>) -> cmt<'tcx> {\n-        let ret = Rc::new(cmt_ {\n+                      expr_ty: Ty<'tcx>) -> cmt_<'tcx> {\n+        let ret = cmt_ {\n             id:cmt_id,\n             span:span,\n             cat:Categorization::Rvalue(temp_scope),\n             mutbl:McDeclared,\n             ty:expr_ty,\n             note: NoteNone\n-        });\n+        };\n         debug!(\"cat_rvalue ret {:?}\", ret);\n         ret\n     }\n@@ -985,15 +985,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                  f_index: usize,\n                                  f_name: Name,\n                                  f_ty: Ty<'tcx>)\n-                                 -> cmt<'tcx> {\n-        let ret = Rc::new(cmt_ {\n+                                 -> cmt_<'tcx> {\n+        let ret = cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: Categorization::Interior(base_cmt, InteriorField(FieldIndex(f_index, f_name))),\n             ty: f_ty,\n             note: NoteNone\n-        });\n+        };\n         debug!(\"cat_field ret {:?}\", ret);\n         ret\n     }\n@@ -1002,7 +1002,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                              expr: &hir::Expr,\n                              base: &hir::Expr,\n                              implicit: bool)\n-                             -> McResult<cmt<'tcx>> {\n+                             -> McResult<cmt_<'tcx>> {\n         debug!(\"cat_overloaded_place: implicit={}\", implicit);\n \n         // Reconstruct the output assuming it's a reference with the\n@@ -1022,15 +1022,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             mutbl,\n         });\n \n-        let base_cmt = self.cat_rvalue_node(expr.id, expr.span, ref_ty);\n+        let base_cmt = Rc::new(self.cat_rvalue_node(expr.id, expr.span, ref_ty));\n         self.cat_deref(expr, base_cmt, implicit)\n     }\n \n     pub fn cat_deref<N:ast_node>(&self,\n                                  node: &N,\n                                  base_cmt: cmt<'tcx>,\n                                  implicit: bool)\n-                                 -> McResult<cmt<'tcx>> {\n+                                 -> McResult<cmt_<'tcx>> {\n         debug!(\"cat_deref: base_cmt={:?}\", base_cmt);\n \n         let base_cmt_ty = base_cmt.ty;\n@@ -1052,15 +1052,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n             ref ty => bug!(\"unexpected type in cat_deref: {:?}\", ty)\n         };\n-        let ret = Rc::new(cmt_ {\n+        let ret = cmt_ {\n             id: node.id(),\n             span: node.span(),\n             // For unique ptrs, we inherit mutability from the owning reference.\n             mutbl: MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n             cat: Categorization::Deref(base_cmt, ptr),\n             ty: deref_ty,\n             note: NoteNone\n-        });\n+        };\n         debug!(\"cat_deref ret {:?}\", ret);\n         Ok(ret)\n     }\n@@ -1070,7 +1070,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                              base_cmt: cmt<'tcx>,\n                              element_ty: Ty<'tcx>,\n                              context: InteriorOffsetKind)\n-                             -> McResult<cmt<'tcx>> {\n+                             -> McResult<cmt_<'tcx>> {\n         //! Creates a cmt for an indexing operation (`[]`).\n         //!\n         //! One subtle aspect of indexing that may not be\n@@ -1089,8 +1089,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         //! - `base_cmt`: the cmt of `elt`\n \n         let interior_elem = InteriorElement(context);\n-        let ret =\n-            self.cat_imm_interior(elt, base_cmt, element_ty, interior_elem);\n+        let ret = self.cat_imm_interior(elt, base_cmt, element_ty, interior_elem);\n         debug!(\"cat_index ret {:?}\", ret);\n         return Ok(ret);\n     }\n@@ -1100,15 +1099,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                         base_cmt: cmt<'tcx>,\n                                         interior_ty: Ty<'tcx>,\n                                         interior: InteriorKind)\n-                                        -> cmt<'tcx> {\n-        let ret = Rc::new(cmt_ {\n+                                        -> cmt_<'tcx> {\n+        let ret = cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: Categorization::Interior(base_cmt, interior),\n             ty: interior_ty,\n             note: NoteNone\n-        });\n+        };\n         debug!(\"cat_imm_interior ret={:?}\", ret);\n         ret\n     }\n@@ -1232,7 +1231,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         .get(pat.hir_id)\n                         .map(|v| v.len())\n                         .unwrap_or(0) {\n-            cmt = self.cat_deref(pat, cmt, true /* implicit */)?;\n+            cmt = Rc::new(self.cat_deref(pat, cmt, true /* implicit */)?);\n         }\n         let cmt = cmt; // lose mutability\n \n@@ -1279,7 +1278,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n                 let interior = InteriorField(FieldIndex(i, Name::intern(&i.to_string())));\n-                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior);\n+                let subcmt = Rc::new(self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior));\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n           }\n@@ -1302,7 +1301,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             for fp in field_pats {\n                 let field_ty = self.pat_ty(&fp.node.pat)?; // see (*2)\n                 let f_index = self.tcx.field_index(fp.node.id, self.tables);\n-                let cmt_field = self.cat_field(pat, cmt.clone(), f_index, fp.node.name, field_ty);\n+                let cmt_field =\n+                    Rc::new(self.cat_field(pat, cmt.clone(), f_index, fp.node.name, field_ty));\n                 self.cat_pattern_(cmt_field, &fp.node.pat, op)?;\n             }\n           }\n@@ -1320,7 +1320,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n                 let interior = InteriorField(FieldIndex(i, Name::intern(&i.to_string())));\n-                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior);\n+                let subcmt = Rc::new(self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior));\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n           }\n@@ -1329,7 +1329,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatKind::Ref since that information is already contained\n             // in the type.\n-            let subcmt = self.cat_deref(pat, cmt, false)?;\n+            let subcmt = Rc::new(self.cat_deref(pat, cmt, false)?);\n             self.cat_pattern_(subcmt, &subpat, op)?;\n           }\n \n@@ -1342,7 +1342,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 }\n             };\n             let context = InteriorOffsetKind::Pattern;\n-            let elt_cmt = self.cat_index(pat, cmt, element_ty, context)?;\n+            let elt_cmt = Rc::new(self.cat_index(pat, cmt, element_ty, context)?);\n             for before_pat in before {\n                 self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n             }\n@@ -1379,7 +1379,7 @@ pub enum AliasableReason {\n }\n \n impl<'tcx> cmt_<'tcx> {\n-    pub fn guarantor(&self) -> cmt<'tcx> {\n+    pub fn guarantor(&self) -> cmt_<'tcx> {\n         //! Returns `self` after stripping away any derefs or\n         //! interior content. The return value is basically the `cmt` which\n         //! determines how long the value in `self` remains live.\n@@ -1392,7 +1392,7 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Deref(_, BorrowedPtr(..)) |\n             Categorization::Deref(_, Implicit(..)) |\n             Categorization::Upvar(..) => {\n-                Rc::new((*self).clone())\n+                (*self).clone()\n             }\n             Categorization::Downcast(ref b, _) |\n             Categorization::Interior(ref b, _) |\n@@ -1442,16 +1442,17 @@ impl<'tcx> cmt_<'tcx> {\n         }\n     }\n \n-    // Digs down through one or two layers of deref and grabs the cmt\n-    // for the upvar if a note indicates there is one.\n-    pub fn upvar(&self) -> Option<cmt<'tcx>> {\n+    // Digs down through one or two layers of deref and grabs the\n+    // Categorization of the cmt for the upvar if a note indicates there is\n+    // one.\n+    pub fn upvar_cat(&self) -> Option<&Categorization<'tcx>> {\n         match self.note {\n             NoteClosureEnv(..) | NoteUpvarRef(..) => {\n                 Some(match self.cat {\n                     Categorization::Deref(ref inner, _) => {\n                         match inner.cat {\n-                            Categorization::Deref(ref inner, _) => inner.clone(),\n-                            Categorization::Upvar(..) => inner.clone(),\n+                            Categorization::Deref(ref inner, _) => &inner.cat,\n+                            Categorization::Upvar(..) => &inner.cat,\n                             _ => bug!()\n                         }\n                     }\n@@ -1462,7 +1463,6 @@ impl<'tcx> cmt_<'tcx> {\n         }\n     }\n \n-\n     pub fn descriptive_string(&self, tcx: TyCtxt) -> String {\n         match self.cat {\n             Categorization::StaticItem => {\n@@ -1479,8 +1479,7 @@ impl<'tcx> cmt_<'tcx> {\n                 }\n             }\n             Categorization::Deref(_, pk) => {\n-                let upvar = self.upvar();\n-                match upvar.as_ref().map(|i| &i.cat) {\n+                match self.upvar_cat() {\n                     Some(&Categorization::Upvar(ref var)) => {\n                         var.to_string()\n                     }"}, {"sha": "bfc9ff6660de9890254f9d37eb06660d413da73d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -690,21 +690,22 @@ impl<'tcx> ScopeTree {\n         // the start. So this algorithm is faster.\n         let mut ma = Some(scope_a);\n         let mut mb = Some(scope_b);\n-        let mut seen: SmallVec<[Scope; 32]> = SmallVec::new();\n+        let mut seen_a: SmallVec<[Scope; 32]> = SmallVec::new();\n+        let mut seen_b: SmallVec<[Scope; 32]> = SmallVec::new();\n         loop {\n             if let Some(a) = ma {\n-                if seen.iter().position(|s| *s == a).is_some() {\n+                if seen_b.iter().position(|s| *s == a).is_some() {\n                     return a;\n                 }\n-                seen.push(a);\n+                seen_a.push(a);\n                 ma = self.parent_map.get(&a).map(|s| *s);\n             }\n \n             if let Some(b) = mb {\n-                if seen.iter().position(|s| *s == b).is_some() {\n+                if seen_a.iter().position(|s| *s == b).is_some() {\n                     return b;\n                 }\n-                seen.push(b);\n+                seen_b.push(b);\n                 mb = self.parent_map.get(&b).map(|s| *s);\n             }\n "}, {"sha": "279908d2b675fae372bbb13780bf293d39fc7220", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -205,7 +205,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n         } else {\n             // Emit errors for non-staged-api crates.\n             for attr in attrs {\n-                let tag = unwrap_or!(attr.name(), continue);\n+                let tag = attr.name();\n                 if tag == \"unstable\" || tag == \"stable\" || tag == \"rustc_deprecated\" {\n                     attr::mark_used(attr);\n                     self.tcx.sess.span_err(attr.span(), \"stability attributes may not be used \\"}, {"sha": "41ba526b73fefdafd3d707eac79698e10da0ddd9", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -68,7 +68,7 @@ fn calculate_predecessors(mir: &Mir) -> IndexVec<BasicBlock, Vec<BasicBlock>> {\n     let mut result = IndexVec::from_elem(vec![], mir.basic_blocks());\n     for (bb, data) in mir.basic_blocks().iter_enumerated() {\n         if let Some(ref term) = data.terminator {\n-            for &tgt in term.successors().iter() {\n+            for &tgt in term.successors() {\n                 result[tgt].push(bb);\n             }\n         }"}, {"sha": "1e1d50c3fc036d36d26369c18ed4d5ffdfc19db7", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,4 +1,3 @@\n-use std::error::Error;\n use std::{fmt, env};\n \n use mir;\n@@ -8,18 +7,16 @@ use super::{\n     MemoryPointer, Lock, AccessKind\n };\n \n-use rustc_const_math::ConstMathErr;\n-use syntax::codemap::Span;\n use backtrace::Backtrace;\n \n #[derive(Debug, Clone)]\n pub struct EvalError<'tcx> {\n-    pub kind: EvalErrorKind<'tcx>,\n+    pub kind: EvalErrorKind<'tcx, u64>,\n     pub backtrace: Option<Backtrace>,\n }\n \n-impl<'tcx> From<EvalErrorKind<'tcx>> for EvalError<'tcx> {\n-    fn from(kind: EvalErrorKind<'tcx>) -> Self {\n+impl<'tcx> From<EvalErrorKind<'tcx, u64>> for EvalError<'tcx> {\n+    fn from(kind: EvalErrorKind<'tcx, u64>) -> Self {\n         let backtrace = match env::var(\"MIRI_BACKTRACE\") {\n             Ok(ref val) if !val.is_empty() => Some(Backtrace::new_unresolved()),\n             _ => None\n@@ -31,8 +28,10 @@ impl<'tcx> From<EvalErrorKind<'tcx>> for EvalError<'tcx> {\n     }\n }\n \n-#[derive(Debug, Clone)]\n-pub enum EvalErrorKind<'tcx> {\n+pub type AssertMessage<'tcx> = EvalErrorKind<'tcx, mir::Operand<'tcx>>;\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n+pub enum EvalErrorKind<'tcx, O> {\n     /// This variant is used by machines to signal their own errors that do not\n     /// match an existing variant\n     MachineError(String),\n@@ -60,10 +59,12 @@ pub enum EvalErrorKind<'tcx> {\n     Unimplemented(String),\n     DerefFunctionPointer,\n     ExecuteMemory,\n-    ArrayIndexOutOfBounds(Span, u64, u64),\n-    Math(Span, ConstMathErr),\n+    BoundsCheck { len: O, index: O },\n+    Overflow(mir::BinOp),\n+    OverflowNeg,\n+    DivisionByZero,\n+    RemainderByZero,\n     Intrinsic(String),\n-    OverflowingMath,\n     InvalidChar(u128),\n     StackFrameLimitReached,\n     OutOfTls,\n@@ -121,14 +122,16 @@ pub enum EvalErrorKind<'tcx> {\n     /// Cannot compute this constant because it depends on another one\n     /// which already produced an error\n     ReferencedConstant,\n+    GeneratorResumedAfterReturn,\n+    GeneratorResumedAfterPanic,\n }\n \n pub type EvalResult<'tcx, T = ()> = Result<T, EvalError<'tcx>>;\n \n-impl<'tcx> Error for EvalError<'tcx> {\n-    fn description(&self) -> &str {\n+impl<'tcx, O> EvalErrorKind<'tcx, O> {\n+    pub fn description(&self) -> &str {\n         use self::EvalErrorKind::*;\n-        match self.kind {\n+        match *self {\n             MachineError(ref inner) => inner,\n             FunctionPointerTyMismatch(..) =>\n                 \"tried to call a function through a function pointer of a different type\",\n@@ -175,14 +178,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"tried to dereference a function pointer\",\n             ExecuteMemory =>\n                 \"tried to treat a memory pointer as a function pointer\",\n-            ArrayIndexOutOfBounds(..) =>\n+            BoundsCheck{..} =>\n                 \"array index out of bounds\",\n-            Math(..) =>\n-                \"mathematical operation failed\",\n             Intrinsic(..) =>\n                 \"intrinsic failed\",\n-            OverflowingMath =>\n-                \"attempted to do overflowing math\",\n             NoMirFor(..) =>\n                 \"mir not found\",\n             InvalidChar(..) =>\n@@ -232,22 +231,41 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"the evaluated program panicked\",\n             ReadFromReturnPointer =>\n                 \"tried to read from the return pointer\",\n-            EvalErrorKind::PathNotFound(_) =>\n+            PathNotFound(_) =>\n                 \"a path could not be resolved, maybe the crate is not loaded\",\n             UnimplementedTraitSelection =>\n                 \"there were unresolved type arguments during trait selection\",\n             TypeckError =>\n                 \"encountered constants with type errors, stopping evaluation\",\n             ReferencedConstant =>\n                 \"referenced constant has errors\",\n+            Overflow(mir::BinOp::Add) => \"attempt to add with overflow\",\n+            Overflow(mir::BinOp::Sub) => \"attempt to subtract with overflow\",\n+            Overflow(mir::BinOp::Mul) => \"attempt to multiply with overflow\",\n+            Overflow(mir::BinOp::Div) => \"attempt to divide with overflow\",\n+            Overflow(mir::BinOp::Rem) => \"attempt to calculate the remainder with overflow\",\n+            OverflowNeg => \"attempt to negate with overflow\",\n+            Overflow(mir::BinOp::Shr) => \"attempt to shift right with overflow\",\n+            Overflow(mir::BinOp::Shl) => \"attempt to shift left with overflow\",\n+            Overflow(op) => bug!(\"{:?} cannot overflow\", op),\n+            DivisionByZero => \"attempt to divide by zero\",\n+            RemainderByZero => \"attempt to calculate the remainder with a divisor of zero\",\n+            GeneratorResumedAfterReturn => \"generator resumed after completion\",\n+            GeneratorResumedAfterPanic => \"generator resumed after panicking\",\n         }\n     }\n }\n \n impl<'tcx> fmt::Display for EvalError<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}\", self.kind)\n+    }\n+}\n+\n+impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use self::EvalErrorKind::*;\n-        match self.kind {\n+        match *self {\n             PointerOutOfBounds { ptr, access, allocation_size } => {\n                 write!(f, \"{} at offset {}, outside bounds of allocation {} which has size {}\",\n                        if access { \"memory access\" } else { \"pointer computed\" },\n@@ -275,14 +293,12 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n             NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n             FunctionPointerTyMismatch(sig, got) =>\n                 write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig, got),\n-            ArrayIndexOutOfBounds(span, len, index) =>\n-                write!(f, \"index out of bounds: the len is {} but the index is {} at {:?}\", len, index, span),\n+            BoundsCheck { ref len, ref index } =>\n+                write!(f, \"index out of bounds: the len is {:?} but the index is {:?}\", len, index),\n             ReallocatedWrongMemoryKind(ref old, ref new) =>\n                 write!(f, \"tried to reallocate memory from {} to {}\", old, new),\n             DeallocatedWrongMemoryKind(ref old, ref new) =>\n                 write!(f, \"tried to deallocate {} memory but gave {} as the kind\", old, new),\n-            Math(_, ref err) =>\n-                write!(f, \"{}\", err.description()),\n             Intrinsic(ref err) =>\n                 write!(f, \"{}\", err),\n             InvalidChar(c) =>"}, {"sha": "546c7a920d538fd6d12a653ea0c41ccf9f510088", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -8,7 +8,7 @@ macro_rules! err {\n mod error;\n mod value;\n \n-pub use self::error::{EvalError, EvalResult, EvalErrorKind};\n+pub use self::error::{EvalError, EvalResult, EvalErrorKind, AssertMessage};\n \n pub use self::value::{PrimVal, PrimValKind, Value, Pointer};\n \n@@ -23,21 +23,21 @@ use std::iter;\n use syntax::ast::Mutability;\n use rustc_serialize::{Encoder, Decoder, Decodable, Encodable};\n \n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Lock {\n     NoLock,\n     WriteLock(DynamicLifetime),\n     /// This should never be empty -- that would be a read lock held and nobody there to release it...\n     ReadLock(Vec<DynamicLifetime>),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct DynamicLifetime {\n     pub frame: usize,\n     pub region: Option<region::Scope>, // \"None\" indicates \"until the function ends\"\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum AccessKind {\n     Read,\n     Write,\n@@ -88,12 +88,12 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n \n     fn signed_offset<'tcx>(self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n         let (res, over) = self.overflowing_signed_offset(val, i as i128);\n-        if over { err!(OverflowingMath) } else { Ok(res) }\n+        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n     fn offset<'tcx>(self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n         let (res, over) = self.overflowing_offset(val, i);\n-        if over { err!(OverflowingMath) } else { Ok(res) }\n+        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n     fn wrapping_signed_offset(self, val: u64, i: i64) -> u64 {"}, {"sha": "37f6d47ff849d563d5ca3fae76dd616fa123bc50", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 107, "deletions": 101, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -15,17 +15,17 @@\n use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n use middle::region;\n-use rustc_const_math::ConstMathErr;\n use rustc_data_structures::sync::{Lrc};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n+use rustc_data_structures::small_vec::SmallVec;\n use rustc_serialize as serialize;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n use mir::visit::MirVisitable;\n-use mir::interpret::{Value, PrimVal};\n+use mir::interpret::{Value, PrimVal, EvalErrorKind};\n use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, Region, Ty, TyCtxt, GeneratorInterior};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -36,12 +36,16 @@ use hir::{self, InlineAsm};\n use std::borrow::{Cow};\n use rustc_data_structures::sync::ReadGuard;\n use std::fmt::{self, Debug, Formatter, Write};\n-use std::{iter, mem, u32};\n+use std::{iter, mem, option, u32};\n use std::ops::{Index, IndexMut};\n use std::vec::IntoIter;\n use syntax::ast::{self, Name};\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n+use rustc_apfloat::ieee::{Single, Double};\n+use rustc_apfloat::Float;\n+\n+pub use mir::interpret::AssertMessage;\n \n mod cache;\n pub mod tcx;\n@@ -247,6 +251,22 @@ impl<'tcx> Mir<'tcx> {\n         })\n     }\n \n+    /// Returns an iterator over all user-declared mutable arguments and locals.\n+    #[inline]\n+    pub fn mut_vars_and_args_iter<'a>(&'a self) -> impl Iterator<Item=Local> + 'a {\n+        (1..self.local_decls.len()).filter_map(move |index| {\n+            let local = Local::new(index);\n+            let decl = &self.local_decls[local];\n+            if (decl.is_user_variable || index < self.arg_count + 1)\n+               && decl.mutability == Mutability::Mut\n+            {\n+                Some(local)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n     /// Returns an iterator over all function arguments.\n     #[inline]\n     pub fn args_iter(&self) -> impl Iterator<Item=Local> {\n@@ -842,12 +862,17 @@ pub enum TerminatorKind<'tcx> {\n     },\n }\n \n+pub type Successors<'a> =\n+    iter::Chain<option::IntoIter<&'a BasicBlock>, slice::Iter<'a, BasicBlock>>;\n+pub type SuccessorsMut<'a> =\n+    iter::Chain<option::IntoIter<&'a mut BasicBlock>, slice::IterMut<'a, BasicBlock>>;\n+\n impl<'tcx> Terminator<'tcx> {\n-    pub fn successors(&self) -> Cow<[BasicBlock]> {\n+    pub fn successors(&self) -> Successors {\n         self.kind.successors()\n     }\n \n-    pub fn successors_mut(&mut self) -> Vec<&mut BasicBlock> {\n+    pub fn successors_mut(&mut self) -> SuccessorsMut {\n         self.kind.successors_mut()\n     }\n \n@@ -868,72 +893,71 @@ impl<'tcx> TerminatorKind<'tcx> {\n         }\n     }\n \n-    pub fn successors(&self) -> Cow<[BasicBlock]> {\n+    pub fn successors(&self) -> Successors {\n         use self::TerminatorKind::*;\n         match *self {\n-            Goto { target: ref b } => slice::from_ref(b).into_cow(),\n-            SwitchInt { targets: ref b, .. } => b[..].into_cow(),\n-            Resume | Abort | GeneratorDrop => (&[]).into_cow(),\n-            Return => (&[]).into_cow(),\n-            Unreachable => (&[]).into_cow(),\n-            Call { destination: Some((_, t)), cleanup: Some(c), .. } => vec![t, c].into_cow(),\n-            Call { destination: Some((_, ref t)), cleanup: None, .. } =>\n-                slice::from_ref(t).into_cow(),\n-            Call { destination: None, cleanup: Some(ref c), .. } => slice::from_ref(c).into_cow(),\n-            Call { destination: None, cleanup: None, .. } => (&[]).into_cow(),\n-            Yield { resume: t, drop: Some(c), .. } => vec![t, c].into_cow(),\n-            Yield { resume: ref t, drop: None, .. } => slice::from_ref(t).into_cow(),\n-            DropAndReplace { target, unwind: Some(unwind), .. } |\n-            Drop { target, unwind: Some(unwind), .. } => {\n-                vec![target, unwind].into_cow()\n+            Resume | Abort | GeneratorDrop | Return | Unreachable |\n+            Call { destination: None, cleanup: None, .. } => {\n+                None.into_iter().chain(&[])\n+            }\n+            Goto { target: ref t } |\n+            Call { destination: None, cleanup: Some(ref t), .. } |\n+            Call { destination: Some((_, ref t)), cleanup: None, .. } |\n+            Yield { resume: ref t, drop: None, .. } |\n+            DropAndReplace { target: ref t, unwind: None, .. } |\n+            Drop { target: ref t, unwind: None, .. } |\n+            Assert { target: ref t, cleanup: None, .. } |\n+            FalseUnwind { real_target: ref t, unwind: None } => {\n+                Some(t).into_iter().chain(&[])\n+            }\n+            Call { destination: Some((_, ref t)), cleanup: Some(ref u), .. } |\n+            Yield { resume: ref t, drop: Some(ref u), .. } |\n+            DropAndReplace { target: ref t, unwind: Some(ref u), .. } |\n+            Drop { target: ref t, unwind: Some(ref u), .. } |\n+            Assert { target: ref t, cleanup: Some(ref u), .. } |\n+            FalseUnwind { real_target: ref t, unwind: Some(ref u) } => {\n+                Some(t).into_iter().chain(slice::from_ref(u))\n             }\n-            DropAndReplace { ref target, unwind: None, .. } |\n-            Drop { ref target, unwind: None, .. } => {\n-                slice::from_ref(target).into_cow()\n+            SwitchInt { ref targets, .. } => {\n+                None.into_iter().chain(&targets[..])\n             }\n-            Assert { target, cleanup: Some(unwind), .. } => vec![target, unwind].into_cow(),\n-            Assert { ref target, .. } => slice::from_ref(target).into_cow(),\n             FalseEdges { ref real_target, ref imaginary_targets } => {\n-                let mut s = vec![*real_target];\n-                s.extend_from_slice(imaginary_targets);\n-                s.into_cow()\n+                Some(real_target).into_iter().chain(&imaginary_targets[..])\n             }\n-            FalseUnwind { real_target: t, unwind: Some(u) } => vec![t, u].into_cow(),\n-            FalseUnwind { real_target: ref t, unwind: None } => slice::from_ref(t).into_cow(),\n         }\n     }\n \n-    // FIXME: no mootable cow. I\u2019m honestly not sure what a \u201ccow\u201d between `&mut [BasicBlock]` and\n-    // `Vec<&mut BasicBlock>` would look like in the first place.\n-    pub fn successors_mut(&mut self) -> Vec<&mut BasicBlock> {\n+    pub fn successors_mut(&mut self) -> SuccessorsMut {\n         use self::TerminatorKind::*;\n         match *self {\n-            Goto { target: ref mut b } => vec![b],\n-            SwitchInt { targets: ref mut b, .. } => b.iter_mut().collect(),\n-            Resume | Abort | GeneratorDrop => Vec::new(),\n-            Return => Vec::new(),\n-            Unreachable => Vec::new(),\n-            Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut c), .. } => vec![t, c],\n-            Call { destination: Some((_, ref mut t)), cleanup: None, .. } => vec![t],\n-            Call { destination: None, cleanup: Some(ref mut c), .. } => vec![c],\n-            Call { destination: None, cleanup: None, .. } => vec![],\n-            Yield { resume: ref mut t, drop: Some(ref mut c), .. } => vec![t, c],\n-            Yield { resume: ref mut t, drop: None, .. } => vec![t],\n-            DropAndReplace { ref mut target, unwind: Some(ref mut unwind), .. } |\n-            Drop { ref mut target, unwind: Some(ref mut unwind), .. } => vec![target, unwind],\n-            DropAndReplace { ref mut target, unwind: None, .. } |\n-            Drop { ref mut target, unwind: None, .. } => {\n-                vec![target]\n+            Resume | Abort | GeneratorDrop | Return | Unreachable |\n+            Call { destination: None, cleanup: None, .. } => {\n+                None.into_iter().chain(&mut [])\n+            }\n+            Goto { target: ref mut t } |\n+            Call { destination: None, cleanup: Some(ref mut t), .. } |\n+            Call { destination: Some((_, ref mut t)), cleanup: None, .. } |\n+            Yield { resume: ref mut t, drop: None, .. } |\n+            DropAndReplace { target: ref mut t, unwind: None, .. } |\n+            Drop { target: ref mut t, unwind: None, .. } |\n+            Assert { target: ref mut t, cleanup: None, .. } |\n+            FalseUnwind { real_target: ref mut t, unwind: None } => {\n+                Some(t).into_iter().chain(&mut [])\n+            }\n+            Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut u), .. } |\n+            Yield { resume: ref mut t, drop: Some(ref mut u), .. } |\n+            DropAndReplace { target: ref mut t, unwind: Some(ref mut u), .. } |\n+            Drop { target: ref mut t, unwind: Some(ref mut u), .. } |\n+            Assert { target: ref mut t, cleanup: Some(ref mut u), .. } |\n+            FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) } => {\n+                Some(t).into_iter().chain(slice::from_ref_mut(u))\n+            }\n+            SwitchInt { ref mut targets, .. } => {\n+                None.into_iter().chain(&mut targets[..])\n             }\n-            Assert { ref mut target, cleanup: Some(ref mut unwind), .. } => vec![target, unwind],\n-            Assert { ref mut target, .. } => vec![target],\n             FalseEdges { ref mut real_target, ref mut imaginary_targets } => {\n-                let mut s = vec![real_target];\n-                s.extend(imaginary_targets.iter_mut());\n-                s\n+                Some(real_target).into_iter().chain(&mut imaginary_targets[..])\n             }\n-            FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) } => vec![t, u],\n-            FalseUnwind { ref mut real_target, unwind: None } => vec![real_target],\n         }\n     }\n \n@@ -1053,18 +1077,18 @@ impl<'tcx> BasicBlockData<'tcx> {\n impl<'tcx> Debug for TerminatorKind<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         self.fmt_head(fmt)?;\n-        let successors = self.successors();\n+        let successor_count = self.successors().count();\n         let labels = self.fmt_successor_labels();\n-        assert_eq!(successors.len(), labels.len());\n+        assert_eq!(successor_count, labels.len());\n \n-        match successors.len() {\n+        match successor_count {\n             0 => Ok(()),\n \n-            1 => write!(fmt, \" -> {:?}\", successors[0]),\n+            1 => write!(fmt, \" -> {:?}\", self.successors().nth(0).unwrap()),\n \n             _ => {\n                 write!(fmt, \" -> [\")?;\n-                for (i, target) in successors.iter().enumerate() {\n+                for (i, target) in self.successors().enumerate() {\n                     if i > 0 {\n                         write!(fmt, \", \")?;\n                     }\n@@ -1113,26 +1137,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 if !expected {\n                     write!(fmt, \"!\")?;\n                 }\n-                write!(fmt, \"{:?}, \", cond)?;\n-\n-                match *msg {\n-                    AssertMessage::BoundsCheck { ref len, ref index } => {\n-                        write!(fmt, \"{:?}, {:?}, {:?}\",\n-                               \"index out of bounds: the len is {} but the index is {}\",\n-                               len, index)?;\n-                    }\n-                    AssertMessage::Math(ref err) => {\n-                        write!(fmt, \"{:?}\", err.description())?;\n-                    }\n-                    AssertMessage::GeneratorResumedAfterReturn => {\n-                        write!(fmt, \"{:?}\", \"generator resumed after completion\")?;\n-                    }\n-                    AssertMessage::GeneratorResumedAfterPanic => {\n-                        write!(fmt, \"{:?}\", \"generator resumed after panicking\")?;\n-                    }\n-                }\n-\n-                write!(fmt, \")\")\n+                write!(fmt, \"{:?}, \\\"{:?}\\\")\", cond, msg)\n             },\n             FalseEdges { .. } => write!(fmt, \"falseEdges\"),\n             FalseUnwind { .. } => write!(fmt, \"falseUnwind\"),\n@@ -1187,17 +1192,6 @@ impl<'tcx> TerminatorKind<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub enum AssertMessage<'tcx> {\n-    BoundsCheck {\n-        len: Operand<'tcx>,\n-        index: Operand<'tcx>\n-    },\n-    Math(ConstMathErr),\n-    GeneratorResumedAfterReturn,\n-    GeneratorResumedAfterPanic,\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Statements\n \n@@ -1898,12 +1892,13 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Result {\n \n pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n     use ty::TypeVariants::*;\n-    use rustc_const_math::ConstFloat;\n     match (value, &ty.sty) {\n         (Value::ByVal(PrimVal::Bytes(0)), &TyBool) => write!(f, \"false\"),\n         (Value::ByVal(PrimVal::Bytes(1)), &TyBool) => write!(f, \"true\"),\n-        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(fty)) =>\n-            write!(f, \"{}\", ConstFloat { bits, ty: fty }),\n+        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(ast::FloatTy::F32)) =>\n+            write!(f, \"{}f32\", Single::from_bits(bits)),\n+        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(ast::FloatTy::F64)) =>\n+            write!(f, \"{}f64\", Double::from_bits(bits)),\n         (Value::ByVal(PrimVal::Bytes(n)), &TyUint(ui)) => write!(f, \"{:?}{}\", n, ui),\n         (Value::ByVal(PrimVal::Bytes(n)), &TyInt(i)) => write!(f, \"{:?}{}\", n as i128, i),\n         (Value::ByVal(PrimVal::Bytes(n)), &TyChar) =>\n@@ -1952,7 +1947,7 @@ impl<'tcx> ControlFlowGraph for Mir<'tcx> {\n     fn successors<'graph>(&'graph self, node: Self::Node)\n                           -> <Self as GraphSuccessors<'graph>>::Iter\n     {\n-        self.basic_blocks[node].terminator().successors().into_owned().into_iter()\n+        self.basic_blocks[node].terminator().successors().cloned()\n     }\n }\n \n@@ -1963,7 +1958,7 @@ impl<'a, 'b> GraphPredecessors<'b> for Mir<'a> {\n \n impl<'a, 'b>  GraphSuccessors<'b> for Mir<'a> {\n     type Item = BasicBlock;\n-    type Iter = IntoIter<BasicBlock>;\n+    type Iter = iter::Cloned<Successors<'b>>;\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n@@ -1983,6 +1978,11 @@ impl fmt::Debug for Location {\n }\n \n impl Location {\n+    pub const START: Location = Location {\n+        block: START_BLOCK,\n+        statement_index: 0,\n+    };\n+\n     /// Returns the location immediately after this one within the enclosing block.\n     ///\n     /// Note that if this location represents a terminator, then the\n@@ -2029,6 +2029,12 @@ pub struct GeneratorLayout<'tcx> {\n     pub fields: Vec<LocalDecl<'tcx>>,\n }\n \n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct BorrowCheckResult<'gcx> {\n+    pub closure_requirements: Option<ClosureRegionRequirements<'gcx>>,\n+    pub used_mut_upvars: SmallVec<[Field; 8]>,\n+}\n+\n /// After we borrow check a closure, we are left with various\n /// requirements that we have inferred between the free regions that\n /// appear in the closure's signature or on its field types.  These\n@@ -2256,8 +2262,8 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 }\n             },\n             Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                let msg = if let AssertMessage::BoundsCheck { ref len, ref index } = *msg {\n-                    AssertMessage::BoundsCheck {\n+                let msg = if let EvalErrorKind::BoundsCheck { ref len, ref index } = *msg {\n+                    EvalErrorKind::BoundsCheck {\n                         len: len.fold_with(folder),\n                         index: index.fold_with(folder),\n                     }\n@@ -2306,7 +2312,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             },\n             Assert { ref cond, ref msg, .. } => {\n                 if cond.visit_with(visitor) {\n-                    if let AssertMessage::BoundsCheck { ref len, ref index } = *msg {\n+                    if let EvalErrorKind::BoundsCheck { ref len, ref index } = *msg {\n                         len.visit_with(visitor) || index.visit_with(visitor)\n                     } else {\n                         false"}, {"sha": "92888ed99e4729b395968a992cc69c8f7512c454", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n-\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -67,7 +65,7 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n             let data = &self.mir[idx];\n \n             if let Some(ref term) = data.terminator {\n-                for &succ in term.successors().iter() {\n+                for &succ in term.successors() {\n                     self.worklist.push(succ);\n                 }\n             }\n@@ -110,7 +108,7 @@ impl<'a, 'tcx> ExactSizeIterator for Preorder<'a, 'tcx> {}\n pub struct Postorder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n     visited: BitVector,\n-    visit_stack: Vec<(BasicBlock, vec::IntoIter<BasicBlock>)>\n+    visit_stack: Vec<(BasicBlock, Successors<'a>)>\n }\n \n impl<'a, 'tcx> Postorder<'a, 'tcx> {\n@@ -126,10 +124,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n \n         if let Some(ref term) = data.terminator {\n             po.visited.insert(root.index());\n-\n-            let succs = term.successors().into_owned().into_iter();\n-\n-            po.visit_stack.push((root, succs));\n+            po.visit_stack.push((root, term.successors()));\n             po.traverse_successor();\n         }\n \n@@ -186,7 +181,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n         // two iterations yield `C` and finally `A` for a final traversal of [E, D, B, C, A]\n         loop {\n             let bb = if let Some(&mut (_, ref mut iter)) = self.visit_stack.last_mut() {\n-                if let Some(bb) = iter.next() {\n+                if let Some(&bb) = iter.next() {\n                     bb\n                 } else {\n                     break;\n@@ -197,8 +192,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n \n             if self.visited.insert(bb.index()) {\n                 if let Some(ref term) = self.mir[bb].terminator {\n-                    let succs = term.successors().into_owned().into_iter();\n-                    self.visit_stack.push((bb, succs));\n+                    self.visit_stack.push((bb, term.successors()));\n                 }\n             }\n         }"}, {"sha": "59b6f3697541a0c8083079caf3d1f05391e25d45", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -511,17 +511,13 @@ macro_rules! make_mir_visitor {\n             fn super_assert_message(&mut self,\n                                     msg: & $($mutability)* AssertMessage<'tcx>,\n                                     location: Location) {\n-                match *msg {\n-                    AssertMessage::BoundsCheck {\n+                use mir::interpret::EvalErrorKind::*;\n+                if let BoundsCheck {\n                         ref $($mutability)* len,\n                         ref $($mutability)* index\n-                    } => {\n-                        self.visit_operand(len, location);\n-                        self.visit_operand(index, location);\n-                    }\n-                    AssertMessage::Math(_) => {},\n-                    AssertMessage::GeneratorResumedAfterReturn => {},\n-                    AssertMessage::GeneratorResumedAfterPanic => {},\n+                    } = *msg {\n+                    self.visit_operand(len, location);\n+                    self.visit_operand(index, location);\n                 }\n             }\n "}, {"sha": "0beda679e69592794be9d46f30235eaaf668f551", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1053,6 +1053,8 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n          2 = full debug info with variable and type information\"),\n     opt_level: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"optimize with possible levels 0-3, s, or z\"),\n+    force_frame_pointers: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"force use of the frame pointers\"),\n     debug_assertions: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"explicitly enable the cfg(debug_assertions) directive\"),\n     inline_threshold: Option<usize> = (None, parse_opt_uint, [TRACKED],\n@@ -1248,6 +1250,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"choose which RELRO level to use\"),\n     nll_subminimal_causes: bool = (false, parse_bool, [UNTRACKED],\n         \"when tracking region error causes, accept subminimal results for faster execution.\"),\n+    nll_facts: bool = (false, parse_bool, [UNTRACKED],\n+                       \"dump facts from NLL analysis into side files\"),\n     disable_nll_user_type_assert: bool = (false, parse_bool, [UNTRACKED],\n         \"disable user provided type assertion in NLL\"),\n     trans_time_graph: bool = (false, parse_bool, [UNTRACKED],\n@@ -1270,7 +1274,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     dep_info_omit_d_target: bool = (false, parse_bool, [TRACKED],\n         \"in dep-info output, omit targets for tracking dependencies of the dep-info files \\\n          themselves\"),\n-    approximate_suggestions: bool = (false, parse_bool, [UNTRACKED],\n+    suggestion_applicability: bool = (false, parse_bool, [UNTRACKED],\n         \"include machine-applicability of suggestions in JSON output\"),\n     unpretty: Option<String> = (None, parse_unpretty, [UNTRACKED],\n         \"Present the input source, unstable (and less-pretty) variants;\n@@ -1681,7 +1685,7 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> ast::CrateConfig {\n                 early_error(ErrorOutputType::default(), &msg)\n             }\n \n-            (meta_item.ident.name, meta_item.value_str())\n+            (meta_item.name(), meta_item.value_str())\n         })\n         .collect::<ast::CrateConfig>()\n }\n@@ -2965,6 +2969,10 @@ mod tests {\n         opts.cg.debuginfo = Some(0xba5eba11);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n+        opts = reference.clone();\n+        opts.cg.force_frame_pointers = Some(false);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n         opts = reference.clone();\n         opts.cg.debug_assertions = Some(true);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());"}, {"sha": "2ab72ba20bf4fc4b321ed9bd76b144e60efea2ea", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -20,7 +20,7 @@ use lint::builtin::BuiltinLintDiagnostics;\n use middle::allocator::AllocatorKind;\n use middle::dependency_format;\n use session::search_paths::PathKind;\n-use session::config::{DebugInfoLevel, OutputType};\n+use session::config::{OutputType};\n use ty::tls;\n use util::nodemap::{FxHashSet};\n use util::common::{duration_to_secs_str, ErrorReported};\n@@ -658,8 +658,11 @@ impl Session {\n     }\n \n     pub fn must_not_eliminate_frame_pointers(&self) -> bool {\n-        self.opts.debuginfo != DebugInfoLevel::NoDebugInfo\n-            || !self.target.target.options.eliminate_frame_pointer\n+        if let Some(x) = self.opts.cg.force_frame_pointers {\n+            x\n+        } else {\n+            !self.target.target.options.eliminate_frame_pointer\n+        }\n     }\n \n     /// Returns the symbol name for the registrar function,\n@@ -1002,7 +1005,7 @@ pub fn build_session_with_codemap(\n                     Some(registry),\n                     codemap.clone(),\n                     pretty,\n-                    sopts.debugging_opts.approximate_suggestions,\n+                    sopts.debugging_opts.suggestion_applicability,\n                 ).ui_testing(sopts.debugging_opts.ui_testing),\n             ),\n             (config::ErrorOutputType::Json(pretty), Some(dst)) => Box::new(\n@@ -1011,7 +1014,7 @@ pub fn build_session_with_codemap(\n                     Some(registry),\n                     codemap.clone(),\n                     pretty,\n-                    sopts.debugging_opts.approximate_suggestions,\n+                    sopts.debugging_opts.suggestion_applicability,\n                 ).ui_testing(sopts.debugging_opts.ui_testing),\n             ),\n             (config::ErrorOutputType::Short(color_config), None) => Box::new("}, {"sha": "5a626e7b82cc47c17f5b297dc63a9dc6ec1ad0a3", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -154,7 +154,10 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n                                            recursion_depth: 0,\n                                            predicate: p })\n                      .chain(obligations)\n-                     .find(|o| !selcx.evaluate_obligation(o));\n+                     .find(|o| !selcx.predicate_may_hold_fatal(o));\n+    // FIXME: the call to `selcx.predicate_may_hold_fatal` above should be ported\n+    // to the canonical trait query form, `infcx.predicate_may_hold`, once\n+    // the new system supports intercrate mode (which coherence needs).\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n         debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);"}, {"sha": "047d4bb893096103d38a4f6c3a6af6132ea3133d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -24,6 +24,7 @@ use super::{\n     SelectionContext,\n     SelectionError,\n     ObjectSafetyViolation,\n+    Overflow,\n };\n \n use errors::DiagnosticBuilder;\n@@ -659,8 +660,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 predicate: ty::Predicate::Trait(predicate),\n                                 .. obligation.clone()\n                             };\n-                            let mut selcx = SelectionContext::new(self);\n-                            if selcx.evaluate_obligation(&unit_obligation) {\n+                            if self.predicate_may_hold(&unit_obligation) {\n                                 err.note(\"the trait is implemented for `()`. \\\n                                          Possibly this error has been caused by changes to \\\n                                          Rust's type-inference algorithm \\\n@@ -830,6 +830,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 err.struct_error(self.tcx, span, \"constant expression\")\n             }\n+\n+            Overflow => {\n+                bug!(\"overflow should be handled before the `report_selection_error` path\");\n+            }\n         };\n         self.note_obligation_cause(&mut err, obligation);\n         err.emit();\n@@ -872,7 +876,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 .count();\n \n             let mut trait_type = trait_ref.self_ty();\n-            let mut selcx = SelectionContext::new(self);\n \n             for refs_remaining in 0..refs_number {\n                 if let ty::TypeVariants::TyRef(_, ty::TypeAndMut{ ty: t_type, mutbl: _ }) =\n@@ -886,7 +889,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                          obligation.param_env,\n                                                          new_trait_ref.to_predicate());\n \n-                    if selcx.evaluate_obligation(&new_obligation) {\n+                    if self.predicate_may_hold(&new_obligation) {\n                         let sp = self.tcx.sess.codemap()\n                             .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n \n@@ -976,6 +979,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                      ArgKind::Arg(format!(\"{}\", field.name), \"_\".to_string())\n                  }).collect::<Vec<_>>())\n             }\n+            hir::map::NodeStructCtor(ref variant_data) => {\n+                (self.tcx.sess.codemap().def_span(self.tcx.hir.span(variant_data.id())),\n+                 variant_data.fields()\n+                    .iter().map(|_| ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned()))\n+                    .collect())\n+            }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n         }\n     }\n@@ -1322,7 +1331,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 cleaned_pred.to_predicate()\n             );\n \n-            selcx.evaluate_obligation(&obligation)\n+            self.predicate_may_hold(&obligation)\n         })\n     }\n "}, {"sha": "6e20150718110ae2a0540ddf435ff1e3c64398c8", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n                 selcx,\n                 register_region_obligations: self.register_region_obligations\n             });\n-            debug!(\"select: outcome={:?}\", outcome);\n+            debug!(\"select: outcome={:#?}\", outcome);\n \n             // FIXME: if we kept the original cache key, we could mark projection\n             // obligations as complete for the projection cache here.\n@@ -333,7 +333,7 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n             if data.is_global() {\n                 // no type variables present, can use evaluation for better caching.\n                 // FIXME: consider caching errors too.\n-                if selcx.evaluate_obligation_conservatively(&obligation) {\n+                if selcx.infcx().predicate_must_hold(&obligation) {\n                     debug!(\"selecting trait `{:?}` at depth {} evaluated to holds\",\n                            data, obligation.recursion_depth);\n                     return Ok(Some(vec![]))"}, {"sha": "dd5208e908e19e117243b7a13280b27abeff8a7f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -41,7 +41,7 @@ pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n-pub use self::select::IntercrateAmbiguityCause;\n+pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::{SpecializesCache, find_associated_item};\n pub use self::engine::TraitEngine;\n@@ -74,6 +74,19 @@ pub enum IntercrateMode {\n     Fixed\n }\n \n+// The mode that trait queries run in\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum TraitQueryMode {\n+    // Standard/un-canonicalized queries get accurate\n+    // spans etc. passed in and hence can do reasonable\n+    // error reporting on their own.\n+    Standard,\n+    // Canonicalized queries get dummy spans and hence\n+    // must generally propagate errors to\n+    // pre-canonicalization callsites.\n+    Canonical,\n+}\n+\n /// An `Obligation` represents some trait reference (e.g. `int:Eq`) for\n /// which the vtable must be found.  The process of finding a vtable is\n /// called \"resolving\" the `Obligation`. This process consists of\n@@ -349,6 +362,7 @@ pub enum SelectionError<'tcx> {\n                                 ty::error::TypeError<'tcx>),\n     TraitNotObjectSafe(DefId),\n     ConstEvalFailure(ConstEvalErr<'tcx>),\n+    Overflow,\n }\n \n pub struct FulfillmentError<'tcx> {\n@@ -550,8 +564,7 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n         predicate: trait_ref.to_predicate(),\n     };\n \n-    let result = SelectionContext::new(infcx)\n-        .evaluate_obligation_conservatively(&obligation);\n+    let result = infcx.predicate_must_hold(&obligation);\n     debug!(\"type_known_to_meet_ty={:?} bound={} => {:?}\",\n            ty, infcx.tcx.item_path_str(def_id), result);\n "}, {"sha": "3cf7af30b3d551a0442f509f2a5279f2494cd5a3", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -18,10 +18,10 @@ use util::nodemap::FxHashMap;\n use syntax::ast::{MetaItem, NestedMetaItem};\n use syntax::attr;\n use syntax_pos::Span;\n-use syntax_pos::symbol::InternedString;\n+use syntax_pos::symbol::LocalInternedString;\n \n #[derive(Clone, Debug)]\n-pub struct OnUnimplementedFormatString(InternedString);\n+pub struct OnUnimplementedFormatString(LocalInternedString);\n \n #[derive(Debug)]\n pub struct OnUnimplementedDirective {\n@@ -190,7 +190,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n         for command in self.subcommands.iter().chain(Some(self)).rev() {\n             if let Some(ref condition) = command.condition {\n                 if !attr::eval_condition(condition, &tcx.sess.parse_sess, &mut |c| {\n-                    options.contains(&(c.ident.name.as_str().to_string(),\n+                    options.contains(&(c.name().as_str().to_string(),\n                                       match c.value_str().map(|s| s.as_str().to_string()) {\n                                           Some(s) => Some(s),\n                                           None => None\n@@ -225,7 +225,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n     pub fn try_parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                      trait_def_id: DefId,\n-                     from: InternedString,\n+                     from: LocalInternedString,\n                      err_sp: Span)\n                      -> Result<Self, ErrorReported>\n     {"}, {"sha": "45fa588bbf5334f821beec5a26a839d722d28274", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -188,15 +188,18 @@ pub fn poly_project_and_unify_type<'cx, 'gcx, 'tcx>(\n     let infcx = selcx.infcx();\n     infcx.commit_if_ok(|snapshot| {\n         let (skol_predicate, skol_map) =\n-            infcx.skolemize_late_bound_regions(&obligation.predicate, snapshot);\n+            infcx.skolemize_late_bound_regions(&obligation.predicate);\n \n         let skol_obligation = obligation.with(skol_predicate);\n         let r = match project_and_unify_type(selcx, &skol_obligation) {\n             Ok(result) => {\n                 let span = obligation.cause.span;\n                 match infcx.leak_check(false, span, &skol_map, snapshot) {\n                     Ok(()) => Ok(infcx.plug_leaks(skol_map, snapshot, result)),\n-                    Err(e) => Err(MismatchedProjectionTypes { err: e }),\n+                    Err(e) => {\n+                        debug!(\"poly_project_and_unify_type: leak check encountered error {:?}\", e);\n+                        Err(MismatchedProjectionTypes { err: e })\n+                    }\n                 }\n             }\n             Err(e) => {\n@@ -243,7 +246,10 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n             obligations.extend(inferred_obligations);\n             Ok(Some(obligations))\n         },\n-        Err(err) => Err(MismatchedProjectionTypes { err: err }),\n+        Err(err) => {\n+            debug!(\"project_and_unify_type: equating types encountered error {:?}\", err);\n+            Err(MismatchedProjectionTypes { err: err })\n+        }\n     }\n }\n \n@@ -403,7 +409,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n         if let ConstVal::Unevaluated(def_id, substs) = constant.val {\n             let tcx = self.selcx.tcx().global_tcx();\n             if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n-                if substs.needs_infer() {\n+                if substs.needs_infer() || substs.has_skol() {\n                     let identity_substs = Substs::identity_for_item(tcx, def_id);\n                     let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n                     if let Some(instance) = instance {"}, {"sha": "4e028cac49abe18474503d907447d865a88038f5", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::InferCtxt;\n+use infer::canonical::{Canonical, Canonicalize};\n+use traits::{EvaluationResult, PredicateObligation, SelectionContext,\n+             TraitQueryMode, OverflowError};\n+use traits::query::CanonicalPredicateGoal;\n+use ty::{ParamEnvAnd, Predicate, TyCtxt};\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Evaluates whether the predicate can be satisfied (by any means)\n+    /// in the given `ParamEnv`.\n+    pub fn predicate_may_hold(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool {\n+        self.evaluate_obligation(obligation).may_apply()\n+    }\n+\n+    /// Evaluates whether the predicate can be satisfied in the given\n+    /// `ParamEnv`, and returns `false` if not certain. However, this is\n+    /// not entirely accurate if inference variables are involved.\n+    pub fn predicate_must_hold(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool {\n+        self.evaluate_obligation(obligation) == EvaluationResult::EvaluatedToOk\n+    }\n+\n+    // Helper function that canonicalizes and runs the query, as well as handles\n+    // overflow.\n+    fn evaluate_obligation(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> EvaluationResult {\n+        let (c_pred, _) =\n+            self.canonicalize_query(&obligation.param_env.and(obligation.predicate));\n+        // Run canonical query. If overflow occurs, rerun from scratch but this time\n+        // in standard trait query mode so that overflow is handled appropriately\n+        // within `SelectionContext`.\n+        match self.tcx.global_tcx().evaluate_obligation(c_pred) {\n+            Ok(result) => result,\n+            Err(OverflowError) => {\n+                let mut selcx =\n+                    SelectionContext::with_query_mode(&self, TraitQueryMode::Standard);\n+                selcx.evaluate_obligation_recursively(obligation)\n+                     .expect(\"Overflow should be caught earlier in standard query mode\")\n+            }\n+        }\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ParamEnvAnd<'tcx, Predicate<'tcx>> {\n+    type Canonicalized = CanonicalPredicateGoal<'gcx>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized {\n+        value\n+    }\n+}"}, {"sha": "096633ddab2f7893cb6961a27b4e357c0ae7bad3", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -19,6 +19,7 @@ use infer::canonical::Canonical;\n use ty::{self, Ty};\n \n pub mod dropck_outlives;\n+pub mod evaluate_obligation;\n pub mod normalize;\n pub mod normalize_erasing_regions;\n \n@@ -27,6 +28,9 @@ pub type CanonicalProjectionGoal<'tcx> =\n \n pub type CanonicalTyGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Ty<'tcx>>>;\n \n+pub type CanonicalPredicateGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::Predicate<'tcx>>>;\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct NoSolution;\n "}, {"sha": "f074e06165311bb12d26344fe7611457280ce010", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -196,7 +196,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n         if let ConstVal::Unevaluated(def_id, substs) = constant.val {\n             let tcx = self.infcx.tcx.global_tcx();\n             if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n-                if substs.needs_infer() {\n+                if substs.needs_infer() || substs.has_skol() {\n                     let identity_substs = Substs::identity_for_item(tcx, def_id);\n                     let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n                     if let Some(instance) = instance {"}, {"sha": "54b2cf2808282fba665ed7f2ac777a088a59c458", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 162, "deletions": 90, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -17,12 +17,12 @@ use self::EvaluationResult::*;\n \n use super::coherence::{self, Conflict};\n use super::DerivedObligationCause;\n-use super::IntercrateMode;\n+use super::{IntercrateMode, TraitQueryMode};\n use super::project;\n use super::project::{normalize_with_depth, Normalized, ProjectionCacheKey};\n use super::{PredicateObligation, TraitObligation, ObligationCause};\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n-use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n+use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch, Overflow};\n use super::{ObjectCastObligation, Obligation};\n use super::TraitNotObjectSafe;\n use super::Selection;\n@@ -87,7 +87,12 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     /// Controls whether or not to filter out negative impls when selecting.\n     /// This is used in librustdoc to distinguish between the lack of an impl\n     /// and a negative impl\n-    allow_negative_impls: bool\n+    allow_negative_impls: bool,\n+\n+    /// The mode that trait queries run in, which informs our error handling\n+    /// policy. In essence, canonicalized queries need their errors propagated\n+    /// rather than immediately reported because we do not have accurate spans.\n+    query_mode: TraitQueryMode,\n }\n \n #[derive(Clone, Debug)]\n@@ -319,7 +324,7 @@ enum BuiltinImplConditions<'tcx> {\n ///     all the \"potential success\" candidates can potentially succeed,\n ///     so they are no-ops when unioned with a definite error, and within\n ///     the categories it's easy to see that the unions are correct.\n-enum EvaluationResult {\n+pub enum EvaluationResult {\n     /// Evaluation successful\n     EvaluatedToOk,\n     /// Evaluation is known to be ambiguous - it *might* hold for some\n@@ -385,7 +390,7 @@ enum EvaluationResult {\n }\n \n impl EvaluationResult {\n-    fn may_apply(self) -> bool {\n+    pub fn may_apply(self) -> bool {\n         match self {\n             EvaluatedToOk |\n             EvaluatedToAmbig |\n@@ -408,6 +413,26 @@ impl EvaluationResult {\n     }\n }\n \n+impl_stable_hash_for!(enum self::EvaluationResult {\n+    EvaluatedToOk,\n+    EvaluatedToAmbig,\n+    EvaluatedToUnknown,\n+    EvaluatedToRecur,\n+    EvaluatedToErr\n+});\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+/// Indicates that trait evaluation caused overflow.\n+pub struct OverflowError;\n+\n+impl_stable_hash_for!(struct OverflowError { });\n+\n+impl<'tcx> From<OverflowError> for SelectionError<'tcx> {\n+    fn from(OverflowError: OverflowError) -> SelectionError<'tcx> {\n+        SelectionError::Overflow\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct EvaluationCache<'tcx> {\n     hashmap: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, WithDepNode<EvaluationResult>>>\n@@ -421,6 +446,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             intercrate: None,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n+            query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n@@ -433,6 +459,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             intercrate: Some(mode),\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n+            query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n@@ -445,6 +472,20 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             intercrate: None,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls,\n+            query_mode: TraitQueryMode::Standard,\n+        }\n+    }\n+\n+    pub fn with_query_mode(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+                           query_mode: TraitQueryMode) -> SelectionContext<'cx, 'gcx, 'tcx> {\n+        debug!(\"with_query_mode({:?})\", query_mode);\n+        SelectionContext {\n+            infcx,\n+            freshener: infcx.freshener(),\n+            intercrate: None,\n+            intercrate_ambiguity_causes: None,\n+            allow_negative_impls: false,\n+            query_mode,\n         }\n     }\n \n@@ -528,12 +569,27 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         assert!(!obligation.predicate.has_escaping_regions());\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n-        let ret = match self.candidate_from_obligation(&stack)? {\n-            None => None,\n-            Some(candidate) => Some(self.confirm_candidate(obligation, candidate)?)\n+\n+        let candidate = match self.candidate_from_obligation(&stack) {\n+            Err(SelectionError::Overflow) => {\n+                // In standard mode, overflow must have been caught and reported\n+                // earlier.\n+                assert!(self.query_mode == TraitQueryMode::Canonical);\n+                return Err(SelectionError::Overflow);\n+            },\n+            Err(e) => { return Err(e); },\n+            Ok(None) => { return Ok(None); },\n+            Ok(Some(candidate)) => candidate\n         };\n \n-        Ok(ret)\n+        match self.confirm_candidate(obligation, candidate) {\n+            Err(SelectionError::Overflow) => {\n+                assert!(self.query_mode == TraitQueryMode::Canonical);\n+                return Err(SelectionError::Overflow);\n+            },\n+            Err(e) => Err(e),\n+            Ok(candidate) => Ok(Some(candidate))\n+        }\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -547,32 +603,30 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     // we can be sure it does not.\n \n     /// Evaluates whether the obligation `obligation` can be satisfied (by any means).\n-    pub fn evaluate_obligation(&mut self,\n-                               obligation: &PredicateObligation<'tcx>)\n-                               -> bool\n+    pub fn predicate_may_hold_fatal(&mut self,\n+                                    obligation: &PredicateObligation<'tcx>)\n+                                    -> bool\n     {\n-        debug!(\"evaluate_obligation({:?})\",\n+        debug!(\"predicate_may_hold_fatal({:?})\",\n                obligation);\n \n-        self.probe(|this, _| {\n-            this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n-                .may_apply()\n-        })\n+        // This fatal query is a stopgap that should only be used in standard mode,\n+        // where we do not expect overflow to be propagated.\n+        assert!(self.query_mode == TraitQueryMode::Standard);\n+\n+        self.evaluate_obligation_recursively(obligation)\n+            .expect(\"Overflow should be caught earlier in standard query mode\")\n+            .may_apply()\n     }\n \n-    /// Evaluates whether the obligation `obligation` can be satisfied,\n-    /// and returns `false` if not certain. However, this is not entirely\n-    /// accurate if inference variables are involved.\n-    pub fn evaluate_obligation_conservatively(&mut self,\n-                                              obligation: &PredicateObligation<'tcx>)\n-                                              -> bool\n+    /// Evaluates whether the obligation `obligation` can be satisfied and returns\n+    /// an `EvaluationResult`.\n+    pub fn evaluate_obligation_recursively(&mut self,\n+                                           obligation: &PredicateObligation<'tcx>)\n+                                           -> Result<EvaluationResult, OverflowError>\n     {\n-        debug!(\"evaluate_obligation_conservatively({:?})\",\n-               obligation);\n-\n         self.probe(|this, _| {\n             this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n-                == EvaluatedToOk\n         })\n     }\n \n@@ -582,29 +636,29 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_predicates_recursively<'a,'o,I>(&mut self,\n                                                 stack: TraitObligationStackList<'o, 'tcx>,\n                                                 predicates: I)\n-                                                -> EvaluationResult\n+                                                -> Result<EvaluationResult, OverflowError>\n         where I : IntoIterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in predicates {\n-            let eval = self.evaluate_predicate_recursively(stack, obligation);\n+            let eval = self.evaluate_predicate_recursively(stack, obligation)?;\n             debug!(\"evaluate_predicate_recursively({:?}) = {:?}\",\n                    obligation, eval);\n             if let EvaluatedToErr = eval {\n                 // fast-path - EvaluatedToErr is the top of the lattice,\n                 // so we don't need to look on the other predicates.\n-                return EvaluatedToErr;\n+                return Ok(EvaluatedToErr);\n             } else {\n                 result = cmp::max(result, eval);\n             }\n         }\n-        result\n+        Ok(result)\n     }\n \n     fn evaluate_predicate_recursively<'o>(&mut self,\n                                           previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                           obligation: &PredicateObligation<'tcx>)\n-                                           -> EvaluationResult\n+                                           -> Result<EvaluationResult, OverflowError>\n     {\n         debug!(\"evaluate_predicate_recursively({:?})\",\n                obligation);\n@@ -620,11 +674,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // does this code ever run?\n                 match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                     Some(Ok(InferOk { obligations, .. })) => {\n-                        self.evaluate_predicates_recursively(previous_stack, &obligations);\n-                        EvaluatedToOk\n+                        self.evaluate_predicates_recursively(previous_stack, &obligations)\n                     },\n-                    Some(Err(_)) => EvaluatedToErr,\n-                    None => EvaluatedToAmbig,\n+                    Some(Err(_)) => Ok(EvaluatedToErr),\n+                    None => Ok(EvaluatedToAmbig),\n                 }\n             }\n \n@@ -636,21 +689,21 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     Some(obligations) =>\n                         self.evaluate_predicates_recursively(previous_stack, obligations.iter()),\n                     None =>\n-                        EvaluatedToAmbig,\n+                        Ok(EvaluatedToAmbig),\n                 }\n             }\n \n             ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => {\n                 // we do not consider region relationships when\n                 // evaluating trait matches\n-                EvaluatedToOk\n+                Ok(EvaluatedToOk)\n             }\n \n             ty::Predicate::ObjectSafe(trait_def_id) => {\n                 if self.tcx().is_object_safe(trait_def_id) {\n-                    EvaluatedToOk\n+                    Ok(EvaluatedToOk)\n                 } else {\n-                    EvaluatedToErr\n+                    Ok(EvaluatedToErr)\n                 }\n             }\n \n@@ -668,10 +721,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         result\n                     }\n                     Ok(None) => {\n-                        EvaluatedToAmbig\n+                        Ok(EvaluatedToAmbig)\n                     }\n                     Err(_) => {\n-                        EvaluatedToErr\n+                        Ok(EvaluatedToErr)\n                     }\n                 }\n             }\n@@ -680,13 +733,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 match self.infcx.closure_kind(closure_def_id, closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n-                            EvaluatedToOk\n+                            Ok(EvaluatedToOk)\n                         } else {\n-                            EvaluatedToErr\n+                            Ok(EvaluatedToErr)\n                         }\n                     }\n                     None => {\n-                        EvaluatedToAmbig\n+                        Ok(EvaluatedToAmbig)\n                     }\n                 }\n             }\n@@ -707,16 +760,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                 promoted: None\n                             };\n                             match self.tcx().const_eval(param_env.and(cid)) {\n-                                Ok(_) => EvaluatedToOk,\n-                                Err(_) => EvaluatedToErr\n+                                Ok(_) => Ok(EvaluatedToOk),\n+                                Err(_) => Ok(EvaluatedToErr)\n                             }\n                         } else {\n-                            EvaluatedToErr\n+                            Ok(EvaluatedToErr)\n                         }\n                     }\n                     None => {\n                         // Inference variables still left in param_env or substs.\n-                        EvaluatedToAmbig\n+                        Ok(EvaluatedToAmbig)\n                     }\n                 }\n             }\n@@ -726,7 +779,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_trait_predicate_recursively<'o>(&mut self,\n                                                 previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                                 mut obligation: TraitObligation<'tcx>)\n-                                                -> EvaluationResult\n+                                                -> Result<EvaluationResult, OverflowError>\n     {\n         debug!(\"evaluate_trait_predicate_recursively({:?})\",\n                obligation);\n@@ -745,22 +798,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             debug!(\"CACHE HIT: EVAL({:?})={:?}\",\n                    fresh_trait_ref,\n                    result);\n-            return result;\n+            return Ok(result);\n         }\n \n         let (result, dep_node) = self.in_task(|this| this.evaluate_stack(&stack));\n+        let result = result?;\n \n         debug!(\"CACHE MISS: EVAL({:?})={:?}\",\n                fresh_trait_ref,\n                result);\n         self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n \n-        result\n+        Ok(result)\n     }\n \n     fn evaluate_stack<'o>(&mut self,\n                           stack: &TraitObligationStack<'o, 'tcx>)\n-                          -> EvaluationResult\n+                          -> Result<EvaluationResult, OverflowError>\n     {\n         // In intercrate mode, whenever any of the types are unbound,\n         // there can always be an impl. Even if there are no impls in\n@@ -815,7 +869,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            return EvaluatedToAmbig;\n+            return Ok(EvaluatedToAmbig);\n         }\n         if unbound_input_types &&\n               stack.iter().skip(1).any(\n@@ -825,7 +879,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         {\n             debug!(\"evaluate_stack({:?}) --> unbound argument, recursive --> giving up\",\n                    stack.fresh_trait_ref);\n-            return EvaluatedToUnknown;\n+            return Ok(EvaluatedToUnknown);\n         }\n \n         // If there is any previous entry on the stack that precisely\n@@ -860,18 +914,19 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             if self.coinductive_match(cycle) {\n                 debug!(\"evaluate_stack({:?}) --> recursive, coinductive\",\n                        stack.fresh_trait_ref);\n-                return EvaluatedToOk;\n+                return Ok(EvaluatedToOk);\n             } else {\n                 debug!(\"evaluate_stack({:?}) --> recursive, inductive\",\n                        stack.fresh_trait_ref);\n-                return EvaluatedToRecur;\n+                return Ok(EvaluatedToRecur);\n             }\n         }\n \n         match self.candidate_from_obligation(stack) {\n             Ok(Some(c)) => self.evaluate_candidate(stack, &c),\n-            Ok(None) => EvaluatedToAmbig,\n-            Err(..) => EvaluatedToErr\n+            Ok(None) => Ok(EvaluatedToAmbig),\n+            Err(Overflow) => Err(OverflowError),\n+            Err(..) => Ok(EvaluatedToErr)\n         }\n     }\n \n@@ -909,7 +964,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_candidate<'o>(&mut self,\n                               stack: &TraitObligationStack<'o, 'tcx>,\n                               candidate: &SelectionCandidate<'tcx>)\n-                              -> EvaluationResult\n+                              -> Result<EvaluationResult, OverflowError>\n     {\n         debug!(\"evaluate_candidate: depth={} candidate={:?}\",\n                stack.obligation.recursion_depth, candidate);\n@@ -921,12 +976,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         stack.list(),\n                         selection.nested_obligations().iter())\n                 }\n-                Err(..) => EvaluatedToErr\n+                Err(..) => Ok(EvaluatedToErr)\n             }\n-        });\n+        })?;\n         debug!(\"evaluate_candidate: depth={} result={:?}\",\n                stack.obligation.recursion_depth, result);\n-        result\n+        Ok(result)\n     }\n \n     fn check_evaluation_cache(&self,\n@@ -1000,7 +1055,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // not update) the cache.\n         let recursion_limit = *self.infcx.tcx.sess.recursion_limit.get();\n         if stack.obligation.recursion_depth >= recursion_limit {\n-            self.infcx().report_overflow_error(&stack.obligation, true);\n+            match self.query_mode {\n+                TraitQueryMode::Standard => {\n+                    self.infcx().report_overflow_error(&stack.obligation, true);\n+                },\n+                TraitQueryMode::Canonical => {\n+                    return Err(Overflow);\n+                },\n+            }\n         }\n \n         // Check the cache. Note that we skolemize the trait-ref\n@@ -1081,9 +1143,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n                     // Heuristics: show the diagnostics when there are no candidates in crate.\n                     if let Ok(candidate_set) = self.assemble_candidates(stack) {\n-                        if !candidate_set.ambiguous && candidate_set.vec.iter().all(|c| {\n-                            !self.evaluate_candidate(stack, &c).may_apply()\n-                        }) {\n+                        let no_candidates_apply =\n+                            candidate_set\n+                            .vec\n+                            .iter()\n+                            .map(|c| self.evaluate_candidate(stack, &c))\n+                            .collect::<Result<Vec<_>, OverflowError>>()?\n+                            .iter()\n+                            .all(|r| !r.may_apply());\n+                        if !candidate_set.ambiguous && no_candidates_apply {\n                             let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n                             let self_ty = trait_ref.self_ty();\n                             let trait_desc = trait_ref.to_string();\n@@ -1151,18 +1219,21 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n \n         // Winnow, but record the exact outcome of evaluation, which\n-        // is needed for specialization.\n-        let mut candidates: Vec<_> = candidates.into_iter().filter_map(|c| {\n-            let eval = self.evaluate_candidate(stack, &c);\n-            if eval.may_apply() {\n-                Some(EvaluatedCandidate {\n+        // is needed for specialization. Propagate overflow if it occurs.\n+        let candidates: Result<Vec<Option<EvaluatedCandidate>>, _> = candidates\n+            .into_iter()\n+            .map(|c| match self.evaluate_candidate(stack, &c) {\n+                Ok(eval) if eval.may_apply() => Ok(Some(EvaluatedCandidate {\n                     candidate: c,\n                     evaluation: eval,\n-                })\n-            } else {\n-                None\n-            }\n-        }).collect();\n+                })),\n+                Ok(_) => Ok(None),\n+                Err(OverflowError) => Err(Overflow),\n+            })\n+            .collect();\n+\n+        let mut candidates: Vec<EvaluatedCandidate> =\n+            candidates?.into_iter().filter_map(|c| c).collect();\n \n         // If there are STILL multiple candidate, we can further\n         // reduce the list by dropping duplicates -- including\n@@ -1438,7 +1509,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let poly_trait_predicate =\n             self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n         let (skol_trait_predicate, skol_map) =\n-            self.infcx().skolemize_late_bound_regions(&poly_trait_predicate, snapshot);\n+            self.infcx().skolemize_late_bound_regions(&poly_trait_predicate);\n         debug!(\"match_projection_obligation_against_definition_bounds: \\\n                 skol_trait_predicate={:?} skol_map={:?}\",\n                skol_trait_predicate,\n@@ -1537,12 +1608,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let matching_bounds =\n             all_bounds.filter(|p| p.def_id() == stack.obligation.predicate.def_id());\n \n-        let matching_bounds =\n-            matching_bounds.filter(\n-                |bound| self.evaluate_where_clause(stack, bound.clone()).may_apply());\n-\n-        let param_candidates =\n-            matching_bounds.map(|bound| ParamCandidate(bound));\n+        // keep only those bounds which may apply, and propagate overflow if it occurs\n+        let mut param_candidates = vec![];\n+        for bound in matching_bounds {\n+            let wc = self.evaluate_where_clause(stack, bound.clone())?;\n+            if wc.may_apply() {\n+                param_candidates.push(ParamCandidate(bound));\n+            }\n+        }\n \n         candidates.vec.extend(param_candidates);\n \n@@ -1552,14 +1625,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_where_clause<'o>(&mut self,\n                                  stack: &TraitObligationStack<'o, 'tcx>,\n                                  where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n-                                 -> EvaluationResult\n+                                 -> Result<EvaluationResult, OverflowError>\n     {\n         self.probe(move |this, _| {\n             match this.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n                     this.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n-                Err(()) => EvaluatedToErr\n+                Err(()) => Ok(EvaluatedToErr)\n             }\n         })\n     }\n@@ -2265,7 +2338,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             self.in_snapshot(|this, snapshot| {\n                 let (skol_ty, skol_map) =\n-                    this.infcx().skolemize_late_bound_regions(&ty, snapshot);\n+                    this.infcx().skolemize_late_bound_regions(&ty);\n                 let Normalized { value: normalized_ty, mut obligations } =\n                     project::normalize_with_depth(this,\n                                                   param_env,\n@@ -2486,7 +2559,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let trait_obligations = self.in_snapshot(|this, snapshot| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n             let (trait_ref, skol_map) =\n-                this.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n+                this.infcx().skolemize_late_bound_regions(&poly_trait_ref);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n             this.impl_or_trait_obligations(cause,\n                                            obligation.recursion_depth + 1,\n@@ -3069,8 +3142,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n \n         let (skol_obligation, skol_map) = self.infcx().skolemize_late_bound_regions(\n-            &obligation.predicate,\n-            snapshot);\n+            &obligation.predicate);\n         let skol_obligation_trait_ref = skol_obligation.trait_ref;\n \n         let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span,"}, {"sha": "d7e42655bbb5be35eca4e6b14c757a7778c0a167", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -177,6 +177,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n             super::ConstEvalFailure(ref err) => {\n                 tcx.lift(err).map(super::ConstEvalFailure)\n             }\n+            super::Overflow => bug!() // FIXME: ape ConstEvalFailure?\n         }\n     }\n }"}, {"sha": "3d154e43a9ae12972cd81f0111e328887102effe", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -34,7 +34,7 @@ use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n use mir::{self, Mir, interpret};\n use mir::interpret::{Value, PrimVal};\n-use ty::subst::{Kind, Substs};\n+use ty::subst::{Kind, Substs, Subst};\n use ty::ReprOptions;\n use ty::Instance;\n use traits;\n@@ -1467,6 +1467,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.borrowck_mode().use_mir()\n     }\n \n+    /// If true, pattern variables for use in guards on match arms\n+    /// will be bound as references to the data, and occurrences of\n+    /// those variables in the guard expression will implicitly\n+    /// dereference those bindings. (See rust-lang/rust#27282.)\n+    pub fn all_pat_vars_are_implicit_refs_within_guards(self) -> bool {\n+        self.borrowck_mode().use_mir()\n+    }\n+\n     /// If true, we should enable two-phase borrows checks. This is\n     /// done with either `-Ztwo-phase-borrows` or with\n     /// `#![feature(nll)]`.\n@@ -2119,7 +2127,7 @@ macro_rules! intern_method {\n                                             $alloc_method:ident,\n                                             $alloc_to_key:expr,\n                                             $alloc_to_ret:expr,\n-                                            $needs_infer:expr) -> $ty:ty) => {\n+                                            $keep_in_local_tcx:expr) -> $ty:ty) => {\n         impl<'a, 'gcx, $lt_tcx> TyCtxt<'a, 'gcx, $lt_tcx> {\n             pub fn $method(self, v: $alloc) -> &$lt_tcx $ty {\n                 {\n@@ -2137,7 +2145,7 @@ macro_rules! intern_method {\n                 // HACK(eddyb) Depend on flags being accurate to\n                 // determine that all contents are in the global tcx.\n                 // See comments on Lift for why we can't use that.\n-                if !($needs_infer)(&v) {\n+                if !($keep_in_local_tcx)(&v) {\n                     if !self.is_global() {\n                         let v = unsafe {\n                             mem::transmute(v)\n@@ -2165,7 +2173,7 @@ macro_rules! intern_method {\n }\n \n macro_rules! direct_interners {\n-    ($lt_tcx:tt, $($name:ident: $method:ident($needs_infer:expr) -> $ty:ty),+) => {\n+    ($lt_tcx:tt, $($name:ident: $method:ident($keep_in_local_tcx:expr) -> $ty:ty),+) => {\n         $(impl<$lt_tcx> PartialEq for Interned<$lt_tcx, $ty> {\n             fn eq(&self, other: &Self) -> bool {\n                 self.0 == other.0\n@@ -2180,7 +2188,10 @@ macro_rules! direct_interners {\n             }\n         }\n \n-        intern_method!($lt_tcx, $name: $method($ty, alloc, |x| x, |x| x, $needs_infer) -> $ty);)+\n+        intern_method!(\n+            $lt_tcx,\n+            $name: $method($ty, alloc, |x| x, |x| x, $keep_in_local_tcx) -> $ty\n+        );)+\n     }\n }\n \n@@ -2189,12 +2200,7 @@ pub fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n }\n \n direct_interners!('tcx,\n-    region: mk_region(|r| {\n-        match r {\n-            &ty::ReVar(_) | &ty::ReSkolemized(..) => true,\n-            _ => false\n-        }\n-    }) -> RegionKind,\n+    region: mk_region(|r: &RegionKind| r.keep_in_local_tcx()) -> RegionKind,\n     const_: mk_const(|c: &Const| keep_local(&c.ty) || keep_local(&c.val)) -> Const<'tcx>\n );\n \n@@ -2328,7 +2334,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem);\n         let adt_def = self.adt_def(def_id);\n-        let substs = self.mk_substs(iter::once(Kind::from(ty)));\n+        let generics = self.generics_of(def_id);\n+        let mut substs = vec![Kind::from(ty)];\n+        // Add defaults for other generic params if there are some.\n+        for def in generics.types.iter().skip(1) {\n+            assert!(def.has_default);\n+            let ty = self.type_of(def.def_id).subst(self, &substs);\n+            substs.push(ty.into());\n+        }\n+        let substs = self.mk_substs(substs.into_iter());\n         self.mk_ty(TyAdt(adt_def, substs))\n     }\n \n@@ -2471,7 +2485,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_self_type(self) -> Ty<'tcx> {\n-        self.mk_param(0, keywords::SelfType.name().as_str())\n+        self.mk_param(0, keywords::SelfType.name().as_interned_str())\n     }\n \n     pub fn mk_param_from_def(self, def: &ty::TypeParameterDef) -> Ty<'tcx> {"}, {"sha": "1793b5e1edba8e0f3ca76ee956775bd8bb82cb1e", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -43,8 +43,8 @@ use middle::const_val::ConstVal;\n use hir::def_id::DefId;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n \n+use rustc_data_structures::lazy_btree_map::LazyBTreeMap;\n use std::fmt;\n-use std::collections::BTreeMap;\n use util::nodemap::FxHashSet;\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n@@ -91,6 +91,9 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn needs_infer(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER)\n     }\n+    fn has_skol(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_RE_SKOL)\n+    }\n     fn needs_subst(&self) -> bool {\n         self.has_type_flags(TypeFlags::NEEDS_SUBST)\n     }\n@@ -111,15 +114,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n     }\n \n-    fn is_normalized_for_trans(&self) -> bool {\n-        !self.has_type_flags(TypeFlags::HAS_RE_INFER |\n-                             TypeFlags::HAS_FREE_REGIONS |\n-                             TypeFlags::HAS_TY_INFER |\n-                             TypeFlags::HAS_PARAMS |\n-                             TypeFlags::HAS_NORMALIZABLE_PROJECTION |\n-                             TypeFlags::HAS_TY_ERR |\n-                             TypeFlags::HAS_SELF)\n-    }\n     /// Indicates whether this value references only 'global'\n     /// types/lifetimes that are the same regardless of what fn we are\n     /// in. This is used for caching. Errs on the side of returning\n@@ -334,7 +328,7 @@ struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     current_depth: u32,\n     fld_r: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n-    map: BTreeMap<ty::BoundRegion, ty::Region<'tcx>>\n+    map: LazyBTreeMap<ty::BoundRegion, ty::Region<'tcx>>\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -349,7 +343,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n-        -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+        -> (T, LazyBTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where F : FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               T : TypeFoldable<'tcx>,\n     {\n@@ -462,7 +456,7 @@ impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n             tcx,\n             current_depth: 1,\n             fld_r,\n-            map: BTreeMap::default()\n+            map: LazyBTreeMap::default()\n         }\n     }\n }"}, {"sha": "752b7f69a6a7ffc41d14c260d33f9eb6cf218db8", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -14,7 +14,7 @@ use ty::{self, Ty, TyCtxt};\n use middle::cstore::{ExternCrate, ExternCrateSource};\n use syntax::ast;\n use syntax::symbol::Symbol;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::LocalInternedString;\n \n use std::cell::Cell;\n \n@@ -131,7 +131,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         let visible_parent_map = self.visible_parent_map(LOCAL_CRATE);\n \n-        let (mut cur_def, mut cur_path) = (external_def_id, Vec::<InternedString>::new());\n+        let (mut cur_def, mut cur_path) = (external_def_id, Vec::<LocalInternedString>::new());\n         loop {\n             // If `cur_def` is a direct or injected extern crate, push the path to the crate\n             // followed by the path to the item within the crate and return.\n@@ -168,8 +168,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             let data = cur_def_key.disambiguated_data.data;\n-            let symbol =\n-                data.get_opt_name().unwrap_or_else(|| Symbol::intern(\"<unnamed>\").as_str());\n+            let symbol = data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n+                Symbol::intern(\"<unnamed>\").as_str()\n+            });\n             cur_path.push(symbol);\n \n             match visible_parent_map.get(&cur_def) {\n@@ -221,7 +222,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::GlobalMetaData(..) => {\n                 let parent_def_id = self.parent_def_id(def_id).unwrap();\n                 self.push_item_path(buffer, parent_def_id);\n-                buffer.push(&data.as_interned_str());\n+                buffer.push(&data.as_interned_str().as_symbol().as_str());\n             }\n             DefPathData::StructCtor => { // present `X` instead of `X::{{constructor}}`\n                 let parent_def_id = self.parent_def_id(def_id).unwrap();"}, {"sha": "a319b341ebbf06ee2bbc82d07829668c31393ad8", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 100, "deletions": 35, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -19,7 +19,6 @@ use std::cmp;\n use std::fmt;\n use std::i128;\n use std::mem;\n-use std::ops::RangeInclusive;\n \n use ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n@@ -149,7 +148,7 @@ pub const FAT_PTR_ADDR: usize = 0;\n /// - For a slice, this is the length.\n pub const FAT_PTR_EXTRA: usize = 1;\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum LayoutError<'tcx> {\n     Unknown(Ty<'tcx>),\n     SizeOverflow(Ty<'tcx>)\n@@ -492,7 +491,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             ty::TyFloat(FloatTy::F64) => scalar(F64),\n             ty::TyFnPtr(_) => {\n                 let mut ptr = scalar_unit(Pointer);\n-                ptr.valid_range.start = 1;\n+                ptr.valid_range = 1..=*ptr.valid_range.end();\n                 tcx.intern_layout(LayoutDetails::scalar(self, ptr))\n             }\n \n@@ -506,7 +505,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let mut data_ptr = scalar_unit(Pointer);\n                 if !ty.is_unsafe_ptr() {\n-                    data_ptr.valid_range.start = 1;\n+                    data_ptr.valid_range = 1..=*data_ptr.valid_range.end();\n                 }\n \n                 let pointee = tcx.normalize_erasing_regions(param_env, pointee);\n@@ -524,7 +523,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     }\n                     ty::TyDynamic(..) => {\n                         let mut vtable = scalar_unit(Pointer);\n-                        vtable.valid_range.start = 1;\n+                        vtable.valid_range = 1..=*vtable.valid_range.end();\n                         vtable\n                     }\n                     _ => return Err(LayoutError::Unknown(unsized_part))\n@@ -751,8 +750,8 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         match st.abi {\n                             Abi::Scalar(ref mut scalar) |\n                             Abi::ScalarPair(ref mut scalar, _) => {\n-                                if scalar.valid_range.start == 0 {\n-                                    scalar.valid_range.start = 1;\n+                                if *scalar.valid_range.start() == 0 {\n+                                    scalar.valid_range = 1..=*scalar.valid_range.end();\n                                 }\n                             }\n                             _ => {}\n@@ -788,18 +787,15 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                                 }\n                             }\n                         }\n-                        if niche_variants.start > v {\n-                            niche_variants.start = v;\n-                        }\n-                        niche_variants.end = v;\n+                        niche_variants = *niche_variants.start().min(&v)..=v;\n                     }\n \n-                    if niche_variants.start > niche_variants.end {\n+                    if niche_variants.start() > niche_variants.end() {\n                         dataful_variant = None;\n                     }\n \n                     if let Some(i) = dataful_variant {\n-                        let count = (niche_variants.end - niche_variants.start + 1) as u128;\n+                        let count = (niche_variants.end() - niche_variants.start() + 1) as u128;\n                         for (field_index, &field) in variants[i].iter().enumerate() {\n                             let (offset, niche, niche_start) =\n                                 match self.find_niche(field, count)? {\n@@ -897,7 +893,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n \n                 // Create the set of structs that represent each variant.\n-                let mut variants = variants.into_iter().enumerate().map(|(i, field_layouts)| {\n+                let mut layout_variants = variants.iter().enumerate().map(|(i, field_layouts)| {\n                     let mut st = univariant_uninterned(&field_layouts,\n                         &def.repr, StructKind::Prefixed(min_ity.size(), prefix_align))?;\n                     st.variants = Variants::Single { index: i };\n@@ -944,11 +940,15 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 // We increase the size of the discriminant to avoid LLVM copying\n                 // padding when it doesn't need to. This normally causes unaligned\n                 // load/stores and excessive memcpy/memset operations. By using a\n-                // bigger integer size, LLVM can be sure about it's contents and\n+                // bigger integer size, LLVM can be sure about its contents and\n                 // won't be so conservative.\n \n                 // Use the initial field alignment\n-                let mut ity = Integer::for_abi_align(dl, start_align).unwrap_or(min_ity);\n+                let mut ity = if def.repr.c() || def.repr.int.is_some() {\n+                    min_ity\n+                } else {\n+                    Integer::for_abi_align(dl, start_align).unwrap_or(min_ity)\n+                };\n \n                 // If the alignment is not larger than the chosen discriminant size,\n                 // don't use the alignment as the final size.\n@@ -958,7 +958,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     // Patch up the variants' first few fields.\n                     let old_ity_size = min_ity.size();\n                     let new_ity_size = ity.size();\n-                    for variant in &mut variants {\n+                    for variant in &mut layout_variants {\n                         if variant.abi == Abi::Uninhabited {\n                             continue;\n                         }\n@@ -985,15 +985,80 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     value: Int(ity, signed),\n                     valid_range: (min as u128 & tag_mask)..=(max as u128 & tag_mask),\n                 };\n-                let abi = if tag.value.size(dl) == size {\n-                    Abi::Scalar(tag.clone())\n-                } else {\n-                    Abi::Aggregate { sized: true }\n-                };\n+                let mut abi = Abi::Aggregate { sized: true };\n+                if tag.value.size(dl) == size {\n+                    abi = Abi::Scalar(tag.clone());\n+                } else if !tag.is_bool() {\n+                    // HACK(nox): Blindly using ScalarPair for all tagged enums\n+                    // where applicable leads to Option<u8> being handled as {i1, i8},\n+                    // which later confuses SROA and some loop optimisations,\n+                    // ultimately leading to the repeat-trusted-len test\n+                    // failing. We make the trade-off of using ScalarPair only\n+                    // for types where the tag isn't a boolean.\n+                    let mut common_prim = None;\n+                    for (field_layouts, layout_variant) in variants.iter().zip(&layout_variants) {\n+                        let offsets = match layout_variant.fields {\n+                            FieldPlacement::Arbitrary { ref offsets, .. } => offsets,\n+                            _ => bug!(),\n+                        };\n+                        let mut fields = field_layouts\n+                            .iter()\n+                            .zip(offsets)\n+                            .filter(|p| !p.0.is_zst());\n+                        let (field, offset) = match (fields.next(), fields.next()) {\n+                            (None, None) => continue,\n+                            (Some(pair), None) => pair,\n+                            _ => {\n+                                common_prim = None;\n+                                break;\n+                            }\n+                        };\n+                        let prim = match field.details.abi {\n+                            Abi::Scalar(ref scalar) => scalar.value,\n+                            _ => {\n+                                common_prim = None;\n+                                break;\n+                            }\n+                        };\n+                        if let Some(pair) = common_prim {\n+                            // This is pretty conservative. We could go fancier\n+                            // by conflating things like i32 and u32, or even\n+                            // realising that (u8, u8) could just cohabit with\n+                            // u16 or even u32.\n+                            if pair != (prim, offset) {\n+                                common_prim = None;\n+                                break;\n+                            }\n+                        } else {\n+                            common_prim = Some((prim, offset));\n+                        }\n+                    }\n+                    if let Some((prim, offset)) = common_prim {\n+                        let pair = scalar_pair(tag.clone(), scalar_unit(prim));\n+                        let pair_offsets = match pair.fields {\n+                            FieldPlacement::Arbitrary {\n+                                ref offsets,\n+                                ref memory_index\n+                            } => {\n+                                assert_eq!(memory_index, &[0, 1]);\n+                                offsets\n+                            }\n+                            _ => bug!()\n+                        };\n+                        if pair_offsets[0] == Size::from_bytes(0) &&\n+                            pair_offsets[1] == *offset &&\n+                            align == pair.align &&\n+                            size == pair.size {\n+                            // We can use `ScalarPair` only when it matches our\n+                            // already computed layout (including `#[repr(C)]`).\n+                            abi = pair.abi;\n+                        }\n+                    }\n+                }\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Tagged {\n                         discr: tag,\n-                        variants\n+                        variants: layout_variants,\n                     },\n                     fields: FieldPlacement::Arbitrary {\n                         offsets: vec![Size::from_bytes(0)],\n@@ -1594,22 +1659,22 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             let max_value = !0u128 >> (128 - bits);\n \n             // Find out how many values are outside the valid range.\n-            let niches = if v.start <= v.end {\n-                v.start + (max_value - v.end)\n+            let niches = if v.start() <= v.end() {\n+                v.start() + (max_value - v.end())\n             } else {\n-                v.start - v.end - 1\n+                v.start() - v.end() - 1\n             };\n \n             // Give up if we can't fit `count` consecutive niches.\n             if count > niches {\n                 return None;\n             }\n \n-            let niche_start = v.end.wrapping_add(1) & max_value;\n-            let niche_end = v.end.wrapping_add(count) & max_value;\n+            let niche_start = v.end().wrapping_add(1) & max_value;\n+            let niche_end = v.end().wrapping_add(count) & max_value;\n             Some((offset, Scalar {\n                 value,\n-                valid_range: v.start..=niche_end\n+                valid_range: *v.start()..=niche_end\n             }, niche_start))\n         };\n \n@@ -1679,14 +1744,14 @@ impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n             }\n             NicheFilling {\n                 dataful_variant,\n-                niche_variants: RangeInclusive { start, end },\n+                ref niche_variants,\n                 ref niche,\n                 niche_start,\n                 ref variants,\n             } => {\n                 dataful_variant.hash_stable(hcx, hasher);\n-                start.hash_stable(hcx, hasher);\n-                end.hash_stable(hcx, hasher);\n+                niche_variants.start().hash_stable(hcx, hasher);\n+                niche_variants.end().hash_stable(hcx, hasher);\n                 niche.hash_stable(hcx, hasher);\n                 niche_start.hash_stable(hcx, hasher);\n                 variants.hash_stable(hcx, hasher);\n@@ -1749,10 +1814,10 @@ impl<'a> HashStable<StableHashingContext<'a>> for Scalar {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        let Scalar { value, valid_range: RangeInclusive { start, end } } = *self;\n+        let Scalar { value, ref valid_range } = *self;\n         value.hash_stable(hcx, hasher);\n-        start.hash_stable(hcx, hasher);\n-        end.hash_stable(hcx, hasher);\n+        valid_range.start().hash_stable(hcx, hasher);\n+        valid_range.end().hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "57c8c4f34e70e66c72ad4a8724972d8a989d6f74", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -9,24 +9,45 @@\n // except according to those terms.\n \n use dep_graph::SerializedDepNodeIndex;\n+use dep_graph::DepNode;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use mir::interpret::{GlobalId};\n-use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal};\n+use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal};\n use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::maps::queries;\n+use ty::maps::Query;\n+use ty::maps::QueryMap;\n \n use std::hash::Hash;\n+use std::fmt::Debug;\n use syntax_pos::symbol::InternedString;\n+use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::stable_hasher::HashStable;\n+use ich::StableHashingContext;\n \n /// Query configuration and description traits.\n \n-pub trait QueryConfig {\n-    type Key: Eq + Hash + Clone;\n-    type Value;\n+pub trait QueryConfig<'tcx> {\n+    const NAME: &'static str;\n+\n+    type Key: Eq + Hash + Clone + Debug;\n+    type Value: Clone + for<'a> HashStable<StableHashingContext<'a>>;\n+\n+    fn query(key: Self::Key) -> Query<'tcx>;\n+\n+    // Don't use this method to access query results, instead use the methods on TyCtxt\n+    fn query_map<'a>(tcx: TyCtxt<'a, 'tcx, '_>) -> &'a Lock<QueryMap<'tcx, Self>>;\n+\n+    fn to_dep_node(tcx: TyCtxt<'_, 'tcx, '_>, key: &Self::Key) -> DepNode;\n+\n+    // Don't use this method to compute query results, instead use the methods on TyCtxt\n+    fn compute(tcx: TyCtxt<'_, 'tcx, '_>, key: Self::Key) -> Self::Value;\n+\n+    fn handle_cycle_error(tcx: TyCtxt<'_, 'tcx, '_>) -> Self::Value;\n }\n \n-pub(super) trait QueryDescription<'tcx>: QueryConfig {\n+pub trait QueryDescription<'tcx>: QueryConfig<'tcx> {\n     fn describe(tcx: TyCtxt, key: Self::Key) -> String;\n \n     #[inline]\n@@ -41,7 +62,7 @@ pub(super) trait QueryDescription<'tcx>: QueryConfig {\n     }\n }\n \n-impl<'tcx, M: QueryConfig<Key=DefId>> QueryDescription<'tcx> for M {\n+impl<'tcx, M: QueryConfig<'tcx, Key=DefId>> QueryDescription<'tcx> for M {\n     default fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         if !tcx.sess.verbose() {\n             format!(\"processing `{}`\", tcx.item_path_str(def_id))\n@@ -73,6 +94,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::normalize_ty_after_erasing_region\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::evaluate_obligation<'tcx> {\n+    fn describe(_tcx: TyCtxt, goal: CanonicalPredicateGoal<'tcx>) -> String {\n+        format!(\"evaluating trait selection obligation `{}`\", goal.value.value)\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::is_copy_raw<'tcx> {\n     fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n         format!(\"computing whether `{}` is `Copy`\", env.value)"}, {"sha": "3b6af018d6b789d839c4bb2a2f84781bc867cc9a", "filename": "src/librustc/ty/maps/job.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -17,13 +17,10 @@ use ty::context::TyCtxt;\n use errors::Diagnostic;\n \n /// Indicates the state of a query for a given key in a query map\n-pub(super) enum QueryResult<'tcx, T> {\n+pub(super) enum QueryResult<'tcx> {\n     /// An already executing query. The query job can be used to await for its completion\n     Started(Lrc<QueryJob<'tcx>>),\n \n-    /// The query is complete and produced `T`\n-    Complete(T),\n-\n     /// The query panicked. Queries trying to wait on this will raise a fatal error / silently panic\n     Poisoned,\n }"}, {"sha": "da29f23589e85e7a5f464cc5d325d1fbc8b49787", "filename": "src/librustc/ty/maps/keys.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -11,7 +11,7 @@\n //! Defines the set of legal keys that can be used in queries.\n \n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n-use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal};\n+use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n@@ -200,3 +200,13 @@ impl<'tcx> Key for CanonicalTyGoal<'tcx> {\n         DUMMY_SP\n     }\n }\n+\n+impl<'tcx> Key for CanonicalPredicateGoal<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, _tcx: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}"}, {"sha": "d89846a75ef51a8050c0af043e60045f2830666f", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use dep_graph::{DepConstructor, DepNode};\n-use errors::DiagnosticBuilder;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::def::{Def, Export};\n use hir::{self, TraitCandidate, ItemLocalId, TransFnAttrs};\n@@ -32,8 +31,9 @@ use mir;\n use mir::interpret::{GlobalId};\n use session::{CompileResult, CrateDisambiguator};\n use session::config::OutputFilenames;\n-use traits::Vtable;\n-use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal, NoSolution};\n+use traits::{self, Vtable};\n+use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal,\n+                    CanonicalTyGoal, NoSolution};\n use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use traits::query::normalize::NormalizationResult;\n use traits::specialization_graph;\n@@ -42,7 +42,7 @@ use ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use ty::steal::Steal;\n use ty::subst::Substs;\n use util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n-use util::common::{profq_msg, ErrorReported, ProfileQueriesMsg};\n+use util::common::{ErrorReported};\n \n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_target::spec::PanicStrategy;\n@@ -67,7 +67,6 @@ pub use self::plumbing::force_from_dep_node;\n \n mod job;\n pub use self::job::{QueryJob, QueryInfo};\n-use self::job::QueryResult;\n \n mod keys;\n pub use self::keys::Key;\n@@ -212,7 +211,7 @@ define_maps! { <'tcx>\n \n     /// Borrow checks the function body. If this is a closure, returns\n     /// additional requirements that the closure's creator must verify.\n-    [] fn mir_borrowck: MirBorrowCheck(DefId) -> Option<mir::ClosureRegionRequirements<'tcx>>,\n+    [] fn mir_borrowck: MirBorrowCheck(DefId) -> mir::BorrowCheckResult<'tcx>,\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence.\n@@ -433,6 +432,12 @@ define_maps! { <'tcx>\n         NoSolution,\n     >,\n \n+    /// Do not call this query directly: invoke `infcx.predicate_may_hold()` or\n+    /// `infcx.predicate_must_hold()` instead.\n+    [] fn evaluate_obligation: EvaluateObligation(\n+        CanonicalPredicateGoal<'tcx>\n+    ) -> Result<traits::EvaluationResult, traits::OverflowError>,\n+\n     [] fn substitute_normalize_and_test_predicates:\n         substitute_normalize_and_test_predicates_node((DefId, &'tcx Substs<'tcx>)) -> bool,\n "}, {"sha": "cea2a03fd532c58c3ea572c5c90c6ffe2567de14", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -30,7 +30,6 @@ use syntax::codemap::{CodeMap, StableFilemapId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, FileMap};\n use syntax_pos::hygiene::{Mark, SyntaxContext, ExpnInfo};\n use ty;\n-use ty::maps::job::QueryResult;\n use ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n use ty::context::TyCtxt;\n use util::common::time;\n@@ -239,14 +238,12 @@ impl<'sess> OnDiskCache<'sess> {\n                 encode_query_results::<specialization_graph_of, _>(tcx, enc, qri)?;\n \n                 // const eval is special, it only encodes successfully evaluated constants\n-                use ty::maps::plumbing::GetCacheInternal;\n-                for (key, entry) in const_eval::get_cache_internal(tcx).map.iter() {\n+                use ty::maps::QueryConfig;\n+                let map = const_eval::query_map(tcx).borrow();\n+                assert!(map.active.is_empty());\n+                for (key, entry) in map.results.iter() {\n                     use ty::maps::config::QueryDescription;\n                     if const_eval::cache_on_disk(key.clone()) {\n-                        let entry = match *entry {\n-                            QueryResult::Complete(ref v) => v,\n-                            _ => panic!(\"incomplete query\"),\n-                        };\n                         if let Ok(ref value) = entry.value {\n                             let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n@@ -1124,7 +1121,7 @@ fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               encoder: &mut CacheEncoder<'enc, 'a, 'tcx, E>,\n                                               query_result_index: &mut EncodedQueryResultIndex)\n                                               -> Result<(), E::Error>\n-    where Q: super::plumbing::GetCacheInternal<'tcx>,\n+    where Q: super::config::QueryDescription<'tcx>,\n           E: 'enc + TyEncoder,\n           Q::Value: Encodable,\n {\n@@ -1133,12 +1130,10 @@ fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     time(tcx.sess, desc, || {\n \n-    for (key, entry) in Q::get_cache_internal(tcx).map.iter() {\n+    let map = Q::query_map(tcx).borrow();\n+    assert!(map.active.is_empty());\n+    for (key, entry) in map.results.iter() {\n         if Q::cache_on_disk(key.clone()) {\n-            let entry = match *entry {\n-                QueryResult::Complete(ref v) => v,\n-                _ => panic!(\"incomplete query\"),\n-            };\n             let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n             // Record position of the cache entry"}, {"sha": "37950463f74446d1f9b486224e416832a04e8f9b", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 461, "deletions": 478, "changes": 939, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -15,21 +15,29 @@\n use dep_graph::{DepNodeIndex, DepNode, DepKind, DepNodeColor};\n use errors::DiagnosticBuilder;\n use errors::Level;\n+use errors::Diagnostic;\n+use errors::FatalError;\n use ty::tls;\n use ty::{TyCtxt};\n use ty::maps::Query;\n+use ty::maps::config::QueryConfig;\n use ty::maps::config::QueryDescription;\n-use ty::maps::job::{QueryResult, QueryInfo};\n+use ty::maps::job::{QueryJob, QueryResult, QueryInfo};\n use ty::item_path;\n \n+use util::common::{profq_msg, ProfileQueriesMsg, QueryMsg};\n+\n use rustc_data_structures::fx::{FxHashMap};\n-use rustc_data_structures::sync::LockGuard;\n-use std::marker::PhantomData;\n+use rustc_data_structures::sync::{Lrc, Lock};\n+use std::mem;\n+use std::ptr;\n+use std::collections::hash_map::Entry;\n use syntax_pos::Span;\n+use syntax::codemap::DUMMY_SP;\n \n-pub(super) struct QueryMap<'tcx, D: QueryDescription<'tcx>> {\n-    phantom: PhantomData<(D, &'tcx ())>,\n-    pub(super) map: FxHashMap<D::Key, QueryResult<'tcx, QueryValue<D::Value>>>,\n+pub struct QueryMap<'tcx, D: QueryConfig<'tcx> + ?Sized> {\n+    pub(super) results: FxHashMap<D::Key, QueryValue<D::Value>>,\n+    pub(super) active: FxHashMap<D::Key, QueryResult<'tcx>>,\n }\n \n pub(super) struct QueryValue<T> {\n@@ -48,18 +56,166 @@ impl<T> QueryValue<T> {\n     }\n }\n \n-impl<'tcx, M: QueryDescription<'tcx>> QueryMap<'tcx, M> {\n+impl<'tcx, M: QueryConfig<'tcx>> QueryMap<'tcx, M> {\n     pub(super) fn new() -> QueryMap<'tcx, M> {\n         QueryMap {\n-            phantom: PhantomData,\n-            map: FxHashMap(),\n+            results: FxHashMap(),\n+            active: FxHashMap(),\n+        }\n+    }\n+}\n+\n+// If enabled, send a message to the profile-queries thread\n+macro_rules! profq_msg {\n+    ($tcx:expr, $msg:expr) => {\n+        if cfg!(debug_assertions) {\n+            if $tcx.sess.profile_queries() {\n+                profq_msg($tcx.sess, $msg)\n+            }\n+        }\n+    }\n+}\n+\n+// If enabled, format a key using its debug string, which can be\n+// expensive to compute (in terms of time).\n+macro_rules! profq_query_msg {\n+    ($query:expr, $tcx:expr, $key:expr) => {{\n+        let msg = if cfg!(debug_assertions) {\n+            if $tcx.sess.profile_queries_and_keys() {\n+                Some(format!(\"{:?}\", $key))\n+            } else { None }\n+        } else { None };\n+        QueryMsg {\n+            query: $query,\n+            msg,\n+        }\n+    }}\n+}\n+\n+/// A type representing the responsibility to execute the job in the `job` field.\n+/// This will poison the relevant query if dropped.\n+pub(super) struct JobOwner<'a, 'tcx: 'a, Q: QueryDescription<'tcx> + 'a> {\n+    map: &'a Lock<QueryMap<'tcx, Q>>,\n+    key: Q::Key,\n+    job: Lrc<QueryJob<'tcx>>,\n+}\n+\n+impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n+    /// Either gets a JobOwner corresponding the the query, allowing us to\n+    /// start executing the query, or it returns with the result of the query.\n+    /// If the query is executing elsewhere, this will wait for it.\n+    /// If the query panicked, this will silently panic.\n+    pub(super) fn try_get(\n+        tcx: TyCtxt<'a, 'tcx, '_>,\n+        span: Span,\n+        key: &Q::Key,\n+    ) -> TryGetJob<'a, 'tcx, Q> {\n+        let map = Q::query_map(tcx);\n+        loop {\n+            let mut lock = map.borrow_mut();\n+            if let Some(value) = lock.results.get(key) {\n+                profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n+                let result = Ok((value.value.clone(), value.index));\n+                return TryGetJob::JobCompleted(result);\n+            }\n+            let job = match lock.active.entry((*key).clone()) {\n+                Entry::Occupied(entry) => {\n+                    match *entry.get() {\n+                        QueryResult::Started(ref job) => job.clone(),\n+                        QueryResult::Poisoned => FatalError.raise(),\n+                    }\n+                }\n+                Entry::Vacant(entry) => {\n+                    // No job entry for this query. Return a new one to be started later\n+                    return tls::with_related_context(tcx, |icx| {\n+                        let info = QueryInfo {\n+                            span,\n+                            query: Q::query(key.clone()),\n+                        };\n+                        let job = Lrc::new(QueryJob::new(info, icx.query.clone()));\n+                        let owner = JobOwner {\n+                            map,\n+                            job: job.clone(),\n+                            key: (*key).clone(),\n+                        };\n+                        entry.insert(QueryResult::Started(job));\n+                        TryGetJob::NotYetStarted(owner)\n+                    })\n+                }\n+            };\n+            mem::drop(lock);\n+\n+            if let Err(cycle) = job.await(tcx, span) {\n+                return TryGetJob::JobCompleted(Err(cycle));\n+            }\n+        }\n+    }\n+\n+    /// Completes the query by updating the query map with the `result`,\n+    /// signals the waiter and forgets the JobOwner, so it won't poison the query\n+    pub(super) fn complete(self, result: &Q::Value, dep_node_index: DepNodeIndex) {\n+        // We can move out of `self` here because we `mem::forget` it below\n+        let key = unsafe { ptr::read(&self.key) };\n+        let job = unsafe { ptr::read(&self.job) };\n+        let map = self.map;\n+\n+        // Forget ourself so our destructor won't poison the query\n+        mem::forget(self);\n+\n+        let value = QueryValue::new(result.clone(), dep_node_index);\n+        {\n+            let mut lock = map.borrow_mut();\n+            lock.active.remove(&key);\n+            lock.results.insert(key, value);\n         }\n+\n+        job.signal_complete();\n+    }\n+\n+    /// Executes a job by changing the ImplicitCtxt to point to the\n+    /// new query job while it executes. It returns the diagnostics\n+    /// captured during execution and the actual result.\n+    pub(super) fn start<'lcx, F, R>(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        compute: F)\n+    -> (R, Vec<Diagnostic>)\n+    where\n+        F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'lcx>) -> R\n+    {\n+        // The TyCtxt stored in TLS has the same global interner lifetime\n+        // as `tcx`, so we use `with_related_context` to relate the 'gcx lifetimes\n+        // when accessing the ImplicitCtxt\n+        let r = tls::with_related_context(tcx, move |current_icx| {\n+            // Update the ImplicitCtxt to point to our new query job\n+            let new_icx = tls::ImplicitCtxt {\n+                tcx,\n+                query: Some(self.job.clone()),\n+                layout_depth: current_icx.layout_depth,\n+                task: current_icx.task,\n+            };\n+\n+            // Use the ImplicitCtxt while we execute the query\n+            tls::enter_context(&new_icx, |_| {\n+                compute(tcx)\n+            })\n+        });\n+\n+        // Extract the diagnostic from the job\n+        let diagnostics = mem::replace(&mut *self.job.diagnostics.lock(), Vec::new());\n+\n+        (r, diagnostics)\n     }\n }\n \n-pub(super) trait GetCacheInternal<'tcx>: QueryDescription<'tcx> + Sized {\n-    fn get_cache_internal<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                              -> LockGuard<'a, QueryMap<'tcx, Self>>;\n+impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n+    fn drop(&mut self) {\n+        // Poison the query so jobs waiting on it panic\n+        self.map.borrow_mut().active.insert(self.key.clone(), QueryResult::Poisoned);\n+        // Also signal the completion of the job, so waiters\n+        // will continue execution\n+        self.job.signal_complete();\n+    }\n }\n \n #[derive(Clone)]\n@@ -70,14 +226,14 @@ pub(super) struct CycleError<'tcx> {\n }\n \n /// The result of `try_get_lock`\n-pub(super) enum TryGetLock<'a, 'tcx: 'a, T, D: QueryDescription<'tcx> + 'a> {\n+pub(super) enum TryGetJob<'a, 'tcx: 'a, D: QueryDescription<'tcx> + 'a> {\n     /// The query is not yet started. Contains a guard to the map eventually used to start it.\n-    NotYetStarted(LockGuard<'a, QueryMap<'tcx, D>>),\n+    NotYetStarted(JobOwner<'a, 'tcx, D>),\n \n     /// The query was already completed.\n     /// Returns the result of the query and its dep node index\n     /// if it succeeded or a cycle error if it failed\n-    JobCompleted(Result<(T, DepNodeIndex), CycleError<'tcx>>),\n+    JobCompleted(Result<(D::Value, DepNodeIndex), CycleError<'tcx>>),\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -180,28 +336,277 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n-}\n \n-// If enabled, send a message to the profile-queries thread\n-macro_rules! profq_msg {\n-    ($tcx:expr, $msg:expr) => {\n-        if cfg!(debug_assertions) {\n-            if $tcx.sess.profile_queries() {\n-                profq_msg($tcx.sess, $msg)\n+    fn try_get_with<Q: QueryDescription<'gcx>>(\n+        self,\n+        span: Span,\n+        key: Q::Key)\n+    -> Result<Q::Value, CycleError<'gcx>>\n+    {\n+        debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n+               Q::NAME,\n+               key,\n+               span);\n+\n+        profq_msg!(self,\n+            ProfileQueriesMsg::QueryBegin(\n+                span.data(),\n+                profq_query_msg!(Q::NAME, self, key),\n+            )\n+        );\n+\n+        let job = match JobOwner::try_get(self, span, &key) {\n+            TryGetJob::NotYetStarted(job) => job,\n+            TryGetJob::JobCompleted(result) => {\n+                return result.map(|(v, index)| {\n+                    self.dep_graph.read_index(index);\n+                    v\n+                })\n             }\n+        };\n+\n+        // Fast path for when incr. comp. is off. `to_dep_node` is\n+        // expensive for some DepKinds.\n+        if !self.dep_graph.is_fully_enabled() {\n+            let null_dep_node = DepNode::new_no_params(::dep_graph::DepKind::Null);\n+            return self.force_query_with_job::<Q>(key, job, null_dep_node).map(|(v, _)| v);\n+        }\n+\n+        let dep_node = Q::to_dep_node(self, &key);\n+\n+        if dep_node.kind.is_anon() {\n+            profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n+\n+            let res = job.start(self, |tcx| {\n+                tcx.dep_graph.with_anon_task(dep_node.kind, || {\n+                    Q::compute(tcx.global_tcx(), key)\n+                })\n+            });\n+\n+            profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n+            let ((result, dep_node_index), diagnostics) = res;\n+\n+            self.dep_graph.read_index(dep_node_index);\n+\n+            self.on_disk_query_result_cache\n+                .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n+\n+            job.complete(&result, dep_node_index);\n+\n+            return Ok(result);\n+        }\n+\n+        if !dep_node.kind.is_input() {\n+            if let Some(dep_node_index) = self.try_mark_green_and_read(&dep_node) {\n+                profq_msg!(self, ProfileQueriesMsg::CacheHit);\n+                return self.load_from_disk_and_cache_in_memory::<Q>(key,\n+                                                                    job,\n+                                                                    dep_node_index,\n+                                                                    &dep_node)\n+            }\n+        }\n+\n+        match self.force_query_with_job::<Q>(key, job, dep_node) {\n+            Ok((result, dep_node_index)) => {\n+                self.dep_graph.read_index(dep_node_index);\n+                Ok(result)\n+            }\n+            Err(e) => Err(e)\n         }\n     }\n-}\n \n-// If enabled, format a key using its debug string, which can be\n-// expensive to compute (in terms of time).\n-macro_rules! profq_key {\n-    ($tcx:expr, $key:expr) => {\n-        if cfg!(debug_assertions) {\n-            if $tcx.sess.profile_queries_and_keys() {\n-                Some(format!(\"{:?}\", $key))\n-            } else { None }\n-        } else { None }\n+    fn load_from_disk_and_cache_in_memory<Q: QueryDescription<'gcx>>(\n+        self,\n+        key: Q::Key,\n+        job: JobOwner<'a, 'gcx, Q>,\n+        dep_node_index: DepNodeIndex,\n+        dep_node: &DepNode\n+    ) -> Result<Q::Value, CycleError<'gcx>>\n+    {\n+        // Note this function can be called concurrently from the same query\n+        // We must ensure that this is handled correctly\n+\n+        debug_assert!(self.dep_graph.is_green(dep_node));\n+\n+        // First we try to load the result from the on-disk cache\n+        let result = if Q::cache_on_disk(key.clone()) &&\n+                        self.sess.opts.debugging_opts.incremental_queries {\n+            let prev_dep_node_index =\n+                self.dep_graph.prev_dep_node_index_of(dep_node);\n+            let result = Q::try_load_from_disk(self.global_tcx(),\n+                                                    prev_dep_node_index);\n+\n+            // We always expect to find a cached result for things that\n+            // can be forced from DepNode.\n+            debug_assert!(!dep_node.kind.can_reconstruct_query_key() ||\n+                            result.is_some(),\n+                            \"Missing on-disk cache entry for {:?}\",\n+                            dep_node);\n+            result\n+        } else {\n+            // Some things are never cached on disk.\n+            None\n+        };\n+\n+        let result = if let Some(result) = result {\n+            result\n+        } else {\n+            // We could not load a result from the on-disk cache, so\n+            // recompute.\n+\n+            // The diagnostics for this query have already been\n+            // promoted to the current session during\n+            // try_mark_green(), so we can ignore them here.\n+            let (result, _) = job.start(self, |tcx| {\n+                // The dep-graph for this computation is already in\n+                // place\n+                tcx.dep_graph.with_ignore(|| {\n+                    Q::compute(tcx, key)\n+                })\n+            });\n+            result\n+        };\n+\n+        // If -Zincremental-verify-ich is specified, re-hash results from\n+        // the cache and make sure that they have the expected fingerprint.\n+        if self.sess.opts.debugging_opts.incremental_verify_ich {\n+            use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n+            use ich::Fingerprint;\n+\n+            assert!(Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n+                    self.dep_graph.prev_fingerprint_of(dep_node),\n+                    \"Fingerprint for green query instance not loaded \\\n+                        from cache: {:?}\", dep_node);\n+\n+            debug!(\"BEGIN verify_ich({:?})\", dep_node);\n+            let mut hcx = self.create_stable_hashing_context();\n+            let mut hasher = StableHasher::new();\n+\n+            result.hash_stable(&mut hcx, &mut hasher);\n+\n+            let new_hash: Fingerprint = hasher.finish();\n+            debug!(\"END verify_ich({:?})\", dep_node);\n+\n+            let old_hash = self.dep_graph.fingerprint_of(dep_node_index);\n+\n+            assert!(new_hash == old_hash, \"Found unstable fingerprints \\\n+                for {:?}\", dep_node);\n+        }\n+\n+        if self.sess.opts.debugging_opts.query_dep_graph {\n+            self.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n+        }\n+\n+        job.complete(&result, dep_node_index);\n+\n+        Ok(result)\n+    }\n+\n+    fn force_query_with_job<Q: QueryDescription<'gcx>>(\n+        self,\n+        key: Q::Key,\n+        job: JobOwner<'_, 'gcx, Q>,\n+        dep_node: DepNode)\n+    -> Result<(Q::Value, DepNodeIndex), CycleError<'gcx>> {\n+        // If the following assertion triggers, it can have two reasons:\n+        // 1. Something is wrong with DepNode creation, either here or\n+        //    in DepGraph::try_mark_green()\n+        // 2. Two distinct query keys get mapped to the same DepNode\n+        //    (see for example #48923)\n+        assert!(!self.dep_graph.dep_node_exists(&dep_node),\n+                \"Forcing query with already existing DepNode.\\n\\\n+                    - query-key: {:?}\\n\\\n+                    - dep-node: {:?}\",\n+                key, dep_node);\n+\n+        profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n+        let res = job.start(self, |tcx| {\n+            if dep_node.kind.is_eval_always() {\n+                tcx.dep_graph.with_eval_always_task(dep_node,\n+                                                    tcx,\n+                                                    key,\n+                                                    Q::compute)\n+            } else {\n+                tcx.dep_graph.with_task(dep_node,\n+                                        tcx,\n+                                        key,\n+                                        Q::compute)\n+            }\n+        });\n+        profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n+\n+        let ((result, dep_node_index), diagnostics) = res;\n+\n+        if self.sess.opts.debugging_opts.query_dep_graph {\n+            self.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n+        }\n+\n+        if dep_node.kind != ::dep_graph::DepKind::Null {\n+            self.on_disk_query_result_cache\n+                .store_diagnostics(dep_node_index, diagnostics);\n+        }\n+\n+        job.complete(&result, dep_node_index);\n+\n+        Ok((result, dep_node_index))\n+    }\n+\n+    /// Ensure that either this query has all green inputs or been executed.\n+    /// Executing query::ensure(D) is considered a read of the dep-node D.\n+    ///\n+    /// This function is particularly useful when executing passes for their\n+    /// side-effects -- e.g., in order to report errors for erroneous programs.\n+    ///\n+    /// Note: The optimization is only available during incr. comp.\n+    pub fn ensure_query<Q: QueryDescription<'gcx>>(self, key: Q::Key) -> () {\n+        let dep_node = Q::to_dep_node(self, &key);\n+\n+        // Ensuring an \"input\" or anonymous query makes no sense\n+        assert!(!dep_node.kind.is_anon());\n+        assert!(!dep_node.kind.is_input());\n+        if self.try_mark_green_and_read(&dep_node).is_none() {\n+            // A None return from `try_mark_green_and_read` means that this is either\n+            // a new dep node or that the dep node has already been marked red.\n+            // Either way, we can't call `dep_graph.read()` as we don't have the\n+            // DepNodeIndex. We must invoke the query itself. The performance cost\n+            // this introduces should be negligible as we'll immediately hit the\n+            // in-memory cache, or another query down the line will.\n+            let _ = self.get_query::<Q>(DUMMY_SP, key);\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    fn force_query<Q: QueryDescription<'gcx>>(\n+        self,\n+        key: Q::Key,\n+        span: Span,\n+        dep_node: DepNode\n+    ) -> Result<(Q::Value, DepNodeIndex), CycleError<'gcx>> {\n+        // We may be concurrently trying both execute and force a query\n+        // Ensure that only one of them runs the query\n+        let job = match JobOwner::try_get(self, span, &key) {\n+            TryGetJob::NotYetStarted(job) => job,\n+            TryGetJob::JobCompleted(result) => return result,\n+        };\n+        self.force_query_with_job::<Q>(key, job, dep_node)\n+    }\n+\n+    pub fn try_get_query<Q: QueryDescription<'gcx>>(\n+        self,\n+        span: Span,\n+        key: Q::Key\n+    ) -> Result<Q::Value, DiagnosticBuilder<'a>> {\n+        match self.try_get_with::<Q>(span, key) {\n+            Ok(e) => Ok(e),\n+            Err(e) => Err(self.report_cycle(e)),\n+        }\n+    }\n+\n+    pub fn get_query<Q: QueryDescription<'gcx>>(self, span: Span, key: Q::Key) -> Q::Value {\n+        self.try_get_query::<Q>(span, key).unwrap_or_else(|mut e| {\n+            e.emit();\n+            Q::handle_cycle_error(self)\n+        })\n     }\n }\n \n@@ -210,7 +615,7 @@ macro_rules! handle_cycle_error {\n         Value::from_cycle_error($this.global_tcx())\n     }};\n     ([fatal_cycle$(, $modifiers:ident)*][$this:expr]) => {{\n-        $this.tcx.sess.abort_if_errors();\n+        $this.sess.abort_if_errors();\n         unreachable!();\n     }};\n     ([$other:ident$(, $modifiers:ident)*][$($args:tt)*]) => {\n@@ -223,12 +628,7 @@ macro_rules! define_maps {\n      $($(#[$attr:meta])*\n        [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n \n-        use dep_graph::DepNodeIndex;\n-        use std::mem;\n-        use errors::Diagnostic;\n-        use errors::FatalError;\n-        use rustc_data_structures::sync::{Lock, LockGuard};\n-        use rustc_data_structures::OnDrop;\n+        use rustc_data_structures::sync::Lock;\n \n         define_map_struct! {\n             tcx: $tcx,\n@@ -251,12 +651,6 @@ macro_rules! define_maps {\n             $($(#[$attr])* $name($K)),*\n         }\n \n-        #[allow(bad_style)]\n-        #[derive(Clone, Debug, PartialEq, Eq)]\n-        pub enum QueryMsg {\n-            $($name(Option<String>)),*\n-        }\n-\n         impl<$tcx> Query<$tcx> {\n             pub fn name(&self) -> &'static str {\n                 match *self {\n@@ -303,162 +697,38 @@ macro_rules! define_maps {\n             })*\n         }\n \n-        $(impl<$tcx> QueryConfig for queries::$name<$tcx> {\n+        $(impl<$tcx> QueryConfig<$tcx> for queries::$name<$tcx> {\n             type Key = $K;\n             type Value = $V;\n-        }\n \n-        impl<$tcx> GetCacheInternal<$tcx> for queries::$name<$tcx> {\n-            fn get_cache_internal<'a>(tcx: TyCtxt<'a, $tcx, $tcx>)\n-                                      -> LockGuard<'a, QueryMap<$tcx, Self>> {\n-                tcx.maps.$name.borrow()\n+            const NAME: &'static str = stringify!($name);\n+\n+            fn query(key: Self::Key) -> Query<'tcx> {\n+                Query::$name(key)\n             }\n-        }\n \n-        impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n+            fn query_map<'a>(tcx: TyCtxt<'a, $tcx, '_>) -> &'a Lock<QueryMap<$tcx, Self>> {\n+                &tcx.maps.$name\n+            }\n \n             #[allow(unused)]\n-            fn to_dep_node(tcx: TyCtxt<'a, $tcx, 'lcx>, key: &$K) -> DepNode {\n+            fn to_dep_node(tcx: TyCtxt<'_, $tcx, '_>, key: &Self::Key) -> DepNode {\n                 use dep_graph::DepConstructor::*;\n \n                 DepNode::new(tcx, $node(*key))\n             }\n \n-            /// Either get the lock of the query map, allowing us to\n-            /// start executing the query, or it returns with the result of the query.\n-            /// If the query already executed and panicked, this will fatal error / silently panic\n-            fn try_get_lock(\n-                tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                span: Span,\n-                key: &$K\n-            ) -> TryGetLock<'a, $tcx, $V, Self>\n-            {\n-                loop {\n-                    let lock = tcx.maps.$name.borrow_mut();\n-                    let job = if let Some(value) = lock.map.get(key) {\n-                        match *value {\n-                            QueryResult::Started(ref job) => Some(job.clone()),\n-                            QueryResult::Complete(ref value) => {\n-                                profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                                let result = Ok(((&value.value).clone(), value.index));\n-                                return TryGetLock::JobCompleted(result);\n-                            },\n-                            QueryResult::Poisoned => FatalError.raise(),\n-                        }\n-                    } else {\n-                        None\n-                    };\n-                    let job = if let Some(job) = job {\n-                        job\n-                    } else {\n-                        return TryGetLock::NotYetStarted(lock);\n-                    };\n-                    mem::drop(lock);\n-\n-                    if let Err(cycle) = job.await(tcx, span) {\n-                        return TryGetLock::JobCompleted(Err(cycle));\n-                    }\n-                }\n+            fn compute(tcx: TyCtxt<'_, 'tcx, '_>, key: Self::Key) -> Self::Value {\n+                let provider = tcx.maps.providers[key.map_crate()].$name;\n+                provider(tcx.global_tcx(), key)\n             }\n \n-            fn try_get_with(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                            span: Span,\n-                            key: $K)\n-                            -> Result<$V, CycleError<$tcx>>\n-            {\n-                debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n-                       stringify!($name),\n-                       key,\n-                       span);\n-\n-                profq_msg!(tcx,\n-                    ProfileQueriesMsg::QueryBegin(\n-                        span.data(),\n-                        QueryMsg::$name(profq_key!(tcx, key))\n-                    )\n-                );\n-\n-                /// Get the lock used to start the query or\n-                /// return the result of the completed query\n-                macro_rules! get_lock_or_return {\n-                    () => {{\n-                        match Self::try_get_lock(tcx, span, &key) {\n-                            TryGetLock::NotYetStarted(lock) => lock,\n-                            TryGetLock::JobCompleted(result) => {\n-                                return result.map(|(v, index)| {\n-                                    tcx.dep_graph.read_index(index);\n-                                    v\n-                                })\n-                            }\n-                        }\n-                    }}\n-                }\n-\n-                let mut lock = get_lock_or_return!();\n-\n-                // Fast path for when incr. comp. is off. `to_dep_node` is\n-                // expensive for some DepKinds.\n-                if !tcx.dep_graph.is_fully_enabled() {\n-                    let null_dep_node = DepNode::new_no_params(::dep_graph::DepKind::Null);\n-                    return Self::force_with_lock(tcx, key, span, lock, null_dep_node)\n-                                .map(|(v, _)| v);\n-                }\n-\n-                let dep_node = Self::to_dep_node(tcx, &key);\n-\n-                if dep_node.kind.is_anon() {\n-                    profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n-\n-                    let res = Self::start_job(tcx, span, key, lock, |tcx| {\n-                        tcx.dep_graph.with_anon_task(dep_node.kind, || {\n-                            Self::compute_result(tcx.global_tcx(), key)\n-                        })\n-                    })?;\n-\n-                    profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n-                    let (((result, dep_node_index), diagnostics), job) = res;\n-\n-                    tcx.dep_graph.read_index(dep_node_index);\n-\n-                    tcx.on_disk_query_result_cache\n-                       .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n-\n-                    let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n-\n-                    tcx.maps\n-                       .$name\n-                       .borrow_mut()\n-                       .map\n-                       .insert(key, QueryResult::Complete(value));\n-\n-                    job.signal_complete();\n-\n-                    return Ok(result);\n-                }\n-\n-                if !dep_node.kind.is_input() {\n-                    // try_mark_green_and_read may force queries. So we must drop our lock here\n-                    mem::drop(lock);\n-                    if let Some(dep_node_index) = tcx.try_mark_green_and_read(&dep_node) {\n-                        profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                        return Self::load_from_disk_and_cache_in_memory(tcx,\n-                                                                        key,\n-                                                                        span,\n-                                                                        dep_node_index,\n-                                                                        &dep_node)\n-                    }\n-                    lock = get_lock_or_return!();\n-                }\n-\n-                match Self::force_with_lock(tcx, key, span, lock, dep_node) {\n-                    Ok((result, dep_node_index)) => {\n-                        tcx.dep_graph.read_index(dep_node_index);\n-                        Ok(result)\n-                    }\n-                    Err(e) => Err(e)\n-                }\n+            fn handle_cycle_error(tcx: TyCtxt<'_, 'tcx, '_>) -> Self::Value {\n+                handle_cycle_error!([$($modifiers)*][tcx])\n             }\n+        }\n \n+        impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n             /// Ensure that either this query has all green inputs or been executed.\n             /// Executing query::ensure(D) is considered a read of the dep-node D.\n             ///\n@@ -467,282 +737,7 @@ macro_rules! define_maps {\n             ///\n             /// Note: The optimization is only available during incr. comp.\n             pub fn ensure(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> () {\n-                let dep_node = Self::to_dep_node(tcx, &key);\n-\n-                // Ensuring an \"input\" or anonymous query makes no sense\n-                assert!(!dep_node.kind.is_anon());\n-                assert!(!dep_node.kind.is_input());\n-                if tcx.try_mark_green_and_read(&dep_node).is_none() {\n-                    // A None return from `try_mark_green_and_read` means that this is either\n-                    // a new dep node or that the dep node has already been marked red.\n-                    // Either way, we can't call `dep_graph.read()` as we don't have the\n-                    // DepNodeIndex. We must invoke the query itself. The performance cost\n-                    // this introduces should be negligible as we'll immediately hit the\n-                    // in-memory cache, or another query down the line will.\n-                    let _ = tcx.$name(key);\n-                }\n-            }\n-\n-            /// Creates a job for the query and updates the query map indicating that it started.\n-            /// Then it changes ImplicitCtxt to point to the new query job while it executes.\n-            /// If the query panics, this updates the query map to indicate so.\n-            fn start_job<F, R>(tcx: TyCtxt<'_, $tcx, 'lcx>,\n-                               span: Span,\n-                               key: $K,\n-                               mut map: LockGuard<'_, QueryMap<$tcx, Self>>,\n-                               compute: F)\n-                -> Result<((R, Vec<Diagnostic>), Lrc<QueryJob<$tcx>>), CycleError<$tcx>>\n-                where F: for<'b> FnOnce(TyCtxt<'b, $tcx, 'lcx>) -> R\n-            {\n-                let query = Query::$name(Clone::clone(&key));\n-\n-                let entry = QueryInfo {\n-                    span,\n-                    query,\n-                };\n-\n-                // The TyCtxt stored in TLS has the same global interner lifetime\n-                // as `tcx`, so we use `with_related_context` to relate the 'gcx lifetimes\n-                // when accessing the ImplicitCtxt\n-                let (r, job) = ty::tls::with_related_context(tcx, move |icx| {\n-                    let job = Lrc::new(QueryJob::new(entry, icx.query.clone()));\n-\n-                    // Store the job in the query map and drop the lock to allow\n-                    // others to wait it\n-                    map.map.entry(key).or_insert(QueryResult::Started(job.clone()));\n-                    mem::drop(map);\n-\n-                    let r = {\n-                        let on_drop = OnDrop(|| {\n-                            // Poison the query so jobs waiting on it panic\n-                            tcx.maps\n-                            .$name\n-                            .borrow_mut()\n-                            .map\n-                            .insert(key, QueryResult::Poisoned);\n-                            // Also signal the completion of the job, so waiters\n-                            // will continue execution\n-                            job.signal_complete();\n-                        });\n-\n-                        // Update the ImplicitCtxt to point to our new query job\n-                        let icx = ty::tls::ImplicitCtxt {\n-                            tcx,\n-                            query: Some(job.clone()),\n-                            layout_depth: icx.layout_depth,\n-                            task: icx.task,\n-                        };\n-\n-                        // Use the ImplicitCtxt while we execute the query\n-                        let r = ty::tls::enter_context(&icx, |icx| {\n-                            compute(icx.tcx)\n-                        });\n-\n-                        mem::forget(on_drop);\n-\n-                        r\n-                    };\n-\n-                    (r, job)\n-                });\n-\n-                // Extract the diagnostic from the job\n-                let diagnostics: Vec<_> = mem::replace(&mut *job.diagnostics.lock(), Vec::new());\n-\n-                Ok(((r, diagnostics), job))\n-            }\n-\n-            fn compute_result(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> $V {\n-                let provider = tcx.maps.providers[key.map_crate()].$name;\n-                provider(tcx.global_tcx(), key)\n-            }\n-\n-            fn load_from_disk_and_cache_in_memory(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                                                  key: $K,\n-                                                  span: Span,\n-                                                  dep_node_index: DepNodeIndex,\n-                                                  dep_node: &DepNode)\n-                                                  -> Result<$V, CycleError<$tcx>>\n-            {\n-                // Note this function can be called concurrently from the same query\n-                // We must ensure that this is handled correctly\n-\n-                debug_assert!(tcx.dep_graph.is_green(dep_node));\n-\n-                // First we try to load the result from the on-disk cache\n-                let result = if Self::cache_on_disk(key) &&\n-                                tcx.sess.opts.debugging_opts.incremental_queries {\n-                    let prev_dep_node_index =\n-                        tcx.dep_graph.prev_dep_node_index_of(dep_node);\n-                    let result = Self::try_load_from_disk(tcx.global_tcx(),\n-                                                          prev_dep_node_index);\n-\n-                    // We always expect to find a cached result for things that\n-                    // can be forced from DepNode.\n-                    debug_assert!(!dep_node.kind.can_reconstruct_query_key() ||\n-                                  result.is_some(),\n-                                  \"Missing on-disk cache entry for {:?}\",\n-                                  dep_node);\n-                    result\n-                } else {\n-                    // Some things are never cached on disk.\n-                    None\n-                };\n-\n-                let (result, job) = if let Some(result) = result {\n-                    (result, None)\n-                } else {\n-                    // We could not load a result from the on-disk cache, so\n-                    // recompute.\n-\n-                    // The diagnostics for this query have already been\n-                    // promoted to the current session during\n-                    // try_mark_green(), so we can ignore them here.\n-                    let ((result, _), job) = Self::start_job(tcx,\n-                                                             span,\n-                                                             key,\n-                                                             tcx.maps.$name.borrow_mut(),\n-                                                             |tcx| {\n-                        // The dep-graph for this computation is already in\n-                        // place\n-                        tcx.dep_graph.with_ignore(|| {\n-                            Self::compute_result(tcx, key)\n-                        })\n-                    })?;\n-                    (result, Some(job))\n-                };\n-\n-                // If -Zincremental-verify-ich is specified, re-hash results from\n-                // the cache and make sure that they have the expected fingerprint.\n-                if tcx.sess.opts.debugging_opts.incremental_verify_ich {\n-                    use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-                    use ich::Fingerprint;\n-\n-                    assert!(Some(tcx.dep_graph.fingerprint_of(dep_node_index)) ==\n-                            tcx.dep_graph.prev_fingerprint_of(dep_node),\n-                            \"Fingerprint for green query instance not loaded \\\n-                             from cache: {:?}\", dep_node);\n-\n-                    debug!(\"BEGIN verify_ich({:?})\", dep_node);\n-                    let mut hcx = tcx.create_stable_hashing_context();\n-                    let mut hasher = StableHasher::new();\n-\n-                    result.hash_stable(&mut hcx, &mut hasher);\n-\n-                    let new_hash: Fingerprint = hasher.finish();\n-                    debug!(\"END verify_ich({:?})\", dep_node);\n-\n-                    let old_hash = tcx.dep_graph.fingerprint_of(dep_node_index);\n-\n-                    assert!(new_hash == old_hash, \"Found unstable fingerprints \\\n-                        for {:?}\", dep_node);\n-                }\n-\n-                if tcx.sess.opts.debugging_opts.query_dep_graph {\n-                    tcx.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n-                }\n-\n-                let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n-\n-                tcx.maps\n-                   .$name\n-                   .borrow_mut()\n-                   .map\n-                   .insert(key, QueryResult::Complete(value));\n-\n-                job.map(|j| j.signal_complete());\n-\n-                Ok(result)\n-            }\n-\n-            #[allow(dead_code)]\n-            fn force(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                     key: $K,\n-                     span: Span,\n-                     dep_node: DepNode)\n-                     -> Result<($V, DepNodeIndex), CycleError<$tcx>> {\n-                // We may be concurrently trying both execute and force a query\n-                // Ensure that only one of them runs the query\n-                let lock = match Self::try_get_lock(tcx, span, &key) {\n-                    TryGetLock::NotYetStarted(lock) => lock,\n-                    TryGetLock::JobCompleted(result) => return result,\n-                };\n-                Self::force_with_lock(tcx,\n-                                      key,\n-                                      span,\n-                                      lock,\n-                                      dep_node)\n-            }\n-\n-            fn force_with_lock(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                               key: $K,\n-                               span: Span,\n-                               map: LockGuard<'_, QueryMap<$tcx, Self>>,\n-                               dep_node: DepNode)\n-                               -> Result<($V, DepNodeIndex), CycleError<$tcx>> {\n-                // If the following assertion triggers, it can have two reasons:\n-                // 1. Something is wrong with DepNode creation, either here or\n-                //    in DepGraph::try_mark_green()\n-                // 2. Two distinct query keys get mapped to the same DepNode\n-                //    (see for example #48923)\n-                assert!(!tcx.dep_graph.dep_node_exists(&dep_node),\n-                        \"Forcing query with already existing DepNode.\\n\\\n-                          - query-key: {:?}\\n\\\n-                          - dep-node: {:?}\",\n-                        key, dep_node);\n-\n-                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n-                let res = Self::start_job(tcx,\n-                                          span,\n-                                          key,\n-                                          map,\n-                                          |tcx| {\n-                    if dep_node.kind.is_eval_always() {\n-                        tcx.dep_graph.with_eval_always_task(dep_node,\n-                                                            tcx,\n-                                                            key,\n-                                                            Self::compute_result)\n-                    } else {\n-                        tcx.dep_graph.with_task(dep_node,\n-                                                tcx,\n-                                                key,\n-                                                Self::compute_result)\n-                    }\n-                })?;\n-                profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n-\n-                let (((result, dep_node_index), diagnostics), job) = res;\n-\n-                if tcx.sess.opts.debugging_opts.query_dep_graph {\n-                    tcx.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n-                }\n-\n-                if dep_node.kind != ::dep_graph::DepKind::Null {\n-                    tcx.on_disk_query_result_cache\n-                       .store_diagnostics(dep_node_index, diagnostics);\n-                }\n-\n-                let value = QueryValue::new(Clone::clone(&result), dep_node_index);\n-\n-                tcx.maps\n-                   .$name\n-                   .borrow_mut()\n-                   .map\n-                   .insert(key, QueryResult::Complete(value));\n-\n-                let job: Lrc<QueryJob> = job;\n-\n-                job.signal_complete();\n-\n-                Ok((result, dep_node_index))\n-            }\n-\n-            pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n-                           -> Result<$V, DiagnosticBuilder<'a>> {\n-                match Self::try_get_with(tcx, span, key) {\n-                    Ok(e) => Ok(e),\n-                    Err(e) => Err(tcx.report_cycle(e)),\n-                }\n+                tcx.ensure_query::<queries::$name>(key);\n             }\n         })*\n \n@@ -778,10 +773,7 @@ macro_rules! define_maps {\n         impl<'a, $tcx, 'lcx> TyCtxtAt<'a, $tcx, 'lcx> {\n             $($(#[$attr])*\n             pub fn $name(self, key: $K) -> $V {\n-                queries::$name::try_get(self.tcx, self.span, key).unwrap_or_else(|mut e| {\n-                    e.emit();\n-                    handle_cycle_error!([$($modifiers)*][self])\n-                })\n+                self.tcx.get_query::<queries::$name>(self.span, key)\n             })*\n         }\n \n@@ -872,7 +864,6 @@ macro_rules! define_provider_struct {\n pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n                                            dep_node: &DepNode)\n                                            -> bool {\n-    use ty::maps::keys::Key;\n     use hir::def_id::LOCAL_CRATE;\n \n     // We must avoid ever having to call force_from_dep_node() for a\n@@ -915,23 +906,14 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n             {\n                 use $crate::util::common::{ProfileQueriesMsg, profq_msg};\n \n-                // FIXME(eddyb) Get more valid Span's on queries.\n-                // def_span guard is necessary to prevent a recursive loop,\n-                // default_span calls def_span query internally.\n-                let span = if stringify!($query) != \"def_span\" {\n-                    $key.default_span(tcx)\n-                } else {\n-                    ::syntax_pos::DUMMY_SP\n-                };\n-\n                 profq_msg!(tcx,\n                     ProfileQueriesMsg::QueryBegin(\n-                        span.data(),\n-                        ::ty::maps::QueryMsg::$query(profq_key!(tcx, $key))\n+                        DUMMY_SP.data(),\n+                        profq_query_msg!(::ty::maps::queries::$query::NAME, tcx, $key),\n                     )\n                 );\n \n-                match ::ty::maps::queries::$query::force(tcx, $key, span, *dep_node) {\n+                match tcx.force_query::<::ty::maps::queries::$query>($key, DUMMY_SP, *dep_node) {\n                     Ok(_) => {},\n                     Err(e) => {\n                         tcx.report_cycle(e).emit();\n@@ -977,6 +959,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::NormalizeProjectionTy |\n         DepKind::NormalizeTyAfterErasingRegions |\n         DepKind::DropckOutlives |\n+        DepKind::EvaluateObligation |\n         DepKind::SubstituteNormalizeAndTestPredicates |\n         DepKind::InstanceDefSizeEstimate |\n         DepKind::ProgramClausesForEnv |"}, {"sha": "d3d06248792400678bd2112a6fc32e1e0c06c7ce", "filename": "src/librustc/ty/maps/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -37,7 +37,7 @@ impl<'tcx> Value<'tcx> for Ty<'tcx> {\n \n impl<'tcx> Value<'tcx> for ty::SymbolName {\n     fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        ty::SymbolName { name: Symbol::intern(\"<error>\").as_str() }\n+        ty::SymbolName { name: Symbol::intern(\"<error>\").as_interned_str() }\n     }\n }\n "}, {"sha": "c4fe112a9e913206ffbd1466d14cb9f390972bcf", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -51,7 +51,7 @@ use std::mem;\n use syntax::ast::{self, DUMMY_NODE_ID, Name, Ident, NodeId};\n use syntax::attr;\n use syntax::ext::hygiene::Mark;\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::{Symbol, LocalInternedString, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n@@ -69,7 +69,7 @@ pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n-pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n+pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid};\n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind::*;\n@@ -1370,15 +1370,13 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n /// type name in a non-zero universe is a skolemized type -- an\n /// idealized representative of \"types in general\" that we use for\n /// checking generic functions.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct UniverseIndex(u32);\n \n impl UniverseIndex {\n     /// The root universe, where things that the user defined are\n     /// visible.\n-    pub fn root() -> UniverseIndex {\n-        UniverseIndex(0)\n-    }\n+    pub const ROOT: Self = UniverseIndex(0);\n \n     /// A \"subuniverse\" corresponds to being inside a `forall` quantifier.\n     /// So, for example, suppose we have this type in universe `U`:\n@@ -1392,7 +1390,21 @@ impl UniverseIndex {\n     /// region `'a`, but that region was not nameable from `U` because\n     /// it was not in scope there.\n     pub fn subuniverse(self) -> UniverseIndex {\n-        UniverseIndex(self.0 + 1)\n+        UniverseIndex(self.0.checked_add(1).unwrap())\n+    }\n+\n+    pub fn as_u32(&self) -> u32 {\n+        self.0\n+    }\n+\n+    pub fn as_usize(&self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+impl From<u32> for UniverseIndex {\n+    fn from(index: u32) -> Self {\n+        UniverseIndex(index)\n     }\n }\n \n@@ -1476,7 +1488,11 @@ impl<'tcx> ParamEnv<'tcx> {\n             }\n \n             Reveal::All => {\n-                if value.needs_infer() || value.has_param_types() || value.has_self_ty() {\n+                if value.has_skol()\n+                    || value.needs_infer()\n+                    || value.has_param_types()\n+                    || value.has_self_ty()\n+                {\n                     ParamEnvAnd {\n                         param_env: self,\n                         value,\n@@ -2031,7 +2047,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer, e.g. issue #31299.\n     pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n-        match queries::adt_sized_constraint::try_get(tcx, DUMMY_SP, self.did) {\n+        match tcx.try_get_query::<queries::adt_sized_constraint>(DUMMY_SP, self.did) {\n             Ok(tys) => tys,\n             Err(mut bug) => {\n                 debug!(\"adt_sized_constraint: {:?} is recursive\", self);\n@@ -2463,7 +2479,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn item_name(self, id: DefId) -> InternedString {\n         if id.index == CRATE_DEF_INDEX {\n-            self.original_crate_name(id.krate).as_str()\n+            self.original_crate_name(id.krate).as_interned_str()\n         } else {\n             let def_key = self.def_key(id);\n             // The name of a StructCtor is that of its struct parent.\n@@ -2820,15 +2836,13 @@ impl_stable_hash_for!(struct self::SymbolName {\n impl SymbolName {\n     pub fn new(name: &str) -> SymbolName {\n         SymbolName {\n-            name: Symbol::intern(name).as_str()\n+            name: Symbol::intern(name).as_interned_str()\n         }\n     }\n-}\n \n-impl Deref for SymbolName {\n-    type Target = str;\n-\n-    fn deref(&self) -> &str { &self.name }\n+    pub fn as_str(&self) -> LocalInternedString {\n+        self.name.as_str()\n+    }\n }\n \n impl fmt::Display for SymbolName {"}, {"sha": "d4ed6c60e0efa6baae51eef83e6132c3cdd4e8cc", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -473,9 +473,19 @@ impl<'a, 'tcx> Lift<'tcx> for ConstEvalErr<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for interpret::EvalError<'a> {\n     type Lifted = interpret::EvalError<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        Some(interpret::EvalError {\n+            kind: tcx.lift(&self.kind)?,\n+            backtrace: self.backtrace.clone(),\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx, O: Lift<'tcx>> Lift<'tcx> for interpret::EvalErrorKind<'a, O> {\n+    type Lifted = interpret::EvalErrorKind<'tcx, <O as Lift<'tcx>>::Lifted>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         use ::mir::interpret::EvalErrorKind::*;\n-        let kind = match self.kind {\n+        Some(match *self {\n             MachineError(ref err) => MachineError(err.clone()),\n             FunctionPointerTyMismatch(a, b) => FunctionPointerTyMismatch(\n                 tcx.lift(&a)?,\n@@ -504,10 +514,11 @@ impl<'a, 'tcx> Lift<'tcx> for interpret::EvalError<'a> {\n             Unimplemented(ref s) => Unimplemented(s.clone()),\n             DerefFunctionPointer => DerefFunctionPointer,\n             ExecuteMemory => ExecuteMemory,\n-            ArrayIndexOutOfBounds(sp, a, b) => ArrayIndexOutOfBounds(sp, a, b),\n-            Math(sp, ref err) => Math(sp, err.clone()),\n+            BoundsCheck { ref len, ref index } => BoundsCheck {\n+                len: tcx.lift(len)?,\n+                index: tcx.lift(index)?,\n+            },\n             Intrinsic(ref s) => Intrinsic(s.clone()),\n-            OverflowingMath => OverflowingMath,\n             InvalidChar(c) => InvalidChar(c),\n             StackFrameLimitReached => StackFrameLimitReached,\n             OutOfTls => OutOfTls,\n@@ -568,10 +579,12 @@ impl<'a, 'tcx> Lift<'tcx> for interpret::EvalError<'a> {\n             UnimplementedTraitSelection => UnimplementedTraitSelection,\n             TypeckError => TypeckError,\n             ReferencedConstant => ReferencedConstant,\n-        };\n-        Some(interpret::EvalError {\n-            kind: kind,\n-            backtrace: self.backtrace.clone(),\n+            OverflowNeg => OverflowNeg,\n+            Overflow(op) => Overflow(op),\n+            DivisionByZero => DivisionByZero,\n+            RemainderByZero => RemainderByZero,\n+            GeneratorResumedAfterReturn => GeneratorResumedAfterReturn,\n+            GeneratorResumedAfterPanic => GeneratorResumedAfterPanic,\n         })\n     }\n }\n@@ -585,7 +598,6 @@ impl<'a, 'tcx> Lift<'tcx> for const_val::ErrKind<'a> {\n             NonConstPath => NonConstPath,\n             UnimplementedConstVal(s) => UnimplementedConstVal(s),\n             IndexOutOfBounds { len, index } => IndexOutOfBounds { len, index },\n-            Math(ref e) => Math(e.clone()),\n \n             LayoutError(ref e) => {\n                 return tcx.lift(e).map(LayoutError)"}, {"sha": "382db571b524eea6bdad0f09c15aa4977661edde", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -864,7 +864,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n     }\n \n     pub fn for_self() -> ParamTy {\n-        ParamTy::new(0, keywords::SelfType.name().as_str())\n+        ParamTy::new(0, keywords::SelfType.name().as_interned_str())\n     }\n \n     pub fn for_def(def: &ty::TypeParameterDef) -> ParamTy {\n@@ -876,8 +876,10 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n     }\n \n     pub fn is_self(&self) -> bool {\n-        if self.name == keywords::SelfType.name().as_str() {\n-            assert_eq!(self.idx, 0);\n+        // FIXME(#50125): Ignoring `Self` with `idx != 0` might lead to weird behavior elsewhere,\n+        // but this should only be possible when using `-Z continue-parse-after-error` like\n+        // `compile-fail/issue-36638.rs`.\n+        if self.name == keywords::SelfType.name().as_str() && self.idx == 0 {\n             true\n         } else {\n             false\n@@ -1019,7 +1021,7 @@ pub enum RegionKind {\n \n     /// A skolemized region - basically the higher-ranked version of ReFree.\n     /// Should not exist after typeck.\n-    ReSkolemized(SkolemizedRegionVid, BoundRegion),\n+    ReSkolemized(ty::UniverseIndex, BoundRegion),\n \n     /// Empty lifetime is for data that is never accessed.\n     /// Bottom in the region lattice. We treat ReEmpty somewhat\n@@ -1073,11 +1075,6 @@ newtype_index!(RegionVid\n         DEBUG_FORMAT = custom,\n     });\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n-pub struct SkolemizedRegionVid {\n-    pub index: u32,\n-}\n-\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum InferTy {\n     TyVar(TyVid),\n@@ -1169,13 +1166,6 @@ impl RegionKind {\n         }\n     }\n \n-    pub fn needs_infer(&self) -> bool {\n-        match *self {\n-            ty::ReVar(..) | ty::ReSkolemized(..) => true,\n-            _ => false\n-        }\n-    }\n-\n     pub fn escapes_depth(&self, depth: u32) -> bool {\n         match *self {\n             ty::ReLateBound(debruijn, _) => debruijn.depth > depth,\n@@ -1193,20 +1183,29 @@ impl RegionKind {\n         }\n     }\n \n+    pub fn keep_in_local_tcx(&self) -> bool {\n+        if let ty::ReVar(..) = self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     pub fn type_flags(&self) -> TypeFlags {\n         let mut flags = TypeFlags::empty();\n \n+        if self.keep_in_local_tcx() {\n+            flags = flags | TypeFlags::KEEP_IN_LOCAL_TCX;\n+        }\n+\n         match *self {\n             ty::ReVar(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_INFER;\n-                flags = flags | TypeFlags::KEEP_IN_LOCAL_TCX;\n             }\n             ty::ReSkolemized(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n-                flags = flags | TypeFlags::HAS_RE_INFER;\n                 flags = flags | TypeFlags::HAS_RE_SKOL;\n-                flags = flags | TypeFlags::KEEP_IN_LOCAL_TCX;\n             }\n             ty::ReLateBound(..) => { }\n             ty::ReEarlyBound(..) => {"}, {"sha": "4aa70e1f7e006964adef5cb1069a1ec8f885afc3", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1024,7 +1024,7 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (param_env, ty) = query.into_parts();\n \n     let needs_drop = |ty: Ty<'tcx>| -> bool {\n-        match ty::queries::needs_drop_raw::try_get(tcx, DUMMY_SP, param_env.and(ty)) {\n+        match tcx.try_get_query::<ty::queries::needs_drop_raw>(DUMMY_SP, param_env.and(ty)) {\n             Ok(v) => v,\n             Err(mut bug) => {\n                 // Cycles should be reported as an error by `check_representable`."}, {"sha": "85533caffce2eb9b634ad72e490a14d42226fe64", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -25,7 +25,6 @@ use std::time::{Duration, Instant};\n \n use std::sync::mpsc::{Sender};\n use syntax_pos::{SpanData};\n-use ty::maps::{QueryMsg};\n use ty::TyCtxt;\n use dep_graph::{DepNode};\n use proc_macro;\n@@ -59,6 +58,17 @@ fn panic_hook(info: &panic::PanicInfo) {\n         if backtrace {\n             TyCtxt::try_print_query_stack();\n         }\n+\n+        #[cfg(windows)]\n+        unsafe {\n+            if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n+                extern \"system\" {\n+                    fn DebugBreak();\n+                }\n+                // Trigger a debugger if we crashed during bootstrap\n+                DebugBreak();\n+            }\n+        }\n     }\n }\n \n@@ -77,6 +87,13 @@ pub struct ProfQDumpParams {\n     pub dump_profq_msg_log:bool,\n }\n \n+#[allow(bad_style)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct QueryMsg {\n+    pub query: &'static str,\n+    pub msg: Option<String>,\n+}\n+\n /// A sequence of these messages induce a trace of query-based incremental compilation.\n /// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n #[derive(Clone,Debug)]"}, {"sha": "894a18b79ccb2ad8916312e3a1921224c4db663a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -462,7 +462,7 @@ impl PrintContext {\n                 0 => Symbol::intern(\"'r\"),\n                 1 => Symbol::intern(\"'s\"),\n                 i => Symbol::intern(&format!(\"'t{}\", i-2)),\n-            }.as_str()\n+            }.as_interned_str()\n         }\n \n         // Replace any anonymous late-bound regions with named\n@@ -808,8 +808,8 @@ define_print! {\n                     write!(f, \"'?{}\", c.index())\n                 }\n \n-                ty::ReSkolemized(id, ref bound_region) => {\n-                    write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n+                ty::ReSkolemized(universe, ref bound_region) => {\n+                    write!(f, \"ReSkolemized({:?}, {:?})\", universe, bound_region)\n                 }\n \n                 ty::ReEmpty => write!(f, \"ReEmpty\"),"}, {"sha": "e662088e82fb09724338560c36cddb60e7641965", "filename": "src/librustc_apfloat/ppc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_apfloat%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_apfloat%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fppc.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -20,7 +20,7 @@ use std::ops::Neg;\n pub struct DoubleFloat<F>(F, F);\n pub type DoubleDouble = DoubleFloat<ieee::Double>;\n \n-// These are legacy semantics for the Fallback, inaccrurate implementation of\n+// These are legacy semantics for the Fallback, inaccurate implementation of\n // IBM double-double, if the accurate DoubleDouble doesn't handle the\n // operation. It's equivalent to having an IEEE number with consecutive 106\n // bits of mantissa and 11 bits of exponent."}, {"sha": "79baf0ec15178299d10b17b186fff0c7dabdc17f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                consume_span: Span,\n-               cmt: mc::cmt<'tcx>,\n+               cmt: &mc::cmt_<'tcx>,\n                mode: euv::ConsumeMode) {\n         debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n                consume_id, cmt, mode);\n@@ -110,12 +110,12 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n \n     fn matched_pat(&mut self,\n                    _matched_pat: &hir::Pat,\n-                   _cmt: mc::cmt,\n+                   _cmt: &mc::cmt_,\n                    _mode: euv::MatchMode) { }\n \n     fn consume_pat(&mut self,\n                    consume_pat: &hir::Pat,\n-                   cmt: mc::cmt<'tcx>,\n+                   cmt: &mc::cmt_<'tcx>,\n                    mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(consume_pat={:?}, cmt={:?}, mode={:?})\",\n                consume_pat,\n@@ -128,7 +128,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n-              cmt: mc::cmt<'tcx>,\n+              cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                bk, loan_cause);\n \n         let hir_id = self.tcx().hir.node_to_hir_id(borrow_id);\n-        if let Some(lp) = opt_loan_path(&cmt) {\n+        if let Some(lp) = opt_loan_path(cmt) {\n             let moved_value_use_kind = match loan_cause {\n                 euv::ClosureCapture(_) => MovedInCapture,\n                 _ => MovedInUse,\n@@ -155,13 +155,13 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     fn mutate(&mut self,\n               assignment_id: ast::NodeId,\n               assignment_span: Span,\n-              assignee_cmt: mc::cmt<'tcx>,\n+              assignee_cmt: &mc::cmt_<'tcx>,\n               mode: euv::MutateMode)\n     {\n         debug!(\"mutate(assignment_id={}, assignee_cmt={:?})\",\n                assignment_id, assignee_cmt);\n \n-        if let Some(lp) = opt_loan_path(&assignee_cmt) {\n+        if let Some(lp) = opt_loan_path(assignee_cmt) {\n             match mode {\n                 MutateMode::Init | MutateMode::JustWrite => {\n                     // In a case like `path = 1`, then path does not\n@@ -363,10 +363,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn check_for_loans_across_yields(&self,\n-                                         cmt: mc::cmt<'tcx>,\n+                                         cmt: &mc::cmt_<'tcx>,\n                                          loan_region: ty::Region<'tcx>,\n                                          borrow_span: Span) {\n-        pub fn borrow_of_local_data<'tcx>(cmt: &mc::cmt<'tcx>) -> bool {\n+        pub fn borrow_of_local_data<'tcx>(cmt: &mc::cmt_<'tcx>) -> bool {\n             match cmt.cat {\n                 // Borrows of static items is allowed\n                 Categorization::StaticItem => false,\n@@ -401,7 +401,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        if !borrow_of_local_data(&cmt) {\n+        if !borrow_of_local_data(cmt) {\n             return;\n         }\n \n@@ -649,9 +649,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     fn consume_common(&self,\n                       id: hir::ItemLocalId,\n                       span: Span,\n-                      cmt: mc::cmt<'tcx>,\n+                      cmt: &mc::cmt_<'tcx>,\n                       mode: euv::ConsumeMode) {\n-        if let Some(lp) = opt_loan_path(&cmt) {\n+        if let Some(lp) = opt_loan_path(cmt) {\n             let moved_value_use_kind = match mode {\n                 euv::Copy => {\n                     self.check_for_copy_of_frozen_path(id, span, &lp);\n@@ -876,11 +876,11 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     fn check_assignment(&self,\n                         assignment_id: hir::ItemLocalId,\n                         assignment_span: Span,\n-                        assignee_cmt: mc::cmt<'tcx>) {\n+                        assignee_cmt: &mc::cmt_<'tcx>) {\n         debug!(\"check_assignment(assignee_cmt={:?})\", assignee_cmt);\n \n         // Check that we don't invalidate any outstanding loans\n-        if let Some(loan_path) = opt_loan_path(&assignee_cmt) {\n+        if let Some(loan_path) = opt_loan_path(assignee_cmt) {\n             let scope = region::Scope::Node(assignment_id);\n             self.each_in_scope_loan_affecting_path(scope, &loan_path, |loan| {\n                 self.report_illegal_mutation(assignment_span, &loan_path, loan);\n@@ -892,7 +892,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         // needs to be done here instead of in check_loans because we\n         // depend on move data.\n         if let Categorization::Local(local_id) = assignee_cmt.cat {\n-            let lp = opt_loan_path(&assignee_cmt).unwrap();\n+            let lp = opt_loan_path(assignee_cmt).unwrap();\n             self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n                 if assignee_cmt.mutbl.is_mutable() {\n                     let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);"}, {"sha": "ac905d6de5d3c0a300dfbd32bde3b06bac21611d", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -26,10 +26,10 @@ use syntax_pos::Span;\n use rustc::hir::*;\n use rustc::hir::map::Node::*;\n \n-struct GatherMoveInfo<'tcx> {\n+struct GatherMoveInfo<'c, 'tcx: 'c> {\n     id: hir::ItemLocalId,\n     kind: MoveKind,\n-    cmt: mc::cmt<'tcx>,\n+    cmt: &'c mc::cmt_<'tcx>,\n     span_path_opt: Option<MovePlace<'tcx>>\n }\n \n@@ -87,7 +87,7 @@ pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                        move_data: &MoveData<'tcx>,\n                                        move_error_collector: &mut MoveErrorCollector<'tcx>,\n                                        move_expr_id: hir::ItemLocalId,\n-                                       cmt: mc::cmt<'tcx>,\n+                                       cmt: &mc::cmt_<'tcx>,\n                                        move_reason: euv::MoveReason) {\n     let kind = match move_reason {\n         euv::DirectRefMove | euv::PatBindingMove => MoveExpr,\n@@ -102,11 +102,11 @@ pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n-pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                      move_data: &MoveData<'tcx>,\n-                                      move_error_collector: &mut MoveErrorCollector<'tcx>,\n-                                      move_pat: &hir::Pat,\n-                                      cmt: mc::cmt<'tcx>) {\n+pub fn gather_move_from_pat<'a, 'c, 'tcx: 'c>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                              move_data: &MoveData<'tcx>,\n+                                              move_error_collector: &mut MoveErrorCollector<'tcx>,\n+                                              move_pat: &hir::Pat,\n+                                              cmt: &'c mc::cmt_<'tcx>) {\n     let source = get_pattern_source(bccx.tcx,move_pat);\n     let pat_span_path_opt = match move_pat.node {\n         PatKind::Binding(_, _, ref path1, _) => {\n@@ -132,18 +132,17 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n-fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+fn gather_move<'a, 'c, 'tcx: 'c>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                          move_data: &MoveData<'tcx>,\n                          move_error_collector: &mut MoveErrorCollector<'tcx>,\n-                         move_info: GatherMoveInfo<'tcx>) {\n+                         move_info: GatherMoveInfo<'c, 'tcx>) {\n     debug!(\"gather_move(move_id={:?}, cmt={:?})\",\n            move_info.id, move_info.cmt);\n \n-    let potentially_illegal_move =\n-                check_and_get_illegal_move_origin(bccx, &move_info.cmt);\n+    let potentially_illegal_move = check_and_get_illegal_move_origin(bccx, move_info.cmt);\n     if let Some(illegal_move_origin) = potentially_illegal_move {\n         debug!(\"illegal_move_origin={:?}\", illegal_move_origin);\n-        let error = MoveError::with_move_info(illegal_move_origin,\n+        let error = MoveError::with_move_info(Rc::new(illegal_move_origin),\n                                               move_info.span_path_opt);\n         move_error_collector.add_error(error);\n         return;\n@@ -177,8 +176,8 @@ pub fn gather_assignment<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n // (keep in sync with move_error::report_cannot_move_out_of )\n fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                               cmt: &mc::cmt<'tcx>)\n-                                               -> Option<mc::cmt<'tcx>> {\n+                                               cmt: &mc::cmt_<'tcx>)\n+                                               -> Option<mc::cmt_<'tcx>> {\n     match cmt.cat {\n         Categorization::Deref(_, mc::BorrowedPtr(..)) |\n         Categorization::Deref(_, mc::Implicit(..)) |"}, {"sha": "6d73500d318020a65eb4f3b9b7454e1a69f04fe5", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -27,7 +27,7 @@ pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     item_scope: region::Scope,\n                                     span: Span,\n                                     cause: euv::LoanCause,\n-                                    cmt: mc::cmt<'tcx>,\n+                                    cmt: &'a mc::cmt_<'tcx>,\n                                     loan_region: ty::Region<'tcx>,\n                                     _: ty::BorrowKind)\n                                     -> Result<(),()> {\n@@ -41,8 +41,8 @@ pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                          span,\n                                          cause,\n                                          loan_region,\n-                                         cmt_original: cmt.clone()};\n-    ctxt.check(&cmt, None)\n+                                         cmt_original: cmt};\n+    ctxt.check(cmt, None)\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -57,12 +57,11 @@ struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n     span: Span,\n     cause: euv::LoanCause,\n     loan_region: ty::Region<'tcx>,\n-    cmt_original: mc::cmt<'tcx>\n+    cmt_original: &'a mc::cmt_<'tcx>\n }\n \n impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n-\n-    fn check(&self, cmt: &mc::cmt<'tcx>, discr_scope: Option<ast::NodeId>) -> R {\n+    fn check(&self, cmt: &mc::cmt_<'tcx>, discr_scope: Option<ast::NodeId>) -> R {\n         //! Main routine. Walks down `cmt` until we find the\n         //! \"guarantor\".  Reports an error if `self.loan_region` is\n         //! larger than scope of `cmt`.\n@@ -102,7 +101,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn scope(&self, cmt: &mc::cmt<'tcx>) -> ty::Region<'tcx> {\n+    fn scope(&self, cmt: &mc::cmt_<'tcx>) -> ty::Region<'tcx> {\n         //! Returns the maximal region scope for the which the\n         //! place `cmt` is guaranteed to be valid without any\n         //! rooting etc, and presuming `cmt` is not mutated.\n@@ -136,7 +135,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n     }\n \n     fn report_error(&self, code: bckerr_code<'tcx>) {\n-        self.bccx.report(BckError { cmt: self.cmt_original.clone(),\n+        self.bccx.report(BckError { cmt: self.cmt_original,\n                                     span: self.span,\n                                     cause: BorrowViolation(self.cause),\n                                     code: code });"}, {"sha": "a74eba3995518b5d149f480f118c9de4e45a670c", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                _consume_span: Span,\n-               cmt: mc::cmt<'tcx>,\n+               cmt: &mc::cmt_<'tcx>,\n                mode: euv::ConsumeMode) {\n         debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n                consume_id, cmt, mode);\n@@ -93,7 +93,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n \n     fn matched_pat(&mut self,\n                    matched_pat: &hir::Pat,\n-                   cmt: mc::cmt<'tcx>,\n+                   cmt: &mc::cmt_<'tcx>,\n                    mode: euv::MatchMode) {\n         debug!(\"matched_pat(matched_pat={:?}, cmt={:?}, mode={:?})\",\n                matched_pat,\n@@ -103,7 +103,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n \n     fn consume_pat(&mut self,\n                    consume_pat: &hir::Pat,\n-                   cmt: mc::cmt<'tcx>,\n+                   cmt: &mc::cmt_<'tcx>,\n                    mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(consume_pat={:?}, cmt={:?}, mode={:?})\",\n                consume_pat,\n@@ -123,7 +123,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n-              cmt: mc::cmt<'tcx>,\n+              cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n@@ -144,7 +144,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     fn mutate(&mut self,\n               assignment_id: ast::NodeId,\n               assignment_span: Span,\n-              assignee_cmt: mc::cmt<'tcx>,\n+              assignee_cmt: &mc::cmt_<'tcx>,\n               mode: euv::MutateMode)\n     {\n         self.guarantee_assignment_valid(assignment_id,\n@@ -165,7 +165,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                 borrow_span: Span,\n                                 loan_cause: AliasableViolationKind,\n-                                cmt: mc::cmt<'tcx>,\n+                                cmt: &mc::cmt_<'tcx>,\n                                 req_kind: ty::BorrowKind)\n                                 -> Result<(),()> {\n \n@@ -206,7 +206,7 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                               borrow_span: Span,\n                               cause: AliasableViolationKind,\n-                              cmt: mc::cmt<'tcx>,\n+                              cmt: &mc::cmt_<'tcx>,\n                               req_kind: ty::BorrowKind)\n                               -> Result<(),()> {\n     debug!(\"check_mutability(cause={:?} cmt={:?} req_kind={:?}\",\n@@ -246,10 +246,10 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     fn guarantee_assignment_valid(&mut self,\n                                   assignment_id: ast::NodeId,\n                                   assignment_span: Span,\n-                                  cmt: mc::cmt<'tcx>,\n+                                  cmt: &mc::cmt_<'tcx>,\n                                   mode: euv::MutateMode) {\n \n-        let opt_lp = opt_loan_path(&cmt);\n+        let opt_lp = opt_loan_path(cmt);\n         debug!(\"guarantee_assignment_valid(assignment_id={}, cmt={:?}) opt_lp={:?}\",\n                assignment_id, cmt, opt_lp);\n \n@@ -259,14 +259,14 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         } else {\n             // Check that we don't allow assignments to non-mutable data.\n             if check_mutability(self.bccx, assignment_span, MutabilityViolation,\n-                                cmt.clone(), ty::MutBorrow).is_err() {\n+                                cmt, ty::MutBorrow).is_err() {\n                 return; // reported an error, no sense in reporting more.\n             }\n         }\n \n         // Check that we don't allow assignments to aliasable data\n         if check_aliasability(self.bccx, assignment_span, MutabilityViolation,\n-                              cmt.clone(), ty::MutBorrow).is_err() {\n+                              cmt, ty::MutBorrow).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n@@ -300,7 +300,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     fn guarantee_valid(&mut self,\n                        borrow_id: hir::ItemLocalId,\n                        borrow_span: Span,\n-                       cmt: mc::cmt<'tcx>,\n+                       cmt: &mc::cmt_<'tcx>,\n                        req_kind: ty::BorrowKind,\n                        loan_region: ty::Region<'tcx>,\n                        cause: euv::LoanCause) {\n@@ -320,28 +320,26 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         // Check that the lifetime of the borrow does not exceed\n         // the lifetime of the data being borrowed.\n         if lifetime::guarantee_lifetime(self.bccx, self.item_ub,\n-                                        borrow_span, cause, cmt.clone(), loan_region,\n-                                        req_kind).is_err() {\n+                                        borrow_span, cause, cmt, loan_region, req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of non-mutable data.\n         if check_mutability(self.bccx, borrow_span, BorrowViolation(cause),\n-                            cmt.clone(), req_kind).is_err() {\n+                            cmt, req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of aliasable data.\n         if check_aliasability(self.bccx, borrow_span, BorrowViolation(cause),\n-                              cmt.clone(), req_kind).is_err() {\n+                              cmt, req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Compute the restrictions that are required to enforce the\n         // loan is safe.\n         let restr = restrictions::compute_restrictions(\n-            self.bccx, borrow_span, cause,\n-            cmt.clone(), loan_region);\n+            self.bccx, borrow_span, cause, &cmt, loan_region);\n \n         debug!(\"guarantee_valid(): restrictions={:?}\", restr);\n "}, {"sha": "0b90127cc7e1e526e2cd82800b3db691cca4f58b", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -30,7 +30,7 @@ pub enum RestrictionResult<'tcx> {\n pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       span: Span,\n                                       cause: euv::LoanCause,\n-                                      cmt: mc::cmt<'tcx>,\n+                                      cmt: &mc::cmt_<'tcx>,\n                                       loan_region: ty::Region<'tcx>)\n                                       -> RestrictionResult<'tcx> {\n     let ctxt = RestrictionsContext {\n@@ -55,7 +55,7 @@ struct RestrictionsContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     fn restrict(&self,\n-                cmt: mc::cmt<'tcx>) -> RestrictionResult<'tcx> {\n+                cmt: &mc::cmt_<'tcx>) -> RestrictionResult<'tcx> {\n         debug!(\"restrict(cmt={:?})\", cmt);\n \n         let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n@@ -86,7 +86,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 // When we borrow the interior of an enum, we have to\n                 // ensure the enum itself is not mutated, because that\n                 // could cause the type of the memory to change.\n-                self.restrict(cmt_base)\n+                self.restrict(&cmt_base)\n             }\n \n             Categorization::Interior(cmt_base, interior) => {\n@@ -101,7 +101,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 };\n                 let interior = interior.cleaned();\n                 let base_ty = cmt_base.ty;\n-                let result = self.restrict(cmt_base);\n+                let result = self.restrict(&cmt_base);\n                 // Borrowing one union field automatically borrows all its fields.\n                 match base_ty.sty {\n                     ty::TyAdt(adt_def, _) if adt_def.is_union() => match result {\n@@ -145,7 +145,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                         //\n                         // Eventually we should make these non-special and\n                         // just rely on Deref<T> implementation.\n-                        let result = self.restrict(cmt_base);\n+                        let result = self.restrict(&cmt_base);\n                         self.extend(result, &cmt, LpDeref(pk))\n                     }\n                     mc::Implicit(bk, lt) | mc::BorrowedPtr(bk, lt) => {\n@@ -155,7 +155,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                                 BckError {\n                                     span: self.span,\n                                     cause: BorrowViolation(self.cause),\n-                                    cmt: cmt_base,\n+                                    cmt: &cmt_base,\n                                     code: err_borrowed_pointer_too_short(\n                                         self.loan_region, lt)});\n                             return RestrictionResult::Safe;\n@@ -169,7 +169,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                                 // The referent can be aliased after the\n                                 // references lifetime ends (by a newly-unfrozen\n                                 // borrow).\n-                                let result = self.restrict(cmt_base);\n+                                let result = self.restrict(&cmt_base);\n                                 self.extend(result, &cmt, LpDeref(pk))\n                             }\n                         }\n@@ -183,7 +183,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n \n     fn extend(&self,\n               result: RestrictionResult<'tcx>,\n-              cmt: &mc::cmt<'tcx>,\n+              cmt: &mc::cmt_<'tcx>,\n               elem: LoanPathElem<'tcx>) -> RestrictionResult<'tcx> {\n         match result {\n             RestrictionResult::Safe => RestrictionResult::Safe,"}, {"sha": "9d0d8c2f909af7caa63f45243ed11a2f441bf624", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -144,7 +144,10 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n     {\n         check_loans::check_loans(&mut bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n     }\n-    unused::check(&mut bccx, body);\n+\n+    if !tcx.use_mir_borrowck() {\n+        unused::check(&mut bccx, body);\n+    }\n \n     Lrc::new(BorrowCheckResult {\n         used_mut_nodes: bccx.used_mut_nodes.into_inner(),\n@@ -497,7 +500,7 @@ impl<'a, 'tcx> LoanPath<'tcx> {\n \n // Avoid \"cannot borrow immutable field `self.x` as mutable\" as that implies that a field *can* be\n // mutable independently of the struct it belongs to. (#35937)\n-pub fn opt_loan_path_is_field<'tcx>(cmt: &mc::cmt<'tcx>) -> (Option<Rc<LoanPath<'tcx>>>, bool) {\n+pub fn opt_loan_path_is_field<'tcx>(cmt: &mc::cmt_<'tcx>) -> (Option<Rc<LoanPath<'tcx>>>, bool) {\n     let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n \n     match cmt.cat {\n@@ -545,7 +548,7 @@ pub fn opt_loan_path_is_field<'tcx>(cmt: &mc::cmt<'tcx>) -> (Option<Rc<LoanPath<\n /// the method `compute()` found in `gather_loans::restrictions`,\n /// which allows it to share common loan path pieces as it\n /// traverses the CMT.\n-pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n+pub fn opt_loan_path<'tcx>(cmt: &mc::cmt_<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n     opt_loan_path_is_field(cmt).0\n }\n \n@@ -564,10 +567,10 @@ pub enum bckerr_code<'tcx> {\n // Combination of an error code and the categorization of the expression\n // that caused it\n #[derive(Debug, PartialEq)]\n-pub struct BckError<'tcx> {\n+pub struct BckError<'c, 'tcx: 'c> {\n     span: Span,\n     cause: AliasableViolationKind,\n-    cmt: mc::cmt<'tcx>,\n+    cmt: &'c mc::cmt_<'tcx>,\n     code: bckerr_code<'tcx>\n }\n \n@@ -599,7 +602,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         region_rels.is_subregion_of(r_sub, r_sup)\n     }\n \n-    pub fn report(&self, err: BckError<'tcx>) {\n+    pub fn report(&self, err: BckError<'a, 'tcx>) {\n         // Catch and handle some particular cases.\n         match (&err.code, &err.cause) {\n             (&err_out_of_scope(&ty::ReScope(_), &ty::ReStatic, _),\n@@ -800,7 +803,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err_with_code(s, msg, code);\n     }\n \n-    fn report_bckerr(&self, err: &BckError<'tcx>) {\n+    fn report_bckerr(&self, err: &BckError<'a, 'tcx>) {\n         let error_span = err.span.clone();\n \n         match err.code {\n@@ -1011,7 +1014,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 db.emit();\n             }\n             err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n-                let descr = self.cmt_to_path_or_string(&err.cmt);\n+                let descr = self.cmt_to_path_or_string(err.cmt);\n                 let mut db = self.lifetime_too_short_for_reborrow(error_span, &descr, Origin::Ast);\n                 let descr = match opt_loan_path(&err.cmt) {\n                     Some(lp) => {\n@@ -1042,7 +1045,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                          span: Span,\n                                          kind: AliasableViolationKind,\n                                          cause: mc::AliasableReason,\n-                                         cmt: mc::cmt<'tcx>) {\n+                                         cmt: &mc::cmt_<'tcx>) {\n         let mut is_closure = false;\n         let prefix = match kind {\n             MutabilityViolation => {\n@@ -1240,7 +1243,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     fn report_out_of_scope_escaping_closure_capture(&self,\n-                                                    err: &BckError<'tcx>,\n+                                                    err: &BckError<'a, 'tcx>,\n                                                     capture_span: Span)\n     {\n         let cmt_path_or_string = self.cmt_to_path_or_string(&err.cmt);\n@@ -1274,18 +1277,18 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn note_and_explain_mutbl_error(&self, db: &mut DiagnosticBuilder, err: &BckError<'tcx>,\n+    fn note_and_explain_mutbl_error(&self, db: &mut DiagnosticBuilder, err: &BckError<'a, 'tcx>,\n                                     error_span: &Span) {\n         match err.cmt.note {\n             mc::NoteClosureEnv(upvar_id) | mc::NoteUpvarRef(upvar_id) => {\n                 // If this is an `Fn` closure, it simply can't mutate upvars.\n                 // If it's an `FnMut` closure, the original variable was declared immutable.\n                 // We need to determine which is the case here.\n-                let kind = match err.cmt.upvar().unwrap().cat {\n+                let kind = match err.cmt.upvar_cat().unwrap() {\n                     Categorization::Upvar(mc::Upvar { kind, .. }) => kind,\n                     _ => bug!()\n                 };\n-                if kind == ty::ClosureKind::Fn {\n+                if *kind == ty::ClosureKind::Fn {\n                     let closure_node_id =\n                         self.tcx.hir.local_def_id_to_node_id(upvar_id.closure_expr_id);\n                     db.span_help(self.tcx.hir.span(closure_node_id),\n@@ -1389,7 +1392,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         cmt.descriptive_string(self.tcx)\n     }\n \n-    pub fn cmt_to_path_or_string(&self, cmt: &mc::cmt<'tcx>) -> String {\n+    pub fn cmt_to_path_or_string(&self, cmt: &mc::cmt_<'tcx>) -> String {\n         match opt_loan_path(cmt) {\n             Some(lp) => format!(\"`{}`\", self.loan_path_to_string(&lp)),\n             None => self.cmt_to_string(cmt),"}, {"sha": "41310ede3e085a0928288779615792ea79dd8055", "filename": "src/librustc_const_math/Cargo.toml", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1d5509bf381d978a1894b6ba869c3b56dd3eeca/src%2Flibrustc_const_math%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1d5509bf381d978a1894b6ba869c3b56dd3eeca/src%2Flibrustc_const_math%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2FCargo.toml?ref=e1d5509bf381d978a1894b6ba869c3b56dd3eeca", "patch": "@@ -1,14 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rustc_const_math\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"rustc_const_math\"\n-path = \"lib.rs\"\n-crate-type = [\"dylib\"]\n-\n-[dependencies]\n-rustc_apfloat = { path = \"../librustc_apfloat\" }\n-serialize = { path = \"../libserialize\" }\n-syntax = { path = \"../libsyntax\" }"}, {"sha": "bd0a332436e6427c945ed803ff270e88da5487be", "filename": "src/librustc_const_math/err.rs", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e1d5509bf381d978a1894b6ba869c3b56dd3eeca/src%2Flibrustc_const_math%2Ferr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d5509bf381d978a1894b6ba869c3b56dd3eeca/src%2Flibrustc_const_math%2Ferr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ferr.rs?ref=e1d5509bf381d978a1894b6ba869c3b56dd3eeca", "patch": "@@ -1,87 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use syntax::ast;\n-\n-#[derive(Debug, PartialEq, Eq, Clone, RustcEncodable, RustcDecodable)]\n-pub enum ConstMathErr {\n-    NotInRange,\n-    CmpBetweenUnequalTypes,\n-    UnequalTypes(Op),\n-    Overflow(Op),\n-    ShiftNegative,\n-    DivisionByZero,\n-    RemainderByZero,\n-    UnsignedNegation,\n-    ULitOutOfRange(ast::UintTy),\n-    LitOutOfRange(ast::IntTy),\n-}\n-pub use self::ConstMathErr::*;\n-\n-#[derive(Debug, PartialEq, Eq, Clone, RustcEncodable, RustcDecodable)]\n-pub enum Op {\n-    Add,\n-    Sub,\n-    Mul,\n-    Div,\n-    Rem,\n-    Shr,\n-    Shl,\n-    Neg,\n-    BitAnd,\n-    BitOr,\n-    BitXor,\n-}\n-\n-impl ConstMathErr {\n-    pub fn description(&self) -> &'static str {\n-        use self::Op::*;\n-        match *self {\n-            NotInRange => \"inferred value out of range\",\n-            CmpBetweenUnequalTypes => \"compared two values of different types\",\n-            UnequalTypes(Add) => \"tried to add two values of different types\",\n-            UnequalTypes(Sub) => \"tried to subtract two values of different types\",\n-            UnequalTypes(Mul) => \"tried to multiply two values of different types\",\n-            UnequalTypes(Div) => \"tried to divide two values of different types\",\n-            UnequalTypes(Rem) => {\n-                \"tried to calculate the remainder of two values of different types\"\n-            },\n-            UnequalTypes(BitAnd) => \"tried to bitand two values of different types\",\n-            UnequalTypes(BitOr) => \"tried to bitor two values of different types\",\n-            UnequalTypes(BitXor) => \"tried to xor two values of different types\",\n-            UnequalTypes(_) => unreachable!(),\n-            Overflow(Add) => \"attempt to add with overflow\",\n-            Overflow(Sub) => \"attempt to subtract with overflow\",\n-            Overflow(Mul) => \"attempt to multiply with overflow\",\n-            Overflow(Div) => \"attempt to divide with overflow\",\n-            Overflow(Rem) => \"attempt to calculate the remainder with overflow\",\n-            Overflow(Neg) => \"attempt to negate with overflow\",\n-            Overflow(Shr) => \"attempt to shift right with overflow\",\n-            Overflow(Shl) => \"attempt to shift left with overflow\",\n-            Overflow(_) => unreachable!(),\n-            ShiftNegative => \"attempt to shift by a negative amount\",\n-            DivisionByZero => \"attempt to divide by zero\",\n-            RemainderByZero => \"attempt to calculate the remainder with a divisor of zero\",\n-            UnsignedNegation => \"unary negation of unsigned integer\",\n-            ULitOutOfRange(ast::UintTy::U8) => \"literal out of range for u8\",\n-            ULitOutOfRange(ast::UintTy::U16) => \"literal out of range for u16\",\n-            ULitOutOfRange(ast::UintTy::U32) => \"literal out of range for u32\",\n-            ULitOutOfRange(ast::UintTy::U64) => \"literal out of range for u64\",\n-            ULitOutOfRange(ast::UintTy::U128) => \"literal out of range for u128\",\n-            ULitOutOfRange(ast::UintTy::Usize) => \"literal out of range for usize\",\n-            LitOutOfRange(ast::IntTy::I8) => \"literal out of range for i8\",\n-            LitOutOfRange(ast::IntTy::I16) => \"literal out of range for i16\",\n-            LitOutOfRange(ast::IntTy::I32) => \"literal out of range for i32\",\n-            LitOutOfRange(ast::IntTy::I64) => \"literal out of range for i64\",\n-            LitOutOfRange(ast::IntTy::I128) => \"literal out of range for i128\",\n-            LitOutOfRange(ast::IntTy::Isize) => \"literal out of range for isize\",\n-        }\n-    }\n-}"}, {"sha": "9d820ea8cbed2990e91ab163aee9416840f8e8b1", "filename": "src/librustc_const_math/float.rs", "status": "removed", "additions": 0, "deletions": 213, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/e1d5509bf381d978a1894b6ba869c3b56dd3eeca/src%2Flibrustc_const_math%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d5509bf381d978a1894b6ba869c3b56dd3eeca/src%2Flibrustc_const_math%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ffloat.rs?ref=e1d5509bf381d978a1894b6ba869c3b56dd3eeca", "patch": "@@ -1,213 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::cmp::Ordering;\n-use std::num::ParseFloatError;\n-\n-use syntax::ast;\n-\n-use rustc_apfloat::{Float, FloatConvert, Status};\n-use rustc_apfloat::ieee::{Single, Double};\n-\n-use super::err::*;\n-\n-// Note that equality for `ConstFloat` means that the it is the same\n-// constant, not that the rust values are equal. In particular, `NaN\n-// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n-// are considering unequal).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub struct ConstFloat {\n-    pub ty: ast::FloatTy,\n-\n-    // This is a bit inefficient but it makes conversions below more\n-    // ergonomic, and all of this will go away once `miri` is merged.\n-    pub bits: u128,\n-}\n-\n-impl ConstFloat {\n-    /// Description of the type, not the value\n-    pub fn description(&self) -> &'static str {\n-        self.ty.ty_to_string()\n-    }\n-\n-    /// Compares the values if they are of the same type\n-    pub fn try_cmp(self, rhs: Self) -> Result<Ordering, ConstMathErr> {\n-        match (self.ty, rhs.ty) {\n-            (ast::FloatTy::F64, ast::FloatTy::F64)  => {\n-                let a = Double::from_bits(self.bits);\n-                let b = Double::from_bits(rhs.bits);\n-                // This is pretty bad but it is the existing behavior.\n-                Ok(a.partial_cmp(&b).unwrap_or(Ordering::Greater))\n-            }\n-\n-            (ast::FloatTy::F32, ast::FloatTy::F32) => {\n-                let a = Single::from_bits(self.bits);\n-                let b = Single::from_bits(rhs.bits);\n-                Ok(a.partial_cmp(&b).unwrap_or(Ordering::Greater))\n-            }\n-\n-            _ => Err(CmpBetweenUnequalTypes),\n-        }\n-    }\n-\n-    pub fn from_i128(input: i128, ty: ast::FloatTy) -> Self {\n-        let bits = match ty {\n-            ast::FloatTy::F32 => Single::from_i128(input).value.to_bits(),\n-            ast::FloatTy::F64 => Double::from_i128(input).value.to_bits()\n-        };\n-        ConstFloat { bits, ty }\n-    }\n-\n-    pub fn from_u128(input: u128, ty: ast::FloatTy) -> Self {\n-        let bits = match ty {\n-            ast::FloatTy::F32 => Single::from_u128(input).value.to_bits(),\n-            ast::FloatTy::F64 => Double::from_u128(input).value.to_bits()\n-        };\n-        ConstFloat { bits, ty }\n-    }\n-\n-    pub fn from_str(num: &str, ty: ast::FloatTy) -> Result<Self, ParseFloatError> {\n-        let bits = match ty {\n-            ast::FloatTy::F32 => {\n-                let rust_bits = num.parse::<f32>()?.to_bits() as u128;\n-                let apfloat = num.parse::<Single>().unwrap_or_else(|e| {\n-                    panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e);\n-                });\n-                let apfloat_bits = apfloat.to_bits();\n-                assert!(rust_bits == apfloat_bits,\n-                    \"apfloat::ieee::Single gave different result for `{}`: \\\n-                     {}({:#x}) vs Rust's {}({:#x})\",\n-                    num, apfloat, apfloat_bits,\n-                    Single::from_bits(rust_bits), rust_bits);\n-                apfloat_bits\n-            }\n-            ast::FloatTy::F64 => {\n-                let rust_bits = num.parse::<f64>()?.to_bits() as u128;\n-                let apfloat = num.parse::<Double>().unwrap_or_else(|e| {\n-                    panic!(\"apfloat::ieee::Double failed to parse `{}`: {:?}\", num, e);\n-                });\n-                let apfloat_bits = apfloat.to_bits();\n-                assert!(rust_bits == apfloat_bits,\n-                    \"apfloat::ieee::Double gave different result for `{}`: \\\n-                     {}({:#x}) vs Rust's {}({:#x})\",\n-                    num, apfloat, apfloat_bits,\n-                    Double::from_bits(rust_bits), rust_bits);\n-                apfloat_bits\n-            }\n-        };\n-        Ok(ConstFloat { bits, ty })\n-    }\n-\n-    pub fn to_i128(self, width: usize) -> Option<i128> {\n-        assert!(width <= 128);\n-        let r = match self.ty {\n-            ast::FloatTy::F32 => Single::from_bits(self.bits).to_i128(width),\n-            ast::FloatTy::F64 => Double::from_bits(self.bits).to_i128(width)\n-        };\n-        if r.status.intersects(Status::INVALID_OP) {\n-            None\n-        } else {\n-            Some(r.value)\n-        }\n-    }\n-\n-    pub fn to_u128(self, width: usize) -> Option<u128> {\n-        assert!(width <= 128);\n-        let r = match self.ty {\n-            ast::FloatTy::F32 => Single::from_bits(self.bits).to_u128(width),\n-            ast::FloatTy::F64 => Double::from_bits(self.bits).to_u128(width)\n-        };\n-        if r.status.intersects(Status::INVALID_OP) {\n-            None\n-        } else {\n-            Some(r.value)\n-        }\n-    }\n-\n-    pub fn convert(self, to: ast::FloatTy) -> Self {\n-        let bits = match (self.ty, to) {\n-            (ast::FloatTy::F32, ast::FloatTy::F32) |\n-            (ast::FloatTy::F64, ast::FloatTy::F64) => return self,\n-\n-            (ast::FloatTy::F32, ast::FloatTy::F64) => {\n-                Double::to_bits(Single::from_bits(self.bits).convert(&mut false).value)\n-            }\n-            (ast::FloatTy::F64, ast::FloatTy::F32) => {\n-                Single::to_bits(Double::from_bits(self.bits).convert(&mut false).value)\n-            }\n-        };\n-        ConstFloat { bits, ty: to }\n-    }\n-}\n-\n-impl ::std::fmt::Display for ConstFloat {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        match self.ty {\n-            ast::FloatTy::F32 => write!(fmt, \"{:#}\", Single::from_bits(self.bits))?,\n-            ast::FloatTy::F64 => write!(fmt, \"{:#}\", Double::from_bits(self.bits))?,\n-        }\n-        write!(fmt, \"{}\", self.ty)\n-    }\n-}\n-\n-impl ::std::fmt::Debug for ConstFloat {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        ::std::fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-macro_rules! derive_binop {\n-    ($op:ident, $func:ident) => {\n-        impl ::std::ops::$op for ConstFloat {\n-            type Output = Result<Self, ConstMathErr>;\n-            fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                let bits = match (self.ty, rhs.ty) {\n-                    (ast::FloatTy::F32, ast::FloatTy::F32) =>{\n-                        let a = Single::from_bits(self.bits);\n-                        let b = Single::from_bits(rhs.bits);\n-                        a.$func(b).value.to_bits()\n-                    }\n-                    (ast::FloatTy::F64, ast::FloatTy::F64) => {\n-                        let a = Double::from_bits(self.bits);\n-                        let b = Double::from_bits(rhs.bits);\n-                        a.$func(b).value.to_bits()\n-                    }\n-                    _ => return Err(UnequalTypes(Op::$op)),\n-                };\n-                Ok(ConstFloat { bits, ty: self.ty })\n-            }\n-        }\n-    }\n-}\n-\n-derive_binop!(Add, add);\n-derive_binop!(Sub, sub);\n-derive_binop!(Mul, mul);\n-derive_binop!(Div, div);\n-derive_binop!(Rem, rem);\n-\n-impl ::std::ops::Neg for ConstFloat {\n-    type Output = Self;\n-    fn neg(self) -> Self {\n-        let bits = match self.ty {\n-            ast::FloatTy::F32 => (-Single::from_bits(self.bits)).to_bits(),\n-            ast::FloatTy::F64 => (-Double::from_bits(self.bits)).to_bits(),\n-        };\n-        ConstFloat { bits, ty: self.ty }\n-    }\n-}\n-\n-/// This is `f32::MAX + (0.5 ULP)` as an integer. Numbers greater or equal to this\n-/// are rounded to infinity when converted to `f32`.\n-///\n-/// NB: Computed as maximum significand with an extra 1 bit added (for the half ULP)\n-/// shifted by the maximum exponent (accounting for normalization).\n-pub const MAX_F32_PLUS_HALF_ULP: u128 = ((1 << (Single::PRECISION + 1)) - 1)\n-                                        << (Single::MAX_EXP - Single::PRECISION as i16);"}, {"sha": "499c330be1da8aca6a0d32483d9d011c2a7bf559", "filename": "src/librustc_const_math/lib.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e1d5509bf381d978a1894b6ba869c3b56dd3eeca/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d5509bf381d978a1894b6ba869c3b56dd3eeca/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=e1d5509bf381d978a1894b6ba869c3b56dd3eeca", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Rusty Mathematics\n-//!\n-//! # Note\n-//!\n-//! This API is completely unstable and subject to change.\n-\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-\n-extern crate rustc_apfloat;\n-\n-extern crate syntax;\n-\n-extern crate serialize as rustc_serialize; // used by deriving\n-\n-mod float;\n-mod err;\n-\n-pub use float::*;\n-pub use err::{ConstMathErr, Op};"}, {"sha": "74f91af10fe637888342d6a7c39407a3e239cd3e", "filename": "src/librustc_data_structures/lazy_btree_map.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_data_structures%2Flazy_btree_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_data_structures%2Flazy_btree_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flazy_btree_map.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::btree_map;\n+use std::collections::BTreeMap;\n+\n+/// A thin wrapper around BTreeMap that avoids allocating upon creation.\n+///\n+/// Vec, HashSet and HashMap all have the nice feature that they don't do any\n+/// heap allocation when creating a new structure of the default size. In\n+/// contrast, BTreeMap *does* allocate in that situation. The compiler uses\n+/// B-Tree maps in some places such that many maps are created but few are\n+/// inserted into, so having a BTreeMap alternative that avoids allocating on\n+/// creation is a performance win.\n+///\n+/// Only a fraction of BTreeMap's functionality is currently supported.\n+/// Additional functionality should be added on demand.\n+#[derive(Debug)]\n+pub struct LazyBTreeMap<K, V>(Option<BTreeMap<K, V>>);\n+\n+impl<K, V> LazyBTreeMap<K, V> {\n+    pub fn new() -> LazyBTreeMap<K, V> {\n+        LazyBTreeMap(None)\n+    }\n+\n+    pub fn iter(&self) -> Iter<K, V> {\n+        Iter(self.0.as_ref().map(|btm| btm.iter()))\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.0.as_ref().map_or(true, |btm| btm.is_empty())\n+    }\n+}\n+\n+impl<K: Ord, V> LazyBTreeMap<K, V> {\n+    fn instantiate(&mut self) -> &mut BTreeMap<K, V> {\n+        if let Some(ref mut btm) = self.0 {\n+            btm\n+        } else {\n+            let btm = BTreeMap::new();\n+            self.0 = Some(btm);\n+            self.0.as_mut().unwrap()\n+        }\n+    }\n+\n+    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n+        self.instantiate().insert(key, value)\n+    }\n+\n+    pub fn entry(&mut self, key: K) -> btree_map::Entry<K, V> {\n+        self.instantiate().entry(key)\n+    }\n+\n+    pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n+        Values(self.0.as_ref().map(|btm| btm.values()))\n+    }\n+}\n+\n+impl<K: Ord, V> Default for LazyBTreeMap<K, V> {\n+    fn default() -> LazyBTreeMap<K, V> {\n+        LazyBTreeMap::new()\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> IntoIterator for &'a LazyBTreeMap<K, V> {\n+    type Item = (&'a K, &'a V);\n+    type IntoIter = Iter<'a, K, V>;\n+\n+    fn into_iter(self) -> Iter<'a, K, V> {\n+        self.iter()\n+    }\n+}\n+\n+pub struct Iter<'a, K: 'a, V: 'a>(Option<btree_map::Iter<'a, K, V>>);\n+\n+impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n+    type Item = (&'a K, &'a V);\n+\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n+        self.0.as_mut().and_then(|iter| iter.next())\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.as_ref().map_or_else(|| (0, Some(0)), |iter| iter.size_hint())\n+    }\n+}\n+\n+pub struct Values<'a, K: 'a, V: 'a>(Option<btree_map::Values<'a, K, V>>);\n+\n+impl<'a, K, V> Iterator for Values<'a, K, V> {\n+    type Item = &'a V;\n+\n+    fn next(&mut self) -> Option<&'a V> {\n+        self.0.as_mut().and_then(|values| values.next())\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.as_ref().map_or_else(|| (0, Some(0)), |values| values.size_hint())\n+    }\n+}\n+"}, {"sha": "597d1627ada03da578556f761897937181a063c7", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -60,6 +60,7 @@ pub mod bitvec;\n pub mod graph;\n pub mod indexed_set;\n pub mod indexed_vec;\n+pub mod lazy_btree_map;\n pub mod obligation_forest;\n pub mod sip128;\n pub mod snapshot_map;"}, {"sha": "a1052ca6c3ca9520fc7cf8f4e38ebc106f8263a7", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1060,7 +1060,7 @@ impl RustcDefaultCalls {\n                     let mut cfgs = Vec::new();\n                     for &(name, ref value) in sess.parse_sess.config.iter() {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n-                            ident: ast::Ident::with_empty_ctxt(name),\n+                            ident: ast::Path::from_ident(name.to_ident()),\n                             node: ast::MetaItemKind::Word,\n                             span: DUMMY_SP,\n                         });\n@@ -1526,7 +1526,8 @@ pub fn in_rustc_thread<F, R>(f: F) -> Result<R, Box<Any + Send>>\n         let thread = cfg.spawn(f);\n         thread.unwrap().join()\n     } else {\n-        Ok(f())\n+        let f = panic::AssertUnwindSafe(f);\n+        panic::catch_unwind(f)\n     }\n }\n "}, {"sha": "6426286ccbc6c3bfb7a0ac2dc5c7176ef9aa2855", "filename": "src/librustc_driver/profile/trace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -10,7 +10,7 @@\n \n use super::*;\n use syntax_pos::SpanData;\n-use rustc::ty::maps::QueryMsg;\n+use rustc::util::common::QueryMsg;\n use std::fs::File;\n use std::time::{Duration, Instant};\n use std::collections::hash_map::HashMap;"}, {"sha": "d2ee3d8743c2cd74886d8e3b3a5d18098c5d22e7", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -303,11 +303,11 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n     pub fn t_param(&self, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        self.infcx.tcx.mk_param(index, Symbol::intern(&name).as_str())\n+        self.infcx.tcx.mk_param(index, Symbol::intern(&name).as_interned_str())\n     }\n \n     pub fn re_early_bound(&self, index: u32, name: &'static str) -> ty::Region<'tcx> {\n-        let name = Symbol::intern(name).as_str();\n+        let name = Symbol::intern(name).as_interned_str();\n         self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             def_id: self.infcx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n             index,"}, {"sha": "75401f21862b67a683b9fab3450f082061d77432", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -11,6 +11,7 @@\n use CodeSuggestion;\n use SubstitutionPart;\n use Substitution;\n+use Applicability;\n use Level;\n use std::fmt;\n use syntax_pos::{MultiSpan, Span};\n@@ -222,7 +223,7 @@ impl Diagnostic {\n             }],\n             msg: msg.to_owned(),\n             show_code_when_inline: false,\n-            approximate: false,\n+            applicability: Applicability::Unspecified,\n         });\n         self\n     }\n@@ -253,7 +254,7 @@ impl Diagnostic {\n             }],\n             msg: msg.to_owned(),\n             show_code_when_inline: true,\n-            approximate: false,\n+            applicability: Applicability::Unspecified,\n         });\n         self\n     }\n@@ -269,15 +270,16 @@ impl Diagnostic {\n             }).collect(),\n             msg: msg.to_owned(),\n             show_code_when_inline: true,\n-            approximate: false,\n+            applicability: Applicability::Unspecified,\n         });\n         self\n     }\n \n     /// This is a suggestion that may contain mistakes or fillers and should\n     /// be read and understood by a human.\n-    pub fn span_approximate_suggestion(&mut self, sp: Span, msg: &str,\n-                                       suggestion: String) -> &mut Self {\n+    pub fn span_suggestion_with_applicability(&mut self, sp: Span, msg: &str,\n+                                       suggestion: String,\n+                                       applicability: Applicability) -> &mut Self {\n         self.suggestions.push(CodeSuggestion {\n             substitutions: vec![Substitution {\n                 parts: vec![SubstitutionPart {\n@@ -287,13 +289,14 @@ impl Diagnostic {\n             }],\n             msg: msg.to_owned(),\n             show_code_when_inline: true,\n-            approximate: true,\n+            applicability,\n         });\n         self\n     }\n \n-    pub fn span_approximate_suggestions(&mut self, sp: Span, msg: &str,\n-                                        suggestions: Vec<String>) -> &mut Self {\n+    pub fn span_suggestions_with_applicability(&mut self, sp: Span, msg: &str,\n+                                        suggestions: Vec<String>,\n+                                        applicability: Applicability) -> &mut Self {\n         self.suggestions.push(CodeSuggestion {\n             substitutions: suggestions.into_iter().map(|snippet| Substitution {\n                 parts: vec![SubstitutionPart {\n@@ -303,7 +306,7 @@ impl Diagnostic {\n             }).collect(),\n             msg: msg.to_owned(),\n             show_code_when_inline: true,\n-            approximate: true,\n+            applicability,\n         });\n         self\n     }"}, {"sha": "7e9ca8633a53e4ea119fb8a0832cccae45c19137", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -11,6 +11,7 @@\n use Diagnostic;\n use DiagnosticId;\n use DiagnosticStyledString;\n+use Applicability;\n \n use Level;\n use Handler;\n@@ -187,15 +188,17 @@ impl<'a> DiagnosticBuilder<'a> {\n                                      msg: &str,\n                                      suggestions: Vec<String>)\n                                      -> &mut Self);\n-    forward!(pub fn span_approximate_suggestion(&mut self,\n+    forward!(pub fn span_suggestion_with_applicability(&mut self,\n                                                 sp: Span,\n                                                 msg: &str,\n-                                                suggestion: String)\n+                                                suggestion: String,\n+                                                applicability: Applicability)\n                                                 -> &mut Self);\n-    forward!(pub fn span_approximate_suggestions(&mut self,\n+    forward!(pub fn span_suggestions_with_applicability(&mut self,\n                                                  sp: Span,\n                                                  msg: &str,\n-                                                 suggestions: Vec<String>)\n+                                                 suggestions: Vec<String>,\n+                                                 applicability: Applicability)\n                                                  -> &mut Self);\n     forward!(pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self);\n     forward!(pub fn code(&mut self, s: DiagnosticId) -> &mut Self);"}, {"sha": "c2b442e949758a19c64f4b2aa73dc8d7264f6282", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -56,6 +56,14 @@ mod lock;\n \n use syntax_pos::{BytePos, Loc, FileLinesResult, FileMap, FileName, MultiSpan, Span, NO_EXPANSION};\n \n+#[derive(Copy, Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+pub enum Applicability {\n+    MachineApplicable,\n+    HasPlaceholders,\n+    MaybeIncorrect,\n+    Unspecified\n+}\n+\n #[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub struct CodeSuggestion {\n     /// Each substitute can have multiple variants due to multiple\n@@ -87,7 +95,7 @@ pub struct CodeSuggestion {\n     /// Sometimes we may show suggestions with placeholders,\n     /// which are useful for users but not useful for\n     /// tools like rustfix\n-    pub approximate: bool,\n+    pub applicability: Applicability,\n }\n \n #[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]"}, {"sha": "38e891008f7308c073fb30b82c976418a4760b4e", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n         for list_item in attr.meta_item_list().unwrap_or_default() {\n             match list_item.word() {\n                 Some(word) if value.is_none() =>\n-                    value = Some(word.ident.name),\n+                    value = Some(word.name()),\n                 _ =>\n                     // FIXME better-encapsulate meta_item (don't directly access `node`)\n                     span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item.node),"}, {"sha": "6906dacfc5ef69af281e585b34bce8d0c50aa994", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n \n         let mname = self.field(attr, MODULE);\n         let mangled_cgu_name = CodegenUnit::mangle_name(&mname.as_str());\n-        let mangled_cgu_name = Symbol::intern(&mangled_cgu_name).as_str();\n+        let mangled_cgu_name = Symbol::intern(&mangled_cgu_name).as_interned_str();\n \n         let dep_node = DepNode::new(self.tcx,\n                                     DepConstructor::CompileCodegenUnit(mangled_cgu_name));"}, {"sha": "f06062fa4ac83091dddc7945df8660ef7672d202", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -675,9 +675,8 @@ impl LintPass for DeprecatedAttr {\n \n impl EarlyLintPass for DeprecatedAttr {\n     fn check_attribute(&mut self, cx: &EarlyContext, attr: &ast::Attribute) {\n-        let name = unwrap_or!(attr.name(), return);\n         for &&(n, _, ref g) in &self.depr_attrs {\n-            if name == n {\n+            if attr.name() == n {\n                 if let &AttributeGate::Gated(Stability::Deprecated(link),\n                                              ref name,\n                                              ref reason,"}, {"sha": "4f6d23dce6dbb835c27a520e48737323c3ff8d9c", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -30,7 +30,6 @@\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n \n-#[macro_use]\n extern crate syntax;\n #[macro_use]\n extern crate rustc;"}, {"sha": "8df40b62ddd1253d66cfd874ecce18377502ba69", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 49, "deletions": 32, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n use rustc::ty::adjustment;\n@@ -72,40 +73,57 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         let mut fn_warned = false;\n         let mut op_warned = false;\n-        if cx.tcx.features().fn_must_use {\n-            let maybe_def = match expr.node {\n-                hir::ExprCall(ref callee, _) => {\n-                    match callee.node {\n-                        hir::ExprPath(ref qpath) => {\n-                            Some(cx.tables.qpath_def(qpath, callee.hir_id))\n-                        },\n-                        _ => None\n-                    }\n-                },\n-                hir::ExprMethodCall(..) => {\n-                    cx.tables.type_dependent_defs().get(expr.hir_id).cloned()\n-                },\n-                _ => None\n-            };\n-            if let Some(def) = maybe_def {\n-                let def_id = def.def_id();\n-                fn_warned = check_must_use(cx, def_id, s.span, \"return value of \");\n-            }\n-\n-            if let hir::ExprBinary(bin_op, ..) = expr.node {\n+        let maybe_def = match expr.node {\n+            hir::ExprCall(ref callee, _) => {\n+                match callee.node {\n+                    hir::ExprPath(ref qpath) => {\n+                        let def = cx.tables.qpath_def(qpath, callee.hir_id);\n+                        if let Def::Fn(_) = def {\n+                            Some(def)\n+                        } else {  // `Def::Local` if it was a closure, for which we\n+                            None  // do not currently support must-use linting\n+                        }\n+                    },\n+                    _ => None\n+                }\n+            },\n+            hir::ExprMethodCall(..) => {\n+                cx.tables.type_dependent_defs().get(expr.hir_id).cloned()\n+            },\n+            _ => None\n+        };\n+        if let Some(def) = maybe_def {\n+            let def_id = def.def_id();\n+            fn_warned = check_must_use(cx, def_id, s.span, \"return value of \");\n+        }\n+        let must_use_op = match expr.node {\n+            // Hardcoding operators here seemed more expedient than the\n+            // refactoring that would be needed to look up the `#[must_use]`\n+            // attribute which does exist on the comparison trait methods\n+            hir::ExprBinary(bin_op, ..)  => {\n                 match bin_op.node {\n-                    // Hardcoding the comparison operators here seemed more\n-                    // expedient than the refactoring that would be needed to\n-                    // look up the `#[must_use]` attribute which does exist on\n-                    // the comparison trait methods\n                     hir::BiEq | hir::BiLt | hir::BiLe | hir::BiNe | hir::BiGe | hir::BiGt => {\n-                        let msg = \"unused comparison which must be used\";\n-                        cx.span_lint(UNUSED_MUST_USE, expr.span, msg);\n-                        op_warned = true;\n+                        Some(\"comparison\")\n+                    },\n+                    hir::BiAdd | hir::BiSub | hir::BiDiv | hir::BiMul | hir::BiRem => {\n+                        Some(\"arithmetic operation\")\n+                    },\n+                    hir::BiAnd | hir::BiOr => {\n+                        Some(\"logical operation\")\n+                    },\n+                    hir::BiBitXor | hir::BiBitAnd | hir::BiBitOr | hir::BiShl | hir::BiShr => {\n+                        Some(\"bitwise operation\")\n                     },\n-                    _ => {},\n                 }\n-            }\n+            },\n+            hir::ExprUnary(..) => Some(\"unary operation\"),\n+            _ => None\n+        };\n+\n+        if let Some(must_use_op) = must_use_op {\n+            cx.span_lint(UNUSED_MUST_USE, expr.span,\n+                         &format!(\"unused {} which must be used\", must_use_op));\n+            op_warned = true;\n         }\n \n         if !(ty_warned || fn_warned || op_warned) {\n@@ -174,8 +192,6 @@ impl LintPass for UnusedAttributes {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n     fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n         debug!(\"checking attribute: {:?}\", attr);\n-        let name = unwrap_or!(attr.name(), return);\n-\n         // Note that check_name() marks the attribute as used if it matches.\n         for &(ref name, ty, _) in BUILTIN_ATTRIBUTES {\n             match ty {\n@@ -195,6 +211,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n             }\n         }\n \n+        let name = attr.name();\n         if !attr::is_used(attr) {\n             debug!(\"Emitting warning for: {:?}\", attr);\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");"}, {"sha": "fdfe2a98bf9b935a259eaa1e6dcde776a8ff6d7d", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -51,7 +51,7 @@ macro_rules! provide {\n         pub fn provide_extern<$lt>(providers: &mut Providers<$lt>) {\n             $(fn $name<'a, $lt:$lt, T>($tcx: TyCtxt<'a, $lt, $lt>, def_id_arg: T)\n                                     -> <ty::queries::$name<$lt> as\n-                                        QueryConfig>::Value\n+                                        QueryConfig<$lt>>::Value\n                 where T: IntoArgs,\n             {\n                 #[allow(unused_variables)]\n@@ -535,7 +535,7 @@ impl CrateStore for cstore::CStore {\n             .insert(local_span, (name.to_string(), data.get_span(id.index, sess)));\n \n         LoadedMacro::MacroDef(ast::Item {\n-            ident: ast::Ident::from_str(&name),\n+            ident: ast::Ident::from_str(&name.as_str()),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             attrs: attrs.iter().cloned().collect(),"}, {"sha": "57f92707ccfe332060a7ed943a7b9d4fa713f70b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -40,7 +40,7 @@ use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, Ident};\n use syntax::codemap;\n-use syntax::symbol::{InternedString, Symbol};\n+use syntax::symbol::InternedString;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n \n@@ -537,12 +537,12 @@ impl<'a, 'tcx> CrateMetadata {\n \n         ty::VariantDef {\n             did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n-            name: Symbol::intern(&self.item_name(index)),\n+            name: self.item_name(index).as_symbol(),\n             fields: item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n                 ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    name: Symbol::intern(&self.item_name(index)),\n+                    name: self.item_name(index).as_symbol(),\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n@@ -730,7 +730,7 @@ impl<'a, 'tcx> CrateMetadata {\n                             if let Some(def) = self.get_def(child_index) {\n                                 callback(def::Export {\n                                     def,\n-                                    ident: Ident::from_str(&self.item_name(child_index)),\n+                                    ident: Ident::from_interned_str(self.item_name(child_index)),\n                                     vis: self.get_visibility(child_index),\n                                     span: self.entry(child_index).span.decode((self, sess)),\n                                     is_import: false,\n@@ -748,7 +748,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 let span = child.span.decode((self, sess));\n                 if let (Some(def), Some(name)) =\n                     (self.get_def(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n-                    let ident = Ident::from_str(&name);\n+                    let ident = Ident::from_interned_str(name);\n                     let vis = self.get_visibility(child_index);\n                     let is_import = false;\n                     callback(def::Export { def, ident, vis, span, is_import });\n@@ -847,7 +847,7 @@ impl<'a, 'tcx> CrateMetadata {\n         };\n \n         ty::AssociatedItem {\n-            name: Symbol::intern(&name),\n+            name: name.as_symbol(),\n             kind,\n             vis: item.visibility.decode(self),\n             defaultness: container.defaultness(),\n@@ -914,7 +914,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(id)\n             .children\n             .decode(self)\n-            .map(|index| Symbol::intern(&self.item_name(index)))\n+            .map(|index| self.item_name(index).as_symbol())\n             .collect()\n     }\n \n@@ -977,7 +977,13 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n-        self.def_key(id).parent.and_then(|parent_index| {\n+        let def_key = self.def_key(id);\n+        match def_key.disambiguated_data.data {\n+            DefPathData::TypeNs(..) | DefPathData::ValueNs(..) => (),\n+            // Not an associated item\n+            _ => return None,\n+        }\n+        def_key.parent.and_then(|parent_index| {\n             match self.entry(parent_index).kind {\n                 EntryKind::Trait(_) => Some(self.local_def_id(parent_index)),\n                 _ => None,\n@@ -1106,7 +1112,7 @@ impl<'a, 'tcx> CrateMetadata {\n             DefKey {\n                 parent: Some(CRATE_DEF_INDEX),\n                 disambiguated_data: DisambiguatedDefPathData {\n-                    data: DefPathData::MacroDef(name.as_str()),\n+                    data: DefPathData::MacroDef(name.as_interned_str()),\n                     disambiguator: 0,\n                 }\n             }"}, {"sha": "62964745b6f9eb49ff8c8730a4375dd4dd1b255a", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -16,7 +16,6 @@ log = \"0.4\"\n log_settings = \"0.1.1\"\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n-rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "db2e078586eda95f346bd4eb11b6227821d44366", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -471,7 +471,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             | (RegionKind::ReClosureBound(_), _)\n             | (RegionKind::ReCanonical(_), _)\n             | (RegionKind::ReErased, _) => {\n-                span_bug!(drop_span, \"region does not make sense in this context\");\n+                span_bug!(drop_span, \"region {:?} does not make sense in this context\",\n+                          borrow.region);\n             }\n         }\n     }"}, {"sha": "28da1b2d733577c114a1c61d2c745a74a1a6aa79", "filename": "src/librustc_mir/borrow_check/location.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,123 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::mir::{BasicBlock, Location, Mir};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+\n+/// Maps between a MIR Location, which identifies the a particular\n+/// statement within a basic block, to a \"rich location\", which\n+/// identifies at a finer granularity. In particular, we distinguish\n+/// the *start* of a statement and the *mid-point*. The mid-point is\n+/// the point *just* before the statement takes effect; in particular,\n+/// for an assignment `A = B`, it is the point where B is about to be\n+/// written into A. This mid-point is a kind of hack to work around\n+/// our inability to track the position information at sufficient\n+/// granularity through outlives relations; however, the rich location\n+/// table serves another purpose: it compresses locations from\n+/// multiple words into a single u32.\n+crate struct LocationTable {\n+    num_points: usize,\n+    statements_before_block: IndexVec<BasicBlock, usize>,\n+}\n+\n+newtype_index!(LocationIndex { DEBUG_FORMAT = \"LocationIndex({})\" });\n+\n+#[derive(Copy, Clone, Debug)]\n+crate enum RichLocation {\n+    Start(Location),\n+    Mid(Location),\n+}\n+\n+impl LocationTable {\n+    crate fn new(mir: &Mir<'_>) -> Self {\n+        let mut num_points = 0;\n+        let statements_before_block = mir.basic_blocks()\n+            .iter()\n+            .map(|block_data| {\n+                let v = num_points;\n+                num_points += (block_data.statements.len() + 1) * 2;\n+                v\n+            })\n+            .collect();\n+\n+        debug!(\n+            \"LocationTable(statements_before_block={:#?})\",\n+            statements_before_block\n+        );\n+        debug!(\"LocationTable: num_points={:#?}\", num_points);\n+\n+        Self {\n+            num_points,\n+            statements_before_block,\n+        }\n+    }\n+\n+    crate fn all_points(&self) -> impl Iterator<Item = LocationIndex> {\n+        (0..self.num_points).map(LocationIndex::new)\n+    }\n+\n+    crate fn start_index(&self, location: Location) -> LocationIndex {\n+        let Location {\n+            block,\n+            statement_index,\n+        } = location;\n+        let start_index = self.statements_before_block[block];\n+        LocationIndex::new(start_index + statement_index * 2)\n+    }\n+\n+    crate fn mid_index(&self, location: Location) -> LocationIndex {\n+        let Location {\n+            block,\n+            statement_index,\n+        } = location;\n+        let start_index = self.statements_before_block[block];\n+        LocationIndex::new(start_index + statement_index * 2 + 1)\n+    }\n+\n+    crate fn to_location(&self, index: LocationIndex) -> RichLocation {\n+        let point_index = index.index();\n+\n+        // Find the basic block. We have a vector with the\n+        // starting index of the statement in each block. Imagine\n+        // we have statement #22, and we have a vector like:\n+        //\n+        // [0, 10, 20]\n+        //\n+        // In that case, this represents point_index 2 of\n+        // basic block BB2. We know this because BB0 accounts for\n+        // 0..10, BB1 accounts for 11..20, and BB2 accounts for\n+        // 20...\n+        //\n+        // To compute this, we could do a binary search, but\n+        // because I am lazy we instead iterate through to find\n+        // the last point where the \"first index\" (0, 10, or 20)\n+        // was less than the statement index (22). In our case, this will\n+        // be (BB2, 20).\n+        let (block, &first_index) = self.statements_before_block\n+            .iter_enumerated()\n+            .filter(|(_, first_index)| **first_index <= point_index)\n+            .last()\n+            .unwrap();\n+\n+        let statement_index = (point_index - first_index) / 2;\n+        if index.is_start() {\n+            RichLocation::Start(Location { block, statement_index })\n+        } else {\n+            RichLocation::Mid(Location { block, statement_index })\n+        }\n+    }\n+}\n+\n+impl LocationIndex {\n+    fn is_start(&self) -> bool {\n+        // even indices are start points; odd indices are mid points\n+        (self.index() % 2) == 0\n+    }\n+}"}, {"sha": "3e3f510e308c330b82fbd16e524aa2e033c2ce2a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 320, "deletions": 119, "changes": 439, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -17,15 +17,17 @@ use rustc::hir::map::definitions::DefPathData;\n use rustc::infer::InferCtxt;\n use rustc::ty::{self, ParamEnv, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Place};\n-use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n-use rustc::mir::{Field, Statement, StatementKind, Terminator, TerminatorKind};\n-use rustc::mir::ClosureRegionRequirements;\n+use rustc::lint::builtin::UNUSED_MUT;\n+use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n+use rustc::mir::{ClearCrossCrate, Local, Location, Place, Mir, Mutability, Operand};\n+use rustc::mir::{Projection, ProjectionElem, Rvalue, Field, Statement, StatementKind};\n+use rustc::mir::{Terminator, TerminatorKind};\n \n use rustc_data_structures::control_flow_graph::dominators::Dominators;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::small_vec::SmallVec;\n \n use std::rc::Rc;\n \n@@ -48,12 +50,14 @@ use std::iter;\n \n use self::borrow_set::{BorrowSet, BorrowData};\n use self::flows::Flows;\n+use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n use self::MutateMode::{JustWrite, WriteAndRead};\n \n crate mod borrow_set;\n mod error_reporting;\n mod flows;\n+mod location;\n crate mod place_ext;\n mod prefixes;\n \n@@ -69,12 +73,15 @@ pub fn provide(providers: &mut Providers) {\n fn mir_borrowck<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-) -> Option<ClosureRegionRequirements<'tcx>> {\n+) -> BorrowCheckResult<'tcx> {\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n \n     if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.use_mir_borrowck() {\n-        return None;\n+        return BorrowCheckResult {\n+            closure_requirements: None,\n+            used_mut_upvars: SmallVec::new(),\n+        };\n     }\n \n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n@@ -90,7 +97,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     input_mir: &Mir<'gcx>,\n     def_id: DefId,\n-) -> Option<ClosureRegionRequirements<'gcx>> {\n+) -> BorrowCheckResult<'gcx> {\n     let tcx = infcx.tcx;\n     let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);\n@@ -105,6 +112,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let mut mir: Mir<'tcx> = input_mir.clone();\n     let free_regions = nll::replace_regions_in_mir(infcx, def_id, param_env, &mut mir);\n     let mir = &mir; // no further changes\n+    let location_table = &LocationTable::new(mir);\n \n     let move_data: MoveData<'tcx> = match MoveData::gather_moves(mir, tcx) {\n         Ok(move_data) => move_data,\n@@ -194,6 +202,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         def_id,\n         free_regions,\n         mir,\n+        location_table,\n         param_env,\n         &mut flow_inits,\n         &mdpe.move_data,\n@@ -237,6 +246,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         reservation_error_reported: FxHashSet(),\n         moved_error_reported: FxHashSet(),\n         nonlexical_regioncx: regioncx,\n+        used_mut: FxHashSet(),\n+        used_mut_upvars: SmallVec::new(),\n         nonlexical_cause_info: None,\n         borrow_set,\n         dominators,\n@@ -252,7 +263,66 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n \n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n \n-    opt_closure_req\n+    // For each non-user used mutable variable, check if it's been assigned from\n+    // a user-declared local. If so, then put that local into the used_mut set.\n+    // Note that this set is expected to be small - only upvars from closures\n+    // would have a chance of erroneously adding non-user-defined mutable vars\n+    // to the set.\n+    let temporary_used_locals: FxHashSet<Local> =\n+        mbcx.used_mut.iter()\n+            .filter(|&local| !mbcx.mir.local_decls[*local].is_user_variable)\n+            .cloned()\n+            .collect();\n+\n+    for local in temporary_used_locals {\n+        for location in mbcx.mir.find_assignments(local) {\n+            for moi in &mbcx.move_data.loc_map[location] {\n+                let mpi = &mbcx.move_data.moves[*moi].path;\n+                let path = &mbcx.move_data.move_paths[*mpi];\n+                debug!(\"assignment of {:?} to {:?}, adding {:?} to used mutable set\",\n+                       path.place, local, path.place);\n+                if let Place::Local(user_local) = path.place {\n+                    mbcx.used_mut.insert(user_local);\n+                }\n+            }\n+        }\n+    }\n+\n+    debug!(\"mbcx.used_mut: {:?}\", mbcx.used_mut);\n+\n+    for local in mbcx.mir.mut_vars_and_args_iter().filter(|local| !mbcx.used_mut.contains(local)) {\n+        if let ClearCrossCrate::Set(ref vsi) = mbcx.mir.visibility_scope_info {\n+            let local_decl = &mbcx.mir.local_decls[local];\n+\n+            // Skip implicit `self` argument for closures\n+            if local.index() == 1 && tcx.is_closure(mbcx.mir_def_id) {\n+                continue;\n+            }\n+\n+            // Skip over locals that begin with an underscore or have no name\n+            match local_decl.name {\n+                Some(name) => if name.as_str().starts_with(\"_\") { continue; },\n+                None => continue,\n+            }\n+\n+            let source_info = local_decl.source_info;\n+            let mut_span = tcx.sess.codemap().span_until_non_whitespace(source_info.span);\n+\n+            tcx.struct_span_lint_node(\n+                UNUSED_MUT,\n+                vsi[local_decl.syntactic_scope].lint_root,\n+                source_info.span,\n+                \"variable does not need to be mutable\"\n+            )\n+            .span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned())\n+            .emit();\n+        }\n+    }\n+\n+    BorrowCheckResult {\n+        closure_requirements: opt_closure_req,\n+        used_mut_upvars: mbcx.used_mut_upvars,\n+    }\n }\n \n #[allow(dead_code)]\n@@ -287,6 +357,12 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// This field keeps track of errors reported in the checking of moved variables,\n     /// so that we don't report report seemingly duplicate errors.\n     moved_error_reported: FxHashSet<Place<'tcx>>,\n+    /// This field keeps track of all the local variables that are declared mut and are mutated.\n+    /// Used for the warning issued by an unused mutable local variable.\n+    used_mut: FxHashSet<Local>,\n+    /// If the function we're checking is a closure, then we'll need to report back the list of\n+    /// mutable upvars that have been used. This field keeps track of them.\n+    used_mut_upvars: SmallVec<[Field; 8]>,\n     /// Non-lexical region inference context, if NLL is enabled.  This\n     /// contains the results from region inference and lets us e.g.\n     /// find out which CFG points are contained in each borrow region.\n@@ -514,18 +590,14 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 cleanup: _,\n             } => {\n                 self.consume_operand(ContextKind::Assert.new(loc), (cond, span), flow_state);\n-                match *msg {\n-                    AssertMessage::BoundsCheck { ref len, ref index } => {\n-                        self.consume_operand(ContextKind::Assert.new(loc), (len, span), flow_state);\n-                        self.consume_operand(\n-                            ContextKind::Assert.new(loc),\n-                            (index, span),\n-                            flow_state,\n-                        );\n-                    }\n-                    AssertMessage::Math(_ /*const_math_err*/) => {}\n-                    AssertMessage::GeneratorResumedAfterReturn => {}\n-                    AssertMessage::GeneratorResumedAfterPanic => {}\n+                use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n+                if let BoundsCheck { ref len, ref index } = *msg {\n+                    self.consume_operand(ContextKind::Assert.new(loc), (len, span), flow_state);\n+                    self.consume_operand(\n+                        ContextKind::Assert.new(loc),\n+                        (index, span),\n+                        flow_state,\n+                    );\n                 }\n             }\n \n@@ -684,6 +756,11 @@ enum InitializationRequiringAction {\n     Assignment,\n }\n \n+struct RootPlace<'d, 'tcx: 'd> {\n+    place: &'d Place<'tcx>,\n+    is_local_mutation_allowed: LocalMutationIsAllowed,\n+}\n+\n impl InitializationRequiringAction {\n     fn as_noun(self) -> &'static str {\n         match self {\n@@ -729,6 +806,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         erased_drop_place_ty: ty::Ty<'gcx>,\n         span: Span,\n     ) {\n+        let gcx = self.tcx.global_tcx();\n+        let drop_field = |\n+            mir: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n+            (index, field): (usize, ty::Ty<'gcx>),\n+        | {\n+            let field_ty = gcx.normalize_erasing_regions(mir.param_env, field);\n+            let place = drop_place.clone().field(Field::new(index), field_ty);\n+\n+            mir.visit_terminator_drop(loc, term, flow_state, &place, field_ty, span);\n+        };\n+\n         match erased_drop_place_ty.sty {\n             // When a struct is being dropped, we need to check\n             // whether it has a destructor, if it does, then we can\n@@ -737,22 +825,31 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             // destructor but `bar` does not, we will only check for\n             // borrows of `x.foo` and not `x.bar`. See #47703.\n             ty::TyAdt(def, substs) if def.is_struct() && !def.has_dtor(self.tcx) => {\n-                for (index, field) in def.all_fields().enumerate() {\n-                    let gcx = self.tcx.global_tcx();\n-                    let field_ty = field.ty(gcx, substs);\n-                    let field_ty = gcx.normalize_erasing_regions(self.param_env, field_ty);\n-                    let place = drop_place.clone().field(Field::new(index), field_ty);\n-\n-                    self.visit_terminator_drop(loc, term, flow_state, &place, field_ty, span);\n-                }\n+                def.all_fields()\n+                    .map(|field| field.ty(gcx, substs))\n+                    .enumerate()\n+                    .for_each(|field| drop_field(self, field));\n+            }\n+            // Same as above, but for tuples.\n+            ty::TyTuple(tys) => {\n+                tys.iter().cloned().enumerate()\n+                    .for_each(|field| drop_field(self, field));\n+            }\n+            // Closures and generators also have disjoint fields, but they are only\n+            // directly accessed in the body of the closure/generator.\n+            ty::TyClosure(def, substs)\n+            | ty::TyGenerator(def, substs, ..)\n+                if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n+            => {\n+                substs.upvar_tys(def, self.tcx).enumerate()\n+                    .for_each(|field| drop_field(self, field));\n             }\n             _ => {\n                 // We have now refined the type of the value being\n                 // dropped (potentially) to just the type of a\n                 // subfield; so check whether that field's type still\n                 // \"needs drop\". If so, we assume that the destructor\n                 // may access any data it likes (i.e., a Deep Write).\n-                let gcx = self.tcx.global_tcx();\n                 if erased_drop_place_ty.needs_drop(gcx, self.param_env) {\n                     self.access_place(\n                         ContextKind::Drop.new(loc),\n@@ -810,7 +907,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         let mutability_error =\n-            self.check_access_permissions(place_span, rw, is_local_mutation_allowed);\n+            self.check_access_permissions(place_span, rw, is_local_mutation_allowed, flow_state);\n         let conflict_error =\n             self.check_access_for_conflict(context, place_span, sd, rw, flow_state);\n \n@@ -1077,9 +1174,34 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // `NullOp::Box`?\n             }\n \n-            Rvalue::Aggregate(ref _aggregate_kind, ref operands) => for operand in operands {\n-                self.consume_operand(context, (operand, span), flow_state);\n-            },\n+            Rvalue::Aggregate(ref aggregate_kind, ref operands) => {\n+                // We need to report back the list of mutable upvars that were\n+                // moved into the closure and subsequently used by the closure,\n+                // in order to populate our used_mut set.\n+                if let AggregateKind::Closure(def_id, _) = &**aggregate_kind {\n+                    let BorrowCheckResult { used_mut_upvars, .. } = self.tcx.mir_borrowck(*def_id);\n+                    debug!(\"{:?} used_mut_upvars={:?}\", def_id, used_mut_upvars);\n+                    for field in used_mut_upvars {\n+                        match operands[field.index()] {\n+                            Operand::Move(Place::Local(local)) => {\n+                                self.used_mut.insert(local);\n+                            }\n+                            Operand::Move(ref place @ Place::Projection(_)) => {\n+                                if let Some(field) = self.is_upvar_field_projection(place) {\n+                                    self.used_mut_upvars.push(field);\n+                                }\n+                            }\n+                            Operand::Move(Place::Static(..)) |\n+                            Operand::Copy(..) |\n+                            Operand::Constant(..) => {}\n+                        }\n+                    }\n+                }\n+\n+                for operand in operands {\n+                    self.consume_operand(context, (operand, span), flow_state);\n+                }\n+            }\n         }\n     }\n \n@@ -1280,7 +1402,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) {\n         debug!(\"check_if_reassignment_to_immutable_state({:?})\", place);\n         // determine if this path has a non-mut owner (and thus needs checking).\n-        if let Ok(()) = self.is_mutable(place, LocalMutationIsAllowed::No) {\n+        if let Ok(..) = self.is_mutable(place, LocalMutationIsAllowed::No) {\n             return;\n         }\n         debug!(\n@@ -1574,10 +1696,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ///\n     /// Returns true if an error is reported, false otherwise.\n     fn check_access_permissions(\n-        &self,\n+        &mut self,\n         (place, span): (&Place<'tcx>, Span),\n         kind: ReadOrWrite,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) -> bool {\n         debug!(\n             \"check_access_permissions({:?}, {:?}, {:?})\",\n@@ -1592,90 +1715,93 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n             }\n             Reservation(WriteKind::MutableBorrow(BorrowKind::Mut { .. }))\n-            | Write(WriteKind::MutableBorrow(BorrowKind::Mut { .. })) => if let Err(place_err) =\n-                self.is_mutable(place, is_local_mutation_allowed)\n-            {\n-                error_reported = true;\n-                let item_msg = self.get_default_err_msg(place);\n-                let mut err = self.tcx\n-                    .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n-                err.span_label(span, \"cannot borrow as mutable\");\n-\n-                if place != place_err {\n-                    if let Some(name) = self.describe_place(place_err) {\n-                        err.note(&format!(\"the value which is causing this path not to be mutable \\\n-                                           is...: `{}`\", name));\n-                    }\n-                }\n-\n-                err.emit();\n-            },\n-            Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {\n-\n-                if let Err(place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n-                    error_reported = true;\n-                    let mut err_info = None;\n-                    match *place_err {\n-\n-                        Place::Projection(box Projection {\n-                        ref base, elem:ProjectionElem::Deref}) => {\n-                            match *base {\n-                                Place::Local(local) => {\n-                                    let locations = self.mir.find_assignments(local);\n-                                        if locations.len() > 0 {\n-                                            let item_msg = if error_reported {\n-                                                self.get_secondary_err_msg(base)\n-                                            } else {\n-                                                self.get_default_err_msg(place)\n-                                            };\n-                                            let sp = self.mir.source_info(locations[0]).span;\n-                                            let mut to_suggest_span = String::new();\n-                                            if let Ok(src) =\n-                                                self.tcx.sess.codemap().span_to_snippet(sp) {\n-                                                    to_suggest_span = src[1..].to_string();\n-                                            };\n-                                            err_info = Some((\n-                                                    sp,\n-                                                    \"consider changing this to be a \\\n-                                                    mutable reference\",\n-                                                    to_suggest_span,\n-                                                    item_msg,\n-                                                    self.get_primary_err_msg(base)));\n-                                        }\n-                                },\n-                            _ => {},\n-                            }\n-                        },\n-                        _ => {},\n-                    }\n+            | Write(WriteKind::MutableBorrow(BorrowKind::Mut { .. })) => {\n+                match self.is_mutable(place, is_local_mutation_allowed) {\n+                    Ok(root_place) => self.add_used_mut(root_place, flow_state),\n+                    Err(place_err) => {\n+                        error_reported = true;\n+                        let item_msg = self.get_default_err_msg(place);\n+                        let mut err = self.tcx\n+                            .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n+                        err.span_label(span, \"cannot borrow as mutable\");\n \n-                    if let Some((err_help_span,\n-                                 err_help_stmt,\n-                                 to_suggest_span,\n-                                 item_msg,\n-                                 sec_span)) = err_info {\n-                        let mut err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n-                        err.span_suggestion(err_help_span,\n-                                            err_help_stmt,\n-                                            format!(\"&mut {}\", to_suggest_span));\n-                        if place != place_err {\n-                            err.span_label(span, sec_span);\n-                        }\n-                        err.emit()\n-                    } else {\n-                        let item_msg_ = self.get_default_err_msg(place);\n-                        let mut err = self.tcx.cannot_assign(span, &item_msg_, Origin::Mir);\n-                        err.span_label(span, \"cannot mutate\");\n                         if place != place_err {\n                             if let Some(name) = self.describe_place(place_err) {\n                                 err.note(&format!(\"the value which is causing this path not to be \\\n-                                                   mutable is...: `{}`\", name));\n+                                    mutable is...: `{}`\", name));\n                             }\n                         }\n+\n                         err.emit();\n                     }\n                 }\n             }\n+            Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {\n+                match self.is_mutable(place, is_local_mutation_allowed) {\n+                    Ok(root_place) => self.add_used_mut(root_place, flow_state),\n+                    Err(place_err) => {\n+                        error_reported = true;\n+\n+                        let err_info = if let Place::Projection(\n+                            box Projection {\n+                                base: Place::Local(local),\n+                                elem: ProjectionElem::Deref\n+                            }\n+                        ) = *place_err {\n+                            let locations = self.mir.find_assignments(local);\n+                            if locations.len() > 0 {\n+                                let item_msg = if error_reported {\n+                                    self.get_secondary_err_msg(&Place::Local(local))\n+                                } else {\n+                                    self.get_default_err_msg(place)\n+                                };\n+                                let sp = self.mir.source_info(locations[0]).span;\n+                                let mut to_suggest_span = String::new();\n+                                if let Ok(src) =\n+                                    self.tcx.sess.codemap().span_to_snippet(sp) {\n+                                        to_suggest_span = src[1..].to_string();\n+                                };\n+                                Some((sp,\n+                                      \"consider changing this to be a \\\n+                                      mutable reference\",\n+                                      to_suggest_span,\n+                                      item_msg,\n+                                      self.get_primary_err_msg(&Place::Local(local))))\n+                            } else {\n+                                None\n+                            }\n+                        } else {\n+                            None\n+                        };\n+\n+                        if let Some((err_help_span,\n+                                     err_help_stmt,\n+                                     to_suggest_span,\n+                                     item_msg,\n+                                     sec_span)) = err_info {\n+                            let mut err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n+                            err.span_suggestion(err_help_span,\n+                                                err_help_stmt,\n+                                                format!(\"&mut {}\", to_suggest_span));\n+                            if place != place_err {\n+                                err.span_label(span, sec_span);\n+                            }\n+                            err.emit()\n+                        } else {\n+                            let item_msg = self.get_default_err_msg(place);\n+                            let mut err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n+                            err.span_label(span, \"cannot mutate\");\n+                            if place != place_err {\n+                                if let Some(name) = self.describe_place(place_err) {\n+                                    err.note(&format!(\"the value which is causing this path not \\\n+                                                       to be mutable is...: `{}`\", name));\n+                                }\n+                            }\n+                            err.emit();\n+                        }\n+                    }\n+                }\n+            }\n             Reservation(WriteKind::Move)\n             | Reservation(WriteKind::StorageDeadOrDrop)\n             | Reservation(WriteKind::MutableBorrow(BorrowKind::Shared))\n@@ -1702,30 +1828,76 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         error_reported\n     }\n \n-    /// Can this value be written or borrowed mutably\n+    /// Adds the place into the used mutable variables set\n+    fn add_used_mut<'d>(\n+        &mut self,\n+        root_place: RootPlace<'d, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>\n+    ) {\n+        match root_place {\n+            RootPlace {\n+                place: Place::Local(local),\n+                is_local_mutation_allowed,\n+            } => {\n+                if is_local_mutation_allowed != LocalMutationIsAllowed::Yes {\n+                    // If the local may be initialized, and it is now currently being\n+                    // mutated, then it is justified to be annotated with the `mut`\n+                    // keyword, since the mutation may be a possible reassignment.\n+                    let mpi = self.move_data.rev_lookup.find_local(*local);\n+                    if flow_state.inits.contains(&mpi) {\n+                        self.used_mut.insert(*local);\n+                    }\n+                }\n+            }\n+            RootPlace {\n+                place: place @ Place::Projection(_),\n+                is_local_mutation_allowed: _,\n+            } => {\n+                if let Some(field) = self.is_upvar_field_projection(&place) {\n+                    self.used_mut_upvars.push(field);\n+                }\n+            }\n+            RootPlace {\n+                place: Place::Static(..),\n+                is_local_mutation_allowed: _,\n+            } => {}\n+        }\n+    }\n+\n+    /// Whether this value be written or borrowed mutably.\n+    /// Returns the root place if the place passed in is a projection.\n     fn is_mutable<'d>(\n         &self,\n         place: &'d Place<'tcx>,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n-    ) -> Result<(), &'d Place<'tcx>> {\n+    ) -> Result<RootPlace<'d, 'tcx>, &'d Place<'tcx>> {\n         match *place {\n             Place::Local(local) => {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n-                        LocalMutationIsAllowed::Yes | LocalMutationIsAllowed::ExceptUpvars => {\n-                            Ok(())\n+                        LocalMutationIsAllowed::Yes => {\n+                            Ok(RootPlace {\n+                                place,\n+                                is_local_mutation_allowed: LocalMutationIsAllowed::Yes\n+                            })\n+                        }\n+                        LocalMutationIsAllowed::ExceptUpvars => {\n+                            Ok(RootPlace {\n+                                place,\n+                                is_local_mutation_allowed: LocalMutationIsAllowed::ExceptUpvars\n+                            })\n                         }\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n-                    Mutability::Mut => Ok(()),\n+                    Mutability::Mut => Ok(RootPlace { place, is_local_mutation_allowed }),\n                 }\n             }\n             Place::Static(ref static_) =>\n                 if self.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n                     Err(place)\n                 } else {\n-                    Ok(())\n+                    Ok(RootPlace { place, is_local_mutation_allowed })\n                 },\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n@@ -1761,9 +1933,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n                                     hir::MutImmutable => return Err(place),\n-                                    // `*mut` raw pointers are always mutable, regardless of context\n-                                    // The users have to check by themselve.\n-                                    hir::MutMutable => return Ok(()),\n+                                    // `*mut` raw pointers are always mutable, regardless of\n+                                    // context. The users have to check by themselves.\n+                                    hir::MutMutable => {\n+                                        return Ok(RootPlace { place, is_local_mutation_allowed });\n+                                    }\n                                 }\n                             }\n                             // `Box<T>` owns its content, so mutable if its location is mutable\n@@ -1794,7 +1968,34 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 }\n                                 (Mutability::Not, LocalMutationIsAllowed::Yes)\n                                 | (Mutability::Mut, _) => {\n-                                    self.is_mutable(&proj.base, is_local_mutation_allowed)\n+                                    // Subtle: this is an upvar\n+                                    // reference, so it looks like\n+                                    // `self.foo` -- we want to double\n+                                    // check that the context `*self`\n+                                    // is mutable (i.e., this is not a\n+                                    // `Fn` closure).  But if that\n+                                    // check succeeds, we want to\n+                                    // *blame* the mutability on\n+                                    // `place` (that is,\n+                                    // `self.foo`). This is used to\n+                                    // propagate the info about\n+                                    // whether mutability declarations\n+                                    // are used outwards, so that we register\n+                                    // the outer variable as mutable. Otherwise a\n+                                    // test like this fails to record the `mut`\n+                                    // as needed:\n+                                    //\n+                                    // ```\n+                                    // fn foo<F: FnOnce()>(_f: F) { }\n+                                    // fn main() {\n+                                    //     let var = Vec::new();\n+                                    //     foo(move || {\n+                                    //         var.push(1);\n+                                    //     });\n+                                    // }\n+                                    // ```\n+                                    let _ = self.is_mutable(&proj.base, is_local_mutation_allowed)?;\n+                                    Ok(RootPlace { place, is_local_mutation_allowed })\n                                 }\n                             }\n                         } else {"}, {"sha": "d34e9434fbf2a0352a5cc4ec36b796f5cf1436f0", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 151, "deletions": 36, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -8,28 +8,37 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::borrow_set::BorrowSet;\n+use borrow_check::location::LocationTable;\n+use borrow_check::nll::facts::AllFacts;\n use rustc::hir;\n-use rustc::mir::{BasicBlock, BasicBlockData, Location, Place, Mir, Rvalue};\n+use rustc::infer::InferCtxt;\n+use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::Place::Projection;\n-use rustc::mir::{Local, PlaceProjection, ProjectionElem};\n-use rustc::mir::visit::TyContext;\n-use rustc::infer::InferCtxt;\n-use rustc::ty::{self, CanonicalTy, ClosureSubsts};\n-use rustc::ty::subst::Substs;\n+use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n+use rustc::mir::{Local, PlaceProjection, ProjectionElem, Statement, Terminator};\n use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::subst::Substs;\n+use rustc::ty::{self, CanonicalTy, ClosureSubsts};\n \n+use super::region_infer::{Cause, RegionInferenceContext};\n use super::ToRegionVid;\n-use super::region_infer::{RegionInferenceContext, Cause};\n \n pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     regioncx: &mut RegionInferenceContext<'tcx>,\n+    all_facts: &mut Option<AllFacts>,\n+    location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n+    borrow_set: &BorrowSet<'tcx>,\n ) {\n     let mut cg = ConstraintGeneration {\n+        borrow_set,\n         infcx,\n         regioncx,\n+        location_table,\n+        all_facts,\n         mir,\n     };\n \n@@ -41,8 +50,11 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n /// 'cg = the duration of the constraint generation process itself.\n struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: &'cg InferCtxt<'cx, 'gcx, 'tcx>,\n+    all_facts: &'cg mut Option<AllFacts>,\n+    location_table: &'cg LocationTable,\n     regioncx: &'cg mut RegionInferenceContext<'tcx>,\n     mir: &'cg Mir<'tcx>,\n+    borrow_set: &'cg BorrowSet<'tcx>,\n }\n \n impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx, 'tcx> {\n@@ -68,12 +80,14 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n     /// call. Make them live at the location where they appear.\n     fn visit_ty(&mut self, ty: &ty::Ty<'tcx>, ty_context: TyContext) {\n         match ty_context {\n-            TyContext::ReturnTy(source_info) |\n-            TyContext::YieldTy(source_info) |\n-            TyContext::LocalDecl { source_info, .. } => {\n-                span_bug!(source_info.span,\n-                          \"should not be visiting outside of the CFG: {:?}\",\n-                          ty_context);\n+            TyContext::ReturnTy(source_info)\n+            | TyContext::YieldTy(source_info)\n+            | TyContext::LocalDecl { source_info, .. } => {\n+                span_bug!(\n+                    source_info.span,\n+                    \"should not be visiting outside of the CFG: {:?}\",\n+                    ty_context\n+                );\n             }\n             TyContext::Location(location) => {\n                 self.add_regular_live_constraint(*ty, location, Cause::LiveOther(location));\n@@ -90,25 +104,117 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         self.super_closure_substs(substs);\n     }\n \n+    fn visit_statement(\n+        &mut self,\n+        block: BasicBlock,\n+        statement: &Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        if let Some(all_facts) = self.all_facts {\n+            all_facts.cfg_edge.push((\n+                self.location_table.start_index(location),\n+                self.location_table.mid_index(location),\n+            ));\n+\n+            all_facts.cfg_edge.push((\n+                self.location_table.mid_index(location),\n+                self.location_table\n+                    .start_index(location.successor_within_block()),\n+            ));\n+        }\n+\n+        self.super_statement(block, statement, location);\n+    }\n+\n+    fn visit_assign(\n+        &mut self,\n+        block: BasicBlock,\n+        place: &Place<'tcx>,\n+        rvalue: &Rvalue<'tcx>,\n+        location: Location,\n+    ) {\n+        // When we see `X = ...`, then kill borrows of\n+        // `(*X).foo` and so forth.\n+        if let Some(all_facts) = self.all_facts {\n+            if let Place::Local(temp) = place {\n+                if let Some(borrow_indices) = self.borrow_set.local_map.get(temp) {\n+                    for &borrow_index in borrow_indices {\n+                        let location_index = self.location_table.mid_index(location);\n+                        all_facts.killed.push((borrow_index, location_index));\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.super_assign(block, place, rvalue, location);\n+    }\n+\n+    fn visit_terminator(\n+        &mut self,\n+        block: BasicBlock,\n+        terminator: &Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        if let Some(all_facts) = self.all_facts {\n+            all_facts.cfg_edge.push((\n+                self.location_table.start_index(location),\n+                self.location_table.mid_index(location),\n+            ));\n+\n+            for successor_block in terminator.successors() {\n+                all_facts.cfg_edge.push((\n+                    self.location_table.mid_index(location),\n+                    self.location_table\n+                        .start_index(successor_block.start_location()),\n+                ));\n+            }\n+        }\n+\n+        self.super_terminator(block, terminator, location);\n+    }\n+\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         debug!(\"visit_rvalue(rvalue={:?}, location={:?})\", rvalue, location);\n \n-        // Look for an rvalue like:\n-        //\n-        //     & L\n-        //\n-        // where L is the path that is borrowed. In that case, we have\n-        // to add the reborrow constraints (which don't fall out\n-        // naturally from the type-checker).\n-        if let Rvalue::Ref(region, _bk, ref borrowed_lv) = *rvalue {\n-            self.add_reborrow_constraint(location, region, borrowed_lv);\n+        match rvalue {\n+            Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n+                // In some cases, e.g. when borrowing from an unsafe\n+                // place, we don't bother to create a loan, since\n+                // there are no conditions to validate.\n+                if let Some(all_facts) = self.all_facts {\n+                    if let Some(borrow_index) = self.borrow_set.location_map.get(&location) {\n+                        let region_vid = region.to_region_vid();\n+                        all_facts.borrow_region.push((\n+                            region_vid,\n+                            *borrow_index,\n+                            self.location_table.mid_index(location),\n+                        ));\n+                    }\n+                }\n+\n+                // Look for an rvalue like:\n+                //\n+                //     & L\n+                //\n+                // where L is the path that is borrowed. In that case, we have\n+                // to add the reborrow constraints (which don't fall out\n+                // naturally from the type-checker).\n+                self.add_reborrow_constraint(location, region, borrowed_place);\n+            }\n+\n+            _ => { }\n         }\n \n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_user_assert_ty(&mut self, _c_ty: &CanonicalTy<'tcx>,\n-                            _local: &Local, _location: Location) { }\n+    fn visit_user_assert_ty(\n+        &mut self,\n+        _c_ty: &CanonicalTy<'tcx>,\n+        _local: &Local,\n+        _location: Location,\n+    ) {\n+    }\n }\n \n impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n@@ -122,8 +228,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n     {\n         debug!(\n             \"add_regular_live_constraint(live_ty={:?}, location={:?})\",\n-            live_ty,\n-            location\n+            live_ty, location\n         );\n \n         self.infcx\n@@ -144,8 +249,10 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n     ) {\n         let mut borrowed_place = borrowed_place;\n \n-        debug!(\"add_reborrow_constraint({:?}, {:?}, {:?})\",\n-               location, borrow_region, borrowed_place);\n+        debug!(\n+            \"add_reborrow_constraint({:?}, {:?}, {:?})\",\n+            location, borrow_region, borrowed_place\n+        );\n         while let Projection(box PlaceProjection { base, elem }) = borrowed_place {\n             debug!(\"add_reborrow_constraint - iteration {:?}\", borrowed_place);\n \n@@ -165,12 +272,20 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n                                 location.successor_within_block(),\n                             );\n \n+                            if let Some(all_facts) = self.all_facts {\n+                                all_facts.outlives.push((\n+                                    ref_region.to_region_vid(),\n+                                    borrow_region.to_region_vid(),\n+                                    self.location_table.mid_index(location),\n+                                ));\n+                            }\n+\n                             match mutbl {\n                                 hir::Mutability::MutImmutable => {\n                                     // Immutable reference. We don't need the base\n                                     // to be valid for the entire lifetime of\n                                     // the borrow.\n-                                    break\n+                                    break;\n                                 }\n                                 hir::Mutability::MutMutable => {\n                                     // Mutable reference. We *do* need the base\n@@ -199,19 +314,19 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n                         }\n                         ty::TyRawPtr(..) => {\n                             // deref of raw pointer, guaranteed to be valid\n-                            break\n+                            break;\n                         }\n                         ty::TyAdt(def, _) if def.is_box() => {\n                             // deref of `Box`, need the base to be valid - propagate\n                         }\n-                        _ => bug!(\"unexpected deref ty {:?} in {:?}\", base_ty, borrowed_place)\n+                        _ => bug!(\"unexpected deref ty {:?} in {:?}\", base_ty, borrowed_place),\n                     }\n                 }\n-                ProjectionElem::Field(..) |\n-                ProjectionElem::Downcast(..) |\n-                ProjectionElem::Index(..) |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Subslice { .. } => {\n+                ProjectionElem::Field(..)\n+                | ProjectionElem::Downcast(..)\n+                | ProjectionElem::Index(..)\n+                | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Subslice { .. } => {\n                     // other field access\n                 }\n             }"}, {"sha": "56e388a5b6094b81d87df6e46a7006a359ba72ca", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -193,7 +193,6 @@ impl<'gcx, 'tcx> UseFinder<'gcx, 'tcx> {\n                         block_data\n                             .terminator()\n                             .successors()\n-                            .iter()\n                             .map(|&basic_block| Location {\n                                 statement_index: 0,\n                                 block: basic_block,"}, {"sha": "2802aa0dff4e23553430ca6651f149d87c5327bb", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,194 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::location::{LocationIndex, LocationTable};\n+use dataflow::indexes::BorrowIndex;\n+use rustc::ty::RegionVid;\n+use std::error::Error;\n+use std::fmt::Debug;\n+use std::fs::{self, File};\n+use std::io::Write;\n+use std::path::Path;\n+\n+/// The \"facts\" which are the basis of the NLL borrow analysis.\n+#[derive(Default)]\n+crate struct AllFacts {\n+    // `borrow_region(R, B, P)` -- the region R may refer to data from borrow B\n+    // starting at the point P (this is usually the point *after* a borrow rvalue)\n+    crate borrow_region: Vec<(RegionVid, BorrowIndex, LocationIndex)>,\n+\n+    // universal_region(R) -- this is a \"free region\" within fn body\n+    crate universal_region: Vec<RegionVid>,\n+\n+    // `cfg_edge(P,Q)` for each edge P -> Q in the control flow\n+    crate cfg_edge: Vec<(LocationIndex, LocationIndex)>,\n+\n+    // `killed(B,P)` when some prefix of the path borrowed at B is assigned at point P\n+    crate killed: Vec<(BorrowIndex, LocationIndex)>,\n+\n+    // `outlives(R1, R2, P)` when we require `R1@P: R2@P`\n+    crate outlives: Vec<(RegionVid, RegionVid, LocationIndex)>,\n+\n+    // `region_live_at(R, P)` when the region R appears in a live variable at P\n+    crate region_live_at: Vec<(RegionVid, LocationIndex)>,\n+}\n+\n+impl AllFacts {\n+    crate fn write_to_dir(\n+        &self,\n+        dir: impl AsRef<Path>,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        let dir: &Path = dir.as_ref();\n+        fs::create_dir_all(dir)?;\n+        let wr = FactWriter { location_table, dir };\n+        macro_rules! write_facts_to_path {\n+            ($wr:ident . write_facts_to_path($this:ident . [\n+                $($field:ident,)*\n+            ])) => {\n+                $(\n+                    $wr.write_facts_to_path(\n+                        &$this.$field,\n+                        &format!(\"{}.facts\", stringify!($field))\n+                    )?;\n+                )*\n+            }\n+        }\n+        write_facts_to_path! {\n+            wr.write_facts_to_path(self.[\n+                borrow_region,\n+                universal_region,\n+                cfg_edge,\n+                killed,\n+                outlives,\n+                region_live_at,\n+            ])\n+        }\n+        Ok(())\n+    }\n+}\n+\n+struct FactWriter<'w> {\n+    location_table: &'w LocationTable,\n+    dir: &'w Path,\n+}\n+\n+impl<'w> FactWriter<'w> {\n+    fn write_facts_to_path<T>(\n+        &self,\n+        rows: &Vec<T>,\n+        file_name: &str,\n+    ) -> Result<(), Box<dyn Error>>\n+    where\n+        T: FactRow,\n+    {\n+        let file = &self.dir.join(file_name);\n+        let mut file = File::create(file)?;\n+        for row in rows {\n+            row.write(&mut file, self.location_table)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+trait FactRow {\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>>;\n+}\n+\n+impl FactRow for RegionVid {\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        write_row(out, location_table, &[self])\n+    }\n+}\n+\n+impl<A, B> FactRow for (A, B)\n+where\n+    A: FactCell,\n+    B: FactCell,\n+{\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        write_row(out, location_table, &[&self.0, &self.1])\n+    }\n+}\n+\n+impl<A, B, C> FactRow for (A, B, C)\n+where\n+    A: FactCell,\n+    B: FactCell,\n+    C: FactCell,\n+{\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        write_row(out, location_table, &[&self.0, &self.1, &self.2])\n+    }\n+}\n+\n+impl<A, B, C, D> FactRow for (A, B, C, D)\n+where\n+    A: FactCell,\n+    B: FactCell,\n+    C: FactCell,\n+    D: FactCell,\n+{\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        write_row(out, location_table, &[&self.0, &self.1, &self.2, &self.3])\n+    }\n+}\n+\n+fn write_row(\n+    out: &mut dyn Write,\n+    location_table: &LocationTable,\n+    columns: &[&dyn FactCell],\n+) -> Result<(), Box<dyn Error>> {\n+    for (index, c) in columns.iter().enumerate() {\n+        let tail = if index == columns.len() - 1 {\n+            \"\\n\"\n+        } else {\n+            \"\\t\"\n+        };\n+        write!(out, \"{:?}{}\", c.to_string(location_table), tail)?;\n+    }\n+    Ok(())\n+}\n+\n+trait FactCell {\n+    fn to_string(&self, location_table: &LocationTable) -> String;\n+}\n+\n+impl<A: Debug> FactCell for A {\n+    default fn to_string(&self, _location_table: &LocationTable) -> String {\n+        format!(\"{:?}\", self)\n+    }\n+}\n+\n+impl FactCell for LocationIndex {\n+    fn to_string(&self, location_table: &LocationTable) -> String {\n+        format!(\"{:?}\", location_table.to_location(*self))\n+    }\n+}"}, {"sha": "0b1729294d8494b3ba74e8c61b482015f0789977", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 50, "deletions": 14, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -9,36 +9,39 @@\n // except according to those terms.\n \n use borrow_check::borrow_set::BorrowSet;\n+use borrow_check::location::LocationTable;\n+use dataflow::move_paths::MoveData;\n+use dataflow::FlowAtLocation;\n+use dataflow::MaybeInitializedPlaces;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::{ClosureRegionRequirements, ClosureOutlivesSubject, Mir};\n use rustc::infer::InferCtxt;\n+use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Mir};\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc::util::nodemap::FxHashMap;\n use std::collections::BTreeSet;\n use std::fmt::Debug;\n use std::io;\n+use std::path::PathBuf;\n use transform::MirSource;\n use util::liveness::{LivenessResults, LocalSet};\n-use dataflow::FlowAtLocation;\n-use dataflow::MaybeInitializedPlaces;\n-use dataflow::move_paths::MoveData;\n \n+use self::mir_util::PassWhere;\n use util as mir_util;\n use util::pretty::{self, ALIGN};\n-use self::mir_util::PassWhere;\n \n mod constraint_generation;\n pub mod explain_borrow;\n-pub(crate) mod region_infer;\n+mod facts;\n+crate mod region_infer;\n mod renumber;\n mod subtype_constraint_generation;\n-pub(crate) mod type_check;\n+crate mod type_check;\n mod universal_regions;\n \n+use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;\n use self::universal_regions::UniversalRegions;\n \n-\n /// Rewrites the regions in the MIR to use NLL variables, also\n /// scraping out the set of universal regions (e.g., region parameters)\n /// declared on the function. That set will need to be given to\n@@ -71,10 +74,11 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n+    location_table: &LocationTable,\n     param_env: ty::ParamEnv<'gcx>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n-    _borrow_set: &BorrowSet<'tcx>,\n+    borrow_set: &BorrowSet<'tcx>,\n ) -> (\n     RegionInferenceContext<'tcx>,\n     Option<ClosureRegionRequirements<'gcx>>,\n@@ -92,15 +96,47 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         move_data,\n     );\n \n+    let mut all_facts = if infcx.tcx.sess.opts.debugging_opts.nll_facts {\n+        Some(AllFacts::default())\n+    } else {\n+        None\n+    };\n+\n+    if let Some(all_facts) = &mut all_facts {\n+        all_facts\n+            .universal_region\n+            .extend(universal_regions.universal_regions());\n+    }\n+\n     // Create the region inference context, taking ownership of the region inference\n     // data that was contained in `infcx`.\n     let var_origins = infcx.take_region_var_origins();\n-    let mut regioncx = RegionInferenceContext::new(var_origins, universal_regions, mir);\n-    subtype_constraint_generation::generate(&mut regioncx, mir, constraint_sets);\n-\n+    let mut regioncx =\n+        RegionInferenceContext::new(var_origins, universal_regions, mir);\n+\n+    // Generate various constraints.\n+    subtype_constraint_generation::generate(\n+        &mut regioncx,\n+        &mut all_facts,\n+        location_table,\n+        mir,\n+        constraint_sets,\n+    );\n+    constraint_generation::generate_constraints(\n+        infcx,\n+        &mut regioncx,\n+        &mut all_facts,\n+        location_table,\n+        &mir,\n+        borrow_set,\n+    );\n \n-    // Generate non-subtyping constraints.\n-    constraint_generation::generate_constraints(infcx, &mut regioncx, &mir);\n+    // Dump facts if requested.\n+    if let Some(all_facts) = all_facts {\n+        let def_path = infcx.tcx.hir.def_path(def_id);\n+        let dir_path = PathBuf::from(\"nll-facts\").join(def_path.to_filename_friendly_no_crate());\n+        all_facts.write_to_dir(dir_path, location_table).unwrap();\n+    }\n \n     // Solve the region constraints.\n     let closure_region_requirements = regioncx.solve(infcx, &mir, def_id);"}, {"sha": "f68394d6149818833bc862f9854d233eceb191f9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dfs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -95,7 +95,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     block_data\n                         .terminator()\n                         .successors()\n-                        .iter()\n                         .map(|&basic_block| Location {\n                             statement_index: 0,\n                             block: basic_block,"}, {"sha": "4d1f3e2b4300ab30a8ed6927cfe0029b6f78bca9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -16,7 +16,7 @@ use rustc::infer::RegionObligation;\n use rustc::infer::RegionVariableOrigin;\n use rustc::infer::SubregionOrigin;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc::infer::region_constraints::{GenericKind, VarOrigins};\n+use rustc::infer::region_constraints::{GenericKind, VarInfos};\n use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n                  Local, Location, Mir};\n use rustc::traits::ObligationCause;\n@@ -256,19 +256,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// of those will be constant regions representing the free\n     /// regions defined in `universal_regions`.\n     pub(crate) fn new(\n-        var_origins: VarOrigins,\n+        var_infos: VarInfos,\n         universal_regions: UniversalRegions<'tcx>,\n         mir: &Mir<'tcx>,\n     ) -> Self {\n-        let num_region_variables = var_origins.len();\n+        let num_region_variables = var_infos.len();\n         let num_universal_regions = universal_regions.len();\n \n         let elements = &Rc::new(RegionValueElements::new(mir, num_universal_regions));\n \n         // Create a RegionDefinition for each inference variable.\n-        let definitions = var_origins\n+        let definitions = var_infos\n             .into_iter()\n-            .map(|origin| RegionDefinition::new(origin))\n+            .map(|info| RegionDefinition::new(info.origin))\n             .collect();\n \n         let mut result = Self {"}, {"sha": "9db19085a39654b630dc4833d9a4b09fb2c45c70", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::mir::Mir;\n+use borrow_check::location::LocationTable;\n+use borrow_check::nll::facts::AllFacts;\n use rustc::infer::region_constraints::Constraint;\n use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::infer::region_constraints::{Verify, VerifyBound};\n+use rustc::mir::{Location, Mir};\n use rustc::ty;\n+use std::iter;\n use syntax::codemap::Span;\n \n-use super::region_infer::{TypeTest, RegionInferenceContext, RegionTest};\n+use super::region_infer::{RegionInferenceContext, RegionTest, TypeTest};\n use super::type_check::Locations;\n use super::type_check::MirTypeckRegionConstraints;\n use super::type_check::OutlivesSet;\n@@ -27,19 +30,30 @@ use super::type_check::OutlivesSet;\n /// them into the NLL `RegionInferenceContext`.\n pub(super) fn generate<'tcx>(\n     regioncx: &mut RegionInferenceContext<'tcx>,\n+    all_facts: &mut Option<AllFacts>,\n+    location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n     constraints: &MirTypeckRegionConstraints<'tcx>,\n ) {\n-    SubtypeConstraintGenerator { regioncx, mir }.generate(constraints);\n+    SubtypeConstraintGenerator {\n+        regioncx,\n+        location_table,\n+        mir,\n+    }.generate(constraints, all_facts);\n }\n \n struct SubtypeConstraintGenerator<'cx, 'tcx: 'cx> {\n     regioncx: &'cx mut RegionInferenceContext<'tcx>,\n+    location_table: &'cx LocationTable,\n     mir: &'cx Mir<'tcx>,\n }\n \n impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n-    fn generate(&mut self, constraints: &MirTypeckRegionConstraints<'tcx>) {\n+    fn generate(\n+        &mut self,\n+        constraints: &MirTypeckRegionConstraints<'tcx>,\n+        all_facts: &mut Option<AllFacts>,\n+    ) {\n         let MirTypeckRegionConstraints {\n             liveness_set,\n             outlives_sets,\n@@ -57,6 +71,17 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n             self.regioncx.add_live_point(region_vid, *location, &cause);\n         }\n \n+        if let Some(all_facts) = all_facts {\n+            all_facts\n+                .region_live_at\n+                .extend(liveness_set.into_iter().flat_map(|(region, location, _)| {\n+                    let r = self.to_region_vid(region);\n+                    let p1 = self.location_table.start_index(*location);\n+                    let p2 = self.location_table.mid_index(*location);\n+                    iter::once((r, p1)).chain(iter::once((r, p2)))\n+                }));\n+        }\n+\n         for OutlivesSet { locations, data } in outlives_sets {\n             debug!(\"generate: constraints at: {:#?}\", locations);\n             let RegionConstraintData {\n@@ -65,7 +90,11 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n                 givens,\n             } = data;\n \n-            let span = self.mir.source_info(locations.from_location).span;\n+            let span = self.mir\n+                .source_info(locations.from_location().unwrap_or(Location::START))\n+                .span;\n+\n+            let at_location = locations.at_location().unwrap_or(Location::START);\n \n             for constraint in constraints.keys() {\n                 debug!(\"generate: constraint: {:?}\", constraint);\n@@ -83,8 +112,24 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n                 // reverse direction, because `regioncx` talks about\n                 // \"outlives\" (`>=`) whereas the region constraints\n                 // talk about `<=`.\n-                self.regioncx\n-                    .add_outlives(span, b_vid, a_vid, locations.at_location);\n+                self.regioncx.add_outlives(span, b_vid, a_vid, at_location);\n+\n+                // In the new analysis, all outlives relations etc\n+                // \"take effect\" at the mid point of the statement\n+                // that requires them, so ignore the `at_location`.\n+                if let Some(all_facts) = all_facts {\n+                    if let Some(from_location) = locations.from_location() {\n+                        all_facts.outlives.push((\n+                            b_vid,\n+                            a_vid,\n+                            self.location_table.mid_index(from_location),\n+                        ));\n+                    } else {\n+                        for location in self.location_table.all_points() {\n+                            all_facts.outlives.push((b_vid, a_vid, location));\n+                        }\n+                    }\n+                }\n             }\n \n             for verify in verifys {\n@@ -109,7 +154,7 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n \n         let lower_bound = self.to_region_vid(verify.region);\n \n-        let point = locations.at_location;\n+        let point = locations.at_location().unwrap_or(Location::START);\n \n         let test = self.verify_bound_to_region_test(&verify.bound);\n \n@@ -149,14 +194,6 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n     }\n \n     fn to_region_vid(&self, r: ty::Region<'tcx>) -> ty::RegionVid {\n-        // Every region that we see in the constraints came from the\n-        // MIR or from the parameter environment. If the former, it\n-        // will be a region variable.  If the latter, it will be in\n-        // the set of universal regions *somewhere*.\n-        if let ty::ReVar(vid) = r {\n-            *vid\n-        } else {\n-            self.regioncx.to_region_vid(r)\n-        }\n+        self.regioncx.to_region_vid(r)\n     }\n }"}, {"sha": "2b1878c33e90b78f877672427d6c7f6703fae1de", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -29,7 +29,7 @@ use rustc::traits::PredicateObligations;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::{AtLocation, TypeChecker};\n+use super::{Locations, TypeChecker};\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     pub(super) fn equate_inputs_and_outputs(\n@@ -47,26 +47,21 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         } = universal_regions;\n         let infcx = self.infcx;\n \n-        let start_position = Location {\n-            block: START_BLOCK,\n-            statement_index: 0,\n-        };\n-\n         // Equate expected input tys with those in the MIR.\n         let argument_locals = (1..).map(Local::new);\n         for (&unnormalized_input_ty, local) in unnormalized_input_tys.iter().zip(argument_locals) {\n-            let input_ty = self.normalize(&unnormalized_input_ty, start_position);\n+            let input_ty = self.normalize(&unnormalized_input_ty, Locations::All);\n             let mir_input_ty = mir.local_decls[local].ty;\n-            self.equate_normalized_input_or_output(start_position, input_ty, mir_input_ty);\n+            self.equate_normalized_input_or_output(input_ty, mir_input_ty);\n         }\n \n         assert!(\n             mir.yield_ty.is_some() && universal_regions.yield_ty.is_some() ||\n             mir.yield_ty.is_none() && universal_regions.yield_ty.is_none()\n-            );\n+        );\n         if let Some(mir_yield_ty) = mir.yield_ty {\n             let ur_yield_ty = universal_regions.yield_ty.unwrap();\n-            self.equate_normalized_input_or_output(start_position, ur_yield_ty, mir_yield_ty);\n+            self.equate_normalized_input_or_output(ur_yield_ty, mir_yield_ty);\n         }\n \n         // Return types are a bit more complex. They may contain existential `impl Trait`\n@@ -75,13 +70,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             \"equate_inputs_and_outputs: unnormalized_output_ty={:?}\",\n             unnormalized_output_ty\n         );\n-        let output_ty = self.normalize(&unnormalized_output_ty, start_position);\n+        let output_ty = self.normalize(&unnormalized_output_ty, Locations::All);\n         debug!(\n             \"equate_inputs_and_outputs: normalized output_ty={:?}\",\n             output_ty\n         );\n         let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n-        let anon_type_map = self.fully_perform_op(start_position.at_self(), |cx| {\n+        let anon_type_map = self.fully_perform_op(Locations::All, |cx| {\n             let mut obligations = ObligationAccumulator::default();\n \n             let (output_ty, anon_type_map) = obligations.add(infcx.instantiate_anon_types(\n@@ -112,7 +107,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let anon_defn_ty = anon_defn_ty.subst(tcx, anon_decl.substs);\n                 let anon_defn_ty = renumber::renumber_regions(\n                     cx.infcx,\n-                    TyContext::Location(start_position),\n+                    TyContext::Location(Location::START),\n                     &anon_defn_ty,\n                 );\n                 debug!(\n@@ -134,7 +129,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }).unwrap_or_else(|terr| {\n                 span_mirbug!(\n                     self,\n-                    start_position,\n+                    Location::START,\n                     \"equate_inputs_and_outputs: `{:?}=={:?}` failed with `{:?}`\",\n                     output_ty,\n                     mir_output_ty,\n@@ -148,7 +143,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         // prove that `T: Iterator` where `T` is the type we\n         // instantiated it with).\n         if let Some(anon_type_map) = anon_type_map {\n-            self.fully_perform_op(start_position.at_self(), |_cx| {\n+            self.fully_perform_op(Locations::All, |_cx| {\n                 infcx.constrain_anon_types(&anon_type_map, universal_regions);\n                 Ok(InferOk {\n                     value: (),\n@@ -158,13 +153,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn equate_normalized_input_or_output(&mut self, location: Location, a: Ty<'tcx>, b: Ty<'tcx>) {\n+    fn equate_normalized_input_or_output(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n         debug!(\"equate_normalized_input_or_output(a={:?}, b={:?})\", a, b);\n \n-        if let Err(terr) = self.eq_types(a, b, location.at_self()) {\n+        if let Err(terr) = self.eq_types(a, b, Locations::All) {\n             span_mirbug!(\n                 self,\n-                location,\n+                Location::START,\n                 \"equate_normalized_input_or_output: `{:?}=={:?}` failed with `{:?}`\",\n                 a,\n                 b,"}, {"sha": "42a1745addff75de36333f0f7047e59e2af05aea", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 96, "deletions": 90, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -22,6 +22,7 @@ use rustc::infer::region_constraints::{GenericKind, RegionConstraintData};\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor};\n+use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::*;\n use rustc::traits::query::NoSolution;\n use rustc::traits::{self, Normalized, TraitEngine};\n@@ -617,17 +618,72 @@ pub struct OutlivesSet<'tcx> {\n     pub data: RegionConstraintData<'tcx>,\n }\n \n+/// The `Locations` type summarizes *where* region constraints are\n+/// required to hold. Normally, this is at a particular point which\n+/// created the obligation, but for constraints that the user gave, we\n+/// want the constraint to hold at all points.\n #[derive(Copy, Clone, Debug)]\n-pub struct Locations {\n-    /// The location in the MIR that generated these constraints.\n-    /// This is intended for error reporting and diagnosis; the\n-    /// constraints may *take effect* at a distinct spot.\n-    pub from_location: Location,\n-\n-    /// The constraints must be met at this location. In terms of the\n-    /// NLL RFC, when you have a constraint `R1: R2 @ P`, this field\n-    /// is the `P` value.\n-    pub at_location: Location,\n+pub enum Locations {\n+    /// Indicates that a type constraint should always be true. This\n+    /// is particularly important in the new borrowck analysis for\n+    /// things like the type of the return slot. Consider this\n+    /// example:\n+    ///\n+    /// ```\n+    /// fn foo<'a>(x: &'a u32) -> &'a u32 {\n+    ///     let y = 22;\n+    ///     return &y; // error\n+    /// }\n+    /// ```\n+    ///\n+    /// Here, we wind up with the signature from the return type being\n+    /// something like `&'1 u32` where `'1` is a universal region. But\n+    /// the type of the return slot `_0` is something like `&'2 u32`\n+    /// where `'2` is an existential region variable. The type checker\n+    /// requires that `&'2 u32 = &'1 u32` -- but at what point? In the\n+    /// older NLL analysis, we required this only at the entry point\n+    /// to the function. By the nature of the constraints, this wound\n+    /// up propagating to all points reachable from start (because\n+    /// `'1` -- as a universal region -- is live everywhere).  In the\n+    /// newer analysis, though, this doesn't work: `_0` is considered\n+    /// dead at the start (it has no usable value) and hence this type\n+    /// equality is basically a no-op. Then, later on, when we do `_0\n+    /// = &'3 y`, that region `'3` never winds up related to the\n+    /// universal region `'1` and hence no error occurs. Therefore, we\n+    /// use Locations::All instead, which ensures that the `'1` and\n+    /// `'2` are equal everything. We also use this for other\n+    /// user-given type annotations; e.g., if the user wrote `let mut\n+    /// x: &'static u32 = ...`, we would ensure that all values\n+    /// assigned to `x` are of `'static` lifetime.\n+    All,\n+\n+    Pair {\n+        /// The location in the MIR that generated these constraints.\n+        /// This is intended for error reporting and diagnosis; the\n+        /// constraints may *take effect* at a distinct spot.\n+        from_location: Location,\n+\n+        /// The constraints must be met at this location. In terms of the\n+        /// NLL RFC, when you have a constraint `R1: R2 @ P`, this field\n+        /// is the `P` value.\n+        at_location: Location,\n+    }\n+}\n+\n+impl Locations {\n+    pub fn from_location(&self) -> Option<Location> {\n+        match self {\n+            Locations::All => None,\n+            Locations::Pair { from_location, .. } => Some(*from_location),\n+        }\n+    }\n+\n+    pub fn at_location(&self) -> Option<Location> {\n+        match self {\n+            Locations::All => None,\n+            Locations::Pair { at_location, .. } => Some(*at_location),\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n@@ -769,7 +825,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     \"check_stmt: user_assert_ty ty={:?} local_ty={:?}\",\n                     ty, local_ty\n                 );\n-                if let Err(terr) = self.eq_types(ty, local_ty, location.at_self()) {\n+                if let Err(terr) = self.eq_types(ty, local_ty, Locations::All) {\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -819,7 +875,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let place_ty = location.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = value.ty(mir, tcx);\n \n-                let locations = Locations {\n+                let locations = Locations::Pair {\n                     from_location: term_location,\n                     at_location: target.start_location(),\n                 };\n@@ -838,7 +894,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // *both* blocks, so we need to ensure that it holds\n                 // at both locations.\n                 if let Some(unwind) = unwind {\n-                    let locations = Locations {\n+                    let locations = Locations::Pair {\n                         from_location: term_location,\n                         at_location: unwind.start_location(),\n                     };\n@@ -918,11 +974,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     ));\n                 }\n \n-                if self.is_box_free(func) {\n-                    self.check_box_free_inputs(mir, term, &sig, args, term_location);\n-                } else {\n-                    self.check_call_inputs(mir, term, &sig, args, term_location);\n-                }\n+                self.check_call_inputs(mir, term, &sig, args, term_location);\n             }\n             TerminatorKind::Assert {\n                 ref cond, ref msg, ..\n@@ -932,7 +984,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n                 }\n \n-                if let AssertMessage::BoundsCheck { ref len, ref index } = *msg {\n+                if let BoundsCheck { ref len, ref index } = *msg {\n                     if len.ty(mir, tcx) != tcx.types.usize {\n                         span_mirbug!(self, len, \"bounds-check length non-usize {:?}\", len)\n                     }\n@@ -974,7 +1026,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match *destination {\n             Some((ref dest, target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                let locations = Locations {\n+                let locations = Locations::Pair {\n                     from_location: term_location,\n                     at_location: target_block.start_location(),\n                 };\n@@ -1026,70 +1078,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn is_box_free(&self, operand: &Operand<'tcx>) -> bool {\n-        match *operand {\n-            Operand::Constant(ref c) => match c.ty.sty {\n-                ty::TyFnDef(ty_def_id, _) => {\n-                    Some(ty_def_id) == self.tcx().lang_items().box_free_fn()\n-                }\n-                _ => false,\n-            },\n-            _ => false,\n-        }\n-    }\n-\n-    fn check_box_free_inputs(\n-        &mut self,\n-        mir: &Mir<'tcx>,\n-        term: &Terminator<'tcx>,\n-        sig: &ty::FnSig<'tcx>,\n-        args: &[Operand<'tcx>],\n-        term_location: Location,\n-    ) {\n-        debug!(\"check_box_free_inputs\");\n-\n-        // box_free takes a Box as a pointer. Allow for that.\n-\n-        if sig.inputs().len() != 1 {\n-            span_mirbug!(self, term, \"box_free should take 1 argument\");\n-            return;\n-        }\n-\n-        let pointee_ty = match sig.inputs()[0].sty {\n-            ty::TyRawPtr(mt) => mt.ty,\n-            _ => {\n-                span_mirbug!(self, term, \"box_free should take a raw ptr\");\n-                return;\n-            }\n-        };\n-\n-        if args.len() != 1 {\n-            span_mirbug!(self, term, \"box_free called with wrong # of args\");\n-            return;\n-        }\n-\n-        let ty = args[0].ty(mir, self.tcx());\n-        let arg_ty = match ty.sty {\n-            ty::TyRawPtr(mt) => mt.ty,\n-            ty::TyAdt(def, _) if def.is_box() => ty.boxed_ty(),\n-            _ => {\n-                span_mirbug!(self, term, \"box_free called with bad arg ty\");\n-                return;\n-            }\n-        };\n-\n-        if let Err(terr) = self.sub_types(arg_ty, pointee_ty, term_location.at_self()) {\n-            span_mirbug!(\n-                self,\n-                term,\n-                \"bad box_free arg ({:?} <- {:?}): {:?}\",\n-                pointee_ty,\n-                arg_ty,\n-                terr\n-            );\n-        }\n-    }\n-\n     fn check_iscleanup(&mut self, mir: &Mir<'tcx>, block_data: &BasicBlockData<'tcx>) {\n         let is_cleanup = block_data.is_cleanup;\n         self.last_span = block_data.terminator().source_info.span;\n@@ -1442,7 +1430,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             };\n             let operand_ty = operand.ty(mir, tcx);\n             if let Err(terr) =\n-                self.sub_types(operand_ty, field_ty, location.at_successor_within_block())\n+                self.sub_types(operand_ty, field_ty, location.at_self())\n             {\n                 span_mirbug!(\n                     self,\n@@ -1494,7 +1482,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             // these extra requirements are basically like where\n             // clauses on the struct.\n             AggregateKind::Closure(def_id, substs) => {\n-                if let Some(closure_region_requirements) = tcx.mir_borrowck(*def_id) {\n+                if let Some(closure_region_requirements) =\n+                    tcx.mir_borrowck(*def_id).closure_requirements\n+                {\n                     closure_region_requirements.apply_requirements(\n                         self.infcx,\n                         self.body_id,\n@@ -1579,12 +1569,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn normalize<T>(&mut self, value: &T, location: Location) -> T\n+    fn normalize<T>(&mut self, value: &T, location: impl ToLocations) -> T\n     where\n         T: fmt::Debug + TypeFoldable<'tcx>,\n     {\n         debug!(\"normalize(value={:?}, location={:?})\", value, location);\n-        self.fully_perform_op(location.at_self(), |this| {\n+        self.fully_perform_op(location.to_locations(), |this| {\n             let Normalized { value, obligations } = this.infcx\n                 .at(&this.misc(this.last_span), this.param_env)\n                 .normalize(value)\n@@ -1650,16 +1640,32 @@ trait AtLocation {\n \n impl AtLocation for Location {\n     fn at_self(self) -> Locations {\n-        Locations {\n+        Locations::Pair {\n             from_location: self,\n             at_location: self,\n         }\n     }\n \n     fn at_successor_within_block(self) -> Locations {\n-        Locations {\n+        Locations::Pair {\n             from_location: self,\n             at_location: self.successor_within_block(),\n         }\n     }\n }\n+\n+trait ToLocations: fmt::Debug + Copy {\n+    fn to_locations(self) -> Locations;\n+}\n+\n+impl ToLocations for Locations {\n+    fn to_locations(self) -> Locations {\n+        self\n+    }\n+}\n+\n+impl ToLocations for Location {\n+    fn to_locations(self) -> Locations {\n+        self.at_self()\n+    }\n+}"}, {"sha": "fae06db31629bbad32f58ce16e51d1e3afae41b3", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::ForGuard::OutsideGuard;\n+use build::matches::ArmHasGuard;\n use hair::*;\n use rustc::mir::*;\n use rustc::hir;\n@@ -113,7 +115,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // Declare the bindings, which may create a visibility scope.\n                     let remainder_span = remainder_scope.span(this.hir.tcx(),\n                                                               &this.hir.region_scope_tree);\n-                    let scope = this.declare_bindings(None, remainder_span, lint_level, &pattern);\n+                    let scope = this.declare_bindings(None, remainder_span, lint_level, &pattern,\n+                                                      ArmHasGuard(false));\n \n                     // Evaluate the initializer, if present.\n                     if let Some(init) = initializer {\n@@ -135,8 +138,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         }\n \n                         this.visit_bindings(&pattern, &mut |this, _, _, node, span, _| {\n-                            this.storage_live_binding(block, node, span);\n-                            this.schedule_drop_for_binding(node, span);\n+                            this.storage_live_binding(block, node, span, OutsideGuard);\n+                            this.schedule_drop_for_binding(node, span, OutsideGuard);\n                         })\n                     }\n "}, {"sha": "365b9babd0869cfb070ae9bb63e65fa0aaf7ca06", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -11,9 +11,11 @@\n //! See docs in build/expr/mod.rs\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::ForGuard::{OutsideGuard, WithinGuard};\n use build::expr::category::Category;\n use hair::*;\n use rustc::mir::*;\n+use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -73,7 +75,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                                            Operand::Copy(Place::Local(idx)),\n                                                            Operand::Copy(len.clone())));\n \n-                let msg = AssertMessage::BoundsCheck {\n+                let msg = BoundsCheck {\n                     len: Operand::Move(len),\n                     index: Operand::Copy(Place::Local(idx))\n                 };\n@@ -85,8 +87,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(Place::Local(Local::new(1)))\n             }\n             ExprKind::VarRef { id } => {\n-                let index = this.var_indices[&id];\n-                block.and(Place::Local(index))\n+                let place = if this.is_bound_var_in_guard(id) {\n+                    let index = this.var_local_id(id, WithinGuard);\n+                    if this.hir.tcx().all_pat_vars_are_implicit_refs_within_guards() {\n+                        Place::Local(index).deref()\n+                    } else {\n+                        Place::Local(index)\n+                    }\n+                } else {\n+                    let index = this.var_local_id(id, OutsideGuard);\n+                    Place::Local(index)\n+                };\n+                block.and(place)\n             }\n             ExprKind::StaticRef { id } => {\n                 block.and(Place::Static(Box::new(Static { def_id: id, ty: expr.ty })))"}, {"sha": "9e96fdf821417f7bdcf7ecad1be5bb5ca7baa92a", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -10,7 +10,6 @@\n \n //! See docs in build/expr/mod.rs\n \n-use rustc_const_math::{ConstMathErr, Op};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -21,7 +20,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::middle::region;\n use rustc::ty::{self, Ty};\n use rustc::mir::*;\n-use rustc::mir::interpret::{Value, PrimVal};\n+use rustc::mir::interpret::{Value, PrimVal, EvalErrorKind};\n use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -86,9 +85,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     this.cfg.push_assign(block, source_info, &is_min,\n                                          Rvalue::BinaryOp(BinOp::Eq, arg.to_copy(), minval));\n \n-                    let err = ConstMathErr::Overflow(Op::Neg);\n                     block = this.assert(block, Operand::Move(is_min), false,\n-                                        AssertMessage::Math(err), expr_span);\n+                                        EvalErrorKind::OverflowNeg, expr_span);\n                 }\n                 block.and(Rvalue::UnaryOp(op, arg))\n             }\n@@ -311,19 +309,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let val = result_value.clone().field(val_fld, ty);\n             let of = result_value.field(of_fld, bool_ty);\n \n-            let err = ConstMathErr::Overflow(match op {\n-                BinOp::Add => Op::Add,\n-                BinOp::Sub => Op::Sub,\n-                BinOp::Mul => Op::Mul,\n-                BinOp::Shl => Op::Shl,\n-                BinOp::Shr => Op::Shr,\n-                _ => {\n-                    bug!(\"MIR build_binary_op: {:?} is not checkable\", op)\n-                }\n-            });\n+            let err = EvalErrorKind::Overflow(op);\n \n             block = self.assert(block, Operand::Move(of), false,\n-                                AssertMessage::Math(err), span);\n+                                err, span);\n \n             block.and(Rvalue::Use(Operand::Move(val)))\n         } else {\n@@ -332,11 +321,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // and 2. there are two possible failure cases, divide-by-zero and overflow.\n \n                 let (zero_err, overflow_err) = if op == BinOp::Div {\n-                    (ConstMathErr::DivisionByZero,\n-                     ConstMathErr::Overflow(Op::Div))\n+                    (EvalErrorKind::DivisionByZero,\n+                     EvalErrorKind::Overflow(op))\n                 } else {\n-                    (ConstMathErr::RemainderByZero,\n-                     ConstMathErr::Overflow(Op::Rem))\n+                    (EvalErrorKind::RemainderByZero,\n+                     EvalErrorKind::Overflow(op))\n                 };\n \n                 // Check for / 0\n@@ -346,7 +335,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      Rvalue::BinaryOp(BinOp::Eq, rhs.to_copy(), zero));\n \n                 block = self.assert(block, Operand::Move(is_zero), false,\n-                                    AssertMessage::Math(zero_err), span);\n+                                    zero_err, span);\n \n                 // We only need to check for the overflow in one case:\n                 // MIN / -1, and only for signed values.\n@@ -371,7 +360,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                          Rvalue::BinaryOp(BinOp::BitAnd, is_neg_1, is_min));\n \n                     block = self.assert(block, Operand::Move(of), false,\n-                                        AssertMessage::Math(overflow_err), span);\n+                                        overflow_err, span);\n                 }\n             }\n "}, {"sha": "562f890b4c0fb9704314dc5bc4f2f2aa8b8bcc4c", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -220,7 +220,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         let f = ty.fn_sig(this.hir.tcx());\n                         if f.abi() == Abi::RustIntrinsic ||\n                            f.abi() == Abi::PlatformIntrinsic {\n-                            Some(this.hir.tcx().item_name(def_id))\n+                            Some(this.hir.tcx().item_name(def_id).as_str())\n                         } else {\n                             None\n                         }"}, {"sha": "6946ac4c7b2771af2a6b7affc10f8870b3adc997", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 267, "deletions": 30, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -14,6 +14,8 @@\n //! details.\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n+use build::ForGuard::{self, OutsideGuard, WithinGuard};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n use rustc::ty::{self, Ty};\n@@ -28,6 +30,11 @@ mod simplify;\n mod test;\n mod util;\n \n+/// ArmHasGuard is isomorphic to a boolean flag. It indicates whether\n+/// a match arm has a guard expression attached to it.\n+#[derive(Copy, Clone, Debug)]\n+pub(crate) struct ArmHasGuard(pub bool);\n+\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn match_expr(&mut self,\n                       destination: &Place<'tcx>,\n@@ -66,7 +73,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let body = self.hir.mirror(arm.body.clone());\n             let scope = self.declare_bindings(None, body.span,\n                                               LintLevel::Inherited,\n-                                              &arm.patterns[0]);\n+                                              &arm.patterns[0],\n+                                              ArmHasGuard(arm.guard.is_some()));\n             (body, scope.unwrap_or(self.visibility_scope))\n         }).collect();\n \n@@ -149,7 +157,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                           var: NodeId, span: Span) {\n         if self.hir.tcx().sess.opts.debugging_opts.disable_nll_user_type_assert { return; }\n \n-        let local_id = self.var_indices[&var];\n+        let local_id = self.var_local_id(var, OutsideGuard);\n         let source_info = self.source_info(span);\n \n         debug!(\"user_assert_ty: local_id={:?}\", hir_id.local_id);\n@@ -173,14 +181,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Binding { mode: BindingMode::ByValue,\n                                    var,\n                                    subpattern: None, .. } => {\n-                let place = self.storage_live_binding(block, var, irrefutable_pat.span);\n+                let place = self.storage_live_binding(block, var, irrefutable_pat.span,\n+                                                      OutsideGuard);\n \n                 if let Some(ty) = ty {\n                     self.user_assert_ty(block, ty, var, irrefutable_pat.span);\n                 }\n \n                 unpack!(block = self.into(&place, block, initializer));\n-                self.schedule_drop_for_binding(var, irrefutable_pat.span);\n+                self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n             }\n             _ => {\n@@ -220,7 +229,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n \n         // now apply the bindings, which will also declare the variables\n-        self.bind_matched_candidate(block, candidate.bindings);\n+        self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n \n         block.unit()\n     }\n@@ -232,7 +241,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             mut var_scope: Option<VisibilityScope>,\n                             scope_span: Span,\n                             lint_level: LintLevel,\n-                            pattern: &Pattern<'tcx>)\n+                            pattern: &Pattern<'tcx>,\n+                            has_guard: ArmHasGuard)\n                             -> Option<VisibilityScope> {\n         assert!(!(var_scope.is_some() && lint_level.is_explicit()),\n                 \"can't have both a var and a lint scope at the same time\");\n@@ -254,15 +264,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 span,\n                 scope: var_scope.unwrap()\n             };\n-            this.declare_binding(source_info, syntactic_scope, mutability, name, var, ty);\n+            this.declare_binding(source_info, syntactic_scope, mutability, name, var,\n+                                 ty, has_guard);\n         });\n         var_scope\n     }\n \n-    pub fn storage_live_binding(&mut self, block: BasicBlock, var: NodeId, span: Span)\n+    pub fn storage_live_binding(&mut self,\n+                                block: BasicBlock,\n+                                var: NodeId,\n+                                span: Span,\n+                                for_guard: ForGuard)\n                             -> Place<'tcx>\n     {\n-        let local_id = self.var_indices[&var];\n+        let local_id = self.var_local_id(var, for_guard);\n         let source_info = self.source_info(span);\n         self.cfg.push(block, Statement {\n             source_info,\n@@ -271,8 +286,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         Place::Local(local_id)\n     }\n \n-    pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span) {\n-        let local_id = self.var_indices[&var];\n+    pub fn schedule_drop_for_binding(&mut self,\n+                                     var: NodeId,\n+                                     span: Span,\n+                                     for_guard: ForGuard) {\n+        let local_id = self.var_local_id(var, for_guard);\n         let var_ty = self.local_decls[local_id].ty;\n         let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n         let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n@@ -770,21 +788,139 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                        vec![candidate.next_candidate_pre_binding_block],\n                                });\n \n-        self.bind_matched_candidate(block, candidate.bindings);\n \n+        // rust-lang/rust#27282: The `autoref` business deserves some\n+        // explanation here.\n+        //\n+        // The intent of the `autoref` flag is that when it is true,\n+        // then any pattern bindings of type T will map to a `&T`\n+        // within the context of the guard expression, but will\n+        // continue to map to a `T` in the context of the arm body. To\n+        // avoid surfacing this distinction in the user source code\n+        // (which would be a severe change to the language and require\n+        // far more revision to the compiler), when `autoref` is true,\n+        // then any occurrence of the identifier in the guard\n+        // expression will automatically get a deref op applied to it.\n+        //\n+        // So an input like:\n+        //\n+        // ```\n+        // let place = Foo::new();\n+        // match place { foo if inspect(foo)\n+        //     => feed(foo), ...  }\n+        // ```\n+        //\n+        // will be treated as if it were really something like:\n+        //\n+        // ```\n+        // let place = Foo::new();\n+        // match place { Foo { .. } if { let tmp1 = &place; inspect(*tmp1) }\n+        //     => { let tmp2 = place; feed(tmp2) }, ... }\n+        //\n+        // And an input like:\n+        //\n+        // ```\n+        // let place = Foo::new();\n+        // match place { ref mut foo if inspect(foo)\n+        //     => feed(foo), ...  }\n+        // ```\n+        //\n+        // will be treated as if it were really something like:\n+        //\n+        // ```\n+        // let place = Foo::new();\n+        // match place { Foo { .. } if { let tmp1 = & &mut place; inspect(*tmp1) }\n+        //     => { let tmp2 = &mut place; feed(tmp2) }, ... }\n+        // ```\n+        //\n+        // In short, any pattern binding will always look like *some*\n+        // kind of `&T` within the guard at least in terms of how the\n+        // MIR-borrowck views it, and this will ensure that guard\n+        // expressions cannot mutate their the match inputs via such\n+        // bindings. (It also ensures that guard expressions can at\n+        // most *copy* values from such bindings; non-Copy things\n+        // cannot be moved via pattern bindings in guard expressions.)\n+        //\n+        // ----\n+        //\n+        // Implementation notes (under assumption `autoref` is true).\n+        //\n+        // To encode the distinction above, we must inject the\n+        // temporaries `tmp1` and `tmp2`.\n+        //\n+        // There are two cases of interest: binding by-value, and binding by-ref.\n+        //\n+        // 1. Binding by-value: Things are simple.\n+        //\n+        //    * Establishing `tmp1` creates a reference into the\n+        //      matched place. This code is emitted by\n+        //      bind_matched_candidate_for_guard.\n+        //\n+        //    * `tmp2` is only initialized \"lazily\", after we have\n+        //      checked the guard. Thus, the code that can trigger\n+        //      moves out of the candidate can only fire after the\n+        //      guard evaluated to true. This initialization code is\n+        //      emitted by bind_matched_candidate_for_arm.\n+        //\n+        // 2. Binding by-reference: Things are tricky.\n+        //\n+        //    * Here, the guard expression wants a `&&` or `&&mut`\n+        //      into the original input. This means we need to borrow\n+        //      a reference that we do not immediately have at hand\n+        //      (because all we have is the places associated with the\n+        //      match input itself; it is up to us to create a place\n+        //      holding a `&` or `&mut` that we can then borrow).\n+        //\n+        //    * Therefore, when the binding is by-reference, we\n+        //      *eagerly* introduce the binding for the arm body\n+        //      (`tmp2`) and then borrow it (`tmp1`).\n+        //\n+        //    * This is documented with \"NOTE tricky business\" below.\n+        //\n+        // FIXME The distinction in how `tmp2` is initialized is\n+        // currently encoded in a pretty awkward fashion; namely, by\n+        // passing a boolean to bind_matched_candidate_for_arm_body\n+        // indicating whether all of the by-ref bindings were already\n+        // initialized.\n+        //\n+        // * Also: pnkfelix thinks \"laziness\" is natural; but since\n+        //   MIR-borrowck did not complain with earlier (universally\n+        //   eager) MIR codegen, laziness might not be *necessary*.\n+\n+        let autoref = self.hir.tcx().all_pat_vars_are_implicit_refs_within_guards();\n         if let Some(guard) = candidate.guard {\n+            if autoref {\n+                self.bind_matched_candidate_for_guard(block, &candidate.bindings);\n+                let guard_frame = GuardFrame {\n+                    locals: candidate.bindings.iter()\n+                        .map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode))\n+                        .collect(),\n+                };\n+                debug!(\"Entering guard translation context: {:?}\", guard_frame);\n+                self.guard_context.push(guard_frame);\n+            } else {\n+                self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n+            }\n+\n             // the block to branch to if the guard fails; if there is no\n             // guard, this block is simply unreachable\n             let guard = self.hir.mirror(guard);\n             let source_info = self.source_info(guard.span);\n             let cond = unpack!(block = self.as_local_operand(block, guard));\n+            if autoref {\n+                let guard_frame = self.guard_context.pop().unwrap();\n+                debug!(\"Exiting guard translation context with locals: {:?}\", guard_frame);\n+            }\n \n             let false_edge_block = self.cfg.start_new_block();\n             self.cfg.terminate(block, source_info,\n                                TerminatorKind::if_(self.hir.tcx(), cond, arm_block,\n                                    false_edge_block));\n \n             let otherwise = self.cfg.start_new_block();\n+            if autoref {\n+                self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, true);\n+            }\n             self.cfg.terminate(false_edge_block, source_info,\n                                TerminatorKind::FalseEdges {\n                                    real_target: otherwise,\n@@ -793,47 +929,137 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                });\n             Some(otherwise)\n         } else {\n+            self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n             self.cfg.terminate(block, candidate_source_info,\n                                TerminatorKind::Goto { target: arm_block });\n             None\n         }\n     }\n \n-    fn bind_matched_candidate(&mut self,\n-                              block: BasicBlock,\n-                              bindings: Vec<Binding<'tcx>>) {\n-        debug!(\"bind_matched_candidate(block={:?}, bindings={:?})\",\n+    fn bind_matched_candidate_for_guard(&mut self,\n+                                        block: BasicBlock,\n+                                        bindings: &[Binding<'tcx>]) {\n+        debug!(\"bind_matched_candidate_for_guard(block={:?}, bindings={:?})\",\n                block, bindings);\n \n+        // Assign each of the bindings. Since we are binding for a\n+        // guard expression, this will never trigger moves out of the\n+        // candidate.\n+        let re_empty = self.hir.tcx().types.re_empty;\n+        for binding in bindings {\n+            let source_info = self.source_info(binding.span);\n+            let local_for_guard = self.storage_live_binding(\n+                block, binding.var_id, binding.span, WithinGuard);\n+            // Question: Why schedule drops if bindings are all\n+            // shared-&'s?  Answer: Because schedule_drop_for_binding\n+            // also emits StorageDead's for those locals.\n+            self.schedule_drop_for_binding(binding.var_id, binding.span, WithinGuard);\n+            match binding.binding_mode {\n+                BindingMode::ByValue => {\n+                    let rvalue = Rvalue::Ref(re_empty, BorrowKind::Shared, binding.source.clone());\n+                    self.cfg.push_assign(block, source_info, &local_for_guard, rvalue);\n+                }\n+                BindingMode::ByRef(region, borrow_kind) => {\n+                    // NOTE tricky business: For `ref id` and `ref mut\n+                    // id` patterns, we want `id` within the guard to\n+                    // correspond to a temp of type `& &T` or `& &mut\n+                    // T`, while within the arm body it will\n+                    // correspond to a temp of type `&T` or `&mut T`,\n+                    // as usual.\n+                    //\n+                    // But to inject the level of indirection, we need\n+                    // something to point to.\n+                    //\n+                    // So:\n+                    //\n+                    // 1. First set up the local for the arm body\n+                    //   (even though we have not yet evaluated the\n+                    //   guard itself),\n+                    //\n+                    // 2. Then setup the local for the guard, which is\n+                    //    just a reference to the local from step 1.\n+                    //\n+                    // Note that since we are setting up the local for\n+                    // the arm body a bit eagerly here (and likewise\n+                    // scheduling its drop code), we should *not* do\n+                    // it redundantly later on.\n+                    //\n+                    // While we could have kept track of this with a\n+                    // flag or collection of such bindings, the\n+                    // treatment of all of these cases is uniform, so\n+                    // we should be safe just avoiding the code\n+                    // without maintaining such state.)\n+                    let local_for_arm_body = self.storage_live_binding(\n+                        block, binding.var_id, binding.span, OutsideGuard);\n+                    self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n+\n+                    // rust-lang/rust#27282: this potentially mutable\n+                    // borrow may require a cast in the future to\n+                    // avoid conflicting with an implicit borrow of\n+                    // the whole match input; or maybe it just\n+                    // requires an extension of our two-phase borrows\n+                    // system. See discussion on rust-lang/rust#49870.\n+                    let rvalue = Rvalue::Ref(region, borrow_kind, binding.source.clone());\n+                    self.cfg.push_assign(block, source_info, &local_for_arm_body, rvalue);\n+                    let rvalue = Rvalue::Ref(region, BorrowKind::Shared, local_for_arm_body);\n+                    self.cfg.push_assign(block, source_info, &local_for_guard, rvalue);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn bind_matched_candidate_for_arm_body(&mut self,\n+                                           block: BasicBlock,\n+                                           bindings: &[Binding<'tcx>],\n+                                           already_initialized_state_for_refs: bool) {\n+        debug!(\"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}, \\\n+                already_initialized_state_for_refs={:?})\",\n+               block, bindings, already_initialized_state_for_refs);\n+\n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n+            if let BindingMode::ByRef(..) = binding.binding_mode {\n+                // See \"NOTE tricky business\" above\n+                if already_initialized_state_for_refs { continue; }\n+            }\n+\n             let source_info = self.source_info(binding.span);\n-            let local = self.storage_live_binding(block, binding.var_id, binding.span);\n-            self.schedule_drop_for_binding(binding.var_id, binding.span);\n+            let local = self.storage_live_binding(block, binding.var_id, binding.span,\n+                                                  OutsideGuard);\n+            self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n             let rvalue = match binding.binding_mode {\n-                BindingMode::ByValue =>\n-                    Rvalue::Use(self.consume_by_copy_or_move(binding.source)),\n-                BindingMode::ByRef(region, borrow_kind) =>\n-                    Rvalue::Ref(region, borrow_kind, binding.source),\n+                BindingMode::ByValue => {\n+                    Rvalue::Use(self.consume_by_copy_or_move(binding.source.clone()))\n+                }\n+                BindingMode::ByRef(region, borrow_kind) => {\n+                    Rvalue::Ref(region, borrow_kind, binding.source.clone())\n+                }\n             };\n             self.cfg.push_assign(block, source_info, &local, rvalue);\n         }\n     }\n \n+    /// Each binding (`ref mut var`/`ref var`/`mut var`/`var`, where\n+    /// the bound `var` has type `T` in the arm body) in a pattern\n+    /// maps to *two* locals. The first local is a binding for\n+    /// occurrences of `var` in the guard, which will all have type\n+    /// `&T`. The second local is a binding for occurrences of `var`\n+    /// in the arm body, which will have type `T`.\n     fn declare_binding(&mut self,\n                        source_info: SourceInfo,\n                        syntactic_scope: VisibilityScope,\n                        mutability: Mutability,\n                        name: Name,\n                        var_id: NodeId,\n-                       var_ty: Ty<'tcx>)\n-                       -> Local\n+                       var_ty: Ty<'tcx>,\n+                       has_guard: ArmHasGuard)\n     {\n         debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, source_info={:?}, \\\n                 syntactic_scope={:?})\",\n                var_id, name, var_ty, source_info, syntactic_scope);\n \n-        let var = self.local_decls.push(LocalDecl::<'tcx> {\n+        let tcx = self.hir.tcx();\n+        let for_arm_body = self.local_decls.push(LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty.clone(),\n             name: Some(name),\n@@ -842,10 +1068,21 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             internal: false,\n             is_user_variable: true,\n         });\n-        self.var_indices.insert(var_id, var);\n-\n-        debug!(\"declare_binding: var={:?}\", var);\n-\n-        var\n+        let locals = if has_guard.0 && tcx.all_pat_vars_are_implicit_refs_within_guards() {\n+            let for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n+                mutability,\n+                ty: tcx.mk_imm_ref(tcx.types.re_empty, var_ty),\n+                name: Some(name),\n+                source_info,\n+                syntactic_scope,\n+                internal: false,\n+                is_user_variable: true,\n+            });\n+            LocalsForNode::Two { for_guard, for_arm_body }\n+        } else {\n+            LocalsForNode::One(for_arm_body)\n+        };\n+        debug!(\"declare_binding: vars={:?}\", locals);\n+        self.var_indices.insert(var_id, locals);\n     }\n }"}, {"sha": "dd2a336af41d0a7d346e6793ccf064848f589369", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 79, "deletions": 3, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -291,8 +291,14 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     visibility_scope_info: IndexVec<VisibilityScope, VisibilityScopeInfo>,\n     visibility_scope: VisibilityScope,\n \n+    /// the guard-context: each time we build the guard expression for\n+    /// a match arm, we push onto this stack, and then pop when we\n+    /// finish building it.\n+    guard_context: Vec<GuardFrame>,\n+\n     /// Maps node ids of variable bindings to the `Local`s created for them.\n-    var_indices: NodeMap<Local>,\n+    /// (A match binding can have two locals; the 2nd is for the arm's guard.)\n+    var_indices: NodeMap<LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     unit_temp: Option<Place<'tcx>>,\n \n@@ -305,6 +311,74 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     cached_unreachable_block: Option<BasicBlock>,\n }\n \n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n+    fn is_bound_var_in_guard(&self, id: ast::NodeId) -> bool {\n+        self.guard_context.iter().any(|frame| frame.locals.iter().any(|local| local.id == id))\n+    }\n+\n+    fn var_local_id(&self, id: ast::NodeId, for_guard: ForGuard) -> Local {\n+        self.var_indices[&id].local_id(for_guard)\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum LocalsForNode {\n+    One(Local),\n+    Two { for_guard: Local, for_arm_body: Local },\n+}\n+\n+#[derive(Debug)]\n+struct GuardFrameLocal {\n+    id: ast::NodeId,\n+}\n+\n+impl GuardFrameLocal {\n+    fn new(id: ast::NodeId, _binding_mode: BindingMode) -> Self {\n+        GuardFrameLocal {\n+            id: id,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct GuardFrame {\n+    /// These are the id's of names that are bound by patterns of the\n+    /// arm of *this* guard.\n+    ///\n+    /// (Frames higher up the stack will have the id's bound in arms\n+    /// further out, such as in a case like:\n+    ///\n+    /// match E1 {\n+    ///      P1(id1) if (... (match E2 { P2(id2) if ... => B2 })) => B1,\n+    /// }\n+    ///\n+    /// here, when building for FIXME\n+    locals: Vec<GuardFrameLocal>,\n+}\n+\n+/// ForGuard is isomorphic to a boolean flag. It indicates whether we are\n+/// talking about the temp for a local binding for a use within a guard expression,\n+/// or a temp for use outside of a guard expressions.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum ForGuard {\n+    WithinGuard,\n+    OutsideGuard,\n+}\n+\n+impl LocalsForNode {\n+    fn local_id(&self, for_guard: ForGuard) -> Local {\n+        match (self, for_guard) {\n+            (&LocalsForNode::One(local_id), ForGuard::OutsideGuard) |\n+            (&LocalsForNode::Two { for_guard: local_id, .. }, ForGuard::WithinGuard) |\n+            (&LocalsForNode::Two { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) =>\n+                local_id,\n+\n+            (&LocalsForNode::One(_), ForGuard::WithinGuard) =>\n+                bug!(\"anything with one local should never be within a guard.\"),\n+        }\n+    }\n+}\n+\n struct CFG<'tcx> {\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n }\n@@ -548,6 +622,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             visibility_scopes: IndexVec::new(),\n             visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n             visibility_scope_info: IndexVec::new(),\n+            guard_context: vec![],\n             push_unsafe_count: 0,\n             unpushed_unsafe: safety,\n             breakable_scopes: vec![],\n@@ -636,11 +711,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // Don't introduce extra copies for simple bindings\n                     PatternKind::Binding { mutability, var, mode: BindingMode::ByValue, .. } => {\n                         self.local_decls[local].mutability = mutability;\n-                        self.var_indices.insert(var, local);\n+                        self.var_indices.insert(var, LocalsForNode::One(local));\n                     }\n                     _ => {\n                         scope = self.declare_bindings(scope, ast_body.span,\n-                                                      LintLevel::Inherited, &pattern);\n+                                                      LintLevel::Inherited, &pattern,\n+                                                      matches::ArmHasGuard(false));\n                         unpack!(block = self.place_into_pattern(block, pattern, &place));\n                     }\n                 }"}, {"sha": "9096ac1444cfc98854b6d3d3dfc2a3750157c1c1", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -73,8 +73,8 @@ pub type Node = BasicBlock;\n pub struct Edge { source: BasicBlock, index: usize }\n \n fn outgoing(mir: &Mir, bb: BasicBlock) -> Vec<Edge> {\n-    let succ_len = mir[bb].terminator().successors().len();\n-    (0..succ_len).map(|index| Edge { source: bb, index: index}).collect()\n+    mir[bb].terminator().successors().enumerate()\n+        .map(|(index, _)| Edge { source: bb, index: index}).collect()\n }\n \n impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n@@ -285,6 +285,6 @@ impl<'a, 'tcx, MWF, P> dot::GraphWalk<'a> for Graph<'a, 'tcx, MWF, P>\n \n     fn target(&self, edge: &Edge) -> Node {\n         let mir = self.mbcx.mir();\n-        mir[edge.source].terminator().successors()[edge.index]\n+        *mir[edge.source].terminator().successors().nth(edge.index).unwrap()\n     }\n }"}, {"sha": "098ad8e558fa968f26bf2c3d681e802fee5f5ae4", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -179,8 +179,14 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                     if let RegionKind::ReEmpty = region {\n                         // If the borrowed value dies before the borrow is used, the region for\n                         // the borrow can be empty. Don't track the borrow in that case.\n+                        debug!(\"Borrows::statement_effect_on_borrows \\\n+                                location: {:?} stmt: {:?} has empty region, killing {:?}\",\n+                               location, stmt.kind, index);\n                         sets.kill(&index);\n                         return\n+                    } else {\n+                        debug!(\"Borrows::statement_effect_on_borrows location: {:?} stmt: {:?}\",\n+                               location, stmt.kind);\n                     }\n \n                     assert!(self.borrow_set.region_map.get(region).unwrap_or_else(|| {"}, {"sha": "5890ea5c9d0c653cc8d186986dbb1c4dd303ade1", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -30,9 +30,9 @@ use syntax::ast::{self, LitKind};\n use syntax::attr;\n use syntax::symbol::Symbol;\n use rustc::hir;\n-use rustc_const_math::ConstFloat;\n use rustc_data_structures::sync::Lrc;\n use rustc::mir::interpret::{Value, PrimVal};\n+use hair::pattern::parse_float;\n \n #[derive(Clone)]\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -170,12 +170,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         neg: bool,\n     ) -> Literal<'tcx> {\n         trace!(\"const_eval_literal: {:#?}, {:?}, {:?}, {:?}\", lit, ty, sp, neg);\n-        let tcx = self.tcx.global_tcx();\n \n-        let parse_float = |num: &str, fty| -> ConstFloat {\n-            ConstFloat::from_str(num, fty).unwrap_or_else(|_| {\n+        let parse_float = |num, fty| -> Value {\n+            parse_float(num, fty, neg).unwrap_or_else(|_| {\n                 // FIXME(#31407) this is only necessary because float parsing is buggy\n-                tcx.sess.span_fatal(sp, \"could not evaluate float literal (see issue #31407)\");\n+                self.tcx.sess.span_fatal(sp, \"could not evaluate float literal (see issue #31407)\");\n             })\n         };\n \n@@ -213,26 +212,14 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             },\n             LitKind::Int(n, _) => Value::ByVal(PrimVal::Bytes(clamp(n))),\n             LitKind::Float(n, fty) => {\n-                let n = n.as_str();\n-                let mut f = parse_float(&n, fty);\n-                if neg {\n-                    f = -f;\n-                }\n-                let bits = f.bits;\n-                Value::ByVal(PrimVal::Bytes(bits))\n+                parse_float(n, fty)\n             }\n             LitKind::FloatUnsuffixed(n) => {\n                 let fty = match ty.sty {\n                     ty::TyFloat(fty) => fty,\n                     _ => bug!()\n                 };\n-                let n = n.as_str();\n-                let mut f = parse_float(&n, fty);\n-                if neg {\n-                    f = -f;\n-                }\n-                let bits = f.bits;\n-                Value::ByVal(PrimVal::Bytes(bits))\n+                parse_float(n, fty)\n             }\n             LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n             LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),"}, {"sha": "77bcd88cecb6ed0e6f362e6c8501f0126d0a8465", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -17,7 +17,7 @@ use super::{Pattern, PatternContext, PatternError, PatternKind};\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::mem_categorization::{cmt};\n+use rustc::middle::mem_categorization::cmt_;\n use rustc::middle::region;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -573,13 +573,13 @@ struct MutationChecker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n-    fn matched_pat(&mut self, _: &Pat, _: cmt, _: euv::MatchMode) {}\n-    fn consume(&mut self, _: ast::NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n-    fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}\n+    fn matched_pat(&mut self, _: &Pat, _: &cmt_, _: euv::MatchMode) {}\n+    fn consume(&mut self, _: ast::NodeId, _: Span, _: &cmt_, _: ConsumeMode) {}\n+    fn consume_pat(&mut self, _: &Pat, _: &cmt_, _: ConsumeMode) {}\n     fn borrow(&mut self,\n               _: ast::NodeId,\n               span: Span,\n-              _: cmt,\n+              _: &cmt_,\n               _: ty::Region<'tcx>,\n               kind:ty:: BorrowKind,\n               _: LoanCause) {\n@@ -594,7 +594,7 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n         }\n     }\n     fn decl_without_init(&mut self, _: ast::NodeId, _: Span) {}\n-    fn mutate(&mut self, _: ast::NodeId, span: Span, _: cmt, mode: MutateMode) {\n+    fn mutate(&mut self, _: ast::NodeId, span: Span, _: &cmt_, mode: MutateMode) {\n         match mode {\n             MutateMode::JustWrite | MutateMode::WriteAndRead => {\n                 struct_span_err!(self.cx.tcx.sess, span, E0302, \"cannot assign in a pattern guard\")"}, {"sha": "623e0de478bcaf6979361d138b70674651fbdd36", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -28,13 +28,13 @@ use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n \n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_const_math::ConstFloat;\n \n use std::cmp::Ordering;\n use std::fmt;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n+use syntax_pos::symbol::Symbol;\n \n #[derive(Clone, Debug)]\n pub enum PatternError {\n@@ -792,7 +792,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 ConstVal::Value(miri) => const_val_field(\n                     self.tcx, self.param_env, instance,\n                     variant_opt, field, miri, cv.ty,\n-                ).unwrap(),\n+                ).expect(\"field access failed\"),\n                 _ => bug!(\"{:#?} is not a valid adt\", cv),\n             };\n             self.const_to_pat(instance, val, id, span)\n@@ -1053,24 +1053,22 @@ pub fn compare_const_vals<'a, 'tcx>(\n     b: &ConstVal,\n     ty: Ty<'tcx>,\n ) -> Option<Ordering> {\n-    use rustc_const_math::ConstFloat;\n     trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n     use rustc::mir::interpret::{Value, PrimVal};\n     match (a, b) {\n         (&ConstVal::Value(Value::ByVal(PrimVal::Bytes(a))),\n          &ConstVal::Value(Value::ByVal(PrimVal::Bytes(b)))) => {\n+            use ::rustc_apfloat::Float;\n             match ty.sty {\n-                ty::TyFloat(ty) => {\n-                    let l = ConstFloat {\n-                        bits: a,\n-                        ty,\n-                    };\n-                    let r = ConstFloat {\n-                        bits: b,\n-                        ty,\n-                    };\n-                    // FIXME(oli-obk): report cmp errors?\n-                    l.try_cmp(r).ok()\n+                ty::TyFloat(ast::FloatTy::F32) => {\n+                    let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n+                    let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n+                    l.partial_cmp(&r)\n+                },\n+                ty::TyFloat(ast::FloatTy::F64) => {\n+                    let l = ::rustc_apfloat::ieee::Double::from_bits(a);\n+                    let r = ::rustc_apfloat::ieee::Double::from_bits(b);\n+                    l.partial_cmp(&r)\n                 },\n                 ty::TyInt(_) => {\n                     let a = interpret::sign_extend(tcx, a, ty).expect(\"layout error for TyInt\");\n@@ -1148,34 +1146,51 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             Value::ByVal(PrimVal::Bytes(n))\n         },\n         LitKind::Float(n, fty) => {\n-            let n = n.as_str();\n-            let mut f = parse_float(&n, fty)?;\n-            if neg {\n-                f = -f;\n-            }\n-            let bits = f.bits;\n-            Value::ByVal(PrimVal::Bytes(bits))\n+            parse_float(n, fty, neg)?\n         }\n         LitKind::FloatUnsuffixed(n) => {\n             let fty = match ty.sty {\n                 ty::TyFloat(fty) => fty,\n                 _ => bug!()\n             };\n-            let n = n.as_str();\n-            let mut f = parse_float(&n, fty)?;\n-            if neg {\n-                f = -f;\n-            }\n-            let bits = f.bits;\n-            Value::ByVal(PrimVal::Bytes(bits))\n+            parse_float(n, fty, neg)?\n         }\n         LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n         LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n     };\n     Ok(ConstVal::Value(lit))\n }\n \n-fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n-                     -> Result<ConstFloat, ()> {\n-    ConstFloat::from_str(num, fty).map_err(|_| ())\n+pub fn parse_float(\n+    num: Symbol,\n+    fty: ast::FloatTy,\n+    neg: bool,\n+) -> Result<Value, ()> {\n+    let num = num.as_str();\n+    use rustc_apfloat::ieee::{Single, Double};\n+    use rustc_apfloat::Float;\n+    let bits = match fty {\n+        ast::FloatTy::F32 => {\n+            num.parse::<f32>().map_err(|_| ())?;\n+            let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n+                panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n+            });\n+            if neg {\n+                f = -f;\n+            }\n+            f.to_bits()\n+        }\n+        ast::FloatTy::F64 => {\n+            num.parse::<f64>().map_err(|_| ())?;\n+            let mut f = num.parse::<Double>().unwrap_or_else(|e| {\n+                panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n+            });\n+            if neg {\n+                f = -f;\n+            }\n+            f.to_bits()\n+        }\n+    };\n+\n+    Ok(Value::ByVal(PrimVal::Bytes(bits)))\n }"}, {"sha": "002b5eb187db31ce36c2467687574938bb39b7d2", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -2,10 +2,9 @@ use rustc::ty::Ty;\n use rustc::ty::layout::LayoutOf;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n \n-use rustc_const_math::ConstFloat;\n+use rustc_apfloat::ieee::{Single, Double};\n use super::{EvalContext, Machine};\n use rustc::mir::interpret::{PrimVal, EvalResult, MemoryPointer, PointerArithmetic};\n-use rustc_apfloat::ieee::{Single, Double};\n use rustc_apfloat::Float;\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -50,8 +49,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 Ok(PrimVal::Bytes(v))\n             }\n \n-            TyFloat(fty) if signed => Ok(PrimVal::Bytes(ConstFloat::from_i128(v as i128, fty).bits)),\n-            TyFloat(fty) => Ok(PrimVal::Bytes(ConstFloat::from_u128(v, fty).bits)),\n+            TyFloat(FloatTy::F32) if signed => Ok(PrimVal::Bytes(Single::from_i128(v as i128).value.to_bits())),\n+            TyFloat(FloatTy::F64) if signed => Ok(PrimVal::Bytes(Double::from_i128(v as i128).value.to_bits())),\n+            TyFloat(FloatTy::F32) => Ok(PrimVal::Bytes(Single::from_u128(v).value.to_bits())),\n+            TyFloat(FloatTy::F64) => Ok(PrimVal::Bytes(Double::from_u128(v).value.to_bits())),\n \n             TyChar if v as u8 as u128 == v => Ok(PrimVal::Bytes(v)),\n             TyChar => err!(InvalidChar(v)),"}, {"sha": "dff9fa271aba52f99b6b03c7ad54dbc03889bbd0", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -263,7 +263,7 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     ) -> EvalResult<'tcx> {\n         let substs = instance.substs;\n \n-        let intrinsic_name = &ecx.tcx.item_name(instance.def_id())[..];\n+        let intrinsic_name = &ecx.tcx.item_name(instance.def_id()).as_str()[..];\n         match intrinsic_name {\n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);"}, {"sha": "bea29b6926aa63c1b48b1c6a5266a75b809885d7", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -513,7 +513,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     // it emits in debug mode) is performance, but it doesn't cost us any performance in miri.\n                     // If, however, the compiler ever starts transforming unchecked intrinsics into unchecked binops,\n                     // we have to go back to just ignoring the overflow here.\n-                    return err!(OverflowingMath);\n+                    return err!(Overflow(bin_op));\n                 }\n             }\n \n@@ -768,9 +768,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n         }\n \n-        if log_enabled!(::log::Level::Trace) {\n-            self.dump_local(dest);\n-        }\n+        self.dump_local(dest);\n \n         Ok(())\n     }\n@@ -919,8 +917,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 niche_start,\n                 ..\n             } => {\n-                let variants_start = niche_variants.start as u128;\n-                let variants_end = niche_variants.end as u128;\n+                let variants_start = *niche_variants.start() as u128;\n+                let variants_end = *niche_variants.end() as u128;\n                 match raw_discr {\n                     PrimVal::Ptr(_) => {\n                         assert!(niche_start == 0);\n@@ -986,7 +984,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 if variant_index != dataful_variant {\n                     let (niche_dest, niche) =\n                         self.place_field(dest, mir::Field::new(0), layout)?;\n-                    let niche_value = ((variant_index - niche_variants.start) as u128)\n+                    let niche_value = ((variant_index - niche_variants.start()) as u128)\n                         .wrapping_add(niche_start);\n                     self.write_primval(niche_dest, PrimVal::Bytes(niche_value), niche.ty)?;\n                 }\n@@ -1342,9 +1340,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         use syntax::ast::FloatTy;\n \n         let layout = self.layout_of(ty)?;\n-        // do the strongest layout check of the two\n-        let align = layout.align.max(ptr_align);\n-        self.memory.check_align(ptr, align)?;\n+        self.memory.check_align(ptr, ptr_align)?;\n \n         if layout.size.bytes() == 0 {\n             return Ok(Some(Value::ByVal(PrimVal::Undef)));\n@@ -1572,6 +1568,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub fn dump_local(&self, place: Place) {\n         // Debug output\n+        if !log_enabled!(::log::Level::Trace) {\n+            return;\n+        }\n         match place {\n             Place::Local { frame, local } => {\n                 let mut allocs = Vec::new();"}, {"sha": "7f8205b8327face1250c757888a8dbfaaf8039d7", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -334,11 +334,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     /// For debugging, print an allocation and all allocations it points to, recursively.\n     pub fn dump_alloc(&self, id: AllocId) {\n+        if !log_enabled!(::log::Level::Trace) {\n+            return;\n+        }\n         self.dump_allocs(vec![id]);\n     }\n \n     /// For debugging, print a list of allocations and all allocations they point to, recursively.\n     pub fn dump_allocs(&self, mut allocs: Vec<AllocId>) {\n+        if !log_enabled!(::log::Level::Trace) {\n+            return;\n+        }\n         use std::fmt::Write;\n         allocs.sort();\n         allocs.dedup();"}, {"sha": "ef6deab04775049ac2dc23fd1c3fd4ee8f32121d", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,9 +1,10 @@\n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc_const_math::ConstFloat;\n use syntax::ast::FloatTy;\n use std::cmp::Ordering;\n use rustc::ty::layout::LayoutOf;\n+use rustc_apfloat::ieee::{Double, Single};\n+use rustc_apfloat::Float;\n \n use super::{EvalContext, Place, Machine, ValTy};\n \n@@ -125,31 +126,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             return err!(Unimplemented(msg));\n         }\n \n-        let float_op = |op, l, r, ty| {\n-            let l = ConstFloat {\n-                bits: l,\n-                ty,\n-            };\n-            let r = ConstFloat {\n-                bits: r,\n-                ty,\n-            };\n-            match op {\n-                Eq => PrimVal::from_bool(l.try_cmp(r).unwrap() == Ordering::Equal),\n-                Ne => PrimVal::from_bool(l.try_cmp(r).unwrap() != Ordering::Equal),\n-                Lt => PrimVal::from_bool(l.try_cmp(r).unwrap() == Ordering::Less),\n-                Le => PrimVal::from_bool(l.try_cmp(r).unwrap() != Ordering::Greater),\n-                Gt => PrimVal::from_bool(l.try_cmp(r).unwrap() == Ordering::Greater),\n-                Ge => PrimVal::from_bool(l.try_cmp(r).unwrap() != Ordering::Less),\n-                Add => PrimVal::Bytes((l + r).unwrap().bits),\n-                Sub => PrimVal::Bytes((l - r).unwrap().bits),\n-                Mul => PrimVal::Bytes((l * r).unwrap().bits),\n-                Div => PrimVal::Bytes((l / r).unwrap().bits),\n-                Rem => PrimVal::Bytes((l % r).unwrap().bits),\n-                _ => bug!(\"invalid float op: `{:?}`\", op),\n-            }\n-        };\n-\n         if left_layout.abi.is_signed() {\n             let op: Option<fn(&i128, &i128) -> bool> = match bin_op {\n                 Lt => Some(i128::lt),\n@@ -164,7 +140,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 return Ok((PrimVal::from_bool(op(&l, &r)), false));\n             }\n             let op: Option<fn(i128, i128) -> (i128, bool)> = match bin_op {\n-                Rem | Div if r == 0 => return Ok((PrimVal::Bytes(l), true)),\n+                Div if r == 0 => return err!(DivisionByZero),\n+                Rem if r == 0 => return err!(RemainderByZero),\n                 Div => Some(i128::overflowing_div),\n                 Rem => Some(i128::overflowing_rem),\n                 Add => Some(i128::overflowing_add),\n@@ -199,7 +176,31 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n \n         if let ty::TyFloat(fty) = left_ty.sty {\n-            return Ok((float_op(bin_op, l, r, fty), false));\n+            macro_rules! float_math {\n+                ($ty:path) => {{\n+                    let l = <$ty>::from_bits(l);\n+                    let r = <$ty>::from_bits(r);\n+                    let val = match bin_op {\n+                        Eq => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) == Ordering::Equal),\n+                        Ne => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) != Ordering::Equal),\n+                        Lt => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) == Ordering::Less),\n+                        Le => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) != Ordering::Greater),\n+                        Gt => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) == Ordering::Greater),\n+                        Ge => PrimVal::from_bool(l.partial_cmp(&r).unwrap_or(Ordering::Greater) != Ordering::Less),\n+                        Add => PrimVal::Bytes((l + r).value.to_bits()),\n+                        Sub => PrimVal::Bytes((l - r).value.to_bits()),\n+                        Mul => PrimVal::Bytes((l * r).value.to_bits()),\n+                        Div => PrimVal::Bytes((l / r).value.to_bits()),\n+                        Rem => PrimVal::Bytes((l % r).value.to_bits()),\n+                        _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n+                    };\n+                    return Ok((val, false));\n+                }};\n+            }\n+            match fty {\n+                FloatTy::F32 => float_math!(Single),\n+                FloatTy::F64 => float_math!(Double),\n+            }\n         }\n \n         // only ints left\n@@ -221,7 +222,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     Add => u128::overflowing_add,\n                     Sub => u128::overflowing_sub,\n                     Mul => u128::overflowing_mul,\n-                    Rem | Div if r == 0 => return Ok((PrimVal::Bytes(l), true)),\n+                    Div if r == 0 => return err!(DivisionByZero),\n+                    Rem if r == 0 => return err!(RemainderByZero),\n                     Div => u128::overflowing_div,\n                     Rem => u128::overflowing_rem,\n                     _ => bug!(),\n@@ -269,7 +271,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             (Neg, ty::TyFloat(FloatTy::F32)) => Single::to_bits(-Single::from_bits(bytes)),\n             (Neg, ty::TyFloat(FloatTy::F64)) => Double::to_bits(-Double::from_bits(bytes)),\n \n-            (Neg, _) if bytes == (1 << (size - 1)) => return err!(OverflowingMath),\n+            (Neg, _) if bytes == (1 << (size - 1)) => return err!(OverflowNeg),\n             (Neg, _) => (-(bytes as i128)) as u128,\n         };\n "}, {"sha": "d03204bfab16d6cb384fc2eea11c42ad220b208a", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -219,9 +219,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         };\n \n-        if log_enabled!(::log::Level::Trace) {\n-            self.dump_local(place);\n-        }\n+        self.dump_local(place);\n \n         Ok(place)\n     }"}, {"sha": "0e0d91f472472d2583db5ea058e7ccfbbd132a8c", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -148,23 +148,24 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 if expected == cond_val {\n                     self.goto_block(target);\n                 } else {\n-                    use rustc::mir::AssertMessage::*;\n+                    use rustc::mir::interpret::EvalErrorKind::*;\n                     return match *msg {\n                         BoundsCheck { ref len, ref index } => {\n-                            let span = terminator.source_info.span;\n                             let len = self.eval_operand_to_primval(len)\n                                 .expect(\"can't eval len\")\n                                 .to_u64()?;\n                             let index = self.eval_operand_to_primval(index)\n                                 .expect(\"can't eval index\")\n                                 .to_u64()?;\n-                            err!(ArrayIndexOutOfBounds(span, len, index))\n-                        }\n-                        Math(ref err) => {\n-                            err!(Math(terminator.source_info.span, err.clone()))\n+                            err!(BoundsCheck { len, index })\n                         }\n+                        Overflow(op) => Err(Overflow(op).into()),\n+                        OverflowNeg => Err(OverflowNeg.into()),\n+                        DivisionByZero => Err(DivisionByZero.into()),\n+                        RemainderByZero => Err(RemainderByZero.into()),\n                         GeneratorResumedAfterReturn |\n                         GeneratorResumedAfterPanic => unimplemented!(),\n+                        _ => bug!(),\n                     };\n                 }\n             }"}, {"sha": "2545ba3a94af12215c6a4a15437304944a2ee358", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -24,16 +24,17 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(decl_macro)]\n-#![feature(dyn_trait)]\n+#![cfg_attr(stage0, feature(dyn_trait))]\n #![feature(fs_read_write)]\n #![feature(macro_vis_matcher)]\n #![feature(exhaustive_patterns)]\n #![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(nonzero)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n #![feature(crate_visibility_modifier)]\n #![feature(never_type)]\n+#![feature(specialization)]\n #![cfg_attr(stage0, feature(try_trait))]\n \n extern crate arena;\n@@ -50,8 +51,6 @@ extern crate rustc_errors;\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_target;\n-extern crate rustc_const_math;\n-extern crate core; // for NonZero\n extern crate log_settings;\n extern crate rustc_apfloat;\n extern crate byteorder;"}, {"sha": "9e43bed1b63af1958dfa089ffb22c4ecd22e5016", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -76,7 +76,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n             MonoItem::GlobalAsm(node_id) => {\n                 let def_id = tcx.hir.local_def_id(node_id);\n                 ty::SymbolName {\n-                    name: Symbol::intern(&format!(\"global_asm_{:?}\", def_id)).as_str()\n+                    name: Symbol::intern(&format!(\"global_asm_{:?}\", def_id)).as_interned_str()\n                 }\n             }\n         }"}, {"sha": "3a65cd4ea770b5664ae05aa9c0653706221caaef", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -146,7 +146,7 @@ pub trait CodegenUnitExt<'tcx> {\n     }\n \n     fn work_product_id(&self) -> WorkProductId {\n-        WorkProductId::from_cgu_name(self.name())\n+        WorkProductId::from_cgu_name(&self.name().as_str())\n     }\n \n     fn items_in_deterministic_order<'a>(&self,\n@@ -206,9 +206,9 @@ fn fallback_cgu_name(tcx: TyCtxt) -> InternedString {\n     const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n \n     if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n-        Symbol::intern(FALLBACK_CODEGEN_UNIT).as_str()\n+        Symbol::intern(FALLBACK_CODEGEN_UNIT).as_interned_str()\n     } else {\n-        Symbol::intern(&CodegenUnit::mangle_name(FALLBACK_CODEGEN_UNIT)).as_str()\n+        Symbol::intern(&CodegenUnit::mangle_name(FALLBACK_CODEGEN_UNIT)).as_interned_str()\n     }\n }\n \n@@ -740,7 +740,7 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         }\n                     }) {\n         cgu_name.push_str(\"-\");\n-        cgu_name.push_str(&part.data.as_interned_str());\n+        cgu_name.push_str(&part.data.as_interned_str().as_str());\n     }\n \n     if volatile {\n@@ -753,11 +753,11 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         CodegenUnit::mangle_name(&cgu_name)\n     };\n \n-    Symbol::intern(&cgu_name[..]).as_str()\n+    Symbol::intern(&cgu_name[..]).as_interned_str()\n }\n \n fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {\n-    Symbol::intern(&format!(\"{}{}\", crate_name, index)).as_str()\n+    Symbol::intern(&format!(\"{}{}\", crate_name, index)).as_interned_str()\n }\n \n fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -772,7 +772,7 @@ fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             debug!(\"CodegenUnit {}:\", cgu.name());\n \n             for (trans_item, linkage) in cgu.items() {\n-                let symbol_name = trans_item.symbol_name(tcx);\n+                let symbol_name = trans_item.symbol_name(tcx).name.as_str();\n                 let symbol_hash_start = symbol_name.rfind('h');\n                 let symbol_hash = symbol_hash_start.map(|i| &symbol_name[i ..])\n                                                    .unwrap_or(\"<no hash>\");"}, {"sha": "699a5b17435bd2c4161d8033eee349992cfc0d9f", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -210,7 +210,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if let Some(..) = ty {\n         let patch = {\n-            let param_env = tcx.param_env(def_id);\n+            let param_env = tcx.param_env(def_id).with_reveal_all();\n             let mut elaborator = DropShimElaborator {\n                 mir: &mir,\n                 patch: MirPatch::new(&mir),"}, {"sha": "2bf5a49c97e8ff31eaf648f27dc810065de63878", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     self.visibility_scope_info[source_info.scope].lint_root;\n                 self.register_violations(&[UnsafetyViolation {\n                     source_info,\n-                    description: Symbol::intern(\"borrow of packed field\").as_str(),\n+                    description: Symbol::intern(\"borrow of packed field\").as_interned_str(),\n                     kind: UnsafetyViolationKind::BorrowPacked(lint_root)\n                 }], &[]);\n             }\n@@ -214,7 +214,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         self.visibility_scope_info[source_info.scope].lint_root;\n                     self.register_violations(&[UnsafetyViolation {\n                         source_info,\n-                        description: Symbol::intern(\"use of extern static\").as_str(),\n+                        description: Symbol::intern(\"use of extern static\").as_interned_str(),\n                         kind: UnsafetyViolationKind::ExternStatic(lint_root)\n                     }], &[]);\n                 }\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         let source_info = self.source_info;\n         self.register_violations(&[UnsafetyViolation {\n             source_info,\n-            description: Symbol::intern(description).as_str(),\n+            description: Symbol::intern(description).as_interned_str(),\n             kind: UnsafetyViolationKind::General,\n         }], &[]);\n     }\n@@ -444,15 +444,15 @@ pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n                 struct_span_err!(\n                     tcx.sess, source_info.span, E0133,\n                     \"{} requires unsafe function or block\", description)\n-                    .span_label(source_info.span, &description[..])\n+                    .span_label(source_info.span, &description.as_str()[..])\n                     .emit();\n             }\n             UnsafetyViolationKind::ExternStatic(lint_node_id) => {\n                 tcx.lint_node(SAFE_EXTERN_STATICS,\n                               lint_node_id,\n                               source_info.span,\n                               &format!(\"{} requires unsafe function or \\\n-                                        block (error E0133)\", &description[..]));\n+                                        block (error E0133)\", &description.as_str()[..]));\n             }\n             UnsafetyViolationKind::BorrowPacked(lint_node_id) => {\n                 if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id) {\n@@ -462,7 +462,7 @@ pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n                                   lint_node_id,\n                                   source_info.span,\n                                   &format!(\"{} requires unsafe function or \\\n-                                            block (error E0133)\", &description[..]));\n+                                            block (error E0133)\", &description.as_str()[..]));\n                 }\n             }\n         }"}, {"sha": "e1db216b6bbbcfad1b1d15a9a696d79cc3325674", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -328,7 +328,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                         } else {\n                             if overflow {\n                                 use rustc::mir::interpret::EvalErrorKind;\n-                                let mut err = EvalErrorKind::OverflowingMath.into();\n+                                let mut err = EvalErrorKind::Overflow(op).into();\n                                 ecx.report(&mut err, false, Some(span));\n                                 return None;\n                             }\n@@ -478,12 +478,12 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                         .hir\n                         .as_local_node_id(self.source.def_id)\n                         .expect(\"some part of a failing const eval must be local\");\n-                    use rustc::mir::AssertMessage::*;\n+                    use rustc::mir::interpret::EvalErrorKind::*;\n                     let msg = match msg {\n-                        // Need proper const propagator for these\n-                        GeneratorResumedAfterReturn |\n-                        GeneratorResumedAfterPanic => return,\n-                        Math(ref err) => err.description().to_owned(),\n+                        Overflow(_) |\n+                        OverflowNeg |\n+                        DivisionByZero |\n+                        RemainderByZero => msg.description().to_owned(),\n                         BoundsCheck { ref len, ref index } => {\n                             let len = self.eval_operand(len).expect(\"len must be const\");\n                             let len = match len.0 {\n@@ -504,6 +504,8 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                                 index,\n                             )\n                         },\n+                        // Need proper const propagator for these\n+                        _ => return,\n                     };\n                     self.tcx.lint_node(\n                         ::rustc::lint::builtin::CONST_ERR,"}, {"sha": "fba60c7e8dc275db03a1e7adff5c86091239f710", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -29,7 +29,6 @@\n //! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n //! future.\n \n-use rustc::hir;\n use rustc::mir::{Constant, Local, LocalKind, Location, Place, Mir, Operand, Rvalue, StatementKind};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n@@ -41,26 +40,8 @@ pub struct CopyPropagation;\n impl MirPass for CopyPropagation {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          source: MirSource,\n+                          _source: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        // Don't run on constant MIR, because trans might not be able to\n-        // evaluate the modified MIR.\n-        // FIXME(eddyb) Remove check after miri is merged.\n-        let id = tcx.hir.as_local_node_id(source.def_id).unwrap();\n-        match (tcx.hir.body_owner_kind(id), source.promoted) {\n-            (_, Some(_)) |\n-            (hir::BodyOwnerKind::Const, _) |\n-            (hir::BodyOwnerKind::Static(_), _) => return,\n-\n-            (hir::BodyOwnerKind::Fn, _) => {\n-                if tcx.is_const_fn(source.def_id) {\n-                    // Don't run on const functions, as, again, trans might not be able to evaluate\n-                    // the optimized IR.\n-                    return\n-                }\n-            }\n-        }\n-\n         // We only run when the MIR optimization level is > 1.\n         // This avoids a slow pass, and messing up debug info.\n         if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {"}, {"sha": "8b2b9ef7e814d3c3ecb1381f6117b0d7edf5c89a", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir;\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -19,26 +18,8 @@ pub struct Deaggregator;\n impl MirPass for Deaggregator {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          source: MirSource,\n+                          _source: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        // Don't run on constant MIR, because trans might not be able to\n-        // evaluate the modified MIR.\n-        // FIXME(eddyb) Remove check after miri is merged.\n-        let id = tcx.hir.as_local_node_id(source.def_id).unwrap();\n-        match (tcx.hir.body_owner_kind(id), source.promoted) {\n-            (_, Some(_)) |\n-            (hir::BodyOwnerKind::Const, _) |\n-            (hir::BodyOwnerKind::Static(_), _) => return,\n-\n-            (hir::BodyOwnerKind::Fn, _) => {\n-                if tcx.is_const_fn(source.def_id) {\n-                    // Don't run on const functions, as, again, trans might not be able to evaluate\n-                    // the optimized IR.\n-                    return\n-                }\n-            }\n-        }\n-\n         let (basic_blocks, local_decls) = mir.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;\n         for bb in basic_blocks {"}, {"sha": "5397d18cdd720be1b0d185fe4359e88d10bb07d3", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -15,7 +15,6 @@ use dataflow::{on_all_children_bits, on_all_drop_children_bits};\n use dataflow::{drop_flag_effects_for_location, on_lookup_result_bits};\n use dataflow::MoveDataParamEnv;\n use dataflow::{self, do_dataflow, DebugFormatted};\n-use rustc::hir;\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n use rustc::middle::const_val::ConstVal;\n@@ -42,15 +41,8 @@ impl MirPass for ElaborateDrops {\n     {\n         debug!(\"elaborate_drops({:?} @ {:?})\", src, mir.span);\n \n-        // Don't run on constant MIR, because trans might not be able to\n-        // evaluate the modified MIR.\n-        // FIXME(eddyb) Remove check after miri is merged.\n         let id = tcx.hir.as_local_node_id(src.def_id).unwrap();\n-        match (tcx.hir.body_owner_kind(id), src.promoted) {\n-            (hir::BodyOwnerKind::Fn, None) => {},\n-            _ => return\n-        }\n-        let param_env = tcx.param_env(src.def_id);\n+        let param_env = tcx.param_env(src.def_id).with_reveal_all();\n         let move_data = MoveData::gather_moves(mir, tcx).unwrap();\n         let elaborate_patch = {\n             let mir = &*mir;\n@@ -558,7 +550,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn drop_flags_on_init(&mut self) {\n-        let loc = Location { block: START_BLOCK, statement_index: 0 };\n+        let loc = Location::START;\n         let span = self.patch.source_info_for_location(self.mir, loc).span;\n         let false_ = self.constant_bool(span, false);\n         for flag in self.drop_flags.values() {\n@@ -584,7 +576,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn drop_flags_for_args(&mut self) {\n-        let loc = Location { block: START_BLOCK, statement_index: 0 };\n+        let loc = Location::START;\n         dataflow::drop_flag_effects_for_function_entry(\n             self.tcx, self.mir, self.env, |path, ds| {\n                 self.set_drop_flag(loc, path, ds);"}, {"sha": "36735586e81175f950deb1e646fcce86d02655c4", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -738,12 +738,17 @@ fn create_generator_resume_function<'a, 'tcx>(\n \n     let mut cases = create_cases(mir, &transform, |point| Some(point.resume));\n \n+    use rustc::mir::interpret::EvalErrorKind::{\n+        GeneratorResumedAfterPanic,\n+        GeneratorResumedAfterReturn,\n+    };\n+\n     // Jump to the entry point on the 0 state\n     cases.insert(0, (0, BasicBlock::new(0)));\n     // Panic when resumed on the returned (1) state\n-    cases.insert(1, (1, insert_panic_block(tcx, mir, AssertMessage::GeneratorResumedAfterReturn)));\n+    cases.insert(1, (1, insert_panic_block(tcx, mir, GeneratorResumedAfterReturn)));\n     // Panic when resumed on the poisoned (2) state\n-    cases.insert(2, (2, insert_panic_block(tcx, mir, AssertMessage::GeneratorResumedAfterPanic)));\n+    cases.insert(2, (2, insert_panic_block(tcx, mir, GeneratorResumedAfterPanic)));\n \n     insert_switch(tcx, mir, cases, &transform, TerminatorKind::Unreachable);\n "}, {"sha": "ee6d42b1fe542fec83a961b49d02279fc2d840e4", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 4, "deletions": 65, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     continue;\n                 }\n \n-                let callee_mir = match ty::queries::optimized_mir::try_get(self.tcx,\n+                let callee_mir = match self.tcx.try_get_query::<ty::queries::optimized_mir>(\n                                                                            callsite.location.span,\n                                                                            callsite.callee) {\n                     Ok(callee_mir) if self.should_inline(callsite, callee_mir) => {\n@@ -330,7 +330,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             }\n \n             if !is_drop {\n-                for &succ in &term.successors()[..] {\n+                for &succ in term.successors() {\n                     work_list.push(succ);\n                 }\n             }\n@@ -379,8 +379,6 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n                 debug!(\"Inlined {:?} into {:?}\", callsite.callee, self.source);\n \n-                let is_box_free = Some(callsite.callee) == self.tcx.lang_items().box_free_fn();\n-\n                 let mut local_map = IndexVec::with_capacity(callee_mir.local_decls.len());\n                 let mut scope_map = IndexVec::with_capacity(callee_mir.visibility_scopes.len());\n                 let mut promoted_map = IndexVec::with_capacity(callee_mir.promoted.len());\n@@ -460,24 +458,8 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n                 let return_block = destination.1;\n \n-                let args : Vec<_> = if is_box_free {\n-                    assert!(args.len() == 1);\n-                    // box_free takes a Box, but is defined with a *mut T, inlining\n-                    // needs to generate the cast.\n-                    // FIXME: we should probably just generate correct MIR in the first place...\n-\n-                    let arg = if let Operand::Move(ref place) = args[0] {\n-                        place.clone()\n-                    } else {\n-                        bug!(\"Constant arg to \\\"box_free\\\"\");\n-                    };\n-\n-                    let ptr_ty = args[0].ty(caller_mir, self.tcx);\n-                    vec![self.cast_box_free_arg(arg, ptr_ty, &callsite, caller_mir)]\n-                } else {\n-                    // Copy the arguments if needed.\n-                    self.make_call_args(args, &callsite, caller_mir)\n-                };\n+                // Copy the arguments if needed.\n+                let args: Vec<_> = self.make_call_args(args, &callsite, caller_mir);\n \n                 let bb_len = caller_mir.basic_blocks().len();\n                 let mut integrator = Integrator {\n@@ -518,49 +500,6 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         }\n     }\n \n-    fn cast_box_free_arg(&self, arg: Place<'tcx>, ptr_ty: Ty<'tcx>,\n-                         callsite: &CallSite<'tcx>, caller_mir: &mut Mir<'tcx>) -> Local {\n-        let arg = Rvalue::Ref(\n-            self.tcx.types.re_erased,\n-            BorrowKind::Mut { allow_two_phase_borrow: false },\n-            arg.deref());\n-\n-        let ty = arg.ty(caller_mir, self.tcx);\n-        let ref_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n-        let ref_tmp = caller_mir.local_decls.push(ref_tmp);\n-        let ref_tmp = Place::Local(ref_tmp);\n-\n-        let ref_stmt = Statement {\n-            source_info: callsite.location,\n-            kind: StatementKind::Assign(ref_tmp.clone(), arg)\n-        };\n-\n-        caller_mir[callsite.bb]\n-            .statements.push(ref_stmt);\n-\n-        let pointee_ty = match ptr_ty.sty {\n-            ty::TyRawPtr(tm) | ty::TyRef(_, tm) => tm.ty,\n-            _ if ptr_ty.is_box() => ptr_ty.boxed_ty(),\n-            _ => bug!(\"Invalid type `{:?}` for call to box_free\", ptr_ty)\n-        };\n-        let ptr_ty = self.tcx.mk_mut_ptr(pointee_ty);\n-\n-        let raw_ptr = Rvalue::Cast(CastKind::Misc, Operand::Move(ref_tmp), ptr_ty);\n-\n-        let cast_tmp = LocalDecl::new_temp(ptr_ty, callsite.location.span);\n-        let cast_tmp = caller_mir.local_decls.push(cast_tmp);\n-\n-        let cast_stmt = Statement {\n-            source_info: callsite.location,\n-            kind: StatementKind::Assign(Place::Local(cast_tmp), raw_ptr)\n-        };\n-\n-        caller_mir[callsite.bb]\n-            .statements.push(cast_stmt);\n-\n-        cast_tmp\n-    }\n-\n     fn make_call_args(\n         &self,\n         args: Vec<Operand<'tcx>>,"}, {"sha": "4762c6aaa27cc8143e78f65ffe3058c493a67d62", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -868,7 +868,7 @@ This does not pose a problem by itself because they can't be accessed directly.\"\n                     Abi::RustIntrinsic |\n                     Abi::PlatformIntrinsic => {\n                         assert!(!self.tcx.is_const_fn(def_id));\n-                        match &self.tcx.item_name(def_id)[..] {\n+                        match &self.tcx.item_name(def_id).as_str()[..] {\n                             \"size_of\" | \"min_align_of\" | \"type_id\" => is_const_fn = Some(def_id),\n \n                             name if name.starts_with(\"simd_shuffle\") => {"}, {"sha": "bcc8fef18f013362135bb6b2162a00907215609d", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -78,7 +78,7 @@ impl RemoveNoopLandingPads {\n             TerminatorKind::SwitchInt { .. } |\n             TerminatorKind::FalseEdges { .. } |\n             TerminatorKind::FalseUnwind { .. } => {\n-                terminator.successors().iter().all(|succ| {\n+                terminator.successors().all(|succ| {\n                     nop_landing_pads.contains(succ.index())\n                 })\n             },"}, {"sha": "691fdd130e551f611237970ec47cca9976d00545", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n \n         for (_, data) in traversal::preorder(mir) {\n             if let Some(ref term) = data.terminator {\n-                for &tgt in term.successors().iter() {\n+                for &tgt in term.successors() {\n                     pred_count[tgt] += 1;\n                 }\n             }\n@@ -219,10 +219,10 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n         };\n \n         let first_succ = {\n-            let successors = terminator.successors();\n-            if let Some(&first_succ) = terminator.successors().get(0) {\n-                if successors.iter().all(|s| *s == first_succ) {\n-                    self.pred_count[first_succ] -= (successors.len()-1) as u32;\n+            if let Some(&first_succ) = terminator.successors().nth(0) {\n+                if terminator.successors().all(|s| *s == first_succ) {\n+                    let count = terminator.successors().count();\n+                    self.pred_count[first_succ] -= (count - 1) as u32;\n                     first_succ\n                 } else {\n                     return false"}, {"sha": "4b7c581d3c8ff3404a640f3c2c8ea2d40b0cf81f", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -13,6 +13,7 @@ use rustc::hir;\n use rustc::mir::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items;\n+use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::util::IntTypeExt;\n@@ -206,6 +207,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             let field = Field::new(i);\n             let subpath = self.elaborator.field_subpath(variant_path, field);\n \n+            assert_eq!(self.elaborator.param_env().reveal, Reveal::All);\n             let field_ty = self.tcx().normalize_erasing_regions(\n                 self.elaborator.param_env(),\n                 f.ty(self.tcx(), substs),\n@@ -337,18 +339,19 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         self.drop_ladder(fields, succ, unwind).0\n     }\n \n-    fn open_drop_for_box<'a>(&mut self, ty: Ty<'tcx>) -> BasicBlock\n+    fn open_drop_for_box<'a>(&mut self, adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n+                             -> BasicBlock\n     {\n-        debug!(\"open_drop_for_box({:?}, {:?})\", self, ty);\n+        debug!(\"open_drop_for_box({:?}, {:?}, {:?})\", self, adt, substs);\n \n         let interior = self.place.clone().deref();\n         let interior_path = self.elaborator.deref_subpath(self.path);\n \n         let succ = self.succ; // FIXME(#43234)\n         let unwind = self.unwind;\n-        let succ = self.box_free_block(ty, succ, unwind);\n+        let succ = self.box_free_block(adt, substs, succ, unwind);\n         let unwind_succ = self.unwind.map(|unwind| {\n-            self.box_free_block(ty, unwind, Unwind::InCleanup)\n+            self.box_free_block(adt, substs, unwind, Unwind::InCleanup)\n         });\n \n         self.drop_subpath(&interior, interior_path, succ, unwind_succ)\n@@ -791,11 +794,12 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             ty::TyTuple(tys) => {\n                 self.open_drop_for_tuple(tys)\n             }\n-            ty::TyAdt(def, _) if def.is_box() => {\n-                self.open_drop_for_box(ty.boxed_ty())\n-            }\n             ty::TyAdt(def, substs) => {\n-                self.open_drop_for_adt(def, substs)\n+                if def.is_box() {\n+                    self.open_drop_for_box(def, substs)\n+                } else {\n+                    self.open_drop_for_adt(def, substs)\n+                }\n             }\n             ty::TyDynamic(..) => {\n                 let unwind = self.unwind; // FIXME(#43234)\n@@ -858,28 +862,34 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n     fn box_free_block<'a>(\n         &mut self,\n-        ty: Ty<'tcx>,\n+        adt: &'tcx ty::AdtDef,\n+        substs: &'tcx Substs<'tcx>,\n         target: BasicBlock,\n         unwind: Unwind,\n     ) -> BasicBlock {\n-        let block = self.unelaborated_free_block(ty, target, unwind);\n+        let block = self.unelaborated_free_block(adt, substs, target, unwind);\n         self.drop_flag_test_block(block, target, unwind)\n     }\n \n     fn unelaborated_free_block<'a>(\n         &mut self,\n-        ty: Ty<'tcx>,\n+        adt: &'tcx ty::AdtDef,\n+        substs: &'tcx Substs<'tcx>,\n         target: BasicBlock,\n         unwind: Unwind\n     ) -> BasicBlock {\n         let tcx = self.tcx();\n         let unit_temp = Place::Local(self.new_temp(tcx.mk_nil()));\n         let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n-        let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n+        let args = adt.variants[0].fields.iter().enumerate().map(|(i, f)| {\n+            let field = Field::new(i);\n+            let field_ty = f.ty(self.tcx(), substs);\n+            Operand::Move(self.place.clone().field(field, field_ty))\n+        }).collect();\n \n         let call = TerminatorKind::Call {\n             func: Operand::function_handle(tcx, free_func, substs, self.source_info.span),\n-            args: vec![Operand::Move(self.place.clone())],\n+            args: args,\n             destination: Some((unit_temp, target)),\n             cleanup: None\n         }; // FIXME(#43234)"}, {"sha": "22e2b1b0b09c9945d6a313d9f7f764502e9f3472", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -125,7 +125,7 @@ fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result\n     let terminator = mir[source].terminator();\n     let labels = terminator.kind.fmt_successor_labels();\n \n-    for (&target, label) in terminator.successors().iter().zip(labels) {\n+    for (&target, label) in terminator.successors().zip(labels) {\n         writeln!(w, r#\"    {} -> {} [label=\"{}\"];\"#, node(source), node(target), label)?;\n     }\n "}, {"sha": "cfb1a2cd28bcc1a115322cc3555a5632edcf915f", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -138,7 +138,7 @@ pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>, mode: LivenessMode) -> Liveness\n         for b in mir.basic_blocks().indices().rev() {\n             // outs[b] = \u222a {ins of successors}\n             bits.clear();\n-            for &successor in mir.basic_blocks()[b].terminator().successors().into_iter() {\n+            for &successor in mir.basic_blocks()[b].terminator().successors() {\n                 bits.union(&ins[successor]);\n             }\n             outs[b].clone_from(&bits);"}, {"sha": "2babb93eedbcfb68732f7b1c821bb6a1bdf15a49", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -12,7 +12,6 @@ crate-type = [\"dylib\"]\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n rustc_mir = { path = \"../librustc_mir\"}\n-rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "b6b5edc094003c2215a26cf031804c650bf865d5", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -23,7 +23,6 @@\n #[macro_use]\n extern crate rustc;\n extern crate rustc_mir;\n-extern crate rustc_const_math;\n extern crate rustc_data_structures;\n \n #[macro_use]"}, {"sha": "45c6e89321d044934c0073ba092fbf951406e9ae", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -18,6 +18,7 @@ use rustc::mir::{Place, PlaceElem, PlaceProjection};\n use rustc::mir::{Mir, Operand, ProjectionElem};\n use rustc::mir::{Rvalue, SourceInfo, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind, VisibilityScope, VisibilityScopeData};\n+use rustc::mir::interpret::EvalErrorKind;\n use rustc::mir::visit as mir_visit;\n use rustc::ty::{self, ClosureSubsts, TyCtxt};\n use rustc::util::nodemap::{FxHashMap};\n@@ -133,14 +134,18 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n                             location: Location) {\n         self.record(\"AssertMessage\", msg);\n         self.record(match *msg {\n-            AssertMessage::BoundsCheck { .. } => \"AssertMessage::BoundsCheck\",\n-            AssertMessage::Math(..) => \"AssertMessage::Math\",\n-            AssertMessage::GeneratorResumedAfterReturn => {\n+            EvalErrorKind::BoundsCheck { .. } => \"AssertMessage::BoundsCheck\",\n+            EvalErrorKind::Overflow(..) => \"AssertMessage::Overflow\",\n+            EvalErrorKind::OverflowNeg => \"AssertMessage::OverflowNeg\",\n+            EvalErrorKind::DivisionByZero => \"AssertMessage::DivisionByZero\",\n+            EvalErrorKind::RemainderByZero => \"AssertMessage::RemainderByZero\",\n+            EvalErrorKind::GeneratorResumedAfterReturn => {\n                 \"AssertMessage::GeneratorResumedAfterReturn\"\n             }\n-            AssertMessage::GeneratorResumedAfterPanic => {\n+            EvalErrorKind::GeneratorResumedAfterPanic => {\n                 \"AssertMessage::GeneratorResumedAfterPanic\"\n             }\n+            _ => bug!(),\n         }, msg);\n         self.super_assert_message(msg, location);\n     }"}, {"sha": "3a577341f7e01b5230494a7bb68d701ddbacaa4e", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -468,13 +468,13 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,\n                _consume_span: Span,\n-               _cmt: mc::cmt,\n+               _cmt: &mc::cmt_,\n                _mode: euv::ConsumeMode) {}\n \n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               _borrow_span: Span,\n-              cmt: mc::cmt<'tcx>,\n+              cmt: &mc::cmt_<'tcx>,\n               _loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause) {\n@@ -489,7 +489,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n             _ => {}\n         }\n \n-        let mut cur = &cmt;\n+        let mut cur = cmt;\n         loop {\n             match cur.cat {\n                 Categorization::Rvalue(..) => {\n@@ -521,11 +521,11 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n     fn mutate(&mut self,\n               _assignment_id: ast::NodeId,\n               _assignment_span: Span,\n-              _assignee_cmt: mc::cmt,\n+              _assignee_cmt: &mc::cmt_,\n               _mode: euv::MutateMode) {\n     }\n \n-    fn matched_pat(&mut self, _: &hir::Pat, _: mc::cmt, _: euv::MatchMode) {}\n+    fn matched_pat(&mut self, _: &hir::Pat, _: &mc::cmt_, _: euv::MatchMode) {}\n \n-    fn consume_pat(&mut self, _consume_pat: &hir::Pat, _cmt: mc::cmt, _mode: euv::ConsumeMode) {}\n+    fn consume_pat(&mut self, _consume_pat: &hir::Pat, _cmt: &mc::cmt_, _mode: euv::ConsumeMode) {}\n }"}, {"sha": "348aa6a7cef4c7678c85c7e43dde9ca7ea9aef43", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -65,7 +65,6 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(rustc_diagnostic_macros)]\n-#![feature(staged_api)]\n \n #[macro_use] extern crate syntax;\n "}, {"sha": "7e3c411c1d2474d920d3cd2806dbde6672e4a86b", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -128,8 +128,6 @@ impl<'a> Registry<'a> {\n     /// This can be used in place of `register_syntax_extension` to register legacy custom derives\n     /// (i.e. attribute syntax extensions whose name begins with `derive_`). Legacy custom\n     /// derives defined by this function do not trigger deprecation warnings when used.\n-    #[unstable(feature = \"rustc_private\", issue = \"27812\")]\n-    #[rustc_deprecated(since = \"1.15.0\", reason = \"replaced by macros 1.1 (RFC 1861)\")]\n     pub fn register_custom_derive(&mut self, name: ast::Name, extension: SyntaxExtension) {\n         assert!(name.as_str().starts_with(\"derive_\"));\n         self.whitelisted_custom_derives.push(name);"}, {"sha": "ef5cc95828372f46f5499c65913324a001a3b11f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -17,7 +17,7 @@ use macros::{InvocationData, LegacyScope};\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use {Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n-use {Resolver, ResolverArenas};\n+use {PerNS, Resolver, ResolverArenas};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n@@ -41,7 +41,6 @@ use syntax::ext::tt::macro_rules;\n use syntax::parse::token::{self, Token};\n use syntax::std_inject::injected_crate_name;\n use syntax::symbol::keywords;\n-use syntax::symbol::Symbol;\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -72,7 +71,6 @@ impl<'a> ToNameBinding<'a> for (Def, ty::Visibility, Span, Mark) {\n struct LegacyMacroImports {\n     import_all: Option<Span>,\n     imports: Vec<(Name, Span)>,\n-    reexports: Vec<(Name, Span)>,\n }\n \n impl<'a> Resolver<'a> {\n@@ -176,7 +174,11 @@ impl<'a> Resolver<'a> {\n                 let subclass = SingleImport {\n                     target: ident,\n                     source,\n-                    result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n+                    result: PerNS {\n+                        type_ns: Cell::new(Err(Undetermined)),\n+                        value_ns: Cell::new(Err(Undetermined)),\n+                        macro_ns: Cell::new(Err(Undetermined)),\n+                    },\n                     type_ns_only,\n                 };\n                 self.add_import_directive(\n@@ -544,14 +546,14 @@ impl<'a> Resolver<'a> {\n         }\n \n         let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n-            (self.cstore.crate_name_untracked(def_id.krate).as_str(), None)\n+            (self.cstore.crate_name_untracked(def_id.krate).as_interned_str(), None)\n         } else {\n             let def_key = self.cstore.def_key(def_id);\n             (def_key.disambiguated_data.data.get_opt_name().unwrap(),\n              Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n         };\n \n-        let kind = ModuleKind::Def(Def::Mod(def_id), Symbol::intern(&name));\n+        let kind = ModuleKind::Def(Def::Mod(def_id), name.as_symbol());\n         let module =\n             self.arenas.alloc_module(ModuleData::new(parent, kind, def_id, Mark::root(), DUMMY_SP));\n         self.extern_module_map.insert((def_id, macros_only), module);\n@@ -622,7 +624,7 @@ impl<'a> Resolver<'a> {\n         let legacy_imports = self.legacy_macro_imports(&item.attrs);\n         let mut used = legacy_imports != LegacyMacroImports::default();\n \n-        // `#[macro_use]` and `#[macro_reexport]` are only allowed at the crate root.\n+        // `#[macro_use]` is only allowed at the crate root.\n         if self.current_module.parent.is_some() && used {\n             span_err!(self.session, item.span, E0468,\n                       \"an `extern crate` loading macros must be at the crate root\");\n@@ -670,17 +672,6 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n         }\n-        for (name, span) in legacy_imports.reexports {\n-            self.cstore.export_macros_untracked(module.def_id().unwrap().krate);\n-            let ident = Ident::with_empty_ctxt(name);\n-            let result = self.resolve_ident_in_module(module, ident, MacroNS, false, false, span);\n-            if let Ok(binding) = result {\n-                let (def, vis) = (binding.def(), binding.vis);\n-                self.macro_exports.push(Export { ident, def, vis, span, is_import: true });\n-            } else {\n-                span_err!(self.session, span, E0470, \"re-exported macro not found\");\n-            }\n-        }\n         used\n     }\n \n@@ -715,28 +706,13 @@ impl<'a> Resolver<'a> {\n                 match attr.meta_item_list() {\n                     Some(names) => for attr in names {\n                         if let Some(word) = attr.word() {\n-                            imports.imports.push((word.ident.name, attr.span()));\n+                            imports.imports.push((word.name(), attr.span()));\n                         } else {\n                             span_err!(self.session, attr.span(), E0466, \"bad macro import\");\n                         }\n                     },\n                     None => imports.import_all = Some(attr.span),\n                 }\n-            } else if attr.check_name(\"macro_reexport\") {\n-                let bad_macro_reexport = |this: &mut Self, span| {\n-                    span_err!(this.session, span, E0467, \"bad macro re-export\");\n-                };\n-                if let Some(names) = attr.meta_item_list() {\n-                    for attr in names {\n-                        if let Some(word) = attr.word() {\n-                            imports.reexports.push((word.ident.name, attr.span()));\n-                        } else {\n-                            bad_macro_reexport(self, attr.span());\n-                        }\n-                    }\n-                } else {\n-                    bad_macro_reexport(self, attr.span());\n-                }\n             }\n         }\n         imports"}, {"sha": "232a32deb864ea456b32657417a03bfe29512f06", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 71, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1395,35 +1395,6 @@ If you would like to import all exported macros, write `macro_use` with no\n arguments.\n \"##,\n \n-E0467: r##\"\n-Macro re-export declarations were empty or malformed.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0467\n-#[macro_reexport]                    // error: no macros listed for export\n-extern crate core as macros_for_good;\n-\n-#[macro_reexport(fun_macro = \"foo\")] // error: not a macro identifier\n-extern crate core as other_macros_for_good;\n-```\n-\n-This is a syntax error at the level of attribute declarations.\n-\n-Currently, `macro_reexport` requires at least one macro name to be listed.\n-Unlike `macro_use`, listing no names does not re-export all macros from the\n-given crate.\n-\n-Decide which macros you would like to export and list them properly.\n-\n-These are proper re-export declarations:\n-\n-```ignore (cannot-doctest-multicrate-project)\n-#[macro_reexport(some_macro, another_macro)]\n-extern crate macros_for_good;\n-```\n-\"##,\n-\n E0468: r##\"\n A non-root module attempts to import macros from another crate.\n \n@@ -1496,48 +1467,6 @@ extern crate some_crate; //ok!\n ```\n \"##,\n \n-E0470: r##\"\n-A macro listed for re-export was not found.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0470\n-#[macro_reexport(drink, be_merry)]\n-extern crate alloc;\n-\n-fn main() {\n-    // ...\n-}\n-```\n-\n-Either the listed macro is not contained in the imported crate, or it is not\n-exported from the given crate.\n-\n-This could be caused by a typo. Did you misspell the macro's name?\n-\n-Double-check the names of the macros listed for re-export, and that the crate\n-in question exports them.\n-\n-A working version:\n-\n-```ignore (cannot-doctest-multicrate-project)\n-// In some_crate crate:\n-#[macro_export]\n-macro_rules! eat {\n-    ...\n-}\n-\n-#[macro_export]\n-macro_rules! drink {\n-    ...\n-}\n-\n-// In your_crate:\n-#[macro_reexport(eat, drink)]\n-extern crate some_crate;\n-```\n-\"##,\n-\n E0530: r##\"\n A binding shadowed something it shouldn't.\n \n@@ -1715,6 +1644,8 @@ register_diagnostics! {\n //  E0421, merged into 531\n     E0531, // unresolved pattern path kind `name`\n //  E0427, merged into 530\n+//  E0467, removed\n+//  E0470, removed\n     E0573,\n     E0574,\n     E0575,"}, {"sha": "d4b212a15d82f9ba637f3337f9431303448e3a42", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -700,7 +700,7 @@ pub enum Namespace {\n pub struct PerNS<T> {\n     value_ns: T,\n     type_ns: T,\n-    macro_ns: Option<T>,\n+    macro_ns: T,\n }\n \n impl<T> ::std::ops::Index<Namespace> for PerNS<T> {\n@@ -709,7 +709,7 @@ impl<T> ::std::ops::Index<Namespace> for PerNS<T> {\n         match ns {\n             ValueNS => &self.value_ns,\n             TypeNS => &self.type_ns,\n-            MacroNS => self.macro_ns.as_ref().unwrap(),\n+            MacroNS => &self.macro_ns,\n         }\n     }\n }\n@@ -719,7 +719,7 @@ impl<T> ::std::ops::IndexMut<Namespace> for PerNS<T> {\n         match ns {\n             ValueNS => &mut self.value_ns,\n             TypeNS => &mut self.type_ns,\n-            MacroNS => self.macro_ns.as_mut().unwrap(),\n+            MacroNS => &mut self.macro_ns,\n         }\n     }\n }\n@@ -1407,6 +1407,7 @@ pub struct Resolver<'a> {\n     graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n+    extern_prelude: FxHashSet<Name>,\n \n     /// n.b. This is used only for better diagnostics, not name resolution itself.\n     has_self: FxHashSet<DefId>,\n@@ -1715,6 +1716,7 @@ impl<'a> Resolver<'a> {\n             // AST.\n             graph_root,\n             prelude: None,\n+            extern_prelude: session.opts.externs.iter().map(|kv| Symbol::intern(kv.0)).collect(),\n \n             has_self: FxHashSet(),\n             field_names: FxHashMap(),\n@@ -1726,7 +1728,7 @@ impl<'a> Resolver<'a> {\n             ribs: PerNS {\n                 value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n                 type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                macro_ns: Some(vec![Rib::new(ModuleRibKind(graph_root))]),\n+                macro_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n             },\n             label_ribs: Vec::new(),\n \n@@ -1806,14 +1808,11 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Runs the function on each namespace.\n-    fn per_ns<T, F: FnMut(&mut Self, Namespace) -> T>(&mut self, mut f: F) -> PerNS<T> {\n-        PerNS {\n-            type_ns: f(self, TypeNS),\n-            value_ns: f(self, ValueNS),\n-            macro_ns: match self.use_extern_macros {\n-                true => Some(f(self, MacroNS)),\n-                false => None,\n-            },\n+    fn per_ns<F: FnMut(&mut Self, Namespace)>(&mut self, mut f: F) {\n+        f(self, TypeNS);\n+        f(self, ValueNS);\n+        if self.use_extern_macros {\n+            f(self, MacroNS);\n         }\n     }\n \n@@ -1970,13 +1969,32 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        match self.prelude {\n-            Some(prelude) if !module.no_implicit_prelude => {\n-                self.resolve_ident_in_module_unadjusted(prelude, ident, ns, false, false, path_span)\n-                    .ok().map(LexicalScopeBinding::Item)\n+        if !module.no_implicit_prelude {\n+            // `record_used` means that we don't try to load crates during speculative resolution\n+            if record_used && ns == TypeNS && self.extern_prelude.contains(&ident.name) {\n+                if !self.session.features_untracked().extern_prelude {\n+                    feature_err(&self.session.parse_sess, \"extern_prelude\",\n+                                ident.span, GateIssue::Language,\n+                                \"access to extern crates through prelude is experimental\").emit();\n+                }\n+\n+                let crate_id = self.crate_loader.process_path_extern(ident.name, ident.span);\n+                let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n+                self.populate_module_if_necessary(crate_root);\n+\n+                let binding = (crate_root, ty::Visibility::Public,\n+                               ident.span, Mark::root()).to_name_binding(self.arenas);\n+                return Some(LexicalScopeBinding::Item(binding));\n+            }\n+            if let Some(prelude) = self.prelude {\n+                if let Ok(binding) = self.resolve_ident_in_module_unadjusted(prelude, ident, ns,\n+                                                                        false, false, path_span) {\n+                    return Some(LexicalScopeBinding::Item(binding));\n+                }\n             }\n-            _ => None,\n         }\n+\n+        None\n     }\n \n     fn hygienic_lexical_parent(&mut self, mut module: Module<'a>, span: &mut Span)\n@@ -3587,8 +3605,9 @@ impl<'a> Resolver<'a> {\n                         // We can see through blocks\n                     } else {\n                         // Items from the prelude\n-                        if let Some(prelude) = self.prelude {\n-                            if !module.no_implicit_prelude {\n+                        if !module.no_implicit_prelude {\n+                            names.extend(self.extern_prelude.iter().cloned());\n+                            if let Some(prelude) = self.prelude {\n                                 add_module_candidates(prelude, &mut names);\n                             }\n                         }"}, {"sha": "4afc621ad8b3e2751c8d6cccd2daac8ef9c2e51b", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -206,10 +206,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n-    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>)\n+    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>, allow_derive: bool)\n                               -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n-            let name = unwrap_or!(attrs[i].name(), continue);\n+            let name = attrs[i].name();\n \n             if self.session.plugin_attributes.borrow().iter()\n                     .any(|&(ref attr_nm, _)| name == &**attr_nm) {\n@@ -227,9 +227,11 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n         }\n \n+        if !allow_derive { return None }\n+\n         // Check for legacy derives\n         for i in 0..attrs.len() {\n-            let name = unwrap_or!(attrs[i].name(), continue);\n+            let name = attrs[i].name();\n \n             if name == \"derive\" {\n                 let result = attrs[i].parse_list(&self.session.parse_sess, |parser| {\n@@ -397,7 +399,7 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_macro_to_def(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n                             -> Result<Def, Determinacy> {\n-        if path.segments.len() > 1 {\n+        if kind != MacroKind::Bang && path.segments.len() > 1 {\n             if !self.session.features_untracked().proc_macro_path_invoc {\n                 emit_feature_err(\n                     &self.session.parse_sess,\n@@ -409,6 +411,7 @@ impl<'a> Resolver<'a> {\n                 );\n             }\n         }\n+\n         let def = self.resolve_macro_to_def_inner(scope, path, kind, force);\n         if def != Err(Determinacy::Undetermined) {\n             // Do not report duplicated errors on every undetermined resolution."}, {"sha": "17aa510b565e90805ea2ae54cd31d8b14f80f2ba", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -33,7 +33,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n use std::cell::{Cell, RefCell};\n-use std::mem;\n+use std::{mem, ptr};\n \n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n@@ -89,6 +89,8 @@ enum SingleImports<'a> {\n     None,\n     /// Only the given single import can define the name in the namespace.\n     MaybeOne(&'a ImportDirective<'a>),\n+    /// Only one of these two single imports can define the name in the namespace.\n+    MaybeTwo(&'a ImportDirective<'a>, &'a ImportDirective<'a>),\n     /// At least one single import will define the name in the namespace.\n     AtLeastOne,\n }\n@@ -101,21 +103,28 @@ impl<'a> Default for SingleImports<'a> {\n }\n \n impl<'a> SingleImports<'a> {\n-    fn add_directive(&mut self, directive: &'a ImportDirective<'a>) {\n+    fn add_directive(&mut self, directive: &'a ImportDirective<'a>, use_extern_macros: bool) {\n         match *self {\n             SingleImports::None => *self = SingleImports::MaybeOne(directive),\n-            // If two single imports can define the name in the namespace, we can assume that at\n-            // least one of them will define it since otherwise both would have to define only one\n-            // namespace, leading to a duplicate error.\n-            SingleImports::MaybeOne(_) => *self = SingleImports::AtLeastOne,\n+            SingleImports::MaybeOne(directive_one) => *self = if use_extern_macros {\n+                SingleImports::MaybeTwo(directive_one, directive)\n+            } else {\n+                SingleImports::AtLeastOne\n+            },\n+            // If three single imports can define the name in the namespace, we can assume that at\n+            // least one of them will define it since otherwise we'd get duplicate errors in one of\n+            // other namespaces.\n+            SingleImports::MaybeTwo(..) => *self = SingleImports::AtLeastOne,\n             SingleImports::AtLeastOne => {}\n         };\n     }\n \n-    fn directive_failed(&mut self) {\n+    fn directive_failed(&mut self, dir: &'a ImportDirective<'a>) {\n         match *self {\n             SingleImports::None => unreachable!(),\n             SingleImports::MaybeOne(_) => *self = SingleImports::None,\n+            SingleImports::MaybeTwo(dir1, dir2) =>\n+                *self = SingleImports::MaybeOne(if ptr::eq(dir1, dir) { dir1 } else { dir2 }),\n             SingleImports::AtLeastOne => {}\n         }\n     }\n@@ -199,23 +208,50 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Check if a single import can still define the name.\n+        let resolve_single_import = |this: &mut Self, directive: &'a ImportDirective<'a>| {\n+            let module = match directive.imported_module.get() {\n+                Some(module) => module,\n+                None => return false,\n+            };\n+            let ident = match directive.subclass {\n+                SingleImport { source, .. } => source,\n+                _ => unreachable!(),\n+            };\n+            match this.resolve_ident_in_module(module, ident, ns, false, false, path_span) {\n+                Err(Determined) => {}\n+                _ => return false,\n+            }\n+            true\n+        };\n         match resolution.single_imports {\n             SingleImports::AtLeastOne => return Err(Undetermined),\n-            SingleImports::MaybeOne(directive) if self.is_accessible(directive.vis.get()) => {\n-                let module = match directive.imported_module.get() {\n-                    Some(module) => module,\n-                    None => return Err(Undetermined),\n-                };\n-                let ident = match directive.subclass {\n-                    SingleImport { source, .. } => source,\n-                    _ => unreachable!(),\n-                };\n-                match self.resolve_ident_in_module(module, ident, ns, false, false, path_span) {\n-                    Err(Determined) => {}\n-                    _ => return Err(Undetermined),\n+            SingleImports::MaybeOne(directive) => {\n+                let accessible = self.is_accessible(directive.vis.get());\n+                if accessible {\n+                    if !resolve_single_import(self, directive) {\n+                        return Err(Undetermined)\n+                    }\n+                }\n+            }\n+            SingleImports::MaybeTwo(directive1, directive2) => {\n+                let accessible1 = self.is_accessible(directive1.vis.get());\n+                let accessible2 = self.is_accessible(directive2.vis.get());\n+                if accessible1 && accessible2 {\n+                    if !resolve_single_import(self, directive1) &&\n+                       !resolve_single_import(self, directive2) {\n+                        return Err(Undetermined)\n+                    }\n+                } else if accessible1 {\n+                    if !resolve_single_import(self, directive1) {\n+                        return Err(Undetermined)\n+                    }\n+                } else {\n+                    if !resolve_single_import(self, directive2) {\n+                        return Err(Undetermined)\n+                    }\n                 }\n             }\n-            SingleImports::MaybeOne(_) | SingleImports::None => {},\n+            SingleImports::None => {},\n         }\n \n         let no_unresolved_invocations =\n@@ -281,7 +317,7 @@ impl<'a> Resolver<'a> {\n             SingleImport { target, .. } => {\n                 self.per_ns(|this, ns| {\n                     let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n-                    resolution.single_imports.add_directive(directive);\n+                    resolution.single_imports.add_directive(directive, this.use_extern_macros);\n                 });\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n@@ -575,7 +611,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n                     this.update_resolution(parent, target, ns, |_, resolution| {\n-                        resolution.single_imports.directive_failed()\n+                        resolution.single_imports.directive_failed(directive)\n                     });\n                 }\n                 Ok(binding) if !binding.is_importable() => {"}, {"sha": "fd1f779f9ecc06168ee635e11907d2b576ed2dda", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -14,7 +14,7 @@ pub use self::Primitive::*;\n use spec::Target;\n \n use std::cmp;\n-use std::ops::{Add, Deref, Sub, Mul, AddAssign, RangeInclusive};\n+use std::ops::{Add, Deref, Sub, Mul, AddAssign, Range, RangeInclusive};\n \n pub mod call;\n \n@@ -326,9 +326,9 @@ impl AddAssign for Size {\n }\n \n /// Alignment of a type in bytes, both ABI-mandated and preferred.\n-/// Each field is a power of two, giving the alignment a maximum value of\n-/// 2<sup>(2<sup>8</sup> - 1)</sup>, which is limited by LLVM to a i32,\n-/// with a maximum capacity of 2<sup>31</sup> - 1 or 2147483647.\n+/// Each field is a power of two, giving the alignment a maximum value\n+/// of 2<sup>(2<sup>8</sup> - 1)</sup>, which is limited by LLVM to a\n+/// maximum capacity of 2<sup>29</sup> or 536870912.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Align {\n     abi_pow2: u8,\n@@ -356,7 +356,7 @@ impl Align {\n             }\n             if bytes != 1 {\n                 Err(format!(\"`{}` is not a power of 2\", align))\n-            } else if pow > 30 {\n+            } else if pow > 29 {\n                 Err(format!(\"`{}` is too large\", align))\n             } else {\n                 Ok(pow)\n@@ -544,6 +544,23 @@ impl Scalar {\n             false\n         }\n     }\n+\n+    /// Returns the valid range as a `x..y` range.\n+    ///\n+    /// If `x` and `y` are equal, the range is full, not empty.\n+    pub fn valid_range_exclusive<C: HasDataLayout>(&self, cx: C) -> Range<u128> {\n+        // For a (max) value of -1, max will be `-1 as usize`, which overflows.\n+        // However, that is fine here (it would still represent the full range),\n+        // i.e., if the range is everything.\n+        let bits = self.value.size(cx).bits();\n+        assert!(bits <= 128);\n+        let mask = !0u128 >> (128 - bits);\n+        let start = *self.valid_range.start();\n+        let end = *self.valid_range.end();\n+        assert_eq!(start, start & mask);\n+        assert_eq!(end, end & mask);\n+        start..(end.wrapping_add(1) & mask)\n+    }\n }\n \n /// Describes how the fields of a type are located in memory."}, {"sha": "45f2ee13bbdc94e29f5e5922564f24314351d1ff", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -29,6 +29,7 @@\n #![feature(const_fn)]\n #![feature(fs_read_write)]\n #![feature(inclusive_range)]\n+#![feature(inclusive_range_methods)]\n #![feature(slice_patterns)]\n \n #[macro_use]"}, {"sha": "46bb01e7c420dfe1f92a90dd8cdeb94022d45509", "filename": "src/librustc_target/spec/apple_ios_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_ios_base.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -98,6 +98,7 @@ pub fn opts(arch: Arch) -> Result<TargetOptions, String> {\n         executables: true,\n         pre_link_args,\n         has_elf_tls: false,\n+        eliminate_frame_pointer: false,\n         // The following line is a workaround for jemalloc 4.5 being broken on\n         // ios. jemalloc 5.0 is supposed to fix this.\n         // see https://github.com/rust-lang/rust/issues/45262"}, {"sha": "2d4e95ab01d6f58bff6db92fb0b641af53340412", "filename": "src/librustc_target/spec/armv5te_unknown_linux_musleabi.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_target%2Fspec%2Farmv5te_unknown_linux_musleabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_target%2Fspec%2Farmv5te_unknown_linux_musleabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Farmv5te_unknown_linux_musleabi.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let base = super::linux_musl_base::opts();\n+    Ok(Target {\n+        // It's important we use \"gnueabihf\" and not \"musleabihf\" here. LLVM\n+        // uses it to determine the calling convention and float ABI, and LLVM\n+        // doesn't support the \"musleabihf\" value.\n+        llvm_target: \"armv5te-unknown-linux-gnueabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"musl\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+\n+        options: TargetOptions {\n+            features: \"+soft-float,+strict-align\".to_string(),\n+            // Atomic operations provided by compiler-builtins\n+            max_atomic_width: Some(32),\n+            abi_blacklist: super::arm_base::abi_blacklist(),\n+            .. base\n+        }\n+    })\n+}"}, {"sha": "d17789dfcc07feb929e520e26038d99774a56668", "filename": "src/librustc_target/spec/i686_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_target%2Fspec%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_target%2Fspec%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi686_apple_darwin.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -16,6 +16,7 @@ pub fn target() -> TargetResult {\n     base.max_atomic_width = Some(64);\n     base.pre_link_args.insert(LinkerFlavor::Gcc, vec![\"-m32\".to_string()]);\n     base.stack_probes = true;\n+    base.eliminate_frame_pointer = false;\n \n     Ok(Target {\n         llvm_target: \"i686-apple-darwin\".to_string(),"}, {"sha": "48e771e0aafab3c942cf8922825cc28cc4276be9", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -283,6 +283,7 @@ supported_targets! {\n     (\"arm-unknown-linux-musleabihf\", arm_unknown_linux_musleabihf),\n     (\"armv4t-unknown-linux-gnueabi\", armv4t_unknown_linux_gnueabi),\n     (\"armv5te-unknown-linux-gnueabi\", armv5te_unknown_linux_gnueabi),\n+    (\"armv5te-unknown-linux-musleabi\", armv5te_unknown_linux_musleabi),\n     (\"armv7-unknown-linux-gnueabihf\", armv7_unknown_linux_gnueabihf),\n     (\"armv7-unknown-linux-musleabihf\", armv7_unknown_linux_musleabihf),\n     (\"aarch64-unknown-linux-gnu\", aarch64_unknown_linux_gnu),"}, {"sha": "ba31ce2692fbcabe38a67fcd0b3f3821d102d5e8", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -193,14 +193,38 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n             .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n             .collect(),\n \n-        ty::TyGenerator(def_id, substs, _) => {\n-            // Note that the interior types are ignored here.\n-            // Any type reachable inside the interior must also be reachable\n-            // through the upvars.\n-            substs\n-                .upvar_tys(def_id, tcx)\n-                .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n-                .collect()\n+        ty::TyGenerator(def_id, substs, _interior) => {\n+            // rust-lang/rust#49918: types can be constructed, stored\n+            // in the interior, and sit idle when generator yields\n+            // (and is subsequently dropped).\n+            //\n+            // It would be nice to descend into interior of a\n+            // generator to determine what effects dropping it might\n+            // have (by looking at any drop effects associated with\n+            // its interior).\n+            //\n+            // However, the interior's representation uses things like\n+            // TyGeneratorWitness that explicitly assume they are not\n+            // traversed in such a manner. So instead, we will\n+            // simplify things for now by treating all generators as\n+            // if they were like trait objects, where its upvars must\n+            // all be alive for the generator's (potential)\n+            // destructor.\n+            //\n+            // In particular, skipping over `_interior` is safe\n+            // because any side-effects from dropping `_interior` can\n+            // only take place through references with lifetimes\n+            // derived from lifetimes attached to the upvars, and we\n+            // *do* incorporate the upvars here.\n+\n+            let constraint = DtorckConstraint {\n+                outlives: substs.upvar_tys(def_id, tcx).map(|t| t.into()).collect(),\n+                dtorck_types: vec![],\n+                overflows: vec![],\n+            };\n+            debug!(\"dtorck_constraint: generator {:?} => {:?}\", def_id, constraint);\n+\n+            Ok(constraint)\n         }\n \n         ty::TyAdt(def, substs) => {"}, {"sha": "21259bbcd38ff9df779a2e9d7923079e05126fe7", "filename": "src/librustc_traits/evaluate_obligation.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fevaluate_obligation.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::traits::{EvaluationResult, Obligation, ObligationCause,\n+                    OverflowError, SelectionContext, TraitQueryMode};\n+use rustc::traits::query::CanonicalPredicateGoal;\n+use rustc::ty::{ParamEnvAnd, TyCtxt};\n+use syntax::codemap::DUMMY_SP;\n+\n+crate fn evaluate_obligation<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    goal: CanonicalPredicateGoal<'tcx>,\n+) -> Result<EvaluationResult, OverflowError> {\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        let (\n+            ParamEnvAnd {\n+                param_env,\n+                value: predicate,\n+            },\n+            _canonical_inference_vars,\n+        ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &goal);\n+\n+        let mut selcx = SelectionContext::with_query_mode(&infcx, TraitQueryMode::Canonical);\n+        let obligation = Obligation::new(ObligationCause::dummy(), param_env, predicate);\n+\n+        selcx.evaluate_obligation_recursively(&obligation)\n+    })\n+}"}, {"sha": "7f18fac2db5a3a5b8996c722c6959492ac4302c1", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -22,6 +22,7 @@ extern crate syntax;\n extern crate syntax_pos;\n \n mod dropck_outlives;\n+mod evaluate_obligation;\n mod normalize_projection_ty;\n mod normalize_erasing_regions;\n mod util;\n@@ -38,6 +39,7 @@ pub fn provide(p: &mut Providers) {\n             normalize_erasing_regions::normalize_ty_after_erasing_regions,\n         program_clauses_for: lowering::program_clauses_for,\n         program_clauses_for_env: lowering::program_clauses_for_env,\n+        evaluate_obligation: evaluate_obligation::evaluate_obligation,\n         ..*p\n     };\n }"}, {"sha": "299433d479dc60d86d69ca5f4cb898482509bb4c", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -17,6 +17,8 @@ crate fn normalize_ty_after_erasing_regions<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     goal: ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Ty<'tcx> {\n+    debug!(\"normalize_ty_after_erasing_regions(goal={:#?})\", goal);\n+\n     let ParamEnvAnd { param_env, value } = goal;\n     tcx.sess.perf_stats.normalize_ty_after_erasing_regions.fetch_add(1, Ordering::Relaxed);\n     tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "a4dd02e97b233573d417e789950265498e4b4634", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -21,7 +21,6 @@ rustc-demangle = \"0.1.4\"\n rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n-rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }"}, {"sha": "1838dae049ad7e1a18cb205ed7ce6648900e4ae0", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -265,7 +265,7 @@ pub trait FnTypeExt<'a, 'tcx> {\n     fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n     fn llvm_cconv(&self) -> llvm::CallConv;\n     fn apply_attrs_llfn(&self, llfn: ValueRef);\n-    fn apply_attrs_callsite(&self, callsite: ValueRef);\n+    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'tcx>, callsite: ValueRef);\n }\n \n impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n@@ -388,8 +388,8 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 return;\n             }\n \n-            if scalar.valid_range.start < scalar.valid_range.end {\n-                if scalar.valid_range.start > 0 {\n+            if scalar.valid_range.start() < scalar.valid_range.end() {\n+                if *scalar.valid_range.start() > 0 {\n                     attrs.set(ArgAttribute::NonNull);\n                 }\n             }\n@@ -640,7 +640,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn apply_attrs_callsite(&self, callsite: ValueRef) {\n+    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'tcx>, callsite: ValueRef) {\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes| {\n             attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n@@ -653,6 +653,24 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n             PassMode::Indirect(ref attrs) => apply(attrs),\n             _ => {}\n         }\n+        if let layout::Abi::Scalar(ref scalar) = self.ret.layout.abi {\n+            // If the value is a boolean, the range is 0..2 and that ultimately\n+            // become 0..0 when the type becomes i1, which would be rejected\n+            // by the LLVM verifier.\n+            match scalar.value {\n+                layout::Int(..) if !scalar.is_bool() => {\n+                    let range = scalar.valid_range_exclusive(bx.cx);\n+                    if range.start != range.end {\n+                        // FIXME(nox): This causes very weird type errors about\n+                        // SHL operators in constants in stage 2 with LLVM 3.9.\n+                        if unsafe { llvm::LLVMRustVersionMajor() >= 4 } {\n+                            bx.range_metadata(callsite, range);\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n         for arg in &self.args {\n             if arg.pad.is_some() {\n                 apply(&ArgAttributes::new());"}, {"sha": "871fe98ec01879612afa2b7830f558ffaa05c3a8", "filename": "src/librustc_trans/allocator.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fallocator.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -11,6 +11,7 @@\n use std::ffi::CString;\n use std::ptr;\n \n+use attributes;\n use libc::c_uint;\n use rustc::middle::allocator::AllocatorKind;\n use rustc::ty::TyCtxt;\n@@ -67,6 +68,9 @@ pub(crate) unsafe fn trans(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind)\n         if tcx.sess.target.target.options.default_hidden_visibility {\n             llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n         }\n+       if tcx.sess.target.target.options.requires_uwtable {\n+           attributes::emit_uwtable(llfn, true);\n+       }\n \n         let callee = CString::new(kind.fn_name(method.name)).unwrap();\n         let callee = llvm::LLVMRustGetOrInsertFunction(llmod,"}, {"sha": "5baed57092d0f3c243605d666bce3a650281dbf6", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -14,6 +14,7 @@ use std::ffi::{CStr, CString};\n use rustc::hir::{self, TransFnAttrFlags};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::session::Session;\n use rustc::session::config::Sanitizer;\n use rustc::ty::TyCtxt;\n use rustc::ty::maps::Providers;\n@@ -68,8 +69,6 @@ pub fn naked(val: ValueRef, is_naked: bool) {\n }\n \n pub fn set_frame_pointer_elimination(cx: &CodegenCx, llfn: ValueRef) {\n-    // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a\n-    // parameter.\n     if cx.sess().must_not_eliminate_frame_pointers() {\n         llvm::AddFunctionAttrStringValue(\n             llfn, llvm::AttributePlace::Function,\n@@ -104,6 +103,18 @@ pub fn set_probestack(cx: &CodegenCx, llfn: ValueRef) {\n         cstr(\"probe-stack\\0\"), cstr(\"__rust_probestack\\0\"));\n }\n \n+pub fn llvm_target_features(sess: &Session) -> impl Iterator<Item = &str> {\n+    const RUSTC_SPECIFIC_FEATURES: &[&str] = &[\n+        \"crt-static\",\n+    ];\n+\n+    let cmdline = sess.opts.cg.target_feature.split(',')\n+        .filter(|f| !RUSTC_SPECIFIC_FEATURES.iter().any(|s| f.contains(s)));\n+    sess.target.target.options.features.split(',')\n+        .chain(cmdline)\n+        .filter(|l| !l.is_empty())\n+}\n+\n /// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n /// attributes.\n pub fn from_fn_attrs(cx: &CodegenCx, llfn: ValueRef, id: DefId) {\n@@ -131,13 +142,16 @@ pub fn from_fn_attrs(cx: &CodegenCx, llfn: ValueRef, id: DefId) {\n         unwind(llfn, false);\n     }\n \n-    let features =\n-        trans_fn_attrs.target_features\n-        .iter()\n-        .map(|f| {\n-            let feature = &*f.as_str();\n-            format!(\"+{}\", llvm_util::to_llvm_feature(cx.tcx.sess, feature))\n-        })\n+    let features = llvm_target_features(cx.tcx.sess)\n+        .map(|s| s.to_string())\n+        .chain(\n+            trans_fn_attrs.target_features\n+                .iter()\n+                .map(|f| {\n+                    let feature = &*f.as_str();\n+                    format!(\"+{}\", llvm_util::to_llvm_feature(cx.tcx.sess, feature))\n+                })\n+        )\n         .collect::<Vec<String>>()\n         .join(\",\");\n "}, {"sha": "ea3f5b408604ee8f4afa1698589bc3f1b51bcac9", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -959,7 +959,11 @@ impl Linker for WasmLd {\n     }\n \n     fn finalize(&mut self) -> Command {\n-        self.cmd.arg(\"--threads\");\n+        // There have been reports in the wild (rustwasm/wasm-bindgen#119) of\n+        // using threads causing weird hangs and bugs. Disable it entirely as\n+        // this isn't yet the bottleneck of compilation at all anyway.\n+        self.cmd.arg(\"--no-threads\");\n+\n         self.cmd.arg(\"-z\").arg(\"stack-size=1048576\");\n \n         // FIXME we probably shouldn't pass this but instead pass an explicit"}, {"sha": "d8520b61d9157b624e6c0917a08a51a5d676504a", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -132,7 +132,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         })\n         .map(|def_id| {\n             let export_level = if special_runtime_crate {\n-                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n+                let name = tcx.symbol_name(Instance::mono(tcx, def_id)).as_str();\n                 // We can probably do better here by just ensuring that\n                 // it has hidden visibility rather than public\n                 // visibility, as this is primarily here to ensure it's"}, {"sha": "148e3d0025c83e3cc443bf901d73fdb39553eaed", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use attributes;\n use back::bytecode::{self, RLIB_BYTECODE_EXTENSION};\n use back::lto::{self, ModuleBuffer, ThinBuffer};\n use back::link::{self, get_linker, remove};\n@@ -111,31 +112,6 @@ pub fn write_output_file(\n     }\n }\n \n-// On android, we by default compile for armv7 processors. This enables\n-// things like double word CAS instructions (rather than emulating them)\n-// which are *far* more efficient. This is obviously undesirable in some\n-// cases, so if any sort of target feature is specified we don't append v7\n-// to the feature list.\n-//\n-// On iOS only armv7 and newer are supported. So it is useful to\n-// get all hardware potential via VFP3 (hardware floating point)\n-// and NEON (SIMD) instructions supported by LLVM.\n-// Note that without those flags various linking errors might\n-// arise as some of intrinsics are converted into function calls\n-// and nobody provides implementations those functions\n-fn target_feature(sess: &Session) -> String {\n-    let rustc_features = [\n-        \"crt-static\",\n-    ];\n-    let requested_features = sess.opts.cg.target_feature.split(',');\n-    let llvm_features = requested_features.filter(|f| {\n-        !rustc_features.iter().any(|s| f.contains(s))\n-    });\n-    format!(\"{},{}\",\n-            sess.target.target.options.features,\n-            llvm_features.collect::<Vec<_>>().join(\",\"))\n-}\n-\n fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n     match optimize {\n       config::OptLevel::No => llvm::CodeGenOptLevel::None,\n@@ -203,7 +179,10 @@ pub fn target_machine_factory(sess: &Session, find_features: bool)\n         None => &*sess.target.target.options.cpu\n     };\n     let cpu = CString::new(cpu.as_bytes()).unwrap();\n-    let features = CString::new(target_feature(sess).as_bytes()).unwrap();\n+    let features = attributes::llvm_target_features(sess)\n+        .collect::<Vec<_>>()\n+        .join(\",\");\n+    let features = CString::new(features).unwrap();\n     let is_pie_binary = !find_features && is_pie_binary(sess);\n     let trap_unreachable = sess.target.target.options.trap_unreachable;\n "}, {"sha": "b756a6695f9415bec8628cbdc980b23f9cd1dfeb", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1037,7 +1037,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n                 cgus.dedup();\n                 for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n                     output.push_str(\" \");\n-                    output.push_str(&cgu_name);\n+                    output.push_str(&cgu_name.as_str());\n \n                     let linkage_abbrev = match linkage {\n                         Linkage::External => \"External\","}, {"sha": "9263d9a5f5dc2096dfa972a592efe1bec38c9c74", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -52,7 +52,7 @@ pub fn get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         return llfn;\n     }\n \n-    let sym = tcx.symbol_name(instance);\n+    let sym = tcx.symbol_name(instance).as_str();\n     debug!(\"get_fn({:?}: {:?}) => {}\", instance, fn_ty, sym);\n \n     // Create a fn pointer with the substituted signature."}, {"sha": "4a0619b23360df1684b3efffd0566943990b1363", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -33,7 +33,7 @@ use libc::{c_uint, c_char};\n use std::iter;\n \n use rustc_target::spec::abi::Abi;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::LocalInternedString;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use context::CodegenCx;\n@@ -183,7 +183,7 @@ pub fn C_u8(cx: &CodegenCx, i: u8) -> ValueRef {\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-pub fn C_cstr(cx: &CodegenCx, s: InternedString, null_terminated: bool) -> ValueRef {\n+pub fn C_cstr(cx: &CodegenCx, s: LocalInternedString, null_terminated: bool) -> ValueRef {\n     unsafe {\n         if let Some(&llval) = cx.const_cstr_cache.borrow().get(&s) {\n             return llval;\n@@ -208,7 +208,7 @@ pub fn C_cstr(cx: &CodegenCx, s: InternedString, null_terminated: bool) -> Value\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_str_slice(cx: &CodegenCx, s: InternedString) -> ValueRef {\n+pub fn C_str_slice(cx: &CodegenCx, s: LocalInternedString) -> ValueRef {\n     let len = s.len();\n     let cs = consts::ptrcast(C_cstr(cx, s, false),\n         cx.layout_of(cx.tcx.mk_str()).llvm_type(cx).ptr_to());"}, {"sha": "405cb83ad4d754a4e443b0d51b842542435c92bf", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -118,7 +118,7 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n              def_id);\n \n     let ty = instance.ty(cx.tcx);\n-    let sym = cx.tcx.symbol_name(instance);\n+    let sym = cx.tcx.symbol_name(instance).as_str();\n \n     let g = if let Some(id) = cx.tcx.hir.as_local_node_id(def_id) {\n "}, {"sha": "90b2fb4b59a7016aa37f38a3ce2d0dbc9361f729", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -39,7 +39,7 @@ use std::ptr;\n use std::iter;\n use std::str;\n use std::sync::Arc;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::LocalInternedString;\n use abi::Abi;\n \n /// There is one `CodegenCx` per compilation unit. Each one has its own LLVM\n@@ -62,7 +62,7 @@ pub struct CodegenCx<'a, 'tcx: 'a> {\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>,\n                                 Option<ty::PolyExistentialTraitRef<'tcx>>), ValueRef>>,\n     /// Cache of constant strings,\n-    pub const_cstr_cache: RefCell<FxHashMap<InternedString, ValueRef>>,\n+    pub const_cstr_cache: RefCell<FxHashMap<LocalInternedString, ValueRef>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n     /// Key is a ValueRef holding a *T,\n@@ -273,7 +273,7 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n             let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n                 let dctx = debuginfo::CrateDebugContext::new(llmod);\n                 debuginfo::metadata::compile_unit_metadata(tcx,\n-                                                           codegen_unit.name(),\n+                                                           &codegen_unit.name().as_str(),\n                                                            &dctx);\n                 Some(dctx)\n             } else {"}, {"sha": "2fc6c9d4433016f74613225759412724916744cd", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1236,7 +1236,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                                    self.layout,\n                                    self.layout.fields.offset(0),\n                                    self.layout.field(cx, 0).size);\n-                name.push_str(&adt.variants[niche_variants.start].name.as_str());\n+                name.push_str(&adt.variants[*niche_variants.start()].name.as_str());\n \n                 // Create the (singleton) list of descriptions of union members.\n                 vec![\n@@ -1399,7 +1399,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     (discr.size(cx), discr.align(cx));\n                 let discriminant_base_type_metadata =\n                     type_metadata(cx, discr.to_ty(cx.tcx), syntax_pos::DUMMY_SP);\n-                let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n+                let discriminant_name = get_enum_discriminant_name(cx, enum_def_id).as_str();\n \n                 let name = CString::new(discriminant_name.as_bytes()).unwrap();\n                 let discriminant_type_metadata = unsafe {"}, {"sha": "30676b91620a62c27e7d60e03bbcfcd6f7a114f3", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -271,7 +271,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         }\n         None => {}\n     };\n-    if sig.output().is_never() {\n+    if cx.layout_of(sig.output()).abi == ty::layout::Abi::Uninhabited {\n         flags = flags | DIFlags::FlagNoReturn;\n     }\n \n@@ -394,7 +394,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             substs.types().zip(names).map(|(ty, name)| {\n                 let actual_type = cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n                 let actual_type_metadata = type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n-                let name = CString::new(name.as_bytes()).unwrap();\n+                let name = CString::new(name.as_str().as_bytes()).unwrap();\n                 unsafe {\n                     llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),"}, {"sha": "51c45de9dc22a7633f1e8a6bdcaa35d5638acd28", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -47,7 +47,7 @@ pub fn item_namespace(cx: &CodegenCx, def_id: DefId) -> DIScope {\n \n     let namespace_name = match def_key.disambiguated_data.data {\n         DefPathData::CrateRoot => cx.tcx.crate_name(def_id.krate).as_str(),\n-        data => data.as_interned_str()\n+        data => data.as_interned_str().as_str()\n     };\n \n     let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();"}, {"sha": "825fac36c93d7bed47119c18a6674bd5f76c215b", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -190,10 +190,10 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             output.push_str(&cx.tcx.crate_name(def_id.krate).as_str());\n             for path_element in cx.tcx.def_path(def_id).data {\n                 output.push_str(\"::\");\n-                output.push_str(&path_element.data.as_interned_str());\n+                output.push_str(&path_element.data.as_interned_str().as_str());\n             }\n         } else {\n-            output.push_str(&cx.tcx.item_name(def_id));\n+            output.push_str(&cx.tcx.item_name(def_id).as_str());\n         }\n     }\n "}, {"sha": "97721ffbf06854e627550e92b1351a21bd3bd12a", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -23,6 +23,7 @@\n use llvm::{self, ValueRef};\n use llvm::AttributePlace::Function;\n use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{self, LayoutOf};\n use rustc::session::config::Sanitizer;\n use rustc_target::spec::PanicStrategy;\n use abi::{Abi, FnType, FnTypeExt};\n@@ -133,8 +134,7 @@ pub fn declare_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, name: &str,\n     let fty = FnType::new(cx, sig, &[]);\n     let llfn = declare_raw_fn(cx, name, fty.llvm_cconv(), fty.llvm_type(cx));\n \n-    // FIXME(canndrew): This is_never should really be an is_uninhabited\n-    if sig.output().is_never() {\n+    if cx.layout_of(sig.output()).abi == layout::Abi::Uninhabited {\n         llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n     }\n "}, {"sha": "49a207a2d8ab5b299f54812d1c45ea0bcf879fd2", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -103,7 +103,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n     let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n     let arg_tys = sig.inputs();\n     let ret_ty = sig.output();\n-    let name = &*tcx.item_name(def_id);\n+    let name = &*tcx.item_name(def_id).as_str();\n \n     let llret_ty = cx.layout_of(ret_ty).llvm_type(cx);\n     let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout, fn_ty.ret.layout.align);"}, {"sha": "7a152d6ded4c56ecc957f4d6ce7c40d5a1a31c31", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -25,10 +25,11 @@\n #![allow(unused_attributes)]\n #![feature(libc)]\n #![feature(quote)]\n+#![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(optin_builtin_traits)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n \n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n@@ -42,7 +43,6 @@ extern crate rustc_mir;\n extern crate rustc_allocator;\n extern crate rustc_apfloat;\n extern crate rustc_target;\n-extern crate rustc_const_math;\n #[macro_use] extern crate rustc_data_structures;\n extern crate rustc_demangle;\n extern crate rustc_incremental;"}, {"sha": "9e5298eb736a33e18c7d97710f1739fa3b925ebc", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -322,7 +322,7 @@ pub fn cleanup_kinds<'a, 'tcx>(mir: &mir::Mir<'tcx>) -> IndexVec<mir::BasicBlock\n             debug!(\"cleanup_kinds: {:?}/{:?}/{:?} propagating funclet {:?}\",\n                    bb, data, result[bb], funclet);\n \n-            for &succ in data.terminator().successors().iter() {\n+            for &succ in data.terminator().successors() {\n                 let kind = result[succ];\n                 debug!(\"cleanup_kinds: propagating {:?} to {:?}/{:?}\",\n                        funclet, succ, kind);"}, {"sha": "b666c2b211525713e762126a5a437160a7ca787b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -13,6 +13,7 @@ use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf};\n use rustc::mir;\n+use rustc::mir::interpret::EvalErrorKind;\n use abi::{Abi, ArgType, ArgTypeExt, FnType, FnTypeExt, LlvmType, PassMode};\n use base;\n use callee;\n@@ -127,7 +128,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                                            ret_bx,\n                                            llblock(this, cleanup),\n                                            cleanup_bundle);\n-                fn_ty.apply_attrs_callsite(invokeret);\n+                fn_ty.apply_attrs_callsite(&bx, invokeret);\n \n                 if let Some((ret_dest, target)) = destination {\n                     let ret_bx = this.build_block(target);\n@@ -136,7 +137,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 }\n             } else {\n                 let llret = bx.call(fn_ptr, &llargs, cleanup_bundle);\n-                fn_ty.apply_attrs_callsite(llret);\n+                fn_ty.apply_attrs_callsite(&bx, llret);\n                 if this.mir[bb].is_cleanup {\n                     // Cleanup is always the cold path. Don't inline\n                     // drop glue. Also, when there is a deeply-nested\n@@ -311,10 +312,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 // checked operation, just a comparison with the minimum\n                 // value, so we have to check for the assert message.\n                 if !bx.cx.check_overflow {\n-                    use rustc_const_math::ConstMathErr::Overflow;\n-                    use rustc_const_math::Op::Neg;\n-\n-                    if let mir::AssertMessage::Math(Overflow(Neg)) = *msg {\n+                    if let mir::interpret::EvalErrorKind::OverflowNeg = *msg {\n                         const_cond = Some(expected);\n                     }\n                 }\n@@ -354,7 +352,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n                 // Put together the arguments to the panic entry point.\n                 let (lang_item, args) = match *msg {\n-                    mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n+                    EvalErrorKind::BoundsCheck { ref len, ref index } => {\n                         let len = self.trans_operand(&mut bx, len).immediate();\n                         let index = self.trans_operand(&mut bx, index).immediate();\n \n@@ -366,26 +364,8 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                         (lang_items::PanicBoundsCheckFnLangItem,\n                          vec![file_line_col, index, len])\n                     }\n-                    mir::AssertMessage::Math(ref err) => {\n-                        let msg_str = Symbol::intern(err.description()).as_str();\n-                        let msg_str = C_str_slice(bx.cx, msg_str);\n-                        let msg_file_line_col = C_struct(bx.cx,\n-                                                     &[msg_str, filename, line, col],\n-                                                     false);\n-                        let msg_file_line_col = consts::addr_of(bx.cx,\n-                                                                msg_file_line_col,\n-                                                                align,\n-                                                                \"panic_loc\");\n-                        (lang_items::PanicFnLangItem,\n-                         vec![msg_file_line_col])\n-                    }\n-                    mir::AssertMessage::GeneratorResumedAfterReturn |\n-                    mir::AssertMessage::GeneratorResumedAfterPanic => {\n-                        let str = if let mir::AssertMessage::GeneratorResumedAfterReturn = *msg {\n-                            \"generator resumed after completion\"\n-                        } else {\n-                            \"generator resumed after panicking\"\n-                        };\n+                    _ => {\n+                        let str = msg.description();\n                         let msg_str = Symbol::intern(str).as_str();\n                         let msg_str = C_str_slice(bx.cx, msg_str);\n                         let msg_file_line_col = C_struct(bx.cx,\n@@ -442,7 +422,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 // Handle intrinsics old trans wants Expr's for, ourselves.\n                 let intrinsic = match def {\n                     Some(ty::InstanceDef::Intrinsic(def_id))\n-                        => Some(bx.tcx().item_name(def_id)),\n+                        => Some(bx.tcx().item_name(def_id).as_str()),\n                     _ => None\n                 };\n                 let intrinsic = intrinsic.as_ref().map(|s| &s[..]);"}, {"sha": "79859aee64d874dfddbbb6333e6521d65bf6eaf7", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -91,24 +91,15 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         }\n \n         let scalar_load_metadata = |load, scalar: &layout::Scalar| {\n-            let (min, max) = (scalar.valid_range.start, scalar.valid_range.end);\n-            let max_next = max.wrapping_add(1);\n-            let bits = scalar.value.size(bx.cx).bits();\n-            assert!(bits <= 128);\n-            let mask = !0u128 >> (128 - bits);\n-            // For a (max) value of -1, max will be `-1 as usize`, which overflows.\n-            // However, that is fine here (it would still represent the full range),\n-            // i.e., if the range is everything.  The lo==hi case would be\n-            // rejected by the LLVM verifier (it would mean either an\n-            // empty set, which is impossible, or the entire range of the\n-            // type, which is pointless).\n+            let vr = scalar.valid_range.clone();\n             match scalar.value {\n-                layout::Int(..) if max_next & mask != min & mask => {\n-                    // llvm::ConstantRange can deal with ranges that wrap around,\n-                    // so an overflow on (max + 1) is fine.\n-                    bx.range_metadata(load, min..max_next);\n+                layout::Int(..) => {\n+                    let range = scalar.valid_range_exclusive(bx.cx);\n+                    if range.start != range.end {\n+                        bx.range_metadata(load, range);\n+                    }\n                 }\n-                layout::Pointer if 0 < min && min < max => {\n+                layout::Pointer if vr.start() < vr.end() && !vr.contains(&0) => {\n                     bx.nonnull_metadata(load);\n                 }\n                 _ => {}\n@@ -296,7 +287,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 ..\n             } => {\n                 let niche_llty = discr.layout.immediate_llvm_type(bx.cx);\n-                if niche_variants.start == niche_variants.end {\n+                if niche_variants.start() == niche_variants.end() {\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_start == 0 {\n                         // HACK(eddyb) Using `C_null` as it works on all types.\n@@ -305,13 +296,13 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                         C_uint_big(niche_llty, niche_start)\n                     };\n                     bx.select(bx.icmp(llvm::IntEQ, lldiscr, niche_llval),\n-                        C_uint(cast_to, niche_variants.start as u64),\n+                        C_uint(cast_to, *niche_variants.start() as u64),\n                         C_uint(cast_to, dataful_variant as u64))\n                 } else {\n                     // Rebase from niche values to discriminant values.\n-                    let delta = niche_start.wrapping_sub(niche_variants.start as u128);\n+                    let delta = niche_start.wrapping_sub(*niche_variants.start() as u128);\n                     let lldiscr = bx.sub(lldiscr, C_uint_big(niche_llty, delta));\n-                    let lldiscr_max = C_uint(niche_llty, niche_variants.end as u64);\n+                    let lldiscr_max = C_uint(niche_llty, *niche_variants.end() as u64);\n                     bx.select(bx.icmp(llvm::IntULE, lldiscr, lldiscr_max),\n                         bx.intcast(lldiscr, cast_to, false),\n                         C_uint(cast_to, dataful_variant as u64))\n@@ -361,7 +352,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n \n                     let niche = self.project_field(bx, 0);\n                     let niche_llty = niche.layout.immediate_llvm_type(bx.cx);\n-                    let niche_value = ((variant_index - niche_variants.start) as u128)\n+                    let niche_value = ((variant_index - *niche_variants.start()) as u128)\n                         .wrapping_add(niche_start);\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_value == 0 {"}, {"sha": "0cd823391b9b66ed4dd6872afb2f56d6ce51f0bc", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -15,7 +15,6 @@ use rustc::ty::layout::{self, LayoutOf};\n use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use rustc_apfloat::{ieee, Float, Status, Round};\n-use rustc_const_math::MAX_F32_PLUS_HALF_ULP;\n use std::{u128, i128};\n \n use base;\n@@ -301,15 +300,15 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                             if let layout::Int(_, s) = scalar.value {\n                                 signed = s;\n \n-                                if scalar.valid_range.end > scalar.valid_range.start {\n+                                if scalar.valid_range.end() > scalar.valid_range.start() {\n                                     // We want `table[e as usize]` to not\n                                     // have bound checks, and this is the most\n                                     // convenient place to put the `assume`.\n \n                                     base::call_assume(&bx, bx.icmp(\n                                         llvm::IntULE,\n                                         llval,\n-                                        C_uint_big(ll_t_in, scalar.valid_range.end)\n+                                        C_uint_big(ll_t_in, *scalar.valid_range.end())\n                                     ));\n                                 }\n                             }\n@@ -536,7 +535,6 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         let is_float = input_ty.is_fp();\n         let is_signed = input_ty.is_signed();\n         let is_nil = input_ty.is_nil();\n-        let is_bool = input_ty.is_bool();\n         match op {\n             mir::BinOp::Add => if is_float {\n                 bx.fadd(lhs, rhs)\n@@ -586,15 +584,6 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     lhs, rhs\n                 )\n             } else {\n-                let (lhs, rhs) = if is_bool {\n-                    // FIXME(#36856) -- extend the bools into `i8` because\n-                    // LLVM's i1 comparisons are broken.\n-                    (bx.zext(lhs, Type::i8(bx.cx)),\n-                     bx.zext(rhs, Type::i8(bx.cx)))\n-                } else {\n-                    (lhs, rhs)\n-                };\n-\n                 bx.icmp(\n                     base::bin_op_to_icmp_predicate(op.to_hir_binop(), is_signed),\n                     lhs, rhs\n@@ -815,6 +804,10 @@ fn cast_int_to_float(bx: &Builder,\n     if is_u128_to_f32 {\n         // All inputs greater or equal to (f32::MAX + 0.5 ULP) are rounded to infinity,\n         // and for everything else LLVM's uitofp works just fine.\n+        use rustc_apfloat::ieee::Single;\n+        use rustc_apfloat::Float;\n+        const MAX_F32_PLUS_HALF_ULP: u128 = ((1 << (Single::PRECISION + 1)) - 1)\n+                                            << (Single::MAX_EXP - Single::PRECISION as i16);\n         let max = C_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n         let overflow = bx.icmp(llvm::IntUGE, x, max);\n         let infinity_bits = C_u32(bx.cx, ieee::Single::INFINITY.to_bits() as u32);"}, {"sha": "d19b5af25273d30a5de19fbc219306ffcb38d6a5", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -88,7 +88,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n                self.to_raw_string(),\n                cx.codegen_unit.name());\n \n-        let symbol_name = self.symbol_name(cx.tcx);\n+        let symbol_name = self.symbol_name(cx.tcx).as_str();\n \n         debug!(\"symbol {}\", &symbol_name);\n "}, {"sha": "be5bff60805c3b2b8242ff3c755c93211b1afc10", "filename": "src/librustc_trans_utils/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_trans_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fsymbol_names.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -229,7 +229,7 @@ fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>)\n                          -> ty::SymbolName\n {\n-    ty::SymbolName { name: Symbol::intern(&compute_symbol_name(tcx, instance)).as_str() }\n+    ty::SymbolName { name: Symbol::intern(&compute_symbol_name(tcx, instance)).as_interned_str() }\n }\n \n fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>)\n@@ -355,12 +355,12 @@ impl SymbolPathBuffer {\n             result: String::with_capacity(64),\n             temp_buf: String::with_capacity(16)\n         };\n-        result.result.push_str(&symbol.name);\n+        result.result.push_str(&symbol.name.as_str());\n         result\n     }\n \n     fn into_interned(self) -> ty::SymbolName {\n-        ty::SymbolName { name: Symbol::intern(&self.result).as_str() }\n+        ty::SymbolName { name: Symbol::intern(&self.result).as_interned_str() }\n     }\n \n     fn finish(mut self, hash: u64) -> String {"}, {"sha": "c426533779c9be18721ec458e7114feca16e048f", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -15,7 +15,6 @@ syntax = { path = \"../libsyntax\" }\n arena = { path = \"../libarena\" }\n fmt_macros = { path = \"../libfmt_macros\" }\n rustc = { path = \"../librustc\" }\n-rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "93dbba6e873a9d4f807e906dfd8008c2f1335a93", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -101,7 +101,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     {\n         let tcx = self.tcx();\n         let lifetime_name = |def_id| {\n-            tcx.hir.name(tcx.hir.as_local_node_id(def_id).unwrap()).as_str()\n+            tcx.hir.name(tcx.hir.as_local_node_id(def_id).unwrap()).as_interned_str()\n         };\n \n         let hir_id = tcx.hir.node_to_hir_id(lifetime.id);\n@@ -981,7 +981,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let item_def_id = tcx.hir.local_def_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);\n                 let index = generics.type_param_to_index[&tcx.hir.local_def_id(node_id)];\n-                tcx.mk_param(index, tcx.hir.name(node_id).as_str())\n+                tcx.mk_param(index, tcx.hir.name(node_id).as_interned_str())\n             }\n             Def::SelfTy(_, Some(def_id)) => {\n                 // Self in impl (we know the concrete type)."}, {"sha": "3199ff17ae92697558cb3d699e1b7d60c8a4fb61", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -120,15 +120,15 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n \n         let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n \n-        let mut selcx = traits::SelectionContext::new(self.fcx);\n         let obligation = traits::Obligation::new(cause.clone(),\n                                                  self.fcx.param_env,\n                                                  trait_ref.to_predicate());\n-        if !selcx.evaluate_obligation(&obligation) {\n+        if !self.fcx.predicate_may_hold(&obligation) {\n             debug!(\"overloaded_deref_ty: cannot match obligation\");\n             return None;\n         }\n \n+        let mut selcx = traits::SelectionContext::new(self.fcx);\n         let normalized = traits::normalize_projection_type(&mut selcx,\n                                                            self.fcx.param_env,\n                                                            ty::ProjectionTy::from_ref_and_name("}, {"sha": "91264849cadf85f41f6930da4045cb23c54e89b1", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -732,8 +732,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if impl_ty.synthetic != trait_ty.synthetic {\n             let impl_node_id = tcx.hir.as_local_node_id(impl_ty.def_id).unwrap();\n             let impl_span = tcx.hir.span(impl_node_id);\n-            let trait_node_id = tcx.hir.as_local_node_id(trait_ty.def_id).unwrap();\n-            let trait_span = tcx.hir.span(trait_node_id);\n+            let trait_span = tcx.def_span(trait_ty.def_id);\n             let mut err = struct_span_err!(tcx.sess,\n                                            impl_span,\n                                            E0643,"}, {"sha": "fcf7541a159b02388449edd83fb53f0e0465d162", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -76,7 +76,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// and in libcore/intrinsics.rs\n pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       it: &hir::ForeignItem) {\n-    let param = |n| tcx.mk_param(n, Symbol::intern(&format!(\"P{}\", n)).as_str());\n+    let param = |n| tcx.mk_param(n, Symbol::intern(&format!(\"P{}\", n)).as_interned_str());\n     let name = it.name.as_str();\n     let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n         let split : Vec<&str> = name.split('_').collect();\n@@ -341,7 +341,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                it: &hir::ForeignItem) {\n     let param = |n| {\n-        let name = Symbol::intern(&format!(\"P{}\", n)).as_str();\n+        let name = Symbol::intern(&format!(\"P{}\", n)).as_interned_str();\n         tcx.mk_param(n, name)\n     };\n "}, {"sha": "5f904a9419b1d6b85caf708d4460d5cd6682a428", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -277,8 +277,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                      poly_trait_ref.to_predicate());\n \n         // Now we want to know if this can be matched\n-        let mut selcx = traits::SelectionContext::new(self);\n-        if !selcx.evaluate_obligation(&obligation) {\n+        if !self.predicate_may_hold(&obligation) {\n             debug!(\"--> Cannot match obligation\");\n             return None; // Cannot be matched, no such method resolution is possible.\n         }"}, {"sha": "907c80f0daf5ef8a0c8864ef0559ad32813ab503", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1173,7 +1173,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     let predicate = trait_ref.to_predicate();\n                     let obligation =\n                         traits::Obligation::new(cause.clone(), self.param_env, predicate);\n-                    if !selcx.evaluate_obligation(&obligation) {\n+                    if !self.predicate_may_hold(&obligation) {\n                         if self.probe(|_| self.select_trait_candidate(trait_ref).is_err()) {\n                             // This candidate's primary obligation doesn't even\n                             // select - don't bother registering anything in\n@@ -1201,7 +1201,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // Evaluate those obligations to see if they might possibly hold.\n             for o in candidate_obligations.into_iter().chain(sub_obligations) {\n                 let o = self.resolve_type_vars_if_possible(&o);\n-                if !selcx.evaluate_obligation(&o) {\n+                if !self.predicate_may_hold(&o) {\n                     result = ProbeResult::NoMatch;\n                     if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n                         possibly_unsatisfied_predicates.push(pred.skip_binder().trait_ref);\n@@ -1485,7 +1485,10 @@ impl<'tcx> Candidate<'tcx> {\n                     // inference variables or other artifacts. This\n                     // means they are safe to put into the\n                     // `WhereClausePick`.\n-                    assert!(!trait_ref.skip_binder().substs.needs_infer());\n+                    assert!(\n+                        !trait_ref.skip_binder().substs.needs_infer()\n+                            && !trait_ref.skip_binder().substs.has_skol()\n+                    );\n \n                     WhereClausePick(trait_ref.clone())\n                 }"}, {"sha": "2dc7c7fe71a89e7b2e08507541cf4b264e22caf5", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -19,7 +19,7 @@ use hir::def::Def;\n use hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::lang_items::FnOnceTraitLangItem;\n use namespace::Namespace;\n-use rustc::traits::{Obligation, SelectionContext};\n+use rustc::traits::Obligation;\n use util::nodemap::FxHashSet;\n \n use syntax::ast;\n@@ -65,7 +65,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              self.body_id,\n                                              self.param_env,\n                                              poly_trait_ref.to_predicate());\n-                        SelectionContext::new(self).evaluate_obligation(&obligation)\n+                        self.predicate_may_hold(&obligation)\n                     })\n                 })\n             }"}, {"sha": "db859e42057e951999d34f480bf49d2abfaf7d09", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -124,7 +124,7 @@ use syntax::attr;\n use syntax::codemap::{original_sp, Spanned};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n-use syntax::symbol::{Symbol, InternedString, keywords};\n+use syntax::symbol::{Symbol, LocalInternedString, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{self, BytePos, Span, MultiSpan};\n \n@@ -3172,7 +3172,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Return an hint about the closest match in field names\n     fn suggest_field_name(variant: &'tcx ty::VariantDef,\n                           field: &Spanned<ast::Name>,\n-                          skip: Vec<InternedString>)\n+                          skip: Vec<LocalInternedString>)\n                           -> Option<Symbol> {\n         let name = field.node.as_str();\n         let names = variant.fields.iter().filter_map(|field| {"}, {"sha": "e7e70a19e496b61b3bbeb7887d2e676f278a6d75", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -96,6 +96,7 @@ use rustc::ty::adjustment;\n \n use std::mem;\n use std::ops::Deref;\n+use std::rc::Rc;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -513,7 +514,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // the adjusted form if there is an adjustment.\n         match cmt_result {\n             Ok(head_cmt) => {\n-                self.check_safety_of_rvalue_destructor_if_necessary(head_cmt, expr.span);\n+                self.check_safety_of_rvalue_destructor_if_necessary(&head_cmt, expr.span);\n             }\n             Err(..) => {\n                 self.tcx.sess.delay_span_bug(expr.span, \"cat_expr Errd\");\n@@ -799,7 +800,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n     /// dereferenced, the lifetime of the pointer includes the deref expr.\n-    fn constrain_adjustments(&mut self, expr: &hir::Expr) -> mc::McResult<mc::cmt<'tcx>> {\n+    fn constrain_adjustments(&mut self, expr: &hir::Expr) -> mc::McResult<mc::cmt_<'tcx>> {\n         debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n         let mut cmt = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n@@ -814,7 +815,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         // If necessary, constrain destructors in the unadjusted form of this\n         // expression.\n-        self.check_safety_of_rvalue_destructor_if_necessary(cmt.clone(), expr.span);\n+        self.check_safety_of_rvalue_destructor_if_necessary(&cmt, expr.span);\n \n         let expr_region = self.tcx.mk_region(ty::ReScope(\n             region::Scope::Node(expr.hir_id.local_id)));\n@@ -837,7 +838,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 });\n \n                 self.link_region(expr.span, deref.region,\n-                                 ty::BorrowKind::from_mutbl(deref.mutbl), cmt.clone());\n+                                 ty::BorrowKind::from_mutbl(deref.mutbl), &cmt);\n \n                 // Specialized version of constrain_call.\n                 self.type_must_outlive(infer::CallRcvr(expr.span),\n@@ -847,7 +848,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             if let adjustment::Adjust::Borrow(ref autoref) = adjustment.kind {\n-                self.link_autoref(expr, cmt.clone(), autoref);\n+                self.link_autoref(expr, &cmt, autoref);\n \n                 // Require that the resulting region encompasses\n                 // the current node.\n@@ -878,7 +879,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn check_safety_of_rvalue_destructor_if_necessary(&mut self,\n-                                                     cmt: mc::cmt<'tcx>,\n+                                                     cmt: &mc::cmt_<'tcx>,\n                                                      span: Span) {\n         match cmt.cat {\n             Categorization::Rvalue(region) => {\n@@ -980,7 +981,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"link_addr_of: cmt={:?}\", cmt);\n \n-        self.link_region_from_node_type(expr.span, expr.hir_id, mutability, cmt);\n+        self.link_region_from_node_type(expr.span, expr.hir_id, mutability, &cmt);\n     }\n \n     /// Computes the guarantors for any ref bindings in a `let` and\n@@ -992,7 +993,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             None => { return; }\n             Some(ref expr) => &**expr,\n         };\n-        let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(init_expr)));\n+        let discr_cmt = Rc::new(ignore_err!(self.with_mc(|mc| mc.cat_expr(init_expr))));\n         self.link_pattern(discr_cmt, &local.pat);\n     }\n \n@@ -1001,7 +1002,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// linked to the lifetime of its guarantor (if any).\n     fn link_match(&self, discr: &hir::Expr, arms: &[hir::Arm]) {\n         debug!(\"regionck::for_match()\");\n-        let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(discr)));\n+        let discr_cmt = Rc::new(ignore_err!(self.with_mc(|mc| mc.cat_expr(discr))));\n         debug!(\"discr_cmt={:?}\", discr_cmt);\n         for arm in arms {\n             for root_pat in &arm.pats {\n@@ -1019,7 +1020,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             let arg_ty = self.node_ty(arg.hir_id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n             let arg_cmt = self.with_mc(|mc| {\n-                mc.cat_rvalue(arg.id, arg.pat.span, re_scope, arg_ty)\n+                Rc::new(mc.cat_rvalue(arg.id, arg.pat.span, re_scope, arg_ty))\n             });\n             debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n                    arg_ty,\n@@ -1044,7 +1045,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                                                                .expect(\"missing binding mode\");\n                         if let ty::BindByReference(mutbl) = bm {\n                             self.link_region_from_node_type(sub_pat.span, sub_pat.hir_id,\n-                                                            mutbl, sub_cmt);\n+                                                            mutbl, &sub_cmt);\n                         }\n                     }\n                     _ => {}\n@@ -1057,15 +1058,14 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// autoref'd.\n     fn link_autoref(&self,\n                     expr: &hir::Expr,\n-                    expr_cmt: mc::cmt<'tcx>,\n+                    expr_cmt: &mc::cmt_<'tcx>,\n                     autoref: &adjustment::AutoBorrow<'tcx>)\n     {\n         debug!(\"link_autoref(autoref={:?}, expr_cmt={:?})\", autoref, expr_cmt);\n \n         match *autoref {\n             adjustment::AutoBorrow::Ref(r, m) => {\n-                self.link_region(expr.span, r,\n-                                 ty::BorrowKind::from_mutbl(m.into()), expr_cmt);\n+                self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m.into()), expr_cmt);\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {\n@@ -1081,15 +1081,14 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                                   span: Span,\n                                   id: hir::HirId,\n                                   mutbl: hir::Mutability,\n-                                  cmt_borrowed: mc::cmt<'tcx>) {\n+                                  cmt_borrowed: &mc::cmt_<'tcx>) {\n         debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n                id, mutbl, cmt_borrowed);\n \n         let rptr_ty = self.resolve_node_type(id);\n         if let ty::TyRef(r, _) = rptr_ty.sty {\n             debug!(\"rptr_ty={}\",  rptr_ty);\n-            self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl),\n-                             cmt_borrowed);\n+            self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n         }\n     }\n \n@@ -1101,27 +1100,27 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                    span: Span,\n                    borrow_region: ty::Region<'tcx>,\n                    borrow_kind: ty::BorrowKind,\n-                   borrow_cmt: mc::cmt<'tcx>) {\n-        let mut borrow_cmt = borrow_cmt;\n-        let mut borrow_kind = borrow_kind;\n-\n+                   borrow_cmt: &mc::cmt_<'tcx>) {\n         let origin = infer::DataBorrowed(borrow_cmt.ty, span);\n         self.type_must_outlive(origin, borrow_cmt.ty, borrow_region);\n \n+        let mut borrow_kind = borrow_kind;\n+        let mut borrow_cmt_cat = borrow_cmt.cat.clone();\n+\n         loop {\n             debug!(\"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n                    borrow_region,\n                    borrow_kind,\n                    borrow_cmt);\n-            match borrow_cmt.cat.clone() {\n+            match borrow_cmt_cat {\n                 Categorization::Deref(ref_cmt, mc::Implicit(ref_kind, ref_region)) |\n                 Categorization::Deref(ref_cmt, mc::BorrowedPtr(ref_kind, ref_region)) => {\n                     match self.link_reborrowed_region(span,\n                                                       borrow_region, borrow_kind,\n                                                       ref_cmt, ref_region, ref_kind,\n                                                       borrow_cmt.note) {\n                         Some((c, k)) => {\n-                            borrow_cmt = c;\n+                            borrow_cmt_cat = c.cat.clone();\n                             borrow_kind = k;\n                         }\n                         None => {\n@@ -1135,7 +1134,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 Categorization::Interior(cmt_base, _) => {\n                     // Borrowing interior or owned data requires the base\n                     // to be valid and borrowable in the same fashion.\n-                    borrow_cmt = cmt_base;\n+                    borrow_cmt_cat = cmt_base.cat.clone();\n                     borrow_kind = borrow_kind;\n                 }\n "}, {"sha": "58dc5839578f783df3620713d481e0f52154c955", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -298,7 +298,8 @@ struct InferBorrowKind<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n-    fn adjust_upvar_borrow_kind_for_consume(&mut self, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n+    fn adjust_upvar_borrow_kind_for_consume(&mut self, cmt: &mc::cmt_<'tcx>,\n+                                            mode: euv::ConsumeMode) {\n         debug!(\n             \"adjust_upvar_borrow_kind_for_consume(cmt={:?}, mode={:?})\",\n             cmt,\n@@ -377,7 +378,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     /// Indicates that `cmt` is being directly mutated (e.g., assigned\n     /// to). If cmt contains any by-ref upvars, this implies that\n     /// those upvars must be borrowed using an `&mut` borrow.\n-    fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: mc::cmt<'tcx>) {\n+    fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: &mc::cmt_<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={:?})\", cmt);\n \n         match cmt.cat.clone() {\n@@ -386,7 +387,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n             Categorization::Downcast(base, _) => {\n                 // Interior or owned data is mutable if base is\n                 // mutable, so iterate to the base.\n-                self.adjust_upvar_borrow_kind_for_mut(base);\n+                self.adjust_upvar_borrow_kind_for_mut(&base);\n             }\n \n             Categorization::Deref(base, mc::BorrowedPtr(..)) |\n@@ -396,7 +397,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                     // borrowed pointer implies that the\n                     // pointer itself must be unique, but not\n                     // necessarily *mutable*\n-                    self.adjust_upvar_borrow_kind_for_unique(base);\n+                    self.adjust_upvar_borrow_kind_for_unique(&base);\n                 }\n             }\n \n@@ -410,7 +411,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn adjust_upvar_borrow_kind_for_unique(&mut self, cmt: mc::cmt<'tcx>) {\n+    fn adjust_upvar_borrow_kind_for_unique(&mut self, cmt: &mc::cmt_<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={:?})\", cmt);\n \n         match cmt.cat.clone() {\n@@ -419,15 +420,15 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n             Categorization::Downcast(base, _) => {\n                 // Interior or owned data is unique if base is\n                 // unique.\n-                self.adjust_upvar_borrow_kind_for_unique(base);\n+                self.adjust_upvar_borrow_kind_for_unique(&base);\n             }\n \n             Categorization::Deref(base, mc::BorrowedPtr(..)) |\n             Categorization::Deref(base, mc::Implicit(..)) => {\n                 if !self.try_adjust_upvar_deref(cmt, ty::UniqueImmBorrow) {\n                     // for a borrowed pointer to be unique, its\n                     // base must be unique\n-                    self.adjust_upvar_borrow_kind_for_unique(base);\n+                    self.adjust_upvar_borrow_kind_for_unique(&base);\n                 }\n             }\n \n@@ -439,7 +440,9 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn try_adjust_upvar_deref(&mut self, cmt: mc::cmt<'tcx>, borrow_kind: ty::BorrowKind) -> bool {\n+    fn try_adjust_upvar_deref(&mut self, cmt: &mc::cmt_<'tcx>, borrow_kind: ty::BorrowKind)\n+                              -> bool\n+    {\n         assert!(match borrow_kind {\n             ty::MutBorrow => true,\n             ty::UniqueImmBorrow => true,\n@@ -581,17 +584,19 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         &mut self,\n         _consume_id: ast::NodeId,\n         _consume_span: Span,\n-        cmt: mc::cmt<'tcx>,\n+        cmt: &mc::cmt_<'tcx>,\n         mode: euv::ConsumeMode,\n     ) {\n         debug!(\"consume(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n-    fn matched_pat(&mut self, _matched_pat: &hir::Pat, _cmt: mc::cmt<'tcx>, _mode: euv::MatchMode) {\n+    fn matched_pat(&mut self, _matched_pat: &hir::Pat, _cmt: &mc::cmt_<'tcx>,\n+                   _mode: euv::MatchMode) {\n     }\n \n-    fn consume_pat(&mut self, _consume_pat: &hir::Pat, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n+    fn consume_pat(&mut self, _consume_pat: &hir::Pat, cmt: &mc::cmt_<'tcx>,\n+                   mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n@@ -600,7 +605,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         &mut self,\n         borrow_id: ast::NodeId,\n         _borrow_span: Span,\n-        cmt: mc::cmt<'tcx>,\n+        cmt: &mc::cmt_<'tcx>,\n         _loan_region: ty::Region<'tcx>,\n         bk: ty::BorrowKind,\n         _loan_cause: euv::LoanCause,\n@@ -629,7 +634,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         &mut self,\n         _assignment_id: ast::NodeId,\n         _assignment_span: Span,\n-        assignee_cmt: mc::cmt<'tcx>,\n+        assignee_cmt: &mc::cmt_<'tcx>,\n         _mode: euv::MutateMode,\n     ) {\n         debug!(\"mutate(assignee_cmt={:?})\", assignee_cmt);"}, {"sha": "d0ff44c8e7e10e65da9a3ad874edecb4ecdf7cb3", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -655,7 +655,7 @@ fn reject_shadowing_type_parameters(tcx: TyCtxt, def_id: DefId) {\n             // local so it should be okay to just unwrap everything.\n             let trait_def_id = impl_params[&method_param.name];\n             let trait_decl_span = tcx.def_span(trait_def_id);\n-            error_194(tcx, type_span, trait_decl_span, &method_param.name[..]);\n+            error_194(tcx, type_span, trait_decl_span, &method_param.name.as_str()[..]);\n         }\n     }\n }"}, {"sha": "802e5375b6b2836ef295def6efa5bbf33df1fb8e", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -107,7 +107,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n     fn write_ty_to_tables(&mut self, hir_id: hir::HirId, ty: Ty<'gcx>) {\n         debug!(\"write_ty_to_tables({:?}, {:?})\", hir_id, ty);\n-        assert!(!ty.needs_infer());\n+        assert!(!ty.needs_infer() && !ty.has_skol());\n         self.tables.node_types_mut().insert(hir_id, ty);\n     }\n \n@@ -431,7 +431,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         if let Some(substs) = self.fcx.tables.borrow().node_substs_opt(hir_id) {\n             let substs = self.resolve(&substs, &span);\n             debug!(\"write_substs_to_tcx({:?}, {:?})\", hir_id, substs);\n-            assert!(!substs.needs_infer());\n+            assert!(!substs.needs_infer() && !substs.has_skol());\n             self.tables.node_substs_mut().insert(hir_id, substs);\n         }\n     }"}, {"sha": "1b8f2e661c30d95ca827fe68a2af7ac987d69553", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -244,7 +244,7 @@ fn type_param_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let param_owner_def_id = tcx.hir.local_def_id(param_owner);\n     let generics = tcx.generics_of(param_owner_def_id);\n     let index = generics.type_param_to_index[&def_id];\n-    let ty = tcx.mk_param(index, tcx.hir.ty_param_name(param_id).as_str());\n+    let ty = tcx.mk_param(index, tcx.hir.ty_param_name(param_id).as_interned_str());\n \n     // Don't look for bounds where the type parameter isn't in scope.\n     let parent = if item_def_id == param_owner_def_id {\n@@ -842,7 +842,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                     opt_self = Some(ty::TypeParameterDef {\n                         index: 0,\n-                        name: keywords::SelfType.name().as_str(),\n+                        name: keywords::SelfType.name().as_interned_str(),\n                         def_id: tcx.hir.local_def_id(param_id),\n                         has_default: false,\n                         object_lifetime_default: rl::Set1::Empty,\n@@ -888,7 +888,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n     let regions = early_lifetimes.enumerate().map(|(i, l)| {\n         ty::RegionParameterDef {\n-            name: l.lifetime.name.name().as_str(),\n+            name: l.lifetime.name.name().as_interned_str(),\n             index: own_start + i as u32,\n             def_id: tcx.hir.local_def_id(l.lifetime.id),\n             pure_wrt_drop: l.pure_wrt_drop,\n@@ -918,7 +918,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         ty::TypeParameterDef {\n             index: type_start + i as u32,\n-            name: p.name.as_str(),\n+            name: p.name.as_interned_str(),\n             def_id: tcx.hir.local_def_id(p.id),\n             has_default: p.default.is_some(),\n             object_lifetime_default:\n@@ -937,7 +937,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // add a dummy parameter for the closure kind\n         types.push(ty::TypeParameterDef {\n             index: type_start,\n-            name: Symbol::intern(\"<closure_kind>\").as_str(),\n+            name: Symbol::intern(\"<closure_kind>\").as_interned_str(),\n             def_id,\n             has_default: false,\n             object_lifetime_default: rl::Set1::Empty,\n@@ -948,7 +948,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // add a dummy parameter for the closure signature\n         types.push(ty::TypeParameterDef {\n             index: type_start + 1,\n-            name: Symbol::intern(\"<closure_signature>\").as_str(),\n+            name: Symbol::intern(\"<closure_signature>\").as_interned_str(),\n             def_id,\n             has_default: false,\n             object_lifetime_default: rl::Set1::Empty,\n@@ -959,7 +959,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.with_freevars(node_id, |fv| {\n             types.extend(fv.iter().zip(2..).map(|(_, i)| ty::TypeParameterDef {\n                 index: type_start + i,\n-                name: Symbol::intern(\"<upvar>\").as_str(),\n+                name: Symbol::intern(\"<upvar>\").as_interned_str(),\n                 def_id,\n                 has_default: false,\n                 object_lifetime_default: rl::Set1::Empty,\n@@ -1429,7 +1429,7 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             def_id: tcx.hir.local_def_id(param.lifetime.id),\n             index,\n-            name: param.lifetime.name.name().as_str(),\n+            name: param.lifetime.name.name().as_interned_str(),\n         }));\n         index += 1;\n \n@@ -1443,7 +1443,7 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T:Foo>`).\n     for param in ast_generics.ty_params() {\n-        let param_ty = ty::ParamTy::new(index, param.name.as_str()).to_ty(tcx);\n+        let param_ty = ty::ParamTy::new(index, param.name.as_interned_str()).to_ty(tcx);\n         index += 1;\n \n         let bounds = compute_bounds(&icx,"}, {"sha": "350b53a406bc885268e54a37783b1c381fa79ce5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -71,6 +71,8 @@ This API is completely unstable and subject to change.\n \n #![allow(non_camel_case_types)]\n \n+#![cfg_attr(stage0, feature(dyn_trait))]\n+\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n@@ -81,7 +83,6 @@ This API is completely unstable and subject to change.\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n #![feature(slice_sort_by_cached_key)]\n-#![feature(dyn_trait)]\n #![feature(never_type)]\n \n #[macro_use] extern crate log;\n@@ -91,7 +92,6 @@ extern crate syntax_pos;\n extern crate arena;\n #[macro_use] extern crate rustc;\n extern crate rustc_platform_intrinsics as intrinsics;\n-extern crate rustc_const_math;\n extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n extern crate rustc_target;"}, {"sha": "221fc4dab723253d0c34a364001d14e077106cd0", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -224,7 +224,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                     let name = if p.name == \"\" {\n                         hir::LifetimeName::Static\n                     } else {\n-                        hir::LifetimeName::Name(Symbol::intern(&p.name))\n+                        hir::LifetimeName::Name(p.name.as_symbol())\n                     };\n \n                     hir::Lifetime {\n@@ -261,7 +261,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                     span: DUMMY_SP,\n                     def: Def::TyParam(param.def_id),\n                     segments: HirVec::from_vec(vec![\n-                        hir::PathSegment::from_name(Symbol::intern(&param.name))\n+                        hir::PathSegment::from_name(param.name.as_symbol())\n                     ]),\n                 }),\n             )),"}, {"sha": "d5e0f95ddf4356ac3396314dc6614889c9095418", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 63, "deletions": 179, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -67,7 +67,7 @@ impl Cfg {\n     /// If the content is not properly formatted, it will return an error indicating what and where\n     /// the error is.\n     pub fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n-        let name = cfg.ident.name;\n+        let name = cfg.name();\n         match cfg.node {\n             MetaItemKind::Word => Ok(Cfg::Cfg(name, None)),\n             MetaItemKind::NameValue(ref lit) => match lit.node {\n@@ -436,6 +436,42 @@ mod test {\n         Cfg::Cfg(Symbol::intern(name), Some(Symbol::intern(value)))\n     }\n \n+    fn dummy_meta_item_word(name: &str) -> MetaItem {\n+        MetaItem {\n+            ident: Path::from_ident(Ident::from_str(name)),\n+            node: MetaItemKind::Word,\n+            span: DUMMY_SP,\n+        }\n+    }\n+\n+    macro_rules! dummy_meta_item_list {\n+        ($name:ident, [$($list:ident),* $(,)*]) => {\n+            MetaItem {\n+                ident: Path::from_ident(Ident::from_str(stringify!($name))),\n+                node: MetaItemKind::List(vec![\n+                    $(\n+                        dummy_spanned(NestedMetaItemKind::MetaItem(\n+                            dummy_meta_item_word(stringify!($list)),\n+                        )),\n+                    )*\n+                ]),\n+                span: DUMMY_SP,\n+            }\n+        };\n+\n+        ($name:ident, [$($list:expr),* $(,)*]) => {\n+            MetaItem {\n+                ident: Path::from_ident(Ident::from_str(stringify!($name))),\n+                node: MetaItemKind::List(vec![\n+                    $(\n+                        dummy_spanned(NestedMetaItemKind::MetaItem($list)),\n+                    )*\n+                ]),\n+                span: DUMMY_SP,\n+            }\n+        };\n+    }\n+\n     #[test]\n     fn test_cfg_not() {\n         with_globals(|| {\n@@ -561,15 +597,11 @@ mod test {\n     #[test]\n     fn test_parse_ok() {\n         with_globals(|| {\n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"all\"),\n-                node: MetaItemKind::Word,\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_word(\"all\");\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n \n             let mi = MetaItem {\n-                ident: Ident::from_str(\"all\"),\n+                ident: Path::from_ident(Ident::from_str(\"all\")),\n                 node: MetaItemKind::NameValue(dummy_spanned(LitKind::Str(\n                     Symbol::intern(\"done\"),\n                     StrStyle::Cooked,\n@@ -578,111 +610,24 @@ mod test {\n             };\n             assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"all\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"a\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"b\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(all, [a, b]);\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\")));\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"any\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"a\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"b\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(any, [a, b]);\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") | word_cfg(\"b\")));\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"not\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"a\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(not, [a]);\n             assert_eq!(Cfg::parse(&mi), Ok(!word_cfg(\"a\")));\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"not\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"any\"),\n-                        node: MetaItemKind::List(vec![\n-                            dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                ident: Ident::from_str(\"a\"),\n-                                node: MetaItemKind::Word,\n-                                span: DUMMY_SP,\n-                            })),\n-                            dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                ident: Ident::from_str(\"all\"),\n-                                node: MetaItemKind::List(vec![\n-                                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                        ident: Ident::from_str(\"b\"),\n-                                        node: MetaItemKind::Word,\n-                                        span: DUMMY_SP,\n-                                    })),\n-                                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                        ident: Ident::from_str(\"c\"),\n-                                        node: MetaItemKind::Word,\n-                                        span: DUMMY_SP,\n-                                    })),\n-                                ]),\n-                                span: DUMMY_SP,\n-                            })),\n-                        ]),\n-                        span: DUMMY_SP,\n-                    })),\n+            let mi = dummy_meta_item_list!(not, [\n+                dummy_meta_item_list!(any, [\n+                    dummy_meta_item_word(\"a\"),\n+                    dummy_meta_item_list!(all, [b, c]),\n                 ]),\n-                span: DUMMY_SP,\n-            };\n+            ]);\n             assert_eq!(Cfg::parse(&mi), Ok(!(word_cfg(\"a\") | (word_cfg(\"b\") & word_cfg(\"c\")))));\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"all\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"a\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"b\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"c\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(all, [a, b, c]);\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\")));\n         })\n     }\n@@ -691,97 +636,36 @@ mod test {\n     fn test_parse_err() {\n         with_globals(|| {\n             let mi = MetaItem {\n-                ident: Ident::from_str(\"foo\"),\n+                ident: Path::from_ident(Ident::from_str(\"foo\")),\n                 node: MetaItemKind::NameValue(dummy_spanned(LitKind::Bool(false))),\n                 span: DUMMY_SP,\n             };\n             assert!(Cfg::parse(&mi).is_err());\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"not\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"a\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"b\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(not, [a, b]);\n             assert!(Cfg::parse(&mi).is_err());\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"not\"),\n-                node: MetaItemKind::List(vec![]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(not, []);\n             assert!(Cfg::parse(&mi).is_err());\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"foo\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"a\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(foo, []);\n             assert!(Cfg::parse(&mi).is_err());\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"all\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"foo\"),\n-                        node: MetaItemKind::List(vec![]),\n-                        span: DUMMY_SP,\n-                    })),\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"b\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(all, [\n+                dummy_meta_item_list!(foo, []),\n+                dummy_meta_item_word(\"b\"),\n+            ]);\n             assert!(Cfg::parse(&mi).is_err());\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"any\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"a\"),\n-                        node: MetaItemKind::Word,\n-                        span: DUMMY_SP,\n-                    })),\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"foo\"),\n-                        node: MetaItemKind::List(vec![]),\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(any, [\n+                dummy_meta_item_word(\"a\"),\n+                dummy_meta_item_list!(foo, []),\n+            ]);\n             assert!(Cfg::parse(&mi).is_err());\n \n-            let mi = MetaItem {\n-                ident: Ident::from_str(\"not\"),\n-                node: MetaItemKind::List(vec![\n-                    dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        ident: Ident::from_str(\"foo\"),\n-                        node: MetaItemKind::List(vec![]),\n-                        span: DUMMY_SP,\n-                    })),\n-                ]),\n-                span: DUMMY_SP,\n-            };\n+            let mi = dummy_meta_item_list!(not, [\n+                dummy_meta_item_list!(foo, []),\n+            ]);\n             assert!(Cfg::parse(&mi).is_err());\n         })\n     }"}, {"sha": "edbf5f3abd25dc534494c5951c1746d711898f03", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1367,7 +1367,7 @@ impl TyParamBound {\n     fn maybe_sized(cx: &DocContext) -> TyParamBound {\n         let did = cx.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n         let empty = cx.tcx.intern_substs(&[]);\n-        let path = external_path(cx, &cx.tcx.item_name(did),\n+        let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n             Some(did), false, vec![], empty);\n         inline::record_extern_fqn(cx, did, TypeKind::Trait);\n         TraitBound(PolyTrait {\n@@ -1474,7 +1474,7 @@ impl<'a, 'tcx> Clean<TyParamBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n         let (trait_ref, ref bounds) = *self;\n         inline::record_extern_fqn(cx, trait_ref.def_id, TypeKind::Trait);\n-        let path = external_path(cx, &cx.tcx.item_name(trait_ref.def_id),\n+        let path = external_path(cx, &cx.tcx.item_name(trait_ref.def_id).as_str(),\n                                  Some(trait_ref.def_id), true, bounds.clone(), trait_ref.substs);\n \n         debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", trait_ref.substs);\n@@ -1755,8 +1755,18 @@ pub struct Generics {\n \n impl Clean<Generics> for hir::Generics {\n     fn clean(&self, cx: &DocContext) -> Generics {\n+        let mut params = Vec::with_capacity(self.params.len());\n+        for p in &self.params {\n+            let p = p.clean(cx);\n+            if let GenericParam::Type(ref tp) = p {\n+                if tp.synthetic == Some(hir::SyntheticTyParamKind::ImplTrait) {\n+                    cx.impl_trait_bounds.borrow_mut().insert(tp.did, tp.bounds.clone());\n+                }\n+            }\n+            params.push(p);\n+        }\n         let mut g = Generics {\n-            params: self.params.clean(cx),\n+            params,\n             where_predicates: self.where_clause.predicates.clean(cx)\n         };\n \n@@ -1869,9 +1879,11 @@ pub struct Method {\n \n impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId) {\n     fn clean(&self, cx: &DocContext) -> Method {\n-        let generics = self.1.clean(cx);\n+        let (generics, decl) = enter_impl_trait(cx, || {\n+            (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx))\n+        });\n         Method {\n-            decl: enter_impl_trait(cx, &generics.params, || (&*self.0.decl, self.2).clean(cx)),\n+            decl,\n             generics,\n             unsafety: self.0.unsafety,\n             constness: self.0.constness,\n@@ -1899,8 +1911,9 @@ pub struct Function {\n \n impl Clean<Item> for doctree::Function {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        let generics = self.generics.clean(cx);\n-        let decl = enter_impl_trait(cx, &generics.params, || (&self.decl, self.body).clean(cx));\n+        let (generics, decl) = enter_impl_trait(cx, || {\n+            (self.generics.clean(cx), (&self.decl, self.body).clean(cx))\n+        });\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -2139,12 +2152,12 @@ impl Clean<Item> for hir::TraitItem {\n                 MethodItem((sig, &self.generics, body).clean(cx))\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(ref names)) => {\n-                let generics = self.generics.clean(cx);\n+                let (generics, decl) = enter_impl_trait(cx, || {\n+                    (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n+                });\n                 TyMethodItem(TyMethod {\n                     unsafety: sig.unsafety.clone(),\n-                    decl: enter_impl_trait(cx, &generics.params, || {\n-                        (&*sig.decl, &names[..]).clean(cx)\n-                    }),\n+                    decl,\n                     generics,\n                     abi: sig.abi\n                 })\n@@ -2801,7 +2814,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     AdtKind::Enum => TypeKind::Enum,\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n-                let path = external_path(cx, &cx.tcx.item_name(did),\n+                let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n                                          None, false, vec![], substs);\n                 ResolvedPath {\n                     path,\n@@ -2812,7 +2825,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             }\n             ty::TyForeign(did) => {\n                 inline::record_extern_fqn(cx, did, TypeKind::Foreign);\n-                let path = external_path(cx, &cx.tcx.item_name(did),\n+                let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n                                          None, false, vec![], Substs::empty());\n                 ResolvedPath {\n                     path: path,\n@@ -2830,7 +2843,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     reg.clean(cx).map(|b| typarams.push(RegionBound(b)));\n                     for did in obj.auto_traits() {\n                         let empty = cx.tcx.intern_substs(&[]);\n-                        let path = external_path(cx, &cx.tcx.item_name(did),\n+                        let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n                             Some(did), false, vec![], empty);\n                         inline::record_extern_fqn(cx, did, TypeKind::Trait);\n                         let bound = TraitBound(PolyTrait {\n@@ -2853,7 +2866,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                         });\n                     }\n \n-                    let path = external_path(cx, &cx.tcx.item_name(did), Some(did),\n+                    let path = external_path(cx, &cx.tcx.item_name(did).as_str(), Some(did),\n                         false, bindings, principal.skip_binder().substs);\n                     ResolvedPath {\n                         path,\n@@ -3415,12 +3428,12 @@ pub struct BareFunctionDecl {\n \n impl Clean<BareFunctionDecl> for hir::BareFnTy {\n     fn clean(&self, cx: &DocContext) -> BareFunctionDecl {\n-        let generic_params = self.generic_params.clean(cx);\n+        let (generic_params, decl) = enter_impl_trait(cx, || {\n+            (self.generic_params.clean(cx), (&*self.decl, &self.arg_names[..]).clean(cx))\n+        });\n         BareFunctionDecl {\n             unsafety: self.unsafety,\n-            decl: enter_impl_trait(cx, &generic_params, || {\n-                (&*self.decl, &self.arg_names[..]).clean(cx)\n-            }),\n+            decl,\n             generic_params,\n             abi: self.abi,\n         }\n@@ -3661,7 +3674,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let denied = self.vis != hir::Public || self.attrs.iter().any(|a| {\n-            a.name().unwrap() == \"doc\" && match a.meta_item_list() {\n+            a.name() == \"doc\" && match a.meta_item_list() {\n                 Some(l) => attr::list_contains_name(&l, \"no_inline\") ||\n                            attr::list_contains_name(&l, \"hidden\"),\n                 None => false,\n@@ -3722,11 +3735,11 @@ impl Clean<Item> for hir::ForeignItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n             hir::ForeignItemFn(ref decl, ref names, ref generics) => {\n-                let generics = generics.clean(cx);\n+                let (generics, decl) = enter_impl_trait(cx, || {\n+                    (generics.clean(cx), (&**decl, &names[..]).clean(cx))\n+                });\n                 ForeignFunctionItem(Function {\n-                    decl: enter_impl_trait(cx, &generics.params, || {\n-                        (&**decl, &names[..]).clean(cx)\n-                    }),\n+                    decl,\n                     generics,\n                     unsafety: hir::Unsafety::Unsafe,\n                     abi: Abi::Rust,\n@@ -3881,6 +3894,7 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::Union(i) => (i, TypeKind::Union),\n         Def::Mod(i) => (i, TypeKind::Module),\n         Def::TyForeign(i) => (i, TypeKind::Foreign),\n+        Def::Const(i) => (i, TypeKind::Const),\n         Def::Static(i, _) => (i, TypeKind::Static),\n         Def::Variant(i) => (cx.tcx.parent_def_id(i).unwrap(), TypeKind::Enum),\n         Def::Macro(i, _) => (i, TypeKind::Macro),\n@@ -4029,23 +4043,11 @@ pub fn def_id_to_path(cx: &DocContext, did: DefId, name: Option<String>) -> Vec<\n     once(crate_name).chain(relative).collect()\n }\n \n-pub fn enter_impl_trait<F, R>(cx: &DocContext, gps: &[GenericParam], f: F) -> R\n+pub fn enter_impl_trait<F, R>(cx: &DocContext, f: F) -> R\n where\n     F: FnOnce() -> R,\n {\n-    let bounds = gps.iter()\n-        .filter_map(|p| {\n-            if let GenericParam::Type(ref tp) = *p {\n-                if tp.synthetic == Some(hir::SyntheticTyParamKind::ImplTrait) {\n-                    return Some((tp.did, tp.bounds.clone()));\n-                }\n-            }\n-\n-            None\n-        })\n-        .collect::<FxHashMap<DefId, Vec<TyParamBound>>>();\n-\n-    let old_bounds = mem::replace(&mut *cx.impl_trait_bounds.borrow_mut(), bounds);\n+    let old_bounds = mem::replace(&mut *cx.impl_trait_bounds.borrow_mut(), Default::default());\n     let r = f();\n     assert!(cx.impl_trait_bounds.borrow().is_empty());\n     *cx.impl_trait_bounds.borrow_mut() = old_bounds;"}, {"sha": "61fb0b40c231560b8005af5f1997b706a41f190e", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -177,7 +177,7 @@ pub fn run_core(search_paths: SearchPaths,\n                 None,\n                 codemap.clone(),\n                 pretty,\n-                sessopts.debugging_opts.approximate_suggestions,\n+                sessopts.debugging_opts.suggestion_applicability,\n             ).ui_testing(sessopts.debugging_opts.ui_testing)\n         ),\n         ErrorOutputType::Short(color_config) => Box::new("}, {"sha": "5e93b20ea17fdb978b06693c5c38b4fb51c69bac", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -146,9 +146,9 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n         window.rootPath = \\\"{root_path}\\\";\\\n         window.currentCrate = \\\"{krate}\\\";\\\n     </script>\\\n+    <script src=\\\"{root_path}aliases.js\\\"></script>\\\n     <script src=\\\"{root_path}main{suffix}.js\\\"></script>\\\n     <script defer src=\\\"{root_path}search-index.js\\\"></script>\\\n-    <script defer src=\\\"{root_path}aliases.js\\\"></script>\\\n </body>\\\n </html>\",\n     css_extension = if css_file_extension {"}, {"sha": "21de2db1dfe74fd7bf1930e06b38b3e20589b31b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1427,7 +1427,7 @@ impl<'a> Cache {\n         }\n         if let Some(ref item_name) = item.name {\n             let path = self.paths.get(&item.def_id)\n-                                 .map(|p| p.0.join(\"::\").to_string())\n+                                 .map(|p| p.0[..p.0.len() - 1].join(\"::\"))\n                                  .unwrap_or(\"std\".to_owned());\n             for alias in item.attrs.lists(\"doc\")\n                                    .filter(|a| a.check_name(\"alias\"))\n@@ -1595,6 +1595,8 @@ impl<'a> Settings<'a> {\n             settings: vec![\n                 (\"item-declarations\", \"Auto-hide item declarations.\", true),\n                 (\"item-attributes\", \"Auto-hide item attributes.\", true),\n+                (\"go-to-only-result\", \"Directly go to item in search if there is only one result\",\n+                 false),\n             ],\n             root_path,\n             suffix,\n@@ -3282,7 +3284,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n }\n \n fn render_attribute(attr: &ast::MetaItem) -> Option<String> {\n-    let name = attr.ident.name;\n+    let name = attr.name();\n \n     if attr.is_word() {\n         Some(format!(\"{}\", name))\n@@ -3317,7 +3319,7 @@ fn render_attributes(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     let mut attrs = String::new();\n \n     for attr in &it.attrs.other_attrs {\n-        let name = attr.name().unwrap();\n+        let name = attr.name();\n         if !ATTRIBUTE_WHITELIST.contains(&&*name.as_str()) {\n             continue;\n         }"}, {"sha": "6d80145b29c7c271a70a5b42166fd6231890de3b", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 58, "deletions": 32, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1013,7 +1013,8 @@\n                 'returned': sortResults(results_returned, true),\n                 'others': sortResults(results),\n             };\n-            if (ALIASES[window.currentCrate][query.raw]) {\n+            if (ALIASES && ALIASES[window.currentCrate] &&\n+                    ALIASES[window.currentCrate][query.raw]) {\n                 var aliases = ALIASES[window.currentCrate][query.raw];\n                 for (var i = 0; i < aliases.length; ++i) {\n                     ret['others'].unshift(aliases[i]);\n@@ -1188,6 +1189,44 @@\n             return '<span>' + path.replace(/::/g, '::</span><span>');\n         }\n \n+        function buildHrefAndPath(item) {\n+            var displayPath;\n+            var href;\n+            var type = itemTypes[item.ty];\n+            var name = item.name;\n+\n+            if (type === 'mod') {\n+                displayPath = item.path + '::';\n+                href = rootPath + item.path.replace(/::/g, '/') + '/' +\n+                       name + '/index.html';\n+            } else if (type === \"primitive\") {\n+                displayPath = \"\";\n+                href = rootPath + item.path.replace(/::/g, '/') +\n+                       '/' + type + '.' + name + '.html';\n+            } else if (type === \"externcrate\") {\n+                displayPath = \"\";\n+                href = rootPath + name + '/index.html';\n+            } else if (item.parent !== undefined) {\n+                var myparent = item.parent;\n+                var anchor = '#' + type + '.' + name;\n+                var parentType = itemTypes[myparent.ty];\n+                if (parentType === \"primitive\") {\n+                    displayPath = myparent.name + '::';\n+                } else {\n+                    displayPath = item.path + '::' + myparent.name + '::';\n+                }\n+                href = rootPath + item.path.replace(/::/g, '/') +\n+                       '/' + parentType +\n+                       '.' + myparent.name +\n+                       '.html' + anchor;\n+            } else {\n+                displayPath = item.path + '::';\n+                href = rootPath + item.path.replace(/::/g, '/') +\n+                       '/' + type + '.' + name + '.html';\n+            }\n+            return [displayPath, href];\n+        }\n+\n         function addTab(array, query, display) {\n             var extraStyle = '';\n             if (display === false) {\n@@ -1211,35 +1250,9 @@\n                     name = item.name;\n                     type = itemTypes[item.ty];\n \n-                    if (type === 'mod') {\n-                        displayPath = item.path + '::';\n-                        href = rootPath + item.path.replace(/::/g, '/') + '/' +\n-                               name + '/index.html';\n-                    } else if (type === \"primitive\") {\n-                        displayPath = \"\";\n-                        href = rootPath + item.path.replace(/::/g, '/') +\n-                               '/' + type + '.' + name + '.html';\n-                    } else if (type === \"externcrate\") {\n-                        displayPath = \"\";\n-                        href = rootPath + name + '/index.html';\n-                    } else if (item.parent !== undefined) {\n-                        var myparent = item.parent;\n-                        var anchor = '#' + type + '.' + name;\n-                        var parentType = itemTypes[myparent.ty];\n-                        if (parentType === \"primitive\") {\n-                            displayPath = myparent.name + '::';\n-                        } else {\n-                            displayPath = item.path + '::' + myparent.name + '::';\n-                        }\n-                        href = rootPath + item.path.replace(/::/g, '/') +\n-                               '/' + parentType +\n-                               '.' + myparent.name +\n-                               '.html' + anchor;\n-                    } else {\n-                        displayPath = item.path + '::';\n-                        href = rootPath + item.path.replace(/::/g, '/') +\n-                               '/' + type + '.' + name + '.html';\n-                    }\n+                    var res = buildHrefAndPath(item);\n+                    var href = res[1];\n+                    var displayPath = res[0];\n \n                     output += '<tr class=\"' + type + ' result\"><td>' +\n                               '<a href=\"' + href + '\">' +\n@@ -1268,6 +1281,16 @@\n         }\n \n         function showResults(results) {\n+            if (results['others'].length === 1 &&\n+                getCurrentValue('rustdoc-go-to-only-result') === \"true\") {\n+                var elem = document.createElement('a');\n+                var res = buildHrefAndPath(results['others'][0]);\n+                elem.href = res[1];\n+                elem.style.display = 'none';\n+                // For firefox, we need the element to be in the DOM so it can be clicked.\n+                document.body.appendChild(elem);\n+                elem.click();\n+            }\n             var output, query = getQuery(search_input.value);\n \n             currentResults = query.id;\n@@ -1721,6 +1744,9 @@\n \n     function toggleAllDocs(pageId) {\n         var toggle = document.getElementById(\"toggle-all-docs\");\n+        if (!toggle) {\n+            return;\n+        }\n         if (hasClass(toggle, \"will-expand\")) {\n             updateLocalStorage(\"rustdoc-collapse\", \"false\");\n             removeClass(toggle, \"will-expand\");\n@@ -1970,14 +1996,14 @@\n         if (e.parentNode.id === \"main\") {\n             var otherMessage;\n             if (hasClass(e, \"type-decl\")) {\n-                otherMessage = '&nbsp;Show&nbsp;type&nbsp;declaration';\n+                otherMessage = '&nbsp;Show&nbsp;declaration';\n             }\n             e.parentNode.insertBefore(createToggle(otherMessage), e);\n             if (otherMessage && getCurrentValue('rustdoc-item-declarations') !== \"false\") {\n                 collapseDocs(e.previousSibling.childNodes[0], \"toggle\");\n             }\n         }\n-    })\n+    });\n \n     autoCollapseAllImpls(getPageId());\n "}, {"sha": "059d41698953d2a4fcb85e36b1e45fd7e264ffa8", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -13,6 +13,8 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\")]\n \n+#![cfg_attr(stage0, feature(dyn_trait))]\n+\n #![feature(ascii_ctype)]\n #![feature(rustc_private)]\n #![feature(box_patterns)]\n@@ -23,14 +25,12 @@\n #![feature(test)]\n #![feature(vec_remove_item)]\n #![feature(entry_and_modify)]\n-#![feature(dyn_trait)]\n \n extern crate arena;\n extern crate getopts;\n extern crate env_logger;\n extern crate rustc;\n extern crate rustc_data_structures;\n-extern crate rustc_const_math;\n extern crate rustc_trans_utils;\n extern crate rustc_driver;\n extern crate rustc_resolve;"}, {"sha": "6db02cc6cc105b7301d725aeef69535ff3ff4465", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -49,7 +49,6 @@ pub struct RustdocVisitor<'a, 'tcx: 'a, 'rcx: 'a> {\n     inlining: bool,\n     /// Is the current module and all of its parents public?\n     inside_public_path: bool,\n-    reexported_macros: FxHashSet<DefId>,\n     exact_paths: Option<FxHashMap<DefId, Vec<String>>>,\n }\n \n@@ -66,7 +65,6 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             view_item_stack: stack,\n             inlining: false,\n             inside_public_path: true,\n-            reexported_macros: FxHashSet(),\n             exact_paths: Some(FxHashMap()),\n             cstore,\n         }\n@@ -221,7 +219,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         if let Some(exports) = self.cx.tcx.module_exports(def_id) {\n             for export in exports.iter().filter(|e| e.vis == Visibility::Public) {\n                 if let Def::Macro(def_id, ..) = export.def {\n-                    if def_id.krate == LOCAL_CRATE || self.reexported_macros.contains(&def_id) {\n+                    if def_id.krate == LOCAL_CRATE {\n                         continue // These are `krate.exported_macros`, handled in `self.visit()`.\n                     }\n \n@@ -298,17 +296,6 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         let is_no_inline = use_attrs.lists(\"doc\").has_word(\"no_inline\") ||\n                            use_attrs.lists(\"doc\").has_word(\"hidden\");\n \n-        // Memoize the non-inlined `pub use`'d macros so we don't push an extra\n-        // declaration in `visit_mod_contents()`\n-        if !def_did.is_local() {\n-            if let Def::Macro(did, _) = def {\n-                if please_inline { return true }\n-                debug!(\"memoizing non-inlined macro export: {:?}\", def);\n-                self.reexported_macros.insert(did);\n-                return false;\n-            }\n-        }\n-\n         // For cross-crate impl inlining we need to know whether items are\n         // reachable in documentation - a previously nonreachable item can be\n         // made reachable by cross-crate inlining which we're checking here."}, {"sha": "a7eb002d5a1d99995ee0c7e8008523a621492bce", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -33,6 +33,7 @@ const MIN_NONZERO_RAW_CAPACITY: usize = 32;     // must be a power of two\n struct DefaultResizePolicy;\n \n impl DefaultResizePolicy {\n+    #[inline]\n     fn new() -> DefaultResizePolicy {\n         DefaultResizePolicy\n     }"}, {"sha": "b50652ed6b557759ddc7949eafa511b36e76fa40", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -79,7 +79,7 @@ impl TaggedHashUintPtr {\n ///\n /// Essential invariants of this structure:\n ///\n-///   - if t.hashes[i] == EMPTY_BUCKET, then `Bucket::at_index(&t, i).raw`\n+///   - if `t.hashes[i] == EMPTY_BUCKET`, then `Bucket::at_index(&t, i).raw`\n ///     points to 'undefined' contents. Don't read from it. This invariant is\n ///     enforced outside this module with the `EmptyBucket`, `FullBucket`,\n ///     and `SafeHash` types."}, {"sha": "817eea5eaf142306bcb6856907f3f72adb158853", "filename": "src/libstd/error.rs", "status": "modified", "additions": 26, "deletions": 39, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -9,34 +9,6 @@\n // except according to those terms.\n \n //! Traits for working with Errors.\n-//!\n-//! # The `Error` trait\n-//!\n-//! `Error` is a trait representing the basic expectations for error values,\n-//! i.e. values of type `E` in [`Result<T, E>`]. At a minimum, errors must provide\n-//! a description, but they may optionally provide additional detail (via\n-//! [`Display`]) and cause chain information:\n-//!\n-//! ```\n-//! use std::fmt::Display;\n-//!\n-//! trait Error: Display {\n-//!     fn description(&self) -> &str;\n-//!\n-//!     fn cause(&self) -> Option<&Error> { None }\n-//! }\n-//! ```\n-//!\n-//! The [`cause`] method is generally used when errors cross \"abstraction\n-//! boundaries\", i.e.  when a one module must report an error that is \"caused\"\n-//! by an error from a lower-level module. This setup makes it possible for the\n-//! high-level module to provide its own errors that do not commit to any\n-//! particular implementation, but also reveal some of its implementation for\n-//! debugging via [`cause`] chains.\n-//!\n-//! [`Result<T, E>`]: ../result/enum.Result.html\n-//! [`Display`]: ../fmt/trait.Display.html\n-//! [`cause`]: trait.Error.html#method.cause\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -63,33 +35,48 @@ use num;\n use str;\n use string;\n \n-/// Base functionality for all errors in Rust.\n+/// `Error` is a trait representing the basic expectations for error values,\n+/// i.e. values of type `E` in [`Result<T, E>`]. Errors must describe\n+/// themselves through the [`Display`] and [`Debug`] traits, and may provide\n+/// cause chain information:\n+///\n+/// The [`cause`] method is generally used when errors cross \"abstraction\n+/// boundaries\", i.e.  when a one module must report an error that is \"caused\"\n+/// by an error from a lower-level module. This setup makes it possible for the\n+/// high-level module to provide its own errors that do not commit to any\n+/// particular implementation, but also reveal some of its implementation for\n+/// debugging via [`cause`] chains.\n+///\n+/// [`Result<T, E>`]: ../result/enum.Result.html\n+/// [`Display`]: ../fmt/trait.Display.html\n+/// [`cause`]: trait.Error.html#method.cause\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Error: Debug + Display {\n-    /// A short description of the error.\n+    /// **This method is soft-deprecated.**\n     ///\n-    /// The description should only be used for a simple message.\n-    /// It should not contain newlines or sentence-ending punctuation,\n-    /// to facilitate embedding in larger user-facing strings.\n-    /// For showing formatted error messages with more information see\n-    /// [`Display`].\n+    /// Although using it won\u2019t cause compilation warning,\n+    /// new code should use [`Display`] instead\n+    /// and new `impl`s can omit it.\n+    ///\n+    /// To obtain error description as a string, use `to_string()`.\n     ///\n     /// [`Display`]: ../fmt/trait.Display.html\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::error::Error;\n-    ///\n     /// match \"xc\".parse::<u32>() {\n     ///     Err(e) => {\n-    ///         println!(\"Error: {}\", e.description());\n+    ///         // Print `e` itself, not `e.description()`.\n+    ///         println!(\"Error: {}\", e);\n     ///     }\n     ///     _ => println!(\"No error\"),\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn description(&self) -> &str;\n+    fn description(&self) -> &str {\n+        \"description() is deprecated; use Display\"\n+    }\n \n     /// The lower-level cause of this error, if any.\n     ///"}, {"sha": "7c358aafa9ba2c2be230b068e80a02406f1be065", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -988,6 +988,7 @@ impl CStr {\n     /// behavior when `ptr` is used inside the `unsafe` block:\n     ///\n     /// ```no_run\n+    /// # #![allow(unused_must_use)]\n     /// use std::ffi::{CString};\n     ///\n     /// let ptr = CString::new(\"Hello\").unwrap().as_ptr();\n@@ -1003,6 +1004,7 @@ impl CStr {\n     /// To fix the problem, bind the `CString` to a local variable:\n     ///\n     /// ```no_run\n+    /// # #![allow(unused_must_use)]\n     /// use std::ffi::{CString};\n     ///\n     /// let hello = CString::new(\"Hello\").unwrap();\n@@ -1118,6 +1120,7 @@ impl CStr {\n     ///\n     /// [`Cow`]: ../borrow/enum.Cow.html\n     /// [`Borrowed`]: ../borrow/enum.Cow.html#variant.Borrowed\n+    /// [`Owned`]: ../borrow/enum.Cow.html#variant.Owned\n     /// [`str`]: ../primitive.str.html\n     /// [`String`]: ../string/struct.String.html\n     ///"}, {"sha": "d41739ab02c6ad90c19d55dbe7fe0d644a1dbb56", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -273,7 +273,6 @@\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(linkage)]\n-#![feature(macro_reexport)]\n #![feature(macro_vis_matcher)]\n #![feature(needs_panic_runtime)]\n #![feature(never_type)]\n@@ -313,6 +312,7 @@\n #![feature(unboxed_closures)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n+#![feature(use_extern_macros)]\n #![feature(vec_push_all)]\n #![feature(doc_cfg)]\n #![feature(doc_masked)]\n@@ -330,10 +330,10 @@\n // with a rustc without jemalloc.\n // FIXME(#44236) shouldn't need MSVC logic\n #![cfg_attr(all(not(target_env = \"msvc\"),\n-                any(stage0, feature = \"force_alloc_system\")),\n+                any(all(stage0, not(test)), feature = \"force_alloc_system\")),\n             feature(global_allocator))]\n #[cfg(all(not(target_env = \"msvc\"),\n-          any(stage0, feature = \"force_alloc_system\")))]\n+          any(all(stage0, not(test)), feature = \"force_alloc_system\")))]\n #[global_allocator]\n static ALLOC: alloc_system::System = alloc_system::System;\n \n@@ -347,15 +347,14 @@ use prelude::v1::*;\n #[cfg(test)] extern crate test;\n #[cfg(test)] extern crate rand;\n \n-// We want to re-export a few macros from core but libcore has already been\n-// imported by the compiler (via our #[no_std] attribute) In this case we just\n-// add a new crate name so we can attach the re-exports to it.\n-#[macro_reexport(assert_eq, assert_ne, debug_assert, debug_assert_eq,\n-                 debug_assert_ne, unreachable, unimplemented, write, writeln, try)]\n-extern crate core as __core;\n+// Re-export a few macros from core\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::{assert_eq, assert_ne, debug_assert, debug_assert_eq, debug_assert_ne};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::{unreachable, unimplemented, write, writeln, try};\n \n+#[allow(unused_imports)] // macros from `alloc` are not used on all platforms\n #[macro_use]\n-#[macro_reexport(vec, format)]\n extern crate alloc as alloc_crate;\n extern crate alloc_system;\n #[doc(masked)]\n@@ -450,6 +449,8 @@ pub use alloc_crate::borrow;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::fmt;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use alloc_crate::format;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::slice;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::str;"}, {"sha": "d1274a4090087b61351444b37d2dc510aeb75ec6", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -450,8 +450,8 @@ pub mod builtin {\n     #[unstable(feature = \"concat_idents_macro\", issue = \"29599\")]\n     #[macro_export]\n     macro_rules! concat_idents {\n-        ($($e:ident),*) => ({ /* compiler built-in */ });\n-        ($($e:ident,)*) => ({ /* compiler built-in */ });\n+        ($($e:ident),+) => ({ /* compiler built-in */ });\n+        ($($e:ident,)+) => ({ /* compiler built-in */ });\n     }\n \n     /// Concatenates literals into a static string slice."}, {"sha": "e80c3eeb876ceebd05cab882fce8da1ce7181ad6", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -13,11 +13,10 @@ use hash;\n use io;\n use mem;\n use net::{ntoh, hton, IpAddr, Ipv4Addr, Ipv6Addr};\n-#[allow(deprecated)]\n-use net::lookup_host;\n use option;\n use sys::net::netc as c;\n use sys_common::{FromInner, AsInner, IntoInner};\n+use sys_common::net::lookup_host;\n use vec;\n use iter;\n use slice;\n@@ -856,7 +855,6 @@ impl ToSocketAddrs for (Ipv6Addr, u16) {\n     }\n }\n \n-#[allow(deprecated)]\n fn resolve_socket_addr(s: &str, p: u16) -> io::Result<vec::IntoIter<SocketAddr>> {\n     let ips = lookup_host(s)?;\n     let v: Vec<_> = ips.map(|mut a| { a.set_port(p); a }).collect();"}, {"sha": "be4bcee8a68aeb0f1c098670fb6cb3bc4c51ee71", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -38,9 +38,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use fmt;\n use io::{self, Error, ErrorKind};\n-use sys_common::net as net_imp;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::ip::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n@@ -128,66 +126,3 @@ fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\n                    \"could not resolve to any addresses\")\n     }))\n }\n-\n-/// An iterator over `SocketAddr` values returned from a host lookup operation.\n-#[unstable(feature = \"lookup_host\", reason = \"unsure about the returned \\\n-                                              iterator and returning socket \\\n-                                              addresses\",\n-           issue = \"27705\")]\n-#[rustc_deprecated(since = \"1.25.0\", reason = \"Use the ToSocketAddrs trait instead\")]\n-pub struct LookupHost(net_imp::LookupHost);\n-\n-#[unstable(feature = \"lookup_host\", reason = \"unsure about the returned \\\n-                                              iterator and returning socket \\\n-                                              addresses\",\n-           issue = \"27705\")]\n-#[rustc_deprecated(since = \"1.25.0\", reason = \"Use the ToSocketAddrs trait instead\")]\n-#[allow(deprecated)]\n-impl Iterator for LookupHost {\n-    type Item = SocketAddr;\n-    fn next(&mut self) -> Option<SocketAddr> { self.0.next() }\n-}\n-\n-#[unstable(feature = \"lookup_host\", reason = \"unsure about the returned \\\n-                                              iterator and returning socket \\\n-                                              addresses\",\n-           issue = \"27705\")]\n-#[rustc_deprecated(since = \"1.25.0\", reason = \"Use the ToSocketAddrs trait instead\")]\n-#[allow(deprecated)]\n-impl fmt::Debug for LookupHost {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"LookupHost { .. }\")\n-    }\n-}\n-\n-/// Resolve the host specified by `host` as a number of `SocketAddr` instances.\n-///\n-/// This method may perform a DNS query to resolve `host` and may also inspect\n-/// system configuration to resolve the specified hostname.\n-///\n-/// The returned iterator will skip over any unknown addresses returned by the\n-/// operating system.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// #![feature(lookup_host)]\n-///\n-/// use std::net;\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     for host in net::lookup_host(\"rust-lang.org\")? {\n-///         println!(\"found address: {}\", host);\n-///     }\n-///     Ok(())\n-/// }\n-/// ```\n-#[unstable(feature = \"lookup_host\", reason = \"unsure about the returned \\\n-                                              iterator and returning socket \\\n-                                              addresses\",\n-           issue = \"27705\")]\n-#[rustc_deprecated(since = \"1.25.0\", reason = \"Use the ToSocketAddrs trait instead\")]\n-#[allow(deprecated)]\n-pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n-    net_imp::lookup_host(host).map(LookupHost)\n-}"}, {"sha": "229034eb7790b029c30b087b733212441fb4c581", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -31,10 +31,14 @@ pub use core::panic::{PanicInfo, Location};\n /// A marker trait which represents \"panic safe\" types in Rust.\n ///\n /// This trait is implemented by default for many types and behaves similarly in\n-/// terms of inference of implementation to the `Send` and `Sync` traits. The\n-/// purpose of this trait is to encode what types are safe to cross a `catch_unwind`\n+/// terms of inference of implementation to the [`Send`] and [`Sync`] traits. The\n+/// purpose of this trait is to encode what types are safe to cross a [`catch_unwind`]\n /// boundary with no fear of unwind safety.\n ///\n+/// [`Send`]: ../marker/trait.Send.html\n+/// [`Sync`]: ../marker/trait.Sync.html\n+/// [`catch_unwind`]: ./fn.catch_unwind.html\n+///\n /// ## What is unwind safety?\n ///\n /// In Rust a function can \"return\" early if it either panics or calls a\n@@ -95,12 +99,13 @@ pub use core::panic::{PanicInfo, Location};\n ///\n /// ## When should `UnwindSafe` be used?\n ///\n-/// Is not intended that most types or functions need to worry about this trait.\n-/// It is only used as a bound on the `catch_unwind` function and as mentioned above,\n-/// the lack of `unsafe` means it is mostly an advisory. The `AssertUnwindSafe`\n-/// wrapper struct in this module can be used to force this trait to be\n-/// implemented for any closed over variables passed to the `catch_unwind` function\n-/// (more on this below).\n+/// It is not intended that most types or functions need to worry about this trait.\n+/// It is only used as a bound on the `catch_unwind` function and as mentioned\n+/// above, the lack of `unsafe` means it is mostly an advisory. The\n+/// [`AssertUnwindSafe`] wrapper struct can be used to force this trait to be\n+/// implemented for any closed over variables passed to `catch_unwind`.\n+///\n+/// [`AssertUnwindSafe`]: ./struct.AssertUnwindSafe.html\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n #[rustc_on_unimplemented = \"the type {Self} may not be safely transferred \\\n                             across an unwind boundary\"]\n@@ -109,11 +114,14 @@ pub auto trait UnwindSafe {}\n /// A marker trait representing types where a shared reference is considered\n /// unwind safe.\n ///\n-/// This trait is namely not implemented by `UnsafeCell`, the root of all\n+/// This trait is namely not implemented by [`UnsafeCell`], the root of all\n /// interior mutability.\n ///\n /// This is a \"helper marker trait\" used to provide impl blocks for the\n-/// `UnwindSafe` trait, for more information see that documentation.\n+/// [`UnwindSafe`] trait, for more information see that documentation.\n+///\n+/// [`UnsafeCell`]: ../cell/struct.UnsafeCell.html\n+/// [`UnwindSafe`]: ./trait.UnwindSafe.html\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n #[rustc_on_unimplemented = \"the type {Self} may contain interior mutability \\\n                             and a reference may not be safely transferrable \\\n@@ -122,14 +130,15 @@ pub auto trait RefUnwindSafe {}\n \n /// A simple wrapper around a type to assert that it is unwind safe.\n ///\n-/// When using `catch_unwind` it may be the case that some of the closed over\n+/// When using [`catch_unwind`] it may be the case that some of the closed over\n /// variables are not unwind safe. For example if `&mut T` is captured the\n /// compiler will generate a warning indicating that it is not unwind safe. It\n /// may not be the case, however, that this is actually a problem due to the\n-/// specific usage of `catch_unwind` if unwind safety is specifically taken into\n+/// specific usage of [`catch_unwind`] if unwind safety is specifically taken into\n /// account. This wrapper struct is useful for a quick and lightweight\n /// annotation that a variable is indeed unwind safe.\n ///\n+/// [`catch_unwind`]: ./fn.catch_unwind.html\n /// # Examples\n ///\n /// One way to use `AssertUnwindSafe` is to assert that the entire closure\n@@ -318,18 +327,22 @@ impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n /// panic and allowing a graceful handling of the error.\n ///\n /// It is **not** recommended to use this function for a general try/catch\n-/// mechanism. The `Result` type is more appropriate to use for functions that\n+/// mechanism. The [`Result`] type is more appropriate to use for functions that\n /// can fail on a regular basis. Additionally, this function is not guaranteed\n /// to catch all panics, see the \"Notes\" section below.\n ///\n-/// The closure provided is required to adhere to the `UnwindSafe` trait to ensure\n+/// [`Result`]: ../result/enum.Result.html\n+///\n+/// The closure provided is required to adhere to the [`UnwindSafe`] trait to ensure\n /// that all captured variables are safe to cross this boundary. The purpose of\n /// this bound is to encode the concept of [exception safety][rfc] in the type\n /// system. Most usage of this function should not need to worry about this\n /// bound as programs are naturally unwind safe without `unsafe` code. If it\n-/// becomes a problem the associated `AssertUnwindSafe` wrapper type in this\n-/// module can be used to quickly assert that the usage here is indeed unwind\n-/// safe.\n+/// becomes a problem the [`AssertUnwindSafe`] wrapper struct can be used to quickly\n+/// assert that the usage here is indeed unwind safe.\n+///\n+/// [`AssertUnwindSafe`]: ./struct.AssertUnwindSafe.html\n+/// [`UnwindSafe`]: ./trait.UnwindSafe.html\n ///\n /// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n ///\n@@ -364,9 +377,11 @@ pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n \n /// Triggers a panic without invoking the panic hook.\n ///\n-/// This is designed to be used in conjunction with `catch_unwind` to, for\n+/// This is designed to be used in conjunction with [`catch_unwind`] to, for\n /// example, carry a panic across a layer of C code.\n ///\n+/// [`catch_unwind`]: ./fn.catch_unwind.html\n+///\n /// # Notes\n ///\n /// Note that panics in Rust are not always implemented via unwinding, but they"}, {"sha": "403056240bf57c3e7d917a9dcd1bb7f58ce34b23", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -76,7 +76,9 @@ static mut HOOK: Hook = Hook::Default;\n /// is invoked. As such, the hook will run with both the aborting and unwinding\n /// runtimes. The default hook prints a message to standard error and generates\n /// a backtrace if requested, but this behavior can be customized with the\n-/// `set_hook` and `take_hook` functions.\n+/// `set_hook` and [`take_hook`] functions.\n+///\n+/// [`take_hook`]: ./fn.take_hook.html\n ///\n /// The hook is provided with a `PanicInfo` struct which contains information\n /// about the origin of the panic, including the payload passed to `panic!` and\n@@ -121,6 +123,10 @@ pub fn set_hook(hook: Box<Fn(&PanicInfo) + 'static + Sync + Send>) {\n \n /// Unregisters the current panic hook, returning it.\n ///\n+/// *See also the function [`set_hook`].*\n+///\n+/// [`set_hook`]: ./fn.set_hook.html\n+///\n /// If no custom hook is registered, the default hook will be returned.\n ///\n /// # Panics"}, {"sha": "696711a70d4f6408cc773abf87d04ed932e64b02", "filename": "src/libstd/path.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -87,7 +87,6 @@ use io;\n use iter::{self, FusedIterator};\n use ops::{self, Deref};\n use rc::Rc;\n-use str::FromStr;\n use sync::Arc;\n \n use ffi::{OsStr, OsString};\n@@ -1441,32 +1440,6 @@ impl From<String> for PathBuf {\n     }\n }\n \n-/// Error returned from [`PathBuf::from_str`][`from_str`].\n-///\n-/// Note that parsing a path will never fail. This error is just a placeholder\n-/// for implementing `FromStr` for `PathBuf`.\n-///\n-/// [`from_str`]: struct.PathBuf.html#method.from_str\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-#[stable(feature = \"path_from_str\", since = \"1.26.0\")]\n-pub enum ParsePathError {}\n-\n-#[stable(feature = \"path_from_str\", since = \"1.26.0\")]\n-impl fmt::Display for ParsePathError {\n-    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {}\n-    }\n-}\n-\n-#[stable(feature = \"path_from_str\", since = \"1.26.0\")]\n-impl FromStr for PathBuf {\n-    type Err = ParsePathError;\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        Ok(PathBuf::from(s))\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<P: AsRef<Path>> iter::FromIterator<P> for PathBuf {\n     fn from_iter<I: IntoIterator<Item = P>>(iter: I) -> PathBuf {"}, {"sha": "9310dad9172a9f816436039b0d6bb4e15d836dc6", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -518,6 +518,7 @@ mod tests {\n         }\n     }\n \n+    #[allow(unused_must_use)]\n     #[test]\n     fn cloning() {\n         let (tx1, rx1) = channel::<i32>();\n@@ -540,6 +541,7 @@ mod tests {\n         tx3.send(()).unwrap();\n     }\n \n+    #[allow(unused_must_use)]\n     #[test]\n     fn cloning2() {\n         let (tx1, rx1) = channel::<i32>();"}, {"sha": "f8cd6103bdfa110e4e421ba0e5c129b1b2f4115c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -474,10 +474,10 @@ pub enum NestedMetaItemKind {\n \n /// A spanned compile-time attribute item.\n ///\n-/// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n+/// E.g. `#[test]`, `#[derive(..)]`, `#[rustfmt::skip]` or `#[feature = \"foo\"]`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MetaItem {\n-    pub ident: Ident,\n+    pub ident: Path,\n     pub node: MetaItemKind,\n     pub span: Span,\n }\n@@ -821,7 +821,7 @@ impl Stmt {\n \n     pub fn is_item(&self) -> bool {\n         match self.node {\n-            StmtKind::Local(_) => true,\n+            StmtKind::Item(_) => true,\n             _ => false,\n         }\n     }"}, {"sha": "ace9904e0c021e57b39ff6005883d6afbaa80d19", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 128, "deletions": 55, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -15,10 +15,10 @@ pub use self::ReprAttr::*;\n pub use self::IntType::*;\n \n use ast;\n-use ast::{AttrId, Attribute, Name, Ident};\n+use ast::{AttrId, Attribute, Name, Ident, Path, PathSegment};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind};\n-use codemap::{Spanned, respan, dummy_spanned};\n+use codemap::{BytePos, Spanned, respan, dummy_spanned};\n use syntax_pos::Span;\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n@@ -107,6 +107,14 @@ pub fn is_known(attr: &Attribute) -> bool {\n     })\n }\n \n+const RUST_KNOWN_TOOL: &[&str] = &[\"clippy\", \"rustfmt\"];\n+\n+pub fn is_known_tool(attr: &Attribute) -> bool {\n+    let tool_name =\n+        attr.path.segments.iter().next().expect(\"empty path in attribute\").ident.name;\n+    RUST_KNOWN_TOOL.contains(&tool_name.as_str().as_ref())\n+}\n+\n impl NestedMetaItem {\n     /// Returns the MetaItem if self is a NestedMetaItemKind::MetaItem.\n     pub fn meta_item(&self) -> Option<&MetaItem> {\n@@ -137,7 +145,7 @@ impl NestedMetaItem {\n     /// Returns the name of the meta item, e.g. `foo` in `#[foo]`,\n     /// `#[foo=\"bar\"]` and `#[foo(bar)]`, if self is a MetaItem\n     pub fn name(&self) -> Option<Name> {\n-        self.meta_item().and_then(|meta_item| Some(meta_item.ident.name))\n+        self.meta_item().and_then(|meta_item| Some(meta_item.name()))\n     }\n \n     /// Gets the string value if self is a MetaItem and the MetaItem is a\n@@ -154,7 +162,7 @@ impl NestedMetaItem {\n                     if meta_item_list.len() == 1 {\n                         let nested_item = &meta_item_list[0];\n                         if nested_item.is_literal() {\n-                            Some((meta_item.ident.name, nested_item.literal().unwrap()))\n+                            Some((meta_item.name(), nested_item.literal().unwrap()))\n                         } else {\n                             None\n                         }\n@@ -204,6 +212,10 @@ impl NestedMetaItem {\n     }\n }\n \n+fn name_from_path(path: &Path) -> Name {\n+    path.segments.last().expect(\"empty path in attribute\").ident.name\n+}\n+\n impl Attribute {\n     pub fn check_name(&self, name: &str) -> bool {\n         let matches = self.path == name;\n@@ -213,11 +225,10 @@ impl Attribute {\n         matches\n     }\n \n-    pub fn name(&self) -> Option<Name> {\n-        match self.path.segments.len() {\n-            1 => Some(self.path.segments[0].ident.name),\n-            _ => None,\n-        }\n+    /// Returns the **last** segment of the name of this attribute.\n+    /// E.g. `foo` for `#[foo]`, `skip` for `#[rustfmt::skip]`.\n+    pub fn name(&self) -> Name {\n+        name_from_path(&self.path)\n     }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n@@ -247,9 +258,17 @@ impl Attribute {\n     pub fn is_value_str(&self) -> bool {\n         self.value_str().is_some()\n     }\n+\n+    pub fn is_scoped(&self) -> bool {\n+        self.path.segments.len() > 1\n+    }\n }\n \n impl MetaItem {\n+    pub fn name(&self) -> Name {\n+        name_from_path(&self.ident)\n+    }\n+\n     pub fn value_str(&self) -> Option<Symbol> {\n         match self.node {\n             MetaItemKind::NameValue(ref v) => {\n@@ -279,7 +298,7 @@ impl MetaItem {\n     pub fn span(&self) -> Span { self.span }\n \n     pub fn check_name(&self, name: &str) -> bool {\n-        self.ident.name == name\n+        self.name() == name\n     }\n \n     pub fn is_value_str(&self) -> bool {\n@@ -296,10 +315,7 @@ impl Attribute {\n     pub fn meta(&self) -> Option<MetaItem> {\n         let mut tokens = self.tokens.trees().peekable();\n         Some(MetaItem {\n-            ident: match self.path.segments.len() {\n-                1 => self.path.segments[0].ident,\n-                _ => return None,\n-            },\n+            ident: self.path.clone(),\n             node: if let Some(node) = MetaItemKind::from_tokens(&mut tokens) {\n                 if tokens.peek().is_some() {\n                     return None;\n@@ -344,12 +360,8 @@ impl Attribute {\n     }\n \n     pub fn parse_meta<'a>(&self, sess: &'a ParseSess) -> PResult<'a, MetaItem> {\n-        if self.path.segments.len() > 1 {\n-            sess.span_diagnostic.span_err(self.path.span, \"expected ident, found path\");\n-        }\n-\n         Ok(MetaItem {\n-            ident: self.path.segments.last().unwrap().ident,\n+            ident: self.path.clone(),\n             node: self.parse(sess, |parser| parser.parse_meta_item_kind())?,\n             span: self.span,\n         })\n@@ -387,16 +399,17 @@ pub fn mk_name_value_item_str(ident: Ident, value: Spanned<Symbol>) -> MetaItem\n }\n \n pub fn mk_name_value_item(span: Span, ident: Ident, value: ast::Lit) -> MetaItem {\n-    MetaItem { ident, span, node: MetaItemKind::NameValue(value) }\n+    MetaItem { ident: Path::from_ident(ident), span, node: MetaItemKind::NameValue(value) }\n }\n \n pub fn mk_list_item(span: Span, ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n-    MetaItem { ident, span, node: MetaItemKind::List(items) }\n+    MetaItem { ident: Path::from_ident(ident), span, node: MetaItemKind::List(items) }\n }\n \n pub fn mk_word_item(ident: Ident) -> MetaItem {\n-    MetaItem { ident, span: ident.span, node: MetaItemKind::Word }\n+    MetaItem { ident: Path::from_ident(ident), span: ident.span, node: MetaItemKind::Word }\n }\n+\n pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n     respan(ident.span, NestedMetaItemKind::MetaItem(mk_word_item(ident)))\n }\n@@ -422,7 +435,7 @@ pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     Attribute {\n         id,\n         style: ast::AttrStyle::Inner,\n-        path: ast::Path::from_ident(item.ident),\n+        path: item.ident,\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n@@ -440,7 +453,7 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     Attribute {\n         id,\n         style: ast::AttrStyle::Outer,\n-        path: ast::Path::from_ident(item.ident),\n+        path: item.ident,\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n@@ -453,7 +466,7 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, span: Span) -> Attribute {\n     Attribute {\n         id,\n         style,\n-        path: ast::Path::from_ident(Ident::from_str(\"doc\").with_span_pos(span)),\n+        path: Path::from_ident(Ident::from_str(\"doc\").with_span_pos(span)),\n         tokens: MetaItemKind::NameValue(lit).tokens(span),\n         is_sugared_doc: true,\n         span,\n@@ -489,7 +502,7 @@ pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n         item.check_name(\"feature\") &&\n         item.meta_item_list().map(|list| {\n             list.iter().any(|mi| {\n-                mi.word().map(|w| w.ident.name == feature_name)\n+                mi.word().map(|w| w.name() == feature_name)\n                          .unwrap_or(false)\n             })\n         }).unwrap_or(false)\n@@ -562,7 +575,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n         if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n             gated_cfg.check_and_emit(sess, feats);\n         }\n-        sess.config.contains(&(cfg.ident.name, cfg.value_str()))\n+        sess.config.contains(&(cfg.name(), cfg.value_str()))\n     })\n }\n \n@@ -583,7 +596,7 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n \n             // The unwraps below may look dangerous, but we've already asserted\n             // that they won't fail with the loop above.\n-            match &*cfg.ident.name.as_str() {\n+            match &*cfg.name().as_str() {\n                 \"any\" => mis.iter().any(|mi| {\n                     eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n@@ -676,7 +689,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n             let meta = meta.as_ref().unwrap();\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.ident.name));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -695,14 +708,14 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     )+\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.ident.name.as_str() {\n+                            match &*mi.name().as_str() {\n                                 $(\n                                     stringify!($name)\n                                         => if !get(mi, &mut $name) { continue 'outer },\n                                 )+\n                                 _ => {\n                                     handle_errors(diagnostic, mi.span,\n-                                                  AttrError::UnknownMetaItem(mi.ident.name));\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n                                     continue 'outer\n                                 }\n                             }\n@@ -714,7 +727,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                 }\n             }\n \n-            match &*meta.ident.name.as_str() {\n+            match &*meta.name().as_str() {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n                         span_err!(diagnostic, item_sp, E0540,\n@@ -769,13 +782,13 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut issue = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.ident.name.as_str() {\n+                            match &*mi.name().as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n                                 \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n                                 _ => {\n                                     handle_errors(diagnostic, meta.span,\n-                                                  AttrError::UnknownMetaItem(mi.ident.name));\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n                                     continue 'outer\n                                 }\n                             }\n@@ -825,12 +838,12 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut since = None;\n                     for meta in metas {\n                         if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                            match &*mi.ident.name.as_str() {\n+                            match &*mi.name().as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"since\" => if !get(mi, &mut since) { continue 'outer },\n                                 _ => {\n                                     handle_errors(diagnostic, meta.span,\n-                                                  AttrError::UnknownMetaItem(mi.ident.name));\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n                                     continue 'outer\n                                 }\n                             }\n@@ -917,7 +930,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n         depr = if let Some(metas) = attr.meta_item_list() {\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.ident.name));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -933,12 +946,12 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n             let mut note = None;\n             for meta in metas {\n                 if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                    match &*mi.ident.name.as_str() {\n+                    match &*mi.name().as_str() {\n                         \"since\" => if !get(mi, &mut since) { continue 'outer },\n                         \"note\" => if !get(mi, &mut note) { continue 'outer },\n                         _ => {\n                             handle_errors(diagnostic, meta.span,\n-                                          AttrError::UnknownMetaItem(mi.ident.name));\n+                                          AttrError::UnknownMetaItem(mi.name()));\n                             continue 'outer\n                         }\n                     }\n@@ -990,7 +1003,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n \n                 let mut recognised = false;\n                 if let Some(mi) = item.word() {\n-                    let word = &*mi.ident.name.as_str();\n+                    let word = &*mi.name().as_str();\n                     let hint = match word {\n                         \"C\" => Some(ReprC),\n                         \"packed\" => Some(ReprPacked(1)),\n@@ -1012,11 +1025,11 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                     let parse_alignment = |node: &ast::LitKind| -> Result<u32, &'static str> {\n                         if let ast::LitKind::Int(literal, ast::LitIntType::Unsuffixed) = node {\n                             if literal.is_power_of_two() {\n-                                // rustc::ty::layout::Align restricts align to <= 2147483647\n-                                if *literal <= 2147483647 {\n+                                // rustc::ty::layout::Align restricts align to <= 2^29\n+                                if *literal <= 1 << 29 {\n                                     Ok(*literal as u32)\n                                 } else {\n-                                    Err(\"larger than 2147483647\")\n+                                    Err(\"larger than 2^29\")\n                                 }\n                             } else {\n                                 Err(\"not a power of two\")\n@@ -1045,6 +1058,30 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                         span_err!(diagnostic, item.span, E0589,\n                                   \"invalid `repr(align)` attribute: {}\", literal_error);\n                     }\n+                } else {\n+                    if let Some(meta_item) = item.meta_item() {\n+                        if meta_item.name() == \"align\" {\n+                            if let MetaItemKind::NameValue(ref value) = meta_item.node {\n+                                recognised = true;\n+                                let mut err = struct_span_err!(diagnostic, item.span, E0693,\n+                                    \"incorrect `repr(align)` attribute format\");\n+                                match value.node {\n+                                    ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n+                                        err.span_suggestion(item.span,\n+                                                            \"use parentheses instead\",\n+                                                            format!(\"align({})\", int));\n+                                    }\n+                                    ast::LitKind::Str(s, _) => {\n+                                        err.span_suggestion(item.span,\n+                                                            \"use parentheses instead\",\n+                                                            format!(\"align({})\", s));\n+                                    }\n+                                    _ => {}\n+                                }\n+                                err.emit();\n+                            }\n+                        }\n+                    }\n                 }\n                 if !recognised {\n                     // Not a word we recognize\n@@ -1103,18 +1140,56 @@ impl IntType {\n \n impl MetaItem {\n     fn tokens(&self) -> TokenStream {\n-        let ident = TokenTree::Token(self.span, Token::from_ast_ident(self.ident));\n-        TokenStream::concat(vec![ident.into(), self.node.tokens(self.span)])\n+        let mut idents = vec![];\n+        let mut last_pos = BytePos(0 as u32);\n+        for (i, segment) in self.ident.segments.iter().enumerate() {\n+            let is_first = i == 0;\n+            if !is_first {\n+                let mod_sep_span = Span::new(last_pos,\n+                                             segment.ident.span.lo(),\n+                                             segment.ident.span.ctxt());\n+                idents.push(TokenTree::Token(mod_sep_span, Token::ModSep).into());\n+            }\n+            idents.push(TokenTree::Token(segment.ident.span,\n+                                         Token::from_ast_ident(segment.ident)).into());\n+            last_pos = segment.ident.span.hi();\n+        }\n+        idents.push(self.node.tokens(self.span));\n+        TokenStream::concat(idents)\n     }\n \n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n         where I: Iterator<Item = TokenTree>,\n     {\n-        let (span, ident) = match tokens.next() {\n-            Some(TokenTree::Token(span, Token::Ident(ident, _))) => (span, ident),\n+        // FIXME: Share code with `parse_path`.\n+        let ident = match tokens.next() {\n+            Some(TokenTree::Token(span, Token::Ident(ident, _))) => {\n+                if let Some(TokenTree::Token(_, Token::ModSep)) = tokens.peek() {\n+                    let mut segments = vec![PathSegment::from_ident(ident.with_span_pos(span))];\n+                    tokens.next();\n+                    loop {\n+                        if let Some(TokenTree::Token(span,\n+                                                     Token::Ident(ident, _))) = tokens.next() {\n+                            segments.push(PathSegment::from_ident(ident.with_span_pos(span)));\n+                        } else {\n+                            return None;\n+                        }\n+                        if let Some(TokenTree::Token(_, Token::ModSep)) = tokens.peek() {\n+                            tokens.next();\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+                    let span = span.with_hi(segments.last().unwrap().ident.span.hi());\n+                    Path { span, segments }\n+                } else {\n+                    Path::from_ident(ident.with_span_pos(span))\n+                }\n+            }\n             Some(TokenTree::Token(_, Token::Interpolated(ref nt))) => match nt.0 {\n-                token::Nonterminal::NtIdent(ident, _) => (ident.span, ident),\n+                token::Nonterminal::NtIdent(ident, _) => Path::from_ident(ident),\n                 token::Nonterminal::NtMeta(ref meta) => return Some(meta.clone()),\n+                token::Nonterminal::NtPath(ref path) => path.clone(),\n                 _ => return None,\n             },\n             _ => return None,\n@@ -1123,10 +1198,11 @@ impl MetaItem {\n         let node = MetaItemKind::from_tokens(tokens)?;\n         let hi = match node {\n             MetaItemKind::NameValue(ref lit) => lit.span.hi(),\n-            MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(span.hi()),\n-            _ => span.hi(),\n+            MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(ident.span.hi()),\n+            _ => ident.span.hi(),\n         };\n-        Some(MetaItem { ident, node, span: span.with_hi(hi) })\n+        let span = ident.span.with_hi(hi);\n+        Some(MetaItem { ident, node, span })\n     }\n }\n \n@@ -1228,10 +1304,7 @@ impl LitKind {\n \n         match *self {\n             LitKind::Str(string, ast::StrStyle::Cooked) => {\n-                let mut escaped = String::new();\n-                for ch in string.as_str().chars() {\n-                    escaped.extend(ch.escape_unicode());\n-                }\n+                let escaped = string.as_str().escape_default();\n                 Token::Literal(token::Lit::Str_(Symbol::intern(&escaped)), None)\n             }\n             LitKind::Str(string, ast::StrStyle::Raw(n)) => {"}, {"sha": "5f940437ab3fbc37395fc0d007be2defdc9afaa9", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -244,6 +244,18 @@ fn main() {\n ```\n \"##,\n \n+E0589: r##\"\n+The value of `N` that was specified for `repr(align(N))` was not a power\n+of two, or was greater than 2^29.\n+\n+```compile_fail,E0589\n+#[repr(align(15))] // error: invalid `repr(align)` attribute: not a power of two\n+enum Foo {\n+    Bar(u64),\n+}\n+```\n+\"##,\n+\n E0658: r##\"\n An unstable feature was used.\n \n@@ -321,7 +333,8 @@ register_diagnostics! {\n     E0555, // malformed feature attribute, expected #![feature(...)]\n     E0556, // malformed feature, expected just one word\n     E0584, // file for module `..` found at both .. and ..\n-    E0589, // invalid `repr(align)` attribute\n     E0629, // missing 'feature' (rustc_const_unstable)\n     E0630, // rustc_const_unstable attribute must be paired with stable/unstable attribute\n+    E0693, // incorrect `repr(align)` attribute format\n+    E0694, // an unknown tool name found in scoped attributes\n }"}, {"sha": "3b76084f2fbe5cd7d8d2e22bafdab9fbcdf8f1eb", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -118,6 +118,20 @@ impl Annotatable {\n         }\n     }\n \n+    pub fn expect_stmt(self) -> ast::Stmt {\n+        match self {\n+            Annotatable::Stmt(stmt) => stmt.into_inner(),\n+            _ => panic!(\"expected statement\"),\n+        }\n+    }\n+\n+    pub fn expect_expr(self) -> P<ast::Expr> {\n+        match self {\n+            Annotatable::Expr(expr) => expr,\n+            _ => panic!(\"expected expression\"),\n+        }\n+    }\n+\n     pub fn derive_allowed(&self) -> bool {\n         match *self {\n             Annotatable::Item(ref item) => match item.node {\n@@ -661,7 +675,9 @@ pub trait Resolver {\n \n     fn resolve_imports(&mut self);\n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n-    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n+    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>, allow_derive: bool)\n+                              -> Option<Attribute>;\n+\n     fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n                      -> Result<Option<Lrc<SyntaxExtension>>, Determinacy>;\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n@@ -687,7 +703,8 @@ impl Resolver for DummyResolver {\n     fn add_builtin(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n \n     fn resolve_imports(&mut self) {}\n-    fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n+    fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>, _allow_derive: bool)\n+                              -> Option<Attribute> { None }\n     fn resolve_invoc(&mut self, _invoc: &mut Invocation, _scope: Mark, _force: bool)\n                      -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n         Err(Determinacy::Determined)"}, {"sha": "584b9455a93ada1e39174e6ed92c7ae2ab2eaf50", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 63, "deletions": 13, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -143,7 +143,7 @@ impl ExpansionKind {\n     }\n \n     fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(self, items: I) -> Expansion {\n-        let items = items.into_iter();\n+        let mut items = items.into_iter();\n         match self {\n             ExpansionKind::Items =>\n                 Expansion::Items(items.map(Annotatable::expect_item).collect()),\n@@ -153,7 +153,14 @@ impl ExpansionKind {\n                 Expansion::TraitItems(items.map(Annotatable::expect_trait_item).collect()),\n             ExpansionKind::ForeignItems =>\n                 Expansion::ForeignItems(items.map(Annotatable::expect_foreign_item).collect()),\n-            _ => unreachable!(),\n+            ExpansionKind::Stmts => Expansion::Stmts(items.map(Annotatable::expect_stmt).collect()),\n+            ExpansionKind::Expr => Expansion::Expr(\n+                items.next().expect(\"expected exactly one expression\").expect_expr()\n+            ),\n+            ExpansionKind::OptExpr =>\n+                Expansion::OptExpr(items.next().map(Annotatable::expect_expr)),\n+            ExpansionKind::Pat | ExpansionKind::Ty =>\n+                panic!(\"patterns and types aren't annotatable\"),\n         }\n     }\n }\n@@ -803,7 +810,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n                 let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n-                    ident: keywords::Invalid.ident(),\n+                    ident: Path::from_ident(keywords::Invalid.ident()),\n                     span: DUMMY_SP,\n                     node: ast::MetaItemKind::Word,\n                 };\n@@ -956,14 +963,15 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         self.collect(kind, InvocationKind::Attr { attr, traits, item })\n     }\n \n-    // If `item` is an attr invocation, remove and return the macro attribute.\n+    /// If `item` is an attr invocation, remove and return the macro attribute and derive traits.\n     fn classify_item<T>(&mut self, mut item: T) -> (Option<ast::Attribute>, Vec<Path>, T)\n         where T: HasAttrs,\n     {\n         let (mut attr, mut traits) = (None, Vec::new());\n \n         item = item.map_attrs(|mut attrs| {\n-            if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs) {\n+            if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs,\n+                                                                                     true) {\n                 attr = Some(legacy_attr_invoc);\n                 return attrs;\n             }\n@@ -978,6 +986,28 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         (attr, traits, item)\n     }\n \n+    /// Alternative of `classify_item()` that ignores `#[derive]` so invocations fallthrough\n+    /// to the unused-attributes lint (making it an error on statements and expressions\n+    /// is a breaking change)\n+    fn classify_nonitem<T: HasAttrs>(&mut self, mut item: T) -> (Option<ast::Attribute>, T) {\n+        let mut attr = None;\n+\n+        item = item.map_attrs(|mut attrs| {\n+            if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs,\n+                                                                                     false) {\n+                attr = Some(legacy_attr_invoc);\n+                return attrs;\n+            }\n+\n+            if self.cx.ecfg.proc_macro_enabled() {\n+                attr = find_attr_invoc(&mut attrs);\n+            }\n+            attrs\n+        });\n+\n+        (attr, item)\n+    }\n+\n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n@@ -987,12 +1017,23 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn check_attributes(&mut self, attrs: &[ast::Attribute]) {\n         let features = self.cx.ecfg.features.unwrap();\n         for attr in attrs.iter() {\n-            feature_gate::check_attribute(attr, self.cx.parse_sess, features);\n+            self.check_attribute_inner(attr, features);\n+\n+            // macros are expanded before any lint passes so this warning has to be hardcoded\n+            if attr.path == \"derive\" {\n+                self.cx.struct_span_warn(attr.span, \"`#[derive]` does nothing on macro invocations\")\n+                    .note(\"this may become a hard error in a future release\")\n+                    .emit();\n+            }\n         }\n     }\n \n     fn check_attribute(&mut self, at: &ast::Attribute) {\n         let features = self.cx.ecfg.features.unwrap();\n+        self.check_attribute_inner(at, features);\n+    }\n+\n+    fn check_attribute_inner(&mut self, at: &ast::Attribute, features: &Features) {\n         feature_gate::check_attribute(at, self.cx.parse_sess, features);\n     }\n }\n@@ -1008,15 +1049,16 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         let mut expr = self.cfg.configure_expr(expr).into_inner();\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n-        let (attr, derives, expr) = self.classify_item(expr);\n+        // ignore derives so they remain unused\n+        let (attr, expr) = self.classify_nonitem(expr);\n \n-        if attr.is_some() || !derives.is_empty() {\n+        if attr.is_some() {\n             // collect the invoc regardless of whether or not attributes are permitted here\n             // expansion will eat the attribute so it won't error later\n             attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n             // ExpansionKind::Expr requires the macro to emit an expression\n-            return self.collect_attr(attr, derives, Annotatable::Expr(P(expr)), ExpansionKind::Expr)\n+            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)), ExpansionKind::Expr)\n                 .make_expr();\n         }\n \n@@ -1032,12 +1074,13 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         let mut expr = configure!(self, expr).into_inner();\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n-        let (attr, derives, expr) = self.classify_item(expr);\n+        // ignore derives so they remain unused\n+        let (attr, expr) = self.classify_nonitem(expr);\n \n-        if attr.is_some() || !derives.is_empty() {\n+        if attr.is_some() {\n             attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n-            return self.collect_attr(attr, derives, Annotatable::Expr(P(expr)),\n+            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n                                      ExpansionKind::OptExpr)\n                 .make_opt_expr();\n         }\n@@ -1071,7 +1114,14 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n         // we'll expand attributes on expressions separately\n         if !stmt.is_expr() {\n-            let (attr, derives, stmt_) = self.classify_item(stmt);\n+            let (attr, derives, stmt_) = if stmt.is_item() {\n+                self.classify_item(stmt)\n+            } else {\n+                // ignore derives on non-item statements so it falls through\n+                // to the unused-attributes lint\n+                let (attr, stmt) = self.classify_nonitem(stmt);\n+                (attr, vec![], stmt)\n+            };\n \n             if attr.is_some() || !derives.is_empty() {\n                 return self.collect_attr(attr, derives,"}, {"sha": "71634ada89458012b70f6b307c5f7dca3bf33ddc", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -835,7 +835,13 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         \"path\" => token::NtPath(panictry!(p.parse_path_common(PathStyle::Type, false))),\n         \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n         \"vis\" => token::NtVis(panictry!(p.parse_visibility(true))),\n-        \"lifetime\" => token::NtLifetime(p.expect_lifetime().ident),\n+        \"lifetime\" => if p.check_lifetime() {\n+            token::NtLifetime(p.expect_lifetime().ident)\n+        } else {\n+            let token_str = pprust::token_to_string(&p.token);\n+            p.fatal(&format!(\"expected a lifetime, found `{}`\", &token_str)).emit();\n+            FatalError.raise();\n+        }\n         // this is not supposed to happen, since it has been checked\n         // when compiling the macro.\n         _ => p.span_bug(sp, \"invalid fragment specifier\"),"}, {"sha": "d8db76a95ff38ef1fde952f99658dd42e6d2d7b9", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "2f15e75093b10ae040a233f83d10f10c7c8697f6", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "f148aaf7267eec9dc581fdfc025d8f2884df44b6", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "cceed589212561c06d0482a79b7f011222956156", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}]}