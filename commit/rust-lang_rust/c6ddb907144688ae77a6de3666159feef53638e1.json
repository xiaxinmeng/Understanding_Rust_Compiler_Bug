{"sha": "c6ddb907144688ae77a6de3666159feef53638e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZGRiOTA3MTQ0Njg4YWU3N2E2ZGUzNjY2MTU5ZmVlZjUzNjM4ZTE=", "commit": {"author": {"name": "adamrk", "email": "ark.email@gmail.com", "date": "2020-08-22T18:11:37Z"}, "committer": {"name": "adamrk", "email": "ark.email@gmail.com", "date": "2020-08-30T10:34:32Z"}, "message": "Add references to fn args during completion", "tree": {"sha": "a560689c0ff6a35b7ed6a6738c48524730a60263", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a560689c0ff6a35b7ed6a6738c48524730a60263"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6ddb907144688ae77a6de3666159feef53638e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6ddb907144688ae77a6de3666159feef53638e1", "html_url": "https://github.com/rust-lang/rust/commit/c6ddb907144688ae77a6de3666159feef53638e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6ddb907144688ae77a6de3666159feef53638e1/comments", "author": {"login": "adamrk", "id": 16367467, "node_id": "MDQ6VXNlcjE2MzY3NDY3", "avatar_url": "https://avatars.githubusercontent.com/u/16367467?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adamrk", "html_url": "https://github.com/adamrk", "followers_url": "https://api.github.com/users/adamrk/followers", "following_url": "https://api.github.com/users/adamrk/following{/other_user}", "gists_url": "https://api.github.com/users/adamrk/gists{/gist_id}", "starred_url": "https://api.github.com/users/adamrk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adamrk/subscriptions", "organizations_url": "https://api.github.com/users/adamrk/orgs", "repos_url": "https://api.github.com/users/adamrk/repos", "events_url": "https://api.github.com/users/adamrk/events{/privacy}", "received_events_url": "https://api.github.com/users/adamrk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "adamrk", "id": 16367467, "node_id": "MDQ6VXNlcjE2MzY3NDY3", "avatar_url": "https://avatars.githubusercontent.com/u/16367467?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adamrk", "html_url": "https://github.com/adamrk", "followers_url": "https://api.github.com/users/adamrk/followers", "following_url": "https://api.github.com/users/adamrk/following{/other_user}", "gists_url": "https://api.github.com/users/adamrk/gists{/gist_id}", "starred_url": "https://api.github.com/users/adamrk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adamrk/subscriptions", "organizations_url": "https://api.github.com/users/adamrk/orgs", "repos_url": "https://api.github.com/users/adamrk/repos", "events_url": "https://api.github.com/users/adamrk/events{/privacy}", "received_events_url": "https://api.github.com/users/adamrk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac4b134c6be27642dbe915f32a41f9a21bd0c1c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac4b134c6be27642dbe915f32a41f9a21bd0c1c9", "html_url": "https://github.com/rust-lang/rust/commit/ac4b134c6be27642dbe915f32a41f9a21bd0c1c9"}], "stats": {"total": 161, "additions": 151, "deletions": 10}, "files": [{"sha": "f182ab228fe37d85596e620c8c86f7333bc8aa9f", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c6ddb907144688ae77a6de3666159feef53638e1/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ddb907144688ae77a6de3666159feef53638e1/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=c6ddb907144688ae77a6de3666159feef53638e1", "patch": "@@ -708,12 +708,24 @@ impl Function {\n         Some(SelfParam { func: self.id })\n     }\n \n-    pub fn params(self, db: &dyn HirDatabase) -> Vec<Param> {\n+    pub fn params(self, db: &dyn HirDatabase) -> Vec<Type> {\n+        let resolver = self.id.resolver(db.upcast());\n+        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n+        let environment = TraitEnvironment::lower(db, &resolver);\n         db.function_data(self.id)\n             .params\n             .iter()\n             .skip(if self.self_param(db).is_some() { 1 } else { 0 })\n-            .map(|_| Param { _ty: () })\n+            .map(|type_ref| {\n+                let ty = Type {\n+                    krate: self.id.lookup(db.upcast()).container.module(db.upcast()).krate,\n+                    ty: InEnvironment {\n+                        value: Ty::from_hir_ext(&ctx, type_ref).0,\n+                        environment: environment.clone(),\n+                    },\n+                };\n+                ty\n+            })\n             .collect()\n     }\n \n@@ -747,10 +759,6 @@ pub struct SelfParam {\n     func: FunctionId,\n }\n \n-pub struct Param {\n-    _ty: (),\n-}\n-\n impl SelfParam {\n     pub fn access(self, db: &dyn HirDatabase) -> Access {\n         let func_data = db.function_data(self.func);\n@@ -1100,6 +1108,12 @@ impl Local {\n             ast.map_left(|it| it.cast().unwrap().to_node(&root)).map_right(|it| it.to_node(&root))\n         })\n     }\n+\n+    pub fn can_unify(self, other: Type, db: &dyn HirDatabase) -> bool {\n+        let def = DefWithBodyId::from(self.parent);\n+        let infer = db.infer(def);\n+        db.can_unify(def, infer[self.pat_id].clone(), other.ty.value)\n+    }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n@@ -1276,6 +1290,14 @@ impl Type {\n         )\n     }\n \n+    pub fn remove_ref(&self) -> Option<Type> {\n+        if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(_), .. }) = self.ty.value {\n+            self.ty.value.substs().map(|substs| self.derived(substs[0].clone()))\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn is_unknown(&self) -> bool {\n         matches!(self.ty.value, Ty::Unknown)\n     }"}, {"sha": "57e60c53b3759ec7aa288c986eb711b46539d9ca", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6ddb907144688ae77a6de3666159feef53638e1/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ddb907144688ae77a6de3666159feef53638e1/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=c6ddb907144688ae77a6de3666159feef53638e1", "patch": "@@ -26,6 +26,9 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::infer::infer_query)]\n     fn infer_query(&self, def: DefWithBodyId) -> Arc<InferenceResult>;\n \n+    #[salsa::invoke(crate::infer::can_unify)]\n+    fn can_unify(&self, def: DefWithBodyId, ty1: Ty, ty2: Ty) -> bool;\n+\n     #[salsa::invoke(crate::lower::ty_query)]\n     #[salsa::cycle(crate::lower::ty_recover)]\n     fn ty(&self, def: TyDefId) -> Binders<Ty>;"}, {"sha": "d461e077b2032b976f778626202ff2a7ac9bd0b5", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c6ddb907144688ae77a6de3666159feef53638e1/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ddb907144688ae77a6de3666159feef53638e1/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=c6ddb907144688ae77a6de3666159feef53638e1", "patch": "@@ -55,7 +55,7 @@ macro_rules! ty_app {\n     };\n }\n \n-mod unify;\n+pub mod unify;\n mod path;\n mod expr;\n mod pat;\n@@ -78,6 +78,19 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n     Arc::new(ctx.resolve_all())\n }\n \n+pub(crate) fn can_unify(db: &dyn HirDatabase, def: DefWithBodyId, ty1: Ty, ty2: Ty) -> bool {\n+    let resolver = def.resolver(db.upcast());\n+    let mut ctx = InferenceContext::new(db, def, resolver);\n+\n+    let ty1 = ctx.canonicalizer().canonicalize_ty(ty1).value;\n+    let ty2 = ctx.canonicalizer().canonicalize_ty(ty2).value;\n+    let mut kinds = Vec::from(ty1.kinds.to_vec());\n+    kinds.extend_from_slice(ty2.kinds.as_ref());\n+    let tys = crate::Canonical::new((ty1.value, ty2.value), kinds);\n+\n+    unify(&tys).is_some()\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n enum ExprOrPatId {\n     ExprId(ExprId),"}, {"sha": "681f98bde86be744bf0b86a36f558e8a3b4ae251", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6ddb907144688ae77a6de3666159feef53638e1/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ddb907144688ae77a6de3666159feef53638e1/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=c6ddb907144688ae77a6de3666159feef53638e1", "patch": "@@ -43,7 +43,7 @@ use crate::{\n };\n \n pub use autoderef::autoderef;\n-pub use infer::{InferTy, InferenceResult};\n+pub use infer::{unify, InferTy, InferenceResult};\n pub use lower::CallableDefId;\n pub use lower::{\n     associated_type_shorthand_candidates, callable_item_sig, ImplTraitLoweringMode, TyDefId,"}, {"sha": "cfcb6dfa190e1b8e37208d50fea0e84bd0d48efc", "filename": "crates/ide/src/completion/presentation.rs", "status": "modified", "additions": 105, "deletions": 2, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/c6ddb907144688ae77a6de3666159feef53638e1/crates%2Fide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ddb907144688ae77a6de3666159feef53638e1/crates%2Fide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=c6ddb907144688ae77a6de3666159feef53638e1", "patch": "@@ -191,6 +191,22 @@ impl Completions {\n         func: hir::Function,\n         local_name: Option<String>,\n     ) {\n+        fn add_arg(arg: &str, ty: &Type, ctx: &CompletionContext) -> String {\n+            let mut prefix = \"\";\n+            if let Some(derefed_ty) = ty.remove_ref() {\n+                ctx.scope.process_all_names(&mut |name, scope| {\n+                    if prefix != \"\" {\n+                        return;\n+                    }\n+                    if let ScopeDef::Local(local) = scope {\n+                        if name.to_string() == arg && local.can_unify(derefed_ty.clone(), ctx.db) {\n+                            prefix = if ty.is_mutable_reference() { \"&mut \" } else { \"&\" };\n+                        }\n+                    }\n+                });\n+            }\n+            prefix.to_string() + arg\n+        };\n         let name = local_name.unwrap_or_else(|| func.name(ctx.db).to_string());\n         let ast_node = func.source(ctx.db).value;\n \n@@ -205,12 +221,20 @@ impl Completions {\n                 .set_deprecated(is_deprecated(func, ctx.db))\n                 .detail(function_declaration(&ast_node));\n \n+        let params_ty = func.params(ctx.db);\n         let params = ast_node\n             .param_list()\n             .into_iter()\n             .flat_map(|it| it.params())\n-            .flat_map(|it| it.pat())\n-            .map(|pat| pat.to_string().trim_start_matches('_').into())\n+            .zip(params_ty)\n+            .flat_map(|(it, param_ty)| {\n+                if let Some(pat) = it.pat() {\n+                    let name = pat.to_string();\n+                    let arg = name.trim_start_matches('_');\n+                    return Some(add_arg(arg, &param_ty, ctx));\n+                }\n+                None\n+            })\n             .collect();\n \n         builder = builder.add_call_parens(ctx, name, Params::Named(params));\n@@ -863,6 +887,85 @@ fn main() { foo(${1:foo}, ${2:bar}, ${3:ho_ge_})$0 }\n         );\n     }\n \n+    #[test]\n+    fn insert_ref_when_matching_local_in_scope() {\n+        check_edit(\n+            \"ref_arg\",\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_ar<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_arg(${1:&x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_mut_ref_when_matching_local_in_scope() {\n+        check_edit(\n+            \"ref_arg\",\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &mut Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_ar<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &mut Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_arg(${1:&mut x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_ref_when_matching_local_in_scope_for_method() {\n+        check_edit(\n+            \"apply_foo\",\n+            r#\"\n+struct Foo {}\n+struct Bar {}\n+impl Bar {\n+    fn apply_foo(&self, x: &Foo) {}\n+}\n+\n+fn main() {\n+    let x = Foo {};\n+    let y = Bar {};\n+    y.<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+struct Bar {}\n+impl Bar {\n+    fn apply_foo(&self, x: &Foo) {}\n+}\n+\n+fn main() {\n+    let x = Foo {};\n+    let y = Bar {};\n+    y.apply_foo(${1:&x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn inserts_parens_for_tuple_enums() {\n         mark::check!(inserts_parens_for_tuple_enums);"}]}