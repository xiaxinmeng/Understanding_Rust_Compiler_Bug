{"sha": "ea9c370ffec63dc4a94e758790f31e6b14e8d5b5", "node_id": "C_kwDOAAsO6NoAKGVhOWMzNzBmZmVjNjNkYzRhOTRlNzU4NzkwZjMxZTZiMTRlOGQ1YjU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-31T05:57:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-31T05:57:54Z"}, "message": "Rollup merge of #100970 - Xiretza:derive-multipart-suggestion, r=davidtwco\n\nAllow deriving multipart suggestions\n\nThis turned into a bit more of a rewrite than I was initially hoping for... Still, I think the `SessionSubdiagnostic` derive is a little cleaner overall now, and closer to the `SessionDiagnostic` derive to make future code sharing easier.\n\nr? ``@davidtwco``", "tree": {"sha": "f03e85857a99c676c131b583815a59b50dd5f30b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f03e85857a99c676c131b583815a59b50dd5f30b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea9c370ffec63dc4a94e758790f31e6b14e8d5b5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDvhiCRBK7hj4Ov3rIwAANxMIABMTuCFtr9wJk5CPUPOF0Ae3\n21w2ck8C+EHfL7eZZcAbF9GRhgg7Rjt3ZMZ48sJnRMs6th2V1k7z8ChQ6FGa0+6X\nUtAmELoJXuCJoOAtMAq44qK6UFXbrjqBZQgxhq41CPYSlm0aQWu8rwDoy4JKPzUF\n4QfyMy8g40bUvBfyLdvdSfDYAAd5OVZPENT/cgxguqFLc7hFnL2cWXIlyzQkUXc0\nSIuyp7MHLcfgXqWPN8qsQZSn8vn8xhmehqZm9zVgahYvCjfTe0r1n/jhVqUZTHV0\nZkiVu2cMCKgI6uxem3JokKWa2c6d0O7Hqf6MvBtMVYBvQqJTq1or+Ci/j40PvgM=\n=g2Jn\n-----END PGP SIGNATURE-----\n", "payload": "tree f03e85857a99c676c131b583815a59b50dd5f30b\nparent 7f442f8ba174fd4233a14ef4d7b577aa907db594\nparent 31b939b3152ea70b2a84992905f48e125d85ca18\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661925474 +0200\ncommitter GitHub <noreply@github.com> 1661925474 +0200\n\nRollup merge of #100970 - Xiretza:derive-multipart-suggestion, r=davidtwco\n\nAllow deriving multipart suggestions\n\nThis turned into a bit more of a rewrite than I was initially hoping for... Still, I think the `SessionSubdiagnostic` derive is a little cleaner overall now, and closer to the `SessionDiagnostic` derive to make future code sharing easier.\n\nr? ``@davidtwco``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea9c370ffec63dc4a94e758790f31e6b14e8d5b5", "html_url": "https://github.com/rust-lang/rust/commit/ea9c370ffec63dc4a94e758790f31e6b14e8d5b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea9c370ffec63dc4a94e758790f31e6b14e8d5b5/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f442f8ba174fd4233a14ef4d7b577aa907db594", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f442f8ba174fd4233a14ef4d7b577aa907db594", "html_url": "https://github.com/rust-lang/rust/commit/7f442f8ba174fd4233a14ef4d7b577aa907db594"}, {"sha": "31b939b3152ea70b2a84992905f48e125d85ca18", "url": "https://api.github.com/repos/rust-lang/rust/commits/31b939b3152ea70b2a84992905f48e125d85ca18", "html_url": "https://github.com/rust-lang/rust/commit/31b939b3152ea70b2a84992905f48e125d85ca18"}], "stats": {"total": 1114, "additions": 748, "deletions": 366}, "files": [{"sha": "f75e2596f361b7549233878bccf2aa570baf3c5e", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ea9c370ffec63dc4a94e758790f31e6b14e8d5b5/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea9c370ffec63dc4a94e758790f31e6b14e8d5b5/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=ea9c370ffec63dc4a94e758790f31e6b14e8d5b5", "patch": "@@ -686,19 +686,12 @@ impl Diagnostic {\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        assert!(!suggestion.is_empty());\n-        self.push_suggestion(CodeSuggestion {\n-            substitutions: vec![Substitution {\n-                parts: suggestion\n-                    .into_iter()\n-                    .map(|(span, snippet)| SubstitutionPart { snippet, span })\n-                    .collect(),\n-            }],\n-            msg: self.subdiagnostic_message_to_diagnostic_message(msg),\n-            style: SuggestionStyle::CompletelyHidden,\n+        self.multipart_suggestion_with_style(\n+            msg,\n+            suggestion,\n             applicability,\n-        });\n-        self\n+            SuggestionStyle::CompletelyHidden,\n+        )\n     }\n \n     /// Prints out a message with a suggested edit of the code."}, {"sha": "8b40e295bd8a7aa33c4e5a52034d61adb2065cbc", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 446, "deletions": 254, "changes": 700, "blob_url": "https://github.com/rust-lang/rust/blob/ea9c370ffec63dc4a94e758790f31e6b14e8d5b5/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea9c370ffec63dc4a94e758790f31e6b14e8d5b5/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=ea9c370ffec63dc4a94e758790f31e6b14e8d5b5", "patch": "@@ -12,7 +12,7 @@ use quote::{format_ident, quote};\n use std::collections::HashMap;\n use std::fmt;\n use std::str::FromStr;\n-use syn::{parse_quote, spanned::Spanned, Meta, MetaList, MetaNameValue, NestedMeta, Path};\n+use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n /// Which kind of suggestion is being created?\n@@ -28,8 +28,41 @@ enum SubdiagnosticSuggestionKind {\n     Verbose,\n }\n \n+impl FromStr for SubdiagnosticSuggestionKind {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"\" => Ok(SubdiagnosticSuggestionKind::Normal),\n+            \"_short\" => Ok(SubdiagnosticSuggestionKind::Short),\n+            \"_hidden\" => Ok(SubdiagnosticSuggestionKind::Hidden),\n+            \"_verbose\" => Ok(SubdiagnosticSuggestionKind::Verbose),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+impl SubdiagnosticSuggestionKind {\n+    pub fn to_suggestion_style(&self) -> TokenStream {\n+        match self {\n+            SubdiagnosticSuggestionKind::Normal => {\n+                quote! { rustc_errors::SuggestionStyle::ShowCode }\n+            }\n+            SubdiagnosticSuggestionKind::Short => {\n+                quote! { rustc_errors::SuggestionStyle::HideCodeInline }\n+            }\n+            SubdiagnosticSuggestionKind::Hidden => {\n+                quote! { rustc_errors::SuggestionStyle::HideCodeAlways }\n+            }\n+            SubdiagnosticSuggestionKind::Verbose => {\n+                quote! { rustc_errors::SuggestionStyle::ShowAlways }\n+            }\n+        }\n+    }\n+}\n+\n /// Which kind of subdiagnostic is being created from a variant?\n-#[derive(Clone, Copy)]\n+#[derive(Clone)]\n enum SubdiagnosticKind {\n     /// `#[label(...)]`\n     Label,\n@@ -40,31 +73,9 @@ enum SubdiagnosticKind {\n     /// `#[warning(...)]`\n     Warn,\n     /// `#[suggestion{,_short,_hidden,_verbose}]`\n-    Suggestion(SubdiagnosticSuggestionKind),\n-}\n-\n-impl FromStr for SubdiagnosticKind {\n-    type Err = ();\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"label\" => Ok(SubdiagnosticKind::Label),\n-            \"note\" => Ok(SubdiagnosticKind::Note),\n-            \"help\" => Ok(SubdiagnosticKind::Help),\n-            \"warning\" => Ok(SubdiagnosticKind::Warn),\n-            \"suggestion\" => Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal)),\n-            \"suggestion_short\" => {\n-                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short))\n-            }\n-            \"suggestion_hidden\" => {\n-                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Hidden))\n-            }\n-            \"suggestion_verbose\" => {\n-                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Verbose))\n-            }\n-            _ => Err(()),\n-        }\n-    }\n+    Suggestion { suggestion_kind: SubdiagnosticSuggestionKind, code: TokenStream },\n+    /// `#[multipart_suggestion{,_short,_hidden,_verbose}]`\n+    MultipartSuggestion { suggestion_kind: SubdiagnosticSuggestionKind },\n }\n \n impl quote::IdentFragment for SubdiagnosticKind {\n@@ -74,17 +85,9 @@ impl quote::IdentFragment for SubdiagnosticKind {\n             SubdiagnosticKind::Note => write!(f, \"note\"),\n             SubdiagnosticKind::Help => write!(f, \"help\"),\n             SubdiagnosticKind::Warn => write!(f, \"warn\"),\n-            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal) => {\n-                write!(f, \"suggestion\")\n-            }\n-            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short) => {\n-                write!(f, \"suggestion_short\")\n-            }\n-            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Hidden) => {\n-                write!(f, \"suggestion_hidden\")\n-            }\n-            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Verbose) => {\n-                write!(f, \"suggestion_verbose\")\n+            SubdiagnosticKind::Suggestion { .. } => write!(f, \"suggestion_with_style\"),\n+            SubdiagnosticKind::MultipartSuggestion { .. } => {\n+                write!(f, \"multipart_suggestion_with_style\")\n             }\n         }\n     }\n@@ -148,11 +151,9 @@ impl<'a> SessionSubdiagnosticDerive<'a> {\n                     variant,\n                     span,\n                     fields: fields_map,\n-                    kind: None,\n-                    slug: None,\n-                    code: None,\n                     span_field: None,\n                     applicability: None,\n+                    has_suggestion_parts: false,\n                 };\n                 builder.into_tokens().unwrap_or_else(|v| v.to_compile_error())\n             });\n@@ -193,21 +194,15 @@ struct SessionSubdiagnosticDeriveBuilder<'a> {\n     /// derive builder.\n     fields: HashMap<String, TokenStream>,\n \n-    /// Subdiagnostic kind of the type/variant.\n-    kind: Option<(SubdiagnosticKind, proc_macro::Span)>,\n-\n-    /// Slug of the subdiagnostic - corresponds to the Fluent identifier for the message - from the\n-    /// `#[kind(slug)]` attribute on the type or variant.\n-    slug: Option<(Path, proc_macro::Span)>,\n-    /// If a suggestion, the code to suggest as a replacement - from the `#[kind(code = \"...\")]`\n-    /// attribute on the type or variant.\n-    code: Option<(TokenStream, proc_macro::Span)>,\n-\n     /// Identifier for the binding to the `#[primary_span]` field.\n     span_field: Option<(proc_macro2::Ident, proc_macro::Span)>,\n     /// If a suggestion, the identifier for the binding to the `#[applicability]` field or a\n     /// `rustc_errors::Applicability::*` variant directly.\n     applicability: Option<(TokenStream, proc_macro::Span)>,\n+\n+    /// Set to true when a `#[suggestion_part]` field is encountered, used to generate an error\n+    /// during finalization if still `false`.\n+    has_suggestion_parts: bool,\n }\n \n impl<'a> HasFieldMap for SessionSubdiagnosticDeriveBuilder<'a> {\n@@ -217,275 +212,472 @@ impl<'a> HasFieldMap for SessionSubdiagnosticDeriveBuilder<'a> {\n }\n \n impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n-    fn identify_kind(&mut self) -> Result<(), DiagnosticDeriveError> {\n+    fn identify_kind(\n+        &mut self,\n+    ) -> Result<Option<(SubdiagnosticKind, Path)>, DiagnosticDeriveError> {\n+        let mut kind_slug = None;\n+\n         for attr in self.variant.ast().attrs {\n             let span = attr.span().unwrap();\n \n             let name = attr.path.segments.last().unwrap().ident.to_string();\n             let name = name.as_str();\n \n             let meta = attr.parse_meta()?;\n-            let kind = match meta {\n-                Meta::List(MetaList { ref nested, .. }) => {\n-                    let mut nested_iter = nested.into_iter();\n-                    if let Some(nested_attr) = nested_iter.next() {\n-                        match nested_attr {\n-                            NestedMeta::Meta(Meta::Path(path)) => {\n-                                self.slug.set_once((path.clone(), span));\n-                            }\n-                            NestedMeta::Meta(meta @ Meta::NameValue(_))\n-                                if matches!(\n-                                    meta.path().segments.last().unwrap().ident.to_string().as_str(),\n-                                    \"code\" | \"applicability\"\n-                                ) =>\n-                            {\n-                                // don't error for valid follow-up attributes\n-                            }\n-                            nested_attr => {\n-                                throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                                    diag.help(\n-                                        \"first argument of the attribute should be the diagnostic \\\n-                                         slug\",\n-                                    )\n-                                })\n-                            }\n-                        };\n-                    }\n+            let Meta::List(MetaList { ref nested, .. }) = meta else {\n+                throw_invalid_attr!(attr, &meta);\n+            };\n \n-                    for nested_attr in nested_iter {\n-                        let meta = match nested_attr {\n-                            NestedMeta::Meta(ref meta) => meta,\n-                            _ => throw_invalid_nested_attr!(attr, &nested_attr),\n-                        };\n-\n-                        let span = meta.span().unwrap();\n-                        let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-                        let nested_name = nested_name.as_str();\n-\n-                        match meta {\n-                            Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                                match nested_name {\n-                                    \"code\" => {\n-                                        let formatted_str = self.build_format(&s.value(), s.span());\n-                                        self.code.set_once((formatted_str, span));\n-                                    }\n-                                    \"applicability\" => {\n-                                        let value = match Applicability::from_str(&s.value()) {\n-                                            Ok(v) => v,\n-                                            Err(()) => {\n-                                                span_err(span, \"invalid applicability\").emit();\n-                                                Applicability::Unspecified\n-                                            }\n-                                        };\n-                                        self.applicability.set_once((quote! { #value }, span));\n-                                    }\n-                                    _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                                        diag.help(\n-                                            \"only `code` and `applicability` are valid nested \\\n-                                             attributes\",\n-                                        )\n-                                    }),\n-                                }\n-                            }\n-                            _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                                if matches!(meta, Meta::Path(_)) {\n-                                    diag.help(\n-                                        \"a diagnostic slug must be the first argument to the \\\n-                                         attribute\",\n-                                    )\n-                                } else {\n-                                    diag\n-                                }\n-                            }),\n-                        }\n+            let mut kind = match name {\n+                \"label\" => SubdiagnosticKind::Label,\n+                \"note\" => SubdiagnosticKind::Note,\n+                \"help\" => SubdiagnosticKind::Help,\n+                \"warning\" => SubdiagnosticKind::Warn,\n+                _ => {\n+                    if let Some(suggestion_kind) =\n+                        name.strip_prefix(\"suggestion\").and_then(|s| s.parse().ok())\n+                    {\n+                        SubdiagnosticKind::Suggestion { suggestion_kind, code: TokenStream::new() }\n+                    } else if let Some(suggestion_kind) =\n+                        name.strip_prefix(\"multipart_suggestion\").and_then(|s| s.parse().ok())\n+                    {\n+                        SubdiagnosticKind::MultipartSuggestion { suggestion_kind }\n+                    } else {\n+                        throw_invalid_attr!(attr, &meta);\n                     }\n-\n-                    let Ok(kind) = SubdiagnosticKind::from_str(name) else {\n-                        throw_invalid_attr!(attr, &meta)\n-                    };\n-\n-                    kind\n                 }\n-                _ => throw_invalid_attr!(attr, &meta),\n             };\n \n-            if matches!(\n-                kind,\n-                SubdiagnosticKind::Label | SubdiagnosticKind::Help | SubdiagnosticKind::Note\n-            ) && self.code.is_some()\n-            {\n-                throw_span_err!(\n-                    span,\n-                    &format!(\"`code` is not a valid nested attribute of a `{}` attribute\", name)\n-                );\n+            let mut slug = None;\n+            let mut code = None;\n+\n+            let mut nested_iter = nested.into_iter();\n+            if let Some(nested_attr) = nested_iter.next() {\n+                match nested_attr {\n+                    NestedMeta::Meta(Meta::Path(path)) => {\n+                        slug.set_once((path.clone(), span));\n+                    }\n+                    NestedMeta::Meta(meta @ Meta::NameValue(_))\n+                        if matches!(\n+                            meta.path().segments.last().unwrap().ident.to_string().as_str(),\n+                            \"code\" | \"applicability\"\n+                        ) =>\n+                    {\n+                        // Don't error for valid follow-up attributes.\n+                    }\n+                    nested_attr => {\n+                        throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                            diag.help(\n+                                \"first argument of the attribute should be the diagnostic \\\n+                                 slug\",\n+                            )\n+                        })\n+                    }\n+                };\n             }\n \n-            if matches!(\n-                kind,\n-                SubdiagnosticKind::Label | SubdiagnosticKind::Help | SubdiagnosticKind::Note\n-            ) && self.applicability.is_some()\n-            {\n-                throw_span_err!(\n-                    span,\n-                    &format!(\n-                        \"`applicability` is not a valid nested attribute of a `{}` attribute\",\n-                        name\n-                    )\n-                );\n+            for nested_attr in nested_iter {\n+                let meta = match nested_attr {\n+                    NestedMeta::Meta(ref meta) => meta,\n+                    _ => throw_invalid_nested_attr!(attr, &nested_attr),\n+                };\n+\n+                let span = meta.span().unwrap();\n+                let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+                let nested_name = nested_name.as_str();\n+\n+                let value = match meta {\n+                    Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => value,\n+                    Meta::Path(_) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                        diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n+                    }),\n+                    _ => throw_invalid_nested_attr!(attr, &nested_attr),\n+                };\n+\n+                match nested_name {\n+                    \"code\" => {\n+                        if matches!(kind, SubdiagnosticKind::Suggestion { .. }) {\n+                            let formatted_str = self.build_format(&value.value(), value.span());\n+                            code.set_once((formatted_str, span));\n+                        } else {\n+                            span_err(\n+                                span,\n+                                &format!(\n+                                    \"`code` is not a valid nested attribute of a `{}` attribute\",\n+                                    name\n+                                ),\n+                            )\n+                            .emit();\n+                        }\n+                    }\n+                    \"applicability\" => {\n+                        if matches!(\n+                            kind,\n+                            SubdiagnosticKind::Suggestion { .. }\n+                                | SubdiagnosticKind::MultipartSuggestion { .. }\n+                        ) {\n+                            let value =\n+                                Applicability::from_str(&value.value()).unwrap_or_else(|()| {\n+                                    span_err(span, \"invalid applicability\").emit();\n+                                    Applicability::Unspecified\n+                                });\n+                            self.applicability.set_once((quote! { #value }, span));\n+                        } else {\n+                            span_err(\n+                                span,\n+                                &format!(\n+                                    \"`applicability` is not a valid nested attribute of a `{}` attribute\",\n+                                    name\n+                                )\n+                            ).emit();\n+                        }\n+                    }\n+                    _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                        diag.help(\"only `code` and `applicability` are valid nested attributes\")\n+                    }),\n+                }\n             }\n \n-            if self.slug.is_none() {\n+            let Some((slug, _)) = slug else {\n                 throw_span_err!(\n                     span,\n                     &format!(\n                         \"diagnostic slug must be first argument of a `#[{}(...)]` attribute\",\n                         name\n                     )\n                 );\n+            };\n+\n+            match kind {\n+                SubdiagnosticKind::Suggestion { code: ref mut code_field, .. } => {\n+                    let Some((code, _)) = code else {\n+                        throw_span_err!(span, \"suggestion without `code = \\\"...\\\"`\");\n+                    };\n+                    *code_field = code;\n+                }\n+                SubdiagnosticKind::Label\n+                | SubdiagnosticKind::Note\n+                | SubdiagnosticKind::Help\n+                | SubdiagnosticKind::Warn\n+                | SubdiagnosticKind::MultipartSuggestion { .. } => {}\n             }\n \n-            self.kind.set_once((kind, span));\n+            kind_slug.set_once(((kind, slug), span))\n         }\n \n-        Ok(())\n+        Ok(kind_slug.map(|(kind_slug, _)| kind_slug))\n+    }\n+\n+    /// Generates the code for a field with no attributes.\n+    fn generate_field_set_arg(&mut self, binding: &BindingInfo<'_>) -> TokenStream {\n+        let ast = binding.ast();\n+        assert_eq!(ast.attrs.len(), 0, \"field with attribute used as diagnostic arg\");\n+\n+        let diag = &self.diag;\n+        let ident = ast.ident.as_ref().unwrap();\n+        quote! {\n+            #diag.set_arg(\n+                stringify!(#ident),\n+                #binding\n+            );\n+        }\n     }\n \n-    fn generate_field_code(\n+    /// Generates the necessary code for all attributes on a field.\n+    fn generate_field_attr_code(\n         &mut self,\n         binding: &BindingInfo<'_>,\n-        is_suggestion: bool,\n-    ) -> Result<TokenStream, DiagnosticDeriveError> {\n+        kind: &SubdiagnosticKind,\n+    ) -> TokenStream {\n         let ast = binding.ast();\n+        assert!(ast.attrs.len() > 0, \"field without attributes generating attr code\");\n \n+        // Abstract over `Vec<T>` and `Option<T>` fields using `FieldInnerTy`, which will\n+        // apply the generated code on each element in the `Vec` or `Option`.\n         let inner_ty = FieldInnerTy::from_type(&ast.ty);\n-        let info = FieldInfo {\n-            binding: binding,\n-            ty: inner_ty.inner_type().unwrap_or(&ast.ty),\n-            span: &ast.span(),\n-        };\n+        ast.attrs\n+            .iter()\n+            .map(|attr| {\n+                let info = FieldInfo {\n+                    binding,\n+                    ty: inner_ty.inner_type().unwrap_or(&ast.ty),\n+                    span: &ast.span(),\n+                };\n \n-        for attr in &ast.attrs {\n-            let name = attr.path.segments.last().unwrap().ident.to_string();\n-            let name = name.as_str();\n-            let span = attr.span().unwrap();\n+                let generated = self\n+                    .generate_field_code_inner(kind, attr, info)\n+                    .unwrap_or_else(|v| v.to_compile_error());\n \n-            let meta = attr.parse_meta()?;\n-            match meta {\n-                Meta::Path(_) => match name {\n-                    \"primary_span\" => {\n-                        report_error_if_not_applied_to_span(attr, &info)?;\n-                        self.span_field.set_once((binding.binding.clone(), span));\n-                        return Ok(quote! {});\n-                    }\n-                    \"applicability\" if is_suggestion => {\n-                        report_error_if_not_applied_to_applicability(attr, &info)?;\n-                        let binding = binding.binding.clone();\n-                        self.applicability.set_once((quote! { #binding }, span));\n-                        return Ok(quote! {});\n-                    }\n-                    \"applicability\" => {\n-                        span_err(span, \"`#[applicability]` is only valid on suggestions\").emit();\n-                        return Ok(quote! {});\n-                    }\n-                    \"skip_arg\" => {\n-                        return Ok(quote! {});\n-                    }\n-                    _ => throw_invalid_attr!(attr, &meta, |diag| {\n+                inner_ty.with(binding, generated)\n+            })\n+            .collect()\n+    }\n+\n+    fn generate_field_code_inner(\n+        &mut self,\n+        kind: &SubdiagnosticKind,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<TokenStream, DiagnosticDeriveError> {\n+        let meta = attr.parse_meta()?;\n+        match meta {\n+            Meta::Path(path) => self.generate_field_code_inner_path(kind, attr, info, path),\n+            Meta::List(list @ MetaList { .. }) => {\n+                self.generate_field_code_inner_list(kind, attr, info, list)\n+            }\n+            _ => throw_invalid_attr!(attr, &meta),\n+        }\n+    }\n+\n+    /// Generates the code for a `[Meta::Path]`-like attribute on a field (e.g. `#[primary_span]`).\n+    fn generate_field_code_inner_path(\n+        &mut self,\n+        kind: &SubdiagnosticKind,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+        path: Path,\n+    ) -> Result<TokenStream, DiagnosticDeriveError> {\n+        let span = attr.span().unwrap();\n+        let ident = &path.segments.last().unwrap().ident;\n+        let name = ident.to_string();\n+        let name = name.as_str();\n+\n+        match name {\n+            \"skip_arg\" => Ok(quote! {}),\n+            \"primary_span\" => {\n+                if matches!(kind, SubdiagnosticKind::MultipartSuggestion { .. }) {\n+                    throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n                         diag.help(\n-                            \"only `primary_span`, `applicability` and `skip_arg` are valid field \\\n-                             attributes\",\n+                            \"multipart suggestions use one or more `#[suggestion_part]`s rather \\\n+                            than one `#[primary_span]`\",\n                         )\n-                    }),\n-                },\n-                _ => throw_invalid_attr!(attr, &meta),\n+                    })\n+                }\n+\n+                report_error_if_not_applied_to_span(attr, &info)?;\n+\n+                let binding = info.binding.binding.clone();\n+                self.span_field.set_once((binding, span));\n+\n+                Ok(quote! {})\n             }\n+            \"suggestion_part\" => {\n+                self.has_suggestion_parts = true;\n+\n+                match kind {\n+                    SubdiagnosticKind::MultipartSuggestion { .. } => {\n+                        span_err(\n+                            span,\n+                            \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\",\n+                        )\n+                        .emit();\n+                        Ok(quote! {})\n+                    }\n+                    SubdiagnosticKind::Label\n+                    | SubdiagnosticKind::Note\n+                    | SubdiagnosticKind::Help\n+                    | SubdiagnosticKind::Warn\n+                    | SubdiagnosticKind::Suggestion { .. } => {\n+                        throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n+                            diag.help(\n+                                \"`#[suggestion_part(...)]` is only valid in multipart suggestions, use `#[primary_span]` instead\",\n+                            )\n+                        });\n+                    }\n+                }\n+            }\n+            \"applicability\" => {\n+                if let SubdiagnosticKind::Suggestion { .. }\n+                | SubdiagnosticKind::MultipartSuggestion { .. } = kind\n+                {\n+                    report_error_if_not_applied_to_applicability(attr, &info)?;\n+\n+                    let binding = info.binding.binding.clone();\n+                    self.applicability.set_once((quote! { #binding }, span));\n+                } else {\n+                    span_err(span, \"`#[applicability]` is only valid on suggestions\").emit();\n+                }\n+\n+                Ok(quote! {})\n+            }\n+            _ => throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n+                let span_attr = if let SubdiagnosticKind::MultipartSuggestion { .. } = kind {\n+                    \"suggestion_part\"\n+                } else {\n+                    \"primary_span\"\n+                };\n+                diag.help(format!(\n+                    \"only `{span_attr}`, `applicability` and `skip_arg` are valid field attributes\",\n+                ))\n+            }),\n         }\n+    }\n \n-        let ident = ast.ident.as_ref().unwrap();\n+    /// Generates the code for a `[Meta::List]`-like attribute on a field (e.g.\n+    /// `#[suggestion_part(code = \"...\")]`).\n+    fn generate_field_code_inner_list(\n+        &mut self,\n+        kind: &SubdiagnosticKind,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+        list: MetaList,\n+    ) -> Result<TokenStream, DiagnosticDeriveError> {\n+        let span = attr.span().unwrap();\n+        let ident = &list.path.segments.last().unwrap().ident;\n+        let name = ident.to_string();\n+        let name = name.as_str();\n+\n+        match name {\n+            \"suggestion_part\" => {\n+                if !matches!(kind, SubdiagnosticKind::MultipartSuggestion { .. }) {\n+                    throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n+                        diag.help(\n+                            \"`#[suggestion_part(...)]` is only valid in multipart suggestions\",\n+                        )\n+                    })\n+                }\n \n-        let diag = &self.diag;\n-        let generated = quote! {\n-            #diag.set_arg(\n-                stringify!(#ident),\n-                #binding\n-            );\n-        };\n+                self.has_suggestion_parts = true;\n+\n+                report_error_if_not_applied_to_span(attr, &info)?;\n+\n+                let mut code = None;\n+                for nested_attr in list.nested.iter() {\n+                    let NestedMeta::Meta(ref meta) = nested_attr else {\n+                        throw_invalid_nested_attr!(attr, &nested_attr);\n+                    };\n+\n+                    let span = meta.span().unwrap();\n+                    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+                    let nested_name = nested_name.as_str();\n+\n+                    let Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) = meta else {\n+                        throw_invalid_nested_attr!(attr, &nested_attr);\n+                    };\n+\n+                    match nested_name {\n+                        \"code\" => {\n+                            let formatted_str = self.build_format(&value.value(), value.span());\n+                            code.set_once((formatted_str, span));\n+                        }\n+                        _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                            diag.help(\"`code` is the only valid nested attribute\")\n+                        }),\n+                    }\n+                }\n+\n+                let Some((code, _)) = code else {\n+                    span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n+                        .emit();\n+                    return Ok(quote! {});\n+                };\n+                let binding = info.binding;\n \n-        Ok(inner_ty.with(binding, generated))\n+                Ok(quote! { suggestions.push((#binding, #code)); })\n+            }\n+            _ => throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n+                let span_attr = if let SubdiagnosticKind::MultipartSuggestion { .. } = kind {\n+                    \"suggestion_part\"\n+                } else {\n+                    \"primary_span\"\n+                };\n+                diag.help(format!(\n+                    \"only `{span_attr}`, `applicability` and `skip_arg` are valid field attributes\",\n+                ))\n+            }),\n+        }\n     }\n \n-    fn into_tokens(&mut self) -> Result<TokenStream, DiagnosticDeriveError> {\n-        self.identify_kind()?;\n-        let Some(kind) = self.kind.map(|(kind, _)| kind) else {\n+    pub fn into_tokens(&mut self) -> Result<TokenStream, DiagnosticDeriveError> {\n+        let Some((kind, slug)) = self.identify_kind()? else {\n             throw_span_err!(\n                 self.variant.ast().ident.span().unwrap(),\n                 \"subdiagnostic kind not specified\"\n             );\n         };\n \n-        let is_suggestion = matches!(kind, SubdiagnosticKind::Suggestion(_));\n-\n-        let mut args = TokenStream::new();\n-        for binding in self.variant.bindings() {\n-            let arg = self\n-                .generate_field_code(binding, is_suggestion)\n-                .unwrap_or_else(|v| v.to_compile_error());\n-            args.extend(arg);\n-        }\n-\n-        // Missing slug errors will already have been reported.\n-        let slug = self\n-            .slug\n-            .as_ref()\n-            .map(|(slug, _)| slug.clone())\n-            .unwrap_or_else(|| parse_quote! { you::need::to::specify::a::slug });\n-        let code = match self.code.as_ref() {\n-            Some((code, _)) => Some(quote! { #code }),\n-            None if is_suggestion => {\n-                span_err(self.span, \"suggestion without `code = \\\"...\\\"`\").emit();\n-                Some(quote! { /* macro error */ \"...\" })\n+        let init = match &kind {\n+            SubdiagnosticKind::Label\n+            | SubdiagnosticKind::Note\n+            | SubdiagnosticKind::Help\n+            | SubdiagnosticKind::Warn\n+            | SubdiagnosticKind::Suggestion { .. } => quote! {},\n+            SubdiagnosticKind::MultipartSuggestion { .. } => {\n+                quote! { let mut suggestions = Vec::new(); }\n             }\n-            None => None,\n         };\n \n+        let attr_args: TokenStream = self\n+            .variant\n+            .bindings()\n+            .iter()\n+            .filter(|binding| !binding.ast().attrs.is_empty())\n+            .map(|binding| self.generate_field_attr_code(binding, &kind))\n+            .collect();\n+\n         let span_field = self.span_field.as_ref().map(|(span, _)| span);\n-        let applicability = match self.applicability.clone() {\n-            Some((applicability, _)) => Some(applicability),\n-            None if is_suggestion => {\n-                span_err(self.span, \"suggestion without `applicability`\").emit();\n-                Some(quote! { rustc_errors::Applicability::Unspecified })\n-            }\n-            None => None,\n-        };\n+        let applicability = self.applicability.take().map_or_else(\n+            || quote! { rustc_errors::Applicability::Unspecified },\n+            |(applicability, _)| applicability,\n+        );\n \n         let diag = &self.diag;\n         let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n         let message = quote! { rustc_errors::fluent::#slug };\n-        let call = if matches!(kind, SubdiagnosticKind::Suggestion(..)) {\n-            if let Some(span) = span_field {\n-                quote! { #diag.#name(#span, #message, #code, #applicability); }\n-            } else {\n-                span_err(self.span, \"suggestion without `#[primary_span]` field\").emit();\n-                quote! { unreachable!(); }\n+        let call = match kind {\n+            SubdiagnosticKind::Suggestion { suggestion_kind, code } => {\n+                if let Some(span) = span_field {\n+                    let style = suggestion_kind.to_suggestion_style();\n+\n+                    quote! { #diag.#name(#span, #message, #code, #applicability, #style); }\n+                } else {\n+                    span_err(self.span, \"suggestion without `#[primary_span]` field\").emit();\n+                    quote! { unreachable!(); }\n+                }\n             }\n-        } else if matches!(kind, SubdiagnosticKind::Label) {\n-            if let Some(span) = span_field {\n-                quote! { #diag.#name(#span, #message); }\n-            } else {\n-                span_err(self.span, \"label without `#[primary_span]` field\").emit();\n-                quote! { unreachable!(); }\n+            SubdiagnosticKind::MultipartSuggestion { suggestion_kind } => {\n+                if !self.has_suggestion_parts {\n+                    span_err(\n+                        self.span,\n+                        \"multipart suggestion without any `#[suggestion_part(...)]` fields\",\n+                    )\n+                    .emit();\n+                }\n+\n+                let style = suggestion_kind.to_suggestion_style();\n+\n+                quote! { #diag.#name(#message, suggestions, #applicability, #style); }\n             }\n-        } else {\n-            if let Some(span) = span_field {\n-                quote! { #diag.#name(#span, #message); }\n-            } else {\n-                quote! { #diag.#name(#message); }\n+            SubdiagnosticKind::Label => {\n+                if let Some(span) = span_field {\n+                    quote! { #diag.#name(#span, #message); }\n+                } else {\n+                    span_err(self.span, \"label without `#[primary_span]` field\").emit();\n+                    quote! { unreachable!(); }\n+                }\n+            }\n+            _ => {\n+                if let Some(span) = span_field {\n+                    quote! { #diag.#name(#span, #message); }\n+                } else {\n+                    quote! { #diag.#name(#message); }\n+                }\n             }\n         };\n \n+        let plain_args: TokenStream = self\n+            .variant\n+            .bindings()\n+            .iter()\n+            .filter(|binding| binding.ast().attrs.is_empty())\n+            .map(|binding| self.generate_field_set_arg(binding))\n+            .collect();\n+\n         Ok(quote! {\n+            #init\n+            #attr_args\n             #call\n-            #args\n+            #plain_args\n         })\n     }\n }"}, {"sha": "20ee5dfc7279844b171ab30f71fd380fc101b0ed", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ea9c370ffec63dc4a94e758790f31e6b14e8d5b5/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea9c370ffec63dc4a94e758790f31e6b14e8d5b5/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=ea9c370ffec63dc4a94e758790f31e6b14e8d5b5", "patch": "@@ -171,8 +171,13 @@ decl_derive!(\n         suggestion_short,\n         suggestion_hidden,\n         suggestion_verbose,\n+        multipart_suggestion,\n+        multipart_suggestion_short,\n+        multipart_suggestion_hidden,\n+        multipart_suggestion_verbose,\n         // field attributes\n         skip_arg,\n         primary_span,\n+        suggestion_part,\n         applicability)] => diagnostics::session_subdiagnostic_derive\n );"}, {"sha": "89eaec78c6f1169b041f56958b2f61091b5212f8", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 134, "deletions": 22, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/ea9c370ffec63dc4a94e758790f31e6b14e8d5b5/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea9c370ffec63dc4a94e758790f31e6b14e8d5b5/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=ea9c370ffec63dc4a94e758790f31e6b14e8d5b5", "patch": "@@ -167,8 +167,8 @@ enum P {\n #[derive(SessionSubdiagnostic)]\n enum Q {\n     #[bar]\n-//~^ ERROR `#[bar]` is not a valid attribute\n-//~^^ ERROR cannot find attribute `bar` in this scope\n+    //~^ ERROR `#[bar]` is not a valid attribute\n+    //~^^ ERROR cannot find attribute `bar` in this scope\n     A {\n         #[primary_span]\n         span: Span,\n@@ -179,8 +179,8 @@ enum Q {\n #[derive(SessionSubdiagnostic)]\n enum R {\n     #[bar = \"...\"]\n-//~^ ERROR `#[bar = ...]` is not a valid attribute\n-//~^^ ERROR cannot find attribute `bar` in this scope\n+    //~^ ERROR `#[bar = ...]` is not a valid attribute\n+    //~^^ ERROR cannot find attribute `bar` in this scope\n     A {\n         #[primary_span]\n         span: Span,\n@@ -191,8 +191,8 @@ enum R {\n #[derive(SessionSubdiagnostic)]\n enum S {\n     #[bar = 4]\n-//~^ ERROR `#[bar = ...]` is not a valid attribute\n-//~^^ ERROR cannot find attribute `bar` in this scope\n+    //~^ ERROR `#[bar = ...]` is not a valid attribute\n+    //~^^ ERROR cannot find attribute `bar` in this scope\n     A {\n         #[primary_span]\n         span: Span,\n@@ -203,8 +203,8 @@ enum S {\n #[derive(SessionSubdiagnostic)]\n enum T {\n     #[bar(\"...\")]\n-//~^ ERROR `#[bar(\"...\")]` is not a valid attribute\n-//~^^ ERROR cannot find attribute `bar` in this scope\n+    //~^ ERROR `#[bar(...)]` is not a valid attribute\n+    //~^^ ERROR cannot find attribute `bar` in this scope\n     A {\n         #[primary_span]\n         span: Span,\n@@ -215,7 +215,7 @@ enum T {\n #[derive(SessionSubdiagnostic)]\n enum U {\n     #[label(code = \"...\")]\n-//~^ ERROR diagnostic slug must be first argument of a `#[label(...)]` attribute\n+    //~^ ERROR diagnostic slug must be first argument of a `#[label(...)]` attribute\n     A {\n         #[primary_span]\n         span: Span,\n@@ -232,7 +232,7 @@ enum V {\n         var: String,\n     },\n     B {\n-//~^ ERROR subdiagnostic kind not specified\n+    //~^ ERROR subdiagnostic kind not specified\n         #[primary_span]\n         span: Span,\n         var: String,\n@@ -310,10 +310,8 @@ union AC {\n #[derive(SessionSubdiagnostic)]\n #[label(parser::add_paren)]\n //~^ NOTE previously specified here\n-//~^^ NOTE previously specified here\n #[label(parser::add_paren)]\n //~^ ERROR specified multiple times\n-//~^^ ERROR specified multiple times\n struct AD {\n     #[primary_span]\n     span: Span,\n@@ -331,16 +329,16 @@ struct AE {\n #[label(parser::add_paren)]\n struct AF {\n     #[primary_span]\n-//~^ NOTE previously specified here\n+    //~^ NOTE previously specified here\n     span_a: Span,\n     #[primary_span]\n-//~^ ERROR specified multiple times\n+    //~^ ERROR specified multiple times\n     span_b: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n struct AG {\n-//~^ ERROR subdiagnostic kind not specified\n+    //~^ ERROR subdiagnostic kind not specified\n     #[primary_span]\n     span: Span,\n }\n@@ -392,27 +390,25 @@ struct AK {\n     #[primary_span]\n     span: Span,\n     #[applicability]\n-//~^ NOTE previously specified here\n+    //~^ NOTE previously specified here\n     applicability_a: Applicability,\n     #[applicability]\n-//~^ ERROR specified multiple times\n+    //~^ ERROR specified multiple times\n     applicability_b: Applicability,\n }\n \n #[derive(SessionSubdiagnostic)]\n #[suggestion(parser::add_paren, code = \"...\")]\n-//~^ ERROR suggestion without `applicability`\n struct AL {\n     #[primary_span]\n     span: Span,\n     #[applicability]\n-//~^ ERROR the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n+    //~^ ERROR the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n     applicability: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n #[suggestion(parser::add_paren, code = \"...\")]\n-//~^ ERROR suggestion without `applicability`\n struct AM {\n     #[primary_span]\n     span: Span,\n@@ -448,8 +444,7 @@ struct AQ;\n \n #[derive(SessionSubdiagnostic)]\n #[suggestion(parser::add_paren, code = \"...\")]\n-//~^ ERROR suggestion without `applicability`\n-//~^^ ERROR suggestion without `#[primary_span]` field\n+//~^ ERROR suggestion without `#[primary_span]` field\n struct AR {\n     var: String,\n }\n@@ -519,3 +514,120 @@ struct AZ {\n     #[primary_span]\n     span: Span,\n }\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(parser::add_paren, code = \"...\")]\n+//~^ ERROR suggestion without `#[primary_span]` field\n+struct BA {\n+    #[suggestion_part]\n+    //~^ ERROR `#[suggestion_part]` is not a valid attribute\n+    span: Span,\n+    #[suggestion_part(code = \"...\")]\n+    //~^ ERROR `#[suggestion_part(...)]` is not a valid attribute\n+    span2: Span,\n+    #[applicability]\n+    applicability: Applicability,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n+//~^ ERROR multipart suggestion without any `#[suggestion_part(...)]` fields\n+//~| ERROR `code` is not a valid nested attribute of a `multipart_suggestion` attribute\n+struct BBa {\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+struct BBb {\n+    #[suggestion_part]\n+    //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+    span1: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+struct BBc {\n+    #[suggestion_part()]\n+    //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+    span1: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren)]\n+//~^ ERROR multipart suggestion without any `#[suggestion_part(...)]` fields\n+struct BC {\n+    #[primary_span]\n+    //~^ ERROR `#[primary_span]` is not a valid attribute\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren)]\n+struct BD {\n+    #[suggestion_part]\n+    //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+    span1: Span,\n+    #[suggestion_part()]\n+    //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+    span2: Span,\n+    #[suggestion_part(foo = \"bar\")]\n+    //~^ ERROR `#[suggestion_part(foo = ...)]` is not a valid attribute\n+    span4: Span,\n+    #[suggestion_part(code = \"...\")]\n+    //~^ ERROR the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n+    s1: String,\n+    #[suggestion_part()]\n+    //~^ ERROR the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n+    s2: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+struct BE {\n+    #[suggestion_part(code = \"...\", code = \",,,\")]\n+    //~^ ERROR specified multiple times\n+    //~| NOTE previously specified here\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+struct BF {\n+    #[suggestion_part(code = \"(\")]\n+    first: Span,\n+    #[suggestion_part(code = \")\")]\n+    second: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren)]\n+struct BG {\n+    #[applicability]\n+    appl: Applicability,\n+    #[suggestion_part(code = \"(\")]\n+    first: Span,\n+    #[suggestion_part(code = \")\")]\n+    second: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+//~^ NOTE previously specified here\n+struct BH {\n+    #[applicability]\n+    //~^ ERROR specified multiple times\n+    appl: Applicability,\n+    #[suggestion_part(code = \"(\")]\n+    first: Span,\n+    #[suggestion_part(code = \")\")]\n+    second: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+struct BI {\n+    #[suggestion_part(code = \"\")]\n+    spans: Vec<Span>,\n+}"}, {"sha": "75a34f44bbe7241bb61e0a293eac4ef41ae06c60", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 158, "deletions": 78, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/ea9c370ffec63dc4a94e758790f31e6b14e8d5b5/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea9c370ffec63dc4a94e758790f31e6b14e8d5b5/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=ea9c370ffec63dc4a94e758790f31e6b14e8d5b5", "patch": "@@ -65,16 +65,16 @@ LL | #[label()]\n    | ^^^^^^^^^^\n \n error: `code` is not a valid nested attribute of a `label` attribute\n-  --> $DIR/subdiagnostic-derive.rs:137:1\n+  --> $DIR/subdiagnostic-derive.rs:137:28\n    |\n LL | #[label(parser::add_paren, code = \"...\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                            ^^^^^^^^^^^^\n \n error: `applicability` is not a valid nested attribute of a `label` attribute\n-  --> $DIR/subdiagnostic-derive.rs:146:1\n+  --> $DIR/subdiagnostic-derive.rs:146:28\n    |\n LL | #[label(parser::add_paren, applicability = \"machine-applicable\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsupported type attribute for subdiagnostic enum\n   --> $DIR/subdiagnostic-derive.rs:155:1\n@@ -100,13 +100,11 @@ error: `#[bar = ...]` is not a valid attribute\n LL |     #[bar = 4]\n    |     ^^^^^^^^^^\n \n-error: `#[bar(\"...\")]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:205:11\n+error: `#[bar(...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:205:5\n    |\n LL |     #[bar(\"...\")]\n-   |           ^^^^^\n-   |\n-   = help: first argument of the attribute should be the diagnostic slug\n+   |     ^^^^^^^^^^^^^\n \n error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n   --> $DIR/subdiagnostic-derive.rs:217:5\n@@ -163,6 +161,8 @@ error: `#[bar(...)]` is not a valid attribute\n    |\n LL |     #[bar(\"...\")]\n    |     ^^^^^^^^^^^^^\n+   |\n+   = help: only `primary_span`, `applicability` and `skip_arg` are valid field attributes\n \n error: unexpected unsupported untagged union\n   --> $DIR/subdiagnostic-derive.rs:304:1\n@@ -175,19 +175,7 @@ LL | | }\n    | |_^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:314:1\n-   |\n-LL | #[label(parser::add_paren)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:311:1\n-   |\n-LL | #[label(parser::add_paren)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:314:1\n+  --> $DIR/subdiagnostic-derive.rs:313:1\n    |\n LL | #[label(parser::add_paren)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -199,141 +187,233 @@ LL | #[label(parser::add_paren)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[label(parser::add_paren)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:323:28\n+  --> $DIR/subdiagnostic-derive.rs:321:28\n    |\n LL | #[label(parser::add_paren, parser::add_paren)]\n    |                            ^^^^^^^^^^^^^^^^^\n    |\n    = help: a diagnostic slug must be the first argument to the attribute\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:336:5\n+  --> $DIR/subdiagnostic-derive.rs:334:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:333:5\n+  --> $DIR/subdiagnostic-derive.rs:331:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: subdiagnostic kind not specified\n-  --> $DIR/subdiagnostic-derive.rs:342:8\n+  --> $DIR/subdiagnostic-derive.rs:340:8\n    |\n LL | struct AG {\n    |        ^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:379:47\n+  --> $DIR/subdiagnostic-derive.rs:377:47\n    |\n LL | #[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n    |                                               ^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:379:33\n+  --> $DIR/subdiagnostic-derive.rs:377:33\n    |\n LL | #[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n    |                                 ^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:397:5\n+  --> $DIR/subdiagnostic-derive.rs:395:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:394:5\n+  --> $DIR/subdiagnostic-derive.rs:392:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n-  --> $DIR/subdiagnostic-derive.rs:408:5\n+  --> $DIR/subdiagnostic-derive.rs:405:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n-error: suggestion without `applicability`\n-  --> $DIR/subdiagnostic-derive.rs:403:1\n+error: suggestion without `code = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:418:1\n    |\n-LL | / #[suggestion(parser::add_paren, code = \"...\")]\n-LL | |\n-LL | | struct AL {\n-LL | |     #[primary_span]\n-...  |\n-LL | |     applicability: Span,\n-LL | | }\n-   | |_^\n+LL | #[suggestion(parser::add_paren)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid applicability\n+  --> $DIR/subdiagnostic-derive.rs:428:46\n+   |\n+LL | #[suggestion(parser::add_paren, code =\"...\", applicability = \"foo\")]\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^\n \n-error: suggestion without `applicability`\n-  --> $DIR/subdiagnostic-derive.rs:414:1\n+error: suggestion without `#[primary_span]` field\n+  --> $DIR/subdiagnostic-derive.rs:446:1\n    |\n LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n-LL | | struct AM {\n-LL | |     #[primary_span]\n-LL | |     span: Span,\n+LL | | struct AR {\n+LL | |     var: String,\n LL | | }\n    | |_^\n \n-error: suggestion without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:422:1\n+error: unsupported type attribute for subdiagnostic enum\n+  --> $DIR/subdiagnostic-derive.rs:460:1\n+   |\n+LL | #[label]\n+   | ^^^^^^^^\n+\n+error: `var` doesn't refer to a field on this type\n+  --> $DIR/subdiagnostic-derive.rs:480:39\n+   |\n+LL | #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+   |                                       ^^^^^^^\n+\n+error: `var` doesn't refer to a field on this type\n+  --> $DIR/subdiagnostic-derive.rs:499:43\n+   |\n+LL |     #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+   |                                           ^^^^^^^\n+\n+error: `#[suggestion_part]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:522:5\n+   |\n+LL |     #[suggestion_part]\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: `#[suggestion_part(...)]` is only valid in multipart suggestions, use `#[primary_span]` instead\n+\n+error: `#[suggestion_part(...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:525:5\n+   |\n+LL |     #[suggestion_part(code = \"...\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-LL | / #[suggestion(parser::add_paren)]\n+   = help: `#[suggestion_part(...)]` is only valid in multipart suggestions\n+\n+error: suggestion without `#[primary_span]` field\n+  --> $DIR/subdiagnostic-derive.rs:519:1\n+   |\n+LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n-LL | | struct AN {\n-LL | |     #[primary_span]\n+LL | | struct BA {\n+LL | |     #[suggestion_part]\n ...  |\n-LL | |     applicability: Applicability,\n+LL | |     var: String,\n LL | | }\n    | |_^\n \n-error: invalid applicability\n-  --> $DIR/subdiagnostic-derive.rs:432:46\n+error: `code` is not a valid nested attribute of a `multipart_suggestion` attribute\n+  --> $DIR/subdiagnostic-derive.rs:534:43\n    |\n-LL | #[suggestion(parser::add_paren, code =\"...\", applicability = \"foo\")]\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^\n+LL | #[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n+   |                                           ^^^^^^^^^^^^\n \n-error: suggestion without `applicability`\n-  --> $DIR/subdiagnostic-derive.rs:450:1\n+error: multipart suggestion without any `#[suggestion_part(...)]` fields\n+  --> $DIR/subdiagnostic-derive.rs:534:1\n    |\n-LL | / #[suggestion(parser::add_paren, code = \"...\")]\n+LL | / #[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n LL | |\n LL | |\n-LL | | struct AR {\n+LL | | struct BBa {\n LL | |     var: String,\n LL | | }\n    | |_^\n \n-error: suggestion without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:450:1\n+error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:544:5\n    |\n-LL | / #[suggestion(parser::add_paren, code = \"...\")]\n+LL |     #[suggestion_part]\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:552:5\n+   |\n+LL |     #[suggestion_part()]\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: `#[primary_span]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:561:5\n+   |\n+LL |     #[primary_span]\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+   = help: multipart suggestions use one or more `#[suggestion_part]`s rather than one `#[primary_span]`\n+\n+error: multipart suggestion without any `#[suggestion_part(...)]` fields\n+  --> $DIR/subdiagnostic-derive.rs:558:1\n+   |\n+LL | / #[multipart_suggestion(parser::add_paren)]\n LL | |\n+LL | | struct BC {\n+LL | |     #[primary_span]\n LL | |\n-LL | | struct AR {\n-LL | |     var: String,\n+LL | |     span: Span,\n LL | | }\n    | |_^\n \n-error: unsupported type attribute for subdiagnostic enum\n-  --> $DIR/subdiagnostic-derive.rs:465:1\n+error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:569:5\n    |\n-LL | #[label]\n-   | ^^^^^^^^\n+LL |     #[suggestion_part]\n+   |     ^^^^^^^^^^^^^^^^^^\n \n-error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:485:39\n+error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:572:5\n    |\n-LL | #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n-   |                                       ^^^^^^^\n+LL |     #[suggestion_part()]\n+   |     ^^^^^^^^^^^^^^^^^^^^\n \n-error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:504:43\n+error: `#[suggestion_part(foo = ...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:575:23\n    |\n-LL |     #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n-   |                                           ^^^^^^^\n+LL |     #[suggestion_part(foo = \"bar\")]\n+   |                       ^^^^^^^^^^^\n+   |\n+   = help: `code` is the only valid nested attribute\n+\n+error: the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n+  --> $DIR/subdiagnostic-derive.rs:578:5\n+   |\n+LL |     #[suggestion_part(code = \"...\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n+  --> $DIR/subdiagnostic-derive.rs:581:5\n+   |\n+LL |     #[suggestion_part()]\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:589:37\n+   |\n+LL |     #[suggestion_part(code = \"...\", code = \",,,\")]\n+   |                                     ^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:589:23\n+   |\n+LL |     #[suggestion_part(code = \"...\", code = \",,,\")]\n+   |                       ^^^^^^^^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:619:5\n+   |\n+LL |     #[applicability]\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:616:43\n+   |\n+LL | #[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find attribute `foo` in this scope\n   --> $DIR/subdiagnostic-derive.rs:63:3\n@@ -395,6 +475,6 @@ error[E0425]: cannot find value `slug` in module `rustc_errors::fluent`\n LL | #[label(slug)]\n    |         ^^^^ not found in `rustc_errors::fluent`\n \n-error: aborting due to 52 previous errors\n+error: aborting due to 64 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}]}