{"sha": "fd8099f0ecc2fd3980469ec45cf834ae9a941ca3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkODA5OWYwZWNjMmZkMzk4MDQ2OWVjNDVjZjgzNGFlOWE5NDFjYTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-04T11:26:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-04T11:26:12Z"}, "message": "Auto merge of #44882 - mikhail-m1:master, r=pnkfelix\n\nadd notes to report_conflicting_borrow MIR borrowck\n\npart of #44596", "tree": {"sha": "ba053282b4b3bc1c04fb9e9ce18e5af40925265a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba053282b4b3bc1c04fb9e9ce18e5af40925265a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd8099f0ecc2fd3980469ec45cf834ae9a941ca3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd8099f0ecc2fd3980469ec45cf834ae9a941ca3", "html_url": "https://github.com/rust-lang/rust/commit/fd8099f0ecc2fd3980469ec45cf834ae9a941ca3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd8099f0ecc2fd3980469ec45cf834ae9a941ca3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eabef0608b030ca8844545837967b29ca4a058b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/eabef0608b030ca8844545837967b29ca4a058b7", "html_url": "https://github.com/rust-lang/rust/commit/eabef0608b030ca8844545837967b29ca4a058b7"}, {"sha": "c68b10f5eed7e7dc74c2d24ad63bcad29baf2e45", "url": "https://api.github.com/repos/rust-lang/rust/commits/c68b10f5eed7e7dc74c2d24ad63bcad29baf2e45", "html_url": "https://github.com/rust-lang/rust/commit/c68b10f5eed7e7dc74c2d24ad63bcad29baf2e45"}], "stats": {"total": 286, "additions": 150, "deletions": 136}, "files": [{"sha": "fea662e21fa9f386fc497c4a983ba029abcd3afa", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 18, "deletions": 91, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/fd8099f0ecc2fd3980469ec45cf834ae9a941ca3/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd8099f0ecc2fd3980469ec45cf834ae9a941ca3/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=fd8099f0ecc2fd3980469ec45cf834ae9a941ca3", "patch": "@@ -470,102 +470,29 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 old_loan.kill_scope.span(self.tcx(), &self.bccx.region_scope_tree).end_point();\n \n             let mut err = match (new_loan.kind, old_loan.kind) {\n-                (ty::MutBorrow, ty::MutBorrow) => {\n-                    let mut err = self.bccx.cannot_mutably_borrow_multiply(\n-                        new_loan.span, &nl, &new_loan_msg, Origin::Ast);\n-\n-                    if new_loan.span == old_loan.span {\n-                        // Both borrows are happening in the same place\n-                        // Meaning the borrow is occurring in a loop\n-                        err.span_label(\n-                                new_loan.span,\n-                                format!(\"mutable borrow starts here in previous \\\n-                                        iteration of loop{}\", new_loan_msg));\n-                        err.span_label(\n-                                previous_end_span,\n-                                \"mutable borrow ends here\");\n-                        err\n-                    } else {\n-                       err.span_label(\n-                                old_loan.span,\n-                                format!(\"first mutable borrow occurs here{}\", old_loan_msg));\n-                        err.span_label(\n-                                new_loan.span,\n-                                format!(\"second mutable borrow occurs here{}\", new_loan_msg));\n-                        err.span_label(\n-                                previous_end_span,\n-                                \"first borrow ends here\");\n-                        err\n-                    }\n-                }\n-\n-                (ty::UniqueImmBorrow, ty::UniqueImmBorrow) => {\n-                    let mut err = self.bccx.cannot_uniquely_borrow_by_two_closures(\n-                        new_loan.span, &nl, Origin::Ast);\n-                    err.span_label(\n-                            old_loan.span,\n-                            \"first closure is constructed here\");\n-                    err.span_label(\n-                            new_loan.span,\n-                            \"second closure is constructed here\");\n-                    err.span_label(\n-                            previous_end_span,\n-                            \"borrow from first closure ends here\");\n-                    err\n-                }\n-\n-                (ty::UniqueImmBorrow, _) => {\n-                    let mut err = self.bccx.cannot_uniquely_borrow_by_one_closure(\n-                        new_loan.span, &nl, &ol_pronoun, &old_loan_msg, Origin::Ast);\n-                    err.span_label(\n-                            new_loan.span,\n-                            format!(\"closure construction occurs here{}\", new_loan_msg));\n-                    err.span_label(\n-                            old_loan.span,\n-                            format!(\"borrow occurs here{}\", old_loan_msg));\n-                    err.span_label(\n-                            previous_end_span,\n-                            \"borrow ends here\");\n-                    err\n-                }\n-\n+                (ty::MutBorrow, ty::MutBorrow) =>\n+                    self.bccx.cannot_mutably_borrow_multiply(\n+                        new_loan.span, &nl, &new_loan_msg, old_loan.span, &old_loan_msg,\n+                        previous_end_span, Origin::Ast),\n+                (ty::UniqueImmBorrow, ty::UniqueImmBorrow) =>\n+                    self.bccx.cannot_uniquely_borrow_by_two_closures(\n+                        new_loan.span, &nl, old_loan.span, previous_end_span, Origin::Ast),\n+                (ty::UniqueImmBorrow, _) =>\n+                    self.bccx.cannot_uniquely_borrow_by_one_closure(\n+                        new_loan.span, &nl, &new_loan_msg,\n+                        old_loan.span, &ol_pronoun, &old_loan_msg, previous_end_span, Origin::Ast),\n                 (_, ty::UniqueImmBorrow) => {\n                     let new_loan_str = &new_loan.kind.to_user_str();\n-                    let mut err = self.bccx.cannot_reborrow_already_uniquely_borrowed(\n-                        new_loan.span, &nl, &new_loan_msg, new_loan_str, Origin::Ast);\n-                    err.span_label(\n-                            new_loan.span,\n-                            format!(\"borrow occurs here{}\", new_loan_msg));\n-                    err.span_label(\n-                            old_loan.span,\n-                            format!(\"closure construction occurs here{}\", old_loan_msg));\n-                    err.span_label(\n-                            previous_end_span,\n-                            \"borrow from closure ends here\");\n-                    err\n+                    self.bccx.cannot_reborrow_already_uniquely_borrowed(\n+                        new_loan.span, &nl, &new_loan_msg, new_loan_str,\n+                        old_loan.span, &old_loan_msg, previous_end_span, Origin::Ast)\n                 }\n-\n-                (..) => {\n-                    let mut err = self.bccx.cannot_reborrow_already_borrowed(\n+                (..) =>\n+                    self.bccx.cannot_reborrow_already_borrowed(\n                         new_loan.span,\n                         &nl, &new_loan_msg, &new_loan.kind.to_user_str(),\n-                        &ol_pronoun, &old_loan.kind.to_user_str(), &old_loan_msg, Origin::Ast);\n-                    err.span_label(\n-                            new_loan.span,\n-                            format!(\"{} borrow occurs here{}\",\n-                                     new_loan.kind.to_user_str(),\n-                                     new_loan_msg));\n-                    err.span_label(\n-                            old_loan.span,\n-                            format!(\"{} borrow occurs here{}\",\n-                                     old_loan.kind.to_user_str(),\n-                                     old_loan_msg));\n-                    err.span_label(\n-                            previous_end_span,\n-                            format!(\"{} borrow ends here\",\n-                                     old_loan.kind.to_user_str()));\n-                    err\n-                }\n+                        old_loan.span, &ol_pronoun, &old_loan.kind.to_user_str(), &old_loan_msg,\n+                        previous_end_span, Origin::Ast)\n             };\n \n             match new_loan.cause {"}, {"sha": "14b6e319132509334a09615b128cb0a9972a0eed", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fd8099f0ecc2fd3980469ec45cf834ae9a941ca3/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd8099f0ecc2fd3980469ec45cf834ae9a941ca3/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=fd8099f0ecc2fd3980469ec45cf834ae9a941ca3", "patch": "@@ -396,28 +396,34 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                             ReadKind::Copy =>\n                                 this.report_use_while_mutably_borrowed(\n                                     context, lvalue_span, borrow),\n-                            ReadKind::Borrow(bk) =>\n+                            ReadKind::Borrow(bk) => {\n+                                let end_issued_loan_span =\n+                                    flow_state.borrows.base_results.operator().region_span(\n+                                        &borrow.region).end_point();\n                                 this.report_conflicting_borrow(\n-                                    context, lvalue_span,\n-                                    common_prefix,\n-                                    (lvalue_span.0, bk), (&borrow.lvalue, borrow.kind)),\n+                                    context, common_prefix, lvalue_span, bk,\n+                                    &borrow, end_issued_loan_span)\n+                            }\n                         }\n                         Control::Break\n                     }\n                     (Write(kind), _) => {\n                         match kind {\n-                            WriteKind::MutableBorrow(bk) =>\n+                            WriteKind::MutableBorrow(bk) => {\n+                                let end_issued_loan_span =\n+                                    flow_state.borrows.base_results.operator().region_span(\n+                                        &borrow.region).end_point();\n                                 this.report_conflicting_borrow(\n-                                    context, lvalue_span,\n-                                    common_prefix,\n-                                    (lvalue_span.0, bk), (&borrow.lvalue, borrow.kind)),\n+                                    context, common_prefix, lvalue_span, bk,\n+                                    &borrow, end_issued_loan_span)\n+                            }\n                             WriteKind::StorageDead |\n                             WriteKind::Mutate =>\n                                 this.report_illegal_mutation_of_borrowed(\n                                     context, lvalue_span, borrow),\n                             WriteKind::Move =>\n                                 this.report_move_out_while_borrowed(\n-                                    context, lvalue_span, borrow),\n+                                    context, lvalue_span, &borrow),\n                         }\n                         Control::Break\n                     }\n@@ -966,48 +972,49 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn report_conflicting_borrow(&mut self,\n                                  _context: Context,\n-                                 (lvalue, span): (&Lvalue, Span),\n                                  common_prefix: &Lvalue,\n-                                 loan1: (&Lvalue, BorrowKind),\n-                                 loan2: (&Lvalue, BorrowKind)) {\n+                                 (lvalue, span): (&Lvalue, Span),\n+                                 gen_borrow_kind: BorrowKind,\n+                                 issued_borrow: &BorrowData,\n+                                 end_issued_loan_span: Span) {\n         use self::prefixes::IsPrefixOf;\n \n-        let (loan1_lvalue, loan1_kind) = loan1;\n-        let (loan2_lvalue, loan2_kind) = loan2;\n+        assert!(common_prefix.is_prefix_of(lvalue));\n+        assert!(common_prefix.is_prefix_of(&issued_borrow.lvalue));\n \n-        assert!(common_prefix.is_prefix_of(loan1_lvalue));\n-        assert!(common_prefix.is_prefix_of(loan2_lvalue));\n+        let issued_span = self.retrieve_borrow_span(issued_borrow);\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n-        let mut err = match (loan1_kind, \"immutable\", \"mutable\",\n-                             loan2_kind, \"immutable\", \"mutable\") {\n+        let mut err = match (gen_borrow_kind, \"immutable\", \"mutable\",\n+                             issued_borrow.kind, \"immutable\", \"mutable\") {\n             (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n             (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) =>\n                 self.tcx.cannot_reborrow_already_borrowed(\n-                    span, &self.describe_lvalue(lvalue),\n-                    \"\", lft, \"it\", rgt, \"\", Origin::Mir),\n+                    span, &self.describe_lvalue(lvalue), \"\", lft, issued_span,\n+                    \"it\", rgt, \"\", end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Mut, _, _, BorrowKind::Mut, _, _) =>\n                 self.tcx.cannot_mutably_borrow_multiply(\n-                    span, &self.describe_lvalue(lvalue), \"\", Origin::Mir),\n+                    span, &self.describe_lvalue(lvalue), \"\", issued_span,\n+                    \"\", end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) =>\n                 self.tcx.cannot_uniquely_borrow_by_two_closures(\n-                    span, &self.describe_lvalue(lvalue), Origin::Mir),\n+                    span, &self.describe_lvalue(lvalue), issued_span,\n+                    end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Unique, _, _, _, _, _) =>\n                 self.tcx.cannot_uniquely_borrow_by_one_closure(\n-                    span, &self.describe_lvalue(lvalue), \"it\", \"\", Origin::Mir),\n+                    span, &self.describe_lvalue(lvalue), \"\",\n+                    issued_span, \"it\", \"\", end_issued_loan_span, Origin::Mir),\n \n             (_, _, _, BorrowKind::Unique, _, _) =>\n                 self.tcx.cannot_reborrow_already_uniquely_borrowed(\n-                    span, &self.describe_lvalue(lvalue), \"it\", \"\", Origin::Mir),\n+                    span, &self.describe_lvalue(lvalue), \"it\", \"\",\n+                    issued_span, \"\", end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) =>\n                 unreachable!(),\n-\n-            // FIXME: add span labels for first and second mutable borrows, as well as\n-            // end point for first.\n         };\n         err.emit();\n     }"}, {"sha": "22ba7479ead6222a2744c8829171ccea66f39552", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fd8099f0ecc2fd3980469ec45cf834ae9a941ca3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd8099f0ecc2fd3980469ec45cf834ae9a941ca3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=fd8099f0ecc2fd3980469ec45cf834ae9a941ca3", "patch": "@@ -11,6 +11,7 @@\n use rustc::mir::{self, Location, Mir};\n use rustc::mir::visit::Visitor;\n use rustc::ty::{Region, TyCtxt};\n+use rustc::ty::RegionKind;\n use rustc::ty::RegionKind::ReScope;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n@@ -21,6 +22,8 @@ use rustc_data_structures::indexed_vec::{IndexVec};\n use dataflow::{BitDenotation, BlockSets, DataflowOperator};\n pub use dataflow::indexes::BorrowIndex;\n \n+use syntax_pos::Span;\n+\n use std::fmt;\n \n // `Borrows` maps each dataflow bit to an `Rvalue::Ref`, which can be\n@@ -32,6 +35,7 @@ pub struct Borrows<'a, 'tcx: 'a> {\n     borrows: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n     location_map: FxHashMap<Location, BorrowIndex>,\n     region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+    region_span_map: FxHashMap<RegionKind, Span>,\n }\n \n // temporarily allow some dead fields: `kind` and `region` will be\n@@ -63,18 +67,21 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n         let mut visitor = GatherBorrows { idx_vec: IndexVec::new(),\n                                           location_map: FxHashMap(),\n-                                          region_map: FxHashMap(), };\n+                                          region_map: FxHashMap(),\n+                                          region_span_map: FxHashMap()};\n         visitor.visit_mir(mir);\n         return Borrows { tcx: tcx,\n                          mir: mir,\n                          borrows: visitor.idx_vec,\n                          location_map: visitor.location_map,\n-                         region_map: visitor.region_map, };\n+                         region_map: visitor.region_map,\n+                         region_span_map: visitor.region_span_map};\n \n         struct GatherBorrows<'tcx> {\n             idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n             location_map: FxHashMap<Location, BorrowIndex>,\n             region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+            region_span_map: FxHashMap<RegionKind, Span>,\n         }\n         impl<'tcx> Visitor<'tcx> for GatherBorrows<'tcx> {\n             fn visit_rvalue(&mut self,\n@@ -90,6 +97,16 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n                     borrows.insert(idx);\n                 }\n             }\n+\n+            fn visit_statement(&mut self,\n+                               block: mir::BasicBlock,\n+                               statement: &mir::Statement<'tcx>,\n+                               location: Location) {\n+                if let mir::StatementKind::EndRegion(region_scope) = statement.kind {\n+                    self.region_span_map.insert(ReScope(region_scope), statement.source_info.span);\n+                }\n+                self.super_statement(block, statement, location);\n+            }\n         }\n     }\n \n@@ -98,6 +115,12 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     pub fn location(&self, idx: BorrowIndex) -> &Location {\n         &self.borrows[idx].location\n     }\n+\n+    pub fn region_span(&self, region: &Region) -> Span {\n+        let opt_span = self.region_span_map.get(region);\n+        assert!(opt_span.is_some(), \"end region not found for {:?}\", region);\n+        *opt_span.unwrap()\n+    }\n }\n \n impl<'a, 'tcx> BitDenotation for Borrows<'a, 'tcx> {"}, {"sha": "81e3cd7f61fbc9b50abae5e9733c0f3f3d217e45", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 73, "deletions": 16, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/fd8099f0ecc2fd3980469ec45cf834ae9a941ca3/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd8099f0ecc2fd3980469ec45cf834ae9a941ca3/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=fd8099f0ecc2fd3980469ec45cf834ae9a941ca3", "patch": "@@ -88,66 +88,123 @@ pub trait BorrowckErrors {\n     }\n \n     fn cannot_mutably_borrow_multiply(&self,\n-                                      span: Span,\n+                                      new_loan_span: Span,\n                                       desc: &str,\n                                       opt_via: &str,\n+                                      old_loan_span: Span,\n+                                      old_opt_via: &str,\n+                                      old_load_end_span:Span,\n                                       o: Origin)\n                                       -> DiagnosticBuilder\n     {\n-        struct_span_err!(self, span, E0499,\n+        let mut err = struct_span_err!(self, new_loan_span, E0499,\n                          \"cannot borrow `{}`{} as mutable more than once at a time{OGN}\",\n-                         desc, opt_via, OGN=o)\n+                         desc, opt_via, OGN=o);\n+        if old_loan_span == new_loan_span {\n+            // Both borrows are happening in the same place\n+            // Meaning the borrow is occurring in a loop\n+            err.span_label(new_loan_span,\n+                           format!(\"mutable borrow starts here in previous \\\n+                                    iteration of loop{}\", opt_via));\n+            err.span_label(old_load_end_span, \"mutable borrow ends here\");\n+        } else {\n+            err.span_label(old_loan_span,\n+                           format!(\"first mutable borrow occurs here{}\", old_opt_via));\n+            err.span_label(new_loan_span,\n+                           format!(\"second mutable borrow occurs here{}\", opt_via));\n+            err.span_label(old_load_end_span, \"first borrow ends here\");\n+        }\n+        err\n     }\n \n-    fn cannot_uniquely_borrow_by_two_closures(&self, span: Span, desc: &str, o: Origin)\n+    fn cannot_uniquely_borrow_by_two_closures(&self,\n+                                              new_loan_span: Span,\n+                                              desc: &str,\n+                                              old_loan_span: Span,\n+                                              old_load_end_span: Span,\n+                                              o: Origin)\n                                               -> DiagnosticBuilder\n     {\n-        struct_span_err!(self, span, E0524,\n+        let mut err = struct_span_err!(self, new_loan_span, E0524,\n                          \"two closures require unique access to `{}` at the same time{OGN}\",\n-                         desc, OGN=o)\n+                         desc, OGN=o);\n+        err.span_label(\n+            old_loan_span,\n+            \"first closure is constructed here\");\n+        err.span_label(\n+            new_loan_span,\n+            \"second closure is constructed here\");\n+        err.span_label(\n+            old_load_end_span,\n+            \"borrow from first closure ends here\");\n+        err\n     }\n \n     fn cannot_uniquely_borrow_by_one_closure(&self,\n-                                             span: Span,\n+                                             new_loan_span: Span,\n                                              desc_new: &str,\n+                                             opt_via: &str,\n+                                             old_loan_span: Span,\n                                              noun_old: &str,\n-                                             msg_old: &str,\n+                                             old_opt_via: &str,\n+                                             previous_end_span: Span,\n                                              o: Origin)\n                                              -> DiagnosticBuilder\n     {\n-        struct_span_err!(self, span, E0500,\n+        let mut err = struct_span_err!(self, new_loan_span, E0500,\n                          \"closure requires unique access to `{}` but {} is already borrowed{}{OGN}\",\n-                         desc_new, noun_old, msg_old, OGN=o)\n+                         desc_new, noun_old, old_opt_via, OGN=o);\n+        err.span_label(new_loan_span,\n+                       format!(\"closure construction occurs here{}\", opt_via));\n+        err.span_label(old_loan_span,\n+                       format!(\"borrow occurs here{}\", old_opt_via));\n+        err.span_label(previous_end_span, \"borrow ends here\");\n+        err\n     }\n \n     fn cannot_reborrow_already_uniquely_borrowed(&self,\n-                                                 span: Span,\n+                                                 new_loan_span: Span,\n                                                  desc_new: &str,\n-                                                 msg_new: &str,\n+                                                 opt_via: &str,\n                                                  kind_new: &str,\n+                                                 old_loan_span: Span,\n+                                                 old_opt_via: &str,\n+                                                 previous_end_span: Span,\n                                                  o: Origin)\n                                                  -> DiagnosticBuilder\n     {\n-        struct_span_err!(self, span, E0501,\n+        let mut err = struct_span_err!(self, new_loan_span, E0501,\n                          \"cannot borrow `{}`{} as {} because previous closure \\\n                           requires unique access{OGN}\",\n-                         desc_new, msg_new, kind_new, OGN=o)\n+                         desc_new, opt_via, kind_new, OGN=o);\n+        err.span_label(new_loan_span,\n+                       format!(\"borrow occurs here{}\", opt_via));\n+        err.span_label(old_loan_span,\n+                       format!(\"closure construction occurs here{}\", old_opt_via));\n+        err.span_label(previous_end_span, \"borrow from closure ends here\");\n+        err\n     }\n \n     fn cannot_reborrow_already_borrowed(&self,\n                                         span: Span,\n                                         desc_new: &str,\n                                         msg_new: &str,\n                                         kind_new: &str,\n+                                        old_span: Span,\n                                         noun_old: &str,\n                                         kind_old: &str,\n                                         msg_old: &str,\n+                                        old_load_end_span: Span,\n                                         o: Origin)\n                                         -> DiagnosticBuilder\n     {\n-        struct_span_err!(self, span, E0502,\n+        let mut err = struct_span_err!(self, span, E0502,\n                          \"cannot borrow `{}`{} as {} because {} is also borrowed as {}{}{OGN}\",\n-                         desc_new, msg_new, kind_new, noun_old, kind_old, msg_old, OGN=o)\n+                         desc_new, msg_new, kind_new, noun_old, kind_old, msg_old, OGN=o);\n+        err.span_label(span, format!(\"{} borrow occurs here{}\", kind_new, msg_new));\n+        err.span_label(old_span, format!(\"{} borrow occurs here{}\", kind_old, msg_old));\n+        err.span_label(old_load_end_span, format!(\"{} borrow ends here\", kind_old));\n+        err\n     }\n \n     fn cannot_assign_to_borrowed(&self, span: Span, borrow_span: Span, desc: &str, o: Origin)"}]}