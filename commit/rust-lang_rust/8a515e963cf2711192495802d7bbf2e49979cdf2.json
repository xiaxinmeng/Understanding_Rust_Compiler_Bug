{"sha": "8a515e963cf2711192495802d7bbf2e49979cdf2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNTE1ZTk2M2NmMjcxMTE5MjQ5NTgwMmQ3YmJmMmU0OTk3OWNkZjI=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-06-22T17:25:39Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-06-30T14:42:58Z"}, "message": "Deny unsafe ops in unsafe fns, part 2", "tree": {"sha": "6b5d4a3ccb13e27782c715f3adba5b57769904b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b5d4a3ccb13e27782c715f3adba5b57769904b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a515e963cf2711192495802d7bbf2e49979cdf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a515e963cf2711192495802d7bbf2e49979cdf2", "html_url": "https://github.com/rust-lang/rust/commit/8a515e963cf2711192495802d7bbf2e49979cdf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a515e963cf2711192495802d7bbf2e49979cdf2/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ee1dec77b89d6341a147d91af8733f8e0b5efc7", "html_url": "https://github.com/rust-lang/rust/commit/8ee1dec77b89d6341a147d91af8733f8e0b5efc7"}], "stats": {"total": 140, "additions": 103, "deletions": 37}, "files": [{"sha": "84148058d03f72eb78b04618ce4200eb2abb9c5a", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=8a515e963cf2711192495802d7bbf2e49979cdf2", "patch": "@@ -1,6 +1,7 @@\n //! An implementation of SipHash.\n \n #![allow(deprecated)] // the types in this module are deprecated\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::cmp;\n use crate::marker::PhantomData;\n@@ -130,15 +131,19 @@ unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n     let mut i = 0; // current byte index (from LSB) in the output u64\n     let mut out = 0;\n     if i + 3 < len {\n-        out = load_int_le!(buf, start + i, u32) as u64;\n+        // SAFETY: `i` cannot be greater than `len`, and the caller must guarantee\n+        // that the index start..start+len is in bounds.\n+        out = unsafe { load_int_le!(buf, start + i, u32) } as u64;\n         i += 4;\n     }\n     if i + 1 < len {\n-        out |= (load_int_le!(buf, start + i, u16) as u64) << (i * 8);\n+        // SAFETY: same as above.\n+        out |= (unsafe { load_int_le!(buf, start + i, u16) } as u64) << (i * 8);\n         i += 2\n     }\n     if i < len {\n-        out |= (*buf.get_unchecked(start + i) as u64) << (i * 8);\n+        // SAFETY: same as above.\n+        out |= (unsafe { *buf.get_unchecked(start + i) } as u64) << (i * 8);\n         i += 1;\n     }\n     debug_assert_eq!(i, len);"}, {"sha": "d2e2fc04a2b7661001f1741c256d14de124f23e1", "filename": "src/libcore/iter/adapters/fuse.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs?ref=8a515e963cf2711192495802d7bbf2e49979cdf2", "patch": "@@ -178,9 +178,10 @@ where\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n         match self.iter {\n-            Some(ref mut iter) => iter.get_unchecked(i),\n+            // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+            Some(ref mut iter) => unsafe { iter.get_unchecked(i) },\n             // SAFETY: the caller asserts there is an item at `i`, so we're not exhausted.\n-            None => intrinsics::unreachable(),\n+            None => unsafe { intrinsics::unreachable() },\n         }\n     }\n "}, {"sha": "133643a0c7f0368c0b7f1cf6eb78c4d1c538dc6f", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=8a515e963cf2711192495802d7bbf2e49979cdf2", "patch": "@@ -272,7 +272,8 @@ where\n     T: Copy,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        *self.it.get_unchecked(i)\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { *self.it.get_unchecked(i) }\n     }\n \n     #[inline]\n@@ -402,7 +403,8 @@ where\n     T: Clone,\n {\n     default unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        self.it.get_unchecked(i).clone()\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { self.it.get_unchecked(i) }.clone()\n     }\n \n     #[inline]\n@@ -418,7 +420,8 @@ where\n     T: Copy,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        *self.it.get_unchecked(i)\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { *self.it.get_unchecked(i) }\n     }\n \n     #[inline]\n@@ -930,7 +933,8 @@ where\n     F: FnMut(I::Item) -> B,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        (self.f)(self.iter.get_unchecked(i))\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        (self.f)(unsafe { self.iter.get_unchecked(i) })\n     }\n     #[inline]\n     fn may_have_side_effect() -> bool {\n@@ -1392,7 +1396,8 @@ where\n     I: TrustedRandomAccess,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> (usize, I::Item) {\n-        (self.count + i, self.iter.get_unchecked(i))\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        (self.count + i, unsafe { self.iter.get_unchecked(i) })\n     }\n \n     fn may_have_side_effect() -> bool {"}, {"sha": "985e6561665c7e923511274e8cb31d2ca7b992e8", "filename": "src/libcore/iter/adapters/zip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=8a515e963cf2711192495802d7bbf2e49979cdf2", "patch": "@@ -271,7 +271,8 @@ where\n     B: TrustedRandomAccess,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> (A::Item, B::Item) {\n-        (self.a.get_unchecked(i), self.b.get_unchecked(i))\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { (self.a.get_unchecked(i), self.b.get_unchecked(i)) }\n     }\n \n     fn may_have_side_effect() -> bool {"}, {"sha": "4a1f6418bb5b3feced5f200285b8c81f00b917c4", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=8a515e963cf2711192495802d7bbf2e49979cdf2", "patch": "@@ -309,6 +309,7 @@\n //! [`min`]: trait.Iterator.html#method.min\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::ops::Try;\n "}, {"sha": "ee53b6a13f837627028c2f1530aaeaf8aa6ec288", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=8a515e963cf2711192495802d7bbf2e49979cdf2", "patch": "@@ -189,12 +189,14 @@ macro_rules! step_identical_methods {\n     () => {\n         #[inline]\n         unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n-            start.unchecked_add(n as Self)\n+            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n+            unsafe { start.unchecked_add(n as Self) }\n         }\n \n         #[inline]\n         unsafe fn backward_unchecked(start: Self, n: usize) -> Self {\n-            start.unchecked_sub(n as Self)\n+            // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.\n+            unsafe { start.unchecked_sub(n as Self) }\n         }\n \n         #[inline]\n@@ -450,21 +452,33 @@ unsafe impl Step for char {\n     #[inline]\n     unsafe fn forward_unchecked(start: char, count: usize) -> char {\n         let start = start as u32;\n-        let mut res = Step::forward_unchecked(start, count);\n+        // SAFETY: the caller must guarantee that this doesn't overflow\n+        // the range of values for a char.\n+        let mut res = unsafe { Step::forward_unchecked(start, count) };\n         if start < 0xD800 && 0xD800 <= res {\n-            res = Step::forward_unchecked(res, 0x800);\n+            // SAFETY: the caller must guarantee that this doesn't overflow\n+            // the range of values for a char.\n+            res = unsafe { Step::forward_unchecked(res, 0x800) };\n         }\n-        char::from_u32_unchecked(res)\n+        // SAFETY: because of the previous contract, this is guaranteed\n+        // by the caller to be a valid char.\n+        unsafe { char::from_u32_unchecked(res) }\n     }\n \n     #[inline]\n     unsafe fn backward_unchecked(start: char, count: usize) -> char {\n         let start = start as u32;\n-        let mut res = Step::backward_unchecked(start, count);\n+        // SAFETY: the caller must guarantee that this doesn't overflow\n+        // the range of values for a char.\n+        let mut res = unsafe { Step::backward_unchecked(start, count) };\n         if start >= 0xE000 && 0xE000 > res {\n-            res = Step::backward_unchecked(res, 0x800);\n+            // SAFETY: the caller must guarantee that this doesn't overflow\n+            // the range of values for a char.\n+            res = unsafe { Step::backward_unchecked(res, 0x800) };\n         }\n-        char::from_u32_unchecked(res)\n+        // SAFETY: because of the previous contract, this is guaranteed\n+        // by the caller to be a valid char.\n+        unsafe { char::from_u32_unchecked(res) }\n     }\n }\n "}, {"sha": "920f5e9c0bd28521e732e3e5159862168fd1c807", "filename": "src/libcore/mem/manually_drop.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=8a515e963cf2711192495802d7bbf2e49979cdf2", "patch": "@@ -122,7 +122,9 @@ impl<T> ManuallyDrop<T> {\n     #[stable(feature = \"manually_drop_take\", since = \"1.42.0\")]\n     #[inline]\n     pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {\n-        ptr::read(&slot.value)\n+        // SAFETY: we are reading from a reference, which is guaranteed\n+        // to be valid for reads.\n+        unsafe { ptr::read(&slot.value) }\n     }\n }\n \n@@ -152,7 +154,10 @@ impl<T: ?Sized> ManuallyDrop<T> {\n     #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n-        ptr::drop_in_place(&mut slot.value)\n+        // SAFETY: we are dropping the value pointed to by a mutable reference\n+        // which is guaranteed to be valid for writes.\n+        // It is up to the caller to make sure that `slot` isn't dropped again.\n+        unsafe { ptr::drop_in_place(&mut slot.value) }\n     }\n }\n "}, {"sha": "7732525a0fc28a0556be5acac26724fbfd39dd20", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=8a515e963cf2711192495802d7bbf2e49979cdf2", "patch": "@@ -494,8 +494,12 @@ impl<T> MaybeUninit<T> {\n     #[inline(always)]\n     #[rustc_diagnostic_item = \"assume_init\"]\n     pub unsafe fn assume_init(self) -> T {\n-        intrinsics::assert_inhabited::<T>();\n-        ManuallyDrop::into_inner(self.value)\n+        // SAFETY: the caller must guarantee that `self` is initialized.\n+        // This also means that `self` must be a `value` variant.\n+        unsafe {\n+            intrinsics::assert_inhabited::<T>();\n+            ManuallyDrop::into_inner(self.value)\n+        }\n     }\n \n     /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n@@ -558,8 +562,12 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n     pub unsafe fn read(&self) -> T {\n-        intrinsics::assert_inhabited::<T>();\n-        self.as_ptr().read()\n+        // SAFETY: the caller must guarantee that `self` is initialized.\n+        // Reading from `self.as_ptr()` is safe since `self` should be initialized.\n+        unsafe {\n+            intrinsics::assert_inhabited::<T>();\n+            self.as_ptr().read()\n+        }\n     }\n \n     /// Gets a shared reference to the contained value.\n@@ -620,8 +628,12 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_ref(&self) -> &T {\n-        intrinsics::assert_inhabited::<T>();\n-        &*self.value\n+        // SAFETY: the caller must guarantee that `self` is initialized.\n+        // This also means that `self` must be a `value` variant.\n+        unsafe {\n+            intrinsics::assert_inhabited::<T>();\n+            &*self.value\n+        }\n     }\n \n     /// Gets a mutable (unique) reference to the contained value.\n@@ -738,8 +750,12 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n-        intrinsics::assert_inhabited::<T>();\n-        &mut *self.value\n+        // SAFETY: the caller must guarantee that `self` is initialized.\n+        // This also means that `self` must be a `value` variant.\n+        unsafe {\n+            intrinsics::assert_inhabited::<T>();\n+            &mut *self.value\n+        }\n     }\n \n     /// Assuming all the elements are initialized, get a slice to them.\n@@ -752,7 +768,11 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"none\")]\n     #[inline(always)]\n     pub unsafe fn slice_get_ref(slice: &[Self]) -> &[T] {\n-        &*(slice as *const [Self] as *const [T])\n+        // SAFETY: casting slice to a `*const [T]` is safe since the caller guarantees that\n+        // `slice` is initialized, and`MaybeUninit` is guaranteed to have the same layout as `T`.\n+        // The pointer obtained is valid since it refers to memory owned by `slice` which is a\n+        // reference and thus guaranteed to be valid for reads.\n+        unsafe { &*(slice as *const [Self] as *const [T]) }\n     }\n \n     /// Assuming all the elements are initialized, get a mutable slice to them.\n@@ -765,7 +785,9 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"none\")]\n     #[inline(always)]\n     pub unsafe fn slice_get_mut(slice: &mut [Self]) -> &mut [T] {\n-        &mut *(slice as *mut [Self] as *mut [T])\n+        // SAFETY: similar to safety notes for `slice_get_ref`, but we have a\n+        // mutable reference which is also guaranteed to be valid for writes.\n+        unsafe { &mut *(slice as *mut [Self] as *mut [T]) }\n     }\n \n     /// Gets a pointer to the first element of the array."}, {"sha": "20ea83fd063c69e54ea67c8333b9c05b613003f1", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a515e963cf2711192495802d7bbf2e49979cdf2/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=8a515e963cf2711192495802d7bbf2e49979cdf2", "patch": "@@ -4,6 +4,7 @@\n //! types, initializing and manipulating memory.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::clone;\n use crate::cmp;\n@@ -623,8 +624,11 @@ pub const fn needs_drop<T>() -> bool {\n #[allow(deprecated)]\n #[rustc_diagnostic_item = \"mem_zeroed\"]\n pub unsafe fn zeroed<T>() -> T {\n-    intrinsics::assert_zero_valid::<T>();\n-    MaybeUninit::zeroed().assume_init()\n+    // SAFETY: the caller must guarantee that an all-zero value is valid for `T`.\n+    unsafe {\n+        intrinsics::assert_zero_valid::<T>();\n+        MaybeUninit::zeroed().assume_init()\n+    }\n }\n \n /// Bypasses Rust's normal memory-initialization checks by pretending to\n@@ -656,8 +660,11 @@ pub unsafe fn zeroed<T>() -> T {\n #[allow(deprecated)]\n #[rustc_diagnostic_item = \"mem_uninitialized\"]\n pub unsafe fn uninitialized<T>() -> T {\n-    intrinsics::assert_uninit_valid::<T>();\n-    MaybeUninit::uninit().assume_init()\n+    // SAFETY: the caller must guarantee that an unitialized value is valid for `T`.\n+    unsafe {\n+        intrinsics::assert_uninit_valid::<T>();\n+        MaybeUninit::uninit().assume_init()\n+    }\n }\n \n /// Swaps the values at two mutable locations, without deinitializing either one.\n@@ -922,9 +929,14 @@ pub fn drop<T>(_x: T) {}\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     // If U has a higher alignment requirement, src may not be suitably aligned.\n     if align_of::<U>() > align_of::<T>() {\n-        ptr::read_unaligned(src as *const T as *const U)\n+        // SAFETY: `src` is a reference which is guaranteed to be valid for reads.\n+        // The caller must guarantee that the actual transmutation is safe.\n+        unsafe { ptr::read_unaligned(src as *const T as *const U) }\n     } else {\n-        ptr::read(src as *const T as *const U)\n+        // SAFETY: `src` is a reference which is guaranteed to be valid for reads.\n+        // We just checked that `src as *const U` was properly aligned.\n+        // The caller must guarantee that the actual transmutation is safe.\n+        unsafe { ptr::read(src as *const T as *const U) }\n     }\n }\n "}]}