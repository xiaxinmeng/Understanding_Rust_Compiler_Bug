{"sha": "f02490d960ecff8fc17272453f4eb8a6837b5a18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMjQ5MGQ5NjBlY2ZmOGZjMTcyNzI0NTNmNGViOGE2ODM3YjVhMTg=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-02-21T14:06:09Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-02-21T14:06:09Z"}, "message": "Rustfmt", "tree": {"sha": "b93c66bda558c49a65960a99a51dbe56a1cc907e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b93c66bda558c49a65960a99a51dbe56a1cc907e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f02490d960ecff8fc17272453f4eb8a6837b5a18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f02490d960ecff8fc17272453f4eb8a6837b5a18", "html_url": "https://github.com/rust-lang/rust/commit/f02490d960ecff8fc17272453f4eb8a6837b5a18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f02490d960ecff8fc17272453f4eb8a6837b5a18/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a87aa4f583ea7b7d4e7fab94ced9fcb6c6058a93", "url": "https://api.github.com/repos/rust-lang/rust/commits/a87aa4f583ea7b7d4e7fab94ced9fcb6c6058a93", "html_url": "https://github.com/rust-lang/rust/commit/a87aa4f583ea7b7d4e7fab94ced9fcb6c6058a93"}], "stats": {"total": 559, "additions": 340, "deletions": 219}, "files": [{"sha": "b4de8aeea196928a3f658497b74f23bf429e9455", "filename": "src/abi.rs", "status": "modified", "additions": 114, "deletions": 53, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=f02490d960ecff8fc17272453f4eb8a6837b5a18", "patch": "@@ -2,7 +2,7 @@ use std::borrow::Cow;\n use std::iter;\n \n use rustc::hir;\n-use rustc::ty::layout::{Scalar, Primitive, Integer, FloatTy};\n+use rustc::ty::layout::{FloatTy, Integer, Primitive, Scalar};\n use rustc_target::spec::abi::Abi;\n \n use crate::prelude::*;\n@@ -32,11 +32,11 @@ pub fn scalar_to_clif_type(tcx: TyCtxt, scalar: Scalar) -> Type {\n             Integer::I32 => types::I32,\n             Integer::I64 => types::I64,\n             Integer::I128 => unimpl!(\"u/i128\"),\n-        }\n+        },\n         Primitive::Float(flt) => match flt {\n             FloatTy::F32 => types::F32,\n             FloatTy::F64 => types::F64,\n-        }\n+        },\n         Primitive::Pointer => pointer_ty(tcx),\n     }\n }\n@@ -46,9 +46,7 @@ fn get_pass_mode<'a, 'tcx: 'a>(\n     ty: Ty<'tcx>,\n     is_return: bool,\n ) -> PassMode {\n-    let layout = tcx\n-        .layout_of(ParamEnv::reveal_all().and(ty))\n-        .unwrap();\n+    let layout = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n     assert!(!layout.is_unsized());\n \n     if layout.size.bytes() == 0 {\n@@ -66,7 +64,9 @@ fn get_pass_mode<'a, 'tcx: 'a>(\n                     PassMode::ByRef\n                 }\n             }\n-            layout::Abi::Scalar(scalar) => PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone())),\n+            layout::Abi::Scalar(scalar) => {\n+                PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone()))\n+            }\n \n             // FIXME implement ScalarPair and Vector Abi in a cg_llvm compatible way\n             layout::Abi::ScalarPair(_, _) => PassMode::ByRef,\n@@ -88,10 +88,7 @@ fn adjust_arg_for_abi<'a, 'tcx: 'a>(\n     }\n }\n \n-fn clif_sig_from_fn_sig<'a, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    sig: FnSig<'tcx>,\n-) -> Signature {\n+fn clif_sig_from_fn_sig<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sig: FnSig<'tcx>) -> Signature {\n     let (call_conv, inputs, output): (CallConv, Vec<Ty>, Ty) = match sig.abi {\n         Abi::Rust => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n         Abi::C => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n@@ -191,7 +188,7 @@ pub fn ty_fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> ty::FnS\n pub fn get_function_name_and_sig<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     inst: Instance<'tcx>,\n-    support_vararg: bool\n+    support_vararg: bool,\n ) -> (String, Signature) {\n     assert!(!inst.substs.needs_infer() && !inst.substs.has_param_types());\n     let fn_ty = inst.ty(tcx);\n@@ -219,7 +216,8 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n     /// Instance must be monomorphized\n     pub fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n         let func_id = import_function(self.tcx, self.module, inst);\n-        let func_ref = self.module\n+        let func_ref = self\n+            .module\n             .declare_func_in_func(func_id, &mut self.bcx.func);\n \n         #[cfg(debug_assertions)]\n@@ -285,7 +283,12 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n         if let Some(val) = self.lib_call(name, input_tys, return_ty, &args) {\n             CValue::ByVal(val, return_layout)\n         } else {\n-            CValue::ByRef(self.bcx.ins().iconst(self.pointer_type, self.pointer_type.bytes() as i64), return_layout)\n+            CValue::ByRef(\n+                self.bcx\n+                    .ins()\n+                    .iconst(self.pointer_type, self.pointer_type.bytes() as i64),\n+                return_layout,\n+            )\n         }\n     }\n \n@@ -322,13 +325,21 @@ fn add_arg_comment<'a, 'tcx: 'a>(\n     let pass_mode = format!(\"{:?}\", pass_mode);\n     fx.add_global_comment(format!(\n         \"{msg:5} {local:>3}{local_field:<5} {param:10} {pass_mode:20} {ssa:10} {ty:?}\",\n-        msg=msg, local=format!(\"{:?}\", local), local_field=local_field, param=param, pass_mode=pass_mode, ssa=format!(\"{:?}\", ssa), ty=ty,\n+        msg = msg,\n+        local = format!(\"{:?}\", local),\n+        local_field = local_field,\n+        param = param,\n+        pass_mode = pass_mode,\n+        ssa = format!(\"{:?}\", ssa),\n+        ty = ty,\n     ));\n }\n \n #[cfg(debug_assertions)]\n fn add_local_header_comment(fx: &mut FunctionCx<impl Backend>) {\n-    fx.add_global_comment(format!(\"msg   loc.idx    param    pass mode            ssa flags  ty\"));\n+    fx.add_global_comment(format!(\n+        \"msg   loc.idx    param    pass mode            ssa flags  ty\"\n+    ));\n }\n \n fn local_place<'a, 'tcx: 'a>(\n@@ -338,23 +349,41 @@ fn local_place<'a, 'tcx: 'a>(\n     is_ssa: bool,\n ) -> CPlace<'tcx> {\n     let place = if is_ssa {\n-        fx.bcx.declare_var(mir_var(local), fx.clif_type(layout.ty).unwrap());\n+        fx.bcx\n+            .declare_var(mir_var(local), fx.clif_type(layout.ty).unwrap());\n         CPlace::Var(local, layout)\n     } else {\n         let place = CPlace::new_stack_slot(fx, layout.ty);\n \n         #[cfg(debug_assertions)]\n         {\n             let TyLayout { ty, details } = layout;\n-            let ty::layout::LayoutDetails { size, align, abi: _, variants: _, fields: _ } = details;\n+            let ty::layout::LayoutDetails {\n+                size,\n+                align,\n+                abi: _,\n+                variants: _,\n+                fields: _,\n+            } = details;\n             match place {\n-                CPlace::Stack(stack_slot, _) => fx.add_entity_comment(stack_slot, format!(\n-                    \"{:?}: {:?} size={} align={},{}\",\n-                    local, ty, size.bytes(), align.abi.bytes(), align.pref.bytes(),\n-                )),\n+                CPlace::Stack(stack_slot, _) => fx.add_entity_comment(\n+                    stack_slot,\n+                    format!(\n+                        \"{:?}: {:?} size={} align={},{}\",\n+                        local,\n+                        ty,\n+                        size.bytes(),\n+                        align.abi.bytes(),\n+                        align.pref.bytes(),\n+                    ),\n+                ),\n                 CPlace::NoPlace(_) => fx.add_global_comment(format!(\n                     \"zst    {:?}: {:?} size={} align={}, {}\",\n-                    local, ty, size.bytes(), align.abi.bytes(), align.pref.bytes(),\n+                    local,\n+                    ty,\n+                    size.bytes(),\n+                    align.abi.bytes(),\n+                    align.pref.bytes(),\n                 )),\n                 _ => unreachable!(),\n             }\n@@ -383,7 +412,16 @@ fn cvalue_for_param<'a, 'tcx: 'a>(\n     let ebb_param = fx.bcx.append_ebb_param(start_ebb, clif_type);\n \n     #[cfg(debug_assertions)]\n-    add_arg_comment(fx, \"arg\", local, local_field, Some(ebb_param), pass_mode, ssa_flags, arg_ty);\n+    add_arg_comment(\n+        fx,\n+        \"arg\",\n+        local,\n+        local_field,\n+        Some(ebb_param),\n+        pass_mode,\n+        ssa_flags,\n+        arg_ty,\n+    );\n \n     match pass_mode {\n         PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n@@ -412,7 +450,16 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n     #[cfg(debug_assertions)]\n     {\n         add_local_header_comment(fx);\n-        add_arg_comment(fx, \"ret\", RETURN_PLACE, None, ret_param, output_pass_mode, ssa_analyzed[&RETURN_PLACE], ret_layout.ty);\n+        add_arg_comment(\n+            fx,\n+            \"ret\",\n+            RETURN_PLACE,\n+            None,\n+            ret_param,\n+            output_pass_mode,\n+            ssa_analyzed[&RETURN_PLACE],\n+            ret_layout.ty,\n+        );\n     }\n \n     enum ArgKind<'tcx> {\n@@ -440,18 +487,22 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n \n                 let mut params = Vec::new();\n                 for (i, arg_ty) in tupled_arg_tys.iter().enumerate() {\n-                    let param = cvalue_for_param(fx, start_ebb, local, Some(i), arg_ty, ssa_analyzed[&local]);\n+                    let param = cvalue_for_param(\n+                        fx,\n+                        start_ebb,\n+                        local,\n+                        Some(i),\n+                        arg_ty,\n+                        ssa_analyzed[&local],\n+                    );\n                     params.push(param);\n                 }\n \n                 (local, ArgKind::Spread(params), arg_ty)\n             } else {\n-                let param = cvalue_for_param(fx, start_ebb, local, None, arg_ty, ssa_analyzed[&local]);\n-                (\n-                    local,\n-                    ArgKind::Normal(param),\n-                    arg_ty,\n-                )\n+                let param =\n+                    cvalue_for_param(fx, start_ebb, local, None, arg_ty, ssa_analyzed[&local]);\n+                (local, ArgKind::Normal(param), arg_ty)\n             }\n         })\n         .collect::<Vec<(Local, ArgKind, Ty)>>();\n@@ -460,7 +511,8 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n \n     match output_pass_mode {\n         PassMode::NoPass => {\n-            fx.local_map.insert(RETURN_PLACE, CPlace::NoPlace(ret_layout));\n+            fx.local_map\n+                .insert(RETURN_PLACE, CPlace::NoPlace(ret_layout));\n         }\n         PassMode::ByVal(_) => {\n             let is_ssa = !ssa_analyzed\n@@ -494,7 +546,9 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n             }\n             ArgKind::Spread(params) => {\n                 for (i, param) in params.into_iter().enumerate() {\n-                    place.place_field(fx, mir::Field::new(i)).write_cvalue(fx, param);\n+                    place\n+                        .place_field(fx, mir::Field::new(i))\n+                        .write_cvalue(fx, param);\n                 }\n             }\n         }\n@@ -553,12 +607,8 @@ pub fn codegen_terminator_call<'a, 'tcx: 'a>(\n         .map(|&(ref place, bb)| (trans_place(fx, place), bb));\n \n     if let ty::FnDef(def_id, substs) = fn_ty.sty {\n-        let instance = ty::Instance::resolve(\n-            fx.tcx,\n-            ty::ParamEnv::reveal_all(),\n-            def_id,\n-            substs,\n-        ).unwrap();\n+        let instance =\n+            ty::Instance::resolve(fx.tcx, ty::ParamEnv::reveal_all(), def_id, substs).unwrap();\n \n         match instance.def {\n             InstanceDef::Intrinsic(_) => {\n@@ -637,8 +687,12 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n \n         // Indirect call\n         None => {\n-            let func = trans_operand(fx, func.expect(\"indirect call without func Operand\")).load_scalar(fx);\n-            (Some(func), args.get(0).map(|arg| adjust_arg_for_abi(fx, *arg)))\n+            let func = trans_operand(fx, func.expect(\"indirect call without func Operand\"))\n+                .load_scalar(fx);\n+            (\n+                Some(func),\n+                args.get(0).map(|arg| adjust_arg_for_abi(fx, *arg)),\n+            )\n         }\n     };\n \n@@ -653,7 +707,9 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n         .collect::<Vec<_>>();\n \n     let call_inst = if let Some(func_ref) = func_ref {\n-        let sig = fx.bcx.import_signature(clif_sig_from_fn_sig(fx.tcx, fn_sig));\n+        let sig = fx\n+            .bcx\n+            .import_signature(clif_sig_from_fn_sig(fx.tcx, fn_sig));\n         fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n     } else {\n         let func_ref = fx.get_function_ref(instance.expect(\"non-indirect call on non-FnDef type\"));\n@@ -666,14 +722,17 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n             unimpl!(\"Variadic call for non-C abi {:?}\", fn_sig.abi);\n         }\n         let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n-        let abi_params = call_args.into_iter().map(|arg| {\n-            let ty = fx.bcx.func.dfg.value_type(arg);\n-            if !ty.is_int() {\n-                // FIXME set %al to upperbound on float args once floats are supported\n-                unimpl!(\"Non int ty {:?} for variadic call\", ty);\n-            }\n-            AbiParam::new(ty)\n-        }).collect::<Vec<AbiParam>>();\n+        let abi_params = call_args\n+            .into_iter()\n+            .map(|arg| {\n+                let ty = fx.bcx.func.dfg.value_type(arg);\n+                if !ty.is_int() {\n+                    // FIXME set %al to upperbound on float args once floats are supported\n+                    unimpl!(\"Non int ty {:?} for variadic call\", ty);\n+                }\n+                AbiParam::new(ty)\n+            })\n+            .collect::<Vec<AbiParam>>();\n         fx.bcx.func.dfg.signatures[sig_ref].params = abi_params;\n     }\n \n@@ -700,11 +759,13 @@ pub fn codegen_drop<'a, 'tcx: 'a>(\n     let fn_sig = ty_fn_sig(fx.tcx, drop_fn_ty);\n \n     match get_pass_mode(fx.tcx, fn_sig.output(), true) {\n-        PassMode::NoPass => {},\n+        PassMode::NoPass => {}\n         _ => unreachable!(),\n     };\n \n-    let sig = fx.bcx.import_signature(clif_sig_from_fn_sig(fx.tcx, fn_sig));\n+    let sig = fx\n+        .bcx\n+        .import_signature(clif_sig_from_fn_sig(fx.tcx, fn_sig));\n     fx.bcx.ins().call_indirect(sig, drop_fn, &[ptr]);\n }\n "}, {"sha": "cfc071612e71f7555be6aafd2d12f846c01b908e", "filename": "src/allocator.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fallocator.rs?ref=f02490d960ecff8fc17272453f4eb8a6837b5a18", "patch": "@@ -15,14 +15,10 @@ use rustc_allocator::{AllocatorTy, ALLOCATOR_METHODS};\n \n /// Returns whether an allocator shim was created\n pub fn codegen(sess: &Session, module: &mut Module<impl Backend + 'static>) -> bool {\n-    let any_dynamic_crate = sess\n-        .dependency_formats\n-        .borrow()\n-        .iter()\n-        .any(|(_, list)| {\n-            use rustc::middle::dependency_format::Linkage;\n-            list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n-        });\n+    let any_dynamic_crate = sess.dependency_formats.borrow().iter().any(|(_, list)| {\n+        use rustc::middle::dependency_format::Linkage;\n+        list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n+    });\n     if any_dynamic_crate {\n         false\n     } else if let Some(kind) = *sess.allocator_kind.get() {"}, {"sha": "62b0bf1ac0434523ffef96ff510ba14be7fe06ee", "filename": "src/base.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=f02490d960ecff8fc17272453f4eb8a6837b5a18", "patch": "@@ -66,16 +66,11 @@ fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n \n     // Step 2. Declare function\n     let (name, sig) = get_function_name_and_sig(tcx, instance, false);\n-    let func_id = cx.module\n-        .declare_function(&name, linkage, &sig)\n-        .unwrap();\n-    let mut debug_context = cx.debug_context.as_mut().map(|debug_context| FunctionDebugContext::new(\n-        tcx,\n-        debug_context,\n-        mir,\n-        &name,\n-        &sig,\n-    ));\n+    let func_id = cx.module.declare_function(&name, linkage, &sig).unwrap();\n+    let mut debug_context = cx\n+        .debug_context\n+        .as_mut()\n+        .map(|debug_context| FunctionDebugContext::new(tcx, debug_context, mir, &name, &sig));\n \n     // Step 3. Make FunctionBuilder\n     let mut func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n@@ -127,12 +122,16 @@ fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n \n     // Step 9. Define function\n     cx.caches.context.func = func;\n-    cx.module.define_function(func_id, &mut cx.caches.context).unwrap();\n+    cx.module\n+        .define_function(func_id, &mut cx.caches.context)\n+        .unwrap();\n \n     // Step 10. Define debuginfo for function\n     let context = &cx.caches.context;\n     let isa = cx.module.isa();\n-    debug_context.as_mut().map(|x| x.define(tcx, context, isa, &source_info_set));\n+    debug_context\n+        .as_mut()\n+        .map(|x| x.define(tcx, context, isa, &source_info_set));\n \n     // Step 11. Clear context to make it usable for the next function\n     cx.caches.context.clear();\n@@ -444,10 +443,14 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                 }\n                 Rvalue::Cast(CastKind::ReifyFnPointer, operand, ty) => {\n                     let layout = fx.layout_of(ty);\n-                    match fx.monomorphize(&operand.ty(&fx.mir.local_decls, fx.tcx)).sty {\n+                    match fx\n+                        .monomorphize(&operand.ty(&fx.mir.local_decls, fx.tcx))\n+                        .sty\n+                    {\n                         ty::FnDef(def_id, substs) => {\n                             let func_ref = fx.get_function_ref(\n-                                Instance::resolve(fx.tcx, ParamEnv::reveal_all(), def_id, substs).unwrap(),\n+                                Instance::resolve(fx.tcx, ParamEnv::reveal_all(), def_id, substs)\n+                                    .unwrap(),\n                             );\n                             let func_addr = fx.bcx.ins().func_addr(fx.pointer_type, func_ref);\n                             lval.write_cvalue(fx, CValue::ByVal(func_addr, layout));\n@@ -570,9 +573,13 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                             };\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n                         }\n-                        (ty::Adt(adt_def, _substs), ty::Uint(_)) | (ty::Adt(adt_def, _substs), ty::Int(_)) if adt_def.is_enum() => {\n+                        (ty::Adt(adt_def, _substs), ty::Uint(_))\n+                        | (ty::Adt(adt_def, _substs), ty::Int(_))\n+                            if adt_def.is_enum() =>\n+                        {\n                             // FIXME avoid forcing to stack\n-                            let place = CPlace::Addr(operand.force_stack(fx), None, operand.layout());\n+                            let place =\n+                                CPlace::Addr(operand.force_stack(fx), None, operand.layout());\n                             let discr = trans_get_discriminant(fx, place, fx.layout_of(to_ty));\n                             lval.write_cvalue(fx, discr);\n                         }\n@@ -674,9 +681,10 @@ fn codegen_array_len<'a, 'tcx: 'a>(\n             let len = crate::constant::force_eval_const(fx, len).unwrap_usize(fx.tcx) as i64;\n             fx.bcx.ins().iconst(fx.pointer_type, len)\n         }\n-        ty::Slice(_elem_ty) => {\n-            place.to_addr_maybe_unsized(fx).1.expect(\"Length metadata for slice place\")\n-        }\n+        ty::Slice(_elem_ty) => place\n+            .to_addr_maybe_unsized(fx)\n+            .1\n+            .expect(\"Length metadata for slice place\"),\n         _ => bug!(\"Rvalue::Len({:?})\", place),\n     }\n }\n@@ -1012,7 +1020,9 @@ fn trans_ptr_binop<'a, 'tcx: 'a>(\n     ret_ty: Ty<'tcx>,\n ) -> CValue<'tcx> {\n     let not_fat = match lhs.layout().ty.sty {\n-        ty::RawPtr(TypeAndMut { ty, mutbl: _ }) => ty.is_sized(fx.tcx.at(DUMMY_SP), ParamEnv::reveal_all()),\n+        ty::RawPtr(TypeAndMut { ty, mutbl: _ }) => {\n+            ty.is_sized(fx.tcx.at(DUMMY_SP), ParamEnv::reveal_all())\n+        }\n         ty::FnPtr(..) => true,\n         _ => bug!(\"trans_ptr_binop on non ptr\"),\n     };"}, {"sha": "1faa6a8514c941a87fba848ca96897a6910d37e6", "filename": "src/common.rs", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=f02490d960ecff8fc17272453f4eb8a6837b5a18", "patch": "@@ -246,7 +246,7 @@ pub enum CPlace<'tcx> {\n     Var(Local, TyLayout<'tcx>),\n     Addr(Value, Option<Value>, TyLayout<'tcx>),\n     Stack(StackSlot, TyLayout<'tcx>),\n-    NoPlace(TyLayout<'tcx>)\n+    NoPlace(TyLayout<'tcx>),\n }\n \n impl<'a, 'tcx: 'a> CPlace<'tcx> {\n@@ -255,11 +255,14 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n             CPlace::Var(_, layout)\n             | CPlace::Addr(_, _, layout)\n             | CPlace::Stack(_, layout)\n-            | CPlace::NoPlace(layout)  => layout,\n+            | CPlace::NoPlace(layout) => layout,\n         }\n     }\n \n-    pub fn new_stack_slot(fx: &mut FunctionCx<'a, 'tcx, impl Backend>, ty: Ty<'tcx>) -> CPlace<'tcx> {\n+    pub fn new_stack_slot(\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+        ty: Ty<'tcx>,\n+    ) -> CPlace<'tcx> {\n         let layout = fx.layout_of(ty);\n         assert!(!layout.is_unsized());\n         if layout.size.bytes() == 0 {\n@@ -281,12 +284,16 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n                 assert!(extra.is_none(), \"unsized values are not yet supported\");\n                 CValue::ByRef(addr, layout)\n             }\n-            CPlace::Stack(stack_slot, layout) => {\n-                CValue::ByRef(fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0), layout)\n-            }\n-            CPlace::NoPlace(layout) => {\n-                CValue::ByRef(fx.bcx.ins().iconst(fx.pointer_type, fx.pointer_type.bytes() as i64), layout)\n-            }\n+            CPlace::Stack(stack_slot, layout) => CValue::ByRef(\n+                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n+                layout,\n+            ),\n+            CPlace::NoPlace(layout) => CValue::ByRef(\n+                fx.bcx\n+                    .ins()\n+                    .iconst(fx.pointer_type, fx.pointer_type.bytes() as i64),\n+                layout,\n+            ),\n         }\n     }\n \n@@ -303,9 +310,10 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n     ) -> (Value, Option<Value>) {\n         match self {\n             CPlace::Addr(addr, extra, _layout) => (addr, extra),\n-            CPlace::Stack(stack_slot, _layout) => {\n-                (fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0), None)\n-            }\n+            CPlace::Stack(stack_slot, _layout) => (\n+                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n+                None,\n+            ),\n             CPlace::NoPlace(_) => (fx.bcx.ins().iconst(fx.pointer_type, 45), None),\n             CPlace::Var(_, _) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n         }\n@@ -364,9 +372,10 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n                 return;\n             }\n             CPlace::Addr(addr, None, dst_layout) => (addr, dst_layout),\n-            CPlace::Stack(stack_slot, dst_layout) => {\n-                (fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0), dst_layout)\n-            }\n+            CPlace::Stack(stack_slot, dst_layout) => (\n+                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n+                dst_layout,\n+            ),\n             CPlace::NoPlace(layout) => {\n                 assert!(layout.size.bytes() == 0);\n                 assert!(from.layout().size.bytes() == 0);\n@@ -389,7 +398,14 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n                 let size = dst_layout.size.bytes();\n                 let src_align = src_layout.align.abi.bytes() as u8;\n                 let dst_align = dst_layout.align.abi.bytes() as u8;\n-                fx.bcx.emit_small_memcpy(fx.module.target_config(), addr, from, size, dst_align, src_align);\n+                fx.bcx.emit_small_memcpy(\n+                    fx.module.target_config(),\n+                    addr,\n+                    from,\n+                    size,\n+                    dst_align,\n+                    src_align,\n+                );\n             }\n         }\n     }\n@@ -419,10 +435,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n     ) -> CPlace<'tcx> {\n         let (elem_layout, addr) = match self.layout().ty.sty {\n             ty::Array(elem_ty, _) => (fx.layout_of(elem_ty), self.to_addr(fx)),\n-            ty::Slice(elem_ty) => (\n-                fx.layout_of(elem_ty),\n-                self.to_addr_maybe_unsized(fx).0,\n-            ),\n+            ty::Slice(elem_ty) => (fx.layout_of(elem_ty), self.to_addr_maybe_unsized(fx).0),\n             _ => bug!(\"place_index({:?})\", self.layout().ty),\n         };\n \n@@ -472,9 +485,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n             match dest.layout().abi {\n                 Abi::ScalarPair(ref a, _) => {\n                     let dest_addr = dest.to_addr(fx);\n-                    fx.bcx\n-                        .ins()\n-                        .store(MemFlags::new(), value, dest_addr, 0);\n+                    fx.bcx.ins().store(MemFlags::new(), value, dest_addr, 0);\n                     fx.bcx.ins().store(\n                         MemFlags::new(),\n                         extra.expect(\"unsized type without metadata\"),\n@@ -494,12 +505,8 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n         assert!(!self.layout().is_unsized());\n         match self {\n             CPlace::Var(var, _) => CPlace::Var(var, layout),\n-            CPlace::Addr(addr, extra, _) => {\n-                CPlace::Addr(addr, extra, layout)\n-            }\n-            CPlace::Stack(stack_slot, _) => {\n-                CPlace::Stack(stack_slot, layout)\n-            }\n+            CPlace::Addr(addr, extra, _) => CPlace::Addr(addr, extra, layout),\n+            CPlace::Stack(stack_slot, _) => CPlace::Stack(stack_slot, layout),\n             CPlace::NoPlace(_) => {\n                 assert!(layout.size.bytes() == 0);\n                 CPlace::NoPlace(layout)"}, {"sha": "0216eb80a53f7e10a86baaafaec22467ad700ae0", "filename": "src/constant.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=f02490d960ecff8fc17272453f4eb8a6837b5a18", "patch": "@@ -5,7 +5,8 @@ use rustc::mir::interpret::{\n };\n use rustc::ty::{Const, LazyConst};\n use rustc_mir::interpret::{\n-    EvalContext, MPlaceTy, Machine, Memory, MemoryKind, OpTy, PlaceTy, Pointer, StackPopCleanup, ImmTy,\n+    EvalContext, ImmTy, MPlaceTy, Machine, Memory, MemoryKind, OpTy, PlaceTy, Pointer,\n+    StackPopCleanup,\n };\n \n use cranelift_module::*;\n@@ -110,12 +111,12 @@ fn trans_const_value<'a, 'tcx: 'a>(\n             let bits = const_.val.try_to_bits(layout.size).unwrap();\n             CValue::const_val(fx, ty, bits as i128 as i64)\n         }\n-        ty::FnDef(_def_id, _substs) => {\n-            CValue::ByRef(\n-                fx.bcx.ins().iconst(fx.pointer_type, fx.pointer_type.bytes() as i64),\n-                layout\n-            )\n-        }\n+        ty::FnDef(_def_id, _substs) => CValue::ByRef(\n+            fx.bcx\n+                .ins()\n+                .iconst(fx.pointer_type, fx.pointer_type.bytes() as i64),\n+            layout,\n+        ),\n         _ => trans_const_place(fx, const_).to_cvalue(fx),\n     }\n }\n@@ -370,7 +371,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for TransPlaceInterpreter {\n         ptr\n     }\n \n-    fn stack_push(_: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>{\n+    fn stack_push(_: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx> {\n         Ok(())\n     }\n "}, {"sha": "35b8369d8a5c9e807a362a9e9f49815a224ba1ce", "filename": "src/debuginfo.rs", "status": "modified", "additions": 47, "deletions": 36, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo.rs?ref=f02490d960ecff8fc17272453f4eb8a6837b5a18", "patch": "@@ -5,11 +5,10 @@ use std::marker::PhantomData;\n use syntax::source_map::FileName;\n \n use gimli::write::{\n-    Address, AttributeValue, DwarfUnit, EndianVec, LineProgram, Range,\n-    RangeList, Result, SectionId, UnitEntryId,\n-    Writer, FileId, LineStringTable, LineString, Sections,\n+    Address, AttributeValue, DwarfUnit, EndianVec, FileId, LineProgram, LineString,\n+    LineStringTable, Range, RangeList, Result, SectionId, Sections, UnitEntryId, Writer,\n };\n-use gimli::{Encoding, Format, RunTimeEndian, LineEncoding};\n+use gimli::{Encoding, Format, LineEncoding, RunTimeEndian};\n \n use faerie::*;\n \n@@ -22,28 +21,35 @@ fn target_endian(tcx: TyCtxt) -> RunTimeEndian {\n     }\n }\n \n-fn line_program_add_file(line_program: &mut LineProgram, line_strings: &mut LineStringTable, file: &FileName) -> FileId {\n+fn line_program_add_file(\n+    line_program: &mut LineProgram,\n+    line_strings: &mut LineStringTable,\n+    file: &FileName,\n+) -> FileId {\n     match file {\n         FileName::Real(path) => {\n-            let dir_name = LineString::new(path.parent().unwrap().to_str().unwrap().as_bytes(), line_program.encoding(), line_strings);\n-            let dir_id =\n-                line_program.add_directory(dir_name);\n-            let file_name = LineString::new(path.file_name().unwrap().to_str().unwrap().as_bytes(), line_program.encoding(), line_strings);\n-            line_program.add_file(\n-                file_name,\n-                dir_id,\n-                None,\n-            )\n+            let dir_name = LineString::new(\n+                path.parent().unwrap().to_str().unwrap().as_bytes(),\n+                line_program.encoding(),\n+                line_strings,\n+            );\n+            let dir_id = line_program.add_directory(dir_name);\n+            let file_name = LineString::new(\n+                path.file_name().unwrap().to_str().unwrap().as_bytes(),\n+                line_program.encoding(),\n+                line_strings,\n+            );\n+            line_program.add_file(file_name, dir_id, None)\n         }\n         // FIXME give more appropriate file names\n         _ => {\n             let dir_id = line_program.default_directory();\n-            let dummy_file_name = LineString::new(file.to_string().into_bytes(), line_program.encoding(), line_strings);\n-            line_program.add_file(\n-                dummy_file_name,\n-                dir_id,\n-                None,\n-            )\n+            let dummy_file_name = LineString::new(\n+                file.to_string().into_bytes(),\n+                line_program.encoding(),\n+                line_strings,\n+            );\n+            line_program.add_file(dummy_file_name, dir_id, None)\n         }\n     }\n }\n@@ -133,7 +139,7 @@ impl<'a, 'tcx: 'a> DebugContext<'tcx> {\n             );\n         }\n \n-         DebugContext {\n+        DebugContext {\n             endian: target_endian(tcx),\n             symbols: indexmap::IndexSet::new(),\n \n@@ -155,7 +161,10 @@ impl<'a, 'tcx: 'a> DebugContext<'tcx> {\n \n         let entry = self.dwarf.unit.get_mut(entry_id);\n \n-        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n+        entry.set(\n+            gimli::DW_AT_decl_file,\n+            AttributeValue::FileIndex(Some(file_id)),\n+        );\n         entry.set(\n             gimli::DW_AT_decl_line,\n             AttributeValue::Udata(loc.line as u64),\n@@ -182,11 +191,7 @@ impl<'a, 'tcx: 'a> DebugContext<'tcx> {\n         let _: Result<()> = sections.for_each_mut(|id, section| {\n             if !section.writer.slice().is_empty() {\n                 artifact\n-                    .declare_with(\n-                        id.name(),\n-                        Decl::DebugSection,\n-                        section.writer.take(),\n-                    )\n+                    .declare_with(id.name(), Decl::DebugSection, section.writer.take())\n                     .unwrap();\n             }\n             Ok(())\n@@ -233,7 +238,10 @@ impl<'a, 'b, 'tcx: 'b> FunctionDebugContext<'a, 'tcx> {\n         // FIXME: add to appropriate scope intead of root\n         let scope = debug_context.dwarf.unit.root();\n \n-        let entry_id = debug_context.dwarf.unit.add(scope, gimli::DW_TAG_subprogram);\n+        let entry_id = debug_context\n+            .dwarf\n+            .unit\n+            .add(scope, gimli::DW_TAG_subprogram);\n         let entry = debug_context.dwarf.unit.get_mut(entry_id);\n         let name_id = debug_context.dwarf.strings.add(name);\n         entry.set(\n@@ -314,13 +322,16 @@ impl<'a, 'b, 'tcx: 'b> FunctionDebugContext<'a, 'tcx> {\n         let entry = self.debug_context.dwarf.unit.get_mut(self.entry_id);\n         entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(end as u64));\n \n-        self.debug_context.unit_range_list.0.push(Range::StartLength {\n-            begin: Address::Relative {\n-                symbol: self.symbol,\n-                addend: 0,\n-            },\n-            length: end as u64,\n-        });\n+        self.debug_context\n+            .unit_range_list\n+            .0\n+            .push(Range::StartLength {\n+                begin: Address::Relative {\n+                    symbol: self.symbol,\n+                    addend: 0,\n+                },\n+                length: end as u64,\n+            });\n     }\n }\n \n@@ -331,7 +342,7 @@ struct WriterRelocate {\n }\n \n impl WriterRelocate {\n-    fn new(ctx: & DebugContext) -> Self {\n+    fn new(ctx: &DebugContext) -> Self {\n         WriterRelocate {\n             relocs: Vec::new(),\n             writer: EndianVec::new(ctx.endian),"}, {"sha": "483bcb51c646fa668797efeacc90a0e968623475", "filename": "src/lib.rs", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f02490d960ecff8fc17272453f4eb8a6837b5a18", "patch": "@@ -14,19 +14,19 @@ extern crate rustc_target;\n extern crate syntax;\n \n use std::any::Any;\n+use std::ffi::CString;\n use std::fs::File;\n-use std::sync::mpsc;\n use std::os::raw::{c_char, c_int};\n-use std::ffi::CString;\n+use std::sync::mpsc;\n \n use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::MetadataLoader;\n+use rustc::mir::mono::{Linkage as RLinkage, Visibility};\n use rustc::session::{\n     config::{DebugInfo, OutputFilenames, OutputType},\n     CompileIncomplete,\n };\n use rustc::ty::query::Providers;\n-use rustc::mir::mono::{Linkage as RLinkage, Visibility};\n use rustc_codegen_ssa::back::linker::LinkerInfo;\n use rustc_codegen_ssa::CrateInfo;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -62,7 +62,7 @@ mod prelude {\n     pub use std::collections::{HashMap, HashSet};\n \n     pub use syntax::ast::{FloatTy, IntTy, UintTy};\n-    pub use syntax::source_map::{DUMMY_SP, Span, Pos};\n+    pub use syntax::source_map::{Pos, Span, DUMMY_SP};\n \n     pub use rustc::bug;\n     pub use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n@@ -84,18 +84,17 @@ mod prelude {\n     pub use rustc_mir::monomorphize::{collector, MonoItem};\n \n     pub use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n-    pub use rustc_codegen_ssa::{CodegenResults, CompiledModule, ModuleKind};\n     pub use rustc_codegen_ssa::traits::*;\n+    pub use rustc_codegen_ssa::{CodegenResults, CompiledModule, ModuleKind};\n \n     pub use cranelift::codegen::ir::{\n-        condcodes::IntCC, function::Function, ExternalName, FuncRef, Inst, StackSlot, SourceLoc,\n+        condcodes::IntCC, function::Function, ExternalName, FuncRef, Inst, SourceLoc, StackSlot,\n     };\n     pub use cranelift::codegen::isa::CallConv;\n     pub use cranelift::codegen::Context;\n     pub use cranelift::prelude::*;\n     pub use cranelift_module::{\n-        self, Backend, DataContext, DataId, FuncId, FuncOrDataId, Linkage,\n-        Module,\n+        self, Backend, DataContext, DataId, FuncId, FuncOrDataId, Linkage, Module,\n     };\n     pub use cranelift_simplejit::{SimpleJITBackend, SimpleJITBuilder};\n \n@@ -251,11 +250,12 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n                 unsafe { ::std::mem::transmute(finalized_main) };\n \n-            let args = ::std::env::var(\"JIT_ARGS\").unwrap_or_else(|_|String::new());\n+            let args = ::std::env::var(\"JIT_ARGS\").unwrap_or_else(|_| String::new());\n             let args = args\n                 .split(\" \")\n                 .chain(Some(&*tcx.crate_name(LOCAL_CRATE).as_str().to_string()))\n-                .map(|arg| CString::new(arg).unwrap()).collect::<Vec<_>>();\n+                .map(|arg| CString::new(arg).unwrap())\n+                .collect::<Vec<_>>();\n             let argv = args.iter().map(|arg| arg.as_ptr()).collect::<Vec<_>>();\n             // TODO: Rust doesn't care, but POSIX argv has a NULL sentinel at the end\n \n@@ -274,14 +274,14 @@ impl CodegenBackend for CraneliftCodegenBackend {\n                     )\n                     .unwrap(),\n                 );\n-                assert_eq!(\n-                    pointer_ty(tcx),\n-                    module.target_config().pointer_type()\n-                );\n+                assert_eq!(pointer_ty(tcx), module.target_config().pointer_type());\n                 module\n             };\n \n-            let emit_module = |name: &str, kind: ModuleKind, mut module: Module<FaerieBackend>, debug: Option<DebugContext>| {\n+            let emit_module = |name: &str,\n+                               kind: ModuleKind,\n+                               mut module: Module<FaerieBackend>,\n+                               debug: Option<DebugContext>| {\n                 module.finalize_definitions();\n                 let mut artifact = module.finish().artifact;\n \n@@ -306,9 +306,13 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             let mut faerie_module = new_module(\"some_file\".to_string());\n \n             let mut debug = if tcx.sess.opts.debuginfo != DebugInfo::None\n-                && !tcx.sess.target.target.options.is_like_osx // macOS debuginfo doesn't work yet (see #303)\n+                // macOS debuginfo doesn't work yet (see #303)\n+                && !tcx.sess.target.target.options.is_like_osx\n             {\n-                let debug = DebugContext::new(tcx, faerie_module.target_config().pointer_type().bytes() as u8);\n+                let debug = DebugContext::new(\n+                    tcx,\n+                    faerie_module.target_config().pointer_type().bytes() as u8,\n+                );\n                 Some(debug)\n             } else {\n                 None\n@@ -319,14 +323,23 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             tcx.sess.abort_if_errors();\n \n             let mut allocator_module = new_module(\"allocator_shim.o\".to_string());\n-            let created_alloc_shim =\n-                crate::allocator::codegen(tcx.sess, &mut allocator_module);\n+            let created_alloc_shim = crate::allocator::codegen(tcx.sess, &mut allocator_module);\n \n             return Box::new(CodegenResults {\n                 crate_name: tcx.crate_name(LOCAL_CRATE),\n-                modules: vec![emit_module(\"dummy_name\", ModuleKind::Regular, faerie_module, debug)],\n+                modules: vec![emit_module(\n+                    \"dummy_name\",\n+                    ModuleKind::Regular,\n+                    faerie_module,\n+                    debug,\n+                )],\n                 allocator_module: if created_alloc_shim {\n-                    Some(emit_module(\"allocator_shim\", ModuleKind::Allocator, allocator_module, None))\n+                    Some(emit_module(\n+                        \"allocator_shim\",\n+                        ModuleKind::Allocator,\n+                        allocator_module,\n+                        None,\n+                    ))\n                 } else {\n                     None\n                 },\n@@ -377,7 +390,7 @@ fn build_isa(sess: &Session) -> Box<isa::TargetIsa + 'static> {\n     let mut flags_builder = settings::builder();\n     flags_builder.enable(\"is_pic\").unwrap();\n     flags_builder.set(\"probestack_enabled\", \"false\").unwrap(); // ___cranelift_probestack is not provided\n-    flags_builder.set(\"enable_verifier\", if cfg!(debug_assertions) {\n+        flags_builder.set(\"enable_verifier\", if cfg!(debug_assertions) {\n         \"true\"\n     } else {\n         \"false\"\n@@ -438,7 +451,7 @@ fn codegen_mono_items<'a, 'tcx: 'a>(\n                     (RLinkage::Internal, Visibility::Default) => Linkage::Local,\n                     // FIXME this should get external linkage, but hidden visibility,\n                     // not internal linkage and default visibility\n-                    | (RLinkage::External, Visibility::Hidden) => Linkage::Export,\n+                    (RLinkage::External, Visibility::Hidden) => Linkage::Export,\n                     _ => panic!(\"{:?} = {:?} {:?}\", mono_item, linkage, vis),\n                 };\n                 base::trans_mono_item(&mut cx, mono_item, linkage);"}, {"sha": "aab6e341a09a423f565408554bf2c4f71b9d2654", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=f02490d960ecff8fc17272453f4eb8a6837b5a18", "patch": "@@ -70,10 +70,7 @@ pub struct CommentWriter {\n }\n \n impl CommentWriter {\n-    pub fn new<'a, 'tcx: 'a>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        instance: Instance<'tcx>,\n-    ) -> Self {\n+    pub fn new<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> Self {\n         CommentWriter {\n             global_comments: vec![\n                 format!(\"symbol {}\", tcx.symbol_name(instance).as_str()),\n@@ -158,7 +155,11 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n         self.clif_comments.global_comments.push(comment.into());\n     }\n \n-    pub fn add_entity_comment<'s, S: Into<Cow<'s, str>>, E: Into<AnyEntity>>(&mut self, entity: E, comment: S) {\n+    pub fn add_entity_comment<'s, S: Into<Cow<'s, str>>, E: Into<AnyEntity>>(\n+        &mut self,\n+        entity: E,\n+        comment: S,\n+    ) {\n         use std::collections::hash_map::Entry;\n         match self.clif_comments.entity_comments.entry(entity.into()) {\n             Entry::Occupied(mut occ) => {\n@@ -196,20 +197,28 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n         );\n \n         let mut clif = String::new();\n-        ::cranelift::codegen::write::decorate_function(&mut &self.clif_comments, &mut clif, &self.bcx.func, None)\n-            .unwrap();\n+        ::cranelift::codegen::write::decorate_function(\n+            &mut &self.clif_comments,\n+            &mut clif,\n+            &self.bcx.func,\n+            None,\n+        )\n+        .unwrap();\n \n         match ::std::fs::File::create(clif_file_name) {\n             Ok(mut file) => {\n-                let target_triple: ::target_lexicon::Triple = self.tcx.sess.target.target.llvm_target.parse().unwrap();\n+                let target_triple: ::target_lexicon::Triple =\n+                    self.tcx.sess.target.target.llvm_target.parse().unwrap();\n                 writeln!(file, \"test compile\").unwrap();\n                 writeln!(file, \"set is_pic\").unwrap();\n                 writeln!(file, \"target {}\", target_triple).unwrap();\n                 writeln!(file, \"\").unwrap();\n                 file.write(clif.as_bytes()).unwrap();\n             }\n             Err(e) => {\n-                self.tcx.sess.warn(&format!(\"err opening clif file: {:?}\", e));\n+                self.tcx\n+                    .sess\n+                    .warn(&format!(\"err opening clif file: {:?}\", e));\n             }\n         }\n     }"}, {"sha": "09dead7e85e84bd006f3547932ec7446c710fd07", "filename": "src/unsize.rs", "status": "modified", "additions": 46, "deletions": 33, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02490d960ecff8fc17272453f4eb8a6837b5a18/src%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsize.rs?ref=f02490d960ecff8fc17272453f4eb8a6837b5a18", "patch": "@@ -16,21 +16,22 @@ pub fn unsized_info<'a, 'tcx: 'a>(\n ) -> Value {\n     let (source, target) = fx.tcx.struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n-        (&ty::Array(_, len), &ty::Slice(_)) => {\n-            fx.bcx.ins().iconst(fx.pointer_type, len.unwrap_usize(fx.tcx) as i64)\n-        }\n+        (&ty::Array(_, len), &ty::Slice(_)) => fx\n+            .bcx\n+            .ins()\n+            .iconst(fx.pointer_type, len.unwrap_usize(fx.tcx) as i64),\n         (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n             // traits, and hence never actually require an actual\n             // change to the vtable.\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n-        (_, &ty::Dynamic(ref data, ..)) => {\n-            crate::vtable::get_vtable(fx, source, data.principal())\n-        }\n-        _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n-                  source,\n-                  target),\n+        (_, &ty::Dynamic(ref data, ..)) => crate::vtable::get_vtable(fx, source, data.principal()),\n+        _ => bug!(\n+            \"unsized_info: invalid unsizing {:?} -> {:?}\",\n+            source,\n+            target\n+        ),\n     }\n }\n \n@@ -39,15 +40,12 @@ pub fn unsize_thin_ptr<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     src: Value,\n     src_ty: Ty<'tcx>,\n-    dst_ty: Ty<'tcx>\n+    dst_ty: Ty<'tcx>,\n ) -> (Value, Value) {\n     match (&src_ty.sty, &dst_ty.sty) {\n-        (&ty::Ref(_, a, _),\n-         &ty::Ref(_, b, _)) |\n-        (&ty::Ref(_, a, _),\n-         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) |\n-        (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n-         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n+        (&ty::Ref(_, a, _), &ty::Ref(_, b, _))\n+        | (&ty::Ref(_, a, _), &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n+        | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(!fx.layout_of(a).is_unsized());\n             (src, unsized_info(fx, a, b, None))\n         }\n@@ -88,11 +86,14 @@ pub fn coerce_unsized_into<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     src: CValue<'tcx>,\n     dst: CPlace<'tcx>,\n-)  {\n+) {\n     let src_ty = src.layout().ty;\n     let dst_ty = dst.layout().ty;\n     let mut coerce_ptr = || {\n-        let (base, info) = if fx.layout_of(src.layout().ty.builtin_deref(true).unwrap().ty).is_unsized() {\n+        let (base, info) = if fx\n+            .layout_of(src.layout().ty.builtin_deref(true).unwrap().ty)\n+            .is_unsized()\n+        {\n             // fat-ptr to fat-ptr unsize preserves the vtable\n             // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n             src.load_value_pair(fx)\n@@ -103,11 +104,9 @@ pub fn coerce_unsized_into<'a, 'tcx: 'a>(\n         dst.write_cvalue(fx, CValue::ByValPair(base, info, dst.layout()));\n     };\n     match (&src_ty.sty, &dst_ty.sty) {\n-        (&ty::Ref(..), &ty::Ref(..)) |\n-        (&ty::Ref(..), &ty::RawPtr(..)) |\n-        (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n-            coerce_ptr()\n-        }\n+        (&ty::Ref(..), &ty::Ref(..))\n+        | (&ty::Ref(..), &ty::RawPtr(..))\n+        | (&ty::RawPtr(..), &ty::RawPtr(..)) => coerce_ptr(),\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n@@ -126,13 +125,14 @@ pub fn coerce_unsized_into<'a, 'tcx: 'a>(\n                 }\n             }\n         }\n-        _ => bug!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n-                  src_ty,\n-                  dst_ty),\n+        _ => bug!(\n+            \"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n+            src_ty,\n+            dst_ty\n+        ),\n     }\n }\n \n-\n // Adapted from https://github.com/rust-lang/rust/blob/2a663555ddf36f6b041445894a8c175cd1bc718c/src/librustc_codegen_ssa/glue.rs\n \n pub fn size_and_align_of_dst<'a, 'tcx: 'a>(\n@@ -142,8 +142,14 @@ pub fn size_and_align_of_dst<'a, 'tcx: 'a>(\n ) -> (Value, Value) {\n     let layout = fx.layout_of(ty);\n     if !layout.is_unsized() {\n-        let size = fx.bcx.ins().iconst(fx.pointer_type, layout.size.bytes() as i64);\n-        let align = fx.bcx.ins().iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n+        let size = fx\n+            .bcx\n+            .ins()\n+            .iconst(fx.pointer_type, layout.size.bytes() as i64);\n+        let align = fx\n+            .bcx\n+            .ins()\n+            .iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n         return (size, align);\n     }\n     match ty.sty {\n@@ -158,8 +164,12 @@ pub fn size_and_align_of_dst<'a, 'tcx: 'a>(\n             let unit = layout.field(fx, 0);\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            (fx.bcx.ins().imul_imm(info, unit.size.bytes() as i64),\n-             fx.bcx.ins().iconst(fx.pointer_type, unit.align.abi.bytes() as i64))\n+            (\n+                fx.bcx.ins().imul_imm(info, unit.size.bytes() as i64),\n+                fx.bcx\n+                    .ins()\n+                    .iconst(fx.pointer_type, unit.align.abi.bytes() as i64),\n+            )\n         }\n         _ => {\n             // First get the size of all statically known fields.\n@@ -196,7 +206,10 @@ pub fn size_and_align_of_dst<'a, 'tcx: 'a>(\n \n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n-            let cmp = fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, sized_align, unsized_align);\n+            let cmp = fx\n+                .bcx\n+                .ins()\n+                .icmp(IntCC::UnsignedGreaterThan, sized_align, unsized_align);\n             let align = fx.bcx.ins().select(cmp, sized_align, unsized_align);\n \n             // Issue #27023: must add any necessary padding to `size`\n@@ -212,7 +225,7 @@ pub fn size_and_align_of_dst<'a, 'tcx: 'a>(\n             let addend = fx.bcx.ins().iadd_imm(align, -1);\n             let add = fx.bcx.ins().iadd(size, addend);\n             let zero = fx.bcx.ins().iconst(fx.pointer_type, 0);\n-            let neg =  fx.bcx.ins().isub(zero, align);\n+            let neg = fx.bcx.ins().isub(zero, align);\n             let size = fx.bcx.ins().band(add, neg);\n \n             (size, align)"}]}