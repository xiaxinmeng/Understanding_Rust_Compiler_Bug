{"sha": "13fde05b12c28e1ed66bd13fdf1ea392f166b811", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzZmRlMDViMTJjMjhlMWVkNjZiZDEzZmRmMWVhMzkyZjE2NmI4MTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-03T23:11:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-03T23:11:17Z"}, "message": "Auto merge of #60462 - eddyb:def-1-a-mere-resolution, r=petrochenkov\n\nrustc: factor out most of hir::def::Def's variants into DefKind, and rename to Res.\n\nThe first two commits are about introducing `DefKind`, both to simplify/orthogonalize `hir::def::Def`, and to allow reasoning about the kind of a definition without dealing with the redundant `DefId`.\n(There are likely more changes to be made, such as adding enough `DefKind` variants for `tcx.def_kind(def_id)` to return just `DefKind`, not `Option<DefKind>`, but this is pretty big as-is)\n\nThe third commit frees up the `Def` name (which we may want to use in the future for \"definitions\", in the sense of \"entities with a `DefId`\") by renaming `hir::def::Def` to `Res` (\"resolution\").\nIMO this fits, as it represents all the possible name resolution results, not just \"definitions (with a `DefId`)\".\n\nQuick examples:\n```rust\n// Before:\nif tcx.describe_def(def_id) == Some(Def::Struct(def_id)) {...}\nif let Def::Struct(def_id) = path.def {...}\n```\n```rust\n// After:\nif tcx.def_kind(def_id) == Some(DefKind::Struct) {...}\nif let Res::Def(DefKind::Struct, def_id) = path.res {...}\n```\n\nr? @petrochenkov cc @rust-lang/compiler", "tree": {"sha": "fb8d9b9657887be7e011edf90cd0d1c739a88cbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb8d9b9657887be7e011edf90cd0d1c739a88cbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13fde05b12c28e1ed66bd13fdf1ea392f166b811", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13fde05b12c28e1ed66bd13fdf1ea392f166b811", "html_url": "https://github.com/rust-lang/rust/commit/13fde05b12c28e1ed66bd13fdf1ea392f166b811", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13fde05b12c28e1ed66bd13fdf1ea392f166b811/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3404557c54ea48fb8efc805d93c450beb3364d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3404557c54ea48fb8efc805d93c450beb3364d4", "html_url": "https://github.com/rust-lang/rust/commit/a3404557c54ea48fb8efc805d93c450beb3364d4"}, {"sha": "ff174fe09e2e0a8f959b970e6ec410b3aafbc58a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff174fe09e2e0a8f959b970e6ec410b3aafbc58a", "html_url": "https://github.com/rust-lang/rust/commit/ff174fe09e2e0a8f959b970e6ec410b3aafbc58a"}], "stats": {"total": 3532, "additions": 1840, "deletions": 1692}, "files": [{"sha": "6366c1f93e6716c78001cbe95451490b4e6d2029", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 144, "deletions": 142, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -11,12 +11,12 @@ use std::fmt::Debug;\n \n use self::Namespace::*;\n \n-/// Encodes if a `Def::Ctor` is the constructor of an enum variant or a struct.\n+/// Encodes if a `DefKind::Ctor` is the constructor of an enum variant or a struct.\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum CtorOf {\n-    /// This `Def::Ctor` is a synthesized constructor of a tuple or unit struct.\n+    /// This `DefKind::Ctor` is a synthesized constructor of a tuple or unit struct.\n     Struct,\n-    /// This `Def::Ctor` is a synthesized constructor of a tuple or unit variant.\n+    /// This `DefKind::Ctor` is a synthesized constructor of a tuple or unit variant.\n     Variant,\n }\n \n@@ -45,88 +45,145 @@ pub enum NonMacroAttrKind {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n-pub enum Def<Id = hir::HirId> {\n+pub enum DefKind {\n     // Type namespace\n-    Mod(DefId),\n-    /// `DefId` refers to the struct itself, `Def::Ctor` refers to its constructor if it exists.\n-    Struct(DefId),\n-    Union(DefId),\n-    Enum(DefId),\n-    /// `DefId` refers to the variant itself, `Def::Ctor` refers to its constructor if it exists.\n-    Variant(DefId),\n-    Trait(DefId),\n+    Mod,\n+    /// Refers to the struct itself, `DefKind::Ctor` refers to its constructor if it exists.\n+    Struct,\n+    Union,\n+    Enum,\n+    /// Refers to the variant itself, `DefKind::Ctor` refers to its constructor if it exists.\n+    Variant,\n+    Trait,\n     /// `existential type Foo: Bar;`\n-    Existential(DefId),\n+    Existential,\n     /// `type Foo = Bar;`\n-    TyAlias(DefId),\n-    ForeignTy(DefId),\n-    TraitAlias(DefId),\n-    AssociatedTy(DefId),\n+    TyAlias,\n+    ForeignTy,\n+    TraitAlias,\n+    AssociatedTy,\n     /// `existential type Foo: Bar;`\n-    AssociatedExistential(DefId),\n+    AssociatedExistential,\n+    TyParam,\n+\n+    // Value namespace\n+    Fn,\n+    Const,\n+    ConstParam,\n+    Static,\n+    /// Refers to the struct or enum variant's constructor.\n+    Ctor(CtorOf, CtorKind),\n+    Method,\n+    AssociatedConst,\n+\n+    // Macro namespace\n+    Macro(MacroKind),\n+}\n+\n+impl DefKind {\n+    pub fn descr(self) -> &'static str {\n+        match self {\n+            DefKind::Fn => \"function\",\n+            DefKind::Mod => \"module\",\n+            DefKind::Static => \"static\",\n+            DefKind::Enum => \"enum\",\n+            DefKind::Variant => \"variant\",\n+            DefKind::Ctor(CtorOf::Variant, CtorKind::Fn) => \"tuple variant\",\n+            DefKind::Ctor(CtorOf::Variant, CtorKind::Const) => \"unit variant\",\n+            DefKind::Ctor(CtorOf::Variant, CtorKind::Fictive) => \"struct variant\",\n+            DefKind::Struct => \"struct\",\n+            DefKind::Ctor(CtorOf::Struct, CtorKind::Fn) => \"tuple struct\",\n+            DefKind::Ctor(CtorOf::Struct, CtorKind::Const) => \"unit struct\",\n+            DefKind::Ctor(CtorOf::Struct, CtorKind::Fictive) =>\n+                bug!(\"impossible struct constructor\"),\n+            DefKind::Existential => \"existential type\",\n+            DefKind::TyAlias => \"type alias\",\n+            DefKind::TraitAlias => \"trait alias\",\n+            DefKind::AssociatedTy => \"associated type\",\n+            DefKind::AssociatedExistential => \"associated existential type\",\n+            DefKind::Union => \"union\",\n+            DefKind::Trait => \"trait\",\n+            DefKind::ForeignTy => \"foreign type\",\n+            DefKind::Method => \"method\",\n+            DefKind::Const => \"constant\",\n+            DefKind::AssociatedConst => \"associated constant\",\n+            DefKind::TyParam => \"type parameter\",\n+            DefKind::ConstParam => \"const parameter\",\n+            DefKind::Macro(macro_kind) => macro_kind.descr(),\n+        }\n+    }\n+\n+    /// An English article for the def.\n+    pub fn article(&self) -> &'static str {\n+        match *self {\n+            DefKind::AssociatedTy\n+            | DefKind::AssociatedConst\n+            | DefKind::AssociatedExistential\n+            | DefKind::Enum\n+            | DefKind::Existential => \"an\",\n+            DefKind::Macro(macro_kind) => macro_kind.article(),\n+            _ => \"a\",\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n+pub enum Res<Id = hir::HirId> {\n+    Def(DefKind, DefId),\n+\n+    // Type namespace\n     PrimTy(hir::PrimTy),\n-    TyParam(DefId),\n     SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n     ToolMod, // e.g., `rustfmt` in `#[rustfmt::skip]`\n \n     // Value namespace\n-    Fn(DefId),\n-    Const(DefId),\n-    ConstParam(DefId),\n-    Static(DefId),\n-    /// `DefId` refers to the struct or enum variant's constructor.\n-    Ctor(DefId, CtorOf, CtorKind),\n     SelfCtor(DefId /* impl */),  // `DefId` refers to the impl\n-    Method(DefId),\n-    AssociatedConst(DefId),\n-\n     Local(Id),\n     Upvar(Id,           // `HirId` of closed over local\n           usize,        // index in the `freevars` list of the closure\n           ast::NodeId), // expr node that creates the closure\n     Label(ast::NodeId),\n \n     // Macro namespace\n-    Macro(DefId, MacroKind),\n     NonMacroAttr(NonMacroAttrKind), // e.g., `#[inline]` or `#[rustfmt::skip]`\n \n-    // Both namespaces\n+    // All namespaces\n     Err,\n }\n \n /// The result of resolving a path before lowering to HIR.\n-/// `base_def` is definition of resolved part of the\n+/// `base_res` is the resolution of the resolved part of the\n /// path, `unresolved_segments` is the number of unresolved\n /// segments.\n ///\n /// ```text\n /// module::Type::AssocX::AssocY::MethodOrAssocType\n /// ^~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-/// base_def      unresolved_segments = 3\n+/// base_res      unresolved_segments = 3\n ///\n /// <T as Trait>::AssocX::AssocY::MethodOrAssocType\n ///       ^~~~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~\n-///       base_def        unresolved_segments = 2\n+///       base_res        unresolved_segments = 2\n /// ```\n #[derive(Copy, Clone, Debug)]\n pub struct PathResolution {\n-    base_def: Def<NodeId>,\n+    base_res: Res<NodeId>,\n     unresolved_segments: usize,\n }\n \n impl PathResolution {\n-    pub fn new(def: Def<NodeId>) -> Self {\n-        PathResolution { base_def: def, unresolved_segments: 0 }\n+    pub fn new(res: Res<NodeId>) -> Self {\n+        PathResolution { base_res: res, unresolved_segments: 0 }\n     }\n \n-    pub fn with_unresolved_segments(def: Def<NodeId>, mut unresolved_segments: usize) -> Self {\n-        if def == Def::Err { unresolved_segments = 0 }\n-        PathResolution { base_def: def, unresolved_segments: unresolved_segments }\n+    pub fn with_unresolved_segments(res: Res<NodeId>, mut unresolved_segments: usize) -> Self {\n+        if res == Res::Err { unresolved_segments = 0 }\n+        PathResolution { base_res: res, unresolved_segments: unresolved_segments }\n     }\n \n     #[inline]\n-    pub fn base_def(&self) -> Def<NodeId> {\n-        self.base_def\n+    pub fn base_res(&self) -> Res<NodeId> {\n+        self.base_res\n     }\n \n     #[inline]\n@@ -213,7 +270,7 @@ impl<T> PerNS<Option<T>> {\n }\n \n /// Definition mapping\n-pub type DefMap = NodeMap<PathResolution>;\n+pub type ResMap = NodeMap<PathResolution>;\n \n /// This is the replacement export map. It maps a module to all of the exports\n /// within.\n@@ -227,9 +284,9 @@ pub type ImportMap = NodeMap<PerNS<Option<PathResolution>>>;\n pub struct Export<Id> {\n     /// The name of the target.\n     pub ident: ast::Ident,\n-    /// The definition of the target.\n-    pub def: Def<Id>,\n-    /// The span of the target definition.\n+    /// The resolution of the target.\n+    pub res: Res<Id>,\n+    /// The span of the target.\n     pub span: Span,\n     /// The visibility of the export.\n     /// We include non-`pub` exports for hygienic macros that get used from extern crates.\n@@ -240,7 +297,7 @@ impl<Id> Export<Id> {\n     pub fn map_id<R>(self, map: impl FnMut(Id) -> R) -> Export<R> {\n         Export {\n             ident: self.ident,\n-            def: self.def.map_id(map),\n+            res: self.res.map_id(map),\n             span: self.span,\n             vis: self.vis,\n         }\n@@ -277,140 +334,85 @@ impl NonMacroAttrKind {\n     }\n }\n \n-impl<Id> Def<Id> {\n+impl<Id> Res<Id> {\n     /// Return the `DefId` of this `Def` if it has an id, else panic.\n     pub fn def_id(&self) -> DefId\n     where\n         Id: Debug,\n     {\n         self.opt_def_id().unwrap_or_else(|| {\n-            bug!(\"attempted .def_id() on invalid def: {:?}\", self)\n+            bug!(\"attempted .def_id() on invalid res: {:?}\", self)\n         })\n     }\n \n-    /// Return `Some(..)` with the `DefId` of this `Def` if it has a id, else `None`.\n+    /// Return `Some(..)` with the `DefId` of this `Res` if it has a id, else `None`.\n     pub fn opt_def_id(&self) -> Option<DefId> {\n         match *self {\n-            Def::Fn(id) | Def::Mod(id) | Def::Static(id) |\n-            Def::Variant(id) | Def::Ctor(id, ..) | Def::Enum(id) |\n-            Def::TyAlias(id) | Def::TraitAlias(id) |\n-            Def::AssociatedTy(id) | Def::TyParam(id) | Def::ConstParam(id) | Def::Struct(id) |\n-            Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n-            Def::AssociatedConst(id) | Def::Macro(id, ..) |\n-            Def::Existential(id) | Def::AssociatedExistential(id) | Def::ForeignTy(id) => {\n-                Some(id)\n-            }\n-\n-            Def::Local(..) |\n-            Def::Upvar(..) |\n-            Def::Label(..)  |\n-            Def::PrimTy(..) |\n-            Def::SelfTy(..) |\n-            Def::SelfCtor(..) |\n-            Def::ToolMod |\n-            Def::NonMacroAttr(..) |\n-            Def::Err => {\n+            Res::Def(_, id) => Some(id),\n+\n+            Res::Local(..) |\n+            Res::Upvar(..) |\n+            Res::Label(..)  |\n+            Res::PrimTy(..) |\n+            Res::SelfTy(..) |\n+            Res::SelfCtor(..) |\n+            Res::ToolMod |\n+            Res::NonMacroAttr(..) |\n+            Res::Err => {\n                 None\n             }\n         }\n     }\n \n-    /// Return the `DefId` of this `Def` if it represents a module.\n+    /// Return the `DefId` of this `Res` if it represents a module.\n     pub fn mod_def_id(&self) -> Option<DefId> {\n         match *self {\n-            Def::Mod(id) => Some(id),\n+            Res::Def(DefKind::Mod, id) => Some(id),\n             _ => None,\n         }\n     }\n \n-    /// A human readable name for the def kind (\"function\", \"module\", etc.).\n+    /// A human readable name for the res kind (\"function\", \"module\", etc.).\n     pub fn kind_name(&self) -> &'static str {\n         match *self {\n-            Def::Fn(..) => \"function\",\n-            Def::Mod(..) => \"module\",\n-            Def::Static(..) => \"static\",\n-            Def::Enum(..) => \"enum\",\n-            Def::Variant(..) => \"variant\",\n-            Def::Ctor(_, CtorOf::Variant, CtorKind::Fn) => \"tuple variant\",\n-            Def::Ctor(_, CtorOf::Variant, CtorKind::Const) => \"unit variant\",\n-            Def::Ctor(_, CtorOf::Variant, CtorKind::Fictive) => \"struct variant\",\n-            Def::Struct(..) => \"struct\",\n-            Def::Ctor(_, CtorOf::Struct, CtorKind::Fn) => \"tuple struct\",\n-            Def::Ctor(_, CtorOf::Struct, CtorKind::Const) => \"unit struct\",\n-            Def::Ctor(_, CtorOf::Struct, CtorKind::Fictive) =>\n-                bug!(\"impossible struct constructor\"),\n-            Def::Existential(..) => \"existential type\",\n-            Def::TyAlias(..) => \"type alias\",\n-            Def::TraitAlias(..) => \"trait alias\",\n-            Def::AssociatedTy(..) => \"associated type\",\n-            Def::AssociatedExistential(..) => \"associated existential type\",\n-            Def::SelfCtor(..) => \"self constructor\",\n-            Def::Union(..) => \"union\",\n-            Def::Trait(..) => \"trait\",\n-            Def::ForeignTy(..) => \"foreign type\",\n-            Def::Method(..) => \"method\",\n-            Def::Const(..) => \"constant\",\n-            Def::AssociatedConst(..) => \"associated constant\",\n-            Def::TyParam(..) => \"type parameter\",\n-            Def::ConstParam(..) => \"const parameter\",\n-            Def::PrimTy(..) => \"builtin type\",\n-            Def::Local(..) => \"local variable\",\n-            Def::Upvar(..) => \"closure capture\",\n-            Def::Label(..) => \"label\",\n-            Def::SelfTy(..) => \"self type\",\n-            Def::Macro(.., macro_kind) => macro_kind.descr(),\n-            Def::ToolMod => \"tool module\",\n-            Def::NonMacroAttr(attr_kind) => attr_kind.descr(),\n-            Def::Err => \"unresolved item\",\n+            Res::Def(kind, _) => kind.descr(),\n+            Res::SelfCtor(..) => \"self constructor\",\n+            Res::PrimTy(..) => \"builtin type\",\n+            Res::Local(..) => \"local variable\",\n+            Res::Upvar(..) => \"closure capture\",\n+            Res::Label(..) => \"label\",\n+            Res::SelfTy(..) => \"self type\",\n+            Res::ToolMod => \"tool module\",\n+            Res::NonMacroAttr(attr_kind) => attr_kind.descr(),\n+            Res::Err => \"unresolved item\",\n         }\n     }\n \n-    /// An English article for the def.\n+    /// An English article for the res.\n     pub fn article(&self) -> &'static str {\n         match *self {\n-            Def::AssociatedTy(..) | Def::AssociatedConst(..) | Def::AssociatedExistential(..) |\n-            Def::Enum(..) | Def::Existential(..) | Def::Err => \"an\",\n-            Def::Macro(.., macro_kind) => macro_kind.article(),\n+            Res::Def(kind, _) => kind.article(),\n+            Res::Err => \"an\",\n             _ => \"a\",\n         }\n     }\n \n-    pub fn map_id<R>(self, mut map: impl FnMut(Id) -> R) -> Def<R> {\n+    pub fn map_id<R>(self, mut map: impl FnMut(Id) -> R) -> Res<R> {\n         match self {\n-            Def::Fn(id) => Def::Fn(id),\n-            Def::Mod(id) => Def::Mod(id),\n-            Def::Static(id) => Def::Static(id),\n-            Def::Enum(id) => Def::Enum(id),\n-            Def::Variant(id) => Def::Variant(id),\n-            Def::Ctor(a, b, c) => Def::Ctor(a, b, c),\n-            Def::Struct(id) => Def::Struct(id),\n-            Def::Existential(id) => Def::Existential(id),\n-            Def::TyAlias(id) => Def::TyAlias(id),\n-            Def::TraitAlias(id) => Def::TraitAlias(id),\n-            Def::AssociatedTy(id) => Def::AssociatedTy(id),\n-            Def::AssociatedExistential(id) => Def::AssociatedExistential(id),\n-            Def::SelfCtor(id) => Def::SelfCtor(id),\n-            Def::Union(id) => Def::Union(id),\n-            Def::Trait(id) => Def::Trait(id),\n-            Def::ForeignTy(id) => Def::ForeignTy(id),\n-            Def::Method(id) => Def::Method(id),\n-            Def::Const(id) => Def::Const(id),\n-            Def::AssociatedConst(id) => Def::AssociatedConst(id),\n-            Def::TyParam(id) => Def::TyParam(id),\n-            Def::ConstParam(id) => Def::ConstParam(id),\n-            Def::PrimTy(id) => Def::PrimTy(id),\n-            Def::Local(id) => Def::Local(map(id)),\n-            Def::Upvar(id, index, closure) => Def::Upvar(\n+            Res::Def(kind, id) => Res::Def(kind, id),\n+            Res::SelfCtor(id) => Res::SelfCtor(id),\n+            Res::PrimTy(id) => Res::PrimTy(id),\n+            Res::Local(id) => Res::Local(map(id)),\n+            Res::Upvar(id, index, closure) => Res::Upvar(\n                 map(id),\n                 index,\n                 closure\n             ),\n-            Def::Label(id) => Def::Label(id),\n-            Def::SelfTy(a, b) => Def::SelfTy(a, b),\n-            Def::Macro(id, macro_kind) => Def::Macro(id, macro_kind),\n-            Def::ToolMod => Def::ToolMod,\n-            Def::NonMacroAttr(attr_kind) => Def::NonMacroAttr(attr_kind),\n-            Def::Err => Def::Err,\n+            Res::Label(id) => Res::Label(id),\n+            Res::SelfTy(a, b) => Res::SelfTy(a, b),\n+            Res::ToolMod => Res::ToolMod,\n+            Res::NonMacroAttr(attr_kind) => Res::NonMacroAttr(attr_kind),\n+            Res::Err => Res::Err,\n         }\n     }\n }"}, {"sha": "8361a62c07e48ed56aa4c79941eb86a6ff85ff41", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 69, "deletions": 66, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -37,7 +37,7 @@ use crate::hir::{self, ParamName};\n use crate::hir::HirVec;\n use crate::hir::map::{DefKey, DefPathData, Definitions};\n use crate::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CRATE_DEF_INDEX};\n-use crate::hir::def::{Def, PathResolution, PerNS};\n+use crate::hir::def::{Res, DefKind, PathResolution, PerNS};\n use crate::hir::{GenericArg, ConstArg};\n use crate::lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n                     ELIDED_LIFETIMES_IN_PATHS};\n@@ -812,29 +812,29 @@ impl<'a> LoweringContext<'a> {\n         self.lower_node_id(self.sess.next_node_id())\n     }\n \n-    fn lower_def(&mut self, def: Def<NodeId>) -> Def {\n-        def.map_id(|id| {\n+    fn lower_res(&mut self, res: Res<NodeId>) -> Res {\n+        res.map_id(|id| {\n             self.lower_node_id_generic(id, |_| {\n-                panic!(\"expected node_id to be lowered already for def {:#?}\", def)\n+                panic!(\"expected node_id to be lowered already for res {:#?}\", res)\n             })\n         })\n     }\n \n-    fn expect_full_def(&mut self, id: NodeId) -> Def<NodeId> {\n-        self.resolver.get_resolution(id).map_or(Def::Err, |pr| {\n+    fn expect_full_res(&mut self, id: NodeId) -> Res<NodeId> {\n+        self.resolver.get_resolution(id).map_or(Res::Err, |pr| {\n             if pr.unresolved_segments() != 0 {\n                 bug!(\"path not fully resolved: {:?}\", pr);\n             }\n-            pr.base_def()\n+            pr.base_res()\n         })\n     }\n \n-    fn expect_full_def_from_use(&mut self, id: NodeId) -> impl Iterator<Item = Def<NodeId>> {\n+    fn expect_full_res_from_use(&mut self, id: NodeId) -> impl Iterator<Item = Res<NodeId>> {\n         self.resolver.get_import(id).present_items().map(|pr| {\n             if pr.unresolved_segments() != 0 {\n                 bug!(\"path not fully resolved: {:?}\", pr);\n             }\n-            pr.base_def()\n+            pr.base_res()\n         })\n     }\n \n@@ -1136,7 +1136,7 @@ impl<'a> LoweringContext<'a> {\n             output,\n             c_variadic: false\n         };\n-        // Lower the arguments before the body otherwise the body will call `lower_def` expecting\n+        // Lower the arguments before the body otherwise the body will call `lower_res` expecting\n         // the argument to have been assigned an id already.\n         let arguments = self.lower_args(Some(&decl));\n         let body_expr = body(self);\n@@ -1251,7 +1251,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_loop_destination(&mut self, destination: Option<(NodeId, Label)>) -> hir::Destination {\n         let target_id = match destination {\n             Some((id, _)) => {\n-                if let Def::Label(loop_id) = self.expect_full_def(id) {\n+                if let Res::Label(loop_id) = self.expect_full_res(id) {\n                     Ok(self.lower_node_id(loop_id))\n                 } else {\n                     Err(hir::LoopIdError::UnresolvedLabel)\n@@ -1417,12 +1417,12 @@ impl<'a> LoweringContext<'a> {\n                 return ty;\n             }\n             TyKind::ImplicitSelf => {\n-                let def = self.expect_full_def(t.id);\n-                let def = self.lower_def(def);\n+                let res = self.expect_full_res(t.id);\n+                let res = self.lower_res(res);\n                 hir::TyKind::Path(hir::QPath::Resolved(\n                     None,\n                     P(hir::Path {\n-                        def,\n+                        res,\n                         segments: hir_vec![hir::PathSegment::from_ident(\n                             keywords::SelfUpper.ident()\n                         )],\n@@ -1500,7 +1500,7 @@ impl<'a> LoweringContext<'a> {\n                             None,\n                             P(hir::Path {\n                                 span,\n-                                def: Def::TyParam(DefId::local(def_index)),\n+                                res: Res::Def(DefKind::TyParam, DefId::local(def_index)),\n                                 segments: hir_vec![hir::PathSegment::from_ident(ident)],\n                             }),\n                         ))\n@@ -1844,11 +1844,11 @@ impl<'a> LoweringContext<'a> {\n \n         let resolution = self.resolver\n             .get_resolution(id)\n-            .unwrap_or_else(|| PathResolution::new(Def::Err));\n+            .unwrap_or_else(|| PathResolution::new(Res::Err));\n \n         let proj_start = p.segments.len() - resolution.unresolved_segments();\n         let path = P(hir::Path {\n-            def: self.lower_def(resolution.base_def()),\n+            res: self.lower_res(resolution.base_res()),\n             segments: p.segments[..proj_start]\n                 .iter()\n                 .enumerate()\n@@ -1869,40 +1869,43 @@ impl<'a> LoweringContext<'a> {\n                         krate: def_id.krate,\n                         index: this.def_key(def_id).parent.expect(\"missing parent\"),\n                     };\n-                    let type_def_id = match resolution.base_def() {\n-                        Def::AssociatedTy(def_id) if i + 2 == proj_start => {\n+                    let type_def_id = match resolution.base_res() {\n+                        Res::Def(DefKind::AssociatedTy, def_id) if i + 2 == proj_start => {\n                             Some(parent_def_id(self, def_id))\n                         }\n-                        Def::Variant(def_id) if i + 1 == proj_start => {\n+                        Res::Def(DefKind::Variant, def_id) if i + 1 == proj_start => {\n                             Some(parent_def_id(self, def_id))\n                         }\n-                        Def::Struct(def_id)\n-                        | Def::Union(def_id)\n-                        | Def::Enum(def_id)\n-                        | Def::TyAlias(def_id)\n-                        | Def::Trait(def_id) if i + 1 == proj_start =>\n+                        Res::Def(DefKind::Struct, def_id)\n+                        | Res::Def(DefKind::Union, def_id)\n+                        | Res::Def(DefKind::Enum, def_id)\n+                        | Res::Def(DefKind::TyAlias, def_id)\n+                        | Res::Def(DefKind::Trait, def_id) if i + 1 == proj_start =>\n                         {\n                             Some(def_id)\n                         }\n                         _ => None,\n                     };\n-                    let parenthesized_generic_args = match resolution.base_def() {\n+                    let parenthesized_generic_args = match resolution.base_res() {\n                         // `a::b::Trait(Args)`\n-                        Def::Trait(..) if i + 1 == proj_start => ParenthesizedGenericArgs::Ok,\n+                        Res::Def(DefKind::Trait, _)\n+                            if i + 1 == proj_start => ParenthesizedGenericArgs::Ok,\n                         // `a::b::Trait(Args)::TraitItem`\n-                        Def::Method(..) | Def::AssociatedConst(..) | Def::AssociatedTy(..)\n+                        Res::Def(DefKind::Method, _)\n+                        | Res::Def(DefKind::AssociatedConst, _)\n+                        | Res::Def(DefKind::AssociatedTy, _)\n                             if i + 2 == proj_start =>\n                         {\n                             ParenthesizedGenericArgs::Ok\n                         }\n                         // Avoid duplicated errors.\n-                        Def::Err => ParenthesizedGenericArgs::Ok,\n+                        Res::Err => ParenthesizedGenericArgs::Ok,\n                         // An error\n-                        Def::Struct(..)\n-                        | Def::Enum(..)\n-                        | Def::Union(..)\n-                        | Def::TyAlias(..)\n-                        | Def::Variant(..) if i + 1 == proj_start =>\n+                        Res::Def(DefKind::Struct, _)\n+                        | Res::Def(DefKind::Enum, _)\n+                        | Res::Def(DefKind::Union, _)\n+                        | Res::Def(DefKind::TyAlias, _)\n+                        | Res::Def(DefKind::Variant, _) if i + 1 == proj_start =>\n                         {\n                             ParenthesizedGenericArgs::Err\n                         }\n@@ -1997,13 +2000,13 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_path_extra(\n         &mut self,\n-        def: Def,\n+        res: Res,\n         p: &Path,\n         param_mode: ParamMode,\n         explicit_owner: Option<NodeId>,\n     ) -> hir::Path {\n         hir::Path {\n-            def,\n+            res,\n             segments: p.segments\n                 .iter()\n                 .map(|segment| {\n@@ -2023,9 +2026,9 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_path(&mut self, id: NodeId, p: &Path, param_mode: ParamMode) -> hir::Path {\n-        let def = self.expect_full_def(id);\n-        let def = self.lower_def(def);\n-        self.lower_path_extra(def, p, param_mode, None)\n+        let res = self.expect_full_res(id);\n+        let res = self.lower_res(res);\n+        self.lower_path_extra(res, p, param_mode, None)\n     }\n \n     fn lower_path_segment(\n@@ -2156,7 +2159,7 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n-        let def = self.expect_full_def(segment.id);\n+        let res = self.expect_full_res(segment.id);\n         let id = if let Some(owner) = explicit_owner {\n             self.lower_node_id_with_owner(segment.id, owner)\n         } else {\n@@ -2170,7 +2173,7 @@ impl<'a> LoweringContext<'a> {\n         hir::PathSegment::new(\n             segment.ident,\n             Some(id),\n-            Some(self.lower_def(def)),\n+            Some(self.lower_res(res)),\n             generic_args,\n             infer_types,\n         )\n@@ -2788,9 +2791,9 @@ impl<'a> LoweringContext<'a> {\n                                 if path.segments.len() == 1\n                                     && bound_pred.bound_generic_params.is_empty() =>\n                             {\n-                                if let Some(Def::TyParam(def_id)) = self.resolver\n+                                if let Some(Res::Def(DefKind::TyParam, def_id)) = self.resolver\n                                     .get_resolution(bound_pred.bounded_ty.id)\n-                                    .map(|d| d.base_def())\n+                                    .map(|d| d.base_res())\n                                 {\n                                     if let Some(node_id) =\n                                         self.resolver.definitions().as_local_node_id(def_id)\n@@ -3242,7 +3245,7 @@ impl<'a> LoweringContext<'a> {\n                         });\n \n                         if let Some(ref trait_ref) = trait_ref {\n-                            if let Def::Trait(def_id) = trait_ref.path.def {\n+                            if let Res::Def(DefKind::Trait, def_id) = trait_ref.path.res {\n                                 this.trait_impls.entry(def_id).or_default().push(\n                                     lowered_trait_impl_id);\n                             }\n@@ -3339,17 +3342,17 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n \n-                let mut defs = self.expect_full_def_from_use(id);\n+                let mut resolutions = self.expect_full_res_from_use(id);\n                 // We want to return *something* from this function, so hold onto the first item\n                 // for later.\n-                let ret_def = self.lower_def(defs.next().unwrap_or(Def::Err));\n+                let ret_res = self.lower_res(resolutions.next().unwrap_or(Res::Err));\n \n                 // Here, we are looping over namespaces, if they exist for the definition\n                 // being imported. We only handle type and value namespaces because we\n                 // won't be dealing with macros in the rest of the compiler.\n                 // Essentially a single `use` which imports two names is desugared into\n                 // two imports.\n-                for (def, &new_node_id) in defs.zip([id1, id2].iter()) {\n+                for (res, &new_node_id) in resolutions.zip([id1, id2].iter()) {\n                     let vis = vis.clone();\n                     let ident = ident.clone();\n                     let mut path = path.clone();\n@@ -3360,9 +3363,9 @@ impl<'a> LoweringContext<'a> {\n \n                     self.with_hir_id_owner(new_node_id, |this| {\n                         let new_id = this.lower_node_id(new_node_id);\n-                        let def = this.lower_def(def);\n+                        let res = this.lower_res(res);\n                         let path =\n-                            this.lower_path_extra(def, &path, ParamMode::Explicit, None);\n+                            this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n                         let item = hir::ItemKind::Use(P(path), hir::UseKind::Single);\n                         let vis_kind = match vis.node {\n                             hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n@@ -3392,7 +3395,7 @@ impl<'a> LoweringContext<'a> {\n                 }\n \n                 let path =\n-                    P(self.lower_path_extra(ret_def, &path, ParamMode::Explicit, None));\n+                    P(self.lower_path_extra(ret_res, &path, ParamMode::Explicit, None));\n                 hir::ItemKind::Use(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n@@ -3510,9 +3513,9 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n \n-                let def = self.expect_full_def_from_use(id).next().unwrap_or(Def::Err);\n-                let def = self.lower_def(def);\n-                let path = P(self.lower_path_extra(def, &prefix, ParamMode::Explicit, None));\n+                let res = self.expect_full_res_from_use(id).next().unwrap_or(Res::Err);\n+                let res = self.lower_res(res);\n+                let path = P(self.lower_path_extra(res, &prefix, ParamMode::Explicit, None));\n                 hir::ItemKind::Use(path, hir::UseKind::ListStem)\n             }\n         }\n@@ -3766,7 +3769,7 @@ impl<'a> LoweringContext<'a> {\n             },\n             UseTreeKind::Glob => {}\n             UseTreeKind::Simple(_, id1, id2) => {\n-                for (_, &id) in self.expect_full_def_from_use(base_id)\n+                for (_, &id) in self.expect_full_res_from_use(base_id)\n                                     .skip(1)\n                                     .zip([id1, id2].iter())\n                 {\n@@ -3943,11 +3946,11 @@ impl<'a> LoweringContext<'a> {\n         let node = match p.node {\n             PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, ident, ref sub) => {\n-                match self.resolver.get_resolution(p.id).map(|d| d.base_def()) {\n+                match self.resolver.get_resolution(p.id).map(|d| d.base_res()) {\n                     // `None` can occur in body-less function signatures\n-                    def @ None | def @ Some(Def::Local(_)) => {\n-                        let canonical_id = match def {\n-                            Some(Def::Local(id)) => id,\n+                    res @ None | res @ Some(Res::Local(_)) => {\n+                        let canonical_id = match res {\n+                            Some(Res::Local(id)) => id,\n                             _ => p.id,\n                         };\n \n@@ -3958,11 +3961,11 @@ impl<'a> LoweringContext<'a> {\n                             sub.as_ref().map(|x| self.lower_pat(x)),\n                         )\n                     }\n-                    Some(def) => hir::PatKind::Path(hir::QPath::Resolved(\n+                    Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n                         None,\n                         P(hir::Path {\n                             span: ident.span,\n-                            def: self.lower_def(def),\n+                            res: self.lower_res(res),\n                             segments: hir_vec![hir::PathSegment::from_ident(ident)],\n                         }),\n                     )),\n@@ -4954,11 +4957,11 @@ impl<'a> LoweringContext<'a> {\n                 } else {\n                     self.lower_node_id(id)\n                 };\n-                let def = self.expect_full_def(id);\n-                let def = self.lower_def(def);\n+                let res = self.expect_full_res(id);\n+                let res = self.lower_res(res);\n                 hir::VisibilityKind::Restricted {\n                     path: P(self.lower_path_extra(\n-                        def,\n+                        res,\n                         path,\n                         ParamMode::Explicit,\n                         explicit_owner,\n@@ -5070,7 +5073,7 @@ impl<'a> LoweringContext<'a> {\n             None,\n             P(hir::Path {\n                 span,\n-                def: Def::Local(binding),\n+                res: Res::Local(binding),\n                 segments: hir_vec![hir::PathSegment::from_ident(ident)],\n             }),\n         ));\n@@ -5276,8 +5279,8 @@ impl<'a> LoweringContext<'a> {\n         let node = match qpath {\n             hir::QPath::Resolved(None, path) => {\n                 // Turn trait object paths into `TyKind::TraitObject` instead.\n-                match path.def {\n-                    Def::Trait(_) | Def::TraitAlias(_) => {\n+                match path.res {\n+                    Res::Def(DefKind::Trait, _) | Res::Def(DefKind::TraitAlias, _) => {\n                         let principal = hir::PolyTraitRef {\n                             bound_generic_params: hir::HirVec::new(),\n                             trait_ref: hir::TraitRef {"}, {"sha": "9c895198ddde993d4b48462cdc03531d9023cd66", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 43, "deletions": 63, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -17,6 +17,7 @@ use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n use crate::hir::*;\n+use crate::hir::DefKind;\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n use crate::hir::print::Nested;\n use crate::util::nodemap::FxHashMap;\n@@ -309,74 +310,68 @@ impl<'hir> Map<'hir> {\n         self.definitions.as_local_node_id(def_id.to_def_id()).unwrap()\n     }\n \n-    pub fn describe_def(&self, node_id: NodeId) -> Option<Def> {\n+    fn def_kind(&self, node_id: NodeId) -> Option<DefKind> {\n         let node = if let Some(node) = self.find(node_id) {\n             node\n         } else {\n             return None\n         };\n \n-        match node {\n+        Some(match node {\n             Node::Item(item) => {\n-                let def_id = || self.local_def_id_from_hir_id(item.hir_id);\n-\n                 match item.node {\n-                    ItemKind::Static(..) => Some(Def::Static(def_id())),\n-                    ItemKind::Const(..) => Some(Def::Const(def_id())),\n-                    ItemKind::Fn(..) => Some(Def::Fn(def_id())),\n-                    ItemKind::Mod(..) => Some(Def::Mod(def_id())),\n-                    ItemKind::Existential(..) => Some(Def::Existential(def_id())),\n-                    ItemKind::Ty(..) => Some(Def::TyAlias(def_id())),\n-                    ItemKind::Enum(..) => Some(Def::Enum(def_id())),\n-                    ItemKind::Struct(..) => Some(Def::Struct(def_id())),\n-                    ItemKind::Union(..) => Some(Def::Union(def_id())),\n-                    ItemKind::Trait(..) => Some(Def::Trait(def_id())),\n-                    ItemKind::TraitAlias(..) => Some(Def::TraitAlias(def_id())),\n+                    ItemKind::Static(..) => DefKind::Static,\n+                    ItemKind::Const(..) => DefKind::Const,\n+                    ItemKind::Fn(..) => DefKind::Fn,\n+                    ItemKind::Mod(..) => DefKind::Mod,\n+                    ItemKind::Existential(..) => DefKind::Existential,\n+                    ItemKind::Ty(..) => DefKind::TyAlias,\n+                    ItemKind::Enum(..) => DefKind::Enum,\n+                    ItemKind::Struct(..) => DefKind::Struct,\n+                    ItemKind::Union(..) => DefKind::Union,\n+                    ItemKind::Trait(..) => DefKind::Trait,\n+                    ItemKind::TraitAlias(..) => DefKind::TraitAlias,\n                     ItemKind::ExternCrate(_) |\n                     ItemKind::Use(..) |\n                     ItemKind::ForeignMod(..) |\n                     ItemKind::GlobalAsm(..) |\n-                    ItemKind::Impl(..) => None,\n+                    ItemKind::Impl(..) => return None,\n                 }\n             }\n             Node::ForeignItem(item) => {\n-                let def_id = self.local_def_id_from_hir_id(item.hir_id);\n                 match item.node {\n-                    ForeignItemKind::Fn(..) => Some(Def::Fn(def_id)),\n-                    ForeignItemKind::Static(..) => Some(Def::Static(def_id)),\n-                    ForeignItemKind::Type => Some(Def::ForeignTy(def_id)),\n+                    ForeignItemKind::Fn(..) => DefKind::Fn,\n+                    ForeignItemKind::Static(..) => DefKind::Static,\n+                    ForeignItemKind::Type => DefKind::ForeignTy,\n                 }\n             }\n             Node::TraitItem(item) => {\n-                let def_id = self.local_def_id_from_hir_id(item.hir_id);\n                 match item.node {\n-                    TraitItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n-                    TraitItemKind::Method(..) => Some(Def::Method(def_id)),\n-                    TraitItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n+                    TraitItemKind::Const(..) => DefKind::AssociatedConst,\n+                    TraitItemKind::Method(..) => DefKind::Method,\n+                    TraitItemKind::Type(..) => DefKind::AssociatedTy,\n                 }\n             }\n             Node::ImplItem(item) => {\n-                let def_id = self.local_def_id_from_hir_id(item.hir_id);\n                 match item.node {\n-                    ImplItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n-                    ImplItemKind::Method(..) => Some(Def::Method(def_id)),\n-                    ImplItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n-                    ImplItemKind::Existential(..) => Some(Def::AssociatedExistential(def_id)),\n+                    ImplItemKind::Const(..) => DefKind::AssociatedConst,\n+                    ImplItemKind::Method(..) => DefKind::Method,\n+                    ImplItemKind::Type(..) => DefKind::AssociatedTy,\n+                    ImplItemKind::Existential(..) => DefKind::AssociatedExistential,\n                 }\n             }\n-            Node::Variant(variant) => {\n-                let def_id = self.local_def_id_from_hir_id(variant.node.id);\n-                Some(Def::Variant(def_id))\n-            }\n+            Node::Variant(_) => DefKind::Variant,\n             Node::Ctor(variant_data) => {\n+                // FIXME(eddyb) is this even possible, if we have a `Node::Ctor`?\n+                if variant_data.ctor_hir_id().is_none() {\n+                    return None;\n+                }\n                 let ctor_of = match self.find(self.get_parent_node(node_id)) {\n                     Some(Node::Item(..)) => def::CtorOf::Struct,\n                     Some(Node::Variant(..)) => def::CtorOf::Variant,\n                     _ => unreachable!(),\n                 };\n-                variant_data.ctor_hir_id()\n-                    .map(|hir_id| self.local_def_id_from_hir_id(hir_id))\n-                    .map(|def_id| Def::Ctor(def_id, ctor_of, def::CtorKind::from_hir(variant_data)))\n+                DefKind::Ctor(ctor_of, def::CtorKind::from_hir(variant_data))\n             }\n             Node::AnonConst(_) |\n             Node::Field(_) |\n@@ -387,35 +382,20 @@ impl<'hir> Map<'hir> {\n             Node::TraitRef(_) |\n             Node::Pat(_) |\n             Node::Binding(_) |\n+            Node::Local(_) |\n             Node::Lifetime(_) |\n             Node::Visibility(_) |\n             Node::Block(_) |\n-            Node::Crate => None,\n-            Node::Local(local) => {\n-                Some(Def::Local(local.hir_id))\n-            }\n-            Node::MacroDef(macro_def) => {\n-                Some(Def::Macro(self.local_def_id_from_hir_id(macro_def.hir_id),\n-                                MacroKind::Bang))\n-            }\n+            Node::Crate => return None,\n+            Node::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n             Node::GenericParam(param) => {\n-                Some(match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        Def::Local(param.hir_id)\n-                    },\n-                    GenericParamKind::Type { .. } => Def::TyParam(\n-                        self.local_def_id_from_hir_id(param.hir_id)),\n-                    GenericParamKind::Const { .. } => Def::ConstParam(\n-                        self.local_def_id_from_hir_id(param.hir_id)),\n-                })\n+                match param.kind {\n+                    GenericParamKind::Lifetime { .. } => return None,\n+                    GenericParamKind::Type { .. } => DefKind::TyParam,\n+                    GenericParamKind::Const { .. } => DefKind::ConstParam,\n+                }\n             }\n-        }\n-    }\n-\n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn describe_def_by_hir_id(&self, hir_id: HirId) -> Option<Def> {\n-        let node_id = self.hir_to_node_id(hir_id);\n-        self.describe_def(node_id)\n+        })\n     }\n \n     fn entry_count(&self) -> usize {\n@@ -1473,11 +1453,11 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n     node_id_to_string(map, node_id, include_id)\n }\n \n-pub fn describe_def(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<Def> {\n+pub fn def_kind(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefKind> {\n     if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n-        tcx.hir().describe_def(node_id)\n+        tcx.hir().def_kind(node_id)\n     } else {\n-        bug!(\"Calling local describe_def query provider for upstream DefId: {:?}\",\n+        bug!(\"Calling local def_kind query provider for upstream DefId: {:?}\",\n              def_id)\n     }\n }"}, {"sha": "ae7358df9d8facc79e811c3b9d672589f897df58", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -10,7 +10,7 @@ pub use self::PrimTy::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n \n-use crate::hir::def::Def;\n+use crate::hir::def::{Res, DefKind};\n use crate::hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n use crate::util::nodemap::{NodeMap, FxHashSet};\n use crate::mir::mono::Linkage;\n@@ -296,8 +296,8 @@ impl Lifetime {\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Path {\n     pub span: Span,\n-    /// The definition that the path resolved to.\n-    pub def: Def,\n+    /// The resolution for the path.\n+    pub res: Res,\n     /// The segments in the path: the things separated by `::`.\n     pub segments: HirVec<PathSegment>,\n }\n@@ -327,13 +327,13 @@ pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n-    // `id` and `def` are optional. We currently only use these in save-analysis,\n+    // `id` and `res` are optional. We currently only use these in save-analysis,\n     // any path segments without these will not have save-analysis info and\n     // therefore will not have 'jump to def' in IDEs, but otherwise will not be\n     // affected. (In general, we don't bother to get the defs for synthesized\n     // segments, only for segments which have come from the AST).\n     pub hir_id: Option<HirId>,\n-    pub def: Option<Def>,\n+    pub res: Option<Res>,\n \n     /// Type/lifetime parameters attached to this path. They come in\n     /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n@@ -355,7 +355,7 @@ impl PathSegment {\n         PathSegment {\n             ident,\n             hir_id: None,\n-            def: None,\n+            res: None,\n             infer_types: true,\n             args: None,\n         }\n@@ -364,14 +364,14 @@ impl PathSegment {\n     pub fn new(\n         ident: Ident,\n         hir_id: Option<HirId>,\n-        def: Option<Def>,\n+        res: Option<Res>,\n         args: GenericArgs,\n         infer_types: bool,\n     ) -> Self {\n         PathSegment {\n             ident,\n             hir_id,\n-            def,\n+            res,\n             infer_types,\n             args: if args.is_empty() {\n                 None\n@@ -1393,8 +1393,11 @@ impl Expr {\n     pub fn is_place_expr(&self) -> bool {\n          match self.node {\n             ExprKind::Path(QPath::Resolved(_, ref path)) => {\n-                match path.def {\n-                    Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n+                match path.res {\n+                    Res::Local(..)\n+                    | Res::Upvar(..)\n+                    | Res::Def(DefKind::Static, _)\n+                    | Res::Err => true,\n                     _ => false,\n                 }\n             }\n@@ -2139,7 +2142,7 @@ pub enum UseKind {\n /// resolve maps each TraitRef's ref_id to its defining trait; that's all\n /// that the ref_id is for. Note that ref_id's value is not the NodeId of the\n /// trait being referred to but just a unique NodeId that serves as a key\n-/// within the DefMap.\n+/// within the ResMap.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitRef {\n     pub path: Path,\n@@ -2151,10 +2154,10 @@ pub struct TraitRef {\n impl TraitRef {\n     /// Gets the `DefId` of the referenced trait. It _must_ actually be a trait or trait alias.\n     pub fn trait_def_id(&self) -> DefId {\n-        match self.path.def {\n-            Def::Trait(did) => did,\n-            Def::TraitAlias(did) => did,\n-            Def::Err => {\n+        match self.path.res {\n+            Res::Def(DefKind::Trait, did) => did,\n+            Res::Def(DefKind::TraitAlias, did) => did,\n+            Res::Err => {\n                 FatalError.raise();\n             }\n             _ => unreachable!(),\n@@ -2476,7 +2479,7 @@ impl ForeignItemKind {\n #[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Freevar<Id = HirId> {\n     /// The variable being accessed free.\n-    pub def: def::Def<Id>,\n+    pub res: Res<Id>,\n \n     // First span where it is accessed (there can be multiple).\n     pub span: Span\n@@ -2485,15 +2488,15 @@ pub struct Freevar<Id = HirId> {\n impl<Id: fmt::Debug + Copy> Freevar<Id> {\n     pub fn map_id<R>(self, map: impl FnMut(Id) -> R) -> Freevar<R> {\n         Freevar {\n-            def: self.def.map_id(map),\n+            res: self.res.map_id(map),\n             span: self.span,\n         }\n     }\n \n     pub fn var_id(&self) -> Id {\n-        match self.def {\n-            Def::Local(id) | Def::Upvar(id, ..) => id,\n-            _ => bug!(\"Freevar::var_id: bad def ({:?})\", self.def)\n+        match self.res {\n+            Res::Local(id) | Res::Upvar(id, ..) => id,\n+            _ => bug!(\"Freevar::var_id: bad res ({:?})\", self.res)\n         }\n     }\n }\n@@ -2518,7 +2521,7 @@ pub type GlobMap = NodeMap<FxHashSet<Name>>;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     check_attr::provide(providers);\n-    providers.describe_def = map::describe_def;\n+    providers.def_kind = map::def_kind;\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]"}, {"sha": "0d2c7d393bb894b5752b733e9a030f0211d87222", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -1,4 +1,4 @@\n-use crate::hir::def::{CtorOf, Def};\n+use crate::hir::def::{CtorOf, Res, DefKind};\n use crate::hir::def_id::DefId;\n use crate::hir::{self, HirId, PatKind};\n use syntax::ast;\n@@ -54,8 +54,8 @@ impl hir::Pat {\n             PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n             PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n             PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n-                match path.def {\n-                    Def::Variant(..) => true,\n+                match path.res {\n+                    Res::Def(DefKind::Variant, _) => true,\n                     _ => false\n                 }\n             }\n@@ -124,9 +124,9 @@ impl hir::Pat {\n                 PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n                 PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n                 PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n-                    match path.def {\n-                        Def::Variant(id) => variants.push(id),\n-                        Def::Ctor(id, CtorOf::Variant, ..) => variants.push(id),\n+                    match path.res {\n+                        Res::Def(DefKind::Variant, id) => variants.push(id),\n+                        Res::Def(DefKind::Ctor(CtorOf::Variant, ..), id) => variants.push(id),\n                         _ => ()\n                     }\n                 }"}, {"sha": "c78026209760753b588dcc200e815f7e3ba64108", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -170,8 +170,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n \n fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment) -> bool {\n     if segment.ident.as_str() == \"TyKind\" {\n-        if let Some(def) = segment.def {\n-            if let Some(did) = def.opt_def_id() {\n+        if let Some(res) = segment.res {\n+            if let Some(did) = res.opt_def_id() {\n                 return cx.match_def_path(did, &[\"rustc\", \"ty\", \"sty\", \"TyKind\"]);\n             }\n         }\n@@ -184,7 +184,7 @@ fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty) -> Option<String> {\n     match &ty.node {\n         TyKind::Path(qpath) => {\n             if let QPath::Resolved(_, path) = qpath {\n-                let did = path.def.opt_def_id()?;\n+                let did = path.res.opt_def_id()?;\n                 if cx.match_def_path(did, &[\"rustc\", \"ty\", \"Ty\"]) {\n                     return Some(format!(\"Ty{}\", gen_args(path.segments.last().unwrap())));\n                 } else if cx.match_def_path(did, &[\"rustc\", \"ty\", \"context\", \"TyCtxt\"]) {"}, {"sha": "a0107ed0546ddd2209245caa06445a344084da69", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -7,7 +7,7 @@ use crate::hir::{self, PatKind, TyKind};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n \n-use crate::hir::def::{CtorOf, Def};\n+use crate::hir::def::{CtorOf, Res, DefKind};\n use crate::hir::CodegenFnAttrFlags;\n use crate::hir::def_id::{DefId, LOCAL_CRATE};\n use crate::lint;\n@@ -68,32 +68,34 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_definition(&mut self, def: Def) {\n-        match def {\n-            Def::Const(_) | Def::AssociatedConst(..) | Def::TyAlias(_) => {\n-                self.check_def_id(def.def_id());\n+    fn handle_res(&mut self, res: Res) {\n+        match res {\n+            Res::Def(DefKind::Const, _)\n+            | Res::Def(DefKind::AssociatedConst, _)\n+            | Res::Def(DefKind::TyAlias, _) => {\n+                self.check_def_id(res.def_id());\n             }\n             _ if self.in_pat => {},\n-            Def::PrimTy(..) | Def::SelfTy(..) | Def::SelfCtor(..) |\n-            Def::Local(..) | Def::Upvar(..) => {}\n-            Def::Ctor(ctor_def_id, CtorOf::Variant, ..) => {\n+            Res::PrimTy(..) | Res::SelfTy(..) | Res::SelfCtor(..) |\n+            Res::Local(..) | Res::Upvar(..) => {}\n+            Res::Def(DefKind::Ctor(CtorOf::Variant, ..), ctor_def_id) => {\n                 let variant_id = self.tcx.parent(ctor_def_id).unwrap();\n                 let enum_id = self.tcx.parent(variant_id).unwrap();\n                 self.check_def_id(enum_id);\n                 if !self.ignore_variant_stack.contains(&ctor_def_id) {\n                     self.check_def_id(variant_id);\n                 }\n             }\n-            Def::Variant(variant_id) => {\n+            Res::Def(DefKind::Variant, variant_id) => {\n                 let enum_id = self.tcx.parent(variant_id).unwrap();\n                 self.check_def_id(enum_id);\n                 if !self.ignore_variant_stack.contains(&variant_id) {\n                     self.check_def_id(variant_id);\n                 }\n             }\n-            Def::ToolMod | Def::NonMacroAttr(..) | Def::Err => {}\n+            Res::ToolMod | Res::NonMacroAttr(..) | Res::Err => {}\n             _ => {\n-                self.check_def_id(def.def_id());\n+                self.check_def_id(res.def_id());\n             }\n         }\n     }\n@@ -117,10 +119,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, def: Def,\n+    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, res: Res,\n                                   pats: &[source_map::Spanned<hir::FieldPat>]) {\n         let variant = match self.tables.node_type(lhs.hir_id).sty {\n-            ty::Adt(adt, _) => adt.variant_of_def(def),\n+            ty::Adt(adt, _) => adt.variant_of_res(res),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n@@ -229,8 +231,8 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n-                let def = self.tables.qpath_def(qpath, expr.hir_id);\n-                self.handle_definition(def);\n+                let res = self.tables.qpath_res(qpath, expr.hir_id);\n+                self.handle_res(res);\n             }\n             hir::ExprKind::MethodCall(..) => {\n                 self.lookup_and_handle_method(expr.hir_id);\n@@ -268,11 +270,11 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         match pat.node {\n             PatKind::Struct(hir::QPath::Resolved(_, ref path), ref fields, _) => {\n-                self.handle_field_pattern_match(pat, path.def, fields);\n+                self.handle_field_pattern_match(pat, path.res, fields);\n             }\n             PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n-                let def = self.tables.qpath_def(qpath, pat.hir_id);\n-                self.handle_definition(def);\n+                let res = self.tables.qpath_res(qpath, pat.hir_id);\n+                self.handle_res(res);\n             }\n             _ => ()\n         }\n@@ -283,7 +285,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &'tcx hir::Path, _: hir::HirId) {\n-        self.handle_definition(path.def);\n+        self.handle_res(path.res);\n         intravisit::walk_path(self, path);\n     }\n "}, {"sha": "cf3f613b08eb5f755194107bbeed951f35a46668", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -9,7 +9,7 @@ pub use self::MatchMode::*;\n use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n-use crate::hir::def::{CtorOf, Def};\n+use crate::hir::def::{CtorOf, Res, DefKind};\n use crate::hir::def_id::DefId;\n use crate::infer::InferCtxt;\n use crate::middle::mem_categorization as mc;\n@@ -862,8 +862,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n                     // Each match binding is effectively an assignment to the\n                     // binding being produced.\n-                    let def = Def::Local(canonical_id);\n-                    if let Ok(ref binding_cmt) = mc.cat_def(pat.hir_id, pat.span, pat_ty, def) {\n+                    let def = Res::Local(canonical_id);\n+                    if let Ok(ref binding_cmt) = mc.cat_res(pat.hir_id, pat.span, pat_ty, def) {\n                         delegate.mutate(pat.hir_id, pat.span, binding_cmt, MutateMode::Init);\n                     }\n \n@@ -898,23 +898,27 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 PatKind::Struct(ref qpath, ..) => qpath,\n                 _ => return\n             };\n-            let def = mc.tables.qpath_def(qpath, pat.hir_id);\n-            match def {\n-                Def::Ctor(variant_ctor_did, CtorOf::Variant, ..) => {\n+            let res = mc.tables.qpath_res(qpath, pat.hir_id);\n+            match res {\n+                Res::Def(DefKind::Ctor(CtorOf::Variant, ..), variant_ctor_did) => {\n                     let variant_did = mc.tcx.parent(variant_ctor_did).unwrap();\n                     let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n \n                     debug!(\"variantctor downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n                     delegate.matched_pat(pat, &downcast_cmt, match_mode);\n                 }\n-                Def::Variant(variant_did) => {\n+                Res::Def(DefKind::Variant, variant_did) => {\n                     let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n \n                     debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n                     delegate.matched_pat(pat, &downcast_cmt, match_mode);\n                 }\n-                Def::Struct(..) | Def::Ctor(..) | Def::Union(..) |\n-                Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => {\n+                Res::Def(DefKind::Struct, _)\n+                | Res::Def(DefKind::Ctor(..), _)\n+                | Res::Def(DefKind::Union, _)\n+                | Res::Def(DefKind::TyAlias, _)\n+                | Res::Def(DefKind::AssociatedTy, _)\n+                | Res::SelfTy(..) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n                     delegate.matched_pat(pat, &cmt_pat, match_mode);\n                 }\n@@ -968,7 +972,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // caller's perspective\n         let var_hir_id = upvar.var_id();\n         let var_ty = self.mc.node_ty(var_hir_id)?;\n-        self.mc.cat_def(closure_hir_id, closure_span, var_ty, upvar.def)\n+        self.mc.cat_res(closure_hir_id, closure_span, var_ty, upvar.res)\n     }\n }\n "}, {"sha": "5c28d480571e9c51132dd58349529cde7e7d8f93", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -1,4 +1,4 @@\n-use crate::hir::def::Def;\n+use crate::hir::def::{Res, DefKind};\n use crate::hir::def_id::DefId;\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::layout::{LayoutError, Pointer, SizeSkeleton, VariantIdx};\n@@ -152,12 +152,12 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        let def = if let hir::ExprKind::Path(ref qpath) = expr.node {\n-            self.tables.qpath_def(qpath, expr.hir_id)\n+        let res = if let hir::ExprKind::Path(ref qpath) = expr.node {\n+            self.tables.qpath_res(qpath, expr.hir_id)\n         } else {\n-            Def::Err\n+            Res::Err\n         };\n-        if let Def::Fn(did) = def {\n+        if let Res::Def(DefKind::Fn, did) = res {\n             if self.def_id_is_transmute(did) {\n                 let typ = self.tables.node_type(expr.hir_id);\n                 let sig = typ.fn_sig(self.tcx);"}, {"sha": "15736218a79233b7c82341315507bb55c21671d7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -467,8 +467,8 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n-        debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.def);\n-        if let Def::Local(..) = path.def {\n+        debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.res);\n+        if let Res::Local(..) = path.res {\n             ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         }\n         intravisit::walk_expr(ir, expr);\n@@ -485,7 +485,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n         let mut call_caps = Vec::new();\n         ir.tcx.with_freevars(expr.hir_id, |freevars| {\n             call_caps.extend(freevars.iter().filter_map(|fv| {\n-                if let Def::Local(rv) = fv.def {\n+                if let Res::Local(rv) = fv.res {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n                     Some(CaptureInfo { ln: fv_ln, var_hid: rv })\n                 } else {\n@@ -1347,8 +1347,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn access_path(&mut self, hir_id: HirId, path: &hir::Path, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n-        match path.def {\n-            Def::Local(hid) => {\n+        match path.res {\n+            Res::Local(hid) => {\n               let nid = self.ir.tcx.hir().hir_to_node_id(hid);\n               self.access_var(hir_id, nid, succ, acc, path.span)\n             }\n@@ -1541,7 +1541,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_place(&mut self, expr: &'tcx Expr) {\n         match expr.node {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n-                if let Def::Local(var_hid) = path.def {\n+                if let Res::Local(var_hid) = path.res {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability"}, {"sha": "f6caf357b393d6376e52e566c8780290eb6aeec1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -62,7 +62,7 @@ use crate::middle::region;\n use crate::hir::def_id::{DefId, LocalDefId};\n use crate::hir::Node;\n use crate::infer::InferCtxt;\n-use crate::hir::def::{CtorOf, Def, CtorKind};\n+use crate::hir::def::{CtorOf, Res, DefKind, CtorKind};\n use crate::ty::adjustment;\n use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n use crate::ty::fold::TypeFoldable;\n@@ -665,8 +665,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprKind::Path(ref qpath) => {\n-                let def = self.tables.qpath_def(qpath, expr.hir_id);\n-                self.cat_def(expr.hir_id, expr.span, expr_ty, def)\n+                let res = self.tables.qpath_res(qpath, expr.hir_id);\n+                self.cat_res(expr.hir_id, expr.span, expr_ty, res)\n             }\n \n             hir::ExprKind::Type(ref e, _) => {\n@@ -689,22 +689,27 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn cat_def(&self,\n+    pub fn cat_res(&self,\n                    hir_id: hir::HirId,\n                    span: Span,\n                    expr_ty: Ty<'tcx>,\n-                   def: Def)\n+                   res: Res)\n                    -> McResult<cmt_<'tcx>> {\n-        debug!(\"cat_def: id={:?} expr={:?} def={:?}\",\n-               hir_id, expr_ty, def);\n-\n-        match def {\n-            Def::Ctor(..) | Def::Const(..) | Def::ConstParam(..) |\n-            Def::AssociatedConst(..) | Def::Fn(..) | Def::Method(..) | Def::SelfCtor(..) => {\n+        debug!(\"cat_res: id={:?} expr={:?} def={:?}\",\n+               hir_id, expr_ty, res);\n+\n+        match res {\n+            Res::Def(DefKind::Ctor(..), _)\n+            | Res::Def(DefKind::Const, _)\n+            | Res::Def(DefKind::ConstParam, _)\n+            | Res::Def(DefKind::AssociatedConst, _)\n+            | Res::Def(DefKind::Fn, _)\n+            | Res::Def(DefKind::Method, _)\n+            | Res::SelfCtor(..) => {\n                 Ok(self.cat_rvalue_node(hir_id, span, expr_ty))\n             }\n \n-            Def::Static(def_id) => {\n+            Res::Def(DefKind::Static, def_id) => {\n                 // `#[thread_local]` statics may not outlive the current function, but\n                 // they also cannot be moved out of.\n                 let is_thread_local = self.tcx.get_attrs(def_id)[..]\n@@ -731,12 +736,12 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 })\n             }\n \n-            Def::Upvar(var_id, _, fn_node_id) => {\n+            Res::Upvar(var_id, _, fn_node_id) => {\n                 let var_nid = self.tcx.hir().hir_to_node_id(var_id);\n                 self.cat_upvar(hir_id, span, var_nid, fn_node_id)\n             }\n \n-            Def::Local(vid) => {\n+            Res::Local(vid) => {\n                 let vnid = self.tcx.hir().hir_to_node_id(vid);\n                 Ok(cmt_ {\n                     hir_id,\n@@ -1268,20 +1273,21 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         match pat.node {\n             PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-                let def = self.tables.qpath_def(qpath, pat.hir_id);\n-                let (cmt, expected_len) = match def {\n-                    Def::Err => {\n+                let res = self.tables.qpath_res(qpath, pat.hir_id);\n+                let (cmt, expected_len) = match res {\n+                    Res::Err => {\n                         debug!(\"access to unresolvable pattern {:?}\", pat);\n                         return Err(())\n                     }\n-                    Def::Ctor(variant_ctor_did, CtorOf::Variant, CtorKind::Fn) => {\n+                    Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), variant_ctor_did) => {\n                         let variant_did = self.tcx.parent(variant_ctor_did).unwrap();\n                         let enum_did = self.tcx.parent(variant_did).unwrap();\n                         (self.cat_downcast_if_needed(pat, cmt, variant_did),\n                          self.tcx.adt_def(enum_did)\n                              .variant_with_ctor_id(variant_ctor_did).fields.len())\n                     }\n-                    Def::Ctor(_, CtorOf::Struct, CtorKind::Fn) | Def::SelfCtor(..) => {\n+                    Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), _)\n+                    | Res::SelfCtor(..) => {\n                         let ty = self.pat_ty_unadjusted(&pat)?;\n                         match ty.sty {\n                             ty::Adt(adt_def, _) => {\n@@ -1310,17 +1316,17 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n             PatKind::Struct(ref qpath, ref field_pats, _) => {\n                 // {f1: p1, ..., fN: pN}\n-                let def = self.tables.qpath_def(qpath, pat.hir_id);\n-                let cmt = match def {\n-                    Def::Err => {\n+                let res = self.tables.qpath_res(qpath, pat.hir_id);\n+                let cmt = match res {\n+                    Res::Err => {\n                         debug!(\"access to unresolvable pattern {:?}\", pat);\n                         return Err(())\n                     }\n-                    Def::Ctor(variant_ctor_did, CtorOf::Variant, _) => {\n+                    Res::Def(DefKind::Ctor(CtorOf::Variant, _), variant_ctor_did) => {\n                         let variant_did = self.tcx.parent(variant_ctor_did).unwrap();\n                         self.cat_downcast_if_needed(pat, cmt, variant_did)\n                     }\n-                    Def::Variant(variant_did) => {\n+                    Res::Def(DefKind::Variant, variant_did) => {\n                         self.cat_downcast_if_needed(pat, cmt, variant_did)\n                     }\n                     _ => cmt,"}, {"sha": "e58083b5b76267458e78f9ac7c35e359a7276709", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -7,7 +7,7 @@\n \n use crate::hir::{CodegenFnAttrs, CodegenFnAttrFlags};\n use crate::hir::Node;\n-use crate::hir::def::Def;\n+use crate::hir::def::{Res, DefKind};\n use crate::hir::def_id::{DefId, CrateNum};\n use rustc_data_structures::sync::Lrc;\n use crate::ty::{self, TyCtxt};\n@@ -92,32 +92,33 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        let def = match expr.node {\n+        let res = match expr.node {\n             hir::ExprKind::Path(ref qpath) => {\n-                Some(self.tables.qpath_def(qpath, expr.hir_id))\n+                Some(self.tables.qpath_res(qpath, expr.hir_id))\n             }\n             hir::ExprKind::MethodCall(..) => {\n                 self.tables.type_dependent_def(expr.hir_id)\n+                    .map(|(kind, def_id)| Res::Def(kind, def_id))\n             }\n             _ => None\n         };\n \n-        match def {\n-            Some(Def::Local(hir_id)) | Some(Def::Upvar(hir_id, ..)) => {\n+        match res {\n+            Some(Res::Local(hir_id)) | Some(Res::Upvar(hir_id, ..)) => {\n                 self.reachable_symbols.insert(hir_id);\n             }\n-            Some(def) => {\n-                if let Some((hir_id, def_id)) = def.opt_def_id().and_then(|def_id| {\n+            Some(res) => {\n+                if let Some((hir_id, def_id)) = res.opt_def_id().and_then(|def_id| {\n                     self.tcx.hir().as_local_hir_id(def_id).map(|hir_id| (hir_id, def_id))\n                 }) {\n                     if self.def_id_represents_local_inlined_item(def_id) {\n                         self.worklist.push(hir_id);\n                     } else {\n-                        match def {\n+                        match res {\n                             // If this path leads to a constant, then we need to\n                             // recurse into the constant to continue finding\n                             // items that are reachable.\n-                            Def::Const(..) | Def::AssociatedConst(..) => {\n+                            Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssociatedConst, _) => {\n                                 self.worklist.push(hir_id);\n                             }\n \n@@ -356,8 +357,8 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n             if !self.access_levels.is_reachable(item.hir_id) {\n                 self.worklist.extend(impl_item_refs.iter().map(|ii_ref| ii_ref.id.hir_id));\n \n-                let trait_def_id = match trait_ref.path.def {\n-                    Def::Trait(def_id) => def_id,\n+                let trait_def_id = match trait_ref.path.res {\n+                    Res::Def(DefKind::Trait, def_id) => def_id,\n                     _ => unreachable!()\n                 };\n "}, {"sha": "d835d872d76d7f3be775fb8f970830cb83785d62", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -5,7 +5,7 @@\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n \n-use crate::hir::def::Def;\n+use crate::hir::def::{Res, DefKind};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use crate::hir::map::Map;\n use crate::hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, Node, ParamName};\n@@ -925,7 +925,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n             if let Some(ref args) = segment.args {\n-                self.visit_segment_args(path.def, depth, args);\n+                self.visit_segment_args(path.res, depth, args);\n             }\n         }\n     }\n@@ -1360,12 +1360,12 @@ fn object_lifetime_defaults_for_item(\n                         continue;\n                     }\n \n-                    let def = match data.bounded_ty.node {\n-                        hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.def,\n+                    let res = match data.bounded_ty.node {\n+                        hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.res,\n                         _ => continue,\n                     };\n \n-                    if def == Def::TyParam(param_def_id) {\n+                    if res == Res::Def(DefKind::TyParam, param_def_id) {\n                         add_bounds(&mut set, &data.bounds);\n                     }\n                 }\n@@ -1890,7 +1890,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_segment_args(&mut self, def: Def, depth: usize, generic_args: &'tcx hir::GenericArgs) {\n+    fn visit_segment_args(&mut self, res: Res, depth: usize, generic_args: &'tcx hir::GenericArgs) {\n         if generic_args.parenthesized {\n             let was_in_fn_syntax = self.is_in_fn_syntax;\n             self.is_in_fn_syntax = true;\n@@ -1928,14 +1928,16 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 index: def_key.parent.expect(\"missing parent\"),\n             }\n         };\n-        let type_def_id = match def {\n-            Def::AssociatedTy(def_id) if depth == 1 => Some(parent_def_id(self, def_id)),\n-            Def::Variant(def_id) if depth == 0 => Some(parent_def_id(self, def_id)),\n-            Def::Struct(def_id)\n-            | Def::Union(def_id)\n-            | Def::Enum(def_id)\n-            | Def::TyAlias(def_id)\n-            | Def::Trait(def_id) if depth == 0 =>\n+        let type_def_id = match res {\n+            Res::Def(DefKind::AssociatedTy, def_id)\n+                if depth == 1 => Some(parent_def_id(self, def_id)),\n+            Res::Def(DefKind::Variant, def_id)\n+                if depth == 0 => Some(parent_def_id(self, def_id)),\n+            Res::Def(DefKind::Struct, def_id)\n+            | Res::Def(DefKind::Union, def_id)\n+            | Res::Def(DefKind::Enum, def_id)\n+            | Res::Def(DefKind::TyAlias, def_id)\n+            | Res::Def(DefKind::Trait, def_id) if depth == 0 =>\n             {\n                 Some(def_id)\n             }\n@@ -2126,21 +2128,24 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         if has_self {\n             // Look for `self: &'a Self` - also desugared from `&'a self`,\n             // and if that matches, use it for elision and return early.\n-            let is_self_ty = |def: Def| {\n-                if let Def::SelfTy(..) = def {\n+            let is_self_ty = |res: Res| {\n+                if let Res::SelfTy(..) = res {\n                     return true;\n                 }\n \n                 // Can't always rely on literal (or implied) `Self` due\n                 // to the way elision rules were originally specified.\n                 let impl_self = impl_self.map(|ty| &ty.node);\n                 if let Some(&hir::TyKind::Path(hir::QPath::Resolved(None, ref path))) = impl_self {\n-                    match path.def {\n+                    match path.res {\n                         // Whitelist the types that unambiguously always\n                         // result in the same type constructor being used\n                         // (it can't differ between `Self` and `self`).\n-                        Def::Struct(_) | Def::Union(_) | Def::Enum(_) | Def::PrimTy(_) => {\n-                            return def == path.def\n+                        Res::Def(DefKind::Struct, _)\n+                        | Res::Def(DefKind::Union, _)\n+                        | Res::Def(DefKind::Enum, _)\n+                        | Res::PrimTy(_) => {\n+                            return res == path.res\n                         }\n                         _ => {}\n                     }\n@@ -2151,7 +2156,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             if let hir::TyKind::Rptr(lifetime_ref, ref mt) = inputs[0].node {\n                 if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.node {\n-                    if is_self_ty(path.def) {\n+                    if is_self_ty(path.res) {\n                         if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n                             let scope = Scope::Elision {\n                                 elide: Elide::Exact(lifetime),"}, {"sha": "5078bd7c594235b11a25d86a4c3641f7162720ef", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -5,7 +5,7 @@ pub use self::StabilityLevel::*;\n \n use crate::lint::{self, Lint, in_derive_expansion};\n use crate::hir::{self, Item, Generics, StructField, Variant, HirId};\n-use crate::hir::def::Def;\n+use crate::hir::def::{Res, DefKind};\n use crate::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::ty::query::Providers;\n@@ -525,10 +525,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // See issue #38412.\n     fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n         // Check if `def_id` is a trait method.\n-        match self.describe_def(def_id) {\n-            Some(Def::Method(_)) |\n-            Some(Def::AssociatedTy(_)) |\n-            Some(Def::AssociatedConst(_)) => {\n+        match self.def_kind(def_id) {\n+            Some(DefKind::Method) |\n+            Some(DefKind::AssociatedTy) |\n+            Some(DefKind::AssociatedConst) => {\n                 if let ty::TraitContainer(trait_def_id) = self.associated_item(def_id).container {\n                     // Trait methods do not declare visibility (even\n                     // for visibility info in cstore). Use containing\n@@ -779,7 +779,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             // individually as it's possible to have a stable trait with unstable\n             // items.\n             hir::ItemKind::Impl(.., Some(ref t), _, ref impl_item_refs) => {\n-                if let Def::Trait(trait_did) = t.path.def {\n+                if let Res::Def(DefKind::Trait, trait_did) = t.path.res {\n                     for impl_item_ref in impl_item_refs {\n                         let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                         let trait_item_def_id = self.tcx.associated_items(trait_did)\n@@ -820,7 +820,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &'tcx hir::Path, id: hir::HirId) {\n-        if let Some(def_id) = path.def.opt_def_id() {\n+        if let Some(def_id) = path.res.opt_def_id() {\n             self.tcx.check_stability(def_id, Some(id), path.span)\n         }\n         intravisit::walk_path(self, path)"}, {"sha": "e1e115cfe177b6539dc9db6edf551e67a935545c", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -469,7 +469,7 @@ rustc_queries! {\n             cache { true }\n         }\n \n-        query describe_def(_: DefId) -> Option<Def> {}\n+        query def_kind(_: DefId) -> Option<DefKind> {}\n         query def_span(_: DefId) -> Span {\n             // FIXME(mw): DefSpans are not really inputs since they are derived from\n             // HIR. But at the moment HIR hashing still contains some hacks that allow"}, {"sha": "fddae02409126f5f10ec0e86b3be6ed9d8905657", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -10,7 +10,7 @@ use crate::session::config::{BorrowckMode, OutputFilenames};\n use crate::session::config::CrateType;\n use crate::middle;\n use crate::hir::{TraitCandidate, HirId, ItemKind, ItemLocalId, Node};\n-use crate::hir::def::{Def, Export};\n+use crate::hir::def::{Res, DefKind, Export};\n use crate::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use crate::hir::map as hir_map;\n use crate::hir::map::DefPathHash;\n@@ -44,6 +44,7 @@ use crate::ty::steal::Steal;\n use crate::ty::subst::{UserSubsts, UnpackedKind};\n use crate::ty::{BoundVar, BindingMode};\n use crate::ty::CanonicalPolyFnSig;\n+use crate::util::common::ErrorReported;\n use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use errors::DiagnosticBuilder;\n@@ -347,7 +348,7 @@ pub struct TypeckTables<'tcx> {\n \n     /// Resolved definitions for `<T>::X` associated paths and\n     /// method calls, including those of overloaded operators.\n-    type_dependent_defs: ItemLocalMap<Def>,\n+    type_dependent_defs: ItemLocalMap<Result<(DefKind, DefId), ErrorReported>>,\n \n     /// Resolved field indices for field accesses in expressions (`S { field }`, `obj.field`)\n     /// or patterns (`S { field }`). The index is often useful by itself, but to learn more\n@@ -478,33 +479,35 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n-    pub fn qpath_def(&self, qpath: &hir::QPath, id: hir::HirId) -> Def {\n+    pub fn qpath_res(&self, qpath: &hir::QPath, id: hir::HirId) -> Res {\n         match *qpath {\n-            hir::QPath::Resolved(_, ref path) => path.def,\n-            hir::QPath::TypeRelative(..) => {\n-                validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n-                self.type_dependent_defs.get(&id.local_id).cloned().unwrap_or(Def::Err)\n-            }\n+            hir::QPath::Resolved(_, ref path) => path.res,\n+            hir::QPath::TypeRelative(..) => self.type_dependent_def(id)\n+                .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),\n         }\n     }\n \n-    pub fn type_dependent_defs(&self) -> LocalTableInContext<'_, Def> {\n+    pub fn type_dependent_defs(\n+        &self,\n+    ) -> LocalTableInContext<'_, Result<(DefKind, DefId), ErrorReported>> {\n         LocalTableInContext {\n             local_id_root: self.local_id_root,\n             data: &self.type_dependent_defs\n         }\n     }\n \n-    pub fn type_dependent_def(&self, id: HirId) -> Option<Def> {\n+    pub fn type_dependent_def(&self, id: HirId) -> Option<(DefKind, DefId)> {\n         validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n-        self.type_dependent_defs.get(&id.local_id).cloned()\n+        self.type_dependent_defs.get(&id.local_id).cloned().and_then(|r| r.ok())\n     }\n \n     pub fn type_dependent_def_id(&self, id: HirId) -> Option<DefId> {\n-        self.type_dependent_def(id).map(|def| def.def_id())\n+        self.type_dependent_def(id).map(|(_, def_id)| def_id)\n     }\n \n-    pub fn type_dependent_defs_mut(&mut self) -> LocalTableInContextMut<'_, Def> {\n+    pub fn type_dependent_defs_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, Result<(DefKind, DefId), ErrorReported>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n             data: &mut self.type_dependent_defs\n@@ -658,7 +661,7 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n \n         match self.type_dependent_defs().get(expr.hir_id) {\n-            Some(&Def::Method(_)) => true,\n+            Some(Ok((DefKind::Method, _))) => true,\n             _ => false\n         }\n     }"}, {"sha": "ffd34c7cdc30e9456a3b6b9165adf5fe37ae366b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -10,7 +10,7 @@ pub use self::fold::TypeFoldable;\n \n use crate::hir::{map as hir_map, FreevarMap, GlobMap, TraitMap};\n use crate::hir::{HirId, Node};\n-use crate::hir::def::{Def, CtorOf, CtorKind, ExportMap};\n+use crate::hir::def::{Res, DefKind, CtorOf, CtorKind, ExportMap};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_data_structures::svh::Svh;\n use rustc_macros::HashStable;\n@@ -191,12 +191,12 @@ pub enum AssociatedKind {\n }\n \n impl AssociatedItem {\n-    pub fn def(&self) -> Def {\n+    pub fn def_kind(&self) -> DefKind {\n         match self.kind {\n-            AssociatedKind::Const => Def::AssociatedConst(self.def_id),\n-            AssociatedKind::Method => Def::Method(self.def_id),\n-            AssociatedKind::Type => Def::AssociatedTy(self.def_id),\n-            AssociatedKind::Existential => Def::AssociatedExistential(self.def_id),\n+            AssociatedKind::Const => DefKind::AssociatedConst,\n+            AssociatedKind::Method => DefKind::Method,\n+            AssociatedKind::Type => DefKind::AssociatedTy,\n+            AssociatedKind::Existential => DefKind::AssociatedExistential,\n         }\n     }\n \n@@ -269,10 +269,10 @@ impl Visibility {\n         match visibility.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Crate(_) => Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n-            hir::VisibilityKind::Restricted { ref path, .. } => match path.def {\n+            hir::VisibilityKind::Restricted { ref path, .. } => match path.res {\n                 // If there is no resolution, `resolve` will have already reported an error, so\n                 // assume that the visibility is public to avoid reporting more privacy errors.\n-                Def::Err => Visibility::Public,\n+                Res::Err => Visibility::Public,\n                 def => Visibility::Restricted(def.def_id()),\n             },\n             hir::VisibilityKind::Inherited => {\n@@ -812,7 +812,7 @@ pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n \n #[derive(Copy, Clone)]\n pub struct ClosureUpvar<'tcx> {\n-    pub def: Def,\n+    pub res: Res,\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n }\n@@ -2337,14 +2337,14 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             .expect(\"variant_index_with_ctor_id: unknown variant\").0\n     }\n \n-    pub fn variant_of_def(&self, def: Def) -> &VariantDef {\n-        match def {\n-            Def::Variant(vid) => self.variant_with_id(vid),\n-            Def::Ctor(cid, ..) => self.variant_with_ctor_id(cid),\n-            Def::Struct(..) | Def::Union(..) |\n-            Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) |\n-            Def::SelfCtor(..) => self.non_enum_variant(),\n-            _ => bug!(\"unexpected def {:?} in variant_of_def\", def)\n+    pub fn variant_of_res(&self, res: Res) -> &VariantDef {\n+        match res {\n+            Res::Def(DefKind::Variant, vid) => self.variant_with_id(vid),\n+            Res::Def(DefKind::Ctor(..), cid) => self.variant_with_ctor_id(cid),\n+            Res::Def(DefKind::Struct, _) | Res::Def(DefKind::Union, _) |\n+            Res::Def(DefKind::TyAlias, _) | Res::Def(DefKind::AssociatedTy, _) | Res::SelfTy(..) |\n+            Res::SelfCtor(..) => self.non_enum_variant(),\n+            _ => bug!(\"unexpected res {:?} in variant_of_res\", res)\n         }\n     }\n \n@@ -2805,8 +2805,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 _ => false,\n             }\n         } else {\n-            match self.describe_def(def_id).expect(\"no def for def-id\") {\n-                Def::AssociatedConst(_) | Def::Method(_) | Def::AssociatedTy(_) => true,\n+            match self.def_kind(def_id).expect(\"no def for def-id\") {\n+                DefKind::AssociatedConst\n+                | DefKind::Method\n+                | DefKind::AssociatedTy => true,\n                 _ => false,\n             }\n         };\n@@ -2948,27 +2950,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns `ty::VariantDef` if `def` refers to a struct,\n+    /// Returns `ty::VariantDef` if `res` refers to a struct,\n     /// or variant or their constructors, panics otherwise.\n-    pub fn expect_variant_def(self, def: Def) -> &'tcx VariantDef {\n-        match def {\n-            Def::Variant(did) => {\n+    pub fn expect_variant_res(self, res: Res) -> &'tcx VariantDef {\n+        match res {\n+            Res::Def(DefKind::Variant, did) => {\n                 let enum_did = self.parent(did).unwrap();\n                 self.adt_def(enum_did).variant_with_id(did)\n             }\n-            Def::Struct(did) | Def::Union(did) => {\n+            Res::Def(DefKind::Struct, did) | Res::Def(DefKind::Union, did) => {\n                 self.adt_def(did).non_enum_variant()\n             }\n-            Def::Ctor(variant_ctor_did, CtorOf::Variant, ..) => {\n+            Res::Def(DefKind::Ctor(CtorOf::Variant, ..), variant_ctor_did) => {\n                 let variant_did = self.parent(variant_ctor_did).unwrap();\n                 let enum_did = self.parent(variant_did).unwrap();\n                 self.adt_def(enum_did).variant_with_ctor_id(variant_ctor_did)\n             }\n-            Def::Ctor(ctor_did, CtorOf::Struct, ..) => {\n+            Res::Def(DefKind::Ctor(CtorOf::Struct, ..), ctor_did) => {\n                 let struct_did = self.parent(ctor_did).expect(\"struct ctor has no parent\");\n                 self.adt_def(struct_did).non_enum_variant()\n             }\n-            _ => bug!(\"expect_variant_def used with unexpected def {:?}\", def)\n+            _ => bug!(\"expect_variant_res used with unexpected res {:?}\", res)\n         }\n     }\n \n@@ -3044,7 +3046,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// `DefId` of the impl that the method belongs to; otherwise, returns `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         let item = if def_id.krate != LOCAL_CRATE {\n-            if let Some(Def::Method(_)) = self.describe_def(def_id) {\n+            if let Some(DefKind::Method) = self.def_kind(def_id) {\n                 Some(self.associated_item(def_id))\n             } else {\n                 None"}, {"sha": "d10da495ee72b898f0a22d846f26ee4722ef8205", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -359,7 +359,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n             DefPathData::TypeNs(ref mut name) if Some(visible_parent) != actual_parent => {\n                 let reexport = self.tcx().item_children(visible_parent)\n                     .iter()\n-                    .find(|child| child.def.def_id() == def_id)\n+                    .find(|child| child.res.def_id() == def_id)\n                     .map(|child| child.ident.as_interned_str());\n                 if let Some(reexport) = reexport {\n                     *name = reexport;"}, {"sha": "18d575f73645c6f4d2427688b855fffd4185bcbf", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -1,6 +1,6 @@\n use crate::dep_graph::{self, DepNode};\n use crate::hir::def_id::{CrateNum, DefId, DefIndex};\n-use crate::hir::def::{Def, Export};\n+use crate::hir::def::{DefKind, Export};\n use crate::hir::{self, TraitCandidate, ItemLocalId, CodegenFnAttrs};\n use crate::infer::canonical::{self, Canonical};\n use crate::lint;"}, {"sha": "bab9527dd07f6695793a6b641252bef5c8e7c288", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -55,7 +55,7 @@ impl fmt::Debug for ty::AdtDef {\n impl fmt::Debug for ty::ClosureUpvar<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"ClosureUpvar({:?},{:?})\",\n-               self.def,\n+               self.res,\n                self.ty)\n     }\n }\n@@ -302,7 +302,7 @@ CloneTypeFoldableAndLiftImpls! {\n     ::syntax::ast::FloatTy,\n     ::syntax::ast::NodeId,\n     ::syntax_pos::symbol::Symbol,\n-    crate::hir::def::Def,\n+    crate::hir::def::Res,\n     crate::hir::def_id::DefId,\n     crate::hir::InlineAsm,\n     crate::hir::MatchSource,\n@@ -1279,7 +1279,7 @@ TupleStructTypeFoldableImpl! {\n \n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n-        def, span, ty\n+        res, span, ty\n     }\n }\n "}, {"sha": "f70429c22b68c24607543d3440f1dc1634e8181e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -21,7 +21,7 @@\n //! If you define a new `LateLintPass`, you will also need to add it to the\n //! `late_lint_methods!` invocation in `lib.rs`.\n \n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::ty::{self, Ty};\n use rustc::{lint, util};\n@@ -154,7 +154,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n         if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.node {\n             let variant = cx.tables.pat_ty(pat).ty_adt_def()\n                                    .expect(\"struct pattern type is not an ADT\")\n-                                   .variant_of_def(cx.tables.qpath_def(qpath, pat.hir_id));\n+                                   .variant_of_res(cx.tables.qpath_res(qpath, pat.hir_id));\n             for fieldpat in field_pats {\n                 if fieldpat.node.is_shorthand {\n                     continue;\n@@ -404,7 +404,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n-                let real_trait = trait_ref.path.def.def_id();\n+                let real_trait = trait_ref.path.res.def_id();\n                 if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(real_trait) {\n                     match cx.tcx.hir().find_by_hir_id(hir_id) {\n                         Some(Node::Item(item)) => {\n@@ -912,11 +912,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n              expr: &hir::Expr)\n              -> Option<(Ty<'tcx>, Ty<'tcx>)> {\n             let def = if let hir::ExprKind::Path(ref qpath) = expr.node {\n-                cx.tables.qpath_def(qpath, expr.hir_id)\n+                cx.tables.qpath_res(qpath, expr.hir_id)\n             } else {\n                 return None;\n             };\n-            if let Def::Fn(did) = def {\n+            if let Res::Def(DefKind::Fn, did) = def {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n@@ -1071,8 +1071,8 @@ impl TypeAliasBounds {\n                 // If this is a type variable, we found a `T::Assoc`.\n                 match ty.node {\n                     hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n-                        match path.def {\n-                            Def::TyParam(_) => true,\n+                        match path.res {\n+                            Res::Def(DefKind::TyParam, _) => true,\n                             _ => false\n                         }\n                     }"}, {"sha": "7a003d14b2bf059a976c0eaddbd198a1cbc44a8c", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::{self, GenericParamKind, PatKind};\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Res, DefKind};\n use rustc::hir::intravisit::FnKind;\n use rustc::lint;\n use rustc::ty;\n@@ -415,7 +415,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.node {\n-            if let Def::Const(..) = path.def {\n+            if let Res::Def(DefKind::Const, _) = path.res {\n                 if path.segments.len() == 1 {\n                     NonUpperCaseGlobals::check_upper_case(\n                         cx,"}, {"sha": "92508ad51f104fcd4380027a7d54e353ff392461", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -1,4 +1,4 @@\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::DefId;\n use rustc::lint;\n use rustc::ty;\n@@ -87,14 +87,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         let mut fn_warned = false;\n         let mut op_warned = false;\n-        let maybe_def = match expr.node {\n+        let maybe_def_id = match expr.node {\n             hir::ExprKind::Call(ref callee, _) => {\n                 match callee.node {\n                     hir::ExprKind::Path(ref qpath) => {\n-                        let def = cx.tables.qpath_def(qpath, callee.hir_id);\n-                        match def {\n-                            Def::Fn(_) | Def::Method(_) => Some(def),\n-                            // `Def::Local` if it was a closure, for which we\n+                        match cx.tables.qpath_res(qpath, callee.hir_id) {\n+                            Res::Def(DefKind::Fn, def_id)\n+                            | Res::Def(DefKind::Method, def_id) => Some(def_id),\n+                            // `Res::Local` if it was a closure, for which we\n                             // do not currently support must-use linting\n                             _ => None\n                         }\n@@ -103,12 +103,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                 }\n             },\n             hir::ExprKind::MethodCall(..) => {\n-                cx.tables.type_dependent_def(expr.hir_id)\n+                cx.tables.type_dependent_def_id(expr.hir_id)\n             },\n             _ => None\n         };\n-        if let Some(def) = maybe_def {\n-            let def_id = def.def_id();\n+        if let Some(def_id) = maybe_def_id {\n             fn_warned = check_must_use(cx, def_id, s.span, \"return value of \", \"\");\n         } else if type_permits_lack_of_use {\n             // We don't warn about unused unit or uninhabited types."}, {"sha": "dfeaeca323f8e7233c51fae78cf5964bfee74896", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -110,7 +110,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     associated_item_def_ids => {\n         let mut result = vec![];\n         cdata.each_child_of_item(def_id.index,\n-          |child| result.push(child.def.def_id()), tcx.sess);\n+          |child| result.push(child.res.def_id()), tcx.sess);\n         Lrc::new(result)\n     }\n     associated_item => { cdata.get_associated_item(def_id.index) }\n@@ -138,7 +138,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     is_const_fn_raw => { cdata.is_const_fn_raw(def_id.index) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n     static_mutability => { cdata.static_mutability(def_id.index) }\n-    describe_def => { cdata.get_def(def_id.index) }\n+    def_kind => { cdata.def_kind(def_id.index) }\n     def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n     lookup_stability => {\n         cdata.get_stability(def_id.index).map(|s| tcx.intern_stability(s))\n@@ -355,7 +355,7 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n                         return;\n                     }\n \n-                    let child = child.def.def_id();\n+                    let child = child.res.def_id();\n \n                     match visible_parent_map.entry(child) {\n                         Entry::Occupied(mut entry) => {"}, {"sha": "ad28f47ba04443454af54d3080925094d42e4865", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 52, "deletions": 47, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -8,7 +8,7 @@ use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash, Definitions};\n use rustc::hir;\n use rustc::middle::cstore::LinkagePreference;\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n-use rustc::hir::def::{self, Def, CtorOf, CtorKind};\n+use rustc::hir::def::{self, Res, DefKind, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, DefIndexAddressSpace,\n                          CRATE_DEF_INDEX, LOCAL_CRATE, LocalDefId};\n use rustc::hir::map::definitions::DefPathTable;\n@@ -399,32 +399,32 @@ impl<'a, 'tcx> MetadataBlob {\n }\n \n impl<'tcx> EntryKind<'tcx> {\n-    fn to_def(&self, did: DefId) -> Option<Def> {\n+    fn def_kind(&self) -> Option<DefKind> {\n         Some(match *self {\n-            EntryKind::Const(..) => Def::Const(did),\n-            EntryKind::AssociatedConst(..) => Def::AssociatedConst(did),\n+            EntryKind::Const(..) => DefKind::Const,\n+            EntryKind::AssociatedConst(..) => DefKind::AssociatedConst,\n             EntryKind::ImmStatic |\n             EntryKind::MutStatic |\n             EntryKind::ForeignImmStatic |\n-            EntryKind::ForeignMutStatic => Def::Static(did),\n-            EntryKind::Struct(_, _) => Def::Struct(did),\n-            EntryKind::Union(_, _) => Def::Union(did),\n+            EntryKind::ForeignMutStatic => DefKind::Static,\n+            EntryKind::Struct(_, _) => DefKind::Struct,\n+            EntryKind::Union(_, _) => DefKind::Union,\n             EntryKind::Fn(_) |\n-            EntryKind::ForeignFn(_) => Def::Fn(did),\n-            EntryKind::Method(_) => Def::Method(did),\n-            EntryKind::Type => Def::TyAlias(did),\n-            EntryKind::TypeParam => Def::TyParam(did),\n-            EntryKind::ConstParam => Def::ConstParam(did),\n-            EntryKind::Existential => Def::Existential(did),\n-            EntryKind::AssociatedType(_) => Def::AssociatedTy(did),\n-            EntryKind::AssociatedExistential(_) => Def::AssociatedExistential(did),\n-            EntryKind::Mod(_) => Def::Mod(did),\n-            EntryKind::Variant(_) => Def::Variant(did),\n-            EntryKind::Trait(_) => Def::Trait(did),\n-            EntryKind::TraitAlias(_) => Def::TraitAlias(did),\n-            EntryKind::Enum(..) => Def::Enum(did),\n-            EntryKind::MacroDef(_) => Def::Macro(did, MacroKind::Bang),\n-            EntryKind::ForeignType => Def::ForeignTy(did),\n+            EntryKind::ForeignFn(_) => DefKind::Fn,\n+            EntryKind::Method(_) => DefKind::Method,\n+            EntryKind::Type => DefKind::TyAlias,\n+            EntryKind::TypeParam => DefKind::TyParam,\n+            EntryKind::ConstParam => DefKind::ConstParam,\n+            EntryKind::Existential => DefKind::Existential,\n+            EntryKind::AssociatedType(_) => DefKind::AssociatedTy,\n+            EntryKind::AssociatedExistential(_) => DefKind::AssociatedExistential,\n+            EntryKind::Mod(_) => DefKind::Mod,\n+            EntryKind::Variant(_) => DefKind::Variant,\n+            EntryKind::Trait(_) => DefKind::Trait,\n+            EntryKind::TraitAlias(_) => DefKind::TraitAlias,\n+            EntryKind::Enum(..) => DefKind::Enum,\n+            EntryKind::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n+            EntryKind::ForeignType => DefKind::ForeignTy,\n \n             EntryKind::ForeignMod |\n             EntryKind::GlobalAsm |\n@@ -507,12 +507,12 @@ impl<'a, 'tcx> CrateMetadata {\n             .expect(\"no name in item_name\")\n     }\n \n-    pub fn get_def(&self, index: DefIndex) -> Option<Def> {\n+    pub fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n         if !self.is_proc_macro(index) {\n-            self.entry(index).kind.to_def(self.local_def_id(index))\n+            self.entry(index).kind.def_kind()\n         } else {\n             let kind = self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.kind();\n-            Some(Def::Macro(self.local_def_id(index), kind))\n+            Some(DefKind::Macro(kind))\n         }\n     }\n \n@@ -743,17 +743,14 @@ impl<'a, 'tcx> CrateMetadata {\n              */\n             if id == CRATE_DEF_INDEX {\n                 for (id, &(name, ref ext)) in proc_macros.iter().enumerate() {\n-                    let def = Def::Macro(\n-                        DefId {\n-                            krate: self.cnum,\n-                            index: DefIndex::from_proc_macro_index(id),\n-                        },\n-                        ext.kind()\n+                    let res = Res::Def(\n+                        DefKind::Macro(ext.kind()),\n+                        self.local_def_id(DefIndex::from_proc_macro_index(id)),\n                     );\n                     let ident = Ident::with_empty_ctxt(name);\n                     callback(def::Export {\n                         ident: ident,\n-                        def: def,\n+                        res: res,\n                         vis: ty::Visibility::Public,\n                         span: DUMMY_SP,\n                     });\n@@ -789,9 +786,9 @@ impl<'a, 'tcx> CrateMetadata {\n                     // FIXME(eddyb) Don't encode these in children.\n                     EntryKind::ForeignMod => {\n                         for child_index in child.children.decode((self, sess)) {\n-                            if let Some(def) = self.get_def(child_index) {\n+                            if let Some(kind) = self.def_kind(child_index) {\n                                 callback(def::Export {\n-                                    def,\n+                                    res: Res::Def(kind, self.local_def_id(child_index)),\n                                     ident: Ident::from_interned_str(self.item_name(child_index)),\n                                     vis: self.get_visibility(child_index),\n                                     span: self.entry(child_index).span.decode((self, sess)),\n@@ -807,30 +804,38 @@ impl<'a, 'tcx> CrateMetadata {\n \n                 let def_key = self.def_key(child_index);\n                 let span = child.span.decode((self, sess));\n-                if let (Some(def), Some(name)) =\n-                    (self.get_def(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n+                if let (Some(kind), Some(name)) =\n+                    (self.def_kind(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n                     let ident = Ident::from_interned_str(name);\n                     let vis = self.get_visibility(child_index);\n-                    callback(def::Export { def, ident, vis, span });\n+                    let def_id = self.local_def_id(child_index);\n+                    let res = Res::Def(kind, def_id);\n+                    callback(def::Export { res, ident, vis, span });\n                     // For non-re-export structs and variants add their constructors to children.\n                     // Re-export lists automatically contain constructors when necessary.\n-                    match def {\n-                        Def::Struct(..) => {\n+                    match kind {\n+                        DefKind::Struct => {\n                             if let Some(ctor_def_id) = self.get_ctor_def_id(child_index) {\n                                 let ctor_kind = self.get_ctor_kind(child_index);\n-                                let ctor_def = Def::Ctor(ctor_def_id, CtorOf::Struct, ctor_kind);\n+                                let ctor_res = Res::Def(\n+                                    DefKind::Ctor(CtorOf::Struct, ctor_kind),\n+                                    ctor_def_id,\n+                                );\n                                 let vis = self.get_visibility(ctor_def_id.index);\n-                                callback(def::Export { def: ctor_def, vis, ident, span });\n+                                callback(def::Export { res: ctor_res, vis, ident, span });\n                             }\n                         }\n-                        Def::Variant(def_id) => {\n+                        DefKind::Variant => {\n                             // Braced variants, unlike structs, generate unusable names in\n                             // value namespace, they are reserved for possible future use.\n                             // It's ok to use the variant's id as a ctor id since an\n                             // error will be reported on any use of such resolution anyway.\n                             let ctor_def_id = self.get_ctor_def_id(child_index).unwrap_or(def_id);\n                             let ctor_kind = self.get_ctor_kind(child_index);\n-                            let ctor_def = Def::Ctor(ctor_def_id, CtorOf::Variant, ctor_kind);\n+                            let ctor_res = Res::Def(\n+                                DefKind::Ctor(CtorOf::Variant, ctor_kind),\n+                                ctor_def_id,\n+                            );\n                             let mut vis = self.get_visibility(ctor_def_id.index);\n                             if ctor_def_id == def_id && vis == ty::Visibility::Public {\n                                 // For non-exhaustive variants lower the constructor visibility to\n@@ -839,11 +844,11 @@ impl<'a, 'tcx> CrateMetadata {\n                                 // were already encoded in metadata.\n                                 let attrs = self.get_item_attrs(def_id.index, sess);\n                                 if attr::contains_name(&attrs, \"non_exhaustive\") {\n-                                    let crate_def_id = DefId { index: CRATE_DEF_INDEX, ..def_id };\n+                                    let crate_def_id = self.local_def_id(CRATE_DEF_INDEX);\n                                     vis = ty::Visibility::Restricted(crate_def_id);\n                                 }\n                             }\n-                            callback(def::Export { def: ctor_def, ident, vis, span });\n+                            callback(def::Export { res: ctor_res, ident, vis, span });\n                         }\n                         _ => {}\n                     }\n@@ -853,8 +858,8 @@ impl<'a, 'tcx> CrateMetadata {\n \n         if let EntryKind::Mod(data) = item.kind {\n             for exp in data.decode((self, sess)).reexports.decode((self, sess)) {\n-                match exp.def {\n-                    Def::Macro(..) => {}\n+                match exp.res {\n+                    Res::Def(DefKind::Macro(..), _) => {}\n                     _ if macros_only => continue,\n                     _ => {}\n                 }"}, {"sha": "4e197867bfb3ebb092076922939c9f74d0dd3e22", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -4,6 +4,7 @@ use crate::borrow_check::nll::universal_regions::DefiningTy;\n use crate::borrow_check::nll::ToRegionVid;\n use crate::borrow_check::Upvar;\n use rustc::hir;\n+use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::mir::Mir;\n@@ -491,12 +492,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     ty::Adt(_adt_def, substs),\n                     hir::TyKind::Path(hir::QPath::Resolved(None, path)),\n                 ) => {\n-                    match path.def {\n+                    match path.res {\n                         // Type parameters of the type alias have no reason to\n                         // be the same as those of the ADT.\n                         // FIXME: We should be able to do something similar to\n                         // match_adt_and_segment in this case.\n-                        hir::def::Def::TyAlias(_) => (),\n+                        Res::Def(DefKind::TyAlias, _) => (),\n                         _ => if let Some(last_segment) = path.segments.last() {\n                             if let Some(name) = self.match_adt_and_segment(\n                                 substs,"}, {"sha": "866b6492d10bcbfa85cc85f6fe6f3405c11d0988", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -6,7 +6,7 @@ use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n use std::collections::hash_map::Entry;\n \n-use rustc::hir::def::Def;\n+use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n@@ -634,14 +634,14 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n             }\n         } else if def_id.is_local() {\n             // constant defined in this crate, we can figure out a lint level!\n-            match tcx.describe_def(def_id) {\n+            match tcx.def_kind(def_id) {\n                 // constants never produce a hard error at the definition site. Anything else is\n                 // a backwards compatibility hazard (and will break old versions of winapi for sure)\n                 //\n                 // note that validation may still cause a hard error on this very same constant,\n                 // because any code that existed before validation could not have failed validation\n                 // thus preventing such a hard error from being a backwards compatibility hazard\n-                Some(Def::Const(_)) | Some(Def::AssociatedConst(_)) => {\n+                Some(DefKind::Const) | Some(DefKind::AssociatedConst) => {\n                     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                     err.report_as_lint(\n                         tcx.at(tcx.def_span(def_id)),"}, {"sha": "5ac1ccd8fade27629625ce6711eeed39b925d2d7", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 53, "deletions": 49, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -4,7 +4,7 @@ use crate::hair::cx::block;\n use crate::hair::cx::to_ref::ToRef;\n use crate::hair::util::UserAnnotatedTyHelpers;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::hir::def::{CtorOf, Def, CtorKind};\n+use rustc::hir::def::{CtorOf, Res, DefKind, CtorKind};\n use rustc::mir::interpret::{GlobalId, ErrorHandled, ConstValue};\n use rustc::ty::{self, AdtKind, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability, PointerCast};\n@@ -249,10 +249,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 {\n                     // Tuple-like ADTs are represented as ExprKind::Call. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def| {\n-                        match path.def {\n-                            Def::Ctor(ctor_id, _, CtorKind::Fn) =>\n+                        match path.res {\n+                            Res::Def(DefKind::Ctor(_, CtorKind::Fn), ctor_id) =>\n                                 Some((adt_def, adt_def.variant_index_with_ctor_id(ctor_id))),\n-                            Def::SelfCtor(..) => Some((adt_def, VariantIdx::new(0))),\n+                            Res::SelfCtor(..) => Some((adt_def, VariantIdx::new(0))),\n                             _ => None,\n                         }\n                     })\n@@ -468,9 +468,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             }\n                         }\n                         AdtKind::Enum => {\n-                            let def = cx.tables().qpath_def(qpath, expr.hir_id);\n-                            match def {\n-                                Def::Variant(variant_id) => {\n+                            let res = cx.tables().qpath_res(qpath, expr.hir_id);\n+                            match res {\n+                                Res::Def(DefKind::Variant, variant_id) => {\n                                     assert!(base.is_none());\n \n                                     let index = adt.variant_index_with_id(variant_id);\n@@ -491,7 +491,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                     }\n                                 }\n                                 _ => {\n-                                    span_bug!(expr.span, \"unexpected def: {:?}\", def);\n+                                    span_bug!(expr.span, \"unexpected res: {:?}\", res);\n                                 }\n                             }\n                         }\n@@ -531,8 +531,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprKind::Path(ref qpath) => {\n-            let def = cx.tables().qpath_def(qpath, expr.hir_id);\n-            convert_path_expr(cx, expr, def)\n+            let res = cx.tables().qpath_res(qpath, expr.hir_id);\n+            convert_path_expr(cx, expr, res)\n         }\n \n         hir::ExprKind::InlineAsm(ref asm, ref outputs, ref inputs) => {\n@@ -657,14 +657,17 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 // The correct solution would be to add symbolic computations to miri,\n                 // so we wouldn't have to compute and store the actual value\n                 let var = if let hir::ExprKind::Path(ref qpath) = source.node {\n-                    let def = cx.tables().qpath_def(qpath, source.hir_id);\n+                    let res = cx.tables().qpath_res(qpath, source.hir_id);\n                     cx\n                         .tables()\n                         .node_type(source.hir_id)\n                         .ty_adt_def()\n                         .and_then(|adt_def| {\n-                        match def {\n-                            Def::Ctor(variant_ctor_id, CtorOf::Variant, CtorKind::Const) => {\n+                        match res {\n+                            Res::Def(\n+                                DefKind::Ctor(CtorOf::Variant, CtorKind::Const),\n+                                variant_ctor_id,\n+                            ) => {\n                                 let idx = adt_def.variant_index_with_ctor_id(variant_ctor_id);\n                                 let (d, o) = adt_def.discriminant_def_for_variant(idx);\n                                 use rustc::ty::util::IntTypeExt;\n@@ -782,37 +785,38 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     }\n }\n \n-fn user_substs_applied_to_def(\n+fn user_substs_applied_to_res(\n     cx: &mut Cx<'a, 'gcx, 'tcx>,\n     hir_id: hir::HirId,\n-    def: &Def,\n+    res: Res,\n ) -> Option<ty::CanonicalUserType<'tcx>> {\n-    debug!(\"user_substs_applied_to_def: def={:?}\", def);\n-    let user_provided_type = match def {\n+    debug!(\"user_substs_applied_to_res: res={:?}\", res);\n+    let user_provided_type = match res {\n         // A reference to something callable -- e.g., a fn, method, or\n         // a tuple-struct or tuple-variant. This has the type of a\n         // `Fn` but with the user-given substitutions.\n-        Def::Fn(_) |\n-        Def::Method(_) |\n-        Def::Ctor(_, _, CtorKind::Fn) |\n-        Def::Const(_) |\n-        Def::AssociatedConst(_) => cx.tables().user_provided_types().get(hir_id).map(|u_ty| *u_ty),\n+        Res::Def(DefKind::Fn, _) |\n+        Res::Def(DefKind::Method, _) |\n+        Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) |\n+        Res::Def(DefKind::Const, _) |\n+        Res::Def(DefKind::AssociatedConst, _) =>\n+            cx.tables().user_provided_types().get(hir_id).map(|u_ty| *u_ty),\n \n         // A unit struct/variant which is used as a value (e.g.,\n         // `None`). This has the type of the enum/struct that defines\n         // this variant -- but with the substitutions given by the\n         // user.\n-        Def::Ctor(_, _, CtorKind::Const) =>\n+        Res::Def(DefKind::Ctor(_, CtorKind::Const), _) =>\n             cx.user_substs_applied_to_ty_of_hir_id(hir_id),\n \n         // `Self` is used in expression as a tuple struct constructor or an unit struct constructor\n-        Def::SelfCtor(_) =>\n+        Res::SelfCtor(_) =>\n             cx.user_substs_applied_to_ty_of_hir_id(hir_id),\n \n         _ =>\n-            bug!(\"user_substs_applied_to_def: unexpected def {:?} at {:?}\", def, hir_id)\n+            bug!(\"user_substs_applied_to_res: unexpected res {:?} at {:?}\", res, hir_id)\n     };\n-    debug!(\"user_substs_applied_to_def: user_provided_type={:?}\", user_provided_type);\n+    debug!(\"user_substs_applied_to_res: user_provided_type={:?}\", user_provided_type);\n     user_provided_type\n }\n \n@@ -826,13 +830,13 @@ fn method_callee<'a, 'gcx, 'tcx>(\n     let (def_id, substs, user_ty) = match overloaded_callee {\n         Some((def_id, substs)) => (def_id, substs, None),\n         None => {\n-            let def = cx.tables().type_dependent_def(expr.hir_id)\n+            let (kind, def_id) = cx.tables().type_dependent_def(expr.hir_id)\n                 .unwrap_or_else(|| {\n                     span_bug!(expr.span, \"no type-dependent def for method callee\")\n                 });\n-            let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n+            let user_ty = user_substs_applied_to_res(cx, expr.hir_id, Res::Def(kind, def_id));\n             debug!(\"method_callee: user_ty={:?}\", user_ty);\n-            (def.def_id(), cx.tables().node_substs(expr.hir_id), user_ty)\n+            (def_id, cx.tables().node_substs(expr.hir_id), user_ty)\n         }\n     };\n     let ty = cx.tcx().mk_fn_def(def_id, substs);\n@@ -890,16 +894,16 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm)\n \n fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n-                                     def: Def)\n+                                     res: Res)\n                                      -> ExprKind<'tcx> {\n     let substs = cx.tables().node_substs(expr.hir_id);\n-    match def {\n+    match res {\n         // A regular function, constructor function or a constant.\n-        Def::Fn(_) |\n-        Def::Method(_) |\n-        Def::Ctor(_, _, CtorKind::Fn) |\n-        Def::SelfCtor(..) => {\n-            let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n+        Res::Def(DefKind::Fn, _) |\n+        Res::Def(DefKind::Method, _) |\n+        Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) |\n+        Res::SelfCtor(..) => {\n+            let user_ty = user_substs_applied_to_res(cx, expr.hir_id, res);\n             debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n                 literal: cx.tcx.mk_const(ty::Const::zero_sized(\n@@ -909,7 +913,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        Def::ConstParam(def_id) => {\n+        Res::Def(DefKind::ConstParam, def_id) => {\n             let node_id = cx.tcx.hir().as_local_node_id(def_id).unwrap();\n             let item_id = cx.tcx.hir().get_parent_node(node_id);\n             let item_def_id = cx.tcx.hir().local_def_id(item_id);\n@@ -928,9 +932,9 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        Def::Const(def_id) |\n-        Def::AssociatedConst(def_id) => {\n-            let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n+        Res::Def(DefKind::Const, def_id) |\n+        Res::Def(DefKind::AssociatedConst, def_id) => {\n+            let user_ty = user_substs_applied_to_res(cx, expr.hir_id, res);\n             debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n                 literal: cx.tcx.mk_const(ty::Const {\n@@ -941,7 +945,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         },\n \n-        Def::Ctor(def_id, _, CtorKind::Const) => {\n+        Res::Def(DefKind::Ctor(_, CtorKind::Const), def_id) => {\n             let user_provided_types = cx.tables.user_provided_types();\n             let user_provided_type = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n             debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n@@ -963,24 +967,24 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        Def::Static(id) => ExprKind::StaticRef { id },\n+        Res::Def(DefKind::Static, id) => ExprKind::StaticRef { id },\n \n-        Def::Local(..) | Def::Upvar(..) => convert_var(cx, expr, def),\n+        Res::Local(..) | Res::Upvar(..) => convert_var(cx, expr, res),\n \n-        _ => span_bug!(expr.span, \"def `{:?}` not yet implemented\", def),\n+        _ => span_bug!(expr.span, \"res `{:?}` not yet implemented\", res),\n     }\n }\n \n fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                expr: &'tcx hir::Expr,\n-                               def: Def)\n+                               res: Res)\n                                -> ExprKind<'tcx> {\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n-    match def {\n-        Def::Local(id) => ExprKind::VarRef { id },\n+    match res {\n+        Res::Local(id) => ExprKind::VarRef { id },\n \n-        Def::Upvar(var_hir_id, index, closure_expr_id) => {\n+        Res::Upvar(var_hir_id, index, closure_expr_id) => {\n             debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\",\n                    var_hir_id,\n                    index,\n@@ -1198,7 +1202,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         temp_lifetime,\n         ty: var_ty,\n         span: closure_expr.span,\n-        kind: convert_var(cx, closure_expr, freevar.def),\n+        kind: convert_var(cx, closure_expr, freevar.res),\n     };\n     match upvar_capture {\n         ty::UpvarCapture::ByValue => captured_var.to_ref(),"}, {"sha": "b08499b981cd7060ccbfd43858e206f42829a637", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -286,7 +286,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 PatKind::Path(hir::QPath::Resolved(None, ref path))\n                         if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n                     format!(\"interpreted as {} {} pattern, not new variable\",\n-                            path.def.article(), path.def.kind_name())\n+                            path.res.article(), path.res.kind_name())\n                 }\n                 _ => format!(\"pattern `{}` not covered\", pattern_string),\n             };"}, {"sha": "01b1780a2054fb8752203ac1ed65d4f1c2b86706", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTyp\n use rustc::ty::subst::{SubstsRef, Kind};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir::{self, PatKind, RangeEnd};\n-use rustc::hir::def::{CtorOf, Def, CtorKind};\n+use rustc::hir::def::{CtorOf, Res, DefKind, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -599,7 +599,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n-                let def = self.tables.qpath_def(qpath, pat.hir_id);\n+                let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 let adt_def = match ty.sty {\n                     ty::Adt(adt_def, _) => adt_def,\n                     ty::Error => { // Avoid ICE (#50585)\n@@ -609,7 +609,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                    \"tuple struct pattern not applied to an ADT {:?}\",\n                                    ty),\n                 };\n-                let variant_def = adt_def.variant_of_def(def);\n+                let variant_def = adt_def.variant_of_res(res);\n \n                 let subpatterns =\n                         subpatterns.iter()\n@@ -620,11 +620,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                    })\n                     .collect();\n \n-                self.lower_variant_or_leaf(def, pat.hir_id, pat.span, ty, subpatterns)\n+                self.lower_variant_or_leaf(res, pat.hir_id, pat.span, ty, subpatterns)\n             }\n \n             PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tables.qpath_def(qpath, pat.hir_id);\n+                let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 let subpatterns =\n                     fields.iter()\n                           .map(|field| {\n@@ -636,7 +636,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                           })\n                           .collect();\n \n-                self.lower_variant_or_leaf(def, pat.hir_id, pat.span, ty, subpatterns)\n+                self.lower_variant_or_leaf(res, pat.hir_id, pat.span, ty, subpatterns)\n             }\n         };\n \n@@ -726,22 +726,22 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n     fn lower_variant_or_leaf(\n         &mut self,\n-        def: Def,\n+        res: Res,\n         hir_id: hir::HirId,\n         span: Span,\n         ty: Ty<'tcx>,\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     ) -> PatternKind<'tcx> {\n-        let def = match def {\n-            Def::Ctor(variant_ctor_id, CtorOf::Variant, ..) => {\n+        let res = match res {\n+            Res::Def(DefKind::Ctor(CtorOf::Variant, ..), variant_ctor_id) => {\n                 let variant_id = self.tcx.parent(variant_ctor_id).unwrap();\n-                Def::Variant(variant_id)\n+                Res::Def(DefKind::Variant, variant_id)\n             },\n-            def => def,\n+            res => res,\n         };\n \n-        let mut kind = match def {\n-            Def::Variant(variant_id) => {\n+        let mut kind = match res {\n+            Res::Def(DefKind::Variant, variant_id) => {\n                 let enum_id = self.tcx.parent(variant_id).unwrap();\n                 let adt_def = self.tcx.adt_def(enum_id);\n                 if adt_def.is_enum() {\n@@ -764,8 +764,13 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n \n-            Def::Struct(..) | Def::Ctor(_, CtorOf::Struct, ..) | Def::Union(..) |\n-            Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) | Def::SelfCtor(..) => {\n+            Res::Def(DefKind::Struct, _)\n+            | Res::Def(DefKind::Ctor(CtorOf::Struct, ..), _)\n+            | Res::Def(DefKind::Union, _)\n+            | Res::Def(DefKind::TyAlias, _)\n+            | Res::Def(DefKind::AssociatedTy, _)\n+            | Res::SelfTy(..)\n+            | Res::SelfCtor(..) => {\n                 PatternKind::Leaf { subpatterns }\n             }\n \n@@ -803,13 +808,13 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                   span: Span)\n                   -> Pattern<'tcx> {\n         let ty = self.tables.node_type(id);\n-        let def = self.tables.qpath_def(qpath, id);\n-        let is_associated_const = match def {\n-            Def::AssociatedConst(_) => true,\n+        let res = self.tables.qpath_res(qpath, id);\n+        let is_associated_const = match res {\n+            Res::Def(DefKind::AssociatedConst, _) => true,\n             _ => false,\n         };\n-        let kind = match def {\n-            Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n+        let kind = match res {\n+            Res::Def(DefKind::Const, def_id) | Res::Def(DefKind::AssociatedConst, def_id) => {\n                 let substs = self.tables.node_substs(id);\n                 match ty::Instance::resolve(\n                     self.tcx,\n@@ -871,7 +876,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     },\n                 }\n             }\n-            _ => self.lower_variant_or_leaf(def, id, span, ty, vec![]),\n+            _ => self.lower_variant_or_leaf(res, id, span, ty, vec![]),\n         };\n \n         Pattern {"}, {"sha": "ad4bc6a91f5a179d9aba993ca1171c45853c0d41", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -4,7 +4,7 @@ use std::mem;\n \n use syntax::source_map::{self, Span, DUMMY_SP};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::def::Def;\n+use rustc::hir::def::DefKind;\n use rustc::mir;\n use rustc::ty::layout::{\n     self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n@@ -501,9 +501,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n             // entry in `locals` should never be used. Make it dead, to be sure.\n             locals[mir::RETURN_PLACE].value = LocalValue::Dead;\n             // Now mark those locals as dead that we do not want to initialize\n-            match self.tcx.describe_def(instance.def_id()) {\n+            match self.tcx.def_kind(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n-                Some(Def::Static(..)) | Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {},\n+                Some(DefKind::Static)\n+                | Some(DefKind::Const)\n+                | Some(DefKind::AssociatedConst) => {},\n                 _ => {\n                     trace!(\"push_stack_frame: {:?}: num_bbs: {}\", span, mir.basic_blocks().len());\n                     for block in mir.basic_blocks() {"}, {"sha": "72af02782010679c81cfa69e822e967c049515bb", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -1,7 +1,7 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use rustc::hir::def::Def;\n+use rustc::hir::def::DefKind;\n use rustc::mir::{\n     Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Local,\n     NullOp, UnOp, StatementKind, Statement, LocalKind, Static, StaticKind,\n@@ -42,8 +42,8 @@ impl MirPass for ConstProp {\n                               .expect(\"Non-local call to local provider is_const_fn\");\n \n         let is_fn_like = FnLikeNode::from_node(tcx.hir().get_by_hir_id(hir_id)).is_some();\n-        let is_assoc_const = match tcx.describe_def(source.def_id()) {\n-            Some(Def::AssociatedConst(_)) => true,\n+        let is_assoc_const = match tcx.def_kind(source.def_id()) {\n+            Some(DefKind::AssociatedConst) => true,\n             _ => false,\n         };\n "}, {"sha": "94259fa523ccdf018bb7667074abfec1953a8978", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -575,22 +575,25 @@ fn write_mir_sig(\n     mir: &Mir<'_>,\n     w: &mut dyn Write,\n ) -> io::Result<()> {\n-    use rustc::hir::def::Def;\n+    use rustc::hir::def::DefKind;\n \n     trace!(\"write_mir_sig: {:?}\", src.instance);\n-    let descr = tcx.describe_def(src.def_id());\n-    let is_function = match descr {\n-        Some(Def::Fn(_)) | Some(Def::Method(_)) | Some(Def::Ctor(..)) => true,\n+    let kind = tcx.def_kind(src.def_id());\n+    let is_function = match kind {\n+        Some(DefKind::Fn)\n+        | Some(DefKind::Method)\n+        | Some(DefKind::Ctor(..)) => true,\n         _ => tcx.is_closure(src.def_id()),\n     };\n-    match (descr, src.promoted) {\n+    match (kind, src.promoted) {\n         (_, Some(i)) => write!(w, \"{:?} in \", i)?,\n-        (Some(Def::Const(_)), _) | (Some(Def::AssociatedConst(_)), _) => write!(w, \"const \")?,\n-        (Some(Def::Static(def_id)), _) =>\n-            write!(w, \"static {}\", if tcx.is_mutable_static(def_id) { \"mut \" } else { \"\" })?,\n+        (Some(DefKind::Const), _)\n+        | (Some(DefKind::AssociatedConst), _) => write!(w, \"const \")?,\n+        (Some(DefKind::Static), _) =>\n+            write!(w, \"static {}\", if tcx.is_mutable_static(src.def_id()) { \"mut \" } else { \"\" })?,\n         (_, _) if is_function => write!(w, \"fn \")?,\n         (None, _) => {}, // things like anon const, not an item\n-        _ => bug!(\"Unexpected def description {:?}\", descr),\n+        _ => bug!(\"Unexpected def kind {:?}\", kind),\n     }\n \n     ty::print::with_forced_impl_filename_line(|| {"}, {"sha": "b6e2aacd55954b7c8e056ccca30b4d48119464b5", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -15,7 +15,7 @@\n // by borrowck::gather_loans\n \n use rustc::ty::cast::CastTy;\n-use rustc::hir::def::{Def, CtorKind};\n+use rustc::hir::def::{Res, DefKind, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n@@ -319,16 +319,19 @@ fn check_expr_kind<'a, 'tcx>(\n             }\n         }\n         hir::ExprKind::Path(ref qpath) => {\n-            let def = v.tables.qpath_def(qpath, e.hir_id);\n-            match def {\n-                Def::Ctor(..) | Def::Fn(..) | Def::Method(..) | Def::SelfCtor(..) =>\n+            let res = v.tables.qpath_res(qpath, e.hir_id);\n+            match res {\n+                Res::Def(DefKind::Ctor(..), _)\n+                | Res::Def(DefKind::Fn, _)\n+                | Res::Def(DefKind::Method, _)\n+                | Res::SelfCtor(..) =>\n                     Promotable,\n \n                 // References to a static that are themselves within a static\n                 // are inherently promotable with the exception\n                 //  of \"#[thread_local]\" statics, which may not\n                 // outlive the current function\n-                Def::Static(did) => {\n+                Res::Def(DefKind::Static, did) => {\n \n                     if v.in_static {\n                         for attr in &v.tcx.get_attrs(did)[..] {\n@@ -346,8 +349,8 @@ fn check_expr_kind<'a, 'tcx>(\n                     }\n                 }\n \n-                Def::Const(did) |\n-                Def::AssociatedConst(did) => {\n+                Res::Def(DefKind::Const, did) |\n+                Res::Def(DefKind::AssociatedConst, did) => {\n                     let promotable = if v.tcx.trait_of_item(did).is_some() {\n                         // Don't peek inside trait associated constants.\n                         NotPromotable\n@@ -381,15 +384,15 @@ fn check_expr_kind<'a, 'tcx>(\n             }\n             // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n             let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n-                v.tables.qpath_def(qpath, callee.hir_id)\n+                v.tables.qpath_res(qpath, callee.hir_id)\n             } else {\n-                Def::Err\n+                Res::Err\n             };\n             let def_result = match def {\n-                Def::Ctor(_, _, CtorKind::Fn) |\n-                Def::SelfCtor(..) => Promotable,\n-                Def::Fn(did) => v.handle_const_fn_call(did),\n-                Def::Method(did) => {\n+                Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) |\n+                Res::SelfCtor(..) => Promotable,\n+                Res::Def(DefKind::Fn, did) => v.handle_const_fn_call(did),\n+                Res::Def(DefKind::Method, did) => {\n                     match v.tcx.associated_item(did).container {\n                         ty::ImplContainer(_) => v.handle_const_fn_call(did),\n                         ty::TraitContainer(_) => NotPromotable,"}, {"sha": "e561b387389e7dd244d34c67e79d17b0b5d81706", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -12,7 +12,7 @@\n \n use rustc::bug;\n use rustc::hir::{self, Node, PatKind, AssociatedItemKind};\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n@@ -234,7 +234,7 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                         Node::Item(item) => match &item.node {\n                             hir::ItemKind::Impl(.., None, _, _) => &impl_item.vis,\n                             hir::ItemKind::Impl(.., Some(trait_ref), _, _)\n-                                => return def_id_visibility(tcx, trait_ref.path.def.def_id()),\n+                                => return def_id_visibility(tcx, trait_ref.path.res.def_id()),\n                             kind => bug!(\"unexpected item kind: {:?}\", kind),\n                         }\n                         node => bug!(\"unexpected node kind: {:?}\", node),\n@@ -472,7 +472,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     /// to update the visibility of the intermediate use so that it isn't linted\n     /// by `unreachable_pub`.\n     ///\n-    /// This isn't trivial as `path.def` has the `DefId` of the eventual target\n+    /// This isn't trivial as `path.res` has the `DefId` of the eventual target\n     /// of the use statement not of the next intermediate use statement.\n     ///\n     /// To do this, consider the last two segments of the path to our intermediate\n@@ -485,8 +485,8 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     /// namespaces. See <https://github.com/rust-lang/rust/pull/57922#discussion_r251234202>.\n     fn update_visibility_of_intermediate_use_statements(&mut self, segments: &[hir::PathSegment]) {\n         if let Some([module, segment]) = segments.rchunks_exact(2).next() {\n-            if let Some(item) = module.def\n-                .and_then(|def| def.mod_def_id())\n+            if let Some(item) = module.res\n+                .and_then(|res| res.mod_def_id())\n                 .and_then(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n                 .map(|module_hir_id| self.tcx.hir().expect_item_by_hir_id(module_hir_id))\n              {\n@@ -717,7 +717,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             if let Some(exports) = self.tcx.module_exports(def_id) {\n                 for export in exports.iter() {\n                     if export.vis == ty::Visibility::Public {\n-                        if let Some(def_id) = export.def.opt_def_id() {\n+                        if let Some(def_id) = export.res.opt_def_id() {\n                             if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n                                 self.update(hir_id, Some(AccessLevel::Exported));\n                             }\n@@ -762,7 +762,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             let def_id = self.tcx.hir().local_def_id_from_hir_id(module_id);\n             if let Some(exports) = self.tcx.module_exports(def_id) {\n                 for export in exports.iter() {\n-                    if let Some(hir_id) = self.tcx.hir().as_local_hir_id(export.def.def_id()) {\n+                    if let Some(hir_id) = self.tcx.hir().as_local_hir_id(export.res.def_id()) {\n                         self.update(hir_id, level);\n                     }\n                 }\n@@ -900,9 +900,9 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprKind::Struct(ref qpath, ref fields, ref base) => {\n-                let def = self.tables.qpath_def(qpath, expr.hir_id);\n+                let res = self.tables.qpath_res(qpath, expr.hir_id);\n                 let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n-                let variant = adt.variant_of_def(def);\n+                let variant = adt.variant_of_res(res);\n                 if let Some(ref base) = *base {\n                     // If the expression uses FRU we need to make sure all the unmentioned fields\n                     // are checked for privacy (RFC 736). Rather than computing the set of\n@@ -934,9 +934,9 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         match pat.node {\n             PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tables.qpath_def(qpath, pat.hir_id);\n+                let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n-                let variant = adt.variant_of_def(def);\n+                let variant = adt.variant_of_res(res);\n                 for field in fields {\n                     let use_ctxt = field.node.ident.span;\n                     let index = self.tcx.field_index(field.node.hir_id, self.tables);\n@@ -1105,26 +1105,30 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     // more code internal visibility at link time. (Access to private functions\n     // is already prohibited by type privacy for function types.)\n     fn visit_qpath(&mut self, qpath: &'tcx hir::QPath, id: hir::HirId, span: Span) {\n-        let def = match *qpath {\n-            hir::QPath::Resolved(_, ref path) => match path.def {\n-                Def::Method(..) | Def::AssociatedConst(..) |\n-                Def::AssociatedTy(..) | Def::AssociatedExistential(..) |\n-                Def::Static(..) => Some(path.def),\n-                _ => None,\n-            }\n-            hir::QPath::TypeRelative(..) => {\n-                self.tables.type_dependent_def(id)\n-            }\n+        let def = match self.tables.qpath_res(qpath, id) {\n+            Res::Def(kind, def_id) => Some((kind, def_id)),\n+            _ => None,\n         };\n-        if let Some(def) = def {\n-            let def_id = def.def_id();\n-            let is_local_static = if let Def::Static(..) = def { def_id.is_local() } else { false };\n+        let def = def.filter(|(kind, _)| {\n+            match kind {\n+                DefKind::Method\n+                | DefKind::AssociatedConst\n+                | DefKind::AssociatedTy\n+                | DefKind::AssociatedExistential\n+                | DefKind::Static => true,\n+                _ => false,\n+            }\n+        });\n+        if let Some((kind, def_id)) = def {\n+            let is_local_static = if let DefKind::Static = kind {\n+                def_id.is_local()\n+            } else { false };\n             if !self.item_is_accessible(def_id) && !is_local_static {\n                 let name = match *qpath {\n                     hir::QPath::Resolved(_, ref path) => path.to_string(),\n                     hir::QPath::TypeRelative(_, ref segment) => segment.ident.to_string(),\n                 };\n-                let msg = format!(\"{} `{}` is private\", def.kind_name(), name);\n+                let msg = format!(\"{} `{}` is private\", kind.descr(), name);\n                 self.tcx.sess.span_err(span, &msg);\n                 return;\n             }\n@@ -1227,9 +1231,9 @@ struct ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n \n impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn path_is_private_type(&self, path: &hir::Path) -> bool {\n-        let did = match path.def {\n-            Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => return false,\n-            def => def.def_id(),\n+        let did = match path.res {\n+            Res::PrimTy(..) | Res::SelfTy(..) | Res::Err => return false,\n+            res => res.def_id(),\n         };\n \n         // A path can only be private if:\n@@ -1349,7 +1353,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                 let not_private_trait =\n                     trait_ref.as_ref().map_or(true, // no trait counts as public trait\n                                               |tr| {\n-                        let did = tr.path.def.def_id();\n+                        let did = tr.path.res.def_id();\n \n                         if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n                             self.trait_is_public(hir_id)"}, {"sha": "3c5760c746fc3dea4faa3f0bb154730376614726", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 99, "deletions": 82, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -44,7 +44,7 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use log::debug;\n \n-type Def = def::Def<NodeId>;\n+type Res = def::Res<NodeId>;\n \n impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n@@ -58,10 +58,10 @@ impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) {\n     }\n }\n \n-impl<'a> ToNameBinding<'a> for (Def, ty::Visibility, Span, Mark) {\n+impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, Mark) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Def(self.0, false),\n+            kind: NameBindingKind::Res(self.0, false),\n             ambiguity: None,\n             vis: self.1,\n             span: self.2,\n@@ -72,10 +72,10 @@ impl<'a> ToNameBinding<'a> for (Def, ty::Visibility, Span, Mark) {\n \n pub(crate) struct IsMacroExport;\n \n-impl<'a> ToNameBinding<'a> for (Def, ty::Visibility, Span, Mark, IsMacroExport) {\n+impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, Mark, IsMacroExport) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Def(self.0, true),\n+            kind: NameBindingKind::Res(self.0, true),\n             ambiguity: None,\n             vis: self.1,\n             span: self.2,\n@@ -193,7 +193,7 @@ impl<'a> Resolver<'a> {\n                     if source.ident.name == keywords::DollarCrate.name() && module_path.is_empty() {\n                         let crate_root = self.resolve_crate_root(source.ident);\n                         let crate_name = match crate_root.kind {\n-                            ModuleKind::Def(_, name) => name,\n+                            ModuleKind::Def(.., name) => name,\n                             ModuleKind::Block(..) => unreachable!(),\n                         };\n                         // HACK(eddyb) unclear how good this is, but keeping `$crate`\n@@ -424,7 +424,7 @@ impl<'a> Resolver<'a> {\n \n             ItemKind::Mod(..) => {\n                 let def_id = self.definitions.local_def_id(item.id);\n-                let module_kind = ModuleKind::Def(Def::Mod(def_id), ident.name);\n+                let module_kind = ModuleKind::Def(DefKind::Mod, def_id, ident.name);\n                 let module = self.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n@@ -443,49 +443,55 @@ impl<'a> Resolver<'a> {\n \n             // These items live in the value namespace.\n             ItemKind::Static(..) => {\n-                let def = Def::Static(self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n+                let res = Res::Def(DefKind::Static, self.definitions.local_def_id(item.id));\n+                self.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n-                let def = Def::Const(self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n+                let res = Res::Def(DefKind::Const, self.definitions.local_def_id(item.id));\n+                self.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Fn(..) => {\n-                let def = Def::Fn(self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n+                let res = Res::Def(DefKind::Fn, self.definitions.local_def_id(item.id));\n+                self.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n \n                 // Functions introducing procedural macros reserve a slot\n                 // in the macro namespace as well (see #52225).\n                 if attr::contains_name(&item.attrs, \"proc_macro\") ||\n                    attr::contains_name(&item.attrs, \"proc_macro_attribute\") {\n-                    let def = Def::Macro(def.def_id(), MacroKind::ProcMacroStub);\n-                    self.define(parent, ident, MacroNS, (def, vis, sp, expansion));\n+                    let res = Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), res.def_id());\n+                    self.define(parent, ident, MacroNS, (res, vis, sp, expansion));\n                 }\n                 if let Some(attr) = attr::find_by_name(&item.attrs, \"proc_macro_derive\") {\n                     if let Some(trait_attr) =\n                             attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n                         if let Some(ident) = trait_attr.ident() {\n-                            let def = Def::Macro(def.def_id(), MacroKind::ProcMacroStub);\n-                            self.define(parent, ident, MacroNS, (def, vis, ident.span, expansion));\n+                            let res = Res::Def(\n+                                DefKind::Macro(MacroKind::ProcMacroStub),\n+                                res.def_id(),\n+                            );\n+                            self.define(parent, ident, MacroNS, (res, vis, ident.span, expansion));\n                         }\n                     }\n                 }\n             }\n \n             // These items live in the type namespace.\n             ItemKind::Ty(..) => {\n-                let def = Def::TyAlias(self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n+                let res = Res::Def(DefKind::TyAlias, self.definitions.local_def_id(item.id));\n+                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             ItemKind::Existential(_, _) => {\n-                let def = Def::Existential(self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n+                let res = Res::Def(DefKind::Existential, self.definitions.local_def_id(item.id));\n+                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             ItemKind::Enum(ref enum_definition, _) => {\n-                let def = Def::Enum(self.definitions.local_def_id(item.id));\n-                let module_kind = ModuleKind::Def(def, ident.name);\n+                let module_kind = ModuleKind::Def(\n+                    DefKind::Enum,\n+                    self.definitions.local_def_id(item.id),\n+                    ident.name,\n+                );\n                 let module = self.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n@@ -499,16 +505,16 @@ impl<'a> Resolver<'a> {\n             }\n \n             ItemKind::TraitAlias(..) => {\n-                let def = Def::TraitAlias(self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n+                let res = Res::Def(DefKind::TraitAlias, self.definitions.local_def_id(item.id));\n+                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             // These items live in both the type and value namespaces.\n             ItemKind::Struct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n                 let def_id = self.definitions.local_def_id(item.id);\n-                let def = Def::Struct(def_id);\n-                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n+                let res = Res::Def(DefKind::Struct, def_id);\n+                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n                 let mut ctor_vis = vis;\n \n@@ -534,17 +540,18 @@ impl<'a> Resolver<'a> {\n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n                 if let Some(ctor_node_id) = struct_def.ctor_id() {\n-                    let ctor_def = Def::Ctor(self.definitions.local_def_id(ctor_node_id),\n-                                             CtorOf::Struct,\n-                                             CtorKind::from_ast(struct_def));\n-                    self.define(parent, ident, ValueNS, (ctor_def, ctor_vis, sp, expansion));\n-                    self.struct_constructors.insert(def.def_id(), (ctor_def, ctor_vis));\n+                    let ctor_res = Res::Def(\n+                        DefKind::Ctor(CtorOf::Struct, CtorKind::from_ast(struct_def)),\n+                        self.definitions.local_def_id(ctor_node_id),\n+                    );\n+                    self.define(parent, ident, ValueNS, (ctor_res, ctor_vis, sp, expansion));\n+                    self.struct_constructors.insert(res.def_id(), (ctor_res, ctor_vis));\n                 }\n             }\n \n             ItemKind::Union(ref vdata, _) => {\n-                let def = Def::Union(self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n+                let res = Res::Def(DefKind::Union, self.definitions.local_def_id(item.id));\n+                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n                 let field_names = vdata.fields().iter().filter_map(|field| {\n@@ -561,7 +568,7 @@ impl<'a> Resolver<'a> {\n                 let def_id = self.definitions.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n-                let module_kind = ModuleKind::Def(Def::Trait(def_id), ident.name);\n+                let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n                 let module = self.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n@@ -586,8 +593,8 @@ impl<'a> Resolver<'a> {\n \n         // Define a name in the type namespace.\n         let def_id = self.definitions.local_def_id(variant.node.id);\n-        let def = Def::Variant(def_id);\n-        self.define(parent, ident, TypeNS, (def, vis, variant.span, expansion));\n+        let res = Res::Def(DefKind::Variant, def_id);\n+        self.define(parent, ident, TypeNS, (res, vis, variant.span, expansion));\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the\n         // crate.\n@@ -605,27 +612,27 @@ impl<'a> Resolver<'a> {\n         let ctor_node_id = variant.node.data.ctor_id().unwrap_or(variant.node.id);\n         let ctor_def_id = self.definitions.local_def_id(ctor_node_id);\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n-        let ctor_def = Def::Ctor(ctor_def_id, CtorOf::Variant, ctor_kind);\n-        self.define(parent, ident, ValueNS, (ctor_def, ctor_vis, variant.span, expansion));\n+        let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n+        self.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expansion));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expansion: Mark) {\n-        let (def, ns) = match item.node {\n+        let (res, ns) = match item.node {\n             ForeignItemKind::Fn(..) => {\n-                (Def::Fn(self.definitions.local_def_id(item.id)), ValueNS)\n+                (Res::Def(DefKind::Fn, self.definitions.local_def_id(item.id)), ValueNS)\n             }\n             ForeignItemKind::Static(..) => {\n-                (Def::Static(self.definitions.local_def_id(item.id)), ValueNS)\n+                (Res::Def(DefKind::Static, self.definitions.local_def_id(item.id)), ValueNS)\n             }\n             ForeignItemKind::Ty => {\n-                (Def::ForeignTy(self.definitions.local_def_id(item.id)), TypeNS)\n+                (Res::Def(DefKind::ForeignTy, self.definitions.local_def_id(item.id)), TypeNS)\n             }\n             ForeignItemKind::Macro(_) => unreachable!(),\n         };\n         let parent = self.current_module;\n         let vis = self.resolve_visibility(&item.vis);\n-        self.define(parent, item.ident, ns, (def, vis, item.span, expansion));\n+        self.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block, expansion: Mark) {\n@@ -642,45 +649,53 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_def(\n+    fn build_reduced_graph_for_external_crate_res(\n         &mut self,\n         parent: Module<'a>,\n         child: Export<ast::NodeId>,\n     ) {\n-        let Export { ident, def, vis, span } = child;\n+        let Export { ident, res, vis, span } = child;\n         // FIXME: We shouldn't create the gensym here, it should come from metadata,\n         // but metadata cannot encode gensyms currently, so we create it here.\n         // This is only a guess, two equivalent idents may incorrectly get different gensyms here.\n         let ident = ident.gensym_if_underscore();\n         let expansion = Mark::root(); // FIXME(jseyfried) intercrate hygiene\n-        match def {\n-            Def::Mod(def_id) | Def::Enum(def_id) => {\n+        match res {\n+            Res::Def(kind @ DefKind::Mod, def_id)\n+            | Res::Def(kind @ DefKind::Enum, def_id) => {\n                 let module = self.new_module(parent,\n-                                             ModuleKind::Def(def, ident.name),\n+                                             ModuleKind::Def(kind, def_id, ident.name),\n                                              def_id,\n                                              expansion,\n                                              span);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n             }\n-            Def::Variant(..) | Def::TyAlias(..) | Def::ForeignTy(..) | Def::Existential(..) |\n-            Def::TraitAlias(..) | Def::PrimTy(..) | Def::ToolMod => {\n-                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n+            Res::Def(DefKind::Variant, _)\n+            | Res::Def(DefKind::TyAlias, _)\n+            | Res::Def(DefKind::ForeignTy, _)\n+            | Res::Def(DefKind::Existential, _)\n+            | Res::Def(DefKind::TraitAlias, _)\n+            | Res::PrimTy(..)\n+            | Res::ToolMod => {\n+                self.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n             }\n-            Def::Fn(..) | Def::Static(..) | Def::Const(..) |\n-            Def::Ctor(_, CtorOf::Variant, ..) => {\n-                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n+            Res::Def(DefKind::Fn, _)\n+            | Res::Def(DefKind::Static, _)\n+            | Res::Def(DefKind::Const, _)\n+            | Res::Def(DefKind::Ctor(CtorOf::Variant, ..), _) => {\n+                self.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n             }\n-            Def::Ctor(def_id, CtorOf::Struct, ..) => {\n-                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n+            Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n+                self.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n \n                 if let Some(struct_def_id) =\n                         self.cstore.def_key(def_id).parent\n                             .map(|index| DefId { krate: def_id.krate, index: index }) {\n-                    self.struct_constructors.insert(struct_def_id, (def, vis));\n+                    self.struct_constructors.insert(struct_def_id, (res, vis));\n                 }\n             }\n-            Def::Trait(def_id) => {\n-                let module_kind = ModuleKind::Def(def, ident.name);\n+            Res::Def(DefKind::Trait, def_id) => {\n+                let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n                 let module = self.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n@@ -689,29 +704,31 @@ impl<'a> Resolver<'a> {\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n \n                 for child in self.cstore.item_children_untracked(def_id, self.session) {\n-                    let def = child.def.map_id(|_| panic!(\"unexpected id\"));\n-                    let ns = if let Def::AssociatedTy(..) = def { TypeNS } else { ValueNS };\n+                    let res = child.res.map_id(|_| panic!(\"unexpected id\"));\n+                    let ns = if let Res::Def(DefKind::AssociatedTy, _) = res {\n+                        TypeNS\n+                    } else { ValueNS };\n                     self.define(module, child.ident, ns,\n-                                (def, ty::Visibility::Public, DUMMY_SP, expansion));\n+                                (res, ty::Visibility::Public, DUMMY_SP, expansion));\n \n-                    if self.cstore.associated_item_cloned_untracked(child.def.def_id())\n+                    if self.cstore.associated_item_cloned_untracked(child.res.def_id())\n                            .method_has_self_argument {\n-                        self.has_self.insert(def.def_id());\n+                        self.has_self.insert(res.def_id());\n                     }\n                 }\n                 module.populated.set(true);\n             }\n-            Def::Struct(def_id) | Def::Union(def_id) => {\n-                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n+            Res::Def(DefKind::Struct, def_id) | Res::Def(DefKind::Union, def_id) => {\n+                self.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n \n                 // Record field names for error reporting.\n                 let field_names = self.cstore.struct_field_names_untracked(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n-            Def::Macro(..) | Def::NonMacroAttr(..) => {\n-                self.define(parent, ident, MacroNS, (def, vis, DUMMY_SP, expansion));\n+            Res::Def(DefKind::Macro(..), _) | Res::NonMacroAttr(..) => {\n+                self.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion));\n             }\n-            _ => bug!(\"unexpected definition: {:?}\", def)\n+            _ => bug!(\"unexpected resolution: {:?}\", res)\n         }\n     }\n \n@@ -733,7 +750,7 @@ impl<'a> Resolver<'a> {\n              Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n         };\n \n-        let kind = ModuleKind::Def(Def::Mod(def_id), name.as_symbol());\n+        let kind = ModuleKind::Def(DefKind::Mod, def_id, name.as_symbol());\n         let module =\n             self.arenas.alloc_module(ModuleData::new(parent, kind, def_id, Mark::root(), DUMMY_SP));\n         self.extern_module_map.insert((def_id, macros_only), module);\n@@ -752,13 +769,13 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    pub fn get_macro(&mut self, def: Def) -> Lrc<SyntaxExtension> {\n-        let def_id = match def {\n-            Def::Macro(def_id, ..) => def_id,\n-            Def::NonMacroAttr(attr_kind) => return Lrc::new(SyntaxExtension::NonMacroAttr {\n+    pub fn get_macro(&mut self, res: Res) -> Lrc<SyntaxExtension> {\n+        let def_id = match res {\n+            Res::Def(DefKind::Macro(..), def_id) => def_id,\n+            Res::NonMacroAttr(attr_kind) => return Lrc::new(SyntaxExtension::NonMacroAttr {\n                 mark_used: attr_kind == NonMacroAttrKind::Tool,\n             }),\n-            _ => panic!(\"expected `Def::Macro` or `Def::NonMacroAttr`\"),\n+            _ => panic!(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\"),\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {\n             return ext.clone();\n@@ -784,7 +801,7 @@ impl<'a> Resolver<'a> {\n         let def_id = module.def_id().unwrap();\n         for child in self.cstore.item_children_untracked(def_id, self.session) {\n             let child = child.map_id(|_| panic!(\"unexpected id\"));\n-            self.build_reduced_graph_for_external_crate_def(module, child);\n+            self.build_reduced_graph_for_external_crate_res(module, child);\n         }\n         module.populated.set(true)\n     }\n@@ -1015,20 +1032,20 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n         // Add the item to the trait info.\n         let item_def_id = self.resolver.definitions.local_def_id(item.id);\n-        let (def, ns) = match item.node {\n-            TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n+        let (res, ns) = match item.node {\n+            TraitItemKind::Const(..) => (Res::Def(DefKind::AssociatedConst, item_def_id), ValueNS),\n             TraitItemKind::Method(ref sig, _) => {\n                 if sig.decl.has_self() {\n                     self.resolver.has_self.insert(item_def_id);\n                 }\n-                (Def::Method(item_def_id), ValueNS)\n+                (Res::Def(DefKind::Method, item_def_id), ValueNS)\n             }\n-            TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS),\n+            TraitItemKind::Type(..) => (Res::Def(DefKind::AssociatedTy, item_def_id), TypeNS),\n             TraitItemKind::Macro(_) => bug!(),  // handled above\n         };\n \n         let vis = ty::Visibility::Public;\n-        self.resolver.define(parent, item.ident, ns, (def, vis, item.span, self.expansion));\n+        self.resolver.define(parent, item.ident, ns, (res, vis, item.span, self.expansion));\n \n         self.resolver.current_module = parent.parent.unwrap(); // nearest normal ancestor\n         visit::walk_trait_item(self, item);"}, {"sha": "bbfc39fc6eaf045579f65ca7f3039b8dde1a4b8a", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -2,15 +2,15 @@ use std::cmp::Reverse;\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use log::debug;\n-use rustc::hir::def::{self, CtorKind, Namespace::*};\n+use rustc::hir::def::{self, DefKind, CtorKind, Namespace::*};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::session::{Session, config::nightly_options};\n use syntax::ast::{self, Expr, ExprKind, Ident};\n use syntax::ext::base::MacroKind;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{BytePos, Span};\n \n-type Def = def::Def<ast::NodeId>;\n+type Res = def::Res<ast::NodeId>;\n \n use crate::macros::ParentScope;\n use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n@@ -26,20 +26,22 @@ impl<'a> Resolver<'a> {\n         path: &[Segment],\n         span: Span,\n         source: PathSource<'_>,\n-        def: Option<Def>,\n+        res: Option<Res>,\n     ) -> (DiagnosticBuilder<'a>, Vec<ImportSuggestion>) {\n         let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n         let ns = source.namespace();\n-        let is_expected = &|def| source.is_expected(def);\n-        let is_enum_variant = &|def| if let Def::Variant(..) = def { true } else { false };\n+        let is_expected = &|res| source.is_expected(res);\n+        let is_enum_variant = &|res| {\n+            if let Res::Def(DefKind::Variant, _) = res { true } else { false }\n+        };\n \n         // Make the base error.\n         let expected = source.descr_expected();\n         let path_str = Segment::names_to_string(path);\n         let item_str = path.last().unwrap().ident;\n-        let code = source.error_code(def.is_some());\n-        let (base_msg, fallback_label, base_span) = if let Some(def) = def {\n-            (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n+        let code = source.error_code(res.is_some());\n+        let (base_msg, fallback_label, base_span) = if let Some(res) = res {\n+            (format!(\"expected {}, found {} `{}`\", expected, res.kind_name(), path_str),\n                 format!(\"not a {}\", expected),\n                 span)\n         } else {\n@@ -54,9 +56,9 @@ impl<'a> Resolver<'a> {\n                     mod_path, Some(TypeNS), false, span, CrateLint::No\n                 ) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                        module.def(),\n+                        module.def_kind(),\n                     _ => None,\n-                }.map_or(String::new(), |def| format!(\"{} \", def.kind_name()));\n+                }.map_or(String::new(), |kind| format!(\"{} \", kind.descr()));\n                 (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n             };\n             (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n@@ -111,13 +113,14 @@ impl<'a> Resolver<'a> {\n         let candidates = self.lookup_import_candidates(ident, ns, is_expected)\n             .drain(..)\n             .filter(|ImportSuggestion { did, .. }| {\n-                match (did, def.and_then(|def| def.opt_def_id())) {\n+                match (did, res.and_then(|res| res.opt_def_id())) {\n                     (Some(suggestion_did), Some(actual_did)) => *suggestion_did != actual_did,\n                     _ => true,\n                 }\n             })\n             .collect::<Vec<_>>();\n-        if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n+        let crate_def_id = DefId::local(CRATE_DEF_INDEX);\n+        if candidates.is_empty() && is_expected(Res::Def(DefKind::Enum, crate_def_id)) {\n             let enum_candidates =\n                 self.lookup_import_candidates(ident, ns, is_enum_variant);\n             let mut enum_candidates = enum_candidates.iter()\n@@ -129,7 +132,7 @@ impl<'a> Resolver<'a> {\n             if !enum_candidates.is_empty() {\n                 // Contextualize for E0412 \"cannot find type\", but don't belabor the point\n                 // (that it's a variant) for E0573 \"expected type, found variant\".\n-                let preamble = if def.is_none() {\n+                let preamble = if res.is_none() {\n                     let others = match enum_candidates.len() {\n                         1 => String::new(),\n                         2 => \" and 1 other\".to_owned(),\n@@ -221,11 +224,11 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Try context-dependent help if relaxed lookup didn't work.\n-        if let Some(def) = def {\n+        if let Some(res) = res {\n             if self.smart_resolve_context_dependent_help(&mut err,\n                                                          span,\n                                                          source,\n-                                                         def,\n+                                                         res,\n                                                          &path_str,\n                                                          &fallback_label) {\n                 return (err, candidates);\n@@ -298,12 +301,12 @@ impl<'a> Resolver<'a> {\n         err: &mut DiagnosticBuilder<'a>,\n         span: Span,\n         source: PathSource<'_>,\n-        def: Def,\n+        res: Res,\n         path_str: &str,\n         fallback_label: &str,\n     ) -> bool {\n         let ns = source.namespace();\n-        let is_expected = &|def| source.is_expected(def);\n+        let is_expected = &|res| source.is_expected(res);\n \n         let path_sep = |err: &mut DiagnosticBuilder<'_>, expr: &Expr| match expr.node {\n             ExprKind::Field(_, ident) => {\n@@ -361,8 +364,8 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        match (def, source) {\n-            (Def::Macro(..), _) => {\n+        match (res, source) {\n+            (Res::Def(DefKind::Macro(..), _), _) => {\n                 err.span_suggestion(\n                     span,\n                     \"use `!` to invoke the macro\",\n@@ -373,18 +376,20 @@ impl<'a> Resolver<'a> {\n                     err.note(\"if you want the `try` keyword, you need to be in the 2018 edition\");\n                 }\n             }\n-            (Def::TyAlias(..), PathSource::Trait(_)) => {\n+            (Res::Def(DefKind::TyAlias, _), PathSource::Trait(_)) => {\n                 err.span_label(span, \"type aliases cannot be used as traits\");\n                 if nightly_options::is_nightly_build() {\n                     err.note(\"did you mean to use a trait alias?\");\n                 }\n             }\n-            (Def::Mod(..), PathSource::Expr(Some(parent))) => if !path_sep(err, &parent) {\n-                return false;\n-            },\n-            (Def::Enum(..), PathSource::TupleStruct)\n-                | (Def::Enum(..), PathSource::Expr(..))  => {\n-                if let Some(variants) = self.collect_enum_variants(def) {\n+            (Res::Def(DefKind::Mod, _), PathSource::Expr(Some(parent))) => {\n+                if !path_sep(err, &parent) {\n+                    return false;\n+                }\n+            }\n+            (Res::Def(DefKind::Enum, def_id), PathSource::TupleStruct)\n+                | (Res::Def(DefKind::Enum, def_id), PathSource::Expr(..))  => {\n+                if let Some(variants) = self.collect_enum_variants(def_id) {\n                     if !variants.is_empty() {\n                         let msg = if variants.len() == 1 {\n                             \"try using the enum's variant\"\n@@ -403,7 +408,7 @@ impl<'a> Resolver<'a> {\n                     err.note(\"did you mean to use one of the enum's variants?\");\n                 }\n             },\n-            (Def::Struct(def_id), _) if ns == ValueNS => {\n+            (Res::Def(DefKind::Struct, def_id), _) if ns == ValueNS => {\n                 if let Some((ctor_def, ctor_vis))\n                         = self.struct_constructors.get(&def_id).cloned() {\n                     let accessible_ctor = self.is_accessible(ctor_vis);\n@@ -417,16 +422,17 @@ impl<'a> Resolver<'a> {\n                     bad_struct_syntax_suggestion();\n                 }\n             }\n-            (Def::Union(..), _) |\n-            (Def::Variant(..), _) |\n-            (Def::Ctor(_, _, CtorKind::Fictive), _) if ns == ValueNS => {\n+            (Res::Def(DefKind::Union, _), _) |\n+            (Res::Def(DefKind::Variant, _), _) |\n+            (Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _), _) if ns == ValueNS => {\n                 bad_struct_syntax_suggestion();\n             }\n-            (Def::SelfTy(..), _) if ns == ValueNS => {\n+            (Res::SelfTy(..), _) if ns == ValueNS => {\n                 err.span_label(span, fallback_label);\n                 err.note(\"can't use `Self` as a constructor, you must use the implemented struct\");\n             }\n-            (Def::TyAlias(_), _) | (Def::AssociatedTy(..), _) if ns == ValueNS => {\n+            (Res::Def(DefKind::TyAlias, _), _)\n+            | (Res::Def(DefKind::AssociatedTy, _), _) if ns == ValueNS => {\n                 err.note(\"can't use a type alias as a constructor\");\n             }\n             _ => return false,\n@@ -622,7 +628,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let resolutions = crate_module.resolutions.borrow();\n         let resolution = resolutions.get(&(ident, MacroNS))?;\n         let binding = resolution.borrow().binding()?;\n-        if let Def::Macro(_, MacroKind::Bang) = binding.def() {\n+        if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {\n             let module_name = crate_module.kind.name().unwrap();\n             let import = match directive.subclass {\n                 ImportDirectiveSubclass::SingleImport { source, target, .. } if source != target =>"}, {"sha": "e0892f98d31472dec995c388089f62f7fef4b6be", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 329, "deletions": 286, "changes": 615, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -24,7 +24,7 @@ use rustc::middle::cstore::CrateStore;\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::{\n-    self, PathResolution, CtorKind, CtorOf, NonMacroAttrKind, DefMap, ImportMap, ExportMap\n+    self, DefKind, PathResolution, CtorKind, CtorOf, NonMacroAttrKind, ResMap, ImportMap, ExportMap\n };\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n@@ -71,7 +71,7 @@ use diagnostics::{find_span_of_binding_until_next_binding, extend_span_to_previo\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n use macros::{InvocationData, LegacyBinding, ParentScope};\n \n-type Def = def::Def<NodeId>;\n+type Res = def::Res<NodeId>;\n \n // N.B., this module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -151,7 +151,7 @@ type Suggestion = (Vec<(Span, String)>, String, Applicability);\n \n enum ResolutionError<'a> {\n     /// Error E0401: can't use type or const parameters from outer function.\n-    GenericParamsFromOuterFunction(Def),\n+    GenericParamsFromOuterFunction(Res),\n     /// Error E0403: the name is already used for a type or const parameter in this generic\n     /// parameter list.\n     NameAlreadyUsedInParameterList(Name, &'a Span),\n@@ -206,7 +206,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                                    resolution_error: ResolutionError<'a>)\n                                    -> DiagnosticBuilder<'sess> {\n     match resolution_error {\n-        ResolutionError::GenericParamsFromOuterFunction(outer_def) => {\n+        ResolutionError::GenericParamsFromOuterFunction(outer_res) => {\n             let mut err = struct_span_err!(resolver.session,\n                 span,\n                 E0401,\n@@ -215,8 +215,8 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n             err.span_label(span, format!(\"use of generic parameter from outer function\"));\n \n             let cm = resolver.session.source_map();\n-            match outer_def {\n-                Def::SelfTy(maybe_trait_defid, maybe_impl_defid) => {\n+            match outer_res {\n+                Res::SelfTy(maybe_trait_defid, maybe_impl_defid) => {\n                     if let Some(impl_span) = maybe_impl_defid.and_then(|def_id| {\n                         resolver.definitions.opt_span(def_id)\n                     }) {\n@@ -236,19 +236,19 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                     }\n                     return err;\n                 },\n-                Def::TyParam(def_id) => {\n+                Res::Def(DefKind::TyParam, def_id) => {\n                     if let Some(span) = resolver.definitions.opt_span(def_id) {\n                         err.span_label(span, \"type parameter from outer function\");\n                     }\n                 }\n-                Def::ConstParam(def_id) => {\n+                Res::Def(DefKind::ConstParam, def_id) => {\n                     if let Some(span) = resolver.definitions.opt_span(def_id) {\n                         err.span_label(span, \"const parameter from outer function\");\n                     }\n                 }\n                 _ => {\n-                    bug!(\"GenericParamsFromOuterFunction should only be used with Def::SelfTy, \\\n-                         Def::TyParam\");\n+                    bug!(\"GenericParamsFromOuterFunction should only be used with Res::SelfTy, \\\n+                         DefKind::TyParam\");\n                 }\n             }\n \n@@ -570,61 +570,81 @@ impl<'a> PathSource<'a> {\n                 MacroNS => bug!(\"associated macro\"),\n             },\n             PathSource::Expr(parent) => match parent.map(|p| &p.node) {\n-                // \"function\" here means \"anything callable\" rather than `Def::Fn`,\n+                // \"function\" here means \"anything callable\" rather than `DefKind::Fn`,\n                 // this is not precise but usually more helpful than just \"value\".\n                 Some(&ExprKind::Call(..)) => \"function\",\n                 _ => \"value\",\n             },\n         }\n     }\n \n-    fn is_expected(self, def: Def) -> bool {\n+    fn is_expected(self, res: Res) -> bool {\n         match self {\n-            PathSource::Type => match def {\n-                Def::Struct(..) | Def::Union(..) | Def::Enum(..) |\n-                Def::Trait(..) | Def::TraitAlias(..) | Def::TyAlias(..) |\n-                Def::AssociatedTy(..) | Def::PrimTy(..) | Def::TyParam(..) |\n-                Def::SelfTy(..) | Def::Existential(..) | Def::ForeignTy(..) => true,\n+            PathSource::Type => match res {\n+                Res::Def(DefKind::Struct, _)\n+                | Res::Def(DefKind::Union, _)\n+                | Res::Def(DefKind::Enum, _)\n+                | Res::Def(DefKind::Trait, _)\n+                | Res::Def(DefKind::TraitAlias, _)\n+                | Res::Def(DefKind::TyAlias, _)\n+                | Res::Def(DefKind::AssociatedTy, _)\n+                | Res::PrimTy(..)\n+                | Res::Def(DefKind::TyParam, _)\n+                | Res::SelfTy(..)\n+                | Res::Def(DefKind::Existential, _)\n+                | Res::Def(DefKind::ForeignTy, _) => true,\n                 _ => false,\n             },\n-            PathSource::Trait(AliasPossibility::No) => match def {\n-                Def::Trait(..) => true,\n+            PathSource::Trait(AliasPossibility::No) => match res {\n+                Res::Def(DefKind::Trait, _) => true,\n                 _ => false,\n             },\n-            PathSource::Trait(AliasPossibility::Maybe) => match def {\n-                Def::Trait(..) => true,\n-                Def::TraitAlias(..) => true,\n+            PathSource::Trait(AliasPossibility::Maybe) => match res {\n+                Res::Def(DefKind::Trait, _) => true,\n+                Res::Def(DefKind::TraitAlias, _) => true,\n                 _ => false,\n             },\n-            PathSource::Expr(..) => match def {\n-                Def::Ctor(_, _, CtorKind::Const) | Def::Ctor(_, _, CtorKind::Fn) |\n-                Def::Const(..) | Def::Static(..) | Def::Local(..) | Def::Upvar(..) |\n-                Def::Fn(..) | Def::Method(..) | Def::AssociatedConst(..) |\n-                Def::SelfCtor(..) | Def::ConstParam(..) => true,\n+            PathSource::Expr(..) => match res {\n+                Res::Def(DefKind::Ctor(_, CtorKind::Const), _)\n+                | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n+                | Res::Def(DefKind::Const, _)\n+                | Res::Def(DefKind::Static, _)\n+                | Res::Local(..)\n+                | Res::Upvar(..)\n+                | Res::Def(DefKind::Fn, _)\n+                | Res::Def(DefKind::Method, _)\n+                | Res::Def(DefKind::AssociatedConst, _)\n+                | Res::SelfCtor(..)\n+                | Res::Def(DefKind::ConstParam, _) => true,\n                 _ => false,\n             },\n-            PathSource::Pat => match def {\n-                Def::Ctor(_, _, CtorKind::Const) |\n-                Def::Const(..) | Def::AssociatedConst(..) |\n-                Def::SelfCtor(..) => true,\n+            PathSource::Pat => match res {\n+                Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n+                Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssociatedConst, _) |\n+                Res::SelfCtor(..) => true,\n                 _ => false,\n             },\n-            PathSource::TupleStruct => match def {\n-                Def::Ctor(_, _, CtorKind::Fn) | Def::SelfCtor(..) => true,\n+            PathSource::TupleStruct => match res {\n+                Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) | Res::SelfCtor(..) => true,\n                 _ => false,\n             },\n-            PathSource::Struct => match def {\n-                Def::Struct(..) | Def::Union(..) | Def::Variant(..) |\n-                Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => true,\n+            PathSource::Struct => match res {\n+                Res::Def(DefKind::Struct, _)\n+                | Res::Def(DefKind::Union, _)\n+                | Res::Def(DefKind::Variant, _)\n+                | Res::Def(DefKind::TyAlias, _)\n+                | Res::Def(DefKind::AssociatedTy, _)\n+                | Res::SelfTy(..) => true,\n                 _ => false,\n             },\n-            PathSource::TraitItem(ns) => match def {\n-                Def::AssociatedConst(..) | Def::Method(..) if ns == ValueNS => true,\n-                Def::AssociatedTy(..) if ns == TypeNS => true,\n+            PathSource::TraitItem(ns) => match res {\n+                Res::Def(DefKind::AssociatedConst, _)\n+                | Res::Def(DefKind::Method, _) if ns == ValueNS => true,\n+                Res::Def(DefKind::AssociatedTy, _) if ns == TypeNS => true,\n                 _ => false,\n             },\n-            PathSource::Visibility => match def {\n-                Def::Mod(..) => true,\n+            PathSource::Visibility => match res {\n+                Res::Def(DefKind::Mod, _) => true,\n                 _ => false,\n             },\n         }\n@@ -799,9 +819,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             }\n             TyKind::ImplicitSelf => {\n                 let self_ty = keywords::SelfUpper.ident();\n-                let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n-                              .map_or(Def::Err, |d| d.def());\n-                self.record_def(ty.id, PathResolution::new(def));\n+                let res = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n+                              .map_or(Res::Err, |d| d.res());\n+                self.record_res(ty.id, PathResolution::new(res));\n             }\n             _ => (),\n         }\n@@ -931,7 +951,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 GenericParamKind::Type { ref default, .. } => {\n                     found_default |= default.is_some();\n                     if found_default {\n-                        Some((Ident::with_empty_ctxt(param.ident.name), Def::Err))\n+                        Some((Ident::with_empty_ctxt(param.ident.name), Res::Err))\n                     } else {\n                         None\n                     }\n@@ -948,7 +968,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                     false\n                 }\n             })\n-            .map(|param| (Ident::with_empty_ctxt(param.ident.name), Def::Err)));\n+            .map(|param| (Ident::with_empty_ctxt(param.ident.name), Res::Err)));\n \n         for param in &generics.params {\n             match param.kind {\n@@ -997,7 +1017,7 @@ enum GenericParameters<'a, 'b> {\n }\n \n /// The rib kind controls the translation of local\n-/// definitions (`Def::Local`) to upvars (`Def::Upvar`).\n+/// definitions (`Res::Local`) to upvars (`Res::Upvar`).\n #[derive(Copy, Clone, Debug)]\n enum RibKind<'a> {\n     /// No translation needs to be applied.\n@@ -1052,7 +1072,7 @@ enum RibKind<'a> {\n /// resolving, the name is looked up from inside out.\n #[derive(Debug)]\n struct Rib<'a> {\n-    bindings: FxHashMap<Ident, Def>,\n+    bindings: FxHashMap<Ident, Res>,\n     kind: RibKind<'a>,\n }\n \n@@ -1067,12 +1087,12 @@ impl<'a> Rib<'a> {\n \n /// An intermediate resolution result.\n ///\n-/// This refers to the thing referred by a name. The difference between `Def` and `Item` is that\n-/// items are visible in their whole block, while defs only from the place they are defined\n+/// This refers to the thing referred by a name. The difference between `Res` and `Item` is that\n+/// items are visible in their whole block, while `Res`es only from the place they are defined\n /// forward.\n enum LexicalScopeBinding<'a> {\n     Item(&'a NameBinding<'a>),\n-    Def(Def),\n+    Res(Res),\n }\n \n impl<'a> LexicalScopeBinding<'a> {\n@@ -1083,10 +1103,10 @@ impl<'a> LexicalScopeBinding<'a> {\n         }\n     }\n \n-    fn def(self) -> Def {\n+    fn res(self) -> Res {\n         match self {\n-            LexicalScopeBinding::Item(binding) => binding.def(),\n-            LexicalScopeBinding::Def(def) => def,\n+            LexicalScopeBinding::Item(binding) => binding.res(),\n+            LexicalScopeBinding::Res(res) => res,\n         }\n     }\n }\n@@ -1113,7 +1133,7 @@ impl ModuleOrUniformRoot<'_> {\n     fn same_def(lhs: Self, rhs: Self) -> bool {\n         match (lhs, rhs) {\n             (ModuleOrUniformRoot::Module(lhs),\n-             ModuleOrUniformRoot::Module(rhs)) => lhs.def() == rhs.def(),\n+             ModuleOrUniformRoot::Module(rhs)) => lhs.def_id() == rhs.def_id(),\n             (ModuleOrUniformRoot::CrateRootAndExternPrelude,\n              ModuleOrUniformRoot::CrateRootAndExternPrelude) |\n             (ModuleOrUniformRoot::ExternPrelude, ModuleOrUniformRoot::ExternPrelude) |\n@@ -1157,15 +1177,15 @@ enum ModuleKind {\n     /// * A normal module \u2012 either `mod from_file;` or `mod from_block { }`.\n     /// * A trait or an enum (it implicitly contains associated types, methods and variant\n     ///   constructors).\n-    Def(Def, Name),\n+    Def(DefKind, DefId, Name),\n }\n \n impl ModuleKind {\n     /// Get name of the module.\n     pub fn name(&self) -> Option<Name> {\n         match self {\n             ModuleKind::Block(..) => None,\n-            ModuleKind::Def(_, name) => Some(*name),\n+            ModuleKind::Def(.., name) => Some(*name),\n         }\n     }\n }\n@@ -1182,7 +1202,7 @@ pub struct ModuleData<'a> {\n     single_segment_macro_resolutions: RefCell<Vec<(Ident, MacroKind, ParentScope<'a>,\n                                                    Option<&'a NameBinding<'a>>)>>,\n     multi_segment_macro_resolutions: RefCell<Vec<(Vec<Segment>, Span, MacroKind, ParentScope<'a>,\n-                                                  Option<Def>)>>,\n+                                                  Option<Res>)>>,\n     builtin_attrs: RefCell<Vec<(Ident, ParentScope<'a>)>>,\n \n     // Macro invocations that can expand into items in this module.\n@@ -1249,28 +1269,38 @@ impl<'a> ModuleData<'a> {\n         }\n     }\n \n-    fn def(&self) -> Option<Def> {\n+    fn res(&self) -> Option<Res> {\n         match self.kind {\n-            ModuleKind::Def(def, _) => Some(def),\n+            ModuleKind::Def(kind, def_id, _) => Some(Res::Def(kind, def_id)),\n+            _ => None,\n+        }\n+    }\n+\n+    fn def_kind(&self) -> Option<DefKind> {\n+        match self.kind {\n+            ModuleKind::Def(kind, ..) => Some(kind),\n             _ => None,\n         }\n     }\n \n     fn def_id(&self) -> Option<DefId> {\n-        self.def().as_ref().map(Def::def_id)\n+        match self.kind {\n+            ModuleKind::Def(_, def_id, _) => Some(def_id),\n+            _ => None,\n+        }\n     }\n \n     // `self` resolves to the first module ancestor that `is_normal`.\n     fn is_normal(&self) -> bool {\n         match self.kind {\n-            ModuleKind::Def(Def::Mod(_), _) => true,\n+            ModuleKind::Def(DefKind::Mod, _, _) => true,\n             _ => false,\n         }\n     }\n \n     fn is_trait(&self) -> bool {\n         match self.kind {\n-            ModuleKind::Def(Def::Trait(_), _) => true,\n+            ModuleKind::Def(DefKind::Trait, _, _) => true,\n             _ => false,\n         }\n     }\n@@ -1293,7 +1323,7 @@ impl<'a> ModuleData<'a> {\n \n impl<'a> fmt::Debug for ModuleData<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}\", self.def())\n+        write!(f, \"{:?}\", self.res())\n     }\n }\n \n@@ -1319,7 +1349,7 @@ impl<'a> ToNameBinding<'a> for &'a NameBinding<'a> {\n \n #[derive(Clone, Debug)]\n enum NameBindingKind<'a> {\n-    Def(Def, /* is_macro_export */ bool),\n+    Res(Res, /* is_macro_export */ bool),\n     Module(Module<'a>),\n     Import {\n         binding: &'a NameBinding<'a>,\n@@ -1417,11 +1447,11 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n-    fn def(&self) -> Def {\n+    fn res(&self) -> Res {\n         match self.kind {\n-            NameBindingKind::Def(def, _) => def,\n-            NameBindingKind::Module(module) => module.def().unwrap(),\n-            NameBindingKind::Import { binding, .. } => binding.def(),\n+            NameBindingKind::Res(res, _) => res,\n+            NameBindingKind::Module(module) => module.res().unwrap(),\n+            NameBindingKind::Import { binding, .. } => binding.res(),\n         }\n     }\n \n@@ -1434,7 +1464,7 @@ impl<'a> NameBinding<'a> {\n \n     // We sometimes need to treat variants as `pub` for backwards compatibility.\n     fn pseudo_vis(&self) -> ty::Visibility {\n-        if self.is_variant() && self.def().def_id().is_local() {\n+        if self.is_variant() && self.res().def_id().is_local() {\n             ty::Visibility::Public\n         } else {\n             self.vis\n@@ -1443,8 +1473,8 @@ impl<'a> NameBinding<'a> {\n \n     fn is_variant(&self) -> bool {\n         match self.kind {\n-            NameBindingKind::Def(Def::Variant(..), _) |\n-            NameBindingKind::Def(Def::Ctor(_, CtorOf::Variant, ..), _) => true,\n+            NameBindingKind::Res(Res::Def(DefKind::Variant, _), _) |\n+            NameBindingKind::Res(Res::Def(DefKind::Ctor(CtorOf::Variant, ..), _), _) => true,\n             _ => false,\n         }\n     }\n@@ -1457,7 +1487,7 @@ impl<'a> NameBinding<'a> {\n                 }, ..\n             } => true,\n             NameBindingKind::Module(\n-                &ModuleData { kind: ModuleKind::Def(Def::Mod(def_id), _), .. }\n+                &ModuleData { kind: ModuleKind::Def(DefKind::Mod, def_id, _), .. }\n             ) => def_id.index == CRATE_DEF_INDEX,\n             _ => false,\n         }\n@@ -1478,33 +1508,35 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn is_importable(&self) -> bool {\n-        match self.def() {\n-            Def::AssociatedConst(..) | Def::Method(..) | Def::AssociatedTy(..) => false,\n+        match self.res() {\n+            Res::Def(DefKind::AssociatedConst, _)\n+            | Res::Def(DefKind::Method, _)\n+            | Res::Def(DefKind::AssociatedTy, _) => false,\n             _ => true,\n         }\n     }\n \n     fn is_macro_def(&self) -> bool {\n         match self.kind {\n-            NameBindingKind::Def(Def::Macro(..), _) => true,\n+            NameBindingKind::Res(Res::Def(DefKind::Macro(..), _), _) => true,\n             _ => false,\n         }\n     }\n \n     fn macro_kind(&self) -> Option<MacroKind> {\n-        match self.def() {\n-            Def::Macro(_, kind) => Some(kind),\n-            Def::NonMacroAttr(..) => Some(MacroKind::Attr),\n+        match self.res() {\n+            Res::Def(DefKind::Macro(kind), _) => Some(kind),\n+            Res::NonMacroAttr(..) => Some(MacroKind::Attr),\n             _ => None,\n         }\n     }\n \n     fn descr(&self) -> &'static str {\n-        if self.is_extern_crate() { \"extern crate\" } else { self.def().kind_name() }\n+        if self.is_extern_crate() { \"extern crate\" } else { self.res().kind_name() }\n     }\n \n     fn article(&self) -> &'static str {\n-        if self.is_extern_crate() { \"an\" } else { self.def().article() }\n+        if self.is_extern_crate() { \"an\" } else { self.res().article() }\n     }\n \n     // Suppose that we resolved macro invocation with `invoc_parent_expansion` to binding `binding`\n@@ -1627,7 +1659,7 @@ pub struct Resolver<'a> {\n     /// The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n \n-    def_map: DefMap,\n+    res_map: ResMap,\n     import_map: ImportMap,\n     pub freevars: FreevarMap,\n     freevars_seen: NodeMap<NodeMap<usize>>,\n@@ -1680,7 +1712,7 @@ pub struct Resolver<'a> {\n     macro_names: FxHashSet<Ident>,\n     builtin_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n     macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n-    pub all_macros: FxHashMap<Name, Def>,\n+    pub all_macros: FxHashMap<Name, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n     macro_defs: FxHashMap<Mark, DefId>,\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n@@ -1699,7 +1731,7 @@ pub struct Resolver<'a> {\n \n     /// Table for mapping struct IDs into struct constructor IDs,\n     /// it's not used during normal resolution, only for better error reporting.\n-    struct_constructors: DefIdMap<(Def, ty::Visibility)>,\n+    struct_constructors: DefIdMap<(Res, ty::Visibility)>,\n \n     /// Only used for better errors on `fn(): fn()`.\n     current_type_ascription: Vec<Span>,\n@@ -1799,7 +1831,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     }\n \n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution> {\n-        self.def_map.get(&id).cloned()\n+        self.res_map.get(&id).cloned()\n     }\n \n     fn get_import(&mut self, id: NodeId) -> PerNS<Option<PathResolution>> {\n@@ -1841,7 +1873,7 @@ impl<'a> Resolver<'a> {\n             }\n         };\n         let path = self.resolve_hir_path_cb(&path, is_value, |_, _, _| errored = true);\n-        if errored || path.def == def::Def::Err {\n+        if errored || path.res == def::Res::Err {\n             Err(())\n         } else {\n             Ok(path)\n@@ -1862,39 +1894,39 @@ impl<'a> Resolver<'a> {\n         let segments = &path.segments;\n         let path = Segment::from_path(&path);\n         // FIXME(Manishearth): intra-doc links won't get warned of epoch changes.\n-        let def = match self.resolve_path_without_parent_scope(&path, Some(namespace), true,\n+        let res = match self.resolve_path_without_parent_scope(&path, Some(namespace), true,\n                                                                span, CrateLint::No) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                module.def().unwrap(),\n+                module.res().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n-                path_res.base_def(),\n+                path_res.base_res(),\n             PathResult::NonModule(..) => {\n                 error_callback(self, span, ResolutionError::FailedToResolve {\n                     label: String::from(\"type-relative paths are not supported in this context\"),\n                     suggestion: None,\n                 });\n-                Def::Err\n+                Res::Err\n             }\n             PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),\n             PathResult::Failed { span, label, suggestion, .. } => {\n                 error_callback(self, span, ResolutionError::FailedToResolve {\n                     label,\n                     suggestion,\n                 });\n-                Def::Err\n+                Res::Err\n             }\n         };\n \n         let segments: Vec<_> = segments.iter().map(|seg| {\n             let mut hir_seg = hir::PathSegment::from_ident(seg.ident);\n-            hir_seg.def = Some(self.def_map.get(&seg.id).map_or(def::Def::Err, |p| {\n-                p.base_def().map_id(|_| panic!(\"unexpected node_id\"))\n+            hir_seg.res = Some(self.res_map.get(&seg.id).map_or(def::Res::Err, |p| {\n+                p.base_res().map_id(|_| panic!(\"unexpected node_id\"))\n             }));\n             hir_seg\n         }).collect();\n         hir::Path {\n             span,\n-            def: def.map_id(|_| panic!(\"unexpected node_id\")),\n+            res: res.map_id(|_| panic!(\"unexpected node_id\")),\n             segments: segments.into(),\n         }\n     }\n@@ -1915,7 +1947,11 @@ impl<'a> Resolver<'a> {\n                arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n         let root_def_id = DefId::local(CRATE_DEF_INDEX);\n-        let root_module_kind = ModuleKind::Def(Def::Mod(root_def_id), keywords::Invalid.name());\n+        let root_module_kind = ModuleKind::Def(\n+            DefKind::Mod,\n+            root_def_id,\n+            keywords::Invalid.name(),\n+        );\n         let graph_root = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n             ..ModuleData::new(None, root_module_kind, root_def_id, Mark::root(), krate.span)\n@@ -1983,7 +2019,7 @@ impl<'a> Resolver<'a> {\n \n             primitive_type_table: PrimitiveTypeTable::new(),\n \n-            def_map: Default::default(),\n+            res_map: Default::default(),\n             import_map: Default::default(),\n             freevars: Default::default(),\n             freevars_seen: Default::default(),\n@@ -2009,7 +2045,7 @@ impl<'a> Resolver<'a> {\n \n             arenas,\n             dummy_binding: arenas.alloc_name_binding(NameBinding {\n-                kind: NameBindingKind::Def(Def::Err, false),\n+                kind: NameBindingKind::Res(Res::Err, false),\n                 ambiguity: None,\n                 expansion: Mark::root(),\n                 span: DUMMY_SP,\n@@ -2140,7 +2176,7 @@ impl<'a> Resolver<'a> {\n                                       -> Option<LexicalScopeBinding<'a>> {\n         assert!(ns == TypeNS  || ns == ValueNS);\n         if ident.name == keywords::Invalid.name() {\n-            return Some(LexicalScopeBinding::Def(Def::Err));\n+            return Some(LexicalScopeBinding::Res(Res::Err));\n         }\n         ident.span = if ident.name == keywords::SelfUpper.name() {\n             // FIXME(jseyfried) improve `Self` hygiene\n@@ -2156,10 +2192,10 @@ impl<'a> Resolver<'a> {\n         let mut module = self.graph_root;\n         for i in (0 .. self.ribs[ns].len()).rev() {\n             debug!(\"walk rib\\n{:?}\", self.ribs[ns][i].bindings);\n-            if let Some(def) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n+            if let Some(res) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n-                return Some(LexicalScopeBinding::Def(\n-                    self.adjust_local_def(ns, i, def, record_used, path_span)\n+                return Some(LexicalScopeBinding::Res(\n+                    self.adjust_local_res(ns, i, res, record_used, path_span)\n                 ));\n             }\n \n@@ -2239,7 +2275,7 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             if ns == TypeNS && is_known_tool(ident.name) {\n-                let binding = (Def::ToolMod, ty::Visibility::Public,\n+                let binding = (Res::ToolMod, ty::Visibility::Public,\n                                DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n                 return Some(LexicalScopeBinding::Item(binding));\n             }\n@@ -2481,7 +2517,7 @@ impl<'a> Resolver<'a> {\n         self.with_current_self_item(item, |this| {\n             this.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n                 let item_def_id = this.definitions.local_def_id(item.id);\n-                this.with_self_rib(Def::SelfTy(None, Some(item_def_id)), |this| {\n+                this.with_self_rib(Res::SelfTy(None, Some(item_def_id)), |this| {\n                     visit::walk_item(this, item);\n                 });\n             });\n@@ -2507,13 +2543,13 @@ impl<'a> Resolver<'a> {\n \n             for &ns in nss {\n                 match self.resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span) {\n-                    Some(LexicalScopeBinding::Def(..)) => {\n+                    Some(LexicalScopeBinding::Res(..)) => {\n                         report_error(self, ns);\n                     }\n                     Some(LexicalScopeBinding::Item(binding)) => {\n                         let orig_blacklisted_binding =\n                             mem::replace(&mut self.blacklisted_binding, Some(binding));\n-                        if let Some(LexicalScopeBinding::Def(..)) =\n+                        if let Some(LexicalScopeBinding::Res(..)) =\n                                 self.resolve_ident_in_lexical_scope(ident, ns, None,\n                                                                     use_tree.prefix.span) {\n                             report_error(self, ns);\n@@ -2559,7 +2595,7 @@ impl<'a> Resolver<'a> {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n                     let local_def_id = this.definitions.local_def_id(item.id);\n-                    this.with_self_rib(Def::SelfTy(Some(local_def_id), None), |this| {\n+                    this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_param_bound, bounds);\n \n@@ -2600,7 +2636,7 @@ impl<'a> Resolver<'a> {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n                     let local_def_id = this.definitions.local_def_id(item.id);\n-                    this.with_self_rib(Def::SelfTy(Some(local_def_id), None), |this| {\n+                    this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_param_bound, bounds);\n                     });\n@@ -2663,10 +2699,13 @@ impl<'a> Resolver<'a> {\n                             }\n                             seen_bindings.entry(ident).or_insert(param.ident.span);\n \n-                        // Plain insert (no renaming).\n-                        let def = Def::TyParam(self.definitions.local_def_id(param.id));\n-                            function_type_rib.bindings.insert(ident, def);\n-                            self.record_def(param.id, PathResolution::new(def));\n+                            // Plain insert (no renaming).\n+                            let res = Res::Def(\n+                                DefKind::TyParam,\n+                                self.definitions.local_def_id(param.id),\n+                            );\n+                            function_type_rib.bindings.insert(ident, res);\n+                            self.record_res(param.id, PathResolution::new(res));\n                         }\n                         GenericParamKind::Const { .. } => {\n                             let ident = param.ident.modern();\n@@ -2682,9 +2721,12 @@ impl<'a> Resolver<'a> {\n                             }\n                             seen_bindings.entry(ident).or_insert(param.ident.span);\n \n-                            let def = Def::ConstParam(self.definitions.local_def_id(param.id));\n-                            function_value_rib.bindings.insert(ident, def);\n-                            self.record_def(param.id, PathResolution::new(def));\n+                            let res = Res::Def(\n+                                DefKind::ConstParam,\n+                                self.definitions.local_def_id(param.id),\n+                            );\n+                            function_value_rib.bindings.insert(ident, res);\n+                            self.record_res(param.id, PathResolution::new(res));\n                         }\n                     }\n                 }\n@@ -2761,16 +2803,16 @@ impl<'a> Resolver<'a> {\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n             let path: Vec<_> = Segment::from_path(&trait_ref.path);\n-            let def = self.smart_resolve_path_fragment(\n+            let res = self.smart_resolve_path_fragment(\n                 trait_ref.ref_id,\n                 None,\n                 &path,\n                 trait_ref.path.span,\n                 PathSource::Trait(AliasPossibility::No),\n                 CrateLint::SimplePath(trait_ref.ref_id),\n-            ).base_def();\n-            if def != Def::Err {\n-                new_id = Some(def.def_id());\n+            ).base_res();\n+            if res != Res::Err {\n+                new_id = Some(res.def_id());\n                 let span = trait_ref.path.span;\n                 if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n                     self.resolve_path_without_parent_scope(\n@@ -2791,13 +2833,13 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n-    fn with_self_rib<F>(&mut self, self_def: Def, f: F)\n+    fn with_self_rib<F>(&mut self, self_res: Res, f: F)\n         where F: FnOnce(&mut Resolver<'_>)\n     {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // Plain insert (no renaming, since types are not currently hygienic)\n-        self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_def);\n+        self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_res);\n         self.ribs[TypeNS].push(self_type_rib);\n         f(self);\n         self.ribs[TypeNS].pop();\n@@ -2806,9 +2848,9 @@ impl<'a> Resolver<'a> {\n     fn with_self_struct_ctor_rib<F>(&mut self, impl_id: DefId, f: F)\n         where F: FnOnce(&mut Resolver<'_>)\n     {\n-        let self_def = Def::SelfCtor(impl_id);\n+        let self_res = Res::SelfCtor(impl_id);\n         let mut self_type_rib = Rib::new(NormalRibKind);\n-        self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_def);\n+        self_type_rib.bindings.insert(keywords::SelfUpper.ident(), self_res);\n         self.ribs[ValueNS].push(self_type_rib);\n         f(self);\n         self.ribs[ValueNS].pop();\n@@ -2824,11 +2866,11 @@ impl<'a> Resolver<'a> {\n         // If applicable, create a rib for the type parameters.\n         self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n             // Dummy self type for better errors if `Self` is used in the trait path.\n-            this.with_self_rib(Def::SelfTy(None, None), |this| {\n+            this.with_self_rib(Res::SelfTy(None, None), |this| {\n                 // Resolve the trait reference, if necessary.\n                 this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n                     let item_def_id = this.definitions.local_def_id(item_id);\n-                    this.with_self_rib(Def::SelfTy(trait_id, Some(item_def_id)), |this| {\n+                    this.with_self_rib(Res::SelfTy(trait_id, Some(item_def_id)), |this| {\n                         if let Some(trait_ref) = opt_trait_reference.as_ref() {\n                             // Resolve type arguments in the trait path.\n                             visit::walk_trait_ref(this, trait_ref);\n@@ -2952,8 +2994,8 @@ impl<'a> Resolver<'a> {\n \n         pat.walk(&mut |pat| {\n             if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n-                if sub_pat.is_some() || match self.def_map.get(&pat.id).map(|res| res.base_def()) {\n-                    Some(Def::Local(..)) => true,\n+                if sub_pat.is_some() || match self.res_map.get(&pat.id).map(|res| res.base_res()) {\n+                    Some(Res::Local(..)) => true,\n                     _ => false,\n                 } {\n                     let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n@@ -3076,9 +3118,9 @@ impl<'a> Resolver<'a> {\n             if let ast::StmtKind::Item(ref item) = stmt.node {\n                 if let ast::ItemKind::MacroDef(..) = item.node {\n                     num_macro_definition_ribs += 1;\n-                    let def = self.definitions.local_def_id(item.id);\n-                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(def)));\n-                    self.label_ribs.push(Rib::new(MacroDefinition(def)));\n+                    let res = self.definitions.local_def_id(item.id);\n+                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n+                    self.label_ribs.push(Rib::new(MacroDefinition(res)));\n                 }\n             }\n \n@@ -3111,7 +3153,7 @@ impl<'a> Resolver<'a> {\n         // because that breaks the assumptions later\n         // passes make about or-patterns.)\n         let ident = ident.modern_and_legacy();\n-        let mut def = Def::Local(pat_id);\n+        let mut res = Res::Local(pat_id);\n         match bindings.get(&ident).cloned() {\n             Some(id) if id == outer_pat_id => {\n                 // `Variant(a, a)`, error\n@@ -3136,7 +3178,7 @@ impl<'a> Resolver<'a> {\n                         pat_src == PatternSource::WhileLet => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n-                def = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident];\n+                res = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident];\n             }\n             Some(..) => {\n                 span_bug!(ident.span, \"two bindings with the same name from \\\n@@ -3146,12 +3188,12 @@ impl<'a> Resolver<'a> {\n                 // A completely fresh binding, add to the lists if it's valid.\n                 if ident.name != keywords::Invalid.name() {\n                     bindings.insert(ident, outer_pat_id);\n-                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident, def);\n+                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident, res);\n                 }\n             }\n         }\n \n-        PathResolution::new(def)\n+        PathResolution::new(res)\n     }\n \n     fn resolve_pattern(&mut self,\n@@ -3171,18 +3213,20 @@ impl<'a> Resolver<'a> {\n                     let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS,\n                                                                       None, pat.span)\n                                       .and_then(LexicalScopeBinding::item);\n-                    let resolution = binding.map(NameBinding::def).and_then(|def| {\n+                    let resolution = binding.map(NameBinding::res).and_then(|res| {\n                         let is_syntactic_ambiguity = opt_pat.is_none() &&\n                             bmode == BindingMode::ByValue(Mutability::Immutable);\n-                        match def {\n-                            Def::Ctor(_, _, CtorKind::Const) |\n-                            Def::Const(..) if is_syntactic_ambiguity => {\n+                        match res {\n+                            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n+                            Res::Def(DefKind::Const, _) if is_syntactic_ambiguity => {\n                                 // Disambiguate in favor of a unit struct/variant\n                                 // or constant pattern.\n                                 self.record_use(ident, ValueNS, binding.unwrap(), false);\n-                                Some(PathResolution::new(def))\n+                                Some(PathResolution::new(res))\n                             }\n-                            Def::Ctor(..) | Def::Const(..) | Def::Static(..) => {\n+                            Res::Def(DefKind::Ctor(..), _)\n+                            | Res::Def(DefKind::Const, _)\n+                            | Res::Def(DefKind::Static, _) => {\n                                 // This is unambiguously a fresh binding, either syntactically\n                                 // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n                                 // to something unusable as a pattern (e.g., constructor function),\n@@ -3196,21 +3240,21 @@ impl<'a> Resolver<'a> {\n                                 );\n                                 None\n                             }\n-                            Def::Fn(..) | Def::Err => {\n+                            Res::Def(DefKind::Fn, _) | Res::Err => {\n                                 // These entities are explicitly allowed\n                                 // to be shadowed by fresh bindings.\n                                 None\n                             }\n-                            def => {\n-                                span_bug!(ident.span, \"unexpected definition for an \\\n-                                                       identifier in pattern: {:?}\", def);\n+                            res => {\n+                                span_bug!(ident.span, \"unexpected resolution for an \\\n+                                                       identifier in pattern: {:?}\", res);\n                             }\n                         }\n                     }).unwrap_or_else(|| {\n                         self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n                     });\n \n-                    self.record_def(pat.id, resolution);\n+                    self.record_res(pat.id, resolution);\n                 }\n \n                 PatKind::TupleStruct(ref path, ..) => {\n@@ -3282,13 +3326,13 @@ impl<'a> Resolver<'a> {\n                                    crate_lint: CrateLint)\n                                    -> PathResolution {\n         let ns = source.namespace();\n-        let is_expected = &|def| source.is_expected(def);\n+        let is_expected = &|res| source.is_expected(res);\n \n-        let report_errors = |this: &mut Self, def: Option<Def>| {\n-            let (err, candidates) = this.smart_resolve_report_errors(path, span, source, def);\n+        let report_errors = |this: &mut Self, res: Option<Res>| {\n+            let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n             let def_id = this.current_module.normal_ancestor_id;\n             let node_id = this.definitions.as_local_node_id(def_id).unwrap();\n-            let better = def.is_some();\n+            let better = res.is_some();\n             this.use_injections.push(UseError { err, candidates, node_id, better });\n             err_path_resolution()\n         };\n@@ -3304,27 +3348,27 @@ impl<'a> Resolver<'a> {\n             crate_lint,\n         ) {\n             Some(resolution) if resolution.unresolved_segments() == 0 => {\n-                if is_expected(resolution.base_def()) || resolution.base_def() == Def::Err {\n+                if is_expected(resolution.base_res()) || resolution.base_res() == Res::Err {\n                     resolution\n                 } else {\n                     // Add a temporary hack to smooth the transition to new struct ctor\n                     // visibility rules. See #38932 for more details.\n                     let mut res = None;\n-                    if let Def::Struct(def_id) = resolution.base_def() {\n-                        if let Some((ctor_def, ctor_vis))\n+                    if let Res::Def(DefKind::Struct, def_id) = resolution.base_res() {\n+                        if let Some((ctor_res, ctor_vis))\n                                 = self.struct_constructors.get(&def_id).cloned() {\n-                            if is_expected(ctor_def) && self.is_accessible(ctor_vis) {\n+                            if is_expected(ctor_res) && self.is_accessible(ctor_vis) {\n                                 let lint = lint::builtin::LEGACY_CONSTRUCTOR_VISIBILITY;\n                                 self.session.buffer_lint(lint, id, span,\n                                     \"private struct constructors are not usable through \\\n                                      re-exports in outer modules\",\n                                 );\n-                                res = Some(PathResolution::new(ctor_def));\n+                                res = Some(PathResolution::new(ctor_res));\n                             }\n                         }\n                     }\n \n-                    res.unwrap_or_else(|| report_errors(self, Some(resolution.base_def())))\n+                    res.unwrap_or_else(|| report_errors(self, Some(resolution.base_res())))\n                 }\n             }\n             Some(resolution) if source.defer_to_typeck() => {\n@@ -3362,7 +3406,7 @@ impl<'a> Resolver<'a> {\n \n         if let PathSource::TraitItem(..) = source {} else {\n             // Avoid recording definition of `A::B` in `<T as A>::B::C`.\n-            self.record_def(id, resolution);\n+            self.record_res(id, resolution);\n         }\n         resolution\n     }\n@@ -3459,13 +3503,13 @@ impl<'a> Resolver<'a> {\n     fn self_type_is_available(&mut self, span: Span) -> bool {\n         let binding = self.resolve_ident_in_lexical_scope(keywords::SelfUpper.ident(),\n                                                           TypeNS, None, span);\n-        if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n+        if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n     fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n         let ident = Ident::new(keywords::SelfLower.name(), self_span);\n         let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span);\n-        if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n+        if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n     // Resolve in alternative namespaces if resolution in the primary namespace fails.\n@@ -3501,9 +3545,10 @@ impl<'a> Resolver<'a> {\n             self.macro_use_prelude.get(&path[0].ident.name).cloned()\n                                   .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang)) {\n             // Return some dummy definition, it's enough for error reporting.\n-            return Some(\n-                PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))\n-            );\n+            return Some(PathResolution::new(Res::Def(\n+                DefKind::Macro(MacroKind::Bang),\n+                DefId::local(CRATE_DEF_INDEX),\n+            )));\n         }\n         fin_res\n     }\n@@ -3536,7 +3581,7 @@ impl<'a> Resolver<'a> {\n                 // trait to resolve.  In that case, we leave the `B`\n                 // segment to be resolved by type-check.\n                 return Some(PathResolution::with_unresolved_segments(\n-                    Def::Mod(DefId::local(CRATE_DEF_INDEX)), path.len()\n+                    Res::Def(DefKind::Mod, DefId::local(CRATE_DEF_INDEX)), path.len()\n                 ));\n             }\n \n@@ -3571,7 +3616,7 @@ impl<'a> Resolver<'a> {\n             // have to be resolved by type-check, since that requires doing\n             // trait resolution.\n             return Some(PathResolution::with_unresolved_segments(\n-                res.base_def(), res.unresolved_segments() + path.len() - qself.position - 1\n+                res.base_res(), res.unresolved_segments() + path.len() - qself.position - 1\n             ));\n         }\n \n@@ -3584,7 +3629,7 @@ impl<'a> Resolver<'a> {\n         ) {\n             PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) if !module.is_normal() => {\n-                PathResolution::new(module.def().unwrap())\n+                PathResolution::new(module.res().unwrap())\n             }\n             // In `a(::assoc_item)*` `a` cannot be a module. If `a` does resolve to a module we\n             // don't report an error right away, but try to fallback to a primitive type.\n@@ -3604,10 +3649,10 @@ impl<'a> Resolver<'a> {\n                        self.primitive_type_table.primitive_types\n                            .contains_key(&path[0].ident.name) => {\n                 let prim = self.primitive_type_table.primitive_types[&path[0].ident.name];\n-                PathResolution::with_unresolved_segments(Def::PrimTy(prim), path.len() - 1)\n+                PathResolution::with_unresolved_segments(Res::PrimTy(prim), path.len() - 1)\n             }\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                PathResolution::new(module.def().unwrap()),\n+                PathResolution::new(module.res().unwrap()),\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve { label, suggestion });\n                 err_path_resolution()\n@@ -3616,7 +3661,7 @@ impl<'a> Resolver<'a> {\n             PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n         };\n \n-        if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n+        if path.len() > 1 && !global_by_default && result.base_res() != Res::Err &&\n            path[0].ident.name != keywords::PathRoot.name() &&\n            path[0].ident.name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n@@ -3627,13 +3672,13 @@ impl<'a> Resolver<'a> {\n                     span,\n                     CrateLint::No,\n                 ) {\n-                    PathResult::NonModule(path_res) => path_res.base_def(),\n+                    PathResult::NonModule(path_res) => path_res.base_res(),\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                        module.def().unwrap(),\n+                        module.res().unwrap(),\n                     _ => return Some(result),\n                 }\n             };\n-            if result.base_def() == unqualified_result {\n+            if result.base_res() == unqualified_result {\n                 let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n                 self.session.buffer_lint(lint, id, span, \"unnecessary qualification\")\n             }\n@@ -3683,12 +3728,12 @@ impl<'a> Resolver<'a> {\n \n         for (i, &Segment { ident, id }) in path.iter().enumerate() {\n             debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n-            let record_segment_def = |this: &mut Self, def| {\n+            let record_segment_res = |this: &mut Self, res| {\n                 if record_used {\n                     if let Some(id) = id {\n-                        if !this.def_map.contains_key(&id) {\n+                        if !this.res_map.contains_key(&id) {\n                             assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n-                            this.record_def(id, PathResolution::new(def));\n+                            this.record_res(id, PathResolution::new(res));\n                         }\n                     }\n                 }\n@@ -3789,11 +3834,11 @@ impl<'a> Resolver<'a> {\n                     // we found a locally-imported or available item/module\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n                     // we found a local variable or type param\n-                    Some(LexicalScopeBinding::Def(def))\n+                    Some(LexicalScopeBinding::Res(res))\n                             if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) => {\n-                        record_segment_def(self, def);\n+                        record_segment_res(self, res);\n                         return PathResult::NonModule(PathResolution::with_unresolved_segments(\n-                            def, path.len() - 1\n+                            res, path.len() - 1\n                         ));\n                     }\n                     _ => Err(Determinacy::determined(record_used)),\n@@ -3805,22 +3850,22 @@ impl<'a> Resolver<'a> {\n                     if i == 1 {\n                         second_binding = Some(binding);\n                     }\n-                    let def = binding.def();\n-                    let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(def);\n+                    let res = binding.res();\n+                    let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(res);\n                     if let Some(next_module) = binding.module() {\n                         module = Some(ModuleOrUniformRoot::Module(next_module));\n-                        record_segment_def(self, def);\n-                    } else if def == Def::ToolMod && i + 1 != path.len() {\n+                        record_segment_res(self, res);\n+                    } else if res == Res::ToolMod && i + 1 != path.len() {\n                         if binding.is_import() {\n                             self.session.struct_span_err(\n                                 ident.span, \"cannot use a tool module through an import\"\n                             ).span_note(\n                                 binding.span, \"the tool module imported here\"\n                             ).emit();\n                         }\n-                        let def = Def::NonMacroAttr(NonMacroAttrKind::Tool);\n-                        return PathResult::NonModule(PathResolution::new(def));\n-                    } else if def == Def::Err {\n+                        let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n+                        return PathResult::NonModule(PathResolution::new(res));\n+                    } else if res == Res::Err {\n                         return PathResult::NonModule(err_path_resolution());\n                     } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n                         self.lint_if_path_starts_with_module(\n@@ -3830,14 +3875,14 @@ impl<'a> Resolver<'a> {\n                             second_binding,\n                         );\n                         return PathResult::NonModule(PathResolution::with_unresolved_segments(\n-                            def, path.len() - i - 1\n+                            res, path.len() - i - 1\n                         ));\n                     } else {\n                         let label = format!(\n                             \"`{}` is {} {}, not a module\",\n                             ident,\n-                            def.article(),\n-                            def.kind_name(),\n+                            res.article(),\n+                            res.kind_name(),\n                         );\n \n                         return PathResult::Failed {\n@@ -3853,16 +3898,18 @@ impl<'a> Resolver<'a> {\n                     if let Some(ModuleOrUniformRoot::Module(module)) = module {\n                         if opt_ns.is_some() && !module.is_normal() {\n                             return PathResult::NonModule(PathResolution::with_unresolved_segments(\n-                                module.def().unwrap(), path.len() - i\n+                                module.res().unwrap(), path.len() - i\n                             ));\n                         }\n                     }\n-                    let module_def = match module {\n-                        Some(ModuleOrUniformRoot::Module(module)) => module.def(),\n+                    let module_res = match module {\n+                        Some(ModuleOrUniformRoot::Module(module)) => module.res(),\n                         _ => None,\n                     };\n-                    let (label, suggestion) = if module_def == self.graph_root.def() {\n-                        let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n+                    let (label, suggestion) = if module_res == self.graph_root.res() {\n+                        let is_mod = |res| {\n+                            match res { Res::Def(DefKind::Mod, _) => true, _ => false }\n+                        };\n                         let mut candidates =\n                             self.lookup_import_candidates(ident, TypeNS, is_mod);\n                         candidates.sort_by_cached_key(|c| {\n@@ -3968,38 +4015,38 @@ impl<'a> Resolver<'a> {\n     }\n \n     // Resolve a local definition, potentially adjusting for closures.\n-    fn adjust_local_def(&mut self,\n+    fn adjust_local_res(&mut self,\n                         ns: Namespace,\n                         rib_index: usize,\n-                        mut def: Def,\n+                        mut res: Res,\n                         record_used: bool,\n-                        span: Span) -> Def {\n-        debug!(\"adjust_local_def\");\n+                        span: Span) -> Res {\n+        debug!(\"adjust_local_res\");\n         let ribs = &self.ribs[ns][rib_index + 1..];\n \n         // An invalid forward use of a type parameter from a previous default.\n         if let ForwardTyParamBanRibKind = self.ribs[ns][rib_index].kind {\n             if record_used {\n                 resolve_error(self, span, ResolutionError::ForwardDeclaredTyParam);\n             }\n-            assert_eq!(def, Def::Err);\n-            return Def::Err;\n+            assert_eq!(res, Res::Err);\n+            return Res::Err;\n         }\n \n         // An invalid use of a type parameter as the type of a const parameter.\n         if let TyParamAsConstParamTy = self.ribs[ns][rib_index].kind {\n             if record_used {\n                 resolve_error(self, span, ResolutionError::ConstParamDependentOnTypeParam);\n             }\n-            assert_eq!(def, Def::Err);\n-            return Def::Err;\n+            assert_eq!(res, Res::Err);\n+            return Res::Err;\n         }\n \n-        match def {\n-            Def::Upvar(..) => {\n-                span_bug!(span, \"unexpected {:?} in bindings\", def)\n+        match res {\n+            Res::Upvar(..) => {\n+                span_bug!(span, \"unexpected {:?} in bindings\", res)\n             }\n-            Def::Local(node_id) => {\n+            Res::Local(node_id) => {\n                 use ResolutionError::*;\n                 let mut res_err = None;\n \n@@ -4010,24 +4057,24 @@ impl<'a> Resolver<'a> {\n                             // Nothing to do. Continue.\n                         }\n                         ClosureRibKind(function_id) => {\n-                            let prev_def = def;\n+                            let prev_res = res;\n \n                             let seen = self.freevars_seen\n                                            .entry(function_id)\n                                            .or_default();\n                             if let Some(&index) = seen.get(&node_id) {\n-                                def = Def::Upvar(node_id, index, function_id);\n+                                res = Res::Upvar(node_id, index, function_id);\n                                 continue;\n                             }\n                             let vec = self.freevars\n                                           .entry(function_id)\n                                           .or_default();\n                             let depth = vec.len();\n-                            def = Def::Upvar(node_id, depth, function_id);\n+                            res = Res::Upvar(node_id, depth, function_id);\n \n                             if record_used {\n                                 vec.push(Freevar {\n-                                    def: prev_def,\n+                                    res: prev_res,\n                                     span,\n                                 });\n                                 seen.insert(node_id, depth);\n@@ -4050,16 +4097,16 @@ impl<'a> Resolver<'a> {\n                             if record_used {\n                                 resolve_error(self, span, AttemptToUseNonConstantValueInConstant);\n                             }\n-                            return Def::Err;\n+                            return Res::Err;\n                         }\n                     }\n                 }\n                 if let Some(res_err) = res_err {\n                      resolve_error(self, span, res_err);\n-                     return Def::Err;\n+                     return Res::Err;\n                 }\n             }\n-            Def::TyParam(..) | Def::SelfTy(..) => {\n+            Res::Def(DefKind::TyParam, _) | Res::SelfTy(..) => {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | TraitOrImplItemRibKind | ClosureRibKind(..) |\n@@ -4073,15 +4120,15 @@ impl<'a> Resolver<'a> {\n                                 resolve_error(\n                                     self,\n                                     span,\n-                                    ResolutionError::GenericParamsFromOuterFunction(def),\n+                                    ResolutionError::GenericParamsFromOuterFunction(res),\n                                 );\n                             }\n-                            return Def::Err;\n+                            return Res::Err;\n                         }\n                     }\n                 }\n             }\n-            Def::ConstParam(..) => {\n+            Res::Def(DefKind::ConstParam, _) => {\n                 let mut ribs = ribs.iter().peekable();\n                 if let Some(Rib { kind: FnItemRibKind, .. }) = ribs.peek() {\n                     // When declaring const parameters inside function signatures, the first rib\n@@ -4096,24 +4143,24 @@ impl<'a> Resolver<'a> {\n                             resolve_error(\n                                 self,\n                                 span,\n-                                ResolutionError::GenericParamsFromOuterFunction(def),\n+                                ResolutionError::GenericParamsFromOuterFunction(res),\n                             );\n                         }\n-                        return Def::Err;\n+                        return Res::Err;\n                     }\n                 }\n             }\n             _ => {}\n         }\n-        def\n+        res\n     }\n \n     fn lookup_assoc_candidate<FilterFn>(&mut self,\n                                         ident: Ident,\n                                         ns: Namespace,\n                                         filter_fn: FilterFn)\n                                         -> Option<AssocSuggestion>\n-        where FilterFn: Fn(Def) -> bool\n+        where FilterFn: Fn(Res) -> bool\n     {\n         fn extract_node_id(t: &Ty) -> Option<NodeId> {\n             match t.node {\n@@ -4127,12 +4174,12 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Fields are generally expected in the same contexts as locals.\n-        if filter_fn(Def::Local(ast::DUMMY_NODE_ID)) {\n+        if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n             if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n                 // Look for a field with the same name in the current self_type.\n-                if let Some(resolution) = self.def_map.get(&node_id) {\n-                    match resolution.base_def() {\n-                        Def::Struct(did) | Def::Union(did)\n+                if let Some(resolution) = self.res_map.get(&node_id) {\n+                    match resolution.base_res() {\n+                        Res::Def(DefKind::Struct, did) | Res::Def(DefKind::Union, did)\n                                 if resolution.unresolved_segments() == 0 => {\n                             if let Some(field_names) = self.field_names.get(&did) {\n                                 if field_names.iter().any(|&field_name| ident.name == field_name) {\n@@ -4156,9 +4203,9 @@ impl<'a> Resolver<'a> {\n                     false,\n                     module.span,\n                 ) {\n-                let def = binding.def();\n-                if filter_fn(def) {\n-                    return Some(if self.has_self.contains(&def.def_id()) {\n+                let res = binding.res();\n+                if filter_fn(res) {\n+                    return Some(if self.has_self.contains(&res.def_id()) {\n                         AssocSuggestion::MethodWithSelf\n                     } else {\n                         AssocSuggestion::AssocItem\n@@ -4178,16 +4225,16 @@ impl<'a> Resolver<'a> {\n         span: Span,\n     ) -> Option<TypoSuggestion>\n     where\n-        FilterFn: Fn(Def) -> bool,\n+        FilterFn: Fn(Res) -> bool,\n     {\n         let add_module_candidates = |module: Module<'_>, names: &mut Vec<TypoSuggestion>| {\n             for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n                 if let Some(binding) = resolution.borrow().binding {\n-                    if !ident.name.is_gensymed() && filter_fn(binding.def()) {\n+                    if !ident.name.is_gensymed() && filter_fn(binding.res()) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n-                            article: binding.def().article(),\n-                            kind: binding.def().kind_name(),\n+                            article: binding.res().article(),\n+                            kind: binding.res().kind_name(),\n                         });\n                     }\n                 }\n@@ -4200,12 +4247,12 @@ impl<'a> Resolver<'a> {\n             // Walk backwards up the ribs in scope and collect candidates.\n             for rib in self.ribs[ns].iter().rev() {\n                 // Locals and type parameters\n-                for (ident, def) in &rib.bindings {\n-                    if !ident.name.is_gensymed() && filter_fn(*def) {\n+                for (ident, &res) in &rib.bindings {\n+                    if !ident.name.is_gensymed() && filter_fn(res) {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n-                            article: def.article(),\n-                            kind: def.kind_name(),\n+                            article: res.article(),\n+                            kind: res.kind_name(),\n                         });\n                     }\n                 }\n@@ -4223,10 +4270,13 @@ impl<'a> Resolver<'a> {\n                                 self.crate_loader\n                                     .maybe_process_path_extern(ident.name, ident.span)\n                                     .and_then(|crate_id| {\n-                                        let crate_mod = Def::Mod(DefId {\n-                                            krate: crate_id,\n-                                            index: CRATE_DEF_INDEX,\n-                                        });\n+                                        let crate_mod = Res::Def(\n+                                            DefKind::Mod,\n+                                            DefId {\n+                                                krate: crate_id,\n+                                                index: CRATE_DEF_INDEX,\n+                                            },\n+                                        );\n \n                                         if !ident.name.is_gensymed() && filter_fn(crate_mod) {\n                                             Some(TypoSuggestion {\n@@ -4249,7 +4299,7 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             // Add primitive types to the mix\n-            if filter_fn(Def::PrimTy(Bool)) {\n+            if filter_fn(Res::PrimTy(Bool)) {\n                 names.extend(\n                     self.primitive_type_table.primitive_types\n                         .iter()\n@@ -4296,10 +4346,10 @@ impl<'a> Resolver<'a> {\n     {\n         if let Some(label) = label {\n             self.unused_labels.insert(id, label.ident.span);\n-            let def = Def::Label(id);\n+            let res = Res::Label(id);\n             self.with_label_rib(|this| {\n                 let ident = label.ident.modern_and_legacy();\n-                this.label_ribs.last_mut().unwrap().bindings.insert(ident, def);\n+                this.label_ribs.last_mut().unwrap().bindings.insert(ident, res);\n                 f(this);\n             });\n         } else {\n@@ -4330,10 +4380,10 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n-                let def = self.search_label(label.ident, |rib, ident| {\n+                let res = self.search_label(label.ident, |rib, ident| {\n                     rib.bindings.get(&ident.modern_and_legacy()).cloned()\n                 });\n-                match def {\n+                match res {\n                     None => {\n                         // Search again for close matches...\n                         // Picks the first label that is \"close enough\", which is not necessarily\n@@ -4348,19 +4398,19 @@ impl<'a> Resolver<'a> {\n                             });\n                             find_best_match_for_name(names, &*ident.as_str(), None)\n                         });\n-                        self.record_def(expr.id, err_path_resolution());\n+                        self.record_res(expr.id, err_path_resolution());\n                         resolve_error(self,\n                                       label.ident.span,\n                                       ResolutionError::UndeclaredLabel(&label.ident.as_str(),\n                                                                        close_match));\n                     }\n-                    Some(Def::Label(id)) => {\n-                        // Since this def is a label, it is never read.\n-                        self.record_def(expr.id, PathResolution::new(Def::Label(id)));\n+                    Some(Res::Label(id)) => {\n+                        // Since this res is a label, it is never read.\n+                        self.record_res(expr.id, PathResolution::new(Res::Label(id)));\n                         self.unused_labels.remove(&id);\n                     }\n                     Some(_) => {\n-                        span_bug!(expr.span, \"label wasn't mapped to a label def!\");\n+                        span_bug!(expr.span, \"label wasn't mapped to a label res!\");\n                     }\n                 }\n \n@@ -4565,9 +4615,9 @@ impl<'a> Resolver<'a> {\n             let mut collected_traits = Vec::new();\n             module.for_each_child(|name, ns, binding| {\n                 if ns != TypeNS { return }\n-                match binding.def() {\n-                    Def::Trait(_) |\n-                    Def::TraitAlias(_) => collected_traits.push((name, binding)),\n+                match binding.res() {\n+                    Res::Def(DefKind::Trait, _) |\n+                    Res::Def(DefKind::TraitAlias, _) => collected_traits.push((name, binding)),\n                     _ => (),\n                 }\n             });\n@@ -4602,7 +4652,7 @@ impl<'a> Resolver<'a> {\n                     let trait_def_id = module.def_id().unwrap();\n                     found_traits.push(TraitCandidate { def_id: trait_def_id, import_id });\n                 }\n-            } else if let Def::TraitAlias(_) = binding.def() {\n+            } else if let Res::Def(DefKind::TraitAlias, _) = binding.res() {\n                 // For now, just treat all trait aliases as possible candidates, since we don't\n                 // know if the ident is somewhere in the transitive bounds.\n \n@@ -4614,7 +4664,7 @@ impl<'a> Resolver<'a> {\n                     }\n                     _ => None,\n                 };\n-                let trait_def_id = binding.def().def_id();\n+                let trait_def_id = binding.res().def_id();\n                 found_traits.push(TraitCandidate { def_id: trait_def_id, import_id });\n             } else {\n                 bug!(\"candidate is not trait or trait alias?\")\n@@ -4629,7 +4679,7 @@ impl<'a> Resolver<'a> {\n                                           crate_name: Ident,\n                                           filter_fn: FilterFn)\n                                           -> Vec<ImportSuggestion>\n-        where FilterFn: Fn(Def) -> bool\n+        where FilterFn: Fn(Res) -> bool\n     {\n         let mut candidates = Vec::new();\n         let mut seen_modules = FxHashSet::default();\n@@ -4651,8 +4701,8 @@ impl<'a> Resolver<'a> {\n \n                 // collect results based on the filter function\n                 if ident.name == lookup_ident.name && ns == namespace {\n-                    let def = name_binding.def();\n-                    if filter_fn(def) {\n+                    let res = name_binding.res();\n+                    if filter_fn(res) {\n                         // create the path\n                         let mut segms = path_segments.clone();\n                         if lookup_ident.span.rust_2018() {\n@@ -4676,9 +4726,9 @@ impl<'a> Resolver<'a> {\n                         // declared as public (due to pruning, we don't explore\n                         // outside crate private modules => no need to check this)\n                         if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n-                            let did = match def {\n-                                Def::Ctor(did, ..) => self.parent(did),\n-                                _ => def.opt_def_id(),\n+                            let did = match res {\n+                                Res::Def(DefKind::Ctor(..), did) => self.parent(did),\n+                                _ => res.opt_def_id(),\n                             };\n                             candidates.push(ImportSuggestion { did, path });\n                         }\n@@ -4724,7 +4774,7 @@ impl<'a> Resolver<'a> {\n                                           namespace: Namespace,\n                                           filter_fn: FilterFn)\n                                           -> Vec<ImportSuggestion>\n-        where FilterFn: Fn(Def) -> bool\n+        where FilterFn: Fn(Res) -> bool\n     {\n         let mut suggestions = self.lookup_import_candidates_from_module(\n             lookup_ident, namespace, self.graph_root, keywords::Crate.ident(), &filter_fn);\n@@ -4749,10 +4799,7 @@ impl<'a> Resolver<'a> {\n         suggestions\n     }\n \n-    fn find_module(&mut self,\n-                   module_def: Def)\n-                   -> Option<(Module<'a>, ImportSuggestion)>\n-    {\n+    fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n         let mut result = None;\n         let mut seen_modules = FxHashSet::default();\n         let mut worklist = vec![(self.graph_root, Vec::new())];\n@@ -4772,16 +4819,16 @@ impl<'a> Resolver<'a> {\n                     // form the path\n                     let mut path_segments = path_segments.clone();\n                     path_segments.push(ast::PathSegment::from_ident(ident));\n-                    if module.def() == Some(module_def) {\n+                    let module_def_id = module.def_id().unwrap();\n+                    if module_def_id == def_id {\n                         let path = Path {\n                             span: name_binding.span,\n                             segments: path_segments,\n                         };\n-                        let did = module.def().and_then(|def| def.opt_def_id());\n-                        result = Some((module, ImportSuggestion { did, path }));\n+                        result = Some((module, ImportSuggestion { did: Some(def_id), path }));\n                     } else {\n                         // add the module to the lookup\n-                        if seen_modules.insert(module.def_id().unwrap()) {\n+                        if seen_modules.insert(module_def_id) {\n                             worklist.push((module, path_segments));\n                         }\n                     }\n@@ -4792,17 +4839,13 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n-    fn collect_enum_variants(&mut self, enum_def: Def) -> Option<Vec<Path>> {\n-        if let Def::Enum(..) = enum_def {} else {\n-            panic!(\"Non-enum def passed to collect_enum_variants: {:?}\", enum_def)\n-        }\n-\n-        self.find_module(enum_def).map(|(enum_module, enum_import_suggestion)| {\n+    fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n+        self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n             self.populate_module_if_necessary(enum_module);\n \n             let mut variants = Vec::new();\n             enum_module.for_each_child_stable(|ident, _, name_binding| {\n-                if let Def::Variant(..) = name_binding.def() {\n+                if let Res::Def(DefKind::Variant, _) = name_binding.res() {\n                     let mut segms = enum_import_suggestion.path.segments.clone();\n                     segms.push(ast::PathSegment::from_ident(ident));\n                     variants.push(Path {\n@@ -4815,9 +4858,9 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    fn record_def(&mut self, node_id: NodeId, resolution: PathResolution) {\n-        debug!(\"(recording def) recording {:?} for {}\", resolution, node_id);\n-        if let Some(prev_res) = self.def_map.insert(node_id, resolution) {\n+    fn record_res(&mut self, node_id: NodeId, resolution: PathResolution) {\n+        debug!(\"(recording res) recording {:?} for {}\", resolution, node_id);\n+        if let Some(prev_res) = self.res_map.insert(node_id, resolution) {\n             panic!(\"path resolved multiple times ({:?} before, {:?} now)\", prev_res, resolution);\n         }\n     }\n@@ -4859,18 +4902,18 @@ impl<'a> Resolver<'a> {\n \n                 let segments = crate_root.into_iter()\n                     .chain(path.segments.iter().map(|seg| seg.into())).collect::<Vec<_>>();\n-                let def = self.smart_resolve_path_fragment(\n+                let res = self.smart_resolve_path_fragment(\n                     id,\n                     None,\n                     &segments,\n                     path.span,\n                     PathSource::Visibility,\n                     CrateLint::SimplePath(id),\n-                ).base_def();\n-                if def == Def::Err {\n+                ).base_res();\n+                if res == Res::Err {\n                     ty::Visibility::Public\n                 } else {\n-                    let vis = ty::Visibility::Restricted(def.def_id());\n+                    let vis = ty::Visibility::Restricted(res.def_id());\n                     if self.is_accessible(vis) {\n                         vis\n                     } else {\n@@ -4918,9 +4961,9 @@ impl<'a> Resolver<'a> {\n \n     fn binding_description(&self, b: &NameBinding<'_>, ident: Ident, from_prelude: bool) -> String {\n         if b.span.is_dummy() {\n-            let add_built_in = match b.def() {\n+            let add_built_in = match b.res() {\n                 // These already contain the \"built-in\" prefix or look bad with it.\n-                Def::NonMacroAttr(..) | Def::PrimTy(..) | Def::ToolMod => false,\n+                Res::NonMacroAttr(..) | Res::PrimTy(..) | Res::ToolMod => false,\n                 _ => true,\n             };\n             let (built_in, from) = if from_prelude {\n@@ -5050,8 +5093,8 @@ impl<'a> Resolver<'a> {\n         }\n \n         let container = match parent.kind {\n-            ModuleKind::Def(Def::Mod(_), _) => \"module\",\n-            ModuleKind::Def(Def::Trait(_), _) => \"trait\",\n+            ModuleKind::Def(DefKind::Mod, _, _) => \"module\",\n+            ModuleKind::Def(DefKind::Trait, _, _) => \"trait\",\n             ModuleKind::Block(..) => \"block\",\n             _ => \"enum\",\n         };\n@@ -5133,7 +5176,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         // Check if the target of the use for both bindings is the same.\n-        let duplicate = new_binding.def().opt_def_id() == old_binding.def().opt_def_id();\n+        let duplicate = new_binding.res().opt_def_id() == old_binding.res().opt_def_id();\n         let has_dummy_span = new_binding.span.is_dummy() || old_binding.span.is_dummy();\n         let from_item = self.extern_prelude.get(&ident)\n             .map(|entry| entry.introduced_by_item)\n@@ -5419,7 +5462,7 @@ fn module_to_string(module: Module<'_>) -> Option<String> {\n     let mut names = Vec::new();\n \n     fn collect_mod(names: &mut Vec<Ident>, module: Module<'_>) {\n-        if let ModuleKind::Def(_, name) = module.kind {\n+        if let ModuleKind::Def(.., name) = module.kind {\n             if let Some(parent) = module.parent {\n                 names.push(Ident::with_empty_ctxt(name));\n                 collect_mod(names, parent);\n@@ -5441,7 +5484,7 @@ fn module_to_string(module: Module<'_>) -> Option<String> {\n }\n \n fn err_path_resolution() -> PathResolution {\n-    PathResolution::new(Def::Err)\n+    PathResolution::new(Res::Err)\n }\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "18573a4594f4c10b6c1944235d86e84d1ee2f7ac", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -8,7 +8,7 @@ use crate::build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n use crate::resolve_imports::ImportResolver;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX, DefIndex,\n                          CrateNum, DefIndexAddressSpace};\n-use rustc::hir::def::{self, NonMacroAttrKind};\n+use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::hir::map::{self, DefCollector};\n use rustc::{ty, lint};\n use rustc::{bug, span_bug};\n@@ -33,7 +33,7 @@ use std::cell::Cell;\n use std::{mem, ptr};\n use rustc_data_structures::sync::Lrc;\n \n-type Def = def::Def<ast::NodeId>;\n+type Res = def::Res<ast::NodeId>;\n \n #[derive(Clone, Debug)]\n pub struct InvocationData<'a> {\n@@ -140,7 +140,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             fn visit_ident(&mut self, ident: Ident) {\n                 if ident.name == keywords::DollarCrate.name() {\n                     let name = match self.resolver.resolve_crate_root(ident).kind {\n-                        ModuleKind::Def(_, name) if name != keywords::Invalid.name() => name,\n+                        ModuleKind::Def(.., name) if name != keywords::Invalid.name() => name,\n                         _ => keywords::Crate.name(),\n                     };\n                     ident.span.ctxt().set_dollar_crate_name(name);\n@@ -179,7 +179,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let kind = ext.kind();\n         self.macro_map.insert(def_id, ext);\n         let binding = self.arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Def(Def::Macro(def_id, kind), false),\n+            kind: NameBindingKind::Res(Res::Def(DefKind::Macro(kind), def_id), false),\n             ambiguity: None,\n             span: DUMMY_SP,\n             vis: ty::Visibility::Public,\n@@ -209,16 +209,16 @@ impl<'a> base::Resolver for Resolver<'a> {\n         };\n \n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n-        let (def, ext) = match self.resolve_macro_to_def(path, kind, &parent_scope, true, force) {\n-            Ok((def, ext)) => (def, ext),\n+        let (res, ext) = match self.resolve_macro_to_res(path, kind, &parent_scope, true, force) {\n+            Ok((res, ext)) => (res, ext),\n             Err(Determinacy::Determined) if kind == MacroKind::Attr => {\n                 // Replace unresolved attributes with used inert attributes for better recovery.\n                 return Ok(Some(Lrc::new(SyntaxExtension::NonMacroAttr { mark_used: true })));\n             }\n             Err(determinacy) => return Err(determinacy),\n         };\n \n-        if let Def::Macro(def_id, _) = def {\n+        if let Res::Def(DefKind::Macro(_), def_id) = res {\n             if after_derive {\n                 self.session.span_err(invoc.span(),\n                                       \"macro attributes must be placed before `#[derive]`\");\n@@ -238,7 +238,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                           derives_in_scope: Vec<ast::Path>, force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy> {\n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n-        Ok(self.resolve_macro_to_def(path, kind, &parent_scope, false, force)?.1)\n+        Ok(self.resolve_macro_to_res(path, kind, &parent_scope, false, force)?.1)\n     }\n \n     fn check_unused_macros(&self) {\n@@ -274,18 +274,18 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn resolve_macro_to_def(\n+    fn resolve_macro_to_res(\n         &mut self,\n         path: &ast::Path,\n         kind: MacroKind,\n         parent_scope: &ParentScope<'a>,\n         trace: bool,\n         force: bool,\n-    ) -> Result<(Def, Lrc<SyntaxExtension>), Determinacy> {\n-        let def = self.resolve_macro_to_def_inner(path, kind, parent_scope, trace, force);\n+    ) -> Result<(Res, Lrc<SyntaxExtension>), Determinacy> {\n+        let res = self.resolve_macro_to_res_inner(path, kind, parent_scope, trace, force);\n \n         // Report errors and enforce feature gates for the resolved macro.\n-        if def != Err(Determinacy::Undetermined) {\n+        if res != Err(Determinacy::Undetermined) {\n             // Do not report duplicated errors on every undetermined resolution.\n             for segment in &path.segments {\n                 if let Some(args) = &segment.args {\n@@ -294,18 +294,18 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let def = def?;\n+        let res = res?;\n \n-        match def {\n-            Def::Macro(def_id, macro_kind) => {\n+        match res {\n+            Res::Def(DefKind::Macro(macro_kind), def_id) => {\n                 self.unused_macros.remove(&def_id);\n                 if macro_kind == MacroKind::ProcMacroStub {\n                     let msg = \"can't use a procedural macro from the same crate that defines it\";\n                     self.session.span_err(path.span, msg);\n                     return Err(Determinacy::Determined);\n                 }\n             }\n-            Def::NonMacroAttr(attr_kind) => {\n+            Res::NonMacroAttr(attr_kind) => {\n                 if kind == MacroKind::Attr {\n                     let features = self.session.features_untracked();\n                     if attr_kind == NonMacroAttrKind::Custom {\n@@ -331,20 +331,20 @@ impl<'a> Resolver<'a> {\n                     }\n                 } else {\n                     // Not only attributes, but anything in macro namespace can result in\n-                    // `Def::NonMacroAttr` definition (e.g., `inline!()`), so we must report\n+                    // `Res::NonMacroAttr` definition (e.g., `inline!()`), so we must report\n                     // an error for those cases.\n-                    let msg = format!(\"expected a macro, found {}\", def.kind_name());\n+                    let msg = format!(\"expected a macro, found {}\", res.kind_name());\n                     self.session.span_err(path.span, &msg);\n                     return Err(Determinacy::Determined);\n                 }\n             }\n-            Def::Err => {\n+            Res::Err => {\n                 return Err(Determinacy::Determined);\n             }\n-            _ => panic!(\"expected `Def::Macro` or `Def::NonMacroAttr`\"),\n+            _ => panic!(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\"),\n         }\n \n-        Ok((def, self.get_macro(def)))\n+        Ok((res, self.get_macro(res)))\n     }\n \n     fn report_unknown_attribute(&self, span: Span, name: &str, msg: &str, feature: &str) {\n@@ -401,14 +401,14 @@ impl<'a> Resolver<'a> {\n         err.emit();\n     }\n \n-    pub fn resolve_macro_to_def_inner(\n+    pub fn resolve_macro_to_res_inner(\n         &mut self,\n         path: &ast::Path,\n         kind: MacroKind,\n         parent_scope: &ParentScope<'a>,\n         trace: bool,\n         force: bool,\n-    ) -> Result<Def, Determinacy> {\n+    ) -> Result<Res, Determinacy> {\n         let path_span = path.span;\n         let mut path = Segment::from_path(path);\n \n@@ -421,10 +421,10 @@ impl<'a> Resolver<'a> {\n         }\n \n         if path.len() > 1 {\n-            let def = match self.resolve_path(&path, Some(MacroNS), parent_scope,\n+            let res = match self.resolve_path(&path, Some(MacroNS), parent_scope,\n                                               false, path_span, CrateLint::No) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n-                    Ok(path_res.base_def())\n+                    Ok(path_res.base_res())\n                 }\n                 PathResult::Indeterminate if !force => return Err(Determinacy::Undetermined),\n                 PathResult::NonModule(..)\n@@ -435,11 +435,11 @@ impl<'a> Resolver<'a> {\n \n             if trace {\n                 parent_scope.module.multi_segment_macro_resolutions.borrow_mut()\n-                    .push((path, path_span, kind, parent_scope.clone(), def.ok()));\n+                    .push((path, path_span, kind, parent_scope.clone(), res.ok()));\n             }\n \n-            self.prohibit_imported_non_macro_attrs(None, def.ok(), path_span);\n-            def\n+            self.prohibit_imported_non_macro_attrs(None, res.ok(), path_span);\n+            res\n         } else {\n             let binding = self.early_resolve_ident_in_lexical_scope(\n                 path[0].ident, ScopeSet::Macro(kind), parent_scope, false, force, path_span\n@@ -453,9 +453,9 @@ impl<'a> Resolver<'a> {\n                     .push((path[0].ident, kind, parent_scope.clone(), binding.ok()));\n             }\n \n-            let def = binding.map(|binding| binding.def());\n-            self.prohibit_imported_non_macro_attrs(binding.ok(), def.ok(), path_span);\n-            def\n+            let res = binding.map(|binding| binding.res());\n+            self.prohibit_imported_non_macro_attrs(binding.ok(), res.ok(), path_span);\n+            res\n         }\n     }\n \n@@ -585,13 +585,13 @@ impl<'a> Resolver<'a> {\n                     let mut result = Err(Determinacy::Determined);\n                     for derive in &parent_scope.derives {\n                         let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n-                        match self.resolve_macro_to_def(derive, MacroKind::Derive,\n+                        match self.resolve_macro_to_res(derive, MacroKind::Derive,\n                                                         &parent_scope, true, force) {\n                             Ok((_, ext)) => {\n                                 if let SyntaxExtension::ProcMacroDerive(_, helpers, _) = &*ext {\n                                     if helpers.contains(&ident.name) {\n                                         let binding =\n-                                            (Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n+                                            (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n                                             ty::Visibility::Public, derive.span, Mark::root())\n                                             .to_name_binding(self.arenas);\n                                         result = Ok((binding, Flags::empty()));\n@@ -684,7 +684,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 WhereToResolve::BuiltinAttrs => {\n                     if is_builtin_attr_name(ident.name) {\n-                        let binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),\n+                        let binding = (Res::NonMacroAttr(NonMacroAttrKind::Builtin),\n                                        ty::Visibility::Public, DUMMY_SP, Mark::root())\n                                        .to_name_binding(self.arenas);\n                         Ok((binding, Flags::PRELUDE))\n@@ -696,7 +696,7 @@ impl<'a> Resolver<'a> {\n                     if (use_prelude || rust_2015) &&\n                        self.session.plugin_attributes.borrow().iter()\n                                                      .any(|(name, _)| ident.name == &**name) {\n-                        let binding = (Def::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n+                        let binding = (Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n                                        ty::Visibility::Public, DUMMY_SP, Mark::root())\n                                        .to_name_binding(self.arenas);\n                         Ok((binding, Flags::PRELUDE))\n@@ -718,7 +718,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 WhereToResolve::ToolPrelude => {\n                     if use_prelude && is_known_tool(ident.name) {\n-                        let binding = (Def::ToolMod, ty::Visibility::Public,\n+                        let binding = (Res::ToolMod, ty::Visibility::Public,\n                                        DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n                         Ok((binding, Flags::PRELUDE))\n                     } else {\n@@ -745,7 +745,7 @@ impl<'a> Resolver<'a> {\n                 WhereToResolve::BuiltinTypes => {\n                     match self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n                         Some(prim_ty) => {\n-                            let binding = (Def::PrimTy(prim_ty), ty::Visibility::Public,\n+                            let binding = (Res::PrimTy(prim_ty), ty::Visibility::Public,\n                                            DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n                             Ok((binding, Flags::PRELUDE))\n                         }\n@@ -762,22 +762,22 @@ impl<'a> Resolver<'a> {\n \n                     if let Some((innermost_binding, innermost_flags)) = innermost_result {\n                         // Found another solution, if the first one was \"weak\", report an error.\n-                        let (def, innermost_def) = (binding.def(), innermost_binding.def());\n-                        if def != innermost_def {\n-                            let builtin = Def::NonMacroAttr(NonMacroAttrKind::Builtin);\n-                            let derive_helper = Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n+                        let (res, innermost_res) = (binding.res(), innermost_binding.res());\n+                        if res != innermost_res {\n+                            let builtin = Res::NonMacroAttr(NonMacroAttrKind::Builtin);\n+                            let derive_helper = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n                             let legacy_helper =\n-                                Def::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper);\n+                                Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper);\n \n                             let ambiguity_error_kind = if is_import {\n                                 Some(AmbiguityKind::Import)\n-                            } else if innermost_def == builtin || def == builtin {\n+                            } else if innermost_res == builtin || res == builtin {\n                                 Some(AmbiguityKind::BuiltinAttr)\n-                            } else if innermost_def == derive_helper || def == derive_helper {\n+                            } else if innermost_res == derive_helper || res == derive_helper {\n                                 Some(AmbiguityKind::DeriveHelper)\n-                            } else if innermost_def == legacy_helper &&\n+                            } else if innermost_res == legacy_helper &&\n                                       flags.contains(Flags::PRELUDE) ||\n-                                      def == legacy_helper &&\n+                                      res == legacy_helper &&\n                                       innermost_flags.contains(Flags::PRELUDE) {\n                                 Some(AmbiguityKind::LegacyHelperVsPrelude)\n                             } else if innermost_flags.contains(Flags::MACRO_RULES) &&\n@@ -889,7 +889,7 @@ impl<'a> Resolver<'a> {\n             // attribute. (Lexical resolution implies the first segment and attr kind should imply\n             // the last segment, so we are certainly working with a single-segment attribute here.)\n             assert!(ns == MacroNS);\n-            let binding = (Def::NonMacroAttr(NonMacroAttrKind::Custom),\n+            let binding = (Res::NonMacroAttr(NonMacroAttrKind::Custom),\n                            ty::Visibility::Public, ident.span, Mark::root())\n                            .to_name_binding(self.arenas);\n             Ok(binding)\n@@ -902,18 +902,18 @@ impl<'a> Resolver<'a> {\n         let module = self.current_module;\n \n         let check_consistency = |this: &mut Self, path: &[Segment], span, kind: MacroKind,\n-                                 initial_def: Option<Def>, def: Def| {\n-            if let Some(initial_def) = initial_def {\n-                if def != initial_def && def != Def::Err && this.ambiguity_errors.is_empty() {\n+                                 initial_res: Option<Res>, res: Res| {\n+            if let Some(initial_res) = initial_res {\n+                if res != initial_res && res != Res::Err && this.ambiguity_errors.is_empty() {\n                     // Make sure compilation does not succeed if preferred macro resolution\n                     // has changed after the macro had been expanded. In theory all such\n                     // situations should be reported as ambiguity errors, so this is a bug.\n-                    if initial_def == Def::NonMacroAttr(NonMacroAttrKind::Custom) {\n+                    if initial_res == Res::NonMacroAttr(NonMacroAttrKind::Custom) {\n                         // Yeah, legacy custom attributes are implemented using forced resolution\n                         // (which is a best effort error recovery tool, basically), so we can't\n                         // promise their resolution won't change later.\n                         let msg = format!(\"inconsistent resolution for a macro: first {}, then {}\",\n-                                          initial_def.kind_name(), def.kind_name());\n+                                          initial_res.kind_name(), res.kind_name());\n                         this.session.span_err(span, &msg);\n                     } else {\n                         span_bug!(span, \"inconsistent resolution for a macro\");\n@@ -938,14 +938,14 @@ impl<'a> Resolver<'a> {\n \n         let macro_resolutions =\n             mem::replace(&mut *module.multi_segment_macro_resolutions.borrow_mut(), Vec::new());\n-        for (mut path, path_span, kind, parent_scope, initial_def) in macro_resolutions {\n+        for (mut path, path_span, kind, parent_scope, initial_res) in macro_resolutions {\n             // FIXME: Path resolution will ICE if segment IDs present.\n             for seg in &mut path { seg.id = None; }\n             match self.resolve_path(&path, Some(MacroNS), &parent_scope,\n                                     true, path_span, CrateLint::No) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n-                    let def = path_res.base_def();\n-                    check_consistency(self, &path, path_span, kind, initial_def, def);\n+                    let res = path_res.base_res();\n+                    check_consistency(self, &path, path_span, kind, initial_res, res);\n                 }\n                 path_res @ PathResult::NonModule(..) | path_res @ PathResult::Failed { .. } => {\n                     let (span, label) = if let PathResult::Failed { span, label, .. } = path_res {\n@@ -969,13 +969,13 @@ impl<'a> Resolver<'a> {\n             match self.early_resolve_ident_in_lexical_scope(ident, ScopeSet::Macro(kind),\n                                                             &parent_scope, true, true, ident.span) {\n                 Ok(binding) => {\n-                    let initial_def = initial_binding.map(|initial_binding| {\n+                    let initial_res = initial_binding.map(|initial_binding| {\n                         self.record_use(ident, MacroNS, initial_binding, false);\n-                        initial_binding.def()\n+                        initial_binding.res()\n                     });\n-                    let def = binding.def();\n+                    let res = binding.res();\n                     let seg = Segment::from_ident(ident);\n-                    check_consistency(self, &[seg], ident.span, kind, initial_def, def);\n+                    check_consistency(self, &[seg], ident.span, kind, initial_res, res);\n                 }\n                 Err(..) => {\n                     assert!(initial_binding.is_none());\n@@ -998,8 +998,8 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn prohibit_imported_non_macro_attrs(&self, binding: Option<&'a NameBinding<'a>>,\n-                                         def: Option<Def>, span: Span) {\n-        if let Some(Def::NonMacroAttr(kind)) = def {\n+                                         res: Option<Res>, span: Span) {\n+        if let Some(Res::NonMacroAttr(kind)) = res {\n             if kind != NonMacroAttrKind::Tool && binding.map_or(true, |b| b.is_import()) {\n                 let msg = format!(\"cannot use a {} through an import\", kind.descr());\n                 let mut err = self.session.struct_span_err(span, &msg);\n@@ -1027,8 +1027,8 @@ impl<'a> Resolver<'a> {\n             find_best_match_for_name(names, name, None)\n         // Then check modules.\n         }).or_else(|| {\n-            let is_macro = |def| {\n-                if let Def::Macro(_, def_kind) = def {\n+            let is_macro = |res| {\n+                if let Res::Def(DefKind::Macro(def_kind), _) = res {\n                     def_kind == kind\n                 } else {\n                     false\n@@ -1107,24 +1107,24 @@ impl<'a> Resolver<'a> {\n         if def.legacy {\n             let ident = ident.modern();\n             self.macro_names.insert(ident);\n-            let def = Def::Macro(def_id, MacroKind::Bang);\n+            let res = Res::Def(DefKind::Macro(MacroKind::Bang), def_id);\n             let is_macro_export = attr::contains_name(&item.attrs, \"macro_export\");\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n             } else {\n                 ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n             };\n-            let binding = (def, vis, item.span, expansion).to_name_binding(self.arenas);\n+            let binding = (res, vis, item.span, expansion).to_name_binding(self.arenas);\n             self.set_binding_parent_module(binding, self.current_module);\n             let legacy_binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n                 parent_legacy_scope: *current_legacy_scope, binding, ident\n             });\n             *current_legacy_scope = LegacyScope::Binding(legacy_binding);\n-            self.all_macros.insert(ident.name, def);\n+            self.all_macros.insert(ident.name, res);\n             if is_macro_export {\n                 let module = self.graph_root;\n                 self.define(module, ident, MacroNS,\n-                            (def, vis, item.span, expansion, IsMacroExport));\n+                            (res, vis, item.span, expansion, IsMacroExport));\n             } else {\n                 if !attr::contains_name(&item.attrs, \"rustc_doc_only_macro\") {\n                     self.check_reserved_macro_name(ident, MacroNS);\n@@ -1133,12 +1133,12 @@ impl<'a> Resolver<'a> {\n             }\n         } else {\n             let module = self.current_module;\n-            let def = Def::Macro(def_id, MacroKind::Bang);\n+            let res = Res::Def(DefKind::Macro(MacroKind::Bang), def_id);\n             let vis = self.resolve_visibility(&item.vis);\n             if vis != ty::Visibility::Public {\n                 self.unused_macros.insert(def_id);\n             }\n-            self.define(module, ident, MacroNS, (def, vis, item.span, expansion));\n+            self.define(module, ident, MacroNS, (res, vis, item.span, expansion));\n         }\n     }\n }"}, {"sha": "522a49ee2c1ea09f85152507d930de0b14d01479", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -21,7 +21,7 @@ use rustc::lint::builtin::{\n     UNUSED_IMPORTS,\n };\n use rustc::hir::def_id::{CrateNum, DefId};\n-use rustc::hir::def::{self, PathResolution, Export};\n+use rustc::hir::def::{self, DefKind, PathResolution, Export};\n use rustc::session::DiagnosticMessageId;\n use rustc::util::nodemap::FxHashSet;\n use rustc::{bug, span_bug};\n@@ -39,7 +39,7 @@ use log::*;\n use std::cell::{Cell, RefCell};\n use std::{mem, ptr};\n \n-type Def = def::Def<NodeId>;\n+type Res = def::Res<NodeId>;\n \n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n@@ -247,7 +247,7 @@ impl<'a> Resolver<'a> {\n \n         if let Some(binding) = resolution.binding {\n             if !restricted_shadowing && binding.expansion != Mark::root() {\n-                if let NameBindingKind::Def(_, true) = binding.kind {\n+                if let NameBindingKind::Res(_, true) = binding.kind {\n                     self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n                 }\n             }\n@@ -287,7 +287,7 @@ impl<'a> Resolver<'a> {\n                         // Forbid expanded shadowing to avoid time travel.\n                         if restricted_shadowing &&\n                         binding.expansion != Mark::root() &&\n-                        binding.def() != shadowed_glob.def() {\n+                        binding.res() != shadowed_glob.res() {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 kind: AmbiguityKind::GlobVsExpanded,\n                                 ident,\n@@ -513,13 +513,13 @@ impl<'a> Resolver<'a> {\n         self.set_binding_parent_module(binding, module);\n         self.update_resolution(module, ident, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n-                if binding.def() == Def::Err {\n-                    // Do not override real bindings with `Def::Err`s from error recovery.\n+                if binding.res() == Res::Err {\n+                    // Do not override real bindings with `Res::Err`s from error recovery.\n                     return Ok(());\n                 }\n                 match (old_binding.is_glob_import(), binding.is_glob_import()) {\n                     (true, true) => {\n-                        if binding.def() != old_binding.def() {\n+                        if binding.res() != old_binding.res() {\n                             resolution.binding = Some(this.ambiguity(AmbiguityKind::GlobVsGlob,\n                                                                      old_binding, binding));\n                         } else if !old_binding.vis.is_at_least(binding.vis, &*this) {\n@@ -533,7 +533,7 @@ impl<'a> Resolver<'a> {\n                         } else {\n                             (binding, old_binding)\n                         };\n-                        if glob_binding.def() != nonglob_binding.def() &&\n+                        if glob_binding.res() != nonglob_binding.res() &&\n                            ns == MacroNS && nonglob_binding.expansion != Mark::root() {\n                             resolution.binding = Some(this.ambiguity(AmbiguityKind::GlobVsExpanded,\n                                                                     nonglob_binding, glob_binding));\n@@ -543,7 +543,7 @@ impl<'a> Resolver<'a> {\n                         resolution.shadowed_glob = Some(glob_binding);\n                     }\n                     (false, false) => {\n-                        if let (&NameBindingKind::Def(_, true), &NameBindingKind::Def(_, true)) =\n+                        if let (&NameBindingKind::Res(_, true), &NameBindingKind::Res(_, true)) =\n                                (&old_binding.kind, &binding.kind) {\n \n                             this.session.buffer_lint_with_diagnostic(\n@@ -619,7 +619,7 @@ impl<'a> Resolver<'a> {\n         t\n     }\n \n-    // Define a \"dummy\" resolution containing a Def::Err as a placeholder for a\n+    // Define a \"dummy\" resolution containing a Res::Err as a placeholder for a\n     // failed resolution\n     fn import_dummy_binding(&mut self, directive: &'a ImportDirective<'a>) {\n         if let SingleImport { target, .. } = directive.subclass {\n@@ -971,7 +971,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 }\n                 return None;\n             }\n-            PathResult::NonModule(path_res) if path_res.base_def() == Def::Err => {\n+            PathResult::NonModule(path_res) if path_res.base_res() == Res::Err => {\n                 if no_ambiguity {\n                     assert!(directive.imported_module.get().is_none());\n                 }\n@@ -1038,7 +1038,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             match binding {\n                 Ok(binding) => {\n                     // Consistency checks, analogous to `finalize_current_module_macro_resolutions`.\n-                    let initial_def = source_bindings[ns].get().map(|initial_binding| {\n+                    let initial_res = source_bindings[ns].get().map(|initial_binding| {\n                         all_ns_err = false;\n                         if let Some(target_binding) = target_bindings[ns].get() {\n                             if target.name == \"_\" &&\n@@ -1047,15 +1047,15 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                                                 directive.module_path.is_empty());\n                             }\n                         }\n-                        initial_binding.def()\n+                        initial_binding.res()\n                     });\n-                    let def = binding.def();\n-                    if let Ok(initial_def) = initial_def {\n-                        if def != initial_def && this.ambiguity_errors.is_empty() {\n+                    let res = binding.res();\n+                    if let Ok(initial_res) = initial_res {\n+                        if res != initial_res && this.ambiguity_errors.is_empty() {\n                             span_bug!(directive.span, \"inconsistent resolution for an import\");\n                         }\n                     } else {\n-                        if def != Def::Err &&\n+                        if res != Res::Err &&\n                            this.ambiguity_errors.is_empty() && this.privacy_errors.is_empty() {\n                             let msg = \"cannot determine resolution for the import\";\n                             let msg_note =\n@@ -1101,7 +1101,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                                     match binding.kind {\n                                         // Never suggest the name that has binding error\n                                         // i.e., the name that cannot be previously resolved\n-                                        NameBindingKind::Def(Def::Err, _) => return None,\n+                                        NameBindingKind::Res(Res::Err, _) => return None,\n                                         _ => Some(&i.name),\n                                     }\n                                 },\n@@ -1223,18 +1223,18 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n         self.per_ns(|this, ns| if let Some(binding) = source_bindings[ns].get().ok() {\n-            let mut def = binding.def();\n-            if let Def::Macro(def_id, _) = def {\n+            let mut res = binding.res();\n+            if let Res::Def(DefKind::Macro(_), def_id) = res {\n                 // `DefId`s from the \"built-in macro crate\" should not leak from resolve because\n                 // later stages are not ready to deal with them and produce lots of ICEs. Replace\n-                // them with `Def::Err` until some saner scheme is implemented for built-in macros.\n+                // them with `Res::Err` until some saner scheme is implemented for built-in macros.\n                 if def_id.krate == CrateNum::BuiltinMacros {\n                     this.session.span_err(directive.span, \"cannot import a built-in macro\");\n-                    def = Def::Err;\n+                    res = Res::Err;\n                 }\n             }\n             let import = this.import_map.entry(directive.id).or_default();\n-            import[ns] = Some(PathResolution::new(def));\n+            import[ns] = Some(PathResolution::new(res));\n         });\n \n         self.check_for_redundant_imports(\n@@ -1264,7 +1264,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         // Skip if we are inside a named module (in contrast to an anonymous\n         // module defined by a block).\n-        if let ModuleKind::Def(_, _) = directive.parent_scope.module.kind {\n+        if let ModuleKind::Def(..) = directive.parent_scope.module.kind {\n             return;\n         }\n \n@@ -1281,7 +1281,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         self.per_ns(|this, ns| if let Some(binding) = source_bindings[ns].get().ok() {\n-            if binding.def() == Def::Err {\n+            if binding.res() == Res::Err {\n                 return;\n             }\n \n@@ -1300,7 +1300,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             ) {\n                 Ok(other_binding) => {\n                     is_redundant[ns] = Some(\n-                        binding.def() == other_binding.def()\n+                        binding.res() == other_binding.res()\n                         && !other_binding.is_ambiguity()\n                     );\n                     redundant_span[ns] =\n@@ -1371,7 +1371,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n \n         // Record the destination of this import\n-        self.record_def(directive.id, PathResolution::new(module.def().unwrap()));\n+        self.record_res(directive.id, PathResolution::new(module.res().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording re-exports,\n@@ -1395,16 +1395,16 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             let is_good_import = binding.is_import() && !binding.is_ambiguity() &&\n                                  !(ident.name.is_gensymed() && ident.name != \"_\");\n             if is_good_import || binding.is_macro_def() {\n-                let def = binding.def();\n-                if def != Def::Err {\n-                    if let Some(def_id) = def.opt_def_id() {\n+                let res = binding.res();\n+                if res != Res::Err {\n+                    if let Some(def_id) = res.opt_def_id() {\n                         if !def_id.is_local() && def_id.krate != CrateNum::BuiltinMacros {\n                             self.cstore.export_macros_untracked(def_id.krate);\n                         }\n                     }\n                     reexports.push(Export {\n                         ident: ident.modern(),\n-                        def: def,\n+                        res: res,\n                         span: binding.span,\n                         vis: binding.vis,\n                     });"}, {"sha": "a45e32ddb6690ccbd0863b9fd14f0bd0638e081a", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -13,7 +13,7 @@\n //! DumpVisitor walks the AST and processes it, and JsonDumper is used for\n //! recording the output.\n \n-use rustc::hir::def::Def as HirDef;\n+use rustc::hir::def::{Res, DefKind as HirDefKind};\n use rustc::hir::def_id::DefId;\n use rustc::session::config::Input;\n use rustc::span_bug;\n@@ -233,8 +233,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     }\n \n     fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n-        match self.save_ctxt.get_path_def(ref_id) {\n-            HirDef::PrimTy(..) | HirDef::SelfTy(..) | HirDef::Err => None,\n+        match self.save_ctxt.get_path_res(ref_id) {\n+            Res::PrimTy(..) | Res::SelfTy(..) | Res::Err => None,\n             def => Some(def.def_id()),\n         }\n     }\n@@ -884,7 +884,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         return;\n                     }\n                 };\n-                let variant = adt.variant_of_def(self.save_ctxt.get_path_def(p.id));\n+                let variant = adt.variant_of_res(self.save_ctxt.get_path_res(p.id));\n \n                 for &Spanned { node: ref field, .. } in fields {\n                     if let Some(index) = self.tcx.find_field_index(field.ident, variant) {\n@@ -914,8 +914,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n         // process collected paths\n         for (id, ident, immut) in collector.collected_idents {\n-            match self.save_ctxt.get_path_def(id) {\n-                HirDef::Local(hir_id) => {\n+            match self.save_ctxt.get_path_res(id) {\n+                Res::Local(hir_id) => {\n                     let mut value = if immut == ast::Mutability::Immutable {\n                         self.span.snippet(ident.span)\n                     } else {\n@@ -957,14 +957,14 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         );\n                     }\n                 }\n-                HirDef::Ctor(_, _, _) |\n-                HirDef::Const(..) |\n-                HirDef::AssociatedConst(..) |\n-                HirDef::Struct(..) |\n-                HirDef::Variant(..) |\n-                HirDef::TyAlias(..) |\n-                HirDef::AssociatedTy(..) |\n-                HirDef::SelfTy(..) => {\n+                Res::Def(HirDefKind::Ctor(..), _) |\n+                Res::Def(HirDefKind::Const, _) |\n+                Res::Def(HirDefKind::AssociatedConst, _) |\n+                Res::Def(HirDefKind::Struct, _) |\n+                Res::Def(HirDefKind::Variant, _) |\n+                Res::Def(HirDefKind::TyAlias, _) |\n+                Res::Def(HirDefKind::AssociatedTy, _) |\n+                Res::SelfTy(..) => {\n                     self.dump_path_ref(id, &ast::Path::from_ident(ident));\n                 }\n                 def => error!(\n@@ -1538,8 +1538,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     }\n                 };\n                 let node_id = self.save_ctxt.tcx.hir().hir_to_node_id(hir_expr.hir_id);\n-                let def = self.save_ctxt.get_path_def(node_id);\n-                self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n+                let res = self.save_ctxt.get_path_res(node_id);\n+                self.process_struct_lit(ex, path, fields, adt.variant_of_res(res), base)\n             }\n             ast::ExprKind::MethodCall(ref seg, ref args) => self.process_method_call(ex, seg, args),\n             ast::ExprKind::Field(ref sub_ex, _) => {"}, {"sha": "c242b4d6a4123d765e8ef97ef4aee55062bdcdca", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -15,7 +15,7 @@ mod span_utils;\n mod sig;\n \n use rustc::hir;\n-use rustc::hir::def::{CtorOf, Def as HirDef};\n+use rustc::hir::def::{CtorOf, Res, DefKind as HirDefKind};\n use rustc::hir::Node;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevels;\n@@ -606,21 +606,21 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_path_def(&self, id: NodeId) -> HirDef {\n+    pub fn get_path_res(&self, id: NodeId) -> Res {\n         match self.tcx.hir().get(id) {\n-            Node::TraitRef(tr) => tr.path.def,\n+            Node::TraitRef(tr) => tr.path.res,\n \n             Node::Item(&hir::Item {\n                 node: hir::ItemKind::Use(ref path, _),\n                 ..\n             }) |\n             Node::Visibility(&Spanned {\n-                node: hir::VisibilityKind::Restricted { ref path, .. }, .. }) => path.def,\n+                node: hir::VisibilityKind::Restricted { ref path, .. }, .. }) => path.res,\n \n             Node::PathSegment(seg) => {\n-                match seg.def {\n-                    Some(def) if def != HirDef::Err => def,\n-                    _ => self.get_path_def(self.tcx.hir().get_parent_node(id)),\n+                match seg.res {\n+                    Some(res) if res != Res::Err => res,\n+                    _ => self.get_path_res(self.tcx.hir().get_parent_node(id)),\n                 }\n             }\n \n@@ -629,7 +629,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 ..\n             }) => {\n                 let hir_id = self.tcx.hir().node_to_hir_id(id);\n-                self.tables.qpath_def(qpath, hir_id)\n+                self.tables.qpath_res(qpath, hir_id)\n             }\n \n             Node::Expr(&hir::Expr {\n@@ -653,15 +653,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 ..\n             }) => {\n                 let hir_id = self.tcx.hir().node_to_hir_id(id);\n-                self.tables.qpath_def(qpath, hir_id)\n+                self.tables.qpath_res(qpath, hir_id)\n             }\n \n             Node::Binding(&hir::Pat {\n                 node: hir::PatKind::Binding(_, canonical_id, ..),\n                 ..\n-            }) => HirDef::Local(canonical_id),\n+            }) => Res::Local(canonical_id),\n \n-            _ => HirDef::Err,\n+            _ => Res::Err,\n         }\n     }\n \n@@ -697,52 +697,52 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             return None;\n         }\n \n-        let def = self.get_path_def(id);\n+        let res = self.get_path_res(id);\n         let span = path_seg.ident.span;\n         filter!(self.span_utils, span);\n         let span = self.span_from_span(span);\n \n-        match def {\n-            HirDef::Upvar(id, ..) | HirDef::Local(id) => {\n+        match res {\n+            Res::Upvar(id, ..) | Res::Local(id) => {\n                 Some(Ref {\n                     kind: RefKind::Variable,\n                     span,\n                     ref_id: id_from_node_id(self.tcx.hir().hir_to_node_id(id), self),\n                 })\n             }\n-            HirDef::Trait(def_id) if fn_type(path_seg) => {\n+            Res::Def(HirDefKind::Trait, def_id) if fn_type(path_seg) => {\n                 Some(Ref {\n                     kind: RefKind::Type,\n                     span,\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n-            HirDef::Struct(def_id) |\n-            HirDef::Variant(def_id, ..) |\n-            HirDef::Union(def_id) |\n-            HirDef::Enum(def_id) |\n-            HirDef::TyAlias(def_id) |\n-            HirDef::ForeignTy(def_id) |\n-            HirDef::TraitAlias(def_id) |\n-            HirDef::AssociatedExistential(def_id) |\n-            HirDef::AssociatedTy(def_id) |\n-            HirDef::Trait(def_id) |\n-            HirDef::Existential(def_id) |\n-            HirDef::TyParam(def_id) => {\n+            Res::Def(HirDefKind::Struct, def_id) |\n+            Res::Def(HirDefKind::Variant, def_id) |\n+            Res::Def(HirDefKind::Union, def_id) |\n+            Res::Def(HirDefKind::Enum, def_id) |\n+            Res::Def(HirDefKind::TyAlias, def_id) |\n+            Res::Def(HirDefKind::ForeignTy, def_id) |\n+            Res::Def(HirDefKind::TraitAlias, def_id) |\n+            Res::Def(HirDefKind::AssociatedExistential, def_id) |\n+            Res::Def(HirDefKind::AssociatedTy, def_id) |\n+            Res::Def(HirDefKind::Trait, def_id) |\n+            Res::Def(HirDefKind::Existential, def_id) |\n+            Res::Def(HirDefKind::TyParam, def_id) => {\n                 Some(Ref {\n                     kind: RefKind::Type,\n                     span,\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n-            HirDef::ConstParam(def_id) => {\n+            Res::Def(HirDefKind::ConstParam, def_id) => {\n                 Some(Ref {\n                     kind: RefKind::Variable,\n                     span,\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n-            HirDef::Ctor(def_id, CtorOf::Struct, ..) => {\n+            Res::Def(HirDefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n                 // This is a reference to a tuple struct where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n                 // def, so adjust to point to the tuple struct itself.\n@@ -753,17 +753,17 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: id_from_def_id(parent_def_id),\n                 })\n             }\n-            HirDef::Static(..) |\n-            HirDef::Const(..) |\n-            HirDef::AssociatedConst(..) |\n-            HirDef::Ctor(..) => {\n+            Res::Def(HirDefKind::Static, _) |\n+            Res::Def(HirDefKind::Const, _) |\n+            Res::Def(HirDefKind::AssociatedConst, _) |\n+            Res::Def(HirDefKind::Ctor(..), _) => {\n                 Some(Ref {\n                     kind: RefKind::Variable,\n                     span,\n-                    ref_id: id_from_def_id(def.def_id()),\n+                    ref_id: id_from_def_id(res.def_id()),\n                 })\n             }\n-            HirDef::Method(decl_id) => {\n+            Res::Def(HirDefKind::Method, decl_id) => {\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.associated_item(decl_id);\n                     self.tcx\n@@ -780,28 +780,28 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: id_from_def_id(def_id.unwrap_or(decl_id)),\n                 })\n             }\n-            HirDef::Fn(def_id) => {\n+            Res::Def(HirDefKind::Fn, def_id) => {\n                 Some(Ref {\n                     kind: RefKind::Function,\n                     span,\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n-            HirDef::Mod(def_id) => {\n+            Res::Def(HirDefKind::Mod, def_id) => {\n                 Some(Ref {\n                     kind: RefKind::Mod,\n                     span,\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n-            HirDef::PrimTy(..) |\n-            HirDef::SelfTy(..) |\n-            HirDef::Label(..) |\n-            HirDef::Macro(..) |\n-            HirDef::ToolMod |\n-            HirDef::NonMacroAttr(..) |\n-            HirDef::SelfCtor(..) |\n-            HirDef::Err => None,\n+            Res::PrimTy(..) |\n+            Res::SelfTy(..) |\n+            Res::Label(..) |\n+            Res::Def(HirDefKind::Macro(..), _) |\n+            Res::ToolMod |\n+            Res::NonMacroAttr(..) |\n+            Res::SelfCtor(..) |\n+            Res::Err => None,\n         }\n     }\n \n@@ -870,8 +870,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     fn lookup_ref_id(&self, ref_id: NodeId) -> Option<DefId> {\n-        match self.get_path_def(ref_id) {\n-            HirDef::PrimTy(_) | HirDef::SelfTy(..) | HirDef::Err => None,\n+        match self.get_path_res(ref_id) {\n+            Res::PrimTy(_) | Res::SelfTy(..) | Res::Err => None,\n             def => Some(def.def_id()),\n         }\n     }"}, {"sha": "4f759b8a73fccdcf1d7058b94f01093e6bb72bec", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -29,7 +29,7 @@ use crate::{id_from_def_id, id_from_node_id, SaveContext};\n \n use rls_data::{SigElement, Signature};\n \n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Res, DefKind};\n use syntax::ast::{self, NodeId};\n use syntax::print::pprust;\n \n@@ -273,8 +273,8 @@ impl Sig for ast::Ty {\n                 };\n \n                 let name = pprust::path_segment_to_string(path.segments.last().ok_or(\"Bad path\")?);\n-                let def = scx.get_path_def(id.ok_or(\"Missing id for Path\")?);\n-                let id = id_from_def_id(def.def_id());\n+                let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n+                let id = id_from_def_id(res.def_id());\n                 if path.segments.len() - qself.position == 1 {\n                     let start = offset + prefix.len();\n                     let end = start + name.len();\n@@ -576,17 +576,19 @@ impl Sig for ast::Item {\n \n impl Sig for ast::Path {\n     fn make(&self, offset: usize, id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n-        let def = scx.get_path_def(id.ok_or(\"Missing id for Path\")?);\n+        let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n \n-        let (name, start, end) = match def {\n-            Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => {\n+        let (name, start, end) = match res {\n+            Res::Label(..) | Res::PrimTy(..) | Res::SelfTy(..) | Res::Err => {\n                 return Ok(Signature {\n                     text: pprust::path_to_string(self),\n                     defs: vec![],\n                     refs: vec![],\n                 })\n             }\n-            Def::AssociatedConst(..) | Def::Variant(..) | Def::Ctor(..) => {\n+            Res::Def(DefKind::AssociatedConst, _)\n+            | Res::Def(DefKind::Variant, _)\n+            | Res::Def(DefKind::Ctor(..), _) => {\n                 let len = self.segments.len();\n                 if len < 2 {\n                     return Err(\"Bad path\");\n@@ -606,7 +608,7 @@ impl Sig for ast::Path {\n             }\n         };\n \n-        let id = id_from_def_id(def.def_id());\n+        let id = id_from_def_id(res.def_id());\n         Ok(Signature {\n             text: name,\n             defs: vec![],"}, {"sha": "4932d77ef04772dad371e3835fb7c47e599fee55", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 74, "deletions": 80, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -4,7 +4,7 @@\n \n use errors::{Applicability, DiagnosticId};\n use crate::hir::{self, GenericArg, GenericArgs, ExprKind};\n-use crate::hir::def::{CtorOf, Def};\n+use crate::hir::def::{CtorOf, Res, DefKind};\n use crate::hir::def_id::DefId;\n use crate::hir::HirVec;\n use crate::lint;\n@@ -1311,10 +1311,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         hir_ref_id: hir::HirId,\n         span: Span,\n         qself_ty: Ty<'tcx>,\n-        qself_def: Def,\n+        qself_res: Res,\n         assoc_segment: &hir::PathSegment,\n         permit_variants: bool,\n-    ) -> (Ty<'tcx>, Def) {\n+    ) -> Result<(Ty<'tcx>, DefKind, DefId), ErrorReported> {\n         let tcx = self.tcx();\n         let assoc_ident = assoc_segment.ident;\n \n@@ -1330,46 +1330,39 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     tcx.hygienic_eq(assoc_ident, vd.ident, adt_def.did)\n                 });\n                 if let Some(variant_def) = variant_def {\n-                    let def = Def::Variant(variant_def.def_id);\n                     if permit_variants {\n                         check_type_alias_enum_variants_enabled(tcx, span);\n                         tcx.check_stability(variant_def.def_id, Some(hir_ref_id), span);\n-                        return (qself_ty, def);\n+                        return Ok((qself_ty, DefKind::Variant, variant_def.def_id));\n                     } else {\n-                        variant_resolution = Some(def);\n+                        variant_resolution = Some(variant_def.def_id);\n                     }\n                 }\n             }\n         }\n \n         // Find the type of the associated item, and the trait where the associated\n         // item is declared.\n-        let bound = match (&qself_ty.sty, qself_def) {\n-            (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n+        let bound = match (&qself_ty.sty, qself_res) {\n+            (_, Res::SelfTy(Some(_), Some(impl_def_id))) => {\n                 // `Self` in an impl of a trait -- we have a concrete self type and a\n                 // trait reference.\n                 let trait_ref = match tcx.impl_trait_ref(impl_def_id) {\n                     Some(trait_ref) => trait_ref,\n                     None => {\n                         // A cycle error occurred, most likely.\n-                        return (tcx.types.err, Def::Err);\n+                        return Err(ErrorReported);\n                     }\n                 };\n \n                 let candidates = traits::supertraits(tcx, ty::Binder::bind(trait_ref))\n                     .filter(|r| self.trait_defines_associated_type_named(r.def_id(), assoc_ident));\n \n-                match self.one_bound_for_assoc_type(candidates, \"Self\", assoc_ident, span) {\n-                    Ok(bound) => bound,\n-                    Err(ErrorReported) => return (tcx.types.err, Def::Err),\n-                }\n+                self.one_bound_for_assoc_type(candidates, \"Self\", assoc_ident, span)?\n             }\n-            (&ty::Param(_), Def::SelfTy(Some(param_did), None)) |\n-            (&ty::Param(_), Def::TyParam(param_did)) => {\n-                match self.find_bound_for_assoc_item(param_did, assoc_ident, span) {\n-                    Ok(bound) => bound,\n-                    Err(ErrorReported) => return (tcx.types.err, Def::Err),\n-                }\n+            (&ty::Param(_), Res::SelfTy(Some(param_did), None)) |\n+            (&ty::Param(_), Res::Def(DefKind::TyParam, param_did)) => {\n+                self.find_bound_for_assoc_item(param_did, assoc_ident, span)?\n             }\n             _ => {\n                 if variant_resolution.is_some() {\n@@ -1413,7 +1406,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                         &assoc_ident.as_str(),\n                     );\n                 }\n-                return (tcx.types.err, Def::Err);\n+                return Err(ErrorReported);\n             }\n         };\n \n@@ -1427,28 +1420,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let ty = self.projected_ty_from_poly_trait_ref(span, item.def_id, bound);\n         let ty = self.normalize_ty(span, ty);\n \n-        let def = Def::AssociatedTy(item.def_id);\n+        let kind = DefKind::AssociatedTy;\n         if !item.vis.is_accessible_from(def_scope, tcx) {\n-            let msg = format!(\"{} `{}` is private\", def.kind_name(), assoc_ident);\n+            let msg = format!(\"{} `{}` is private\", kind.descr(), assoc_ident);\n             tcx.sess.span_err(span, &msg);\n         }\n         tcx.check_stability(item.def_id, Some(hir_ref_id), span);\n \n-        if let Some(variant_def) = variant_resolution {\n+        if let Some(variant_def_id) = variant_resolution {\n             let mut err = tcx.struct_span_lint_hir(\n                 AMBIGUOUS_ASSOCIATED_ITEMS,\n                 hir_ref_id,\n                 span,\n                 \"ambiguous associated item\",\n             );\n \n-            let mut could_refer_to = |def: Def, also| {\n+            let mut could_refer_to = |kind: DefKind, def_id, also| {\n                 let note_msg = format!(\"`{}` could{} refer to {} defined here\",\n-                                       assoc_ident, also, def.kind_name());\n-                err.span_note(tcx.def_span(def.def_id()), &note_msg);\n+                                       assoc_ident, also, kind.descr());\n+                err.span_note(tcx.def_span(def_id), &note_msg);\n             };\n-            could_refer_to(variant_def, \"\");\n-            could_refer_to(def, \" also\");\n+            could_refer_to(DefKind::Variant, variant_def_id, \"\");\n+            could_refer_to(kind, item.def_id, \" also\");\n \n             err.span_suggestion(\n                 span,\n@@ -1458,7 +1451,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             ).emit();\n         }\n \n-        (ty, def)\n+        Ok((ty, kind, item.def_id))\n     }\n \n     fn qpath_to_ty(&self,\n@@ -1554,11 +1547,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         err.span_label(span, \"associated type not allowed here\").emit();\n     }\n \n-    pub fn def_ids_for_path_segments(&self,\n-                                     segments: &[hir::PathSegment],\n-                                     self_ty: Option<Ty<'tcx>>,\n-                                     def: Def)\n-                                     -> Vec<PathSeg> {\n+    // FIXME(eddyb, varkor) handle type paths here too, not just value ones.\n+    pub fn def_ids_for_value_path_segments(\n+        &self,\n+        segments: &[hir::PathSegment],\n+        self_ty: Option<Ty<'tcx>>,\n+        kind: DefKind,\n+        def_id: DefId,\n+    ) -> Vec<PathSeg> {\n         // We need to extract the type parameters supplied by the user in\n         // the path `path`. Due to the current setup, this is a bit of a\n         // tricky-process; the problem is that resolve only tells us the\n@@ -1602,10 +1598,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         //    `SomeStruct::<A>`, contains parameters in TypeSpace, and the\n         //    final segment, `foo::<B>` contains parameters in fn space.\n         //\n-        // 5. Reference to a local variable\n-        //\n-        //    Local variables can't have any type parameters.\n-        //\n         // The first step then is to categorize the segments appropriately.\n \n         let tcx = self.tcx();\n@@ -1615,10 +1607,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n         let mut path_segs = vec![];\n \n-        match def {\n+        match kind {\n             // Case 1. Reference to a struct constructor.\n-            Def::Ctor(def_id, CtorOf::Struct, ..) |\n-            Def::SelfCtor(.., def_id) => {\n+            DefKind::Ctor(CtorOf::Struct, ..) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n                 let generics = tcx.generics_of(def_id);\n@@ -1629,7 +1620,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n \n             // Case 2. Reference to a variant constructor.\n-            Def::Ctor(def_id, CtorOf::Variant, ..) | Def::Variant(def_id, ..) => {\n+            DefKind::Ctor(CtorOf::Variant, ..)\n+            | DefKind::Variant => {\n                 let adt_def = self_ty.map(|t| t.ty_adt_def().unwrap());\n                 let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n                     debug_assert!(adt_def.is_enum());\n@@ -1639,12 +1631,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     // parameters at all.\n                     let mut def_id = def_id;\n \n-                    // `Def::Ctor` -> `Def::Variant`\n-                    if let Def::Ctor(..) = def {\n+                    // `DefKind::Ctor` -> `DefKind::Variant`\n+                    if let DefKind::Ctor(..) = kind {\n                         def_id = tcx.parent(def_id).unwrap()\n                     }\n \n-                    // `Def::Variant` -> `Def::Item` (enum)\n+                    // `DefKind::Variant` -> `DefKind::Enum`\n                     let enum_def_id = tcx.parent(def_id).unwrap();\n                     (enum_def_id, last - 1)\n                 } else {\n@@ -1662,27 +1654,24 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n \n             // Case 3. Reference to a top-level value.\n-            Def::Fn(def_id) |\n-            Def::Const(def_id) |\n-            Def::ConstParam(def_id) |\n-            Def::Static(def_id) => {\n+            DefKind::Fn\n+            | DefKind::Const\n+            | DefKind::ConstParam\n+            | DefKind::Static => {\n                 path_segs.push(PathSeg(def_id, last));\n             }\n \n             // Case 4. Reference to a method or associated const.\n-            Def::Method(def_id) |\n-            Def::AssociatedConst(def_id) => {\n+            DefKind::Method\n+            | DefKind::AssociatedConst => {\n                 if segments.len() >= 2 {\n                     let generics = tcx.generics_of(def_id);\n                     path_segs.push(PathSeg(generics.parent.unwrap(), last - 1));\n                 }\n                 path_segs.push(PathSeg(def_id, last));\n             }\n \n-            // Case 5. Local variable, no generics.\n-            Def::Local(..) | Def::Upvar(..) => {}\n-\n-            _ => bug!(\"unexpected definition: {:?}\", def),\n+            kind => bug!(\"unexpected definition kind {:?} for {:?}\", kind, def_id),\n         }\n \n         debug!(\"path_segs = {:?}\", path_segs);\n@@ -1691,19 +1680,19 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     }\n \n     // Check a type `Path` and convert it to a `Ty`.\n-    pub fn def_to_ty(&self,\n+    pub fn res_to_ty(&self,\n                      opt_self_ty: Option<Ty<'tcx>>,\n                      path: &hir::Path,\n                      permit_variants: bool)\n                      -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n-        debug!(\"def_to_ty(def={:?}, opt_self_ty={:?}, path_segments={:?})\",\n-               path.def, opt_self_ty, path.segments);\n+        debug!(\"res_to_ty(res={:?}, opt_self_ty={:?}, path_segments={:?})\",\n+               path.res, opt_self_ty, path.segments);\n \n         let span = path.span;\n-        match path.def {\n-            Def::Existential(did) => {\n+        match path.res {\n+            Res::Def(DefKind::Existential, did) => {\n                 // Check for desugared impl trait.\n                 assert!(ty::is_impl_trait_defn(tcx, did).is_none());\n                 let item_segment = path.segments.split_last().unwrap();\n@@ -1714,18 +1703,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     tcx.mk_opaque(did, substs),\n                 )\n             }\n-            Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) |\n-            Def::Union(did) | Def::ForeignTy(did) => {\n+            Res::Def(DefKind::Enum, did)\n+            | Res::Def(DefKind::TyAlias, did)\n+            | Res::Def(DefKind::Struct, did)\n+            | Res::Def(DefKind::Union, did)\n+            | Res::Def(DefKind::ForeignTy, did) => {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n-            Def::Variant(_) if permit_variants => {\n+            Res::Def(kind @ DefKind::Variant, def_id) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n                 assert_eq!(opt_self_ty, None);\n \n-                let path_segs = self.def_ids_for_path_segments(&path.segments, None, path.def);\n+                let path_segs =\n+                    self.def_ids_for_value_path_segments(&path.segments, None, kind, def_id);\n                 let generic_segs: FxHashSet<_> =\n                     path_segs.iter().map(|PathSeg(_, index)| index).collect();\n                 self.prohibit_generics(path.segments.iter().enumerate().filter_map(|(index, seg)| {\n@@ -1739,7 +1732,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 let PathSeg(def_id, index) = path_segs.last().unwrap();\n                 self.ast_path_to_ty(span, *def_id, &path.segments[*index])\n             }\n-            Def::TyParam(did) => {\n+            Res::Def(DefKind::TyParam, did) => {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n \n@@ -1751,20 +1744,20 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     &tcx.hir().local_def_id_from_hir_id(hir_id)];\n                 tcx.mk_ty_param(index, tcx.hir().name_by_hir_id(hir_id).as_interned_str())\n             }\n-            Def::SelfTy(_, Some(def_id)) => {\n+            Res::SelfTy(_, Some(def_id)) => {\n                 // `Self` in impl (we know the concrete type).\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n                 // Try to evaluate any array length constants\n                 self.normalize_ty(span, tcx.at(span).type_of(def_id))\n             }\n-            Def::SelfTy(Some(_), None) => {\n+            Res::SelfTy(Some(_), None) => {\n                 // `Self` in trait.\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n                 tcx.mk_self_type()\n             }\n-            Def::AssociatedTy(def_id) => {\n+            Res::Def(DefKind::AssociatedTy, def_id) => {\n                 debug_assert!(path.segments.len() >= 2);\n                 self.prohibit_generics(&path.segments[..path.segments.len() - 2]);\n                 self.qpath_to_ty(span,\n@@ -1773,7 +1766,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                                  &path.segments[path.segments.len() - 2],\n                                  path.segments.last().unwrap())\n             }\n-            Def::PrimTy(prim_ty) => {\n+            Res::PrimTy(prim_ty) => {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n                 match prim_ty {\n@@ -1785,11 +1778,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     hir::Str => tcx.mk_str()\n                 }\n             }\n-            Def::Err => {\n+            Res::Err => {\n                 self.set_tainted_by_errors();\n                 return self.tcx().types.err;\n             }\n-            _ => span_bug!(span, \"unexpected definition: {:?}\", path.def)\n+            _ => span_bug!(span, \"unexpected resolution: {:?}\", path.res)\n         }\n     }\n \n@@ -1835,7 +1828,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n                     self.ast_ty_to_ty(qself)\n                 });\n-                self.def_to_ty(opt_self_ty, path, false)\n+                self.res_to_ty(opt_self_ty, path, false)\n             }\n             hir::TyKind::Def(item_id, ref lifetimes) => {\n                 let did = tcx.hir().local_def_id_from_hir_id(item_id.id);\n@@ -1845,12 +1838,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n                 let ty = self.ast_ty_to_ty(qself);\n \n-                let def = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.node {\n-                    path.def\n+                let res = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.node {\n+                    path.res\n                 } else {\n-                    Def::Err\n+                    Res::Err\n                 };\n-                self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, def, segment, false).0\n+                self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, res, segment, false)\n+                    .map(|(ty, _, _)| ty).unwrap_or(tcx.types.err)\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n                 let length = self.ast_const_to_const(length, tcx.types.usize);\n@@ -1911,7 +1905,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let expr = &tcx.hir().body(ast_const.body).value;\n         if let ExprKind::Path(ref qpath) = expr.node {\n             if let hir::QPath::Resolved(_, ref path) = qpath {\n-                if let Def::ConstParam(def_id) = path.def {\n+                if let Res::Def(DefKind::ConstParam, def_id) = path.res {\n                     let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n                     let item_id = tcx.hir().get_parent_node(node_id);\n                     let item_def_id = tcx.hir().local_def_id(item_id);\n@@ -2097,16 +2091,16 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n {\n     let (auto_traits, trait_bounds): (Vec<_>, _) = trait_bounds.iter().partition(|bound| {\n         // Checks whether `trait_did` is an auto trait and adds it to `auto_traits` if so.\n-        match bound.trait_ref.path.def {\n-            Def::Trait(trait_did) if tcx.trait_is_auto(trait_did) => {\n+        match bound.trait_ref.path.res {\n+            Res::Def(DefKind::Trait, trait_did) if tcx.trait_is_auto(trait_did) => {\n                 true\n             }\n             _ => false\n         }\n     });\n \n     let auto_traits = auto_traits.into_iter().map(|tr| {\n-        if let Def::Trait(trait_did) = tr.trait_ref.path.def {\n+        if let Res::Def(DefKind::Trait, trait_did) = tr.trait_ref.path.res {\n             trait_did\n         } else {\n             unreachable!()"}, {"sha": "62afbc44d07b689fc38bbb00c933baea7c2c6e13", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -3,7 +3,7 @@ use crate::check::coercion::CoerceMany;\n use crate::util::nodemap::FxHashMap;\n use errors::{Applicability, DiagnosticBuilder};\n use rustc::hir::{self, PatKind, Pat};\n-use rustc::hir::def::{Def, CtorKind};\n+use rustc::hir::def::{Res, DefKind, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer;\n use rustc::infer::type_variable::TypeVariableOrigin;\n@@ -19,7 +19,7 @@ use syntax_pos::Span;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n \n-use super::report_unexpected_variant_def;\n+use super::report_unexpected_variant_res;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// `match_discrim_span` argument having a `Span` indicates that this pattern is part of\n@@ -65,9 +65,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             PatKind::Path(ref qpath) => {\n-                let (def, _, _) = self.resolve_ty_and_def_ufcs(qpath, pat.hir_id, pat.span);\n+                let (def, _, _) = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n                 match def {\n-                    Def::Const(..) | Def::AssociatedConst(..) => false,\n+                    Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssociatedConst, _) => false,\n                     _ => true,\n                 }\n             }\n@@ -840,28 +840,28 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let tcx = self.tcx;\n \n         // Resolve the path and check the definition for errors.\n-        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.hir_id, pat.span);\n-        match def {\n-            Def::Err => {\n+        let (res, opt_ty, segments) = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n+        match res {\n+            Res::Err => {\n                 self.set_tainted_by_errors();\n                 return tcx.types.err;\n             }\n-            Def::Method(..) => {\n-                report_unexpected_variant_def(tcx, &def, pat.span, qpath);\n+            Res::Def(DefKind::Method, _) => {\n+                report_unexpected_variant_res(tcx, res, pat.span, qpath);\n                 return tcx.types.err;\n             }\n-            Def::Ctor(_, _, CtorKind::Fictive) |\n-            Def::Ctor(_, _, CtorKind::Fn) => {\n-                report_unexpected_variant_def(tcx, &def, pat.span, qpath);\n+            Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) |\n+            Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n+                report_unexpected_variant_res(tcx, res, pat.span, qpath);\n                 return tcx.types.err;\n             }\n-            Def::Ctor(_, _, CtorKind::Const) | Def::SelfCtor(..) |\n-            Def::Const(..) | Def::AssociatedConst(..) => {} // OK\n-            _ => bug!(\"unexpected pattern definition: {:?}\", def)\n+            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) | Res::SelfCtor(..) |\n+            Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssociatedConst, _) => {} // OK\n+            _ => bug!(\"unexpected pattern resolution: {:?}\", res)\n         }\n \n         // Type-check the path.\n-        let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.hir_id).0;\n+        let pat_ty = self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id).0;\n         self.demand_suptype(pat.span, expected, pat_ty);\n         pat_ty\n     }\n@@ -882,45 +882,45 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 self.check_pat_walk(&pat, tcx.types.err, def_bm, match_arm_pat_span);\n             }\n         };\n-        let report_unexpected_def = |def: Def| {\n+        let report_unexpected_res = |res: Res| {\n             let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n-                              def.kind_name(),\n+                              res.kind_name(),\n                               hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n             struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n                 .span_label(pat.span, \"not a tuple variant or struct\").emit();\n             on_error();\n         };\n \n         // Resolve the path and check the definition for errors.\n-        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.hir_id, pat.span);\n-        if def == Def::Err {\n+        let (res, opt_ty, segments) = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n+        if res == Res::Err {\n             self.set_tainted_by_errors();\n             on_error();\n             return self.tcx.types.err;\n         }\n \n         // Type-check the path.\n-        let (pat_ty, def) = self.instantiate_value_path(segments, opt_ty, def, pat.span,\n+        let (pat_ty, res) = self.instantiate_value_path(segments, opt_ty, res, pat.span,\n             pat.hir_id);\n         if !pat_ty.is_fn() {\n-            report_unexpected_def(def);\n+            report_unexpected_res(res);\n             return self.tcx.types.err;\n         }\n \n-        let variant = match def {\n-            Def::Err => {\n+        let variant = match res {\n+            Res::Err => {\n                 self.set_tainted_by_errors();\n                 on_error();\n                 return tcx.types.err;\n             }\n-            Def::AssociatedConst(..) | Def::Method(..) => {\n-                report_unexpected_def(def);\n+            Res::Def(DefKind::AssociatedConst, _) | Res::Def(DefKind::Method, _) => {\n+                report_unexpected_res(res);\n                 return tcx.types.err;\n             }\n-            Def::Ctor(_, _, CtorKind::Fn) => {\n-                tcx.expect_variant_def(def)\n+            Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n+                tcx.expect_variant_res(res)\n             }\n-            _ => bug!(\"unexpected pattern definition: {:?}\", def)\n+            _ => bug!(\"unexpected pattern resolution: {:?}\", res)\n         };\n \n         // Replace constructor type with constructed type for tuple struct patterns.\n@@ -947,7 +947,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             let fields_ending = if variant.fields.len() == 1 { \"\" } else { \"s\" };\n             struct_span_err!(tcx.sess, pat.span, E0023,\n                              \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n-                             subpats.len(), subpats_ending, def.kind_name(),\n+                             subpats.len(), subpats_ending, res.kind_name(),\n                              variant.fields.len(),  fields_ending)\n                 .span_label(pat.span, format!(\"expected {} field{}, found {}\",\n                                               variant.fields.len(), fields_ending, subpats.len()))"}, {"sha": "61c281d3dd9d22ed477045b5fb512e7a442f2683", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -3,7 +3,7 @@ use super::method::MethodCallee;\n use super::{Expectation, FnCtxt, Needs, TupleArgumentsFlag};\n \n use errors::{Applicability, DiagnosticBuilder};\n-use hir::def::Def;\n+use hir::def::Res;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -317,7 +317,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let mut inner_callee_path = None;\n                     let def = match callee.node {\n                         hir::ExprKind::Path(ref qpath) => {\n-                            self.tables.borrow().qpath_def(qpath, callee.hir_id)\n+                            self.tables.borrow().qpath_res(qpath, callee.hir_id)\n                         }\n                         hir::ExprKind::Call(ref inner_callee, _) => {\n                             // If the call spans more than one line and the callee kind is\n@@ -338,19 +338,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 inner_callee_path = Some(inner_qpath);\n                                 self.tables\n                                     .borrow()\n-                                    .qpath_def(inner_qpath, inner_callee.hir_id)\n+                                    .qpath_res(inner_qpath, inner_callee.hir_id)\n                             } else {\n-                                Def::Err\n+                                Res::Err\n                             }\n                         }\n-                        _ => Def::Err,\n+                        _ => Res::Err,\n                     };\n \n                     err.span_label(call_expr.span, \"call expression requires function\");\n \n                     let def_span = match def {\n-                        Def::Err => None,\n-                        Def::Local(id) | Def::Upvar(id, ..) => {\n+                        Res::Err => None,\n+                        Res::Local(id) | Res::Upvar(id, ..) => {\n                             Some(self.tcx.hir().span_by_hir_id(id))\n                         },\n                         _ => def"}, {"sha": "647d947485e689282c8b3a60088b30ffa1d4d8e5", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -1,4 +1,5 @@\n use rustc::hir::{self, GenericParamKind, ImplItemKind, TraitItemKind};\n+use rustc::hir::def::{Res, DefKind};\n use rustc::infer::{self, InferOk};\n use rustc::ty::{self, TyCtxt, GenericParamDefKind};\n use rustc::ty::util::ExplicitSelf;\n@@ -844,7 +845,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 if let hir::TyKind::Path(\n                                     hir::QPath::Resolved(None, ref path)) = ty.node\n                                 {\n-                                    if let hir::def::Def::TyParam(def_id) = path.def {\n+                                    if let Res::Def(DefKind::TyParam, def_id) = path.res {\n                                         if def_id == self.1 {\n                                             self.0 = Some(ty.span);\n                                         }"}, {"sha": "1377f88df8f218d9bad53e270fc2f67b994e9153", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -5,7 +5,6 @@ use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use syntax::util::parser::PREC_POSTFIX;\n use syntax_pos::Span;\n use rustc::hir;\n-use rustc::hir::def::Def;\n use rustc::hir::Node;\n use rustc::hir::{print, lowering::is_range_literal};\n use rustc::ty::{self, Ty, AssociatedItem};\n@@ -206,9 +205,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     // This function checks if the method isn't static and takes other arguments than `self`.\n     fn has_no_input_arg(&self, method: &AssociatedItem) -> bool {\n-        match method.def() {\n-            Def::Method(def_id) => {\n-                self.tcx.fn_sig(def_id).inputs().skip_binder().len() == 1\n+        match method.kind {\n+            ty::AssociatedKind::Method => {\n+                self.tcx.fn_sig(method.def_id).inputs().skip_binder().len() == 1\n             }\n             _ => false,\n         }\n@@ -235,7 +234,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         expr: &hir::Expr,\n     ) -> Option<(Span, &'static str, String)> {\n         if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.node {\n-            if let hir::def::Def::Local(id) = path.def {\n+            if let hir::def::Res::Local(id) = path.res {\n                 let parent = self.tcx.hir().get_parent_node_by_hir_id(id);\n                 if let Some(Node::Expr(hir::Expr {\n                     hir_id,"}, {"sha": "bbdc7df4441e808e17a6b520ecbe1c8ebe8fe15c", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -15,7 +15,7 @@ use crate::namespace::Namespace;\n use errors::{Applicability, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n use rustc::hir;\n-use rustc::hir::def::{CtorOf, Def};\n+use rustc::hir::def::{CtorOf, DefKind};\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n@@ -53,9 +53,9 @@ pub enum MethodError<'tcx> {\n     // Multiple methods might apply.\n     Ambiguity(Vec<CandidateSource>),\n \n-    // Found an applicable method, but it is not visible. The second argument contains a list of\n+    // Found an applicable method, but it is not visible. The third argument contains a list of\n     // not-in-scope traits which may work.\n-    PrivateMatch(Def, Vec<DefId>),\n+    PrivateMatch(DefKind, DefId, Vec<DefId>),\n \n     // Found a `Self: Sized` bound where `Self` is a trait object, also the caller may have\n     // forgotten to import a trait.\n@@ -400,7 +400,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         method_name: ast::Ident,\n         self_ty: Ty<'tcx>,\n         expr_id: hir::HirId\n-    ) -> Result<Def, MethodError<'tcx>> {\n+    ) -> Result<(DefKind, DefId), MethodError<'tcx>> {\n         debug!(\n             \"resolve_ufcs: method_name={:?} self_ty={:?} expr_id={:?}\",\n             method_name, self_ty, expr_id,\n@@ -422,9 +422,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // them as well. It's ok to use the variant's id as a ctor id since an\n                     // error will be reported on any use of such resolution anyway.\n                     let ctor_def_id = variant_def.ctor_def_id.unwrap_or(variant_def.def_id);\n-                    let def = Def::Ctor(ctor_def_id, CtorOf::Variant, variant_def.ctor_kind);\n-                    tcx.check_stability(def.def_id(), Some(expr_id), span);\n-                    return Ok(def);\n+                    tcx.check_stability(ctor_def_id, Some(expr_id), span);\n+                    return Ok((\n+                        DefKind::Ctor(CtorOf::Variant, variant_def.ctor_kind),\n+                        ctor_def_id,\n+                    ));\n                 }\n             }\n         }\n@@ -439,10 +441,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 .unwrap().insert(import_def_id);\n         }\n \n-        let def = pick.item.def();\n-        debug!(\"resolve_ufcs: def={:?}\", def);\n-        tcx.check_stability(def.def_id(), Some(expr_id), span);\n-        Ok(def)\n+        let def_kind = pick.item.def_kind();\n+        debug!(\"resolve_ufcs: def_kind={:?}, def_id={:?}\", def_kind, pick.item.def_id);\n+        tcx.check_stability(pick.item.def_id, Some(expr_id), span);\n+        Ok((def_kind, pick.item.def_id))\n     }\n \n     /// Finds item with name `item_name` defined in impl/trait `def_id`"}, {"sha": "8c61a127d1014cbca72211e373140e777e8c3db5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -6,7 +6,7 @@ use super::suggest;\n use crate::check::autoderef::{self, Autoderef};\n use crate::check::FnCtxt;\n use crate::hir::def_id::DefId;\n-use crate::hir::def::Def;\n+use crate::hir::def::DefKind;\n use crate::namespace::Namespace;\n \n use rustc_data_structures::sync::Lrc;\n@@ -68,7 +68,7 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     allow_similar_names: bool,\n \n     /// Some(candidate) if there is a private candidate\n-    private_candidate: Option<Def>,\n+    private_candidate: Option<(DefKind, DefId)>,\n \n     /// Collects near misses when trait bounds for type parameters are unsatisfied and is only used\n     /// for error reporting\n@@ -520,7 +520,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 self.extension_candidates.push(candidate);\n             }\n         } else if self.private_candidate.is_none() {\n-            self.private_candidate = Some(candidate.item.def());\n+            self.private_candidate =\n+                Some((candidate.item.def_kind(), candidate.item.def_id));\n         }\n     }\n \n@@ -861,9 +862,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                method: &ty::AssociatedItem,\n                                self_ty: Option<Ty<'tcx>>,\n                                expected: Ty<'tcx>) -> bool {\n-        match method.def() {\n-            Def::Method(def_id) => {\n-                let fty = self.tcx.fn_sig(def_id);\n+        match method.kind {\n+            ty::AssociatedKind::Method => {\n+                let fty = self.tcx.fn_sig(method.def_id);\n                 self.probe(|_| {\n                     let substs = self.fresh_substs_for_item(self.span, method.def_id);\n                     let fty = fty.subst(self.tcx, substs);\n@@ -1004,8 +1005,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             _ => vec![],\n         };\n \n-        if let Some(def) = private_candidate {\n-            return Err(MethodError::PrivateMatch(def, out_of_scope_traits));\n+        if let Some((kind, def_id)) = private_candidate {\n+            return Err(MethodError::PrivateMatch(kind, def_id, out_of_scope_traits));\n         }\n         let lev_candidate = self.probe_for_lev_candidate()?;\n "}, {"sha": "b57ae361eb69e7fdbae7f245bee1d18c436ca444", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -8,7 +8,7 @@ use crate::util::nodemap::FxHashSet;\n use errors::{Applicability, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n use rustc::hir::{self, ExprKind, Node, QPath};\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::hir::map as hir_map;\n use rustc::hir::print;\n@@ -249,7 +249,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             ExprKind::Path(ref qpath) => {\n                                 // local binding\n                                 if let &QPath::Resolved(_, ref path) = &qpath {\n-                                    if let hir::def::Def::Local(hir_id) = path.def {\n+                                    if let hir::def::Res::Local(hir_id) = path.res {\n                                         let span = tcx.hir().span_by_hir_id(hir_id);\n                                         let snippet = tcx.sess.source_map().span_to_snippet(span)\n                                             .unwrap();\n@@ -483,13 +483,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 if let Some(lev_candidate) = lev_candidate {\n-                    let def = lev_candidate.def();\n+                    let def_kind = lev_candidate.def_kind();\n                     err.span_suggestion(\n                         span,\n                         &format!(\n                             \"there is {} {} with a similar name\",\n-                            def.article(),\n-                            def.kind_name(),\n+                            def_kind.article(),\n+                            def_kind.descr(),\n                         ),\n                         lev_candidate.ident.to_string(),\n                         Applicability::MaybeIncorrect,\n@@ -510,9 +510,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 err.emit();\n             }\n \n-            MethodError::PrivateMatch(def, out_of_scope_traits) => {\n+            MethodError::PrivateMatch(kind, _, out_of_scope_traits) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0624,\n-                                               \"{} `{}` is private\", def.kind_name(), item_name);\n+                                               \"{} `{}` is private\", kind.descr(), item_name);\n                 self.suggest_valid_traits(&mut err, out_of_scope_traits);\n                 err.emit();\n             }\n@@ -799,21 +799,21 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n     // Cross-crate:\n \n     let mut external_mods = FxHashSet::default();\n-    fn handle_external_def(tcx: TyCtxt<'_, '_, '_>,\n+    fn handle_external_res(tcx: TyCtxt<'_, '_, '_>,\n                            traits: &mut Vec<DefId>,\n                            external_mods: &mut FxHashSet<DefId>,\n-                           def: Def) {\n-        match def {\n-            Def::Trait(def_id) |\n-            Def::TraitAlias(def_id) => {\n+                           res: Res) {\n+        match res {\n+            Res::Def(DefKind::Trait, def_id) |\n+            Res::Def(DefKind::TraitAlias, def_id) => {\n                 traits.push(def_id);\n             }\n-            Def::Mod(def_id) => {\n+            Res::Def(DefKind::Mod, def_id) => {\n                 if !external_mods.insert(def_id) {\n                     return;\n                 }\n                 for child in tcx.item_children(def_id).iter() {\n-                    handle_external_def(tcx, traits, external_mods, child.def)\n+                    handle_external_res(tcx, traits, external_mods, child.res)\n                 }\n             }\n             _ => {}\n@@ -824,7 +824,7 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n             krate: cnum,\n             index: CRATE_DEF_INDEX,\n         };\n-        handle_external_def(tcx, &mut traits, &mut external_mods, Def::Mod(def_id));\n+        handle_external_res(tcx, &mut traits, &mut external_mods, Res::Def(DefKind::Mod, def_id));\n     }\n \n     traits"}, {"sha": "4ae75511322b63b13c4dcb1dce57e589fa618eae", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 109, "deletions": 78, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -88,7 +88,7 @@ mod op;\n use crate::astconv::{AstConv, PathSeg};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc::hir::{self, ExprKind, GenericArg, ItemKind, Node, PatKind, QPath};\n-use rustc::hir::def::{CtorOf, CtorKind, Def};\n+use rustc::hir::def::{CtorOf, CtorKind, Res, DefKind};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -1896,13 +1896,13 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_representable(tcx, sp, def_id);\n }\n \n-fn report_unexpected_variant_def<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                 def: &Def,\n+fn report_unexpected_variant_res<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                 res: Res,\n                                                  span: Span,\n                                                  qpath: &QPath) {\n     span_err!(tcx.sess, span, E0533,\n               \"expected unit struct/variant or constant, found {} `{}`\",\n-              def.kind_name(),\n+              res.kind_name(),\n               hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n }\n \n@@ -2149,7 +2149,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tables\n             .borrow_mut()\n             .type_dependent_defs_mut()\n-            .insert(hir_id, Def::Method(method.def_id));\n+            .insert(hir_id, Ok((DefKind::Method, method.def_id)));\n \n         self.write_substs(hir_id, method.substs);\n \n@@ -3922,20 +3922,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n         let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, hir_id);\n         let variant = match def {\n-            Def::Err => {\n+            Res::Err => {\n                 self.set_tainted_by_errors();\n                 return None;\n             }\n-            Def::Variant(..) => {\n+            Res::Def(DefKind::Variant, _) => {\n                 match ty.sty {\n                     ty::Adt(adt, substs) => {\n-                        Some((adt.variant_of_def(def), adt.did, substs))\n+                        Some((adt.variant_of_res(def), adt.did, substs))\n                     }\n                     _ => bug!(\"unexpected type: {:?}\", ty)\n                 }\n             }\n-            Def::Struct(..) | Def::Union(..) | Def::TyAlias(..) |\n-            Def::AssociatedTy(..) | Def::SelfTy(..) => {\n+            Res::Def(DefKind::Struct, _)\n+            | Res::Def(DefKind::Union, _)\n+            | Res::Def(DefKind::TyAlias, _)\n+            | Res::Def(DefKind::AssociatedTy, _)\n+            | Res::SelfTy(..) => {\n                 match ty.sty {\n                     ty::Adt(adt, substs) if !adt.is_enum() => {\n                         Some((adt.non_enum_variant(), adt.did, substs))\n@@ -4230,18 +4233,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             ExprKind::Path(ref qpath) => {\n-                let (def, opt_ty, segs) = self.resolve_ty_and_def_ufcs(qpath, expr.hir_id,\n+                let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id,\n                     expr.span);\n-                let ty = match def {\n-                    Def::Err => {\n+                let ty = match res {\n+                    Res::Err => {\n                         self.set_tainted_by_errors();\n                         tcx.types.err\n                     }\n-                    Def::Ctor(_, _, CtorKind::Fictive) => {\n-                        report_unexpected_variant_def(tcx, &def, expr.span, qpath);\n+                    Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n+                        report_unexpected_variant_res(tcx, res, expr.span, qpath);\n                         tcx.types.err\n                     }\n-                    _ => self.instantiate_value_path(segs, opt_ty, def, expr.span, id).0,\n+                    _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, id).0,\n                 };\n \n                 if let ty::FnDef(..) = ty.sty {\n@@ -4778,80 +4781,94 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     qpath: &QPath,\n                                     path_span: Span,\n                                     hir_id: hir::HirId)\n-                                    -> (Def, Ty<'tcx>)\n+                                    -> (Res, Ty<'tcx>)\n     {\n         match *qpath {\n             QPath::Resolved(ref maybe_qself, ref path) => {\n                 let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n-                let ty = AstConv::def_to_ty(self, self_ty, path, true);\n-                (path.def, ty)\n+                let ty = AstConv::res_to_ty(self, self_ty, path, true);\n+                (path.res, ty)\n             }\n             QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n-                let def = if let hir::TyKind::Path(QPath::Resolved(_, ref path)) = qself.node {\n-                    path.def\n+                let res = if let hir::TyKind::Path(QPath::Resolved(_, ref path)) = qself.node {\n+                    path.res\n                 } else {\n-                    Def::Err\n+                    Res::Err\n                 };\n-                let (ty, def) = AstConv::associated_path_to_ty(self, hir_id, path_span,\n-                                                               ty, def, segment, true);\n+                let result = AstConv::associated_path_to_ty(\n+                    self,\n+                    hir_id,\n+                    path_span,\n+                    ty,\n+                    res,\n+                    segment,\n+                    true,\n+                );\n+                let ty = result.map(|(ty, _, _)| ty).unwrap_or(self.tcx().types.err);\n+                let result = result.map(|(_, kind, def_id)| (kind, def_id));\n \n                 // Write back the new resolution.\n-                self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, def);\n+                self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, result);\n \n-                (def, ty)\n+                (result.map(|(kind, def_id)| Res::Def(kind, def_id)).unwrap_or(Res::Err), ty)\n             }\n         }\n     }\n \n     /// Resolves associated value path into a base type and associated constant or method\n-    /// definition. The newly resolved definition is written into `type_dependent_defs`.\n-    pub fn resolve_ty_and_def_ufcs<'b>(&self,\n+    /// resolution. The newly resolved definition is written into `type_dependent_defs`.\n+    pub fn resolve_ty_and_res_ufcs<'b>(&self,\n                                        qpath: &'b QPath,\n                                        hir_id: hir::HirId,\n                                        span: Span)\n-                                       -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n+                                       -> (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n-        debug!(\"resolve_ty_and_def_ufcs: qpath={:?} hir_id={:?} span={:?}\", qpath, hir_id, span);\n+        debug!(\"resolve_ty_and_res_ufcs: qpath={:?} hir_id={:?} span={:?}\", qpath, hir_id, span);\n         let (ty, qself, item_segment) = match *qpath {\n             QPath::Resolved(ref opt_qself, ref path) => {\n-                return (path.def,\n+                return (path.res,\n                         opt_qself.as_ref().map(|qself| self.to_ty(qself)),\n                         &path.segments[..]);\n             }\n             QPath::TypeRelative(ref qself, ref segment) => {\n                 (self.to_ty(qself), qself, segment)\n             }\n         };\n-        if let Some(cached_def) = self.tables.borrow().type_dependent_def(hir_id) {\n+        if let Some(&cached_result) = self.tables.borrow().type_dependent_defs().get(hir_id) {\n             // Return directly on cache hit. This is useful to avoid doubly reporting\n             // errors with default match binding modes. See #44614.\n-            return (cached_def, Some(ty), slice::from_ref(&**item_segment))\n+            let def = cached_result.map(|(kind, def_id)| Res::Def(kind, def_id))\n+                .unwrap_or(Res::Err);\n+            return (def, Some(ty), slice::from_ref(&**item_segment));\n         }\n         let item_name = item_segment.ident;\n-        let def = match self.resolve_ufcs(span, item_name, ty, hir_id) {\n-            Ok(def) => def,\n-            Err(error) => {\n-                let def = match error {\n-                    method::MethodError::PrivateMatch(def, _) => def,\n-                    _ => Def::Err,\n-                };\n-                if item_name.name != keywords::Invalid.name() {\n-                    self.report_method_error(span,\n-                                             ty,\n-                                             item_name,\n-                                             SelfSource::QPath(qself),\n-                                             error,\n-                                             None);\n-                }\n-                def\n+        let result = self.resolve_ufcs(span, item_name, ty, hir_id).or_else(|error| {\n+            let result = match error {\n+                method::MethodError::PrivateMatch(kind, def_id, _) => Ok((kind, def_id)),\n+                _ => Err(ErrorReported),\n+            };\n+            if item_name.name != keywords::Invalid.name() {\n+                self.report_method_error(\n+                    span,\n+                    ty,\n+                    item_name,\n+                    SelfSource::QPath(qself),\n+                    error,\n+                    None,\n+                );\n             }\n-        };\n+            result\n+        });\n \n         // Write back the new resolution.\n-        self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, def);\n-        (def, Some(ty), slice::from_ref(&**item_segment))\n+        self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, result);\n+        (\n+            result.map(|(kind, def_id)| Res::Def(kind, def_id)).unwrap_or(Res::Err),\n+            Some(ty),\n+            slice::from_ref(&**item_segment),\n+        )\n     }\n \n     pub fn check_decl_initializer(&self,\n@@ -5352,18 +5369,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Rewrite `SelfCtor` to `Ctor`\n-    pub fn rewrite_self_ctor(&self, def: Def, span: Span) -> (Def, DefId, Ty<'tcx>) {\n+    pub fn rewrite_self_ctor(\n+        &self,\n+        res: Res,\n+        span: Span,\n+    ) -> Result<(DefKind, DefId, Ty<'tcx>), ErrorReported> {\n         let tcx = self.tcx;\n-        if let Def::SelfCtor(impl_def_id) = def {\n+        if let Res::SelfCtor(impl_def_id) = res {\n             let ty = self.impl_self_ty(span, impl_def_id).ty;\n             let adt_def = ty.ty_adt_def();\n \n             match adt_def {\n                 Some(adt_def) if adt_def.has_ctor() => {\n                     let variant = adt_def.non_enum_variant();\n                     let ctor_def_id = variant.ctor_def_id.unwrap();\n-                    let def = Def::Ctor(ctor_def_id, CtorOf::Struct, variant.ctor_kind);\n-                    (def, ctor_def_id, tcx.type_of(ctor_def_id))\n+                    Ok((\n+                        DefKind::Ctor(CtorOf::Struct, variant.ctor_kind),\n+                        ctor_def_id,\n+                        tcx.type_of(ctor_def_id),\n+                    ))\n                 }\n                 _ => {\n                     let mut err = tcx.sess.struct_span_err(span,\n@@ -5386,16 +5410,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     err.emit();\n \n-                    (def, impl_def_id, tcx.types.err)\n+                    Err(ErrorReported)\n                 }\n             }\n         } else {\n-            let def_id = def.def_id();\n-\n-            // The things we are substituting into the type should not contain\n-            // escaping late-bound regions, and nor should the base type scheme.\n-            let ty = tcx.type_of(def_id);\n-            (def, def_id, ty)\n+            match res {\n+                Res::Def(kind, def_id) => {\n+                    // The things we are substituting into the type should not contain\n+                    // escaping late-bound regions, and nor should the base type scheme.\n+                    let ty = tcx.type_of(def_id);\n+                    Ok((kind, def_id, ty))\n+                }\n+                _ => span_bug!(span, \"unexpected res in rewrite_self_ctor: {:?}\", res),\n+            }\n         }\n     }\n \n@@ -5404,37 +5431,41 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn instantiate_value_path(&self,\n                                   segments: &[hir::PathSegment],\n                                   self_ty: Option<Ty<'tcx>>,\n-                                  def: Def,\n+                                  res: Res,\n                                   span: Span,\n                                   hir_id: hir::HirId)\n-                                  -> (Ty<'tcx>, Def) {\n+                                  -> (Ty<'tcx>, Res) {\n         debug!(\n-            \"instantiate_value_path(segments={:?}, self_ty={:?}, def={:?}, hir_id={})\",\n+            \"instantiate_value_path(segments={:?}, self_ty={:?}, res={:?}, hir_id={})\",\n             segments,\n             self_ty,\n-            def,\n+            res,\n             hir_id,\n         );\n \n         let tcx = self.tcx;\n \n-        match def {\n-            Def::Local(hid) | Def::Upvar(hid, ..) => {\n+        match res {\n+            Res::Local(hid) | Res::Upvar(hid, ..) => {\n                 let ty = self.local_ty(span, hid).decl_ty;\n                 let ty = self.normalize_associated_types_in(span, &ty);\n                 self.write_ty(hir_id, ty);\n-                return (ty, def);\n+                return (ty, res);\n             }\n             _ => {}\n         }\n \n-        let (def, def_id, ty) = self.rewrite_self_ctor(def, span);\n-        let path_segs = AstConv::def_ids_for_path_segments(self, segments, self_ty, def);\n+        let (kind, def_id, ty) = match self.rewrite_self_ctor(res, span) {\n+            Ok(result) => result,\n+            Err(ErrorReported) => return (tcx.types.err, res),\n+        };\n+        let path_segs =\n+            AstConv::def_ids_for_value_path_segments(self, segments, self_ty, kind, def_id);\n \n         let mut user_self_ty = None;\n         let mut is_alias_variant_ctor = false;\n-        match def {\n-            Def::Ctor(_, CtorOf::Variant, _) => {\n+        match kind {\n+            DefKind::Ctor(CtorOf::Variant, _) => {\n                 if let Some(self_ty) = self_ty {\n                     let adt_def = self_ty.ty_adt_def().unwrap();\n                     user_self_ty = Some(UserSelfTy {\n@@ -5444,10 +5475,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     is_alias_variant_ctor = true;\n                 }\n             }\n-            Def::Method(def_id) |\n-            Def::AssociatedConst(def_id) => {\n+            DefKind::Method\n+            | DefKind::AssociatedConst => {\n                 let container = tcx.associated_item(def_id).container;\n-                debug!(\"instantiate_value_path: def={:?} container={:?}\", def, container);\n+                debug!(\"instantiate_value_path: def_id={:?} container={:?}\", def_id, container);\n                 match container {\n                     ty::TraitContainer(trait_did) => {\n                         callee::check_legal_trait_for_method_call(tcx, span, trait_did)\n@@ -5637,7 +5668,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                ty_substituted);\n         self.write_substs(hir_id, substs);\n \n-        (ty_substituted, def)\n+        (ty_substituted, Res::Def(kind, def_id))\n     }\n \n     fn check_rustc_args_require_const(&self,"}, {"sha": "ed8ac89912c1279374a87b485b3e3b4487d968e6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -42,7 +42,7 @@ use syntax::feature_gate;\n use syntax::symbol::{keywords, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n \n-use rustc::hir::def::{CtorKind, Def};\n+use rustc::hir::def::{CtorKind, Res, DefKind};\n use rustc::hir::Node;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -380,8 +380,8 @@ fn is_param<'a, 'tcx>(\n     param_id: hir::HirId,\n ) -> bool {\n     if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n-        match path.def {\n-            Def::SelfTy(Some(def_id), None) | Def::TyParam(def_id) => {\n+        match path.res {\n+            Res::SelfTy(Some(def_id), None) | Res::Def(DefKind::TyParam, def_id) => {\n                 def_id == tcx.hir().local_def_id_from_hir_id(param_id)\n             }\n             _ => false,\n@@ -1377,14 +1377,14 @@ pub fn checked_type_of<'a, 'tcx>(\n                                 }\n                                 bug!(\"no arg matching AnonConst in path\")\n                             }\n-                            match path.def {\n+                            match path.res {\n                                 // We've encountered an `AnonConst` in some path, so we need to\n                                 // figure out which generic parameter it corresponds to and return\n                                 // the relevant type.\n-                                Def::Struct(def_id)\n-                                | Def::Union(def_id)\n-                                | Def::Enum(def_id)\n-                                | Def::Fn(def_id) => {\n+                                Res::Def(DefKind::Struct, def_id)\n+                                | Res::Def(DefKind::Union, def_id)\n+                                | Res::Def(DefKind::Enum, def_id)\n+                                | Res::Def(DefKind::Fn, def_id) => {\n                                     let generics = tcx.generics_of(def_id);\n                                     let mut param_index = 0;\n                                     for param in &generics.params {\n@@ -1399,7 +1399,7 @@ pub fn checked_type_of<'a, 'tcx>(\n                                     // probably from an extra arg where one is not needed.\n                                     return Some(tcx.types.err);\n                                 }\n-                                Def::Err => tcx.types.err,\n+                                Res::Err => tcx.types.err,\n                                 x => {\n                                     if !fail {\n                                         return None;\n@@ -1778,7 +1778,7 @@ fn is_unsized<'gcx: 'tcx, 'tcx>(\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n             if let Ok(kind_id) = kind_id {\n-                if tpb.path.def != Def::Trait(kind_id) {\n+                if tpb.path.res != Res::Def(DefKind::Trait, kind_id) {\n                     tcx.sess.span_warn(\n                         span,\n                         \"default bound relaxed for a type parameter, but \\"}, {"sha": "d9d6b8e07e99482a5b8872290ff807ce3774c248", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -7,7 +7,7 @@ use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax_pos::Span;\n \n use rustc::hir;\n-use rustc::hir::def::{Def, CtorKind};\n+use rustc::hir::def::{Res, DefKind, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc_metadata::cstore::LoadedMacro;\n use rustc::ty;\n@@ -37,72 +37,71 @@ use super::Clean;\n /// and `Some` of a vector of items if it was successfully expanded.\n pub fn try_inline(\n     cx: &DocContext<'_>,\n-    def: Def,\n+    res: Res,\n     name: ast::Name,\n     visited: &mut FxHashSet<DefId>\n-)\n-                  -> Option<Vec<clean::Item>> {\n-    let did = if let Some(did) = def.opt_def_id() {\n+) -> Option<Vec<clean::Item>> {\n+    let did = if let Some(did) = res.opt_def_id() {\n         did\n     } else {\n         return None;\n     };\n     if did.is_local() { return None }\n     let mut ret = Vec::new();\n-    let inner = match def {\n-        Def::Trait(did) => {\n+    let inner = match res {\n+        Res::Def(DefKind::Trait, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Trait);\n             ret.extend(build_impls(cx, did));\n             clean::TraitItem(build_external_trait(cx, did))\n         }\n-        Def::Fn(did) => {\n+        Res::Def(DefKind::Fn, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Function);\n             clean::FunctionItem(build_external_function(cx, did))\n         }\n-        Def::Struct(did) => {\n+        Res::Def(DefKind::Struct, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Struct);\n             ret.extend(build_impls(cx, did));\n             clean::StructItem(build_struct(cx, did))\n         }\n-        Def::Union(did) => {\n+        Res::Def(DefKind::Union, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Union);\n             ret.extend(build_impls(cx, did));\n             clean::UnionItem(build_union(cx, did))\n         }\n-        Def::TyAlias(did) => {\n+        Res::Def(DefKind::TyAlias, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Typedef);\n             ret.extend(build_impls(cx, did));\n             clean::TypedefItem(build_type_alias(cx, did), false)\n         }\n-        Def::Enum(did) => {\n+        Res::Def(DefKind::Enum, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Enum);\n             ret.extend(build_impls(cx, did));\n             clean::EnumItem(build_enum(cx, did))\n         }\n-        Def::ForeignTy(did) => {\n+        Res::Def(DefKind::ForeignTy, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Foreign);\n             ret.extend(build_impls(cx, did));\n             clean::ForeignTypeItem\n         }\n         // Never inline enum variants but leave them shown as re-exports.\n-        Def::Variant(..) => return None,\n+        Res::Def(DefKind::Variant, _) => return None,\n         // Assume that enum variants and struct types are re-exported next to\n         // their constructors.\n-        Def::Ctor(..) | Def::SelfCtor(..) => return Some(Vec::new()),\n-        Def::Mod(did) => {\n+        Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => return Some(Vec::new()),\n+        Res::Def(DefKind::Mod, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Module);\n             clean::ModuleItem(build_module(cx, did, visited))\n         }\n-        Def::Static(did) => {\n+        Res::Def(DefKind::Static, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Static);\n             clean::StaticItem(build_static(cx, did, cx.tcx.is_mutable_static(did)))\n         }\n-        Def::Const(did) => {\n+        Res::Def(DefKind::Const, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Const);\n             clean::ConstantItem(build_const(cx, did))\n         }\n         // FIXME: proc-macros don't propagate attributes or spans across crates, so they look empty\n-        Def::Macro(did, MacroKind::Bang) => {\n+        Res::Def(DefKind::Macro(MacroKind::Bang), did) => {\n             let mac = build_macro(cx, did, name);\n             if let clean::MacroItem(..) = mac {\n                 record_extern_fqn(cx, did, clean::TypeKind::Macro);\n@@ -127,15 +126,15 @@ pub fn try_inline(\n     Some(ret)\n }\n \n-pub fn try_inline_glob(cx: &DocContext<'_>, def: Def, visited: &mut FxHashSet<DefId>)\n+pub fn try_inline_glob(cx: &DocContext<'_>, res: Res, visited: &mut FxHashSet<DefId>)\n     -> Option<Vec<clean::Item>>\n {\n-    if def == Def::Err { return None }\n-    let did = def.def_id();\n+    if res == Res::Err { return None }\n+    let did = res.def_id();\n     if did.is_local() { return None }\n \n-    match def {\n-        Def::Mod(did) => {\n+    match res {\n+        Res::Def(DefKind::Mod, did) => {\n             let m = build_module(cx, did, visited);\n             Some(m.items)\n         }\n@@ -413,10 +412,10 @@ fn build_module(\n         // two namespaces, so the target may be listed twice. Make sure we only\n         // visit each node at most once.\n         for &item in cx.tcx.item_children(did).iter() {\n-            let def_id = item.def.def_id();\n+            let def_id = item.res.def_id();\n             if item.vis == ty::Visibility::Public {\n                 if did == def_id || !visited.insert(def_id) { continue }\n-                if let Some(i) = try_inline(cx, item.def, item.ident.name, visited) {\n+                if let Some(i) = try_inline(cx, item.res, item.ident.name, visited) {\n                     items.extend(i)\n                 }\n             }"}, {"sha": "de74a6a540055c9c79d4e4ef942ad6eeafb3a52c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 93, "deletions": 80, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -19,7 +19,7 @@ use rustc::middle::lang_items;\n use rustc::middle::stability;\n use rustc::mir::interpret::{GlobalId, ConstValue};\n use rustc::hir::{self, HirVec};\n-use rustc::hir::def::{self, Def, CtorKind};\n+use rustc::hir::def::{self, Res, DefKind, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::ty::subst::{InternalSubsts, SubstsRef, UnpackedKind};\n use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n@@ -257,8 +257,8 @@ impl Clean<ExternalCrate> for CrateNum {\n         // Also note that this does not attempt to deal with modules tagged\n         // duplicately for the same primitive. This is handled later on when\n         // rendering by delegating everything to a hash map.\n-        let as_primitive = |def: Def| {\n-            if let Def::Mod(def_id) = def {\n+        let as_primitive = |res: Res| {\n+            if let Res::Def(DefKind::Mod, def_id) = res {\n                 let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n                 let mut prim = None;\n                 for attr in attrs.lists(\"doc\") {\n@@ -281,11 +281,14 @@ impl Clean<ExternalCrate> for CrateNum {\n                 let item = cx.tcx.hir().expect_item_by_hir_id(id.id);\n                 match item.node {\n                     hir::ItemKind::Mod(_) => {\n-                        as_primitive(Def::Mod(cx.tcx.hir().local_def_id_from_hir_id(id.id)))\n+                        as_primitive(Res::Def(\n+                            DefKind::Mod,\n+                            cx.tcx.hir().local_def_id_from_hir_id(id.id),\n+                        ))\n                     }\n                     hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n-                        as_primitive(path.def).map(|(_, prim, attrs)| {\n+                        as_primitive(path.res).map(|(_, prim, attrs)| {\n                             // Pretend the primitive is local.\n                             (cx.tcx.hir().local_def_id_from_hir_id(id.id), prim, attrs)\n                         })\n@@ -294,12 +297,12 @@ impl Clean<ExternalCrate> for CrateNum {\n                 }\n             }).collect()\n         } else {\n-            cx.tcx.item_children(root).iter().map(|item| item.def)\n+            cx.tcx.item_children(root).iter().map(|item| item.res)\n               .filter_map(as_primitive).collect()\n         };\n \n-        let as_keyword = |def: Def| {\n-            if let Def::Mod(def_id) = def {\n+        let as_keyword = |res: Res| {\n+            if let Res::Def(DefKind::Mod, def_id) = res {\n                 let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n                 let mut keyword = None;\n                 for attr in attrs.lists(\"doc\") {\n@@ -323,19 +326,22 @@ impl Clean<ExternalCrate> for CrateNum {\n                 let item = cx.tcx.hir().expect_item_by_hir_id(id.id);\n                 match item.node {\n                     hir::ItemKind::Mod(_) => {\n-                        as_keyword(Def::Mod(cx.tcx.hir().local_def_id_from_hir_id(id.id)))\n+                        as_keyword(Res::Def(\n+                            DefKind::Mod,\n+                            cx.tcx.hir().local_def_id_from_hir_id(id.id),\n+                        ))\n                     }\n                     hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n-                        as_keyword(path.def).map(|(_, prim, attrs)| {\n+                        as_keyword(path.res).map(|(_, prim, attrs)| {\n                             (cx.tcx.hir().local_def_id_from_hir_id(id.id), prim, attrs)\n                         })\n                     }\n                     _ => None\n                 }\n             }).collect()\n         } else {\n-            cx.tcx.item_children(root).iter().map(|item| item.def)\n+            cx.tcx.item_children(root).iter().map(|item| item.res)\n               .filter_map(as_keyword).collect()\n         };\n \n@@ -1157,7 +1163,7 @@ fn external_path(cx: &DocContext<'_>, name: &str, trait_did: Option<DefId>, has_\n                  bindings: Vec<TypeBinding>, substs: SubstsRef<'_>) -> Path {\n     Path {\n         global: false,\n-        def: Def::Err,\n+        res: Res::Err,\n         segments: vec![PathSegment {\n             name: name.to_string(),\n             args: external_generic_args(cx, trait_did, has_self, bindings, substs)\n@@ -2781,18 +2787,17 @@ impl Clean<Type> for hir::Ty {\n                 }\n             }\n             TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n-                if let Some(new_ty) = cx.ty_substs.borrow().get(&path.def).cloned() {\n-                    return new_ty;\n-                }\n-\n-                if let Def::TyParam(did) = path.def {\n+                if let Res::Def(DefKind::TyParam, did) = path.res {\n+                    if let Some(new_ty) = cx.ty_substs.borrow().get(&did).cloned() {\n+                        return new_ty;\n+                    }\n                     if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&did) {\n                         return ImplTrait(bounds);\n                     }\n                 }\n \n                 let mut alias = None;\n-                if let Def::TyAlias(def_id) = path.def {\n+                if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n                     // Substitute private type aliases\n                     if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n                         if !cx.renderinfo.borrow().access_levels.is_exported(def_id) {\n@@ -2805,7 +2810,7 @@ impl Clean<Type> for hir::Ty {\n                     let provided_params = &path.segments.last().expect(\"segments were empty\");\n                     let mut ty_substs = FxHashMap::default();\n                     let mut lt_substs = FxHashMap::default();\n-                    let mut const_substs = FxHashMap::default();\n+                    let mut ct_substs = FxHashMap::default();\n                     provided_params.with_generic_args(|generic_args| {\n                         let mut indices: GenericParamCount = Default::default();\n                         for param in generics.params.iter() {\n@@ -2834,9 +2839,8 @@ impl Clean<Type> for hir::Ty {\n                                     indices.lifetimes += 1;\n                                 }\n                                 hir::GenericParamKind::Type { ref default, .. } => {\n-                                    let ty_param_def =\n-                                        Def::TyParam(\n-                                            cx.tcx.hir().local_def_id_from_hir_id(param.hir_id));\n+                                    let ty_param_def_id =\n+                                        cx.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n                                     let mut j = 0;\n                                     let type_ = generic_args.args.iter().find_map(|arg| {\n                                         match arg {\n@@ -2851,17 +2855,16 @@ impl Clean<Type> for hir::Ty {\n                                         }\n                                     });\n                                     if let Some(ty) = type_.cloned() {\n-                                        ty_substs.insert(ty_param_def, ty.clean(cx));\n+                                        ty_substs.insert(ty_param_def_id, ty.clean(cx));\n                                     } else if let Some(default) = default.clone() {\n-                                        ty_substs.insert(ty_param_def,\n+                                        ty_substs.insert(ty_param_def_id,\n                                                          default.into_inner().clean(cx));\n                                     }\n                                     indices.types += 1;\n                                 }\n                                 hir::GenericParamKind::Const { .. } => {\n-                                    let const_param_def =\n-                                        Def::ConstParam(\n-                                            cx.tcx.hir().local_def_id_from_hir_id(param.hir_id));\n+                                    let const_param_def_id =\n+                                        cx.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n                                     let mut j = 0;\n                                     let const_ = generic_args.args.iter().find_map(|arg| {\n                                         match arg {\n@@ -2876,15 +2879,15 @@ impl Clean<Type> for hir::Ty {\n                                         }\n                                     });\n                                     if let Some(ct) = const_.cloned() {\n-                                        const_substs.insert(const_param_def, ct.clean(cx));\n+                                        ct_substs.insert(const_param_def_id, ct.clean(cx));\n                                     }\n                                     // FIXME(const_generics:defaults)\n                                     indices.consts += 1;\n                                 }\n                             }\n                         }\n                     });\n-                    return cx.enter_alias(ty_substs, lt_substs, const_substs, || ty.clean(cx));\n+                    return cx.enter_alias(ty_substs, lt_substs, ct_substs, || ty.clean(cx));\n                 }\n                 resolve_type(cx, path.clean(cx), self.hir_id)\n             }\n@@ -2893,7 +2896,10 @@ impl Clean<Type> for hir::Ty {\n                 segments.pop();\n                 let trait_path = hir::Path {\n                     span: p.span,\n-                    def: Def::Trait(cx.tcx.associated_item(p.def.def_id()).container.id()),\n+                    res: Res::Def(\n+                        DefKind::Trait,\n+                        cx.tcx.associated_item(p.res.def_id()).container.id(),\n+                    ),\n                     segments: segments.into(),\n                 };\n                 Type::QPath {\n@@ -2903,14 +2909,14 @@ impl Clean<Type> for hir::Ty {\n                 }\n             }\n             TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n-                let mut def = Def::Err;\n+                let mut res = Res::Err;\n                 let ty = hir_ty_to_ty(cx.tcx, self);\n                 if let ty::Projection(proj) = ty.sty {\n-                    def = Def::Trait(proj.trait_ref(cx.tcx).def_id);\n+                    res = Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id);\n                 }\n                 let trait_path = hir::Path {\n                     span: self.span,\n-                    def,\n+                    res,\n                     segments: vec![].into(),\n                 };\n                 Type::QPath {\n@@ -3196,7 +3202,7 @@ impl Clean<Option<Visibility>> for hir::Visibility {\n             hir::VisibilityKind::Crate(_) => Visibility::Crate,\n             hir::VisibilityKind::Restricted { ref path, .. } => {\n                 let path = path.clean(cx);\n-                let did = register_def(cx, path.def);\n+                let did = register_res(cx, path.res);\n                 Visibility::Restricted(did, path)\n             }\n         })\n@@ -3434,7 +3440,7 @@ impl Clean<Span> for syntax_pos::Span {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct Path {\n     pub global: bool,\n-    pub def: Def,\n+    pub res: Res,\n     pub segments: Vec<PathSegment>,\n }\n \n@@ -3448,7 +3454,7 @@ impl Clean<Path> for hir::Path {\n     fn clean(&self, cx: &DocContext<'_>) -> Path {\n         Path {\n             global: self.is_global(),\n-            def: self.def,\n+            res: self.res,\n             segments: if self.is_global() { &self.segments[1..] } else { &self.segments }.clean(cx),\n         }\n     }\n@@ -3564,7 +3570,7 @@ fn strip_path(path: &Path) -> Path {\n \n     Path {\n         global: path.global,\n-        def: path.def.clone(),\n+        res: path.res.clone(),\n         segments,\n     }\n }\n@@ -3898,12 +3904,15 @@ impl Clean<Vec<Item>> for doctree::ExternCrate {\n         if please_inline {\n             let mut visited = FxHashSet::default();\n \n-            let def = Def::Mod(DefId {\n-                krate: self.cnum,\n-                index: CRATE_DEF_INDEX,\n-            });\n+            let res = Res::Def(\n+                DefKind::Mod,\n+                DefId {\n+                    krate: self.cnum,\n+                    index: CRATE_DEF_INDEX,\n+                },\n+            );\n \n-            if let Some(items) = inline::try_inline(cx, def, self.name, &mut visited) {\n+            if let Some(items) = inline::try_inline(cx, res, self.name, &mut visited) {\n                 return items;\n             }\n         }\n@@ -3941,7 +3950,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n         let inner = if self.glob {\n             if !denied {\n                 let mut visited = FxHashSet::default();\n-                if let Some(items) = inline::try_inline_glob(cx, path.def, &mut visited) {\n+                if let Some(items) = inline::try_inline_glob(cx, path.res, &mut visited) {\n                     return items;\n                 }\n             }\n@@ -3950,18 +3959,20 @@ impl Clean<Vec<Item>> for doctree::Import {\n         } else {\n             let name = self.name;\n             if !please_inline {\n-                match path.def {\n-                    Def::Mod(did) => if !did.is_local() && did.index == CRATE_DEF_INDEX {\n-                        // if we're `pub use`ing an extern crate root, don't inline it unless we\n-                        // were specifically asked for it\n-                        denied = true;\n+                match path.res {\n+                    Res::Def(DefKind::Mod, did) => {\n+                        if !did.is_local() && did.index == CRATE_DEF_INDEX {\n+                            // if we're `pub use`ing an extern crate root, don't inline it unless we\n+                            // were specifically asked for it\n+                            denied = true;\n+                        }\n                     }\n                     _ => {}\n                 }\n             }\n             if !denied {\n                 let mut visited = FxHashSet::default();\n-                if let Some(items) = inline::try_inline(cx, path.def, name, &mut visited) {\n+                if let Some(items) = inline::try_inline(cx, path.res, name, &mut visited) {\n                     return items;\n                 }\n             }\n@@ -4145,54 +4156,56 @@ fn resolve_type(cx: &DocContext<'_>,\n         debug!(\"resolve_type({:?},{:?})\", path, id);\n     }\n \n-    let is_generic = match path.def {\n-        Def::PrimTy(p) => match p {\n+    let is_generic = match path.res {\n+        Res::PrimTy(p) => match p {\n             hir::Str => return Primitive(PrimitiveType::Str),\n             hir::Bool => return Primitive(PrimitiveType::Bool),\n             hir::Char => return Primitive(PrimitiveType::Char),\n             hir::Int(int_ty) => return Primitive(int_ty.into()),\n             hir::Uint(uint_ty) => return Primitive(uint_ty.into()),\n             hir::Float(float_ty) => return Primitive(float_ty.into()),\n         },\n-        Def::SelfTy(..) if path.segments.len() == 1 => {\n+        Res::SelfTy(..) if path.segments.len() == 1 => {\n             return Generic(keywords::SelfUpper.name().to_string());\n         }\n-        Def::TyParam(..) if path.segments.len() == 1 => {\n+        Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n             return Generic(format!(\"{:#}\", path));\n         }\n-        Def::SelfTy(..) | Def::TyParam(..) | Def::AssociatedTy(..) => true,\n+        Res::SelfTy(..)\n+        | Res::Def(DefKind::TyParam, _)\n+        | Res::Def(DefKind::AssociatedTy, _) => true,\n         _ => false,\n     };\n-    let did = register_def(&*cx, path.def);\n+    let did = register_res(&*cx, path.res);\n     ResolvedPath { path: path, param_names: None, did: did, is_generic: is_generic }\n }\n \n-pub fn register_def(cx: &DocContext<'_>, def: Def) -> DefId {\n-    debug!(\"register_def({:?})\", def);\n-\n-    let (did, kind) = match def {\n-        Def::Fn(i) => (i, TypeKind::Function),\n-        Def::TyAlias(i) => (i, TypeKind::Typedef),\n-        Def::Enum(i) => (i, TypeKind::Enum),\n-        Def::Trait(i) => (i, TypeKind::Trait),\n-        Def::Struct(i) => (i, TypeKind::Struct),\n-        Def::Union(i) => (i, TypeKind::Union),\n-        Def::Mod(i) => (i, TypeKind::Module),\n-        Def::ForeignTy(i) => (i, TypeKind::Foreign),\n-        Def::Const(i) => (i, TypeKind::Const),\n-        Def::Static(i) => (i, TypeKind::Static),\n-        Def::Variant(i) => (cx.tcx.parent(i).expect(\"cannot get parent def id\"),\n+pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n+    debug!(\"register_res({:?})\", res);\n+\n+    let (did, kind) = match res {\n+        Res::Def(DefKind::Fn, i) => (i, TypeKind::Function),\n+        Res::Def(DefKind::TyAlias, i) => (i, TypeKind::Typedef),\n+        Res::Def(DefKind::Enum, i) => (i, TypeKind::Enum),\n+        Res::Def(DefKind::Trait, i) => (i, TypeKind::Trait),\n+        Res::Def(DefKind::Struct, i) => (i, TypeKind::Struct),\n+        Res::Def(DefKind::Union, i) => (i, TypeKind::Union),\n+        Res::Def(DefKind::Mod, i) => (i, TypeKind::Module),\n+        Res::Def(DefKind::ForeignTy, i) => (i, TypeKind::Foreign),\n+        Res::Def(DefKind::Const, i) => (i, TypeKind::Const),\n+        Res::Def(DefKind::Static, i) => (i, TypeKind::Static),\n+        Res::Def(DefKind::Variant, i) => (cx.tcx.parent(i).expect(\"cannot get parent def id\"),\n                             TypeKind::Enum),\n-        Def::Macro(i, mac_kind) => match mac_kind {\n+        Res::Def(DefKind::Macro(mac_kind), i) => match mac_kind {\n             MacroKind::Bang => (i, TypeKind::Macro),\n             MacroKind::Attr => (i, TypeKind::Attr),\n             MacroKind::Derive => (i, TypeKind::Derive),\n             MacroKind::ProcMacroStub => unreachable!(),\n         },\n-        Def::TraitAlias(i) => (i, TypeKind::TraitAlias),\n-        Def::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n-        Def::SelfTy(_, Some(impl_def_id)) => return impl_def_id,\n-        _ => return def.def_id()\n+        Res::Def(DefKind::TraitAlias, i) => (i, TypeKind::TraitAlias),\n+        Res::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n+        Res::SelfTy(_, Some(impl_def_id)) => return impl_def_id,\n+        _ => return res.def_id()\n     };\n     if did.is_local() { return did }\n     inline::record_extern_fqn(cx, did, kind);\n@@ -4204,10 +4217,10 @@ pub fn register_def(cx: &DocContext<'_>, def: Def) -> DefId {\n \n fn resolve_use_source(cx: &DocContext<'_>, path: Path) -> ImportSource {\n     ImportSource {\n-        did: if path.def.opt_def_id().is_none() {\n+        did: if path.res.opt_def_id().is_none() {\n             None\n         } else {\n-            Some(register_def(cx, path.def))\n+            Some(register_res(cx, path.res))\n         },\n         path,\n     }\n@@ -4417,13 +4430,13 @@ pub fn path_to_def(tcx: TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n             for item in mem::replace(&mut items, Lrc::new(vec![])).iter() {\n                 if item.ident.name == *segment {\n                     if path_it.peek().is_none() {\n-                        return match item.def {\n-                            def::Def::Trait(did) => Some(did),\n+                        return match item.res {\n+                            def::Res::Def(DefKind::Trait, did) => Some(did),\n                             _ => None,\n                         }\n                     }\n \n-                    items = tcx.item_children(item.def.def_id());\n+                    items = tcx.item_children(item.res.def_id());\n                     break;\n                 }\n             }"}, {"sha": "5555ea302c96f1aa203c4710eaf5d6a39ad6ae3d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -1,7 +1,6 @@\n use rustc_lint;\n use rustc::session::{self, config};\n use rustc::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CrateNum, LOCAL_CRATE};\n-use rustc::hir::def::Def;\n use rustc::hir::HirId;\n use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n@@ -59,12 +58,12 @@ pub struct DocContext<'tcx> {\n     // The current set of type and lifetime substitutions,\n     // for expanding type aliases at the HIR level:\n \n-    /// Table type parameter definition -> substituted type\n-    pub ty_substs: RefCell<FxHashMap<Def, clean::Type>>,\n-    /// Table `NodeId` of lifetime parameter definition -> substituted lifetime\n+    /// Table `DefId` of type parameter -> substituted type\n+    pub ty_substs: RefCell<FxHashMap<DefId, clean::Type>>,\n+    /// Table `DefId` of lifetime parameter -> substituted lifetime\n     pub lt_substs: RefCell<FxHashMap<DefId, clean::Lifetime>>,\n-    /// Table node id of const parameter definition -> substituted const\n-    pub ct_substs: RefCell<FxHashMap<Def, clean::Constant>>,\n+    /// Table `DefId` of const parameter -> substituted const\n+    pub ct_substs: RefCell<FxHashMap<DefId, clean::Constant>>,\n     /// Table DefId of `impl Trait` in argument position -> bounds\n     pub impl_trait_bounds: RefCell<FxHashMap<DefId, Vec<clean::GenericBound>>>,\n     pub send_trait: Option<DefId>,\n@@ -91,9 +90,9 @@ impl<'tcx> DocContext<'tcx> {\n     /// Call the closure with the given parameters set as\n     /// the substitutions for a type alias' RHS.\n     pub fn enter_alias<F, R>(&self,\n-                             ty_substs: FxHashMap<Def, clean::Type>,\n+                             ty_substs: FxHashMap<DefId, clean::Type>,\n                              lt_substs: FxHashMap<DefId, clean::Lifetime>,\n-                             ct_substs: FxHashMap<Def, clean::Constant>,\n+                             ct_substs: FxHashMap<DefId, clean::Constant>,\n                              f: F) -> R\n     where F: FnOnce() -> R {\n         let (old_tys, old_lts, old_cts) = ("}, {"sha": "705b222efe80582628303e21356738134bc04fa8", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 80, "deletions": 77, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -1,5 +1,5 @@\n use errors::Applicability;\n-use rustc::hir::def::{Def, Namespace::{self, *}, PerNS};\n+use rustc::hir::def::{Res, DefKind, Namespace::{self, *}, PerNS};\n use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::lint as lint;\n@@ -56,7 +56,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                ns: Namespace,\n                current_item: &Option<String>,\n                parent_id: Option<hir::HirId>)\n-        -> Result<(Def, Option<String>), ()>\n+        -> Result<(Res, Option<String>), ()>\n     {\n         let cx = self.cx;\n \n@@ -74,12 +74,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             if let Ok(result) = result {\n                 // In case this is a trait item, skip the\n                 // early return and try looking for the trait.\n-                let value = match result.def {\n-                    Def::Method(_) | Def::AssociatedConst(_) => true,\n-                    Def::AssociatedTy(_) => false,\n-                    Def::Variant(_) => return handle_variant(cx, result.def),\n+                let value = match result.res {\n+                    Res::Def(DefKind::Method, _) | Res::Def(DefKind::AssociatedConst, _) => true,\n+                    Res::Def(DefKind::AssociatedTy, _) => false,\n+                    Res::Def(DefKind::Variant, _) => return handle_variant(cx, result.res),\n                     // Not a trait item; just return what we found.\n-                    _ => return Ok((result.def, None))\n+                    _ => return Ok((result.res, None))\n                 };\n \n                 if value != (ns == ValueNS) {\n@@ -132,8 +132,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             let ty = cx.enter_resolver(|resolver| resolver.with_scope(node_id, |resolver| {\n                     resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n             }))?;\n-            match ty.def {\n-                Def::Struct(did) | Def::Union(did) | Def::Enum(did) | Def::TyAlias(did) => {\n+            match ty.res {\n+                Res::Def(DefKind::Struct, did)\n+                | Res::Def(DefKind::Union, did)\n+                | Res::Def(DefKind::Enum, did)\n+                | Res::Def(DefKind::TyAlias, did) => {\n                     let item = cx.tcx.inherent_impls(did)\n                                      .iter()\n                                      .flat_map(|imp| cx.tcx.associated_items(*imp))\n@@ -144,7 +147,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             ty::AssociatedKind::Const if ns == ValueNS => \"associatedconstant\",\n                             _ => return Err(())\n                         };\n-                        Ok((ty.def, Some(format!(\"{}.{}\", out, item_name))))\n+                        Ok((ty.res, Some(format!(\"{}.{}\", out, item_name))))\n                     } else {\n                         match cx.tcx.type_of(did).sty {\n                             ty::Adt(def, _) => {\n@@ -156,7 +159,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                        .iter()\n                                        .find(|item| item.ident.name == item_name)\n                                 } {\n-                                    Ok((ty.def,\n+                                    Ok((ty.res,\n                                         Some(format!(\"{}.{}\",\n                                                      if def.is_enum() {\n                                                          \"variant\"\n@@ -172,7 +175,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         }\n                     }\n                 }\n-                Def::Trait(did) => {\n+                Res::Def(DefKind::Trait, did) => {\n                     let item = cx.tcx.associated_item_def_ids(did).iter()\n                                  .map(|item| cx.tcx.associated_item(*item))\n                                  .find(|item| item.ident.name == item_name);\n@@ -190,7 +193,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             _ => return Err(())\n                         };\n \n-                        Ok((ty.def, Some(format!(\"{}.{}\", kind, item_name))))\n+                        Ok((ty.res, Some(format!(\"{}.{}\", kind, item_name))))\n                     } else {\n                         Err(())\n                     }\n@@ -280,7 +283,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             }\n \n             let link = ori_link.replace(\"`\", \"\");\n-            let (def, fragment) = {\n+            let (res, fragment) = {\n                 let mut kind = None;\n                 let path_str = if let Some(prefix) =\n                     [\"struct@\", \"enum@\", \"type@\",\n@@ -315,8 +318,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n                 match kind {\n                     Some(ns @ ValueNS) => {\n-                        if let Ok(def) = self.resolve(path_str, ns, &current_item, parent_node) {\n-                            def\n+                        if let Ok(res) = self.resolve(path_str, ns, &current_item, parent_node) {\n+                            res\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n                             // This could just be a normal link or a broken link\n@@ -326,8 +329,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         }\n                     }\n                     Some(ns @ TypeNS) => {\n-                        if let Ok(def) = self.resolve(path_str, ns, &current_item, parent_node) {\n-                            def\n+                        if let Ok(res) = self.resolve(path_str, ns, &current_item, parent_node) {\n+                            res\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n                             // This could just be a normal link.\n@@ -337,18 +340,18 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     None => {\n                         // Try everything!\n                         let candidates = PerNS {\n-                            macro_ns: macro_resolve(cx, path_str).map(|def| (def, None)),\n+                            macro_ns: macro_resolve(cx, path_str).map(|res| (res, None)),\n                             type_ns: self\n                                 .resolve(path_str, TypeNS, &current_item, parent_node)\n                                 .ok(),\n                             value_ns: self\n                                 .resolve(path_str, ValueNS, &current_item, parent_node)\n                                 .ok()\n-                                .and_then(|(def, fragment)| {\n+                                .and_then(|(res, fragment)| {\n                                     // Constructors are picked up in the type namespace.\n-                                    match def {\n-                                        Def::Ctor(..) | Def::SelfCtor(..) => None,\n-                                        _ => Some((def, fragment))\n+                                    match res {\n+                                        Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => None,\n+                                        _ => Some((res, fragment))\n                                     }\n                                 }),\n                         };\n@@ -369,14 +372,14 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 path_str,\n                                 &dox,\n                                 link_range,\n-                                candidates.map(|candidate| candidate.map(|(def, _)| def)),\n+                                candidates.map(|candidate| candidate.map(|(res, _)| res)),\n                             );\n                             continue;\n                         }\n                     }\n                     Some(MacroNS) => {\n-                        if let Some(def) = macro_resolve(cx, path_str) {\n-                            (def, None)\n+                        if let Some(res) = macro_resolve(cx, path_str) {\n+                            (res, None)\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n                             continue\n@@ -385,10 +388,10 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 }\n             };\n \n-            if let Def::PrimTy(_) = def {\n+            if let Res::PrimTy(_) = res {\n                 item.attrs.links.push((ori_link, None, fragment));\n             } else {\n-                let id = register_def(cx, def);\n+                let id = register_res(cx, res);\n                 item.attrs.links.push((ori_link, Some(id), fragment));\n             }\n         }\n@@ -419,24 +422,24 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n }\n \n /// Resolves a string as a macro.\n-fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Def> {\n+fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n     use syntax::ext::base::{MacroKind, SyntaxExtension};\n     let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n     let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n     cx.enter_resolver(|resolver| {\n         let parent_scope = resolver.dummy_parent_scope();\n-        if let Ok(def) = resolver.resolve_macro_to_def_inner(&path, MacroKind::Bang,\n+        if let Ok(res) = resolver.resolve_macro_to_res_inner(&path, MacroKind::Bang,\n                                                             &parent_scope, false, false) {\n-            if let Def::Macro(_, MacroKind::ProcMacroStub) = def {\n+            if let Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) = res {\n                 // skip proc-macro stubs, they'll cause `get_macro` to crash\n             } else {\n-                if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n-                    return Some(def.map_id(|_| panic!(\"unexpected id\")));\n+                if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(res) {\n+                    return Some(res.map_id(|_| panic!(\"unexpected id\")));\n                 }\n             }\n         }\n-        if let Some(def) = resolver.all_macros.get(&Symbol::intern(path_str)) {\n-            return Some(def.map_id(|_| panic!(\"unexpected id\")));\n+        if let Some(res) = resolver.all_macros.get(&Symbol::intern(path_str)) {\n+            return Some(res.map_id(|_| panic!(\"unexpected id\")));\n         }\n         None\n     })\n@@ -496,14 +499,14 @@ fn ambiguity_error(\n     path_str: &str,\n     dox: &str,\n     link_range: Option<Range<usize>>,\n-    candidates: PerNS<Option<Def>>,\n+    candidates: PerNS<Option<Res>>,\n ) {\n     let sp = span_of_attrs(attrs);\n \n     let mut msg = format!(\"`{}` is \", path_str);\n \n     let candidates = [TypeNS, ValueNS, MacroNS].iter().filter_map(|&ns| {\n-        candidates[ns].map(|def| (def, ns))\n+        candidates[ns].map(|res| (res, ns))\n     }).collect::<Vec<_>>();\n     match candidates.as_slice() {\n         [(first_def, _), (second_def, _)] => {\n@@ -517,11 +520,11 @@ fn ambiguity_error(\n         }\n         _ => {\n             let mut candidates = candidates.iter().peekable();\n-            while let Some((def, _)) = candidates.next() {\n+            while let Some((res, _)) = candidates.next() {\n                 if candidates.peek().is_some() {\n-                    msg += &format!(\"{} {}, \", def.article(), def.kind_name());\n+                    msg += &format!(\"{} {}, \", res.article(), res.kind_name());\n                 } else {\n-                    msg += &format!(\"and {} {}\", def.article(), def.kind_name());\n+                    msg += &format!(\"and {} {}\", res.article(), res.kind_name());\n                 }\n             }\n         }\n@@ -539,23 +542,23 @@ fn ambiguity_error(\n             diag.set_span(sp);\n             diag.span_label(sp, \"ambiguous link\");\n \n-            for (def, ns) in candidates {\n-                let (action, mut suggestion) = match def {\n-                    Def::Method(..) | Def::Fn(..) => {\n+            for (res, ns) in candidates {\n+                let (action, mut suggestion) = match res {\n+                    Res::Def(DefKind::Method, _) | Res::Def(DefKind::Fn, _) => {\n                         (\"add parentheses\", format!(\"{}()\", path_str))\n                     }\n-                    Def::Macro(..) => {\n+                    Res::Def(DefKind::Macro(..), _) => {\n                         (\"add an exclamation mark\", format!(\"{}!\", path_str))\n                     }\n                     _ => {\n-                        let type_ = match (def, ns) {\n-                            (Def::Const(..), _) => \"const\",\n-                            (Def::Static(..), _) => \"static\",\n-                            (Def::Struct(..), _) => \"struct\",\n-                            (Def::Enum(..), _) => \"enum\",\n-                            (Def::Union(..), _) => \"union\",\n-                            (Def::Trait(..), _) => \"trait\",\n-                            (Def::Mod(..), _) => \"module\",\n+                        let type_ = match (res, ns) {\n+                            (Res::Def(DefKind::Const, _), _) => \"const\",\n+                            (Res::Def(DefKind::Static, _), _) => \"static\",\n+                            (Res::Def(DefKind::Struct, _), _) => \"struct\",\n+                            (Res::Def(DefKind::Enum, _), _) => \"enum\",\n+                            (Res::Def(DefKind::Union, _), _) => \"union\",\n+                            (Res::Def(DefKind::Trait, _), _) => \"trait\",\n+                            (Res::Def(DefKind::Mod, _), _) => \"module\",\n                             (_, TypeNS) => \"type\",\n                             (_, ValueNS) => \"value\",\n                             (_, MacroNS) => \"macro\",\n@@ -572,7 +575,7 @@ fn ambiguity_error(\n \n                 diag.span_suggestion(\n                     sp,\n-                    &format!(\"to link to the {}, {}\", def.kind_name(), action),\n+                    &format!(\"to link to the {}, {}\", res.kind_name(), action),\n                     suggestion,\n                     Applicability::MaybeIncorrect,\n                 );\n@@ -600,41 +603,41 @@ fn ambiguity_error(\n     diag.emit();\n }\n \n-/// Given an enum variant's def, return the def of its enum and the associated fragment.\n-fn handle_variant(cx: &DocContext<'_>, def: Def) -> Result<(Def, Option<String>), ()> {\n+/// Given an enum variant's res, return the res of its enum and the associated fragment.\n+fn handle_variant(cx: &DocContext<'_>, res: Res) -> Result<(Res, Option<String>), ()> {\n     use rustc::ty::DefIdTree;\n \n-    let parent = if let Some(parent) = cx.tcx.parent(def.def_id()) {\n+    let parent = if let Some(parent) = cx.tcx.parent(res.def_id()) {\n         parent\n     } else {\n         return Err(())\n     };\n-    let parent_def = Def::Enum(parent);\n-    let variant = cx.tcx.expect_variant_def(def);\n+    let parent_def = Res::Def(DefKind::Enum, parent);\n+    let variant = cx.tcx.expect_variant_res(res);\n     Ok((parent_def, Some(format!(\"{}.v\", variant.ident.name))))\n }\n \n-const PRIMITIVES: &[(&str, Def)] = &[\n-    (\"u8\",    Def::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U8))),\n-    (\"u16\",   Def::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U16))),\n-    (\"u32\",   Def::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U32))),\n-    (\"u64\",   Def::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U64))),\n-    (\"u128\",  Def::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U128))),\n-    (\"usize\", Def::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::Usize))),\n-    (\"i8\",    Def::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I8))),\n-    (\"i16\",   Def::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I16))),\n-    (\"i32\",   Def::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I32))),\n-    (\"i64\",   Def::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I64))),\n-    (\"i128\",  Def::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I128))),\n-    (\"isize\", Def::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::Isize))),\n-    (\"f32\",   Def::PrimTy(hir::PrimTy::Float(syntax::ast::FloatTy::F32))),\n-    (\"f64\",   Def::PrimTy(hir::PrimTy::Float(syntax::ast::FloatTy::F64))),\n-    (\"str\",   Def::PrimTy(hir::PrimTy::Str)),\n-    (\"bool\",  Def::PrimTy(hir::PrimTy::Bool)),\n-    (\"char\",  Def::PrimTy(hir::PrimTy::Char)),\n+const PRIMITIVES: &[(&str, Res)] = &[\n+    (\"u8\",    Res::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U8))),\n+    (\"u16\",   Res::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U16))),\n+    (\"u32\",   Res::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U32))),\n+    (\"u64\",   Res::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U64))),\n+    (\"u128\",  Res::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U128))),\n+    (\"usize\", Res::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::Usize))),\n+    (\"i8\",    Res::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I8))),\n+    (\"i16\",   Res::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I16))),\n+    (\"i32\",   Res::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I32))),\n+    (\"i64\",   Res::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I64))),\n+    (\"i128\",  Res::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I128))),\n+    (\"isize\", Res::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::Isize))),\n+    (\"f32\",   Res::PrimTy(hir::PrimTy::Float(syntax::ast::FloatTy::F32))),\n+    (\"f64\",   Res::PrimTy(hir::PrimTy::Float(syntax::ast::FloatTy::F64))),\n+    (\"str\",   Res::PrimTy(hir::PrimTy::Str)),\n+    (\"bool\",  Res::PrimTy(hir::PrimTy::Bool)),\n+    (\"char\",  Res::PrimTy(hir::PrimTy::Char)),\n ];\n \n-fn is_primitive(path_str: &str, ns: Namespace) -> Option<Def> {\n+fn is_primitive(path_str: &str, ns: Namespace) -> Option<Res> {\n     if ns == TypeNS {\n         PRIMITIVES.iter().find(|x| x.0 == path_str).map(|x| x.1)\n     } else {"}, {"sha": "94d2d7ffdb8c2bb14b4f7c93566ecfc88f583feb", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -2,7 +2,7 @@\n //! usable for `clean`.\n \n use rustc::hir::{self, Node};\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevel;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n@@ -265,7 +265,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     /// Returns `true` if the target has been inlined.\n     fn maybe_inline_local(&mut self,\n                           id: hir::HirId,\n-                          def: Def,\n+                          res: Res,\n                           renamed: Option<ast::Ident>,\n                           glob: bool,\n                           om: &mut Module,\n@@ -284,10 +284,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             false\n         }\n \n-        debug!(\"maybe_inline_local def: {:?}\", def);\n+        debug!(\"maybe_inline_local res: {:?}\", res);\n \n         let tcx = self.cx.tcx;\n-        let def_did = if let Some(did) = def.opt_def_id() {\n+        let res_did = if let Some(did) = res.opt_def_id() {\n             did\n         } else {\n             return false;\n@@ -302,22 +302,22 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // reachable in documentation -- a previously nonreachable item can be\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront).\n-        if !def_did.is_local() && !is_no_inline {\n-            let attrs = clean::inline::load_attrs(self.cx, def_did);\n+        if !res_did.is_local() && !is_no_inline {\n+            let attrs = clean::inline::load_attrs(self.cx, res_did);\n             let self_is_hidden = attrs.lists(\"doc\").has_word(\"hidden\");\n-            match def {\n-                Def::Trait(did) |\n-                Def::Struct(did) |\n-                Def::Union(did) |\n-                Def::Enum(did) |\n-                Def::ForeignTy(did) |\n-                Def::TyAlias(did) if !self_is_hidden => {\n+            match res {\n+                Res::Def(DefKind::Trait, did) |\n+                Res::Def(DefKind::Struct, did) |\n+                Res::Def(DefKind::Union, did) |\n+                Res::Def(DefKind::Enum, did) |\n+                Res::Def(DefKind::ForeignTy, did) |\n+                Res::Def(DefKind::TyAlias, did) if !self_is_hidden => {\n                     self.cx.renderinfo\n                         .borrow_mut()\n                         .access_levels.map\n                         .insert(did, AccessLevel::Public);\n                 },\n-                Def::Mod(did) => if !self_is_hidden {\n+                Res::Def(DefKind::Mod, did) => if !self_is_hidden {\n                     crate::visit_lib::LibEmbargoVisitor::new(self.cx).visit_mod(did);\n                 },\n                 _ => {},\n@@ -326,21 +326,21 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false\n         }\n \n-        let def_hir_id = match tcx.hir().as_local_hir_id(def_did) {\n+        let res_hir_id = match tcx.hir().as_local_hir_id(res_did) {\n             Some(n) => n, None => return false\n         };\n \n-        let is_private = !self.cx.renderinfo.borrow().access_levels.is_public(def_did);\n-        let is_hidden = inherits_doc_hidden(self.cx, def_hir_id);\n+        let is_private = !self.cx.renderinfo.borrow().access_levels.is_public(res_did);\n+        let is_hidden = inherits_doc_hidden(self.cx, res_hir_id);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n         if (!please_inline && !is_private && !is_hidden) || is_no_inline {\n             return false\n         }\n \n-        if !self.view_item_stack.insert(def_hir_id) { return false }\n+        if !self.view_item_stack.insert(res_hir_id) { return false }\n \n-        let ret = match tcx.hir().get_by_hir_id(def_hir_id) {\n+        let ret = match tcx.hir().get_by_hir_id(res_hir_id) {\n             Node::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n@@ -373,7 +373,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             }\n             _ => false,\n         };\n-        self.view_item_stack.remove(&def_hir_id);\n+        self.view_item_stack.remove(&res_hir_id);\n         ret\n     }\n \n@@ -420,9 +420,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n                 // Struct and variant constructors and proc macro stubs always show up alongside\n                 // their definitions, we've already processed them so just discard these.\n-                match path.def {\n-                    Def::Ctor(..) | Def::SelfCtor(..) | Def::Macro(_, MacroKind::ProcMacroStub) =>\n-                        return,\n+                match path.res {\n+                    Res::Def(DefKind::Ctor(..), _)\n+                    | Res::SelfCtor(..)\n+                    | Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) => return,\n                     _ => {}\n                 }\n \n@@ -439,7 +440,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     });\n                     let ident = if is_glob { None } else { Some(ident) };\n                     if self.maybe_inline_local(item.hir_id,\n-                                               path.def,\n+                                               path.res,\n                                                ident,\n                                                is_glob,\n                                                om,"}, {"sha": "326c9a10f7df839ec2ed2cc4d28ebbdf264333a2", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -1,5 +1,5 @@\n use rustc::middle::privacy::{AccessLevels, AccessLevel};\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty::Visibility;\n use rustc::util::nodemap::FxHashSet;\n@@ -60,17 +60,17 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n         }\n \n         for item in self.cx.tcx.item_children(def_id).iter() {\n-            if let Some(def_id) = item.def.opt_def_id() {\n+            if let Some(def_id) = item.res.opt_def_id() {\n                 if self.cx.tcx.def_key(def_id).parent.map_or(false, |d| d == def_id.index) ||\n                     item.vis == Visibility::Public {\n-                    self.visit_item(item.def);\n+                    self.visit_item(item.res);\n                 }\n             }\n         }\n     }\n \n-    fn visit_item(&mut self, def: Def) {\n-        let def_id = def.def_id();\n+    fn visit_item(&mut self, res: Res) {\n+        let def_id = res.def_id();\n         let vis = self.cx.tcx.visibility(def_id);\n         let inherited_item_level = if vis == Visibility::Public {\n             self.prev_level\n@@ -80,7 +80,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n \n         let item_level = self.update(def_id, inherited_item_level);\n \n-        if let Def::Mod(..) = def {\n+        if let Res::Def(DefKind::Mod, _) = res {\n             let orig_level = self.prev_level;\n \n             self.prev_level = item_level;"}, {"sha": "1031d507101de2d734637cf4e97cc4f0f8fd9609", "filename": "src/test/ui/imports/issue-53269.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Ftest%2Fui%2Fimports%2Fissue-53269.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Ftest%2Fui%2Fimports%2Fissue-53269.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53269.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -1,4 +1,4 @@\n-// Ambiguity between a `macro_rules` macro and a non-existent import recovered as `Def::Err`\n+// Ambiguity between a `macro_rules` macro and a non-existent import recovered as `Res::Err`\n \n macro_rules! mac { () => () }\n "}, {"sha": "615b36a0b21ec0b96d6f5beea43630b1ca1bb2a7", "filename": "src/test/ui/imports/issue-53512.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Ftest%2Fui%2Fimports%2Fissue-53512.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fde05b12c28e1ed66bd13fdf1ea392f166b811/src%2Ftest%2Fui%2Fimports%2Fissue-53512.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53512.rs?ref=13fde05b12c28e1ed66bd13fdf1ea392f166b811", "patch": "@@ -1,4 +1,4 @@\n-// Macro from prelude is shadowed by non-existent import recovered as `Def::Err`.\n+// Macro from prelude is shadowed by non-existent import recovered as `Res::Err`.\n \n use std::assert; //~ ERROR unresolved import `std::assert`\n "}]}