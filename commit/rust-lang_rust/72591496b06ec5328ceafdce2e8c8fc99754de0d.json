{"sha": "72591496b06ec5328ceafdce2e8c8fc99754de0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNTkxNDk2YjA2ZWM1MzI4Y2VhZmRjZTJlOGM4ZmM5OTc1NGRlMGQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-13T19:55:23Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-13T20:08:05Z"}, "message": "Remove some needlessly repetetive casts in metadata code", "tree": {"sha": "c0a8004cb2fd26d43d1643d20d34d72216eda398", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0a8004cb2fd26d43d1643d20d34d72216eda398"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72591496b06ec5328ceafdce2e8c8fc99754de0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72591496b06ec5328ceafdce2e8c8fc99754de0d", "html_url": "https://github.com/rust-lang/rust/commit/72591496b06ec5328ceafdce2e8c8fc99754de0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72591496b06ec5328ceafdce2e8c8fc99754de0d/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c9d95a9a0f82895559dc1dae6300ee14c304d7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c9d95a9a0f82895559dc1dae6300ee14c304d7e", "html_url": "https://github.com/rust-lang/rust/commit/6c9d95a9a0f82895559dc1dae6300ee14c304d7e"}], "stats": {"total": 187, "additions": 93, "deletions": 94}, "files": [{"sha": "2a089ad14ad06ce5fd43db06610187b1005ba309", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/72591496b06ec5328ceafdce2e8c8fc99754de0d/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72591496b06ec5328ceafdce2e8c8fc99754de0d/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=72591496b06ec5328ceafdce2e8c8fc99754de0d", "patch": "@@ -79,9 +79,9 @@ fn lookup_item(item_id: int, data: @[u8]) -> ebml::doc {\n     ret find_item(item_id, items);\n }\n \n-fn item_family(item: ebml::doc) -> u8 {\n+fn item_family(item: ebml::doc) -> char {\n     let fam = ebml::get_doc(item, tag_items_data_item_family);\n-    ret ebml::doc_as_u8(fam);\n+    ebml::doc_as_u8(fam) as char\n }\n \n fn item_symbol(item: ebml::doc) -> str {\n@@ -218,24 +218,22 @@ fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n     let fam_ch = item_family(item);\n     let did = {crate: cnum, node: did_.node};\n     // We treat references to enums as references to types.\n-    let def =\n-        alt fam_ch as char {\n-          'c' { ast::def_const(did) }\n-          'u' { ast::def_fn(did, ast::unsafe_fn) }\n-          'f' { ast::def_fn(did, ast::impure_fn) }\n-          'p' { ast::def_fn(did, ast::pure_fn) }\n-          'y' { ast::def_ty(did) }\n-          't' { ast::def_ty(did) }\n-          'm' { ast::def_mod(did) }\n-          'n' { ast::def_native_mod(did) }\n-          'v' {\n-            let tid = variant_enum_id(item);\n-            tid = {crate: cnum, node: tid.node};\n-            ast::def_variant(tid, did)\n-          }\n-          'I' { ast::def_ty(did) }\n-        };\n-    ret def;\n+    alt fam_ch {\n+      'c' { ast::def_const(did) }\n+      'u' { ast::def_fn(did, ast::unsafe_fn) }\n+      'f' { ast::def_fn(did, ast::impure_fn) }\n+      'p' { ast::def_fn(did, ast::pure_fn) }\n+      'y' { ast::def_ty(did) }\n+      't' { ast::def_ty(did) }\n+      'm' { ast::def_mod(did) }\n+      'n' { ast::def_native_mod(did) }\n+      'v' {\n+        let tid = variant_enum_id(item);\n+        tid = {crate: cnum, node: tid.node};\n+        ast::def_variant(tid, did)\n+      }\n+      'I' { ast::def_ty(did) }\n+    }\n }\n \n fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n@@ -338,7 +336,7 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n           _ { tcx.sess.bug(\"get_iface_methods: id has non-function type\");\n         } };\n         result += [{ident: name, tps: bounds, fty: fty,\n-                    purity: alt item_family(mth) as char {\n+                    purity: alt item_family(mth) {\n                       'u' { ast::unsafe_fn }\n                       'f' { ast::impure_fn }\n                       'p' { ast::pure_fn }\n@@ -347,15 +345,15 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     @result\n }\n \n-fn family_has_type_params(fam_ch: u8) -> bool {\n-    alt fam_ch as char {\n+fn family_has_type_params(fam_ch: char) -> bool {\n+    alt fam_ch {\n       'c' | 'T' | 'm' | 'n' { false }\n       'f' | 'u' | 'p' | 'F' | 'U' | 'P' | 'y' | 't' | 'v' | 'i' | 'I' { true }\n     }\n }\n \n-fn family_names_type(fam_ch: u8) -> bool {\n-    alt fam_ch as char { 'y' | 't' | 'I' { true } _ { false } }\n+fn family_names_type(fam_ch: char) -> bool {\n+    alt fam_ch { 'y' | 't' | 'I' { true } _ { false } }\n }\n \n fn read_path(d: ebml::doc) -> {path: str, pos: uint} {\n@@ -371,8 +369,8 @@ fn describe_def(items: ebml::doc, id: ast::def_id) -> str {\n     ret item_family_to_str(item_family(find_item(id.node, items)));\n }\n \n-fn item_family_to_str(fam: u8) -> str {\n-    alt fam as char {\n+fn item_family_to_str(fam: char) -> str {\n+    alt fam {\n       'c' { ret \"const\"; }\n       'f' { ret \"fn\"; }\n       'u' { ret \"unsafe fn\"; }"}, {"sha": "650d1fcf9751d1032068ee53e83a3306ff11522b", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/72591496b06ec5328ceafdce2e8c8fc99754de0d/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72591496b06ec5328ceafdce2e8c8fc99754de0d/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=72591496b06ec5328ceafdce2e8c8fc99754de0d", "patch": "@@ -168,9 +168,9 @@ fn encode_reexport_paths(ebml_w: ebml::writer,\n \n \n // Item info table encoding\n-fn encode_family(ebml_w: ebml::writer, c: u8) {\n+fn encode_family(ebml_w: ebml::writer, c: char) {\n     ebml::start_tag(ebml_w, tag_items_data_item_family);\n-    ebml_w.writer.write([c]);\n+    ebml_w.writer.write([c as u8]);\n     ebml::end_tag(ebml_w);\n }\n \n@@ -244,7 +244,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         index += [{val: variant.node.id, pos: ebml_w.writer.tell()}];\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n-        encode_family(ebml_w, 'v' as u8);\n+        encode_family(ebml_w, 'v');\n         encode_name(ebml_w, variant.node.name);\n         encode_enum_id(ebml_w, local_def(id));\n         encode_type(ecx, ebml_w,\n@@ -292,7 +292,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n                        id: node_id, path: ast_map::path, name: ident) {\n     ebml::start_tag(ebml_w, tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n-    encode_family(ebml_w, 'm' as u8);\n+    encode_family(ebml_w, 'm');\n     encode_name(ebml_w, name);\n     alt ecx.ccx.impl_map.get(id) {\n       list::cons(impls, @list::nil) {\n@@ -322,7 +322,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n       item_const(_, _) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'c' as u8);\n+        encode_family(ebml_w, 'c');\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n@@ -331,7 +331,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n       item_fn(decl, tps, _) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, purity_fn_family(decl.purity) as u8);\n+        encode_family(ebml_w, purity_fn_family(decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n@@ -344,15 +344,15 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n       item_native_mod(_) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'n' as u8);\n+        encode_family(ebml_w, 'n');\n         encode_name(ebml_w, item.ident);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml::end_tag(ebml_w);\n       }\n       item_ty(_, tps) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'y' as u8);\n+        encode_family(ebml_w, 'y');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n@@ -362,7 +362,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n       item_enum(variants, tps) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 't' as u8);\n+        encode_family(ebml_w, 't');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n@@ -382,7 +382,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n-        encode_family(ebml_w, 'y' as u8);\n+        encode_family(ebml_w, 'y');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, ty::ty_fn_ret(fn_ty));\n         encode_name(ebml_w, item.ident);\n@@ -393,7 +393,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         index += [{val: ctor_id, pos: ebml_w.writer.tell()}];\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n-        encode_family(ebml_w, 'f' as u8);\n+        encode_family(ebml_w, 'f');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, fn_ty);\n         encode_symbol(ecx, ebml_w, ctor_id);\n@@ -403,7 +403,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n       item_impl(tps, ifce, _, methods) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'i' as u8);\n+        encode_family(ebml_w, 'i');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n@@ -430,7 +430,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             index += [{val: m.id, pos: ebml_w.writer.tell()}];\n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(m.id));\n-            encode_family(ebml_w, purity_fn_family(m.decl.purity) as u8);\n+            encode_family(ebml_w, purity_fn_family(m.decl.purity));\n             encode_type_param_bounds(ebml_w, ecx, tps + m.tps);\n             encode_type(ecx, ebml_w, node_id_to_type(tcx, m.id));\n             encode_name(ebml_w, m.ident);\n@@ -442,7 +442,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n       item_iface(tps, ms) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'I' as u8);\n+        encode_family(ebml_w, 'I');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n@@ -452,7 +452,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             encode_name(ebml_w, mty.ident);\n             encode_type_param_bounds(ebml_w, ecx, ms[i].tps);\n             encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));\n-            encode_family(ebml_w, purity_fn_family(mty.purity) as u8);\n+            encode_family(ebml_w, purity_fn_family(mty.purity));\n             ebml::end_tag(ebml_w);\n             i += 1u;\n         }\n@@ -467,13 +467,8 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     ebml::start_tag(ebml_w, tag_items_data_item);\n     alt nitem.node {\n       native_item_fn(fn_decl, tps) {\n-        let letter = alt fn_decl.purity {\n-          unsafe_fn { 'u' }\n-          pure_fn { 'p' }   // this is currently impossible, but hey.\n-          impure_fn { 'f' }\n-        } as u8;\n         encode_def_id(ebml_w, local_def(nitem.id));\n-        encode_family(ebml_w, letter);\n+        encode_family(ebml_w, purity_fn_family(fn_decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.ccx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);"}, {"sha": "be7afbe0437fda03ea765417a094988006f6ff94", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 52, "deletions": 46, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/72591496b06ec5328ceafdce2e8c8fc99754de0d/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72591496b06ec5328ceafdce2e8c8fc99754de0d/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=72591496b06ec5328ceafdce2e8c8fc99754de0d", "patch": "@@ -18,16 +18,22 @@ type conv_did = fn(ast::def_id) -> ast::def_id;\n \n type pstate = {data: @[u8], crate: int, mutable pos: uint, tcx: ty::ctxt};\n \n-fn peek(st: @pstate) -> u8 {\n-    st.data[st.pos]\n+fn peek(st: @pstate) -> char {\n+    st.data[st.pos] as char\n }\n \n-fn next(st: @pstate) -> u8 {\n-    let ch = st.data[st.pos];\n+fn next(st: @pstate) -> char {\n+    let ch = st.data[st.pos] as char;\n     st.pos = st.pos + 1u;\n     ret ch;\n }\n \n+fn next_byte(st: @pstate) -> u8 {\n+    let b = st.data[st.pos];\n+    st.pos = st.pos + 1u;\n+    ret b;\n+}\n+\n fn parse_ident(st: @pstate, last: char) -> ast::ident {\n     fn is_last(b: char, c: char) -> bool { ret c == b; }\n     ret parse_ident_(st, bind is_last(last, _));\n@@ -36,8 +42,8 @@ fn parse_ident(st: @pstate, last: char) -> ast::ident {\n fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n    ast::ident {\n     let rslt = \"\";\n-    while !is_last(peek(st) as char) {\n-        rslt += str::from_byte(next(st));\n+    while !is_last(peek(st)) {\n+        rslt += str::from_byte(next_byte(st));\n     }\n     ret rslt;\n }\n@@ -50,20 +56,20 @@ fn parse_ty_data(data: @[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n }\n \n fn parse_ret_ty(st: @pstate, conv: conv_did) -> (ast::ret_style, ty::t) {\n-    alt peek(st) as char {\n+    alt peek(st) {\n       '!' { next(st); (ast::noreturn, ty::mk_bot(st.tcx)) }\n       _ { (ast::return_val, parse_ty(st, conv)) }\n     }\n }\n \n fn parse_constrs(st: @pstate, conv: conv_did) -> [@ty::constr] {\n     let rslt: [@ty::constr] = [];\n-    alt peek(st) as char {\n+    alt peek(st) {\n       ':' {\n         do  {\n             next(st);\n             rslt += [parse_constr(st, conv, parse_constr_arg)];\n-        } while peek(st) as char == ';'\n+        } while peek(st) == ';'\n       }\n       _ { }\n     }\n@@ -73,12 +79,12 @@ fn parse_constrs(st: @pstate, conv: conv_did) -> [@ty::constr] {\n // FIXME less copy-and-paste\n fn parse_ty_constrs(st: @pstate, conv: conv_did) -> [@ty::type_constr] {\n     let rslt: [@ty::type_constr] = [];\n-    alt peek(st) as char {\n+    alt peek(st) {\n       ':' {\n         do  {\n             next(st);\n             rslt += [parse_constr(st, conv, parse_ty_constr_arg)];\n-        } while peek(st) as char == ';'\n+        } while peek(st) == ';'\n       }\n       _ { }\n     }\n@@ -90,7 +96,7 @@ fn parse_path(st: @pstate) -> @ast::path {\n     fn is_last(c: char) -> bool { ret c == '(' || c == ':'; }\n     idents += [parse_ident_(st, is_last)];\n     while true {\n-        alt peek(st) as char {\n+        alt peek(st) {\n           ':' { next(st); next(st); }\n           c {\n             if c == '(' {\n@@ -104,7 +110,7 @@ fn parse_path(st: @pstate) -> @ast::path {\n }\n \n fn parse_constr_arg(st: @pstate) -> ast::fn_constr_arg {\n-    alt peek(st) as char {\n+    alt peek(st) {\n       '*' { st.pos += 1u; ret ast::carg_base; }\n       c {\n \n@@ -129,7 +135,7 @@ fn parse_constr_arg(st: @pstate) -> ast::fn_constr_arg {\n }\n \n fn parse_ty_constr_arg(st: @pstate) -> ast::constr_arg_general_<@path> {\n-    alt peek(st) as char {\n+    alt peek(st) {\n       '*' { st.pos += 1u; ret ast::carg_base; }\n       c { ret ast::carg_ident(parse_path(st)); }\n     }\n@@ -141,15 +147,15 @@ fn parse_constr<T: copy>(st: @pstate, conv: conv_did,\n     let sp = ast_util::dummy_sp(); // FIXME: use a real span\n     let args: [@sp_constr_arg<T>] = [];\n     let pth = parse_path(st);\n-    let ignore: char = next(st) as char;\n+    let ignore: char = next(st);\n     assert (ignore == '(');\n     let def = parse_def(st, conv);\n     let an_arg: constr_arg_general_<T>;\n     do  {\n         an_arg = pser(st);\n         // FIXME use a real span\n         args += [@respan(sp, an_arg)];\n-        ignore = next(st) as char;\n+        ignore = next(st);\n     } while ignore == ';'\n     assert (ignore == ')');\n     ret @respan(sp, {path: pth, args: args, id: def});\n@@ -171,15 +177,15 @@ fn parse_proto(c: char) -> ast::proto {\n }\n \n fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n-    alt next(st) as char {\n+    alt next(st) {\n       'n' { ret ty::mk_nil(st.tcx); }\n       'z' { ret ty::mk_bot(st.tcx); }\n       'b' { ret ty::mk_bool(st.tcx); }\n       'i' { ret ty::mk_int(st.tcx); }\n       'u' { ret ty::mk_uint(st.tcx); }\n       'l' { ret ty::mk_float(st.tcx); }\n       'M' {\n-        alt next(st) as char {\n+        alt next(st) {\n           'b' { ret ty::mk_mach_uint(st.tcx, ast::ty_u8); }\n           'w' { ret ty::mk_mach_uint(st.tcx, ast::ty_u16); }\n           'l' { ret ty::mk_mach_uint(st.tcx, ast::ty_u32); }\n@@ -195,18 +201,18 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       'c' { ret ty::mk_char(st.tcx); }\n       'S' { ret ty::mk_str(st.tcx); }\n       't' {\n-        assert (next(st) as char == '[');\n+        assert (next(st) == '[');\n         let def = parse_def(st, conv);\n         let params: [ty::t] = [];\n-        while peek(st) as char != ']' { params += [parse_ty(st, conv)]; }\n+        while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_enum(st.tcx, def, params);\n       }\n       'x' {\n-        assert (next(st) as char == '[');\n+        assert (next(st) == '[');\n         let def = parse_def(st, conv);\n         let params: [ty::t] = [];\n-        while peek(st) as char != ']' { params += [parse_ty(st, conv)]; }\n+        while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_iface(st.tcx, def, params);\n       }\n@@ -215,9 +221,9 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         ret ty::mk_param(st.tcx, parse_int(st) as uint, did);\n       }\n       's' {\n-        assert next(st) as char == '[';\n+        assert next(st) == '[';\n         let params = [];\n-        while peek(st) as char != ']' { params += [parse_ty(st, conv)]; }\n+        while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n         st.pos += 1u;\n         ret ty::mk_self(st.tcx, params);\n       }\n@@ -226,12 +232,12 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       '*' { ret ty::mk_ptr(st.tcx, parse_mt(st, conv)); }\n       'I' { ret ty::mk_vec(st.tcx, parse_mt(st, conv)); }\n       'R' {\n-        assert (next(st) as char == '[');\n+        assert (next(st) == '[');\n         let fields: [ty::field] = [];\n-        while peek(st) as char != ']' {\n+        while peek(st) != ']' {\n             let name = \"\";\n-            while peek(st) as char != '=' {\n-                name += str::from_byte(next(st));\n+            while peek(st) != '=' {\n+                name += str::from_byte(next_byte(st));\n             }\n             st.pos = st.pos + 1u;\n             fields += [{ident: name, mt: parse_mt(st, conv)}];\n@@ -240,30 +246,30 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         ret ty::mk_rec(st.tcx, fields);\n       }\n       'T' {\n-        assert (next(st) as char == '[');\n+        assert (next(st) == '[');\n         let params = [];\n-        while peek(st) as char != ']' { params += [parse_ty(st, conv)]; }\n+        while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_tup(st.tcx, params);\n       }\n       'f' {\n-        let proto = parse_proto(next(st) as char);\n+        let proto = parse_proto(next(st));\n         parse_ty_rust_fn(st, conv, proto)\n       }\n       'r' {\n-        assert (next(st) as char == '[');\n+        assert (next(st) == '[');\n         let def = parse_def(st, conv);\n         let inner = parse_ty(st, conv);\n         let params: [ty::t] = [];\n-        while peek(st) as char != ']' { params += [parse_ty(st, conv)]; }\n+        while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_res(st.tcx, def, inner, params);\n       }\n       'X' { ret ty::mk_var(st.tcx, parse_int(st)); }\n       'Y' { ret ty::mk_type(st.tcx); }\n       'y' { ret ty::mk_send_type(st.tcx); }\n       'C' {\n-        let ck = alt next(st) as char {\n+        let ck = alt next(st) {\n           '&' { ty::ck_block }\n           '@' { ty::ck_box }\n           '~' { ty::ck_uniq }\n@@ -272,9 +278,9 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       }\n       '#' {\n         let pos = parse_hex(st);\n-        assert (next(st) as char == ':');\n+        assert (next(st) == ':');\n         let len = parse_hex(st);\n-        assert (next(st) as char == '#');\n+        assert (next(st) == '#');\n         alt st.tcx.rcache.find({cnum: st.crate, pos: pos, len: len}) {\n           some(tt) { ret tt; }\n           none {\n@@ -286,10 +292,10 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         }\n       }\n       'A' {\n-        assert (next(st) as char == '[');\n+        assert (next(st) == '[');\n         let tt = parse_ty(st, conv);\n         let tcs = parse_ty_constrs(st, conv);\n-        assert (next(st) as char == ']');\n+        assert (next(st) == ']');\n         ret ty::mk_constr(st.tcx, tt, tcs);\n       }\n       '\"' {\n@@ -304,7 +310,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n \n fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n     let m;\n-    alt peek(st) as char {\n+    alt peek(st) {\n       'm' { next(st); m = ast::mut; }\n       '?' { next(st); m = ast::maybe_mut; }\n       _ { m = ast::imm; }\n@@ -314,15 +320,15 @@ fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n \n fn parse_def(st: @pstate, conv: conv_did) -> ast::def_id {\n     let def = [];\n-    while peek(st) as char != '|' { def += [next(st)]; }\n+    while peek(st) != '|' { def += [next_byte(st)]; }\n     st.pos = st.pos + 1u;\n     ret conv(parse_def_id(def));\n }\n \n fn parse_int(st: @pstate) -> int {\n     let n = 0;\n     while true {\n-        let cur = peek(st) as char;\n+        let cur = peek(st);\n         if cur < '0' || cur > '9' { break; }\n         st.pos = st.pos + 1u;\n         n *= 10;\n@@ -334,7 +340,7 @@ fn parse_int(st: @pstate) -> int {\n fn parse_hex(st: @pstate) -> uint {\n     let n = 0u;\n     while true {\n-        let cur = peek(st) as char;\n+        let cur = peek(st);\n         if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { break; }\n         st.pos = st.pos + 1u;\n         n *= 16u;\n@@ -346,10 +352,10 @@ fn parse_hex(st: @pstate) -> uint {\n }\n \n fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n-    assert (next(st) as char == '[');\n+    assert (next(st) == '[');\n     let inputs: [ty::arg] = [];\n-    while peek(st) as char != ']' {\n-        let mode = alt peek(st) as char {\n+    while peek(st) != ']' {\n+        let mode = alt peek(st) {\n           '&' { ast::by_mut_ref }\n           '-' { ast::by_move }\n           '+' { ast::by_copy }\n@@ -399,7 +405,7 @@ fn parse_bounds_data(data: @[u8], start: uint,\n fn parse_bounds(st: @pstate, conv: conv_did) -> @[ty::param_bound] {\n     let bounds = [];\n     while true {\n-        bounds += [alt next(st) as char {\n+        bounds += [alt next(st) {\n           'S' { ty::bound_send }\n           'C' { ty::bound_copy }\n           'I' { ty::bound_iface(parse_ty(st, conv)) }"}]}