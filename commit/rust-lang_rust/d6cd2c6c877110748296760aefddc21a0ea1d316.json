{"sha": "d6cd2c6c877110748296760aefddc21a0ea1d316", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2Y2QyYzZjODc3MTEwNzQ4Mjk2NzYwYWVmZGRjMjFhMGVhMWQzMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-18T14:37:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-18T14:37:39Z"}, "message": "Auto merge of #82183 - michaelwoerister:lazier-defpathhash-loading2, r=wesleywiser\n\nSimplify lazy DefPathHash decoding by using an on-disk hash table.\n\nThis PR simplifies the logic around mapping `DefPathHash` values encountered during incremental compilation to valid `DefId`s in the current session. It is able to do so by using an on-disk hash table encoding that allows for looking up values directly, i.e. without deserializing the entire table.\n\nThe main simplification comes from not having to keep track of `DefPathHashes` being used during the compilation session.", "tree": {"sha": "a9d40afc34fef4aef248f8bc3a04a92b4765cc50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9d40afc34fef4aef248f8bc3a04a92b4765cc50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6cd2c6c877110748296760aefddc21a0ea1d316", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6cd2c6c877110748296760aefddc21a0ea1d316", "html_url": "https://github.com/rust-lang/rust/commit/d6cd2c6c877110748296760aefddc21a0ea1d316", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6cd2c6c877110748296760aefddc21a0ea1d316/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23afad6e7f0ff17320411a274f3a3beb92452235", "url": "https://api.github.com/repos/rust-lang/rust/commits/23afad6e7f0ff17320411a274f3a3beb92452235", "html_url": "https://github.com/rust-lang/rust/commit/23afad6e7f0ff17320411a274f3a3beb92452235"}, {"sha": "4d151d92deaf86280b4c96cdc7c6f1a58927bd00", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d151d92deaf86280b4c96cdc7c6f1a58927bd00", "html_url": "https://github.com/rust-lang/rust/commit/4d151d92deaf86280b4c96cdc7c6f1a58927bd00"}], "stats": {"total": 629, "additions": 279, "deletions": 350}, "files": [{"sha": "35eac402190d9c811278dae7efbce2e264f1ce63", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -2321,6 +2321,15 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"odht\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0b18a8d1c919d3e7b5c49708d08ef7d60bc2150a7c3a8244257c54ca3f625010\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+]\n+\n [[package]]\n name = \"once_cell\"\n version = \"1.7.2\"\n@@ -3859,6 +3868,7 @@ version = \"0.0.0\"\n name = \"rustc_hir\"\n version = \"0.0.0\"\n dependencies = [\n+ \"odht\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_feature\",\n@@ -4045,6 +4055,7 @@ name = \"rustc_metadata\"\n version = \"0.0.0\"\n dependencies = [\n  \"libc\",\n+ \"odht\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\","}, {"sha": "ff6758e66dff22075dfd8937b469350a688c7dd6", "filename": "compiler/rustc_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2FCargo.toml?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -17,3 +17,4 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_ast = { path = \"../rustc_ast\" }\n tracing = \"0.1\"\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n+odht = { version = \"0.2.1\", features = [\"nightly\"] }"}, {"sha": "8bfb47af26f1ae09c386522e424dfbc3b0aead07", "filename": "compiler/rustc_hir/src/def_path_hash_map.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_hir%2Fsrc%2Fdef_path_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_hir%2Fsrc%2Fdef_path_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef_path_hash_map.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -0,0 +1,37 @@\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_span::def_id::{DefIndex, DefPathHash};\n+\n+#[derive(Clone, Default)]\n+pub struct Config;\n+\n+impl odht::Config for Config {\n+    type Key = DefPathHash;\n+    type Value = DefIndex;\n+\n+    type EncodedKey = [u8; 16];\n+    type EncodedValue = [u8; 4];\n+\n+    type H = odht::UnHashFn;\n+\n+    #[inline]\n+    fn encode_key(k: &DefPathHash) -> [u8; 16] {\n+        k.0.to_le_bytes()\n+    }\n+\n+    #[inline]\n+    fn encode_value(v: &DefIndex) -> [u8; 4] {\n+        v.as_u32().to_le_bytes()\n+    }\n+\n+    #[inline]\n+    fn decode_key(k: &[u8; 16]) -> DefPathHash {\n+        DefPathHash(Fingerprint::from_le_bytes(*k))\n+    }\n+\n+    #[inline]\n+    fn decode_value(v: &[u8; 4]) -> DefIndex {\n+        DefIndex::from_u32(u32::from_le_bytes(*v))\n+    }\n+}\n+\n+pub type DefPathHashMap = odht::HashTableOwned<Config>;"}, {"sha": "ca29351455e628654ae48fed1851e475f321b6cd", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -6,11 +6,11 @@\n \n pub use crate::def_id::DefPathHash;\n use crate::def_id::{CrateNum, DefIndex, LocalDefId, StableCrateId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::def_path_hash_map::DefPathHashMap;\n use crate::hir;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n-use rustc_data_structures::unhash::UnhashMap;\n use rustc_index::vec::IndexVec;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -28,7 +28,7 @@ use tracing::debug;\n pub struct DefPathTable {\n     index_to_key: IndexVec<DefIndex, DefKey>,\n     def_path_hashes: IndexVec<DefIndex, DefPathHash>,\n-    def_path_hash_to_index: UnhashMap<DefPathHash, DefIndex>,\n+    def_path_hash_to_index: DefPathHashMap,\n }\n \n impl DefPathTable {\n@@ -44,7 +44,7 @@ impl DefPathTable {\n \n         // Check for hash collisions of DefPathHashes. These should be\n         // exceedingly rare.\n-        if let Some(existing) = self.def_path_hash_to_index.insert(def_path_hash, index) {\n+        if let Some(existing) = self.def_path_hash_to_index.insert(&def_path_hash, &index) {\n             let def_path1 = DefPath::make(LOCAL_CRATE, existing, |idx| self.def_key(idx));\n             let def_path2 = DefPath::make(LOCAL_CRATE, index, |idx| self.def_key(idx));\n \n@@ -87,7 +87,7 @@ impl DefPathTable {\n \n     pub fn enumerated_keys_and_path_hashes(\n         &self,\n-    ) -> impl Iterator<Item = (DefIndex, &DefKey, &DefPathHash)> + '_ {\n+    ) -> impl Iterator<Item = (DefIndex, &DefKey, &DefPathHash)> + ExactSizeIterator + '_ {\n         self.index_to_key\n             .iter_enumerated()\n             .map(move |(index, key)| (index, key, &self.def_path_hashes[index]))\n@@ -110,6 +110,9 @@ pub struct Definitions {\n     expansions_that_defined: FxHashMap<LocalDefId, ExpnId>,\n \n     def_id_to_span: IndexVec<LocalDefId, Span>,\n+\n+    /// The [StableCrateId] of the local crate.\n+    stable_crate_id: StableCrateId,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -356,6 +359,7 @@ impl Definitions {\n             hir_id_to_def_id: Default::default(),\n             expansions_that_defined: Default::default(),\n             def_id_to_span,\n+            stable_crate_id,\n         }\n     }\n \n@@ -439,11 +443,17 @@ impl Definitions {\n     }\n \n     #[inline(always)]\n-    pub fn local_def_path_hash_to_def_id(&self, hash: DefPathHash) -> Option<LocalDefId> {\n+    pub fn local_def_path_hash_to_def_id(&self, hash: DefPathHash) -> LocalDefId {\n+        debug_assert!(hash.stable_crate_id() == self.stable_crate_id);\n         self.table\n             .def_path_hash_to_index\n             .get(&hash)\n-            .map(|&local_def_index| LocalDefId { local_def_index })\n+            .map(|local_def_index| LocalDefId { local_def_index })\n+            .unwrap()\n+    }\n+\n+    pub fn def_path_hash_to_def_index_map(&self) -> &DefPathHashMap {\n+        &self.table.def_path_hash_to_index\n     }\n }\n "}, {"sha": "ce36648d6df118b4e6238e328592b0352f13fc12", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -16,6 +16,7 @@ extern crate rustc_data_structures;\n \n mod arena;\n pub mod def;\n+pub mod def_path_hash_map;\n pub mod definitions;\n pub use rustc_span::def_id;\n mod hir;"}, {"sha": "42596f3318d6c0236c2f9d135bd40c24f08bde35", "filename": "compiler/rustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2FCargo.toml?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -8,6 +8,7 @@ doctest = false\n \n [dependencies]\n libc = \"0.2\"\n+odht = { version = \"0.2.1\", features = [\"nightly\"] }\n snap = \"1\"\n tracing = \"0.1\"\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "48d8cdf57dcfcd348421a3c0f7f1a145b55ea984", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -45,7 +45,7 @@ pub struct CStore {\n \n     /// This map is used to verify we get no hash conflicts between\n     /// `StableCrateId` values.\n-    stable_crate_ids: FxHashMap<StableCrateId, CrateNum>,\n+    pub(crate) stable_crate_ids: FxHashMap<StableCrateId, CrateNum>,\n \n     /// Unused externs of the crate\n     unused_externs: Vec<Symbol>,"}, {"sha": "eb3a9f576a735429415e0d1e6198b296a33cf342", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 79, "deletions": 77, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -48,7 +48,26 @@ use rustc_span::hygiene::HygieneDecodeContext;\n \n mod cstore_impl;\n \n-crate struct MetadataBlob(MetadataRef);\n+/// A reference to the raw binary version of crate metadata.\n+/// A `MetadataBlob` internally is just a reference counted pointer to\n+/// the actual data, so cloning it is cheap.\n+#[derive(Clone)]\n+crate struct MetadataBlob(Lrc<MetadataRef>);\n+\n+// This is needed so we can create an OwningRef into the blob.\n+// The data behind a `MetadataBlob` has a stable address because it is\n+// contained within an Rc/Arc.\n+unsafe impl rustc_data_structures::owning_ref::StableAddress for MetadataBlob {}\n+\n+// This is needed so we can create an OwningRef into the blob.\n+impl std::ops::Deref for MetadataBlob {\n+    type Target = [u8];\n+\n+    #[inline]\n+    fn deref(&self) -> &[u8] {\n+        &self.0[..]\n+    }\n+}\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n@@ -76,10 +95,8 @@ crate struct CrateMetadata {\n     raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate.\n     source_map_import_info: OnceCell<Vec<ImportedSourceFile>>,\n-    /// For every definition in this crate, maps its `DefPathHash` to its\n-    /// `DefIndex`. See `raw_def_id_to_def_id` for more details about how\n-    /// this is used.\n-    def_path_hash_map: OnceCell<UnhashMap<DefPathHash, DefIndex>>,\n+    /// For every definition in this crate, maps its `DefPathHash` to its `DefIndex`.\n+    def_path_hash_map: DefPathHashMapRef<'static>,\n     /// Likewise for ExpnHash.\n     expn_hash_map: OnceCell<UnhashMap<ExpnHash, ExpnIndex>>,\n     /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n@@ -134,6 +151,7 @@ struct ImportedSourceFile {\n pub(super) struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n     cdata: Option<CrateMetadataRef<'a>>,\n+    blob: &'a MetadataBlob,\n     sess: Option<&'tcx Session>,\n     tcx: Option<TyCtxt<'tcx>>,\n \n@@ -148,7 +166,8 @@ pub(super) struct DecodeContext<'a, 'tcx> {\n \n /// Abstract over the various ways one can create metadata decoders.\n pub(super) trait Metadata<'a, 'tcx>: Copy {\n-    fn raw_bytes(self) -> &'a [u8];\n+    fn blob(self) -> &'a MetadataBlob;\n+\n     fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n         None\n     }\n@@ -162,8 +181,9 @@ pub(super) trait Metadata<'a, 'tcx>: Copy {\n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n         let tcx = self.tcx();\n         DecodeContext {\n-            opaque: opaque::Decoder::new(self.raw_bytes(), pos),\n+            opaque: opaque::Decoder::new(self.blob(), pos),\n             cdata: self.cdata(),\n+            blob: self.blob(),\n             sess: self.sess().or(tcx.map(|tcx| tcx.sess)),\n             tcx,\n             last_source_file_index: 0,\n@@ -176,51 +196,61 @@ pub(super) trait Metadata<'a, 'tcx>: Copy {\n }\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {\n-    fn raw_bytes(self) -> &'a [u8] {\n-        &self.0\n+    #[inline]\n+    fn blob(self) -> &'a MetadataBlob {\n+        self\n     }\n }\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a MetadataBlob, &'tcx Session) {\n-    fn raw_bytes(self) -> &'a [u8] {\n-        let (blob, _) = self;\n-        &blob.0\n+    #[inline]\n+    fn blob(self) -> &'a MetadataBlob {\n+        self.0\n     }\n \n+    #[inline]\n     fn sess(self) -> Option<&'tcx Session> {\n         let (_, sess) = self;\n         Some(sess)\n     }\n }\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadataRef<'a> {\n-    fn raw_bytes(self) -> &'a [u8] {\n-        self.blob.raw_bytes()\n+    #[inline]\n+    fn blob(self) -> &'a MetadataBlob {\n+        &self.blob\n     }\n+    #[inline]\n     fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n         Some(*self)\n     }\n }\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, &'tcx Session) {\n-    fn raw_bytes(self) -> &'a [u8] {\n-        self.0.raw_bytes()\n+    #[inline]\n+    fn blob(self) -> &'a MetadataBlob {\n+        &self.0.blob\n     }\n+    #[inline]\n     fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n         Some(*self.0)\n     }\n+    #[inline]\n     fn sess(self) -> Option<&'tcx Session> {\n         Some(&self.1)\n     }\n }\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, TyCtxt<'tcx>) {\n-    fn raw_bytes(self) -> &'a [u8] {\n-        self.0.raw_bytes()\n+    #[inline]\n+    fn blob(self) -> &'a MetadataBlob {\n+        &self.0.blob\n     }\n+    #[inline]\n     fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n         Some(*self.0)\n     }\n+    #[inline]\n     fn tcx(self) -> Option<TyCtxt<'tcx>> {\n         Some(self.1)\n     }\n@@ -246,12 +276,21 @@ impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable<DecodeContext<'a, 'tcx>>> Lazy<[T]> {\n }\n \n impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n+    #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n+        debug_assert!(self.tcx.is_some(), \"missing TyCtxt in DecodeContext\");\n+        self.tcx.unwrap()\n+    }\n+\n+    #[inline]\n+    pub fn blob(&self) -> &'a MetadataBlob {\n+        self.blob\n     }\n \n-    fn cdata(&self) -> CrateMetadataRef<'a> {\n-        self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n+    #[inline]\n+    pub fn cdata(&self) -> CrateMetadataRef<'a> {\n+        debug_assert!(self.cdata.is_some(), \"missing CrateMetadata in DecodeContext\");\n+        self.cdata.unwrap()\n     }\n \n     fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {\n@@ -276,6 +315,11 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         self.lazy_state = LazyState::Previous(NonZeroUsize::new(position + min_size).unwrap());\n         Ok(Lazy::from_position_and_meta(NonZeroUsize::new(position).unwrap(), meta))\n     }\n+\n+    #[inline]\n+    pub fn read_raw_bytes(&mut self, len: usize) -> &'a [u8] {\n+        self.opaque.read_raw_bytes(len)\n+    }\n }\n \n impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n@@ -586,11 +630,11 @@ implement_ty_decoder!(DecodeContext<'a, 'tcx>);\n \n impl MetadataBlob {\n     crate fn new(metadata_ref: MetadataRef) -> MetadataBlob {\n-        MetadataBlob(metadata_ref)\n+        MetadataBlob(Lrc::new(metadata_ref))\n     }\n \n     crate fn is_compatible(&self) -> bool {\n-        self.raw_bytes().starts_with(METADATA_HEADER)\n+        self.blob().starts_with(METADATA_HEADER)\n     }\n \n     crate fn get_rustc_version(&self) -> String {\n@@ -599,7 +643,7 @@ impl MetadataBlob {\n     }\n \n     crate fn get_root(&self) -> CrateRoot<'tcx> {\n-        let slice = self.raw_bytes();\n+        let slice = &self.blob()[..];\n         let offset = METADATA_HEADER.len();\n         let pos = (((slice[offset + 0] as u32) << 24)\n             | ((slice[offset + 1] as u32) << 16)\n@@ -1552,58 +1596,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .or_insert_with(|| self.root.tables.def_keys.get(self, index).unwrap().decode(self))\n     }\n \n-    /// Finds the corresponding `DefId` for the provided `DefPathHash`, if it exists.\n-    /// This is used by incremental compilation to map a serialized `DefPathHash` to\n-    /// its `DefId` in the current session.\n-    /// Normally, only one 'main' crate will change between incremental compilation sessions:\n-    /// all dependencies will be completely unchanged. In this case, we can avoid\n-    /// decoding every `DefPathHash` in the crate, since the `DefIndex` from the previous\n-    /// session will still be valid. If our 'guess' is wrong (the `DefIndex` no longer exists,\n-    /// or has a different `DefPathHash`, then we need to decode all `DefPathHashes` to determine\n-    /// the correct mapping).\n-    fn def_path_hash_to_def_id(\n-        &self,\n-        krate: CrateNum,\n-        index_guess: u32,\n-        hash: DefPathHash,\n-    ) -> Option<DefId> {\n-        let def_index_guess = DefIndex::from_u32(index_guess);\n-        let old_hash = self\n-            .root\n-            .tables\n-            .def_path_hashes\n-            .get(self, def_index_guess)\n-            .map(|lazy| lazy.decode(self));\n-\n-        // Fast path: the definition and its index is unchanged from the\n-        // previous compilation session. There is no need to decode anything\n-        // else\n-        if old_hash == Some(hash) {\n-            return Some(DefId { krate, index: def_index_guess });\n-        }\n-\n-        let is_proc_macro = self.is_proc_macro_crate();\n-\n-        // Slow path: We need to find out the new `DefIndex` of the provided\n-        // `DefPathHash`, if its still exists. This requires decoding every `DefPathHash`\n-        // stored in this crate.\n-        let map = self.cdata.def_path_hash_map.get_or_init(|| {\n-            let end_id = self.root.tables.def_path_hashes.size() as u32;\n-            let mut map = UnhashMap::with_capacity_and_hasher(end_id as usize, Default::default());\n-            for i in 0..end_id {\n-                let def_index = DefIndex::from_u32(i);\n-                // There may be gaps in the encoded table if we're decoding a proc-macro crate\n-                if let Some(hash) = self.root.tables.def_path_hashes.get(self, def_index) {\n-                    map.insert(hash.decode(self), def_index);\n-                } else if !is_proc_macro {\n-                    panic!(\"Missing def_path_hashes entry for {:?}\", def_index);\n-                }\n-            }\n-            map\n-        });\n-        map.get(&hash).map(|index| DefId { krate, index: *index })\n-    }\n-\n     // Returns the path leading to the thing with this `id`.\n     fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n@@ -1626,6 +1618,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.def_path_hash_unlocked(index, &mut def_path_hashes)\n     }\n \n+    #[inline]\n+    fn def_path_hash_to_def_index(&self, hash: DefPathHash) -> DefIndex {\n+        self.def_path_hash_map.def_path_hash_to_def_index(&hash)\n+    }\n+\n     fn expn_hash_to_expn_id(&self, index_guess: u32, hash: ExpnHash) -> ExpnId {\n         debug_assert_eq!(ExpnId::from_hash(hash), None);\n         let index_guess = ExpnIndex::from_u32(index_guess);\n@@ -1892,13 +1889,18 @@ impl CrateMetadata {\n         let alloc_decoding_state =\n             AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n         let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n+\n+        // Pre-decode the DefPathHash->DefIndex table. This is a cheap operation\n+        // that does not copy any data. It just does some data verification.\n+        let def_path_hash_map = root.def_path_hash_map.decode(&blob);\n+\n         CrateMetadata {\n             blob,\n             root,\n             trait_impls,\n             raw_proc_macros,\n             source_map_import_info: OnceCell::new(),\n-            def_path_hash_map: Default::default(),\n+            def_path_hash_map,\n             expn_hash_map: Default::default(),\n             alloc_decoding_state,\n             cnum,"}, {"sha": "70952d388d52d9fba6aed7960422085428600f43", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -498,6 +498,10 @@ impl CrateStore for CStore {\n         self.get_crate_data(cnum).root.stable_crate_id\n     }\n \n+    fn stable_crate_id_to_crate_num(&self, stable_crate_id: StableCrateId) -> CrateNum {\n+        self.stable_crate_ids[&stable_crate_id]\n+    }\n+\n     /// Returns the `DefKey` for a given `DefId`. This indicates the\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to.\n@@ -513,14 +517,9 @@ impl CrateStore for CStore {\n         self.get_crate_data(def.krate).def_path_hash(def.index)\n     }\n \n-    // See `CrateMetadataRef::def_path_hash_to_def_id` for more details\n-    fn def_path_hash_to_def_id(\n-        &self,\n-        cnum: CrateNum,\n-        index_guess: u32,\n-        hash: DefPathHash,\n-    ) -> Option<DefId> {\n-        self.get_crate_data(cnum).def_path_hash_to_def_id(cnum, index_guess, hash)\n+    fn def_path_hash_to_def_id(&self, cnum: CrateNum, hash: DefPathHash) -> DefId {\n+        let def_index = self.get_crate_data(cnum).def_path_hash_to_def_index(hash);\n+        DefId { krate: cnum, index: def_index }\n     }\n \n     fn expn_hash_to_expn_id(&self, cnum: CrateNum, index_guess: u32, hash: ExpnHash) -> ExpnId {"}, {"sha": "d6435bb649d6dcbe8eefed4343bed02b53b5b17f", "filename": "compiler/rustc_metadata/src/rmeta/def_path_hash_map.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -0,0 +1,58 @@\n+use crate::rmeta::DecodeContext;\n+use crate::rmeta::EncodeContext;\n+use crate::rmeta::MetadataBlob;\n+use rustc_data_structures::owning_ref::OwningRef;\n+use rustc_hir::def_path_hash_map::{Config as HashMapConfig, DefPathHashMap};\n+use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n+use rustc_span::def_id::{DefIndex, DefPathHash};\n+\n+crate enum DefPathHashMapRef<'tcx> {\n+    OwnedFromMetadata(odht::HashTable<HashMapConfig, OwningRef<MetadataBlob, [u8]>>),\n+    BorrowedFromTcx(&'tcx DefPathHashMap),\n+}\n+\n+impl DefPathHashMapRef<'tcx> {\n+    #[inline]\n+    pub fn def_path_hash_to_def_index(&self, def_path_hash: &DefPathHash) -> DefIndex {\n+        match *self {\n+            DefPathHashMapRef::OwnedFromMetadata(ref map) => map.get(def_path_hash).unwrap(),\n+            DefPathHashMapRef::BorrowedFromTcx(_) => {\n+                panic!(\"DefPathHashMap::BorrowedFromTcx variant only exists for serialization\")\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for DefPathHashMapRef<'tcx> {\n+    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        match *self {\n+            DefPathHashMapRef::BorrowedFromTcx(def_path_hash_map) => {\n+                let bytes = def_path_hash_map.raw_bytes();\n+                e.emit_usize(bytes.len())?;\n+                e.emit_raw_bytes(bytes)\n+            }\n+            DefPathHashMapRef::OwnedFromMetadata(_) => {\n+                panic!(\"DefPathHashMap::OwnedFromMetadata variant only exists for deserialization\")\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefPathHashMapRef<'static> {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<DefPathHashMapRef<'static>, String> {\n+        // Import TyDecoder so we can access the DecodeContext::position() method\n+        use crate::rustc_middle::ty::codec::TyDecoder;\n+\n+        let len = d.read_usize()?;\n+        let pos = d.position();\n+        let o = OwningRef::new(d.blob().clone()).map(|x| &x[pos..pos + len]);\n+\n+        // Although we already have the data we need via the OwningRef, we still need\n+        // to advance the DecodeContext's position so it's in a valid state after\n+        // the method. We use read_raw_bytes() for that.\n+        let _ = d.read_raw_bytes(len);\n+\n+        let inner = odht::HashTable::from_raw_bytes(o).map_err(|e| format!(\"{}\", e))?;\n+        Ok(DefPathHashMapRef::OwnedFromMetadata(inner))\n+    }\n+}"}, {"sha": "a50c4549d3d3fbe8a1334e73c3801d79ca08ee34", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -1,3 +1,4 @@\n+use crate::rmeta::def_path_hash_map::DefPathHashMapRef;\n use crate::rmeta::table::{FixedSizeEncoding, TableBuilder};\n use crate::rmeta::*;\n \n@@ -472,6 +473,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n+    fn encode_def_path_hash_map(&mut self) -> Lazy<DefPathHashMapRef<'tcx>> {\n+        self.lazy(DefPathHashMapRef::BorrowedFromTcx(\n+            self.tcx.resolutions(()).definitions.def_path_hash_to_def_index_map(),\n+        ))\n+    }\n+\n     fn encode_source_map(&mut self) -> Lazy<[rustc_span::SourceFile]> {\n         let source_map = self.tcx.sess.source_map();\n         let all_source_files = source_map.files();\n@@ -675,6 +682,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let (syntax_contexts, expn_data, expn_hashes) = self.encode_hygiene();\n         let hygiene_bytes = self.position() - i;\n \n+        i = self.position();\n+        let def_path_hash_map = self.encode_def_path_hash_map();\n+        let def_path_hash_map_bytes = self.position() - i;\n+\n         // Encode source_map. This needs to be done last,\n         // since encoding `Span`s tells us which `SourceFiles` we actually\n         // need to encode.\n@@ -722,6 +733,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             syntax_contexts,\n             expn_data,\n             expn_hashes,\n+            def_path_hash_map,\n         });\n \n         let total_bytes = self.position();\n@@ -744,6 +756,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             eprintln!(\"            impl bytes: {}\", impl_bytes);\n             eprintln!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n             eprintln!(\"  def-path table bytes: {}\", def_path_table_bytes);\n+            eprintln!(\" def-path hashes bytes: {}\", def_path_hash_map_bytes);\n             eprintln!(\" proc-macro-data-bytes: {}\", proc_macro_data_bytes);\n             eprintln!(\"             mir bytes: {}\", mir_bytes);\n             eprintln!(\"            item bytes: {}\", item_bytes);"}, {"sha": "eb2bd80f46e64686715184798f10db490e3935e0", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -1,4 +1,5 @@\n use decoder::Metadata;\n+use def_path_hash_map::DefPathHashMapRef;\n use table::{Table, TableBuilder};\n \n use rustc_ast::{self as ast, MacroDef};\n@@ -35,6 +36,7 @@ use encoder::EncodeContext;\n use rustc_span::hygiene::SyntaxContextData;\n \n mod decoder;\n+mod def_path_hash_map;\n mod encoder;\n mod table;\n \n@@ -231,6 +233,8 @@ crate struct CrateRoot<'tcx> {\n     expn_data: ExpnDataTable,\n     expn_hashes: ExpnHashTable,\n \n+    def_path_hash_map: Lazy<DefPathHashMapRef<'tcx>>,\n+\n     source_map: Lazy<[rustc_span::SourceFile]>,\n \n     compiler_builtins: bool,"}, {"sha": "4dfefda490b3deeea6878c4f97787aecd747da5c", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -199,7 +199,7 @@ where\n         debug!(\"Table::lookup: index={:?} len={:?}\", i, self.meta);\n \n         let start = self.position.get();\n-        let bytes = &metadata.raw_bytes()[start..start + self.meta];\n+        let bytes = &metadata.blob()[start..start + self.meta];\n         <Option<T>>::maybe_read_from_bytes_at(bytes, i.index())?\n     }\n "}, {"sha": "e788dd4be85d715a55bb5c4da496117123861fe6", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -336,7 +336,11 @@ impl DepNodeExt for DepNode {\n     /// has been removed.\n     fn extract_def_id(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n         if self.kind.can_reconstruct_query_key() {\n-            tcx.on_disk_cache.as_ref()?.def_path_hash_to_def_id(tcx, DefPathHash(self.hash.into()))\n+            Some(\n+                tcx.on_disk_cache\n+                    .as_ref()?\n+                    .def_path_hash_to_def_id(tcx, DefPathHash(self.hash.into())),\n+            )\n         } else {\n             None\n         }\n@@ -385,17 +389,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n     }\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n-        let hash = tcx.def_path_hash(*self);\n-        // If this is a foreign `DefId`, store its current value\n-        // in the incremental cache. When we decode the cache,\n-        // we will use the old DefIndex as an initial guess for\n-        // a lookup into the crate metadata.\n-        if !self.is_local() {\n-            if let Some(cache) = &tcx.on_disk_cache {\n-                cache.store_foreign_def_id_hash(*self, hash);\n-            }\n-        }\n-        hash.0\n+        tcx.def_path_hash(*self).0\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {"}, {"sha": "35dc1631db3c2757094b2e952d7e9a32cb8dabf0", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -92,12 +92,7 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     type DepKind = DepKind;\n     type StableHashingContext = StableHashingContext<'tcx>;\n \n-    fn register_reused_dep_node(&self, dep_node: &DepNode) {\n-        if let Some(cache) = self.on_disk_cache.as_ref() {\n-            cache.register_reused_dep_node(*self, dep_node)\n-        }\n-    }\n-\n+    #[inline]\n     fn create_stable_hashing_context(&self) -> Self::StableHashingContext {\n         TyCtxt::create_stable_hashing_context(*self)\n     }"}, {"sha": "81c44b27033ec07252961490db2a035e2af1b218", "filename": "compiler/rustc_middle/src/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -199,14 +199,10 @@ pub trait CrateStore: std::fmt::Debug {\n     // incr.  comp. uses to identify a CrateNum.\n     fn crate_name(&self, cnum: CrateNum) -> Symbol;\n     fn stable_crate_id(&self, cnum: CrateNum) -> StableCrateId;\n+    fn stable_crate_id_to_crate_num(&self, stable_crate_id: StableCrateId) -> CrateNum;\n \n     /// Fetch a DefId from a DefPathHash for a foreign crate.\n-    fn def_path_hash_to_def_id(\n-        &self,\n-        cnum: CrateNum,\n-        index_guess: u32,\n-        hash: DefPathHash,\n-    ) -> Option<DefId>;\n+    fn def_path_hash_to_def_id(&self, cnum: CrateNum, hash: DefPathHash) -> DefId;\n     fn expn_hash_to_expn_id(&self, cnum: CrateNum, index_guess: u32, hash: ExpnHash) -> ExpnId;\n \n     // utility functions"}, {"sha": "706c395943335a9030acae1f910f3827939de3d9", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -1,7 +1,7 @@\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n-use crate::dep_graph::{DepGraph, DepNode};\n+use crate::dep_graph::DepGraph;\n use crate::hir::place::Place as HirPlace;\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n@@ -83,23 +83,7 @@ pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     /// Converts a `DefPathHash` to its corresponding `DefId` in the current compilation\n     /// session, if it still exists. This is used during incremental compilation to\n     /// turn a deserialized `DefPathHash` into its current `DefId`.\n-    fn def_path_hash_to_def_id(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        def_path_hash: DefPathHash,\n-    ) -> Option<DefId>;\n-\n-    /// If the given `dep_node`'s hash still exists in the current compilation,\n-    /// and its current `DefId` is foreign, calls `store_foreign_def_id` with it.\n-    ///\n-    /// Normally, `store_foreign_def_id_hash` can be called directly by\n-    /// the dependency graph when we construct a `DepNode`. However,\n-    /// when we re-use a deserialized `DepNode` from the previous compilation\n-    /// session, we only have the `DefPathHash` available. This method is used\n-    /// to that any `DepNode` that we re-use has a `DefPathHash` -> `RawId` written\n-    /// out for usage in the next compilation session.\n-    fn register_reused_dep_node(&self, tcx: TyCtxt<'tcx>, dep_node: &DepNode);\n-    fn store_foreign_def_id_hash(&self, def_id: DefId, hash: DefPathHash);\n+    fn def_path_hash_to_def_id(&self, tcx: TyCtxt<'tcx>, def_path_hash: DefPathHash) -> DefId;\n \n     fn drop_serialized_data(&self, tcx: TyCtxt<'tcx>);\n \n@@ -1316,6 +1300,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Maps a StableCrateId to the corresponding CrateNum. This method assumes\n+    /// that the crate in question has already been loaded by the CrateStore.\n+    #[inline]\n+    pub fn stable_crate_id_to_crate_num(self, stable_crate_id: StableCrateId) -> CrateNum {\n+        if stable_crate_id == self.sess.local_stable_crate_id() {\n+            LOCAL_CRATE\n+        } else {\n+            self.untracked_resolutions.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n+        }\n+    }\n+\n     pub fn def_path_debug_str(self, def_id: DefId) -> String {\n         // We are explicitly not going through queries here in order to get\n         // crate name and stable crate id since this code is called from debug!()"}, {"sha": "d8cff0bd1880f898cd0d25da893d5b475c5bcd5c", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 26, "deletions": 187, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -1,12 +1,12 @@\n use crate::QueryCtxt;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::memmap::Mmap;\n-use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, OnceCell, RwLock};\n+use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, RwLock};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathHash;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n+use rustc_middle::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::mir::{self, interpret};\n use rustc_middle::thir;\n@@ -25,7 +25,6 @@ use rustc_span::hygiene::{\n use rustc_span::source_map::{SourceMap, StableSourceFileId};\n use rustc_span::CachingSourceMapView;\n use rustc_span::{BytePos, ExpnData, ExpnHash, Pos, SourceFile, Span};\n-use std::collections::hash_map::Entry;\n use std::mem;\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n@@ -51,8 +50,6 @@ pub struct OnDiskCache<'sess> {\n     // session.\n     current_side_effects: Lock<FxHashMap<DepNodeIndex, QuerySideEffects>>,\n \n-    cnum_map: OnceCell<UnhashMap<StableCrateId, CrateNum>>,\n-\n     source_map: &'sess SourceMap,\n     file_index_to_stable_id: FxHashMap<SourceFileIndex, EncodedSourceFileId>,\n \n@@ -87,27 +84,11 @@ pub struct OnDiskCache<'sess> {\n     expn_data: UnhashMap<ExpnHash, AbsoluteBytePos>,\n     // Additional information used when decoding hygiene data.\n     hygiene_context: HygieneDecodeContext,\n-    // Maps `DefPathHash`es to their `RawDefId`s from the *previous*\n+    // Maps `ExpnHash`es to their raw value from the *previous*\n     // compilation session. This is used as an initial 'guess' when\n-    // we try to map a `DefPathHash` to its `DefId` in the current compilation\n-    // session.\n-    foreign_def_path_hashes: UnhashMap<DefPathHash, RawDefId>,\n-    // Likewise for ExpnId.\n+    // we try to map an `ExpnHash` to its value in the current\n+    // compilation session.\n     foreign_expn_data: UnhashMap<ExpnHash, u32>,\n-\n-    // The *next* compilation sessison's `foreign_def_path_hashes` - at\n-    // the end of our current compilation session, this will get written\n-    // out to the `foreign_def_path_hashes` field of the `Footer`, which\n-    // will become `foreign_def_path_hashes` of the next compilation session.\n-    // This stores any `DefPathHash` that we may need to map to a `DefId`\n-    // during the next compilation session.\n-    latest_foreign_def_path_hashes: Lock<UnhashMap<DefPathHash, RawDefId>>,\n-\n-    // Caches all lookups of `DefPathHashes`, both for local and foreign\n-    // definitions. A definition from the previous compilation session\n-    // may no longer exist in the current compilation session, so\n-    // we use `Option<DefId>` so that we can cache a lookup failure.\n-    def_path_hash_to_def_id_cache: Lock<UnhashMap<DefPathHash, Option<DefId>>>,\n }\n \n // This type is used only for serialization and deserialization.\n@@ -122,7 +103,6 @@ struct Footer {\n     syntax_contexts: FxHashMap<u32, AbsoluteBytePos>,\n     // See `OnDiskCache.expn_data`\n     expn_data: UnhashMap<ExpnHash, AbsoluteBytePos>,\n-    foreign_def_path_hashes: UnhashMap<DefPathHash, RawDefId>,\n     foreign_expn_data: UnhashMap<ExpnHash, u32>,\n }\n \n@@ -145,19 +125,6 @@ impl AbsoluteBytePos {\n     }\n }\n \n-/// Represents a potentially invalid `DefId`. This is used during incremental\n-/// compilation to represent a `DefId` from the *previous* compilation session,\n-/// which may no longer be valid. This is used to help map a `DefPathHash`\n-/// to a `DefId` in the current compilation session.\n-#[derive(Encodable, Decodable, Copy, Clone, Debug)]\n-crate struct RawDefId {\n-    // We deliberately do not use `CrateNum` and `DefIndex`\n-    // here, since a crate/index from the previous compilation\n-    // session may no longer exist.\n-    pub krate: u32,\n-    pub index: u32,\n-}\n-\n /// An `EncodedSourceFileId` is the same as a `StableSourceFileId` except that\n /// the source crate is represented as a [StableCrateId] instead of as a\n /// `CrateNum`. This way `EncodedSourceFileId` can be encoded and decoded\n@@ -170,8 +137,8 @@ struct EncodedSourceFileId {\n }\n \n impl EncodedSourceFileId {\n-    fn translate(&self, cnum_map: &UnhashMap<StableCrateId, CrateNum>) -> StableSourceFileId {\n-        let cnum = cnum_map[&self.stable_crate_id];\n+    fn translate(&self, tcx: TyCtxt<'_>) -> StableSourceFileId {\n+        let cnum = tcx.stable_crate_id_to_crate_num(self.stable_crate_id);\n         StableSourceFileId { file_name_hash: self.file_name_hash, cnum }\n     }\n \n@@ -211,7 +178,6 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n             serialized_data: RwLock::new(Some(data)),\n             file_index_to_stable_id: footer.file_index_to_stable_id,\n             file_index_to_file: Default::default(),\n-            cnum_map: OnceCell::new(),\n             source_map: sess.source_map(),\n             current_side_effects: Default::default(),\n             query_result_index: footer.query_result_index.into_iter().collect(),\n@@ -221,9 +187,6 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n             expn_data: footer.expn_data,\n             foreign_expn_data: footer.foreign_expn_data,\n             hygiene_context: Default::default(),\n-            foreign_def_path_hashes: footer.foreign_def_path_hashes,\n-            latest_foreign_def_path_hashes: Default::default(),\n-            def_path_hash_to_def_id_cache: Default::default(),\n         }\n     }\n \n@@ -232,7 +195,6 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n             serialized_data: RwLock::new(None),\n             file_index_to_stable_id: Default::default(),\n             file_index_to_file: Default::default(),\n-            cnum_map: OnceCell::new(),\n             source_map,\n             current_side_effects: Default::default(),\n             query_result_index: Default::default(),\n@@ -242,9 +204,6 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n             expn_data: UnhashMap::default(),\n             foreign_expn_data: UnhashMap::default(),\n             hygiene_context: Default::default(),\n-            foreign_def_path_hashes: Default::default(),\n-            latest_foreign_def_path_hashes: Default::default(),\n-            def_path_hash_to_def_id_cache: Default::default(),\n         }\n     }\n \n@@ -254,13 +213,6 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n     /// In order to serialize the new on-disk cache, the former on-disk cache file needs to be\n     /// deleted, hence we won't be able to refer to its memmapped data.\n     fn drop_serialized_data(&self, tcx: TyCtxt<'tcx>) {\n-        // Register any dep nodes that we reused from the previous session,\n-        // but didn't `DepNode::construct` in this session. This ensures\n-        // that their `DefPathHash` to `RawDefId` mappings are registered\n-        // in 'latest_foreign_def_path_hashes' if necessary, since that\n-        // normally happens in `DepNode::construct`.\n-        tcx.dep_graph.register_reused_dep_nodes(tcx);\n-\n         // Load everything into memory so we can write it out to the on-disk\n         // cache. The vast majority of cacheable query results should already\n         // be in memory, so this should be a cheap operation.\n@@ -294,7 +246,6 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n                 (file_to_file_index, file_index_to_stable_id)\n             };\n \n-            let latest_foreign_def_path_hashes = self.latest_foreign_def_path_hashes.lock().clone();\n             let hygiene_encode_context = HygieneEncodeContext::default();\n \n             let mut encoder = CacheEncoder {\n@@ -306,7 +257,6 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n                 source_map: CachingSourceMapView::new(tcx.sess.source_map()),\n                 file_to_file_index,\n                 hygiene_context: &hygiene_encode_context,\n-                latest_foreign_def_path_hashes,\n             };\n \n             // Encode query results.\n@@ -383,9 +333,6 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n                 },\n             )?;\n \n-            let foreign_def_path_hashes =\n-                std::mem::take(&mut encoder.latest_foreign_def_path_hashes);\n-\n             // `Encode the file footer.\n             let footer_pos = encoder.position() as u64;\n             encoder.encode_tagged(\n@@ -398,7 +345,6 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n                     syntax_contexts,\n                     expn_data,\n                     foreign_expn_data,\n-                    foreign_def_path_hashes,\n                 },\n             )?;\n \n@@ -413,80 +359,21 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n         })\n     }\n \n-    fn def_path_hash_to_def_id(&self, tcx: TyCtxt<'tcx>, hash: DefPathHash) -> Option<DefId> {\n-        let mut cache = self.def_path_hash_to_def_id_cache.lock();\n-        match cache.entry(hash) {\n-            Entry::Occupied(e) => *e.get(),\n-            Entry::Vacant(e) => {\n-                debug!(\"def_path_hash_to_def_id({:?})\", hash);\n-                // Check if the `DefPathHash` corresponds to a definition in the current\n-                // crate\n-                if let Some(def_id) =\n-                    tcx.definitions_untracked().local_def_path_hash_to_def_id(hash)\n-                {\n-                    let def_id = def_id.to_def_id();\n-                    e.insert(Some(def_id));\n-                    return Some(def_id);\n-                }\n-                // This `raw_def_id` represents the `DefId` of this `DefPathHash` in\n-                // the *previous* compliation session. The `DefPathHash` includes the\n-                // owning crate, so if the corresponding definition still exists in the\n-                // current compilation session, the crate is guaranteed to be the same\n-                // (otherwise, we would compute a different `DefPathHash`).\n-                let raw_def_id = self.get_raw_def_id(&hash)?;\n-                debug!(\"def_path_hash_to_def_id({:?}): raw_def_id = {:?}\", hash, raw_def_id);\n-                // If the owning crate no longer exists, the corresponding definition definitely\n-                // no longer exists.\n-                let krate = self.try_remap_cnum(tcx, hash.stable_crate_id())?;\n-                debug!(\"def_path_hash_to_def_id({:?}): krate = {:?}\", hash, krate);\n-                // If our `DefPathHash` corresponded to a definition in the local crate,\n-                // we should have either found it in `local_def_path_hash_to_def_id`, or\n-                // never attempted to load it in the first place. Any query result or `DepNode`\n-                // that references a local `DefId` should depend on some HIR-related `DepNode`.\n-                // If a local definition is removed/modified such that its old `DefPathHash`\n-                // no longer has a corresponding definition, that HIR-related `DepNode` should\n-                // end up red. This should prevent us from ever calling\n-                // `tcx.def_path_hash_to_def_id`, since we'll end up recomputing any\n-                // queries involved.\n-                debug_assert_ne!(krate, LOCAL_CRATE);\n-                // Try to find a definition in the current session, using the previous `DefIndex`\n-                // as an initial guess.\n-                let opt_def_id =\n-                    tcx.cstore_untracked().def_path_hash_to_def_id(krate, raw_def_id.index, hash);\n-                debug!(\"def_path_to_def_id({:?}): opt_def_id = {:?}\", hash, opt_def_id);\n-                e.insert(opt_def_id);\n-                opt_def_id\n-            }\n-        }\n-    }\n+    fn def_path_hash_to_def_id(&self, tcx: TyCtxt<'tcx>, hash: DefPathHash) -> DefId {\n+        debug!(\"def_path_hash_to_def_id({:?})\", hash);\n \n-    fn register_reused_dep_node(&self, tcx: TyCtxt<'sess>, dep_node: &DepNode) {\n-        // For reused dep nodes, we only need to store the mapping if the node\n-        // is one whose query key we can reconstruct from the hash. We use the\n-        // mapping to aid that reconstruction in the next session. While we also\n-        // use it to decode `DefId`s we encoded in the cache as `DefPathHashes`,\n-        // they're already registered during `DefId` encoding.\n-        if dep_node.kind.can_reconstruct_query_key() {\n-            let hash = DefPathHash(dep_node.hash.into());\n-\n-            // We can't simply copy the `RawDefId` from `foreign_def_path_hashes` to\n-            // `latest_foreign_def_path_hashes`, since the `RawDefId` might have\n-            // changed in the current compilation session (e.g. we've added/removed crates,\n-            // or added/removed definitions before/after the target definition).\n-            if let Some(def_id) = self.def_path_hash_to_def_id(tcx, hash) {\n-                if !def_id.is_local() {\n-                    self.store_foreign_def_id_hash(def_id, hash);\n-                }\n-            }\n-        }\n-    }\n+        let stable_crate_id = hash.stable_crate_id();\n \n-    fn store_foreign_def_id_hash(&self, def_id: DefId, hash: DefPathHash) {\n-        // We may overwrite an existing entry, but it will have the same value,\n-        // so it's fine\n-        self.latest_foreign_def_path_hashes\n-            .lock()\n-            .insert(hash, RawDefId { krate: def_id.krate.as_u32(), index: def_id.index.as_u32() });\n+        // If this is a DefPathHash from the local crate, we can look up the\n+        // DefId in the tcx's `Definitions`.\n+        if stable_crate_id == tcx.sess.local_stable_crate_id() {\n+            tcx.definitions_untracked().local_def_path_hash_to_def_id(hash).to_def_id()\n+        } else {\n+            // If this is a DefPathHash from an upstream crate, let the CrateStore map\n+            // it to a DefId.\n+            let cnum = tcx.cstore_untracked().stable_crate_id_to_crate_num(stable_crate_id);\n+            tcx.cstore_untracked().def_path_hash_to_def_id(cnum, hash)\n+        }\n     }\n }\n \n@@ -518,17 +405,6 @@ impl<'sess> OnDiskCache<'sess> {\n         debug_assert!(prev.is_none());\n     }\n \n-    fn get_raw_def_id(&self, hash: &DefPathHash) -> Option<RawDefId> {\n-        self.foreign_def_path_hashes.get(hash).copied()\n-    }\n-\n-    fn try_remap_cnum(&self, tcx: TyCtxt<'_>, stable_crate_id: StableCrateId) -> Option<CrateNum> {\n-        let cnum_map = self.cnum_map.get_or_init(|| Self::compute_cnum_map(tcx));\n-        debug!(\"try_remap_cnum({:?}): cnum_map={:?}\", stable_crate_id, cnum_map);\n-\n-        cnum_map.get(&stable_crate_id).copied()\n-    }\n-\n     /// Returns the cached query result if there is something in the cache for\n     /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n     pub fn try_load_query_result<'tcx, T>(\n@@ -586,14 +462,11 @@ impl<'sess> OnDiskCache<'sess> {\n     where\n         T: Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n-        let cnum_map = self.cnum_map.get_or_init(|| Self::compute_cnum_map(tcx));\n-\n         let serialized_data = self.serialized_data.read();\n         let mut decoder = CacheDecoder {\n             tcx,\n             opaque: opaque::Decoder::new(serialized_data.as_deref().unwrap_or(&[]), pos.to_usize()),\n             source_map: self.source_map,\n-            cnum_map,\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n             alloc_decoding_session: self.alloc_decoding_state.new_decoding_session(),\n@@ -604,23 +477,6 @@ impl<'sess> OnDiskCache<'sess> {\n         };\n         f(&mut decoder)\n     }\n-\n-    // This function builds mapping from previous-session-`CrateNum` to\n-    // current-session-`CrateNum`. There might be `CrateNum`s from the previous\n-    // `Session` that don't occur in the current one. For these, the mapping\n-    // maps to None.\n-    fn compute_cnum_map(tcx: TyCtxt<'_>) -> UnhashMap<StableCrateId, CrateNum> {\n-        tcx.dep_graph.with_ignore(|| {\n-            tcx.crates(())\n-                .iter()\n-                .chain(std::iter::once(&LOCAL_CRATE))\n-                .map(|&cnum| {\n-                    let hash = tcx.def_path_hash(cnum.as_def_id()).stable_crate_id();\n-                    (hash, cnum)\n-                })\n-                .collect()\n-        })\n-    }\n }\n \n //- DECODING -------------------------------------------------------------------\n@@ -632,7 +488,6 @@ pub struct CacheDecoder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     opaque: opaque::Decoder<'a>,\n     source_map: &'a SourceMap,\n-    cnum_map: &'a UnhashMap<StableCrateId, CrateNum>,\n     file_index_to_file: &'a Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n     file_index_to_stable_id: &'a FxHashMap<SourceFileIndex, EncodedSourceFileId>,\n     alloc_decoding_session: AllocDecodingSession<'a>,\n@@ -645,18 +500,18 @@ pub struct CacheDecoder<'a, 'tcx> {\n impl<'a, 'tcx> CacheDecoder<'a, 'tcx> {\n     fn file_index_to_file(&self, index: SourceFileIndex) -> Lrc<SourceFile> {\n         let CacheDecoder {\n+            tcx,\n             ref file_index_to_file,\n             ref file_index_to_stable_id,\n             ref source_map,\n-            ref cnum_map,\n             ..\n         } = *self;\n \n         file_index_to_file\n             .borrow_mut()\n             .entry(index)\n             .or_insert_with(|| {\n-                let stable_id = file_index_to_stable_id[&index].translate(cnum_map);\n+                let stable_id = file_index_to_stable_id[&index].translate(tcx);\n                 source_map\n                     .source_file_by_stable_id(stable_id)\n                     .expect(\"failed to lookup `SourceFile` in new context\")\n@@ -798,7 +653,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n             return Ok(expn_id);\n         }\n \n-        let krate = decoder.cnum_map[&hash.stable_crate_id()];\n+        let krate = decoder.tcx.stable_crate_id_to_crate_num(hash.stable_crate_id());\n \n         let expn_id = if krate == LOCAL_CRATE {\n             // We look up the position of the associated `ExpnData` and decode it.\n@@ -871,7 +726,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Span {\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for CrateNum {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n         let stable_id = StableCrateId::decode(d)?;\n-        let cnum = d.cnum_map[&stable_id];\n+        let cnum = d.tcx.stable_crate_id_to_crate_num(stable_id);\n         Ok(cnum)\n     }\n }\n@@ -899,12 +754,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n         // If we get to this point, then all of the query inputs were green,\n         // which means that the definition with this hash is guaranteed to\n         // still exist in the current compilation session.\n-        Ok(d.tcx()\n-            .on_disk_cache\n-            .as_ref()\n-            .unwrap()\n-            .def_path_hash_to_def_id(d.tcx(), def_path_hash)\n-            .unwrap())\n+        Ok(d.tcx().on_disk_cache.as_ref().unwrap().def_path_hash_to_def_id(d.tcx(), def_path_hash))\n     }\n }\n \n@@ -969,7 +819,6 @@ pub struct CacheEncoder<'a, 'tcx, E: OpaqueEncoder> {\n     source_map: CachingSourceMapView<'tcx>,\n     file_to_file_index: FxHashMap<*const SourceFile, SourceFileIndex>,\n     hygiene_context: &'a HygieneEncodeContext,\n-    latest_foreign_def_path_hashes: UnhashMap<DefPathHash, RawDefId>,\n }\n \n impl<'a, 'tcx, E> CacheEncoder<'a, 'tcx, E>\n@@ -1102,17 +951,7 @@ where\n     E: 'a + OpaqueEncoder,\n {\n     fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n-        let def_path_hash = s.tcx.def_path_hash(*self);\n-        // Store additional information when we encode a foreign `DefId`,\n-        // so that we can map its `DefPathHash` back to a `DefId` in the next\n-        // compilation session.\n-        if !self.is_local() {\n-            s.latest_foreign_def_path_hashes.insert(\n-                def_path_hash,\n-                RawDefId { krate: self.krate.as_u32(), index: self.index.as_u32() },\n-            );\n-        }\n-        def_path_hash.encode(s)\n+        s.tcx.def_path_hash(*self).encode(s)\n     }\n }\n "}, {"sha": "46dc0c720ce7f998b133cc619a432171728702e9", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -53,18 +53,6 @@ use std::hash::Hash;\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n pub struct DepNode<K> {\n     pub kind: K,\n-    // Important - whenever a `DepNode` is constructed, we need to make\n-    // sure to register a `DefPathHash -> DefId` mapping if needed.\n-    // This is currently done in two places:\n-    //\n-    // * When a `DepNode::construct` is called, `arg.to_fingerprint()`\n-    //   is responsible for calling `OnDiskCache::store_foreign_def_id_hash`\n-    //   if needed\n-    // * When we serialize the on-disk cache, `OnDiskCache::serialize` is\n-    //   responsible for calling `DepGraph::register_reused_dep_nodes`.\n-    //\n-    // FIXME: Enforce this by preventing manual construction of `DefNode`\n-    // (e.g. add a `_priv: ()` field)\n     pub hash: PackedFingerprint,\n }\n "}, {"sha": "23a437718427222a7c9440afa148757030e1633e", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -760,20 +760,6 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n-    // Register reused dep nodes (i.e. nodes we've marked red or green) with the context.\n-    pub fn register_reused_dep_nodes<Ctxt: DepContext<DepKind = K>>(&self, tcx: Ctxt) {\n-        let data = self.data.as_ref().unwrap();\n-        for prev_index in data.colors.values.indices() {\n-            match data.colors.get(prev_index) {\n-                Some(DepNodeColor::Red) | Some(DepNodeColor::Green(_)) => {\n-                    let dep_node = data.previous.index_to_node(prev_index);\n-                    tcx.register_reused_dep_node(&dep_node);\n-                }\n-                None => {}\n-            }\n-        }\n-    }\n-\n     pub fn print_incremental_info(&self) {\n         if let Some(data) = &self.data {\n             data.current.encoder.borrow().print_incremental_info("}, {"sha": "b5be1192ce73fe14833fae7e660ba708fadcc87c", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -27,8 +27,6 @@ pub trait DepContext: Copy {\n     /// Access the DepGraph.\n     fn dep_graph(&self) -> &DepGraph<Self::DepKind>;\n \n-    fn register_reused_dep_node(&self, dep_node: &DepNode<Self::DepKind>);\n-\n     /// Access the profiler.\n     fn profiler(&self) -> &SelfProfilerRef;\n "}, {"sha": "60703384e9e85ab74b6c967c4033fc8987bd4a19", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6cd2c6c877110748296760aefddc21a0ea1d316/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cd2c6c877110748296760aefddc21a0ea1d316/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=d6cd2c6c877110748296760aefddc21a0ea1d316", "patch": "@@ -144,6 +144,7 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"num-integer\",\n     \"num-traits\",\n     \"object\",\n+    \"odht\",\n     \"once_cell\",\n     \"opaque-debug\",\n     \"parking_lot\","}]}