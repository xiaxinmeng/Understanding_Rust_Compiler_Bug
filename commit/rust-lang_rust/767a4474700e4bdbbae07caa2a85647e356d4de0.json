{"sha": "767a4474700e4bdbbae07caa2a85647e356d4de0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2N2E0NDc0NzAwZTRiZGJiYWUwN2NhYTJhODU2NDdlMzU2ZDRkZTA=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-02-13T21:04:17Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-02-17T22:04:28Z"}, "message": "privacy: Mark reachable but unnameable items as reachable", "tree": {"sha": "1868d15932eb891726de4da6aa6513be15abf29e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1868d15932eb891726de4da6aa6513be15abf29e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/767a4474700e4bdbbae07caa2a85647e356d4de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/767a4474700e4bdbbae07caa2a85647e356d4de0", "html_url": "https://github.com/rust-lang/rust/commit/767a4474700e4bdbbae07caa2a85647e356d4de0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/767a4474700e4bdbbae07caa2a85647e356d4de0/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2051a92134bae8b4c5fd3fdeab32c78b7bd74014", "url": "https://api.github.com/repos/rust-lang/rust/commits/2051a92134bae8b4c5fd3fdeab32c78b7bd74014", "html_url": "https://github.com/rust-lang/rust/commit/2051a92134bae8b4c5fd3fdeab32c78b7bd74014"}], "stats": {"total": 187, "additions": 176, "deletions": 11}, "files": [{"sha": "b8bcf2ed9e5d3022192faa70501ec8dc7536c426", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 134, "deletions": 11, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/767a4474700e4bdbbae07caa2a85647e356d4de0/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767a4474700e4bdbbae07caa2a85647e356d4de0/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=767a4474700e4bdbbae07caa2a85647e356d4de0", "patch": "@@ -169,6 +169,10 @@ struct EmbargoVisitor<'a, 'tcx: 'a> {\n     changed: bool,\n }\n \n+struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n+    ev: &'b mut EmbargoVisitor<'a, 'tcx>,\n+}\n+\n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn ty_level(&self, ty: &hir::Ty) -> Option<AccessLevel> {\n         if let hir::TyPath(..) = ty.node {\n@@ -214,6 +218,10 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n             old_level\n         }\n     }\n+\n+    fn reach<'b>(&'b mut self) -> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+        ReachEverythingInTheInterfaceVisitor { ev: self }\n+    }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n@@ -245,10 +253,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             }\n         };\n \n-        // Update id of the item itself\n+        // Update level of the item itself\n         let item_level = self.update(item.id, inherited_item_level);\n \n-        // Update ids of nested things\n+        // Update levels of nested things\n         match item.node {\n             hir::ItemEnum(ref def, _) => {\n                 for variant in &def.variants {\n@@ -292,19 +300,72 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemTy(ref ty, _) if item_level.is_some() => {\n-                if let hir::TyPath(..) = ty.node {\n-                    match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n-                        Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {},\n-                        def => {\n-                            if let Some(node_id) = self.tcx.map.as_local_node_id(def.def_id()) {\n-                                self.update(node_id, Some(AccessLevel::Reachable));\n-                            }\n+            _ => {}\n+        }\n+\n+        // Mark all items in interfaces of reachable items as reachable\n+        match item.node {\n+            // The interface is empty\n+            hir::ItemExternCrate(..) => {}\n+            // All nested items are checked by visit_item\n+            hir::ItemMod(..) => {}\n+            // Reexports are handled in visit_mod\n+            hir::ItemUse(..) => {}\n+            // Visit everything\n+            hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n+            hir::ItemTrait(..) | hir::ItemTy(..) | hir::ItemImpl(_, _, _, Some(..), _, _) => {\n+                if item_level.is_some() {\n+                    self.reach().visit_item(item);\n+                }\n+            }\n+            // Visit everything, but enum variants have their own levels\n+            hir::ItemEnum(ref def, ref generics) => {\n+                if item_level.is_some() {\n+                    self.reach().visit_generics(generics);\n+                }\n+                for variant in &def.variants {\n+                    if self.get(variant.node.data.id()).is_some() {\n+                        for field in variant.node.data.fields() {\n+                            self.reach().visit_struct_field(field);\n+                        }\n+                        // Corner case: if the variant is reachable, but its\n+                        // enum is not, make the enum reachable as well.\n+                        self.update(item.id, Some(AccessLevel::Reachable));\n+                    }\n+                }\n+            }\n+            // Visit everything, but foreign items have their own levels\n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    if self.get(foreign_item.id).is_some() {\n+                        self.reach().visit_foreign_item(foreign_item);\n+                    }\n+                }\n+            }\n+            // Visit everything except for private fields\n+            hir::ItemStruct(ref struct_def, ref generics) => {\n+                if item_level.is_some() {\n+                    self.reach().visit_generics(generics);\n+                    for field in struct_def.fields() {\n+                        if field.node.kind.visibility() == hir::Public {\n+                            self.reach().visit_struct_field(field);\n+                        }\n+                    }\n+                }\n+            }\n+            // The interface is empty\n+            hir::ItemDefaultImpl(..) => {}\n+            // Visit everything except for private impl items\n+            hir::ItemImpl(_, _, ref generics, None, _, ref impl_items) => {\n+                if item_level.is_some() {\n+                    self.reach().visit_generics(generics);\n+                    for impl_item in impl_items {\n+                        if impl_item.vis == hir::Public {\n+                            self.reach().visit_impl_item(impl_item);\n                         }\n                     }\n                 }\n             }\n-            _ => {}\n         }\n \n         let orig_level = self.prev_level;\n@@ -347,6 +408,68 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n     }\n }\n \n+impl<'b, 'a, 'tcx: 'a> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+    // Make the type hidden under a type alias reachable\n+    fn reach_aliased_type(&mut self, item: &hir::Item, path: &hir::Path) {\n+        if let hir::ItemTy(ref ty, ref generics) = item.node {\n+            // See `fn is_public_type_alias` for details\n+            self.visit_ty(ty);\n+            let provided_params = path.segments.last().unwrap().parameters.types().len();\n+            for ty_param in &generics.ty_params[provided_params..] {\n+                if let Some(ref default_ty) = ty_param.default {\n+                    self.visit_ty(default_ty);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n+        if let hir::TyPath(_, ref path) = ty.node {\n+            let def = self.ev.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n+            match def {\n+                Def::Struct(def_id) | Def::Enum(def_id) | Def::TyAlias(def_id) |\n+                Def::Trait(def_id) | Def::AssociatedTy(def_id, _) => {\n+                    if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n+                        let item = self.ev.tcx.map.expect_item(node_id);\n+                        if let Def::TyAlias(..) = def {\n+                            // Type aliases are substituted. Associated type aliases are not\n+                            // substituted yet, but ideally they should be.\n+                            if self.ev.get(item.id).is_none() {\n+                                self.reach_aliased_type(item, path);\n+                            }\n+                        } else {\n+                            self.ev.update(item.id, Some(AccessLevel::Reachable));\n+                        }\n+                    }\n+                }\n+\n+                _ => {}\n+            }\n+        }\n+\n+        intravisit::walk_ty(self, ty);\n+    }\n+\n+    fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n+        let def_id = self.ev.tcx.trait_ref_to_def_id(trait_ref);\n+        if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n+            let item = self.ev.tcx.map.expect_item(node_id);\n+            self.ev.update(item.id, Some(AccessLevel::Reachable));\n+        }\n+\n+        intravisit::walk_trait_ref(self, trait_ref);\n+    }\n+\n+    // Don't recurse into function bodies\n+    fn visit_block(&mut self, _: &hir::Block) {}\n+    // Don't recurse into expressions in array sizes or const initializers\n+    fn visit_expr(&mut self, _: &hir::Expr) {}\n+    // Don't recurse into patterns in function arguments\n+    fn visit_pat(&mut self, _: &hir::Pat) {}\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n /// The privacy visitor, where privacy checks take place (violations reported)\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "9b1635c1944a7b6dd11a5565c46ee36902f5b75b", "filename": "src/test/auxiliary/issue-16734.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/767a4474700e4bdbbae07caa2a85647e356d4de0/src%2Ftest%2Fauxiliary%2Fissue-16734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767a4474700e4bdbbae07caa2a85647e356d4de0/src%2Ftest%2Fauxiliary%2Fissue-16734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-16734.rs?ref=767a4474700e4bdbbae07caa2a85647e356d4de0", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod inner_private_module {\n+    pub struct Unnameable;\n+\n+    impl Unnameable {\n+        pub fn method_of_unnameable_type(&self) -> &'static str {\n+            \"Hello!\"\n+        }\n+    }\n+}\n+\n+pub fn public_function_returning_unnameable_type() -> inner_private_module::Unnameable {\n+    inner_private_module::Unnameable\n+}"}, {"sha": "80225c9fe8eacc0c85934f17c919302ebbd6ba84", "filename": "src/test/run-pass/issue-16734.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/767a4474700e4bdbbae07caa2a85647e356d4de0/src%2Ftest%2Frun-pass%2Fissue-16734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767a4474700e4bdbbae07caa2a85647e356d4de0/src%2Ftest%2Frun-pass%2Fissue-16734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16734.rs?ref=767a4474700e4bdbbae07caa2a85647e356d4de0", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-16734.rs\n+\n+extern crate issue_16734;\n+\n+fn main() {\n+    let res = issue_16734::public_function_returning_unnameable_type()\n+                                .method_of_unnameable_type();\n+    assert_eq!(res, \"Hello!\");\n+}"}]}