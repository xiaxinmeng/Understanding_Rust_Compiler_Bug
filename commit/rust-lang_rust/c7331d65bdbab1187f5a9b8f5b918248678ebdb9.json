{"sha": "c7331d65bdbab1187f5a9b8f5b918248678ebdb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MzMxZDY1YmRiYWIxMTg3ZjVhOWI4ZjViOTE4MjQ4Njc4ZWJkYjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-17T20:23:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-17T20:23:58Z"}, "message": "Auto merge of #87203 - jackh726:logging, r=nikomatsakis\n\nSome perf optimizations and logging\n\nVarious bits of (potential) perf optimizations and some logging additions/changes pulled out from #85499\n\nThe only not extremely straightforward change is adding `needs_normalization` in `trait::project`. This is just a perf optimization to avoid fold through a type with *only* opaque types in `UserFacing` mode (as they aren't replaced).\n\nThis should be a simple PR for *anyone* to review, so I'm going to let highfive assign. But I'll go ahead and cc `@nikomatsakis` in case he has time today.", "tree": {"sha": "0b2681f7ed2cd89df7cd8b8dfaf36c85dd6c7244", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b2681f7ed2cd89df7cd8b8dfaf36c85dd6c7244"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7331d65bdbab1187f5a9b8f5b918248678ebdb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7331d65bdbab1187f5a9b8f5b918248678ebdb9", "html_url": "https://github.com/rust-lang/rust/commit/c7331d65bdbab1187f5a9b8f5b918248678ebdb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68511b574ffe019a5cb3e9fa92605f80d39167bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/68511b574ffe019a5cb3e9fa92605f80d39167bc", "html_url": "https://github.com/rust-lang/rust/commit/68511b574ffe019a5cb3e9fa92605f80d39167bc"}, {"sha": "fa839b1194a401c77a5fadba0a2b351870ea4683", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa839b1194a401c77a5fadba0a2b351870ea4683", "html_url": "https://github.com/rust-lang/rust/commit/fa839b1194a401c77a5fadba0a2b351870ea4683"}], "stats": {"total": 63, "additions": 45, "deletions": 18}, "files": [{"sha": "25b7a84b3a06929fa5c0df1c8f1c3f92848727e0", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=c7331d65bdbab1187f5a9b8f5b918248678ebdb9", "patch": "@@ -418,6 +418,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// be called in a loop until `outcome.stalled` is false.\n     ///\n     /// This _cannot_ be unrolled (presently, at least).\n+    #[inline(never)]\n     pub fn process_obligations<P, OUT>(&mut self, processor: &mut P) -> OUT\n     where\n         P: ObligationProcessor<Obligation = O>,\n@@ -671,6 +672,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.reused_node_vec = node_rewrites;\n     }\n \n+    #[inline(never)]\n     fn apply_rewrites(&mut self, node_rewrites: &[usize]) {\n         let orig_nodes_len = node_rewrites.len();\n "}, {"sha": "13b78b26af4244a6d1ea6803a26c2d6de4113afb", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=c7331d65bdbab1187f5a9b8f5b918248678ebdb9", "patch": "@@ -400,6 +400,7 @@ impl<'tcx> From<ty::TyVid> for TyVidEqKey<'tcx> {\n \n impl<'tcx> ut::UnifyKey for TyVidEqKey<'tcx> {\n     type Value = TypeVariableValue<'tcx>;\n+    #[inline(always)]\n     fn index(&self) -> u32 {\n         self.vid.index\n     }"}, {"sha": "dfe2909498d1862ecaceed5bb5636f4cae822667", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=c7331d65bdbab1187f5a9b8f5b918248678ebdb9", "patch": "@@ -167,15 +167,14 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     /// `SomeTrait` or a where-clause that lets us unify `$0` with\n     /// something concrete. If this fails, we'll unify `$0` with\n     /// `projection_ty` again.\n+    #[tracing::instrument(level = \"debug\", skip(self, infcx, param_env, cause))]\n     fn normalize_projection_type(\n         &mut self,\n         infcx: &InferCtxt<'_, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         projection_ty: ty::ProjectionTy<'tcx>,\n         cause: ObligationCause<'tcx>,\n     ) -> Ty<'tcx> {\n-        debug!(?projection_ty, \"normalize_projection_type\");\n-\n         debug_assert!(!projection_ty.has_escaping_bound_vars());\n \n         // FIXME(#20304) -- cache"}, {"sha": "d1ab9fa025ed6f5156e4e4fdcef711063971e590", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=c7331d65bdbab1187f5a9b8f5b918248678ebdb9", "patch": "@@ -273,7 +273,7 @@ where\n     Normalized { value, obligations }\n }\n \n-#[instrument(level = \"debug\", skip(selcx, param_env, cause, obligations))]\n+#[instrument(level = \"info\", skip(selcx, param_env, cause, obligations))]\n pub fn normalize_with_depth_to<'a, 'b, 'tcx, T>(\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -285,13 +285,26 @@ pub fn normalize_with_depth_to<'a, 'b, 'tcx, T>(\n where\n     T: TypeFoldable<'tcx>,\n {\n+    debug!(obligations.len = obligations.len());\n     let mut normalizer = AssocTypeNormalizer::new(selcx, param_env, cause, depth, obligations);\n     let result = ensure_sufficient_stack(|| normalizer.fold(value));\n     debug!(?result, obligations.len = normalizer.obligations.len());\n     debug!(?normalizer.obligations,);\n     result\n }\n \n+pub(crate) fn needs_normalization<'tcx, T: TypeFoldable<'tcx>>(value: &T, reveal: Reveal) -> bool {\n+    match reveal {\n+        Reveal::UserFacing => value\n+            .has_type_flags(ty::TypeFlags::HAS_TY_PROJECTION | ty::TypeFlags::HAS_CT_PROJECTION),\n+        Reveal::All => value.has_type_flags(\n+            ty::TypeFlags::HAS_TY_PROJECTION\n+                | ty::TypeFlags::HAS_TY_OPAQUE\n+                | ty::TypeFlags::HAS_CT_PROJECTION,\n+        ),\n+    }\n+}\n+\n struct AssocTypeNormalizer<'a, 'b, 'tcx> {\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -314,14 +327,19 @@ impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n \n     fn fold<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n         let value = self.selcx.infcx().resolve_vars_if_possible(value);\n+        debug!(?value);\n \n         assert!(\n             !value.has_escaping_bound_vars(),\n             \"Normalizing {:?} without wrapping in a `Binder`\",\n             value\n         );\n \n-        if !value.has_projections() { value } else { value.fold_with(self) }\n+        if !needs_normalization(&value, self.param_env.reveal()) {\n+            value\n+        } else {\n+            value.fold_with(self)\n+        }\n     }\n }\n \n@@ -341,7 +359,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty.has_projections() {\n+        if !needs_normalization(&ty, self.param_env.reveal()) {\n             return ty;\n         }\n         // We don't want to normalize associated types that occur inside of region\n@@ -825,7 +843,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n \n     let cache_result = infcx.inner.borrow_mut().projection_cache().try_start(cache_key);\n     match cache_result {\n-        Ok(()) => {}\n+        Ok(()) => debug!(\"no cache\"),\n         Err(ProjectionCacheEntry::Ambiguous) => {\n             // If we found ambiguity the last time, that means we will continue\n             // to do so until some type in the key changes (and we know it\n@@ -852,6 +870,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             return Err(InProgress);\n         }\n         Err(ProjectionCacheEntry::Recur) => {\n+            debug!(\"recur cache\");\n             return Err(InProgress);\n         }\n         Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n@@ -1058,12 +1077,11 @@ impl<'tcx> Progress<'tcx> {\n ///\n /// IMPORTANT:\n /// - `obligation` must be fully normalized\n+#[tracing::instrument(level = \"info\", skip(selcx))]\n fn project_type<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n ) -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>> {\n-    debug!(?obligation, \"project_type\");\n-\n     if !selcx.tcx().recursion_limit().value_within_limit(obligation.recursion_depth) {\n         debug!(\"project: overflow!\");\n         // This should really be an immediate error, but some existing code"}, {"sha": "d65a378b1edec193ecd750f7c23ad6b76ffe6dab", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=c7331d65bdbab1187f5a9b8f5b918248678ebdb9", "patch": "@@ -6,6 +6,7 @@ use crate::infer::at::At;\n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n use crate::traits::error_reporting::InferCtxtExt;\n+use crate::traits::project::needs_normalization;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use rustc_data_structures::sso::SsoHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n@@ -49,7 +50,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n             value,\n             self.param_env,\n         );\n-        if !value.has_projections() {\n+        if !needs_normalization(&value, self.param_env.reveal()) {\n             return Ok(Normalized { value, obligations: vec![] });\n         }\n \n@@ -65,7 +66,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n         };\n \n         let result = value.fold_with(&mut normalizer);\n-        debug!(\n+        info!(\n             \"normalize::<{}>: result={:?} with {} obligations\",\n             std::any::type_name::<T>(),\n             result,\n@@ -112,7 +113,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty.has_projections() {\n+        if !needs_normalization(&ty, self.param_env.reveal()) {\n             return ty;\n         }\n "}, {"sha": "564c63ef30cb66411aa63f0afbb0259e696d4d81", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=c7331d65bdbab1187f5a9b8f5b918248678ebdb9", "patch": "@@ -1865,12 +1865,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn match_impl(\n         &mut self,\n         impl_def_id: DefId,\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<Normalized<'tcx, SubstsRef<'tcx>>, ()> {\n-        debug!(?impl_def_id, ?obligation, \"match_impl\");\n         let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n \n         // Before we create the substitutions and everything, first\n@@ -1888,6 +1888,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(), impl_substs);\n \n+        debug!(?impl_trait_ref);\n+\n         let Normalized { value: impl_trait_ref, obligations: mut nested_obligations } =\n             ensure_sufficient_stack(|| {\n                 project::normalize_with_depth(\n@@ -1915,7 +1917,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(());\n         }\n \n-        debug!(?impl_substs, \"match_impl: success\");\n+        debug!(?impl_substs, ?nested_obligations, \"match_impl: success\");\n         Ok(Normalized { value: impl_substs, obligations: nested_obligations })\n     }\n \n@@ -2068,6 +2070,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// impl or trait. The obligations are substituted and fully\n     /// normalized. This is used when confirming an impl or default\n     /// impl.\n+    #[tracing::instrument(level = \"debug\", skip(self, cause, param_env))]\n     fn impl_or_trait_obligations(\n         &mut self,\n         cause: ObligationCause<'tcx>,\n@@ -2076,7 +2079,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         def_id: DefId,           // of impl or trait\n         substs: SubstsRef<'tcx>, // for impl or trait\n     ) -> Vec<PredicateObligation<'tcx>> {\n-        debug!(?def_id, \"impl_or_trait_obligations\");\n         let tcx = self.tcx();\n \n         // To allow for one-pass evaluation of the nested obligation,\n@@ -2094,9 +2096,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // `$1: Copy`, so we must ensure the obligations are emitted in\n         // that order.\n         let predicates = tcx.predicates_of(def_id);\n+        debug!(?predicates);\n         assert_eq!(predicates.parent, None);\n         let mut obligations = Vec::with_capacity(predicates.predicates.len());\n         for (predicate, _) in predicates.predicates {\n+            debug!(?predicate);\n             let predicate = normalize_with_depth_to(\n                 self,\n                 param_env,"}, {"sha": "27c8e00c5596cf26f66bb649560796a75ef232ee", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=c7331d65bdbab1187f5a9b8f5b918248678ebdb9", "patch": "@@ -85,6 +85,7 @@ pub fn trait_obligations<'a, 'tcx>(\n     let mut wf =\n         WfPredicates { infcx, param_env, body_id, span, out: vec![], recursion_depth: 0, item };\n     wf.compute_trait_ref(trait_ref, Elaborate::All);\n+    debug!(obligations = ?wf.out);\n     wf.normalize()\n }\n "}, {"sha": "4ed07ba358de3b3794d76c9f0f7538b37545dcc8", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=c7331d65bdbab1187f5a9b8f5b918248678ebdb9", "patch": "@@ -1578,6 +1578,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Add all the obligations that are required, substituting and normalized appropriately.\n+    #[tracing::instrument(level = \"debug\", skip(self, span, def_id, substs))]\n     fn add_required_obligations(&self, span: Span, def_id: DefId, substs: &SubstsRef<'tcx>) {\n         let (bounds, spans) = self.instantiate_bounds(span, def_id, &substs);\n "}, {"sha": "7e43e36fe55c6e8ae64ad78f1570621f241a7d5f", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=c7331d65bdbab1187f5a9b8f5b918248678ebdb9", "patch": "@@ -179,6 +179,7 @@ impl Inherited<'a, 'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         let ok = self.partially_normalize_associated_types_in(cause, param_env, value);\n+        debug!(?ok);\n         self.register_infer_ok_obligations(ok)\n     }\n }"}, {"sha": "b24d63917c1cf48a72eb97e8aced98dd93d95d00", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7331d65bdbab1187f5a9b8f5b918248678ebdb9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=c7331d65bdbab1187f5a9b8f5b918248678ebdb9", "patch": "@@ -379,14 +379,13 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n     }\n }\n \n+#[tracing::instrument(level = \"debug\", skip(tcx, span, sig_if_method))]\n fn check_associated_item(\n     tcx: TyCtxt<'_>,\n     item_id: hir::HirId,\n     span: Span,\n     sig_if_method: Option<&hir::FnSig<'_>>,\n ) {\n-    debug!(\"check_associated_item: {:?}\", item_id);\n-\n     let code = ObligationCauseCode::WellFormed(Some(item_id));\n     for_id(tcx, item_id, span).with_fcx(|fcx| {\n         let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id(item_id));\n@@ -650,14 +649,13 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_fo\n     });\n }\n \n+#[tracing::instrument(level = \"debug\", skip(tcx, ast_self_ty, ast_trait_ref))]\n fn check_impl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     item: &'tcx hir::Item<'tcx>,\n     ast_self_ty: &hir::Ty<'_>,\n     ast_trait_ref: &Option<hir::TraitRef<'_>>,\n ) {\n-    debug!(\"check_impl: {:?}\", item);\n-\n     for_item(tcx, item).with_fcx(|fcx| {\n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n@@ -675,6 +673,7 @@ fn check_impl<'tcx>(\n                     ast_trait_ref.path.span,\n                     Some(item),\n                 );\n+                debug!(?obligations);\n                 for obligation in obligations {\n                     fcx.register_predicate(obligation);\n                 }"}]}