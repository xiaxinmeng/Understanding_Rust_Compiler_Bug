{"sha": "7ec72efe10df28fcf5c6ec13c2a487572041be59", "node_id": "C_kwDOAAsO6NoAKDdlYzcyZWZlMTBkZjI4ZmNmNWM2ZWMxM2MyYTQ4NzU3MjA0MWJlNTk", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-02T21:22:02Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-11T17:45:42Z"}, "message": "Allow the elaborator to only filter to real supertraits", "tree": {"sha": "7f37906cf05513c69c824bb70873c88feeb09611", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f37906cf05513c69c824bb70873c88feeb09611"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ec72efe10df28fcf5c6ec13c2a487572041be59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ec72efe10df28fcf5c6ec13c2a487572041be59", "html_url": "https://github.com/rust-lang/rust/commit/7ec72efe10df28fcf5c6ec13c2a487572041be59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ec72efe10df28fcf5c6ec13c2a487572041be59/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4560b61cd15aa026a03a64c99ead1edf7896826f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4560b61cd15aa026a03a64c99ead1edf7896826f", "html_url": "https://github.com/rust-lang/rust/commit/4560b61cd15aa026a03a64c99ead1edf7896826f"}], "stats": {"total": 155, "additions": 107, "deletions": 48}, "files": [{"sha": "8cb95610da08005eb2fd7c6af76b42394f1e48fa", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7ec72efe10df28fcf5c6ec13c2a487572041be59/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec72efe10df28fcf5c6ec13c2a487572041be59/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=7ec72efe10df28fcf5c6ec13c2a487572041be59", "patch": "@@ -1663,39 +1663,45 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             })\n         });\n \n-        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n-            bound.map_bound(|mut b| {\n-                assert_eq!(b.projection_ty.self_ty(), dummy_self);\n-\n-                // Like for trait refs, verify that `dummy_self` did not leak inside default type\n-                // parameters.\n-                let references_self = b.projection_ty.substs.iter().skip(1).any(|arg| {\n-                    if arg.walk().any(|arg| arg == dummy_self.into()) {\n-                        return true;\n+        let existential_projections = projection_bounds\n+            .iter()\n+            // We filter out traits that don't have `Self` as their self type above,\n+            // we need to do the same for projections.\n+            .filter(|(bound, _)| bound.skip_binder().self_ty() == dummy_self)\n+            .map(|(bound, _)| {\n+                bound.map_bound(|mut b| {\n+                    assert_eq!(b.projection_ty.self_ty(), dummy_self);\n+\n+                    // Like for trait refs, verify that `dummy_self` did not leak inside default type\n+                    // parameters.\n+                    let references_self = b.projection_ty.substs.iter().skip(1).any(|arg| {\n+                        if arg.walk().any(|arg| arg == dummy_self.into()) {\n+                            return true;\n+                        }\n+                        false\n+                    });\n+                    if references_self {\n+                        let guar = tcx.sess.delay_span_bug(\n+                            span,\n+                            \"trait object projection bounds reference `Self`\",\n+                        );\n+                        let substs: Vec<_> = b\n+                            .projection_ty\n+                            .substs\n+                            .iter()\n+                            .map(|arg| {\n+                                if arg.walk().any(|arg| arg == dummy_self.into()) {\n+                                    return tcx.ty_error(guar).into();\n+                                }\n+                                arg\n+                            })\n+                            .collect();\n+                        b.projection_ty.substs = tcx.mk_substs(&substs);\n                     }\n-                    false\n-                });\n-                if references_self {\n-                    let guar = tcx\n-                        .sess\n-                        .delay_span_bug(span, \"trait object projection bounds reference `Self`\");\n-                    let substs: Vec<_> = b\n-                        .projection_ty\n-                        .substs\n-                        .iter()\n-                        .map(|arg| {\n-                            if arg.walk().any(|arg| arg == dummy_self.into()) {\n-                                return tcx.ty_error(guar).into();\n-                            }\n-                            arg\n-                        })\n-                        .collect();\n-                    b.projection_ty.substs = tcx.mk_substs(&substs);\n-                }\n \n-                ty::ExistentialProjection::erase_self_ty(tcx, b)\n-            })\n-        });\n+                    ty::ExistentialProjection::erase_self_ty(tcx, b)\n+                })\n+            });\n \n         let regular_trait_predicates = existential_trait_refs\n             .map(|trait_ref| trait_ref.map_bound(ty::ExistentialPredicate::Trait));"}, {"sha": "8c2495e1dd8c51dc6da052d86071aac955f3c081", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ec72efe10df28fcf5c6ec13c2a487572041be59/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec72efe10df28fcf5c6ec13c2a487572041be59/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=7ec72efe10df28fcf5c6ec13c2a487572041be59", "patch": "@@ -210,7 +210,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // and we want to keep inference generally in the same order of\n             // the registered obligations.\n             predicates.rev(),\n-        ) {\n+        )\n+        // We only care about self bounds\n+        .filter_only_self()\n+        {\n             debug!(?pred);\n             let bound_predicate = pred.kind();\n "}, {"sha": "ef01d5d513bbc456a95df15a7976d2adbb0b8af3", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7ec72efe10df28fcf5c6ec13c2a487572041be59/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec72efe10df28fcf5c6ec13c2a487572041be59/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=7ec72efe10df28fcf5c6ec13c2a487572041be59", "patch": "@@ -69,6 +69,7 @@ impl<'tcx> Extend<ty::Predicate<'tcx>> for PredicateSet<'tcx> {\n pub struct Elaborator<'tcx, O> {\n     stack: Vec<O>,\n     visited: PredicateSet<'tcx>,\n+    only_self: bool,\n }\n \n /// Describes how to elaborate an obligation into a sub-obligation.\n@@ -170,7 +171,8 @@ pub fn elaborate<'tcx, O: Elaboratable<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n     obligations: impl IntoIterator<Item = O>,\n ) -> Elaborator<'tcx, O> {\n-    let mut elaborator = Elaborator { stack: Vec::new(), visited: PredicateSet::new(tcx) };\n+    let mut elaborator =\n+        Elaborator { stack: Vec::new(), visited: PredicateSet::new(tcx), only_self: false };\n     elaborator.extend_deduped(obligations);\n     elaborator\n }\n@@ -185,14 +187,25 @@ impl<'tcx, O: Elaboratable<'tcx>> Elaborator<'tcx, O> {\n         self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate())));\n     }\n \n+    /// Filter to only the supertraits of trait predicates, i.e. only the predicates\n+    /// that have `Self` as their self type, instead of all implied predicates.\n+    pub fn filter_only_self(mut self) -> Self {\n+        self.only_self = true;\n+        self\n+    }\n+\n     fn elaborate(&mut self, elaboratable: &O) {\n         let tcx = self.visited.tcx;\n \n         let bound_predicate = elaboratable.predicate().kind();\n         match bound_predicate.skip_binder() {\n             ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n-                // Get predicates declared on the trait.\n-                let predicates = tcx.implied_predicates_of(data.def_id());\n+                // Get predicates implied by the trait, or only super predicates if we only care about self predicates.\n+                let predicates = if self.only_self {\n+                    tcx.super_predicates_of(data.def_id())\n+                } else {\n+                    tcx.implied_predicates_of(data.def_id())\n+                };\n \n                 let obligations =\n                     predicates.predicates.iter().enumerate().map(|(index, &(mut pred, span))| {\n@@ -350,18 +363,16 @@ pub fn supertraits<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n ) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n-    let pred: ty::Predicate<'tcx> = trait_ref.to_predicate(tcx);\n-    FilterToTraits::new(elaborate(tcx, [pred]))\n+    elaborate(tcx, [trait_ref.to_predicate(tcx)]).filter_only_self().filter_to_traits()\n }\n \n pub fn transitive_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n ) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n-    FilterToTraits::new(elaborate(\n-        tcx,\n-        trait_refs.map(|trait_ref| -> ty::Predicate<'tcx> { trait_ref.to_predicate(tcx) }),\n-    ))\n+    elaborate(tcx, trait_refs.map(|trait_ref| trait_ref.to_predicate(tcx)))\n+        .filter_only_self()\n+        .filter_to_traits()\n }\n \n /// A specialized variant of `elaborate` that only elaborates trait references that may\n@@ -402,18 +413,18 @@ pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n // Other\n ///////////////////////////////////////////////////////////////////////////\n \n+impl<'tcx> Elaborator<'tcx, ty::Predicate<'tcx>> {\n+    fn filter_to_traits(self) -> FilterToTraits<Self> {\n+        FilterToTraits { base_iterator: self }\n+    }\n+}\n+\n /// A filter around an iterator of predicates that makes it yield up\n /// just trait references.\n pub struct FilterToTraits<I> {\n     base_iterator: I,\n }\n \n-impl<I> FilterToTraits<I> {\n-    fn new(base: I) -> FilterToTraits<I> {\n-        FilterToTraits { base_iterator: base }\n-    }\n-}\n-\n impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     type Item = ty::PolyTraitRef<'tcx>;\n "}, {"sha": "1159d11e5c0c8411f7a8089fcaac4c43e9a448e0", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ec72efe10df28fcf5c6ec13c2a487572041be59/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec72efe10df28fcf5c6ec13c2a487572041be59/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=7ec72efe10df28fcf5c6ec13c2a487572041be59", "patch": "@@ -255,6 +255,8 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                 ty::Adt(def, _) => is_def_must_use(cx, def.did(), span),\n                 ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n                     elaborate(cx.tcx, cx.tcx.explicit_item_bounds(def).iter().cloned())\n+                        // We only care about self bounds for the impl-trait\n+                        .filter_only_self()\n                         .find_map(|(pred, _span)| {\n                             // We only look at the `DefId`, so it is safe to skip the binder here.\n                             if let ty::PredicateKind::Clause(ty::Clause::Trait("}, {"sha": "3fb1d49b33808bb2b21be3ac6a2089897e1e3ac6", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ec72efe10df28fcf5c6ec13c2a487572041be59/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec72efe10df28fcf5c6ec13c2a487572041be59/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=7ec72efe10df28fcf5c6ec13c2a487572041be59", "patch": "@@ -498,7 +498,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let tcx = self.tcx();\n         let own_bounds: FxIndexSet<_> =\n             bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)).collect();\n-        for assumption in elaborate(tcx, own_bounds.iter().copied()) {\n+        for assumption in elaborate(tcx, own_bounds.iter().copied())\n+            // we only care about bounds that match the `Self` type\n+            .filter_only_self()\n+        {\n             // FIXME: Predicates are fully elaborated in the object type's existential bounds\n             // list. We want to only consider these pre-elaborated projections, and not other\n             // projection predicates that we reach by elaborating the principal trait ref,"}, {"sha": "247a4f8128073a0a8b487babc3e7f204b6b569cf", "filename": "tests/ui/traits/alias/dont-elaborate-non-self.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7ec72efe10df28fcf5c6ec13c2a487572041be59/tests%2Fui%2Ftraits%2Falias%2Fdont-elaborate-non-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ec72efe10df28fcf5c6ec13c2a487572041be59/tests%2Fui%2Ftraits%2Falias%2Fdont-elaborate-non-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Falias%2Fdont-elaborate-non-self.stderr?ref=7ec72efe10df28fcf5c6ec13c2a487572041be59", "patch": "@@ -0,0 +1,20 @@\n+error[E0277]: the size for values of type `(dyn Fn() -> Fut + 'static)` cannot be known at compilation time\n+  --> $DIR/dont-elaborate-non-self.rs:7:11\n+   |\n+LL | fn f<Fut>(a: dyn F<Fut>) {}\n+   |           ^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `(dyn Fn() -> Fut + 'static)`\n+   = help: unsized fn params are gated as an unstable feature\n+help: you can use `impl Trait` as the argument type\n+   |\n+LL | fn f<Fut>(a: impl F<Fut>) {}\n+   |              ~~~~\n+help: function arguments must have a statically known size, borrowed types always have a known size\n+   |\n+LL | fn f<Fut>(a: &dyn F<Fut>) {}\n+   |              +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "5574a0320895e0bd28c9c41eafdea51d468a7567", "filename": "tests/ui/traits/trait-upcasting/alias-where-clause-isnt-supertrait.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ec72efe10df28fcf5c6ec13c2a487572041be59/tests%2Fui%2Ftraits%2Ftrait-upcasting%2Falias-where-clause-isnt-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ec72efe10df28fcf5c6ec13c2a487572041be59/tests%2Fui%2Ftraits%2Ftrait-upcasting%2Falias-where-clause-isnt-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Ftrait-upcasting%2Falias-where-clause-isnt-supertrait.stderr?ref=7ec72efe10df28fcf5c6ec13c2a487572041be59", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/alias-where-clause-isnt-supertrait.rs:27:5\n+   |\n+LL | fn test(x: &dyn C) -> &dyn B {\n+   |                       ------ expected `&dyn B` because of return type\n+LL |     x\n+   |     ^ expected trait `B`, found trait `C`\n+   |\n+   = note: expected reference `&dyn B`\n+              found reference `&dyn C`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}