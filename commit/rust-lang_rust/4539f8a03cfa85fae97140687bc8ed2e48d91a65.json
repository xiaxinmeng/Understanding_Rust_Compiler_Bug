{"sha": "4539f8a03cfa85fae97140687bc8ed2e48d91a65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MzlmOGEwM2NmYTg1ZmFlOTcxNDA2ODdiYzhlZDJlNDhkOTFhNjU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-10T00:49:19Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-10T00:50:06Z"}, "message": "Alias-ify fold and its users, remove another 85kb.", "tree": {"sha": "f2ec0e7aec963b1ed58304567b30d0c7bc8494ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2ec0e7aec963b1ed58304567b30d0c7bc8494ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4539f8a03cfa85fae97140687bc8ed2e48d91a65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4539f8a03cfa85fae97140687bc8ed2e48d91a65", "html_url": "https://github.com/rust-lang/rust/commit/4539f8a03cfa85fae97140687bc8ed2e48d91a65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4539f8a03cfa85fae97140687bc8ed2e48d91a65/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfcc8678e5f734c85c02004331757ee9c1f737a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfcc8678e5f734c85c02004331757ee9c1f737a0", "html_url": "https://github.com/rust-lang/rust/commit/cfcc8678e5f734c85c02004331757ee9c1f737a0"}], "stats": {"total": 735, "additions": 378, "deletions": 357}, "files": [{"sha": "832ef13182f4a88b309687e88ab9dd5c1298aeba", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4539f8a03cfa85fae97140687bc8ed2e48d91a65/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4539f8a03cfa85fae97140687bc8ed2e48d91a65/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=4539f8a03cfa85fae97140687bc8ed2e48d91a65", "patch": "@@ -441,9 +441,10 @@ fn load_crate(session.session sess,\n     fail;\n }\n \n-fn fold_view_item_use(&env e, &span sp, ast.ident ident,\n-        vec[@ast.meta_item] meta_items, ast.def_id id, Option.t[int] cnum_opt)\n-        -> @ast.view_item {\n+fn fold_view_item_use(&env e, &span sp, &ast.ident ident,\n+                      &vec[@ast.meta_item] meta_items,\n+                      &ast.def_id id, &Option.t[int] cnum_opt)\n+    -> @ast.view_item {\n     auto cnum;\n     if (!e.crate_cache.contains_key(ident)) {\n         cnum = e.next_crate_num;"}, {"sha": "3afa9ef676da8dc6083317953ead1f8ac23de9d7", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 297, "deletions": 279, "changes": 576, "blob_url": "https://github.com/rust-lang/rust/blob/4539f8a03cfa85fae97140687bc8ed2e48d91a65/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4539f8a03cfa85fae97140687bc8ed2e48d91a65/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=4539f8a03cfa85fae97140687bc8ed2e48d91a65", "patch": "@@ -39,7 +39,7 @@ type ast_fold[ENV] =\n     @rec\n     (\n      // Path fold.\n-     (fn(&ENV e, &span sp, ast.path_ p) -> path)  fold_path,\n+     (fn(&ENV e, &span sp, &ast.path_ p) -> path) fold_path,\n \n      // Type folds.\n      (fn(&ENV e, &span sp) -> @ty)                fold_ty_nil,\n@@ -53,246 +53,252 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp, &mt tm) -> @ty)        fold_ty_box,\n      (fn(&ENV e, &span sp, &mt tm) -> @ty)        fold_ty_vec,\n \n-     (fn(&ENV e, &span sp, vec[mt] elts) -> @ty)  fold_ty_tup,\n+     (fn(&ENV e, &span sp, &vec[mt] elts) -> @ty) fold_ty_tup,\n \n      (fn(&ENV e, &span sp,\n-         vec[ast.ty_field] elts) -> @ty)          fold_ty_rec,\n+         &vec[ast.ty_field] elts) -> @ty)         fold_ty_rec,\n \n      (fn(&ENV e, &span sp,\n-         vec[ast.ty_method] meths) -> @ty)        fold_ty_obj,\n+         &vec[ast.ty_method] meths) -> @ty)       fold_ty_obj,\n \n      (fn(&ENV e, &span sp,\n          ast.proto proto,\n-         vec[rec(ast.mode mode, @ty ty)] inputs,\n-         @ty output) -> @ty)                      fold_ty_fn,\n+         &vec[rec(ast.mode mode, @ty ty)] inputs,\n+         &@ty output) -> @ty)                     fold_ty_fn,\n \n-     (fn(&ENV e, &span sp, ast.path p,\n+     (fn(&ENV e, &span sp, &ast.path p,\n          &Option.t[def] d) -> @ty)                fold_ty_path,\n \n-     (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_chan,\n-     (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_port,\n+     (fn(&ENV e, &span sp, &@ty t) -> @ty)        fold_ty_chan,\n+     (fn(&ENV e, &span sp, &@ty t) -> @ty)        fold_ty_port,\n \n      // Expr folds.\n      (fn(&ENV e, &span sp,\n-         vec[@expr] es, ast.mutability mut,\n-         ann a) -> @expr)                         fold_expr_vec,\n+         &vec[@expr] es, ast.mutability mut,\n+         &ann a) -> @expr)                        fold_expr_vec,\n \n      (fn(&ENV e, &span sp,\n-         vec[ast.elt] es, ann a) -> @expr)        fold_expr_tup,\n+         &vec[ast.elt] es, &ann a) -> @expr)      fold_expr_tup,\n \n      (fn(&ENV e, &span sp,\n-         vec[ast.field] fields,\n-         Option.t[@expr] base, ann a) -> @expr)   fold_expr_rec,\n+         &vec[ast.field] fields,\n+         &Option.t[@expr] base, &ann a) -> @expr) fold_expr_rec,\n \n      (fn(&ENV e, &span sp,\n-         @expr f, vec[@expr] args,\n-         ann a) -> @expr)                         fold_expr_call,\n+         &@expr f, &vec[@expr] args,\n+         &ann a) -> @expr)                        fold_expr_call,\n \n      (fn(&ENV e, &span sp,\n-         ident id, ann a) -> @expr)               fold_expr_self_method,\n+         &ident id, &ann a) -> @expr)             fold_expr_self_method,\n \n      (fn(&ENV e, &span sp,\n-         @expr f, vec[Option.t[@expr]] args,\n-         ann a) -> @expr)                         fold_expr_bind,\n+         &@expr f, &vec[Option.t[@expr]] args,\n+         &ann a) -> @expr)                        fold_expr_bind,\n \n      (fn(&ENV e, &span sp,\n-         ast.spawn_dom dom, Option.t[str] name,\n-         @expr f, vec[@expr] args,\n-         ann a) -> @expr)                         fold_expr_spawn,\n+         ast.spawn_dom dom, &Option.t[str] name,\n+         &@expr f, &vec[@expr] args,\n+         &ann a) -> @expr)                        fold_expr_spawn,\n \n      (fn(&ENV e, &span sp,\n          ast.binop,\n-         @expr lhs, @expr rhs,\n-         ann a) -> @expr)                         fold_expr_binary,\n+         &@expr lhs, &@expr rhs,\n+         &ann a) -> @expr)                        fold_expr_binary,\n \n      (fn(&ENV e, &span sp,\n-         ast.unop, @expr e,\n-         ann a) -> @expr)                         fold_expr_unary,\n+         ast.unop, &@expr e,\n+         &ann a) -> @expr)                        fold_expr_unary,\n \n      (fn(&ENV e, &span sp,\n-         @ast.lit, ann a) -> @expr)               fold_expr_lit,\n+         &@ast.lit, &ann a) -> @expr)             fold_expr_lit,\n \n      (fn(&ENV e, &span sp,\n-         @ast.expr e, @ast.ty ty,\n-         ann a) -> @expr)                         fold_expr_cast,\n+         &@ast.expr e, &@ast.ty ty,\n+         &ann a) -> @expr)                        fold_expr_cast,\n \n      (fn(&ENV e, &span sp,\n-         @expr cond, &block thn,\n+         &@expr cond, &block thn,\n          &Option.t[@expr] els,\n-         ann a) -> @expr)                         fold_expr_if,\n+         &ann a) -> @expr)                        fold_expr_if,\n \n      (fn(&ENV e, &span sp,\n-         @decl decl, @expr seq, &block body,\n-         ann a) -> @expr)                         fold_expr_for,\n+         &@decl decl, &@expr seq, &block body,\n+         &ann a) -> @expr)                        fold_expr_for,\n \n      (fn(&ENV e, &span sp,\n-         @decl decl, @expr seq, &block body,\n-         ann a) -> @expr)                         fold_expr_for_each,\n+         &@decl decl, &@expr seq, &block body,\n+         &ann a) -> @expr)                        fold_expr_for_each,\n \n      (fn(&ENV e, &span sp,\n-         @expr cond, &block body,\n-         ann a) -> @expr)                         fold_expr_while,\n+         &@expr cond, &block body,\n+         &ann a) -> @expr)                        fold_expr_while,\n \n      (fn(&ENV e, &span sp,\n-         &block body, @expr cond,\n-         ann a) -> @expr)                         fold_expr_do_while,\n+         &block body, &@expr cond,\n+         &ann a) -> @expr)                        fold_expr_do_while,\n \n      (fn(&ENV e, &span sp,\n-         @expr e, vec[arm] arms,\n-         ann a) -> @expr)                         fold_expr_alt,\n+         &@expr e, &vec[arm] arms,\n+         &ann a) -> @expr)                        fold_expr_alt,\n \n      (fn(&ENV e, &span sp,\n-         &block blk, ann a) -> @expr)             fold_expr_block,\n+         &block blk, &ann a) -> @expr)            fold_expr_block,\n \n      (fn(&ENV e, &span sp,\n-         @expr lhs, @expr rhs,\n-         ann a) -> @expr)                         fold_expr_assign,\n+         &@expr lhs, &@expr rhs,\n+         &ann a) -> @expr)                        fold_expr_assign,\n \n      (fn(&ENV e, &span sp,\n          ast.binop,\n-         @expr lhs, @expr rhs,\n-         ann a) -> @expr)                         fold_expr_assign_op,\n+         &@expr lhs, &@expr rhs,\n+         &ann a) -> @expr)                        fold_expr_assign_op,\n \n      (fn(&ENV e, &span sp,\n-         @expr lhs, @expr rhs, ann a) -> @expr)   fold_expr_send,\n+         &@expr lhs, &@expr rhs,\n+         &ann a) -> @expr)                        fold_expr_send,\n \n      (fn(&ENV e, &span sp,\n-         @expr lhs, @expr rhs, ann a) -> @expr)   fold_expr_recv,\n+         &@expr lhs, &@expr rhs,\n+         &ann a) -> @expr)                        fold_expr_recv,\n \n      (fn(&ENV e, &span sp,\n-         @expr e, ident i,\n-         ann a) -> @expr)                         fold_expr_field,\n+         &@expr e, &ident i,\n+         &ann a) -> @expr)                        fold_expr_field,\n \n      (fn(&ENV e, &span sp,\n-         @expr e, @expr ix,\n-         ann a) -> @expr)                         fold_expr_index,\n+         &@expr e, &@expr ix,\n+         &ann a) -> @expr)                        fold_expr_index,\n \n      (fn(&ENV e, &span sp,\n          &path p,\n          &Option.t[def] d,\n-         ann a) -> @expr)                         fold_expr_path,\n+         &ann a) -> @expr)                        fold_expr_path,\n \n      (fn(&ENV e, &span sp,\n-         &path p, vec[@expr] args,\n-         Option.t[str] body,\n-         @expr expanded,\n-         ann a) -> @expr)                         fold_expr_ext,\n+         &path p, &vec[@expr] args,\n+         &Option.t[str] body,\n+         &@expr expanded,\n+         &ann a) -> @expr)                        fold_expr_ext,\n \n-     (fn(&ENV e, &span sp, ann a) -> @expr)       fold_expr_fail,\n+     (fn(&ENV e, &span sp, &ann a) -> @expr)      fold_expr_fail,\n \n-     (fn(&ENV e, &span sp, ann a) -> @expr)       fold_expr_break,\n+     (fn(&ENV e, &span sp, &ann a) -> @expr)      fold_expr_break,\n \n-     (fn(&ENV e, &span sp, ann a) -> @expr)       fold_expr_cont,\n+     (fn(&ENV e, &span sp, &ann a) -> @expr)      fold_expr_cont,\n \n      (fn(&ENV e, &span sp,\n-         &Option.t[@expr] rv, ann a) -> @expr)    fold_expr_ret,\n+         &Option.t[@expr] rv, &ann a) -> @expr)   fold_expr_ret,\n \n      (fn(&ENV e, &span sp,\n-         &Option.t[@expr] rv, ann a) -> @expr)    fold_expr_put,\n+         &Option.t[@expr] rv, &ann a) -> @expr)   fold_expr_put,\n \n      (fn(&ENV e, &span sp,\n-         @expr e, ann a) -> @expr)                fold_expr_be,\n+         &@expr e, &ann a) -> @expr)              fold_expr_be,\n \n      (fn(&ENV e, &span sp, int lvl,\n-         @expr e, ann a) -> @expr)                fold_expr_log,\n+         &@expr e, &ann a) -> @expr)              fold_expr_log,\n \n      (fn(&ENV e, &span sp,\n-         @expr e, ann a) -> @expr)                fold_expr_check,\n+         &@expr e, &ann a) -> @expr)              fold_expr_check,\n \n      (fn(&ENV e, &span sp,\n-         @expr e, ann a) -> @expr)                fold_expr_assert,\n+         &@expr e, &ann a) -> @expr)              fold_expr_assert,\n \n      (fn(&ENV e, &span sp,\n-         ann a) -> @expr)                         fold_expr_port,\n+         &ann a) -> @expr)                        fold_expr_port,\n \n      (fn(&ENV e, &span sp,\n-         @expr e, ann a) -> @expr)                fold_expr_chan,\n+         &@expr e, &ann a) -> @expr)              fold_expr_chan,\n \n \n      // Decl folds.\n      (fn(&ENV e, &span sp,\n-         @ast.local local) -> @decl)              fold_decl_local,\n+         &@ast.local local) -> @decl)             fold_decl_local,\n \n      (fn(&ENV e, &span sp,\n-         @item item) -> @decl)                    fold_decl_item,\n+         &@item item) -> @decl)                   fold_decl_item,\n \n \n      // Pat folds.\n      (fn(&ENV e, &span sp,\n-         ann a) -> @pat)                          fold_pat_wild,\n+         &ann a) -> @pat)                         fold_pat_wild,\n \n      (fn(&ENV e, &span sp,\n-         @ast.lit lit, ann a) -> @pat)            fold_pat_lit,\n+         &@ast.lit lit, &ann a) -> @pat)          fold_pat_lit,\n \n      (fn(&ENV e, &span sp,\n-         ident i, def_id did, ann a) -> @pat)     fold_pat_bind,\n+         &ident i, &def_id did, &ann a) -> @pat)  fold_pat_bind,\n \n      (fn(&ENV e, &span sp,\n-         path p, vec[@pat] args,\n-         Option.t[ast.variant_def] d,\n-         ann a) -> @pat)                          fold_pat_tag,\n+         &path p, &vec[@pat] args,\n+         &Option.t[ast.variant_def] d,\n+         &ann a) -> @pat)                         fold_pat_tag,\n \n \n      // Stmt folds.\n      (fn(&ENV e, &span sp,\n-         @decl decl, ann a)\n+         &@decl decl, &ann a)\n       -> @stmt)                                   fold_stmt_decl,\n \n      (fn(&ENV e, &span sp,\n-         @expr e, ann a)\n+         &@expr e, &ann a)\n       -> @stmt)                                   fold_stmt_expr,\n \n      // Item folds.\n-     (fn(&ENV e, &span sp, ident ident,\n-         @ty t, @expr e,\n-         def_id id, ann a) -> @item)              fold_item_const,\n+     (fn(&ENV e, &span sp, &ident ident,\n+         &@ty t, &@expr e,\n+         &def_id id, &ann a) -> @item)            fold_item_const,\n \n-     (fn(&ENV e, &span sp, ident ident,\n+     (fn(&ENV e, &span sp, &ident ident,\n          &ast._fn f,\n-         vec[ast.ty_param] ty_params,\n-         def_id id, ann a) -> @item)              fold_item_fn,\n+         &vec[ast.ty_param] ty_params,\n+         &def_id id, &ann a) -> @item)            fold_item_fn,\n \n-     (fn(&ENV e, &span sp, ident ident,\n-         Option.t[str] link_name,\n+     (fn(&ENV e, &span sp, &ident ident,\n+         &Option.t[str] link_name,\n          &ast.fn_decl decl,\n-         vec[ast.ty_param] ty_params,\n-         def_id id, ann a) -> @native_item)       fold_native_item_fn,\n+         &vec[ast.ty_param] ty_params,\n+         &def_id id, &ann a) -> @native_item)     fold_native_item_fn,\n \n-     (fn(&ENV e, &span sp, ident ident,\n-         &ast._mod m, def_id id) -> @item)        fold_item_mod,\n+     (fn(&ENV e, &span sp, &ident ident,\n+         &ast._mod m, &def_id id) -> @item)       fold_item_mod,\n \n-     (fn(&ENV e, &span sp, ident ident,\n-         &ast.native_mod m, def_id id) -> @item)  fold_item_native_mod,\n+     (fn(&ENV e, &span sp, &ident ident,\n+         &ast.native_mod m, &def_id id) -> @item) fold_item_native_mod,\n \n-     (fn(&ENV e, &span sp, ident ident,\n-         @ty t, vec[ast.ty_param] ty_params,\n-         def_id id, ann a) -> @item)              fold_item_ty,\n+     (fn(&ENV e, &span sp, &ident ident,\n+         &@ty t, &vec[ast.ty_param] ty_params,\n+         &def_id id, &ann a) -> @item)            fold_item_ty,\n \n-     (fn(&ENV e, &span sp, ident ident,\n-         def_id id) -> @native_item)              fold_native_item_ty,\n+     (fn(&ENV e, &span sp, &ident ident,\n+         &def_id id) -> @native_item)             fold_native_item_ty,\n \n-     (fn(&ENV e, &span sp, ident ident,\n-         vec[ast.variant] variants,\n-         vec[ast.ty_param] ty_params,\n-         def_id id, ann a) -> @item)              fold_item_tag,\n+     (fn(&ENV e, &span sp, &ident ident,\n+         &vec[ast.variant] variants,\n+         &vec[ast.ty_param] ty_params,\n+         &def_id id, &ann a) -> @item)            fold_item_tag,\n \n-     (fn(&ENV e, &span sp, ident ident,\n+     (fn(&ENV e, &span sp, &ident ident,\n          &ast._obj ob,\n-         vec[ast.ty_param] ty_params,\n-         ast.obj_def_ids odid, ann a) -> @item)   fold_item_obj,\n+         &vec[ast.ty_param] ty_params,\n+         &ast.obj_def_ids odid, &ann a) -> @item) fold_item_obj,\n \n      // View Item folds.\n-     (fn(&ENV e, &span sp, ident ident,\n-         vec[@meta_item] meta_items,\n-         def_id id, Option.t[int]) -> @view_item) fold_view_item_use,\n+     (fn(&ENV e, &span sp, &ident ident,\n+         &vec[@meta_item] meta_items,\n+         &def_id id,\n+         &Option.t[int]) -> @view_item)           fold_view_item_use,\n \n-     (fn(&ENV e, &span sp, ident i, vec[ident] idents,\n-         def_id id, Option.t[def]) -> @view_item) fold_view_item_import,\n+     (fn(&ENV e, &span sp, &ident i,\n+         &vec[ident] idents,\n+         &def_id id,\n+         &Option.t[def]) -> @view_item)           fold_view_item_import,\n \n-     (fn(&ENV e, &span sp, ident i) -> @view_item) fold_view_item_export,\n+     (fn(&ENV e, &span sp,\n+         &ident i) -> @view_item)                 fold_view_item_export,\n \n      // Annotation folds.\n-     (fn(&ENV e, ann a) -> ann)                   fold_ann,\n+     (fn(&ENV e, &ann a) -> ann)                  fold_ann,\n \n      // Additional nodes.\n \n@@ -301,35 +307,36 @@ type ast_fold[ENV] =\n          &block body) -> ast._fn)                 fold_fn,\n \n      (fn(&ENV e,\n-         vec[arg] inputs,\n-         @ty output,\n-         purity p) -> ast.fn_decl)                fold_fn_decl,\n+         &vec[arg] inputs,\n+         &@ty output,\n+         &purity p) -> ast.fn_decl)               fold_fn_decl,\n \n      (fn(&ENV e, &ast._mod m) -> ast._mod)        fold_mod,\n \n      (fn(&ENV e, &ast.native_mod m) -> ast.native_mod) fold_native_mod,\n \n      (fn(&ENV e, &span sp,\n-         vec[@ast.crate_directive] cdirs,\n+         &vec[@ast.crate_directive] cdirs,\n          &ast._mod m) -> @ast.crate)              fold_crate,\n \n      (fn(&ENV e,\n-         vec[ast.obj_field] fields,\n-         vec[@ast.method] methods,\n-         Option.t[@ast.method] dtor) -> ast._obj) fold_obj,\n+         &vec[ast.obj_field] fields,\n+         &vec[@ast.method] methods,\n+         &Option.t[@ast.method] dtor)\n+      -> ast._obj)                                fold_obj,\n \n      // Env updates.\n-     (fn(&ENV e, @ast.crate c) -> ENV) update_env_for_crate,\n-     (fn(&ENV e, @item i) -> ENV) update_env_for_item,\n-     (fn(&ENV e, @native_item i) -> ENV) update_env_for_native_item,\n-     (fn(&ENV e, @view_item i) -> ENV) update_env_for_view_item,\n+     (fn(&ENV e, &@ast.crate c) -> ENV) update_env_for_crate,\n+     (fn(&ENV e, &@item i) -> ENV) update_env_for_item,\n+     (fn(&ENV e, &@native_item i) -> ENV) update_env_for_native_item,\n+     (fn(&ENV e, &@view_item i) -> ENV) update_env_for_view_item,\n      (fn(&ENV e, &block b) -> ENV) update_env_for_block,\n-     (fn(&ENV e, @stmt s) -> ENV) update_env_for_stmt,\n-     (fn(&ENV e, @decl i) -> ENV) update_env_for_decl,\n-     (fn(&ENV e, @pat p) -> ENV) update_env_for_pat,\n+     (fn(&ENV e, &@stmt s) -> ENV) update_env_for_stmt,\n+     (fn(&ENV e, &@decl i) -> ENV) update_env_for_decl,\n+     (fn(&ENV e, &@pat p) -> ENV) update_env_for_pat,\n      (fn(&ENV e, &arm a) -> ENV) update_env_for_arm,\n-     (fn(&ENV e, @expr x) -> ENV) update_env_for_expr,\n-     (fn(&ENV e, @ty t) -> ENV) update_env_for_ty,\n+     (fn(&ENV e, &@expr x) -> ENV) update_env_for_expr,\n+     (fn(&ENV e, &@ty t) -> ENV) update_env_for_ty,\n \n      // Traversal control.\n      (fn(&ENV v) -> bool) keep_going\n@@ -338,7 +345,7 @@ type ast_fold[ENV] =\n \n //// Fold drivers.\n \n-fn fold_path[ENV](&ENV env, ast_fold[ENV] fld, &path p) -> path {\n+fn fold_path[ENV](&ENV env, &ast_fold[ENV] fld, &path p) -> path {\n     let vec[@ast.ty] tys_ = vec();\n     for (@ast.ty t in p.node.types) {\n         Vec.push[@ast.ty](tys_, fold_ty(env, fld, t));\n@@ -347,7 +354,7 @@ fn fold_path[ENV](&ENV env, ast_fold[ENV] fld, &path p) -> path {\n     ret fld.fold_path(env, p.span, p_);\n }\n \n-fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n+fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n     let ENV env_ = fld.update_env_for_ty(env, t);\n \n     if (!fld.keep_going(env_)) {\n@@ -434,10 +441,10 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n     }\n }\n \n-fn fold_ty_fn[ENV](&ENV env, ast_fold[ENV] fld, &span sp,\n+fn fold_ty_fn[ENV](&ENV env, &ast_fold[ENV] fld, &span sp,\n                    ast.proto proto,\n-                   vec[rec(ast.mode mode, @ty ty)] inputs,\n-                   @ty output) -> @ty {\n+                   &vec[rec(ast.mode mode, @ty ty)] inputs,\n+                   &@ty output) -> @ty {\n     auto output_ = fold_ty(env, fld, output);\n     let vec[rec(ast.mode mode, @ty ty)] inputs_ = vec();\n     for (rec(ast.mode mode, @ty ty) input in inputs) {\n@@ -448,7 +455,7 @@ fn fold_ty_fn[ENV](&ENV env, ast_fold[ENV] fld, &span sp,\n     ret fld.fold_ty_fn(env, sp, proto, inputs_, output_);\n }\n \n-fn fold_decl[ENV](&ENV env, ast_fold[ENV] fld, @decl d) -> @decl {\n+fn fold_decl[ENV](&ENV env, &ast_fold[ENV] fld, &@decl d) -> @decl {\n     let ENV env_ = fld.update_env_for_decl(env, d);\n \n     if (!fld.keep_going(env_)) {\n@@ -487,7 +494,7 @@ fn fold_decl[ENV](&ENV env, ast_fold[ENV] fld, @decl d) -> @decl {\n     fail;\n }\n \n-fn fold_pat[ENV](&ENV env, ast_fold[ENV] fld, @ast.pat p) -> @ast.pat {\n+fn fold_pat[ENV](&ENV env, &ast_fold[ENV] fld, &@ast.pat p) -> @ast.pat {\n     let ENV env_ = fld.update_env_for_pat(env, p);\n \n     if (!fld.keep_going(env_)) {\n@@ -515,24 +522,25 @@ fn fold_pat[ENV](&ENV env, ast_fold[ENV] fld, @ast.pat p) -> @ast.pat {\n     }\n }\n \n-fn fold_exprs[ENV](&ENV env, ast_fold[ENV] fld, vec[@expr] es) -> vec[@expr] {\n+fn fold_exprs[ENV](&ENV env, &ast_fold[ENV] fld,\n+                   &vec[@expr] es) -> vec[@expr] {\n     let vec[@expr] exprs = vec();\n     for (@expr e in es) {\n         Vec.push[@expr](exprs, fold_expr(env, fld, e));\n     }\n     ret exprs;\n }\n \n-fn fold_tup_elt[ENV](&ENV env, ast_fold[ENV] fld, &ast.elt e) -> ast.elt {\n+fn fold_tup_elt[ENV](&ENV env, &ast_fold[ENV] fld, &ast.elt e) -> ast.elt {\n     ret rec(expr=fold_expr(env, fld, e.expr) with e);\n }\n \n-fn fold_rec_field[ENV](&ENV env, ast_fold[ENV] fld, &ast.field f)\n+fn fold_rec_field[ENV](&ENV env, &ast_fold[ENV] fld, &ast.field f)\n     -> ast.field {\n     ret rec(expr=fold_expr(env, fld, f.expr) with f);\n }\n \n-fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n+fn fold_expr[ENV](&ENV env, &ast_fold[ENV] fld, &@expr e) -> @expr {\n \n     let ENV env_ = fld.update_env_for_expr(env, e);\n \n@@ -829,7 +837,7 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n }\n \n \n-fn fold_stmt[ENV](&ENV env, ast_fold[ENV] fld, &@stmt s) -> @stmt {\n+fn fold_stmt[ENV](&ENV env, &ast_fold[ENV] fld, &@stmt s) -> @stmt {\n \n     let ENV env_ = fld.update_env_for_stmt(env, s);\n \n@@ -853,7 +861,7 @@ fn fold_stmt[ENV](&ENV env, ast_fold[ENV] fld, &@stmt s) -> @stmt {\n     fail;\n }\n \n-fn fold_block[ENV](&ENV env, ast_fold[ENV] fld, &block blk) -> block {\n+fn fold_block[ENV](&ENV env, &ast_fold[ENV] fld, &block blk) -> block {\n \n     auto index = new_str_hash[ast.block_index_entry]();\n     let ENV env_ = fld.update_env_for_block(env, blk);\n@@ -879,23 +887,23 @@ fn fold_block[ENV](&ENV env, ast_fold[ENV] fld, &block blk) -> block {\n         }\n     }\n \n-    auto aa = fld.fold_ann(env, blk.node.a); \n+    auto aa = fld.fold_ann(env, blk.node.a);\n     ret respan(blk.span, rec(stmts=stmts, expr=expr, index=index, a=aa));\n }\n \n-fn fold_arm[ENV](&ENV env, ast_fold[ENV] fld, &arm a) -> arm {\n+fn fold_arm[ENV](&ENV env, &ast_fold[ENV] fld, &arm a) -> arm {\n     let ENV env_ = fld.update_env_for_arm(env, a);\n     auto ppat = fold_pat(env_, fld, a.pat);\n     auto bblock = fold_block(env_, fld, a.block);\n     ret rec(pat=ppat, block=bblock, index=a.index);\n }\n \n-fn fold_arg[ENV](&ENV env, ast_fold[ENV] fld, &arg a) -> arg {\n+fn fold_arg[ENV](&ENV env, &ast_fold[ENV] fld, &arg a) -> arg {\n     auto ty = fold_ty(env, fld, a.ty);\n     ret rec(ty=ty with a);\n }\n \n-fn fold_fn_decl[ENV](&ENV env, ast_fold[ENV] fld,\n+fn fold_fn_decl[ENV](&ENV env, &ast_fold[ENV] fld,\n                      &ast.fn_decl decl) -> ast.fn_decl {\n     let vec[ast.arg] inputs = vec();\n     for (ast.arg a in decl.inputs) {\n@@ -905,7 +913,7 @@ fn fold_fn_decl[ENV](&ENV env, ast_fold[ENV] fld,\n     ret fld.fold_fn_decl(env, inputs, output, decl.purity);\n }\n \n-fn fold_fn[ENV](&ENV env, ast_fold[ENV] fld, &ast._fn f) -> ast._fn {\n+fn fold_fn[ENV](&ENV env, &ast_fold[ENV] fld, &ast._fn f) -> ast._fn {\n     auto decl = fold_fn_decl(env, fld, f.decl);\n \n     auto body = fold_block[ENV](env, fld, f.body);\n@@ -914,21 +922,21 @@ fn fold_fn[ENV](&ENV env, ast_fold[ENV] fld, &ast._fn f) -> ast._fn {\n }\n \n \n-fn fold_obj_field[ENV](&ENV env, ast_fold[ENV] fld,\n+fn fold_obj_field[ENV](&ENV env, &ast_fold[ENV] fld,\n                        &ast.obj_field f) -> ast.obj_field {\n     auto ty = fold_ty(env, fld, f.ty);\n     ret rec(ty=ty with f);\n }\n \n \n-fn fold_method[ENV](&ENV env, ast_fold[ENV] fld,\n-                    @ast.method m) -> @ast.method {\n+fn fold_method[ENV](&ENV env, &ast_fold[ENV] fld,\n+                    &@ast.method m) -> @ast.method {\n     auto meth = fold_fn(env, fld, m.node.meth);\n     ret @rec(node=rec(meth=meth with m.node) with *m);\n }\n \n \n-fn fold_obj[ENV](&ENV env, ast_fold[ENV] fld, &ast._obj ob) -> ast._obj {\n+fn fold_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast._obj ob) -> ast._obj {\n \n     let vec[ast.obj_field] fields = vec();\n     let vec[@ast.method] meths = vec();\n@@ -959,7 +967,7 @@ fn fold_obj[ENV](&ENV env, ast_fold[ENV] fld, &ast._obj ob) -> ast._obj {\n     ret fld.fold_obj(env, fields, meths, dtor);\n }\n \n-fn fold_view_item[ENV](&ENV env, ast_fold[ENV] fld, @view_item vi)\n+fn fold_view_item[ENV](&ENV env, &ast_fold[ENV] fld, &@view_item vi)\n     -> @view_item {\n \n     let ENV env_ = fld.update_env_for_view_item(env, vi);\n@@ -987,7 +995,7 @@ fn fold_view_item[ENV](&ENV env, ast_fold[ENV] fld, @view_item vi)\n     fail;\n }\n \n-fn fold_item[ENV](&ENV env, ast_fold[ENV] fld, @item i) -> @item {\n+fn fold_item[ENV](&ENV env, &ast_fold[ENV] fld, &@item i) -> @item {\n \n     let ENV env_ = fld.update_env_for_item(env, i);\n \n@@ -1049,7 +1057,7 @@ fn fold_item[ENV](&ENV env, ast_fold[ENV] fld, @item i) -> @item {\n     fail;\n }\n \n-fn fold_mod[ENV](&ENV e, ast_fold[ENV] fld, &ast._mod m) -> ast._mod {\n+fn fold_mod[ENV](&ENV e, &ast_fold[ENV] fld, &ast._mod m) -> ast._mod {\n \n     let vec[@view_item] view_items = vec();\n     let vec[@item] items = vec();\n@@ -1070,8 +1078,8 @@ fn fold_mod[ENV](&ENV e, ast_fold[ENV] fld, &ast._mod m) -> ast._mod {\n     ret fld.fold_mod(e, rec(view_items=view_items, items=items, index=index));\n }\n \n-fn fold_native_item[ENV](&ENV env, ast_fold[ENV] fld,\n-                         @native_item i) -> @native_item {\n+fn fold_native_item[ENV](&ENV env, &ast_fold[ENV] fld,\n+                         &@native_item i) -> @native_item {\n     let ENV env_ = fld.update_env_for_native_item(env, i);\n \n     if (!fld.keep_going(env_)) {\n@@ -1090,7 +1098,7 @@ fn fold_native_item[ENV](&ENV env, ast_fold[ENV] fld,\n     }\n }\n \n-fn fold_native_mod[ENV](&ENV e, ast_fold[ENV] fld,\n+fn fold_native_mod[ENV](&ENV e, &ast_fold[ENV] fld,\n                         &ast.native_mod m) -> ast.native_mod {\n     let vec[@view_item] view_items = vec();\n     let vec[@native_item] items = vec();\n@@ -1114,7 +1122,8 @@ fn fold_native_mod[ENV](&ENV e, ast_fold[ENV] fld,\n                                    index=index));\n }\n \n-fn fold_crate[ENV](&ENV env, ast_fold[ENV] fld, @ast.crate c) -> @ast.crate {\n+fn fold_crate[ENV](&ENV env, &ast_fold[ENV] fld,\n+                   &@ast.crate c) -> @ast.crate {\n     // FIXME: possibly fold the directives so you process any expressions\n     // within them? Not clear. After front/eval.rs, nothing else should look\n     // at crate directives.\n@@ -1132,7 +1141,7 @@ fn respan[T](&span sp, &T t) -> spanned[T] {\n \n // Path identity.\n \n-fn identity_fold_path[ENV](&ENV env, &span sp, ast.path_ p) -> path {\n+fn identity_fold_path[ENV](&ENV env, &span sp, &ast.path_ p) -> path {\n     ret respan(sp, p);\n }\n \n@@ -1180,359 +1189,368 @@ fn identity_fold_ty_vec[ENV](&ENV env, &span sp, &mt tm) -> @ty {\n }\n \n fn identity_fold_ty_tup[ENV](&ENV env, &span sp,\n-                             vec[mt] elts) -> @ty {\n+                             &vec[mt] elts) -> @ty {\n     ret @respan(sp, ast.ty_tup(elts));\n }\n \n fn identity_fold_ty_rec[ENV](&ENV env, &span sp,\n-                             vec[ast.ty_field] elts) -> @ty {\n+                             &vec[ast.ty_field] elts) -> @ty {\n     ret @respan(sp, ast.ty_rec(elts));\n }\n \n fn identity_fold_ty_obj[ENV](&ENV env, &span sp,\n-                             vec[ast.ty_method] meths) -> @ty {\n+                             &vec[ast.ty_method] meths) -> @ty {\n     ret @respan(sp, ast.ty_obj(meths));\n }\n \n fn identity_fold_ty_fn[ENV](&ENV env, &span sp,\n                             ast.proto proto,\n-                            vec[rec(ast.mode mode, @ty ty)] inputs,\n-                            @ty output) -> @ty {\n+                            &vec[rec(ast.mode mode, @ty ty)] inputs,\n+                            &@ty output) -> @ty {\n     ret @respan(sp, ast.ty_fn(proto, inputs, output));\n }\n \n-fn identity_fold_ty_path[ENV](&ENV env, &span sp, ast.path p,\n-                        &Option.t[def] d) -> @ty {\n+fn identity_fold_ty_path[ENV](&ENV env, &span sp, &ast.path p,\n+                              &Option.t[def] d) -> @ty {\n     ret @respan(sp, ast.ty_path(p, d));\n }\n \n-fn identity_fold_ty_chan[ENV](&ENV env, &span sp, @ty t) -> @ty {\n+fn identity_fold_ty_chan[ENV](&ENV env, &span sp, &@ty t) -> @ty {\n     ret @respan(sp, ast.ty_chan(t));\n }\n \n-fn identity_fold_ty_port[ENV](&ENV env, &span sp, @ty t) -> @ty {\n+fn identity_fold_ty_port[ENV](&ENV env, &span sp, &@ty t) -> @ty {\n     ret @respan(sp, ast.ty_port(t));\n }\n \n // Expr identities.\n \n-fn identity_fold_expr_vec[ENV](&ENV env, &span sp, vec[@expr] es,\n-                               ast.mutability mut, ann a) -> @expr {\n+fn identity_fold_expr_vec[ENV](&ENV env, &span sp, &vec[@expr] es,\n+                               ast.mutability mut, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_vec(es, mut, a));\n }\n \n fn identity_fold_expr_tup[ENV](&ENV env, &span sp,\n-                               vec[ast.elt] es, ann a) -> @expr {\n+                               &vec[ast.elt] es, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_tup(es, a));\n }\n \n fn identity_fold_expr_rec[ENV](&ENV env, &span sp,\n-                               vec[ast.field] fields,\n-                               Option.t[@expr] base, ann a) -> @expr {\n+                               &vec[ast.field] fields,\n+                               &Option.t[@expr] base, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_rec(fields, base, a));\n }\n \n-fn identity_fold_expr_call[ENV](&ENV env, &span sp, @expr f,\n-                                vec[@expr] args, ann a) -> @expr {\n+fn identity_fold_expr_call[ENV](&ENV env, &span sp, &@expr f,\n+                                &vec[@expr] args, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_call(f, args, a));\n }\n \n-fn identity_fold_expr_self_method[ENV](&ENV env, &span sp, ident id,\n-                                       ann a) -> @expr {\n+fn identity_fold_expr_self_method[ENV](&ENV env, &span sp, &ident id,\n+                                       &ann a) -> @expr {\n     ret @respan(sp, ast.expr_self_method(id, a));\n }\n \n-fn identity_fold_expr_bind[ENV](&ENV env, &span sp, @expr f,\n-                                vec[Option.t[@expr]] args_opt, ann a)\n+fn identity_fold_expr_bind[ENV](&ENV env, &span sp, &@expr f,\n+                                &vec[Option.t[@expr]] args_opt, &ann a)\n         -> @expr {\n     ret @respan(sp, ast.expr_bind(f, args_opt, a));\n }\n \n fn identity_fold_expr_spawn[ENV](&ENV env, &span sp,\n-                                 ast.spawn_dom dom, Option.t[str] name,\n-                                 @expr f, vec[@expr] args, ann a) -> @expr {\n+                                 ast.spawn_dom dom, &Option.t[str] name,\n+                                 &@expr f, &vec[@expr] args,\n+                                 &ann a) -> @expr {\n     ret @respan(sp, ast.expr_spawn(dom, name, f, args, a));\n }\n \n fn identity_fold_expr_binary[ENV](&ENV env, &span sp, ast.binop b,\n-                                  @expr lhs, @expr rhs,\n-                                  ann a) -> @expr {\n+                                  &@expr lhs, &@expr rhs,\n+                                  &ann a) -> @expr {\n     ret @respan(sp, ast.expr_binary(b, lhs, rhs, a));\n }\n \n fn identity_fold_expr_unary[ENV](&ENV env, &span sp,\n-                                 ast.unop u, @expr e, ann a)\n+                                 ast.unop u, &@expr e, &ann a)\n         -> @expr {\n     ret @respan(sp, ast.expr_unary(u, e, a));\n }\n \n-fn identity_fold_expr_lit[ENV](&ENV env, &span sp, @ast.lit lit,\n-                               ann a) -> @expr {\n+fn identity_fold_expr_lit[ENV](&ENV env, &span sp, &@ast.lit lit,\n+                               &ann a) -> @expr {\n     ret @respan(sp, ast.expr_lit(lit, a));\n }\n \n-fn identity_fold_expr_cast[ENV](&ENV env, &span sp, @ast.expr e,\n-                                @ast.ty t, ann a) -> @expr {\n+fn identity_fold_expr_cast[ENV](&ENV env, &span sp, &@ast.expr e,\n+                                &@ast.ty t, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_cast(e, t, a));\n }\n \n fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n-                              @expr cond, &block thn,\n-                              &Option.t[@expr] els, ann a) -> @expr {\n+                              &@expr cond, &block thn,\n+                              &Option.t[@expr] els, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_if(cond, thn, els, a));\n }\n \n fn identity_fold_expr_for[ENV](&ENV env, &span sp,\n-                               @decl d, @expr seq,\n-                               &block body, ann a) -> @expr {\n+                               &@decl d, &@expr seq,\n+                               &block body, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_for(d, seq, body, a));\n }\n \n fn identity_fold_expr_for_each[ENV](&ENV env, &span sp,\n-                                    @decl d, @expr seq,\n-                                    &block body, ann a) -> @expr {\n+                                    &@decl d, &@expr seq,\n+                                    &block body, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_for_each(d, seq, body, a));\n }\n \n fn identity_fold_expr_while[ENV](&ENV env, &span sp,\n-                                 @expr cond, &block body, ann a) -> @expr {\n+                                 &@expr cond, &block body, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_while(cond, body, a));\n }\n \n fn identity_fold_expr_do_while[ENV](&ENV env, &span sp,\n-                                    &block body, @expr cond, ann a) -> @expr {\n+                                    &block body, &@expr cond,\n+                                    &ann a) -> @expr {\n     ret @respan(sp, ast.expr_do_while(body, cond, a));\n }\n \n fn identity_fold_expr_alt[ENV](&ENV env, &span sp,\n-                               @expr e, vec[arm] arms, ann a) -> @expr {\n+                               &@expr e, &vec[arm] arms,\n+                               &ann a) -> @expr {\n     ret @respan(sp, ast.expr_alt(e, arms, a));\n }\n \n fn identity_fold_expr_block[ENV](&ENV env, &span sp, &block blk,\n-                                 ann a) -> @expr {\n+                                 &ann a) -> @expr {\n     ret @respan(sp, ast.expr_block(blk, a));\n }\n \n fn identity_fold_expr_assign[ENV](&ENV env, &span sp,\n-                                  @expr lhs, @expr rhs, ann a)\n+                                  &@expr lhs, &@expr rhs, &ann a)\n         -> @expr {\n     ret @respan(sp, ast.expr_assign(lhs, rhs, a));\n }\n \n fn identity_fold_expr_assign_op[ENV](&ENV env, &span sp, ast.binop op,\n-                                     @expr lhs, @expr rhs, ann a)\n+                                     &@expr lhs, &@expr rhs, &ann a)\n         -> @expr {\n     ret @respan(sp, ast.expr_assign_op(op, lhs, rhs, a));\n }\n \n fn identity_fold_expr_send[ENV](&ENV e, &span sp,\n-                                @expr lhs, @expr rhs, ann a) -> @expr {\n+                                &@expr lhs, &@expr rhs, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_send(lhs, rhs, a));\n }\n \n fn identity_fold_expr_recv[ENV](&ENV e, &span sp,\n-                                @expr lhs, @expr rhs, ann a) -> @expr {\n+                                &@expr lhs, &@expr rhs, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_recv(lhs, rhs, a));\n }\n \n fn identity_fold_expr_field[ENV](&ENV env, &span sp,\n-                                 @expr e, ident i, ann a) -> @expr {\n+                                 &@expr e, &ident i, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_field(e, i, a));\n }\n \n fn identity_fold_expr_index[ENV](&ENV env, &span sp,\n-                                 @expr e, @expr ix, ann a) -> @expr {\n+                                 &@expr e, &@expr ix, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_index(e, ix, a));\n }\n \n fn identity_fold_expr_path[ENV](&ENV env, &span sp,\n                                 &path p, &Option.t[def] d,\n-                                ann a) -> @expr {\n+                                &ann a) -> @expr {\n     ret @respan(sp, ast.expr_path(p, d, a));\n }\n \n fn identity_fold_expr_ext[ENV](&ENV env, &span sp,\n-                               &path p, vec[@expr] args,\n-                               Option.t[str] body,\n-                               @expr expanded,\n-                               ann a) -> @expr {\n+                               &path p, &vec[@expr] args,\n+                               &Option.t[str] body,\n+                               &@expr expanded,\n+                               &ann a) -> @expr {\n     ret @respan(sp, ast.expr_ext(p, args, body, expanded, a));\n }\n \n-fn identity_fold_expr_fail[ENV](&ENV env, &span sp, ann a) -> @expr {\n+fn identity_fold_expr_fail[ENV](&ENV env, &span sp, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_fail(a));\n }\n \n-fn identity_fold_expr_break[ENV](&ENV env, &span sp, ann a) -> @expr {\n+fn identity_fold_expr_break[ENV](&ENV env, &span sp, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_break(a));\n }\n \n-fn identity_fold_expr_cont[ENV](&ENV env, &span sp, ann a) -> @expr {\n+fn identity_fold_expr_cont[ENV](&ENV env, &span sp, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_cont(a));\n }\n \n fn identity_fold_expr_ret[ENV](&ENV env, &span sp,\n-                               &Option.t[@expr] rv, ann a) -> @expr {\n+                               &Option.t[@expr] rv, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_ret(rv, a));\n }\n \n fn identity_fold_expr_put[ENV](&ENV env, &span sp,\n-                               &Option.t[@expr] rv, ann a) -> @expr {\n+                               &Option.t[@expr] rv, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_put(rv, a));\n }\n \n-fn identity_fold_expr_be[ENV](&ENV env, &span sp, @expr x, ann a) -> @expr {\n+fn identity_fold_expr_be[ENV](&ENV env, &span sp,\n+                              &@expr x, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_be(x, a));\n }\n \n-fn identity_fold_expr_log[ENV](&ENV e, &span sp, int lvl, @expr x,\n-                               ann a) -> @expr {\n+fn identity_fold_expr_log[ENV](&ENV e, &span sp, int lvl, &@expr x,\n+                               &ann a) -> @expr {\n     ret @respan(sp, ast.expr_log(lvl, x, a));\n }\n \n-fn identity_fold_expr_check[ENV](&ENV e, &span sp, @expr x, ann a)\n+fn identity_fold_expr_check[ENV](&ENV e, &span sp, &@expr x, &ann a)\n     -> @expr {\n     ret @respan(sp, ast.expr_check(x, a));\n }\n \n-fn identity_fold_expr_assert[ENV](&ENV e, &span sp, @expr x, ann a)\n+fn identity_fold_expr_assert[ENV](&ENV e, &span sp, &@expr x, &ann a)\n     -> @expr {\n     ret @respan(sp, ast.expr_assert(x, a));\n }\n \n-fn identity_fold_expr_port[ENV](&ENV e, &span sp, ann a) -> @expr {\n+fn identity_fold_expr_port[ENV](&ENV e, &span sp, &ann a) -> @expr {\n     ret @respan(sp, ast.expr_port(a));\n }\n \n-fn identity_fold_expr_chan[ENV](&ENV e, &span sp, @expr x, ann a) -> @expr {\n+fn identity_fold_expr_chan[ENV](&ENV e, &span sp, &@expr x,\n+                                &ann a) -> @expr {\n     ret @respan(sp, ast.expr_chan(x, a));\n }\n \n // Decl identities.\n \n fn identity_fold_decl_local[ENV](&ENV e, &span sp,\n-                                 @ast.local local) -> @decl {\n+                                 &@ast.local local) -> @decl {\n     ret @respan(sp, ast.decl_local(local));\n }\n \n-fn identity_fold_decl_item[ENV](&ENV e, &span sp, @item i) -> @decl {\n+fn identity_fold_decl_item[ENV](&ENV e, &span sp, &@item i) -> @decl {\n     ret @respan(sp, ast.decl_item(i));\n }\n \n \n // Pat identities.\n \n-fn identity_fold_pat_wild[ENV](&ENV e, &span sp, ann a) -> @pat {\n+fn identity_fold_pat_wild[ENV](&ENV e, &span sp, &ann a) -> @pat {\n     ret @respan(sp, ast.pat_wild(a));\n }\n \n-fn identity_fold_pat_lit[ENV](&ENV e, &span sp, @ast.lit lit, ann a) -> @pat {\n+fn identity_fold_pat_lit[ENV](&ENV e, &span sp,\n+                              &@ast.lit lit, &ann a) -> @pat {\n     ret @respan(sp, ast.pat_lit(lit, a));\n }\n \n-fn identity_fold_pat_bind[ENV](&ENV e, &span sp, ident i, def_id did, ann a)\n+fn identity_fold_pat_bind[ENV](&ENV e, &span sp, &ident i,\n+                               &def_id did, &ann a)\n         -> @pat {\n     ret @respan(sp, ast.pat_bind(i, did, a));\n }\n \n-fn identity_fold_pat_tag[ENV](&ENV e, &span sp, path p, vec[@pat] args,\n-                              Option.t[ast.variant_def] d, ann a) -> @pat {\n+fn identity_fold_pat_tag[ENV](&ENV e, &span sp, &path p, &vec[@pat] args,\n+                              &Option.t[ast.variant_def] d, &ann a) -> @pat {\n     ret @respan(sp, ast.pat_tag(p, args, d, a));\n }\n \n \n // Stmt identities.\n \n-fn identity_fold_stmt_decl[ENV](&ENV env, &span sp, @decl d, ann a) -> @stmt {\n+fn identity_fold_stmt_decl[ENV](&ENV env, &span sp,\n+                                &@decl d, &ann a) -> @stmt {\n     ret @respan(sp, ast.stmt_decl(d, a));\n }\n \n-fn identity_fold_stmt_expr[ENV](&ENV e, &span sp, @expr x, ann a) -> @stmt {\n+fn identity_fold_stmt_expr[ENV](&ENV e, &span sp,\n+                                &@expr x, &ann a) -> @stmt {\n     ret @respan(sp, ast.stmt_expr(x, a));\n }\n \n \n // Item identities.\n \n-fn identity_fold_item_const[ENV](&ENV e, &span sp, ident i,\n-                                 @ty t, @expr ex,\n-                                 def_id id, ann a) -> @item {\n+fn identity_fold_item_const[ENV](&ENV e, &span sp, &ident i,\n+                                  &@ty t, &@expr ex,\n+                                 &def_id id, &ann a) -> @item {\n     ret @respan(sp, ast.item_const(i, t, ex, id, a));\n }\n \n-fn identity_fold_item_fn[ENV](&ENV e, &span sp, ident i,\n-                              &ast._fn f, vec[ast.ty_param] ty_params,\n-                              def_id id, ann a) -> @item {\n+fn identity_fold_item_fn[ENV](&ENV e, &span sp, &ident i,\n+                              &ast._fn f, &vec[ast.ty_param] ty_params,\n+                              &def_id id, &ann a) -> @item {\n     ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n }\n \n-fn identity_fold_native_item_fn[ENV](&ENV e, &span sp, ident i,\n-                                     Option.t[str] link_name,\n+fn identity_fold_native_item_fn[ENV](&ENV e, &span sp, &ident i,\n+                                     &Option.t[str] link_name,\n                                      &ast.fn_decl decl,\n-                                     vec[ast.ty_param] ty_params,\n-                                     def_id id, ann a) -> @native_item {\n+                                     &vec[ast.ty_param] ty_params,\n+                                     &def_id id, &ann a) -> @native_item {\n     ret @respan(sp, ast.native_item_fn(i, link_name, decl, ty_params, id, a));\n }\n \n-fn identity_fold_item_mod[ENV](&ENV e, &span sp, ident i,\n-                               &ast._mod m, def_id id) -> @item {\n+fn identity_fold_item_mod[ENV](&ENV e, &span sp, &ident i,\n+                               &ast._mod m, &def_id id) -> @item {\n     ret @respan(sp, ast.item_mod(i, m, id));\n }\n \n-fn identity_fold_item_native_mod[ENV](&ENV e, &span sp, ident i,\n-                                      &ast.native_mod m, def_id id) -> @item {\n+fn identity_fold_item_native_mod[ENV](&ENV e, &span sp, &ident i,\n+                                      &ast.native_mod m, &def_id id) -> @item {\n     ret @respan(sp, ast.item_native_mod(i, m, id));\n }\n \n-fn identity_fold_item_ty[ENV](&ENV e, &span sp, ident i,\n-                              @ty t, vec[ast.ty_param] ty_params,\n-                              def_id id, ann a) -> @item {\n+fn identity_fold_item_ty[ENV](&ENV e, &span sp, &ident i,\n+                              &@ty t, &vec[ast.ty_param] ty_params,\n+                              &def_id id, &ann a) -> @item {\n     ret @respan(sp, ast.item_ty(i, t, ty_params, id, a));\n }\n \n-fn identity_fold_native_item_ty[ENV](&ENV e, &span sp, ident i,\n-                                     def_id id) -> @native_item {\n+fn identity_fold_native_item_ty[ENV](&ENV e, &span sp, &ident i,\n+                                     &def_id id) -> @native_item {\n     ret @respan(sp, ast.native_item_ty(i, id));\n }\n \n-fn identity_fold_item_tag[ENV](&ENV e, &span sp, ident i,\n-                               vec[ast.variant] variants,\n-                               vec[ast.ty_param] ty_params,\n-                               def_id id, ann a) -> @item {\n+fn identity_fold_item_tag[ENV](&ENV e, &span sp, &ident i,\n+                               &vec[ast.variant] variants,\n+                               &vec[ast.ty_param] ty_params,\n+                               &def_id id, &ann a) -> @item {\n     ret @respan(sp, ast.item_tag(i, variants, ty_params, id, a));\n }\n \n-fn identity_fold_item_obj[ENV](&ENV e, &span sp, ident i,\n-                               &ast._obj ob, vec[ast.ty_param] ty_params,\n-                               ast.obj_def_ids odid, ann a) -> @item {\n+fn identity_fold_item_obj[ENV](&ENV e, &span sp, &ident i,\n+                               &ast._obj ob, &vec[ast.ty_param] ty_params,\n+                               &ast.obj_def_ids odid, &ann a) -> @item {\n     ret @respan(sp, ast.item_obj(i, ob, ty_params, odid, a));\n }\n \n // View Item folds.\n \n-fn identity_fold_view_item_use[ENV](&ENV e, &span sp, ident i,\n-                                    vec[@meta_item] meta_items,\n-                                    def_id id, Option.t[int] cnum)\n+fn identity_fold_view_item_use[ENV](&ENV e, &span sp, &ident i,\n+                                    &vec[@meta_item] meta_items,\n+                                    &def_id id, &Option.t[int] cnum)\n     -> @view_item {\n     ret @respan(sp, ast.view_item_use(i, meta_items, id, cnum));\n }\n \n-fn identity_fold_view_item_import[ENV](&ENV e, &span sp, ident i,\n-                                       vec[ident] is, def_id id,\n-                                       Option.t[def] target_def)\n+fn identity_fold_view_item_import[ENV](&ENV e, &span sp, &ident i,\n+                                       &vec[ident] is, &def_id id,\n+                                       &Option.t[def] target_def)\n     -> @view_item {\n     ret @respan(sp, ast.view_item_import(i, is, id, target_def));\n }\n \n-fn identity_fold_view_item_export[ENV](&ENV e, &span sp, ident i)\n+fn identity_fold_view_item_export[ENV](&ENV e, &span sp, &ident i)\n     -> @view_item {\n     ret @respan(sp, ast.view_item_export(i));\n }\n \n // Annotation folding.\n \n-fn identity_fold_ann[ENV](&ENV e, ann a) -> ann {\n+fn identity_fold_ann[ENV](&ENV e, &ann a) -> ann {\n     ret a;\n }\n \n@@ -1543,9 +1561,9 @@ fn identity_fold_block[ENV](&ENV e, &span sp, &ast.block_ blk) -> block {\n }\n \n fn identity_fold_fn_decl[ENV](&ENV e,\n-                              vec[arg] inputs,\n-                              @ty output,\n-                              purity p) -> ast.fn_decl {\n+                              &vec[arg] inputs,\n+                              &@ty output,\n+                              &purity p) -> ast.fn_decl {\n     ret rec(inputs=inputs, output=output, purity=p);\n }\n \n@@ -1566,62 +1584,62 @@ fn identity_fold_native_mod[ENV](&ENV e,\n }\n \n fn identity_fold_crate[ENV](&ENV e, &span sp,\n-                            vec[@ast.crate_directive] cdirs,\n+                            &vec[@ast.crate_directive] cdirs,\n                             &ast._mod m) -> @ast.crate {\n     ret @respan(sp, rec(directives=cdirs, module=m));\n }\n \n fn identity_fold_obj[ENV](&ENV e,\n-                          vec[ast.obj_field] fields,\n-                          vec[@ast.method] methods,\n-                          Option.t[@ast.method] dtor) -> ast._obj {\n+                          &vec[ast.obj_field] fields,\n+                          &vec[@ast.method] methods,\n+                          &Option.t[@ast.method] dtor) -> ast._obj {\n     ret rec(fields=fields, methods=methods, dtor=dtor);\n }\n \n \n // Env update identities.\n \n-fn identity_update_env_for_crate[ENV](&ENV e, @ast.crate c) -> ENV {\n+fn identity_update_env_for_crate[ENV](&ENV e, &@ast.crate c) -> ENV {\n     ret e;\n }\n \n-fn identity_update_env_for_item[ENV](&ENV e, @item i) -> ENV {\n+fn identity_update_env_for_item[ENV](&ENV e, &@item i) -> ENV {\n     ret e;\n }\n \n-fn identity_update_env_for_native_item[ENV](&ENV e, @native_item i) -> ENV {\n+fn identity_update_env_for_native_item[ENV](&ENV e, &@native_item i) -> ENV {\n     ret e;\n }\n \n-fn identity_update_env_for_view_item[ENV](&ENV e, @view_item i) -> ENV {\n+fn identity_update_env_for_view_item[ENV](&ENV e, &@view_item i) -> ENV {\n     ret e;\n }\n \n fn identity_update_env_for_block[ENV](&ENV e, &block b) -> ENV {\n     ret e;\n }\n \n-fn identity_update_env_for_stmt[ENV](&ENV e, @stmt s) -> ENV {\n+fn identity_update_env_for_stmt[ENV](&ENV e, &@stmt s) -> ENV {\n     ret e;\n }\n \n-fn identity_update_env_for_decl[ENV](&ENV e, @decl d) -> ENV {\n+fn identity_update_env_for_decl[ENV](&ENV e, &@decl d) -> ENV {\n     ret e;\n }\n \n fn identity_update_env_for_arm[ENV](&ENV e, &arm a) -> ENV {\n     ret e;\n }\n \n-fn identity_update_env_for_pat[ENV](&ENV e, @pat p) -> ENV {\n+fn identity_update_env_for_pat[ENV](&ENV e, &@pat p) -> ENV {\n     ret e;\n }\n \n-fn identity_update_env_for_expr[ENV](&ENV e, @expr x) -> ENV {\n+fn identity_update_env_for_expr[ENV](&ENV e, &@expr x) -> ENV {\n     ret e;\n }\n \n-fn identity_update_env_for_ty[ENV](&ENV e, @ty t) -> ENV {\n+fn identity_update_env_for_ty[ENV](&ENV e, &@ty t) -> ENV {\n     ret e;\n }\n \n@@ -1697,7 +1715,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          = bind identity_fold_expr_check[ENV](_,_,_,_),\n          fold_expr_assert\n          = bind identity_fold_expr_assert[ENV](_,_,_,_),\n-              \n+\n          fold_expr_port   = bind identity_fold_expr_port[ENV](_,_,_),\n          fold_expr_chan   = bind identity_fold_expr_chan[ENV](_,_,_,_),\n "}, {"sha": "5fb2eb04fa93daef0b1d0f6e7564bae7b2e604e0", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4539f8a03cfa85fae97140687bc8ed2e48d91a65/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4539f8a03cfa85fae97140687bc8ed2e48d91a65/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=4539f8a03cfa85fae97140687bc8ed2e48d91a65", "patch": "@@ -604,9 +604,9 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns, direction dir)\n     }\n }\n \n-fn fold_pat_tag(&env e, &span sp, ast.path p, vec[@ast.pat] args,\n-                Option.t[ast.variant_def] old_def,\n-                ann a) -> @ast.pat {\n+fn fold_pat_tag(&env e, &span sp, &ast.path p, &vec[@ast.pat] args,\n+                &Option.t[ast.variant_def] old_def,\n+                &ann a) -> @ast.pat {\n     auto len = Vec.len[ast.ident](p.node.idents);\n     auto last_id = p.node.idents.(len - 1u);\n     auto new_def;\n@@ -647,7 +647,7 @@ fn fold_pat_tag(&env e, &span sp, ast.path p, vec[@ast.pat] args,\n // expressions tacked on the end.\n \n fn fold_expr_path(&env e, &span sp, &ast.path p, &Option.t[def] d,\n-                  ann a) -> @ast.expr {\n+                  &ann a) -> @ast.expr {\n     auto n_idents = Vec.len[ast.ident](p.node.idents);\n     assert (n_idents != 0u);\n \n@@ -683,9 +683,9 @@ fn fold_expr_path(&env e, &span sp, &ast.path p, &Option.t[def] d,\n }\n \n fn fold_view_item_import(&env e, &span sp,\n-                         import_map index, ident i,\n-                         vec[ident] is, ast.def_id id,\n-                         Option.t[def] target_id) -> @ast.view_item {\n+                         &import_map index, &ident i,\n+                         &vec[ident] is, &ast.def_id id,\n+                         &Option.t[def] target_id) -> @ast.view_item {\n     // Produce errors for invalid imports\n     auto len = Vec.len[ast.ident](is);\n     auto last_id = is.(len - 1u);\n@@ -703,30 +703,30 @@ fn fold_view_item_import(&env e, &span sp,\n                                                               target_def));\n }\n \n-fn fold_ty_path(&env e, &span sp, ast.path p, &Option.t[def] d) -> @ast.ty {\n+fn fold_ty_path(&env e, &span sp, &ast.path p, &Option.t[def] d) -> @ast.ty {\n     auto index = new_def_hash[def_wrap]();\n     auto d = find_final_def(e, index, sp, p.node.idents, ns_type,\n                             none[ast.def_id]);\n \n     ret @fold.respan[ast.ty_](sp, ast.ty_path(p, some(unwrap_def(d))));\n }\n \n-fn update_env_for_crate(&env e, @ast.crate c) -> env {\n+fn update_env_for_crate(&env e, &@ast.crate c) -> env {\n     ret rec(scopes = cons[scope](scope_crate(c), @e.scopes) with e);\n }\n \n-fn update_env_for_item(&env e, @ast.item i) -> env {\n+fn update_env_for_item(&env e, &@ast.item i) -> env {\n     ret rec(scopes = cons[scope](scope_item(i), @e.scopes) with e);\n }\n \n-fn update_env_for_native_item(&env e, @ast.native_item i) -> env {\n+fn update_env_for_native_item(&env e, &@ast.native_item i) -> env {\n     ret rec(scopes = cons[scope](scope_native_item(i), @e.scopes) with e);\n }\n \n // Not actually called by fold, but here since this is analogous to\n // update_env_for_item() above and is called by find_final_def().\n-fn update_env_for_external_mod(&env e, ast.def_id mod_id,\n-                               vec[ast.ident] idents) -> env {\n+fn update_env_for_external_mod(&env e, &ast.def_id mod_id,\n+                               &vec[ast.ident] idents) -> env {\n     ret rec(scopes = cons[scope](scope_external_mod(mod_id, idents),\n                                  @e.scopes)\n             with e);\n@@ -736,7 +736,7 @@ fn update_env_for_block(&env e, &ast.block b) -> env {\n     ret rec(scopes = cons[scope](scope_block(b), @e.scopes) with e);\n }\n \n-fn update_env_for_expr(&env e, @ast.expr x) -> env {\n+fn update_env_for_expr(&env e, &@ast.expr x) -> env {\n     alt (x.node) {\n         case (ast.expr_for(?d, _, _, _)) {\n             ret rec(scopes = cons[scope](scope_loop(d), @e.scopes) with e);\n@@ -753,7 +753,7 @@ fn update_env_for_arm(&env e, &ast.arm p) -> env {\n     ret rec(scopes = cons[scope](scope_arm(p), @e.scopes) with e);\n }\n \n-fn resolve_imports(session.session sess, @ast.crate crate) -> @ast.crate {\n+fn resolve_imports(session.session sess, &@ast.crate crate) -> @ast.crate {\n     let fold.ast_fold[env] fld = fold.new_identity_fold[env]();\n \n     auto import_index = new_def_hash[def_wrap]();"}, {"sha": "cdccb82870d035e1c3f5ef39fa3ae42f176c200d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4539f8a03cfa85fae97140687bc8ed2e48d91a65/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4539f8a03cfa85fae97140687bc8ed2e48d91a65/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=4539f8a03cfa85fae97140687bc8ed2e48d91a65", "patch": "@@ -631,7 +631,7 @@ mod Collect {\n         ret result;\n     }\n \n-    fn collect(&@ty_item_table id_to_ty_item, @ast.item i) -> @ty_item_table {\n+    fn collect(&@ty_item_table id_to_ty_item, &@ast.item i) -> @ty_item_table {\n         alt (i.node) {\n             case (ast.item_ty(_, _, _, ?def_id, _)) {\n                 id_to_ty_item.insert(def_id, any_item_rust(i));\n@@ -647,7 +647,7 @@ mod Collect {\n         ret id_to_ty_item;\n     }\n \n-    fn collect_native(&@ty_item_table id_to_ty_item, @ast.native_item i)\n+    fn collect_native(&@ty_item_table id_to_ty_item, &@ast.native_item i)\n         -> @ty_item_table {\n         alt (i.node) {\n             case (ast.native_item_ty(_, ?def_id)) {\n@@ -662,7 +662,7 @@ mod Collect {\n         ret id_to_ty_item;\n     }\n \n-    fn convert(&@env e, @ast.item i) -> @env {\n+    fn convert(&@env e, &@ast.item i) -> @env {\n         auto abi = e.abi;\n         alt (i.node) {\n             case (ast.item_mod(_, _, _)) {\n@@ -681,40 +681,40 @@ mod Collect {\n         ret @rec(abi=abi with *e);\n     }\n \n-    fn convert_native(&@env e, @ast.native_item i) -> @env {\n+    fn convert_native(&@env e, &@ast.native_item i) -> @env {\n         ty_of_native_item(e.cx, i, e.abi);\n         ret e;\n     }\n \n-    fn fold_item_const(&@env e, &span sp, ast.ident i,\n-                       @ast.ty t, @ast.expr ex,\n-                       ast.def_id id, ast.ann a) -> @ast.item {\n+    fn fold_item_const(&@env e, &span sp, &ast.ident i,\n+                       &@ast.ty t, &@ast.expr ex,\n+                       &ast.def_id id, &ast.ann a) -> @ast.item {\n         // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_const(i, t, ex, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n-    fn fold_item_fn(&@env e, &span sp, ast.ident i,\n-                    &ast._fn f, vec[ast.ty_param] ty_params,\n-                    ast.def_id id, ast.ann a) -> @ast.item {\n+    fn fold_item_fn(&@env e, &span sp, &ast.ident i,\n+                    &ast._fn f, &vec[ast.ty_param] ty_params,\n+                    &ast.def_id id, &ast.ann a) -> @ast.item {\n         // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_fn(i, f, ty_params, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n-    fn fold_native_item_fn(&@env e, &span sp, ast.ident i, Option.t[str] ln,\n-                           &ast.fn_decl d, vec[ast.ty_param] ty_params,\n-                           ast.def_id id, ast.ann a) -> @ast.native_item {\n+    fn fold_native_item_fn(&@env e, &span sp, &ast.ident i, &Option.t[str] ln,\n+                           &ast.fn_decl d, &vec[ast.ty_param] ty_params,\n+                           &ast.def_id id, &ast.ann a) -> @ast.native_item {\n         // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.native_item_fn(i, ln, d, ty_params, id,\n                                        triv_ann(typ));\n         ret @fold.respan[ast.native_item_](sp, item);\n     }\n \n-    fn get_ctor_obj_methods(&@env e, ty.t t) -> vec[method] {\n+    fn get_ctor_obj_methods(&@env e, &ty.t t) -> vec[method] {\n         alt (struct(e.cx.tcx, t)) {\n             case (ty.ty_fn(_,_,?tobj)) {\n                 alt (struct(e.cx.tcx, tobj)) {\n@@ -735,9 +735,9 @@ mod Collect {\n     }\n \n \n-    fn fold_item_obj(&@env e, &span sp, ast.ident i,\n-                    &ast._obj ob, vec[ast.ty_param] ty_params,\n-                    ast.obj_def_ids odid, ast.ann a) -> @ast.item {\n+    fn fold_item_obj(&@env e, &span sp, &ast.ident i,\n+                    &ast._obj ob, &vec[ast.ty_param] ty_params,\n+                    &ast.obj_def_ids odid, &ast.ann a) -> @ast.item {\n         // assert (e.cx.type_cache.contains_key(odid.ctor));\n         auto t = e.cx.type_cache.get(odid.ctor)._1;\n         let vec[method] meth_tys = get_ctor_obj_methods(e, t);\n@@ -791,19 +791,19 @@ mod Collect {\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n-    fn fold_item_ty(&@env e, &span sp, ast.ident i,\n-                    @ast.ty t, vec[ast.ty_param] ty_params,\n-                    ast.def_id id, ast.ann a) -> @ast.item {\n+    fn fold_item_ty(&@env e, &span sp, &ast.ident i,\n+                    &@ast.ty t, &vec[ast.ty_param] ty_params,\n+                    &ast.def_id id, &ast.ann a) -> @ast.item {\n         // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_ty(i, t, ty_params, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n-    fn fold_item_tag(&@env e, &span sp, ast.ident i,\n-                     vec[ast.variant] variants,\n-                     vec[ast.ty_param] ty_params,\n-                     ast.def_id id, ast.ann a) -> @ast.item {\n+    fn fold_item_tag(&@env e, &span sp, &ast.ident i,\n+                     &vec[ast.variant] variants,\n+                     &vec[ast.ty_param] ty_params,\n+                     &ast.def_id id, &ast.ann a) -> @ast.item {\n         auto variants_t = get_tag_variant_types(e.cx, id, variants,\n                                                 ty_params);\n         auto typ = e.cx.type_cache.get(id)._1;\n@@ -813,7 +813,8 @@ mod Collect {\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n-    fn collect_item_types(session.session sess, ty.ctxt tcx, @ast.crate crate)\n+    fn collect_item_types(&session.session sess, &ty.ctxt tcx,\n+                          &@ast.crate crate)\n             -> tup(@ast.crate, ty.type_cache, @ty_item_table) {\n         // First pass: collect all type item IDs.\n         auto module = crate.node.module;\n@@ -1523,7 +1524,7 @@ mod Pushdown {\n // Local variable resolution: the phase that finds all the types in the AST\n // and replaces opaque \"ty_local\" types with the resolved local types.\n \n-fn writeback_local(&Option.t[@fn_ctxt] env, &span sp, @ast.local local)\n+fn writeback_local(&Option.t[@fn_ctxt] env, &span sp, &@ast.local local)\n         -> @ast.decl {\n     auto fcx = Option.get[@fn_ctxt](env);\n \n@@ -1545,7 +1546,7 @@ fn writeback_local(&Option.t[@fn_ctxt] env, &span sp, @ast.local local)\n     ret @fold.respan[ast.decl_](sp, ast.decl_local(local_wb));\n }\n \n-fn resolve_local_types_in_annotation(&Option.t[@fn_ctxt] env, ast.ann ann)\n+fn resolve_local_types_in_annotation(&Option.t[@fn_ctxt] env, &ast.ann ann)\n         -> ast.ann {\n     fn resolver(@fn_ctxt fcx, ty.t typ) -> ty.t {\n         alt (struct(fcx.ccx.tcx, typ)) {\n@@ -1574,7 +1575,7 @@ fn resolve_local_types_in_annotation(&Option.t[@fn_ctxt] env, ast.ann ann)\n \n fn resolve_local_types_in_block(&@fn_ctxt fcx, &ast.block block)\n         -> ast.block {\n-    fn update_env_for_item(&Option.t[@fn_ctxt] env, @ast.item i)\n+    fn update_env_for_item(&Option.t[@fn_ctxt] env, &@ast.item i)\n             -> Option.t[@fn_ctxt] {\n         ret none[@fn_ctxt];\n     }\n@@ -1588,13 +1589,11 @@ fn resolve_local_types_in_block(&@fn_ctxt fcx, &ast.block block)\n     auto rltia = bind resolve_local_types_in_annotation(_,_);\n     auto uefi = update_env_for_item;\n     auto kg = keep_going;\n-    fld = @rec(\n-        fold_decl_local = wbl,\n-        fold_ann = rltia,\n-        update_env_for_item = uefi,\n-        keep_going = kg\n-        with *fld\n-    );\n+    fld = @rec(fold_decl_local = wbl,\n+               fold_ann = rltia,\n+               update_env_for_item = uefi,\n+               keep_going = kg\n+               with *fld);\n     ret fold.fold_block[Option.t[@fn_ctxt]](some[@fn_ctxt](fcx), fld, block);\n }\n \n@@ -2872,9 +2871,9 @@ fn check_fn(&@crate_ctxt ccx, &ast.fn_decl decl, ast.proto proto,\n     ret fn_t;\n }\n \n-fn check_item_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n-                 vec[ast.ty_param] ty_params, ast.def_id id,\n-                 ast.ann ann) -> @ast.item {\n+fn check_item_fn(&@crate_ctxt ccx, &span sp, &ast.ident ident, &ast._fn f,\n+                 &vec[ast.ty_param] ty_params, &ast.def_id id,\n+                 &ast.ann ann) -> @ast.item {\n \n     // FIXME: duplicate work: the item annotation already has the arg types\n     // and return type translated to typeck.ty values. We don't need do to it\n@@ -2893,7 +2892,7 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n     ret @fold.respan[ast.item_](sp, item);\n }\n \n-fn update_obj_fields(&@crate_ctxt ccx, @ast.item i) -> @crate_ctxt {\n+fn update_obj_fields(&@crate_ctxt ccx, &@ast.item i) -> @crate_ctxt {\n     alt (i.node) {\n         case (ast.item_obj(_, ?ob, _, ?obj_def_ids, _)) {\n             let ast.def_id di = obj_def_ids.ty;"}, {"sha": "7a9f9da768637c7b547f844cecccb9a423a7383a", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4539f8a03cfa85fae97140687bc8ed2e48d91a65/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4539f8a03cfa85fae97140687bc8ed2e48d91a65/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=4539f8a03cfa85fae97140687bc8ed2e48d91a65", "patch": "@@ -309,7 +309,7 @@ fn num_locals(fn_info m) -> uint {\n   ret m.size();\n }\n \n-fn collect_local(&@vec[tup(ident, def_id)] vars, &span sp, @ast.local loc) \n+fn collect_local(&@vec[tup(ident, def_id)] vars, &span sp, &@ast.local loc)\n     -> @decl {\n     log(\"collect_local: pushing \" + loc.ident);\n     Vec.push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n@@ -351,19 +351,20 @@ fn mk_fn_info(_fn f) -> fn_info {\n   ret res;\n }\n \n-/* extends mk_fn_info to a function item, side-effecting the map fi from \n+/* extends mk_fn_info to a function item, side-effecting the map fi from\n    function IDs to fn_info maps */\n-fn mk_fn_info_item_fn(&fn_info_map fi, &span sp, ident i, &ast._fn f,\n-                 vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n+fn mk_fn_info_item_fn(&fn_info_map fi, &span sp, &ident i, &ast._fn f,\n+                 &vec[ast.ty_param] ty_params, &def_id id, &ann a) -> @item {\n   fi.insert(id, mk_fn_info(f));\n   log(i + \" has \" + uistr(num_locals(mk_fn_info(f))) + \" local vars\");\n   ret @respan(sp, item_fn(i, f, ty_params, id, a));\n }\n \n-/* extends mk_fn_info to an obj item, side-effecting the map fi from \n+/* extends mk_fn_info to an obj item, side-effecting the map fi from\n    function IDs to fn_info maps */\n-fn mk_fn_info_item_obj(&fn_info_map fi, &span sp, ident i, &ast._obj o,\n-     vec[ast.ty_param] ty_params, ast.obj_def_ids odid, ann a) -> @item {\n+fn mk_fn_info_item_obj(&fn_info_map fi, &span sp, &ident i, &ast._obj o,\n+                       &vec[ast.ty_param] ty_params,\n+                       &ast.obj_def_ids odid, &ann a) -> @item {\n     auto all_methods = Vec.clone[@method](o.methods);\n     plus_option[@method](all_methods, o.dtor);\n     for (@method m in all_methods) {\n@@ -1251,14 +1252,15 @@ fn find_pre_post_fn(&fn_info_map fm, &fn_info fi, &_fn f) -> () {\n     find_pre_post_block(fm, fi, f.body);\n }\n \n-fn check_item_fn(&fn_info_map fm, &span sp, ident i, &ast._fn f,\n-                 vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n+fn check_item_fn(&fn_info_map fm, &span sp, &ident i, &ast._fn f,\n+                 &vec[ast.ty_param] ty_params,\n+                 &def_id id, &ann a) -> @item {\n \n     log(\"check_item_fn:\");\n     log_fn(f, i, ty_params);\n \n   assert (fm.contains_key(id));\n-  find_pre_post_fn(fm, fm.get(id), f);  \n+  find_pre_post_fn(fm, fm.get(id), f);\n \n   ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n }\n@@ -2006,9 +2008,9 @@ fn check_fn_states(&fn_info_map f_info_map, &fn_info f_info, &ast._fn f)\n     check_states_against_conditions(f_info, f);\n }\n \n-fn check_item_fn_state(&fn_info_map f_info_map, &span sp, ident i,\n-                       &ast._fn f, vec[ast.ty_param] ty_params, def_id id,\n-                       ann a) -> @item {\n+fn check_item_fn_state(&fn_info_map f_info_map, &span sp, &ident i,\n+                       &ast._fn f, &vec[ast.ty_param] ty_params,\n+                       &def_id id, &ann a) -> @item {\n \n   /* Look up the var-to-bit-num map for this function */\n   assert (f_info_map.contains_key(id));\n@@ -2026,8 +2028,9 @@ fn check_method_states(&fn_info_map f_info_map, @method m) -> () {\n     check_fn_states(f_info_map, f_info, m.node.meth);\n }\n \n-fn check_obj_state(&fn_info_map f_info_map, vec[obj_field] fields,\n-                  vec[@method] methods, Option.t[@method] dtor) -> ast._obj {\n+fn check_obj_state(&fn_info_map f_info_map, &vec[obj_field] fields,\n+                   &vec[@method] methods,\n+                   &Option.t[@method] dtor) -> ast._obj {\n     fn one(fn_info_map fm, &@method m) -> () {\n         ret check_method_states(fm, m);\n     }\n@@ -2037,7 +2040,7 @@ fn check_obj_state(&fn_info_map f_info_map, vec[obj_field] fields,\n     ret rec(fields=fields, methods=methods, dtor=dtor);\n }\n \n-fn init_ann(&fn_info fi, ann a) -> ann {\n+fn init_ann(&fn_info fi, &ann a) -> ann {\n     alt (a) {\n         case (ann_none) {\n             //            log(\"init_ann: shouldn't see ann_none\");\n@@ -2053,7 +2056,7 @@ fn init_ann(&fn_info fi, ann a) -> ann {\n     }\n }\n \n-fn init_blank_ann(&() ignore, ann a) -> ann {\n+fn init_blank_ann(&() ignore, &ann a) -> ann {\n     alt (a) {\n         case (ann_none) {\n             //            log(\"init_blank_ann: shouldn't see ann_none\");\n@@ -2492,7 +2495,7 @@ fn annotate_crate(&fn_info_map fm, &@ast.crate crate) -> @ast.crate {\n fn check_crate(@ast.crate crate) -> @ast.crate {\n   /* Build the global map from function id to var-to-bit-num-map */\n   auto fm = mk_f_to_fn_info(crate);\n-  \n+\n   /* Add a blank ts_ann to every statement (and expression) */\n   auto with_anns = annotate_crate(fm, crate);\n "}, {"sha": "2c4dcd26ee5402fa3c487b74d2ebd6b1275bdd44", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4539f8a03cfa85fae97140687bc8ed2e48d91a65/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4539f8a03cfa85fae97140687bc8ed2e48d91a65/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=4539f8a03cfa85fae97140687bc8ed2e48d91a65", "patch": "@@ -252,12 +252,12 @@ fn has_nonlocal_exits(&ast.block b) -> bool {\n     /* overkill, but just passing around a mutable bool doesn't seem\n        to work in rustboot */\n     auto has_exits = new_str_hash[()]();\n- \n-   fn set_break(&flag f, &span sp, ast.ann a) -> @ast.expr {\n+\n+   fn set_break(&flag f, &span sp, &ast.ann a) -> @ast.expr {\n         f.insert(\"foo\", ());\n         ret @respan(sp, ast.expr_break(a));\n     }\n-    fn set_cont(&flag f, &span sp, ast.ann a) -> @ast.expr {\n+    fn set_cont(&flag f, &span sp, &ast.ann a) -> @ast.expr {\n         f.insert(\"foo\", ());\n         ret @respan(sp, ast.expr_cont(a));\n     }"}]}