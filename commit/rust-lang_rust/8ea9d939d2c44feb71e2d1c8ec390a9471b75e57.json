{"sha": "8ea9d939d2c44feb71e2d1c8ec390a9471b75e57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYTlkOTM5ZDJjNDRmZWI3MWUyZDFjOGVjMzkwYTk0NzFiNzVlNTc=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-10T20:54:17Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-10T20:54:17Z"}, "message": "Rewrite `#[derive]` removal to be based on AST", "tree": {"sha": "3c7eff71e1778213524d57f4aee14bfaf9e35a68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c7eff71e1778213524d57f4aee14bfaf9e35a68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ea9d939d2c44feb71e2d1c8ec390a9471b75e57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ea9d939d2c44feb71e2d1c8ec390a9471b75e57", "html_url": "https://github.com/rust-lang/rust/commit/8ea9d939d2c44feb71e2d1c8ec390a9471b75e57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ea9d939d2c44feb71e2d1c8ec390a9471b75e57/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da08198bc94b9c51338cd94aeadc73324b373011", "url": "https://api.github.com/repos/rust-lang/rust/commits/da08198bc94b9c51338cd94aeadc73324b373011", "html_url": "https://github.com/rust-lang/rust/commit/da08198bc94b9c51338cd94aeadc73324b373011"}], "stats": {"total": 219, "additions": 112, "deletions": 107}, "files": [{"sha": "9fa419fcf149eaf3f1773349ac4e57831f9040bd", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ea9d939d2c44feb71e2d1c8ec390a9471b75e57/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea9d939d2c44feb71e2d1c8ec390a9471b75e57/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=8ea9d939d2c44feb71e2d1c8ec390a9471b75e57", "patch": "@@ -12,9 +12,9 @@ use syntax::{\n };\n \n use crate::{\n-    ast_id_map::AstIdMap, hygiene::HygieneFrame, BuiltinDeriveExpander, BuiltinFnLikeExpander,\n-    EagerCallLoc, EagerMacroId, HirFileId, HirFileIdRepr, LazyMacroId, MacroCallId, MacroCallLoc,\n-    MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n+    ast_id_map::AstIdMap, hygiene::HygieneFrame, input::process_macro_input, BuiltinDeriveExpander,\n+    BuiltinFnLikeExpander, EagerCallLoc, EagerMacroId, HirFileId, HirFileIdRepr, LazyMacroId,\n+    MacroCallId, MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n };\n \n /// Total limit on the number of tokens produced by any macro invocation.\n@@ -281,6 +281,7 @@ fn macro_arg_text(db: &dyn AstDatabase, id: MacroCallId) -> Option<GreenNode> {\n     };\n     let loc = db.lookup_intern_macro(id);\n     let arg = loc.kind.arg(db)?;\n+    let arg = process_macro_input(db, arg, id);\n     Some(arg.green().into())\n }\n "}, {"sha": "112216859cf23f3a771191ba9835f864a484b913", "filename": "crates/hir_expand/src/input.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/8ea9d939d2c44feb71e2d1c8ec390a9471b75e57/crates%2Fhir_expand%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea9d939d2c44feb71e2d1c8ec390a9471b75e57/crates%2Fhir_expand%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Finput.rs?ref=8ea9d939d2c44feb71e2d1c8ec390a9471b75e57", "patch": "@@ -0,0 +1,94 @@\n+//! Macro input conditioning.\n+\n+use syntax::{\n+    ast::{self, AttrsOwner},\n+    AstNode, SyntaxNode,\n+};\n+\n+use crate::{\n+    db::AstDatabase,\n+    name::{name, AsName},\n+    LazyMacroId, MacroCallKind, MacroCallLoc,\n+};\n+\n+pub(crate) fn process_macro_input(\n+    db: &dyn AstDatabase,\n+    node: SyntaxNode,\n+    id: LazyMacroId,\n+) -> SyntaxNode {\n+    let loc: MacroCallLoc = db.lookup_intern_macro(id);\n+\n+    match loc.kind {\n+        MacroCallKind::FnLike { .. } => node,\n+        MacroCallKind::Derive { derive_attr_index, .. } => {\n+            let item = match ast::Item::cast(node.clone()) {\n+                Some(item) => item,\n+                None => return node,\n+            };\n+\n+            remove_derives_up_to(item, derive_attr_index as usize).syntax().clone()\n+        }\n+    }\n+}\n+\n+/// Removes `#[derive]` attributes from `item`, up to `attr_index`.\n+fn remove_derives_up_to(item: ast::Item, attr_index: usize) -> ast::Item {\n+    let item = item.clone_for_update();\n+    for attr in item.attrs().take(attr_index + 1) {\n+        if let Some(name) =\n+            attr.path().and_then(|path| path.as_single_segment()).and_then(|seg| seg.name_ref())\n+        {\n+            if name.as_name() == name![derive] {\n+                attr.syntax().detach();\n+            }\n+        }\n+    }\n+    item\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use base_db::fixture::WithFixture;\n+    use base_db::SourceDatabase;\n+    use expect_test::{expect, Expect};\n+\n+    use crate::test_db::TestDB;\n+\n+    use super::*;\n+\n+    fn test_remove_derives_up_to(attr: usize, ra_fixture: &str, expect: Expect) {\n+        let (db, file_id) = TestDB::with_single_file(&ra_fixture);\n+        let parsed = db.parse(file_id);\n+\n+        let mut items: Vec<_> =\n+            parsed.syntax_node().descendants().filter_map(ast::Item::cast).collect();\n+        assert_eq!(items.len(), 1);\n+\n+        let item = remove_derives_up_to(items.pop().unwrap(), attr);\n+        expect.assert_eq(&item.to_string());\n+    }\n+\n+    #[test]\n+    fn remove_derive() {\n+        test_remove_derives_up_to(\n+            2,\n+            r#\"\n+#[allow(unused)]\n+#[derive(Copy)]\n+#[derive(Hello)]\n+#[derive(Clone)]\n+struct A {\n+    bar: u32\n+}\n+        \"#,\n+            expect![[r#\"\n+#[allow(unused)]\n+\n+\n+#[derive(Clone)]\n+struct A {\n+    bar: u32\n+}\"#]],\n+        );\n+    }\n+}"}, {"sha": "5df11856e90c366059826f05396b23c8de561ef5", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ea9d939d2c44feb71e2d1c8ec390a9471b75e57/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea9d939d2c44feb71e2d1c8ec390a9471b75e57/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=8ea9d939d2c44feb71e2d1c8ec390a9471b75e57", "patch": "@@ -14,6 +14,7 @@ pub mod builtin_macro;\n pub mod proc_macro;\n pub mod quote;\n pub mod eager;\n+mod input;\n \n use either::Either;\n \n@@ -292,8 +293,19 @@ pub struct MacroCallLoc {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum MacroCallKind {\n-    FnLike { ast_id: AstId<ast::MacroCall>, fragment: FragmentKind },\n-    Derive { ast_id: AstId<ast::Item>, derive_name: String, derive_attr_index: u32 },\n+    FnLike {\n+        ast_id: AstId<ast::MacroCall>,\n+        fragment: FragmentKind,\n+    },\n+    Derive {\n+        ast_id: AstId<ast::Item>,\n+        derive_name: String,\n+        /// Syntactical index of the invoking `#[derive]` attribute.\n+        ///\n+        /// Outer attributes are counted first, then inner attributes. This does not support\n+        /// out-of-line modules, which may have attributes spread across 2 files!\n+        derive_attr_index: u32,\n+    },\n }\n \n impl MacroCallKind {"}, {"sha": "d5643393ae2fc564e20633561001e628ea22e777", "filename": "crates/hir_expand/src/proc_macro.rs", "status": "modified", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8ea9d939d2c44feb71e2d1c8ec390a9471b75e57/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea9d939d2c44feb71e2d1c8ec390a9471b75e57/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs?ref=8ea9d939d2c44feb71e2d1c8ec390a9471b75e57", "patch": "@@ -2,7 +2,6 @@\n \n use crate::db::AstDatabase;\n use base_db::{CrateId, ProcMacroId};\n-use tt::buffer::{Cursor, TokenBuffer};\n \n #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n pub struct ProcMacroExpander {\n@@ -44,9 +43,6 @@ impl ProcMacroExpander {\n                     .clone()\n                     .ok_or_else(|| err!(\"No derive macro found.\"))?;\n \n-                let tt = remove_derive_attrs(tt)\n-                    .ok_or_else(|| err!(\"Fail to remove derive for custom derive\"))?;\n-\n                 // Proc macros have access to the environment variables of the invoking crate.\n                 let env = &krate_graph[calling_crate].env;\n \n@@ -56,101 +52,3 @@ impl ProcMacroExpander {\n         }\n     }\n }\n-\n-fn eat_punct(cursor: &mut Cursor, c: char) -> bool {\n-    if let Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(punct), _)) = cursor.token_tree() {\n-        if punct.char == c {\n-            *cursor = cursor.bump();\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-fn eat_subtree(cursor: &mut Cursor, kind: tt::DelimiterKind) -> bool {\n-    if let Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) = cursor.token_tree() {\n-        if Some(kind) == subtree.delimiter_kind() {\n-            *cursor = cursor.bump_subtree();\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-fn eat_ident(cursor: &mut Cursor, t: &str) -> bool {\n-    if let Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Ident(ident), _)) = cursor.token_tree() {\n-        if t == ident.text.as_str() {\n-            *cursor = cursor.bump();\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-fn remove_derive_attrs(tt: &tt::Subtree) -> Option<tt::Subtree> {\n-    let buffer = TokenBuffer::from_tokens(&tt.token_trees);\n-    let mut p = buffer.begin();\n-    let mut result = tt::Subtree::default();\n-\n-    while !p.eof() {\n-        let curr = p;\n-\n-        if eat_punct(&mut p, '#') {\n-            eat_punct(&mut p, '!');\n-            let parent = p;\n-            if eat_subtree(&mut p, tt::DelimiterKind::Bracket) {\n-                if eat_ident(&mut p, \"derive\") {\n-                    p = parent.bump();\n-                    continue;\n-                }\n-            }\n-        }\n-\n-        result.token_trees.push(curr.token_tree()?.cloned());\n-        p = curr.bump();\n-    }\n-\n-    Some(result)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use test_utils::assert_eq_text;\n-\n-    #[test]\n-    fn test_remove_derive_attrs() {\n-        let tt = mbe::parse_to_token_tree(\n-            r#\"\n-    #[allow(unused)]\n-    #[derive(Copy)]\n-    #[derive(Hello)]\n-    struct A {\n-        bar: u32\n-    }\n-\"#,\n-        )\n-        .unwrap()\n-        .0;\n-        let result = format!(\"{:#?}\", remove_derive_attrs(&tt).unwrap());\n-\n-        assert_eq_text!(\n-            r#\"\n-SUBTREE $\n-  PUNCH   # [alone] 0\n-  SUBTREE [] 1\n-    IDENT   allow 2\n-    SUBTREE () 3\n-      IDENT   unused 4\n-  IDENT   struct 15\n-  IDENT   A 16\n-  SUBTREE {} 17\n-    IDENT   bar 18\n-    PUNCH   : [alone] 19\n-    IDENT   u32 20\n-\"#\n-            .trim(),\n-            &result\n-        );\n-    }\n-}"}]}