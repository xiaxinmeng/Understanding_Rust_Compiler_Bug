{"sha": "6849abcf7df583f58f390eb55c7b0e84dfb1bd25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NDlhYmNmN2RmNTgzZjU4ZjM5MGViNTVjN2IwZTg0ZGZiMWJkMjU=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-02-23T16:59:07Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-02-23T16:59:07Z"}, "message": "Handle the new ty_native_fn in type check.", "tree": {"sha": "a959a4936231e978e4a29a8af3ba0f9c660cba8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a959a4936231e978e4a29a8af3ba0f9c660cba8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6849abcf7df583f58f390eb55c7b0e84dfb1bd25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6849abcf7df583f58f390eb55c7b0e84dfb1bd25", "html_url": "https://github.com/rust-lang/rust/commit/6849abcf7df583f58f390eb55c7b0e84dfb1bd25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6849abcf7df583f58f390eb55c7b0e84dfb1bd25/comments", "author": null, "committer": null, "parents": [{"sha": "3b7e9dc393c7b015bb06a8cc1213c25b8911362f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b7e9dc393c7b015bb06a8cc1213c25b8911362f", "html_url": "https://github.com/rust-lang/rust/commit/3b7e9dc393c7b015bb06a8cc1213c25b8911362f"}], "stats": {"total": 121, "additions": 96, "deletions": 25}, "files": [{"sha": "0f277329d1bc379e8cf41230c7c372a3a421a81c", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 87, "deletions": 20, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/6849abcf7df583f58f390eb55c7b0e84dfb1bd25/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6849abcf7df583f58f390eb55c7b0e84dfb1bd25/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=6849abcf7df583f58f390eb55c7b0e84dfb1bd25", "patch": "@@ -346,6 +346,14 @@ fn fold_ty(ty_fold fld, @t ty) -> @t {\n             }\n             ret rewrap(ty, ty_fn(proto, new_args, fold_ty(fld, ret_ty)));\n         }\n+        case (ty_native_fn(?args, ?ret_ty)) {\n+            let vec[arg] new_args = vec();\n+            for (arg a in args) {\n+                auto new_ty = fold_ty(fld, a.ty);\n+                new_args += vec(rec(mode=a.mode, ty=new_ty));\n+            }\n+            ret rewrap(ty, ty_native_fn(new_args, fold_ty(fld, ret_ty)));\n+        }\n         case (ty_obj(?methods)) {\n             let vec[method] new_methods = vec();\n             for (method m in methods) {\n@@ -588,6 +596,7 @@ fn count_ty_params(@t ty) -> uint {\n fn ty_fn_args(@t fty) -> vec[arg] {\n     alt (fty.struct) {\n         case (ty.ty_fn(_, ?a, _)) { ret a; }\n+        case (ty.ty_native_fn(?a, _)) { ret a; }\n     }\n }\n \n@@ -600,12 +609,14 @@ fn ty_fn_proto(@t fty) -> ast.proto {\n fn ty_fn_ret(@t fty) -> @t {\n     alt (fty.struct) {\n         case (ty.ty_fn(_, _, ?r)) { ret r; }\n+        case (ty.ty_native_fn(_, ?r)) { ret r; }\n     }\n }\n \n fn is_fn_ty(@t fty) -> bool {\n     alt (fty.struct) {\n         case (ty.ty_fn(_, _, _)) { ret true; }\n+        case (ty.ty_native_fn(_, _)) { ret true; }\n         case (_) { ret false; }\n     }\n     ret false;\n@@ -826,24 +837,23 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n         ret ures_err(terr_mismatch, expected, actual);\n     }\n \n-    fn unify_fn(@hashmap[int,@ty.t] bindings,\n-                ast.proto e_proto,\n-                ast.proto a_proto,\n-                @ty.t expected,\n-                @ty.t actual,\n-                &unify_handler handler,\n-                vec[arg] expected_inputs, @t expected_output,\n-                vec[arg] actual_inputs, @t actual_output)\n-        -> unify_result {\n-\n-        if (e_proto != a_proto) {\n-            ret ures_err(terr_mismatch, expected, actual);\n-        }\n+    tag fn_common_res {\n+        fn_common_res_err(unify_result);\n+        fn_common_res_ok(vec[arg], @t);\n+    }\n \n+    fn unify_fn_common(@hashmap[int,@ty.t] bindings,\n+                       @ty.t expected,\n+                       @ty.t actual,\n+                       &unify_handler handler,\n+                       vec[arg] expected_inputs, @t expected_output,\n+                       vec[arg] actual_inputs, @t actual_output)\n+        -> fn_common_res {\n         auto expected_len = _vec.len[arg](expected_inputs);\n         auto actual_len = _vec.len[arg](actual_inputs);\n         if (expected_len != actual_len) {\n-            ret ures_err(terr_arg_count, expected, actual);\n+            ret fn_common_res_err(ures_err(terr_arg_count,\n+                                           expected, actual));\n         }\n \n         // TODO: as above, we should have an iter2 iterator.\n@@ -874,32 +884,75 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                 }\n \n                 case (_) {\n-                    ret result;\n+                    ret fn_common_res_err(result);\n                 }\n             }\n \n             i += 1u;\n         }\n \n         // Check the output.\n-        auto result_out;\n         auto result = unify_step(bindings,\n                                  expected_output,\n                                  actual_output,\n                                  handler);\n         alt (result) {\n             case (ures_ok(?rty)) {\n-                result_out = rty;\n+                ret fn_common_res_ok(result_ins, rty);\n             }\n \n             case (_) {\n-                ret result;\n+                ret fn_common_res_err(result);\n             }\n         }\n+    }\n \n-        auto t = plain_ty(ty.ty_fn(e_proto, result_ins, result_out));\n-        ret ures_ok(t);\n+    fn unify_fn(@hashmap[int,@ty.t] bindings,\n+                ast.proto e_proto,\n+                ast.proto a_proto,\n+                @ty.t expected,\n+                @ty.t actual,\n+                &unify_handler handler,\n+                vec[arg] expected_inputs, @t expected_output,\n+                vec[arg] actual_inputs, @t actual_output)\n+        -> unify_result {\n \n+        if (e_proto != a_proto) {\n+            ret ures_err(terr_mismatch, expected, actual);\n+        }\n+        auto t = unify_fn_common(bindings, expected, actual,\n+                                 handler, expected_inputs, expected_output,\n+                                 actual_inputs, actual_output);\n+        alt (t) {\n+            case (fn_common_res_err(?r)) {\n+                ret r;\n+            }\n+            case (fn_common_res_ok(?result_ins, ?result_out)) {\n+                auto t2 = plain_ty(ty.ty_fn(e_proto, result_ins, result_out));\n+                ret ures_ok(t2);\n+            }\n+        }\n+    }\n+\n+    fn unify_native_fn(@hashmap[int,@ty.t] bindings,\n+                       @ty.t expected,\n+                       @ty.t actual,\n+                       &unify_handler handler,\n+                       vec[arg] expected_inputs, @t expected_output,\n+                       vec[arg] actual_inputs, @t actual_output)\n+        -> unify_result {\n+        auto t = unify_fn_common(bindings, expected, actual,\n+                                 handler, expected_inputs, expected_output,\n+                                 actual_inputs, actual_output);\n+        alt (t) {\n+            case (fn_common_res_err(?r)) {\n+                ret r;\n+            }\n+            case (fn_common_res_ok(?result_ins, ?result_out)) {\n+                auto t2 = plain_ty(ty.ty_native_fn(result_ins, result_out));\n+                ret ures_ok(t2);\n+            }\n+        }\n     }\n \n     fn unify_obj(@hashmap[int,@ty.t] bindings,\n@@ -1258,6 +1311,20 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                 }\n             }\n \n+            case (ty.ty_native_fn(?expected_inputs, ?expected_output)) {\n+                alt (actual.struct) {\n+                    case (ty.ty_native_fn(?actual_inputs, ?actual_output)) {\n+                        ret unify_native_fn(bindings,\n+                                            expected, actual, handler,\n+                                            expected_inputs, expected_output,\n+                                            actual_inputs, actual_output);\n+                    }\n+                    case (_) {\n+                        ret ures_err(terr_mismatch, expected, actual);\n+                    }\n+                }\n+            }\n+\n             case (ty.ty_obj(?expected_meths)) {\n                 alt (actual.struct) {\n                     case (ty.ty_obj(?actual_meths)) {"}, {"sha": "0d583c5e41876fd64d6a2f8be24a30fd1c94fbb7", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6849abcf7df583f58f390eb55c7b0e84dfb1bd25/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6849abcf7df583f58f390eb55c7b0e84dfb1bd25/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=6849abcf7df583f58f390eb55c7b0e84dfb1bd25", "patch": "@@ -1336,18 +1336,21 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             }\n         }\n \n-        auto proto_0 = ast.proto_fn;    // FIXME: typestate botch\n+        auto rt_0 = next_ty_var(fcx.ccx);\n+        auto t_0 = plain_ty(ty.ty_uint); // FIXME: typestate botch\n         alt (expr_ty(f_0).struct) {\n-            case (ty.ty_fn(?proto, _, _))   { proto_0 = proto; }\n+            case (ty.ty_fn(?proto, _, _))   {\n+                t_0 = plain_ty(ty.ty_fn(proto, arg_tys_0, rt_0));\n+            }\n+            case (ty.ty_native_fn(_, _))   {\n+                t_0 = plain_ty(ty.ty_native_fn(arg_tys_0, rt_0));\n+            }\n             case (_) {\n                 log \"check_call_or_bind(): fn expr doesn't have fn type\";\n                 fail;\n             }\n         }\n \n-        auto rt_0 = next_ty_var(fcx.ccx);\n-        auto t_0 = plain_ty(ty.ty_fn(proto_0, arg_tys_0, rt_0));\n-\n         // Unify and write back to the function.\n         auto f_1 = demand_expr(fcx, t_0, f_0);\n \n@@ -1824,6 +1827,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto rt_1 = plain_ty(ty.ty_nil);    // FIXME: typestate botch\n             alt (expr_ty(result._0).struct) {\n                 case (ty.ty_fn(_,_,?rt))    { rt_1 = rt; }\n+                case (ty.ty_native_fn(_,?rt))    { rt_1 = rt; }\n                 case (_) {\n                     log \"LHS of call expr didn't have a function type?!\";\n                     fail;"}]}