{"sha": "3aaf02b9075101086fba0d4491a3ad03d749fc84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYWYwMmI5MDc1MTAxMDg2ZmJhMGQ0NDkxYTNhZDAzZDc0OWZjODQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-16T17:34:32Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-16T17:34:32Z"}, "message": "rustc: Make the type collection pass no longer rebuild the AST", "tree": {"sha": "f75aad281b5ce5df4838d65897ebf209057dc61a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f75aad281b5ce5df4838d65897ebf209057dc61a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3aaf02b9075101086fba0d4491a3ad03d749fc84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3aaf02b9075101086fba0d4491a3ad03d749fc84", "html_url": "https://github.com/rust-lang/rust/commit/3aaf02b9075101086fba0d4491a3ad03d749fc84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3aaf02b9075101086fba0d4491a3ad03d749fc84/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "525a5c582fe7cf5b805cf2ff8bd5398da5bee422", "url": "https://api.github.com/repos/rust-lang/rust/commits/525a5c582fe7cf5b805cf2ff8bd5398da5bee422", "html_url": "https://github.com/rust-lang/rust/commit/525a5c582fe7cf5b805cf2ff8bd5398da5bee422"}], "stats": {"total": 342, "additions": 129, "deletions": 213}, "files": [{"sha": "4fb836873880cc448d3fd04da99867054c061bc8", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 129, "deletions": 213, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/3aaf02b9075101086fba0d4491a3ad03d749fc84/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aaf02b9075101086fba0d4491a3ad03d749fc84/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=3aaf02b9075101086fba0d4491a3ad03d749fc84", "patch": "@@ -395,14 +395,18 @@ fn write_nil_type(ty::ctxt tcx, &node_type_table ntt, uint node_id) {\n \n // Item collection - a pair of bootstrap passes:\n //\n-// 1. Collect the IDs of all type items (typedefs) and store them in a table.\n+// (1) Collect the IDs of all type items (typedefs) and store them in a table.\n //\n-// 2. Translate the AST fragments that describe types to determine a type for\n-//    each item. When we encounter a named type, we consult the table built in\n-//    pass 1 to find its item, and recursively translate it.\n+// (2) Translate the AST fragments that describe types to determine a type for\n+//     each item. When we encounter a named type, we consult the table built\n+//     in pass 1 to find its item, and recursively translate it.\n //\n // We then annotate the AST with the resulting types and return the annotated\n // AST, along with a table mapping item IDs to their types.\n+//\n+// TODO: This logic is quite convoluted; it's a relic of the time when we\n+// actually wrote types directly into the AST and didn't have a type cache.\n+// Could use some cleanup. Consider topologically sorting in phase (1) above.\n \n mod collect {\n     type ctxt = rec(session::session sess,\n@@ -451,8 +455,6 @@ mod collect {\n             ret creader::get_type(cx.sess, cx.tcx, id);\n         }\n \n-        // assert (cx.id_to_ty_item.contains_key(id));\n-\n         auto it = cx.id_to_ty_item.get(id);\n         auto tpt;\n         alt (it) {\n@@ -485,9 +487,7 @@ mod collect {\n                  &ast::ident id,\n                  &ast::_obj obj_info,\n                  &vec[ast::ty_param] ty_params) -> ty::ty_param_count_and_ty {\n-        auto f = bind ty_of_method(cx, _);\n-        auto methods = _vec::map[@ast::method,method](f, obj_info.methods);\n-\n+        auto methods = get_obj_method_types(cx, obj_info);\n         auto t_obj = ty::mk_obj(cx.tcx, ty::sort_methods(methods));\n         t_obj = ty::rename(cx.tcx, t_obj, id);\n         auto ty_param_count = _vec::len[ast::ty_param](ty_params);\n@@ -497,21 +497,23 @@ mod collect {\n     fn ty_of_obj_ctor(@ctxt cx,\n                       &ast::ident id,\n                       &ast::_obj obj_info,\n-                      &ast::def_id obj_ty_id,\n+                      &ast::def_id ctor_id,\n                       &vec[ast::ty_param] ty_params)\n             -> ty::ty_param_count_and_ty {\n         auto t_obj = ty_of_obj(cx, id, obj_info, ty_params);\n+\n         let vec[arg] t_inputs = vec();\n         for (ast::obj_field f in obj_info.fields) {\n             auto g = bind getter(cx, _);\n             auto t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n             _vec::push[arg](t_inputs, rec(mode=ty::mo_alias, ty=t_field));\n         }\n \n-        cx.type_cache.insert(obj_ty_id, t_obj);\n-\n         auto t_fn = ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1);\n-        ret tup(t_obj._0, t_fn);\n+\n+        auto tpt = tup(t_obj._0, t_fn);\n+        cx.type_cache.insert(ctor_id, tpt);\n+        ret tpt;\n     }\n \n     fn ty_of_item(&@ctxt cx, &@ast::item it) -> ty::ty_param_count_and_ty {\n@@ -535,10 +537,9 @@ mod collect {\n             }\n \n             case (ast::item_obj(?ident, ?obj_info, ?tps, ?odid, _)) {\n-                auto t_ctor = ty_of_obj_ctor(cx, ident, obj_info, odid.ty,\n-                                             tps);\n-                cx.type_cache.insert(odid.ctor, t_ctor);\n-                ret cx.type_cache.get(odid.ty);\n+                auto t_obj = ty_of_obj(cx, ident, obj_info, tps);\n+                cx.type_cache.insert(odid.ty, t_obj);\n+                ret t_obj;\n             }\n \n             case (ast::item_ty(?ident, ?t, ?tps, ?def_id, _)) {\n@@ -658,6 +659,11 @@ mod collect {\n         ret result;\n     }\n \n+    fn get_obj_method_types(&@ctxt cx, &ast::_obj object) -> vec[method] {\n+        ret _vec::map[@ast::method,method](bind ty_of_method(cx, _),\n+                                           object.methods);\n+    }\n+\n     fn collect(&@ty_item_table id_to_ty_item, &@ast::item i) {\n         alt (i.node) {\n             case (ast::item_ty(_, _, _, ?def_id, _)) {\n@@ -684,193 +690,107 @@ mod collect {\n         }\n     }\n \n-    fn convert(&@env e, &@ast::item i) -> @env {\n-        auto abi = e.abi;\n-        alt (i.node) {\n+    fn convert(@ctxt cx, @mutable option::t[ast::native_abi] abi,\n+               &@ast::item it) {\n+        alt (it.node) {\n             case (ast::item_mod(_, _, _)) {\n                 // ignore item_mod, it has no type.\n             }\n             case (ast::item_native_mod(_, ?native_mod, _)) {\n-                // ignore item_native_mod, it has no type.\n-                abi = native_mod.abi;\n-            }\n-            case (_) {\n-                // This call populates the ty_table with the converted type of\n-                // the item in passing; we don't need to do anything else.\n-                ty_of_item(e.cx, i);\n-            }\n-        }\n-        ret @rec(abi=abi with *e);\n-    }\n-\n-    fn convert_native(&@env e, &@ast::native_item i) -> @env {\n-        ty_of_native_item(e.cx, i, e.abi);\n-        ret e;\n-    }\n-\n-    fn fold_item_const(&@env e, &span sp, &ast::ident i,\n-                       &@ast::ty t, &@ast::expr ex,\n-                       &ast::def_id id, &ast::ann a) -> @ast::item {\n-        // assert (e.cx.type_cache.contains_key(id));\n-        auto typ = e.cx.type_cache.get(id)._1;\n-        auto item = ast::item_const(i, t, ex, id,\n-                                    triv_ann(ast::ann_tag(a), typ));\n-        write_type_only(e.cx.node_types, ast::ann_tag(a), typ);\n-        ret @fold::respan[ast::item_](sp, item);\n-    }\n-\n-    fn fold_item_fn(&@env e, &span sp, &ast::ident i,\n-                    &ast::_fn f, &vec[ast::ty_param] ty_params,\n-                    &ast::def_id id, &ast::ann a) -> @ast::item {\n-        // assert (e.cx.type_cache.contains_key(id));\n-        auto typ = e.cx.type_cache.get(id)._1;\n-        auto item = ast::item_fn(i, f, ty_params, id,\n-                                 triv_ann(ast::ann_tag(a), typ));\n-        write_type_only(e.cx.node_types, ast::ann_tag(a), typ);\n-        ret @fold::respan[ast::item_](sp, item);\n-    }\n-\n-    fn fold_native_item_fn(&@env e, &span sp, &ast::ident i,\n-                           &option::t[str] ln,\n-                           &ast::fn_decl d, &vec[ast::ty_param] ty_params,\n-                           &ast::def_id id, &ast::ann a) -> @ast::native_item{\n-        // assert (e.cx.type_cache.contains_key(id));\n-        auto typ = e.cx.type_cache.get(id)._1;\n-        auto item = ast::native_item_fn(i, ln, d, ty_params, id,\n-                                        triv_ann(ast::ann_tag(a), typ));\n-        write_type_only(e.cx.node_types, ast::ann_tag(a), typ);\n-        ret @fold::respan[ast::native_item_](sp, item);\n-    }\n-\n-    fn get_ctor_obj_methods(&@env e, &ty::t t) -> vec[method] {\n-        alt (struct(e.cx.tcx, t)) {\n-            case (ty::ty_fn(_,_,?tobj)) {\n-                alt (struct(e.cx.tcx, tobj)) {\n-                    case (ty::ty_obj(?tm)) {\n-                        ret tm;\n-                    }\n-                    case (_) {\n-                        let vec[method] tm = vec();\n-                        ret tm;\n+                // Propagate the native ABI down to convert_native() below,\n+                // but otherwise do nothing, as native modules have no types.\n+                *abi = some[ast::native_abi](native_mod.abi);\n+            }\n+            case (ast::item_tag(_, ?variants, ?ty_params, ?tag_id, ?ann)) {\n+                auto tpt = ty_of_item(cx, it);\n+                write_type_only(cx.node_types, ast::ann_tag(ann), tpt._1);\n+\n+                get_tag_variant_types(cx, tag_id, variants, ty_params);\n+            }\n+            case (ast::item_obj(?ident, ?object, ?ty_params, ?odid, ?ann)) {\n+                // This calls ty_of_obj().\n+                auto t_obj = ty_of_item(cx, it);\n+\n+                // Now we need to call ty_of_obj_ctor(); this is the type that\n+                // we write into the table for this item.\n+                auto tpt = ty_of_obj_ctor(cx, ident, object, odid.ctor,\n+                                          ty_params);\n+                write_type_only(cx.node_types, ast::ann_tag(ann), tpt._1);\n+\n+                // Write the methods into the type table.\n+                //\n+                // FIXME: Inefficient; this ends up calling\n+                // get_obj_method_types() twice. (The first time was above in\n+                // ty_of_obj().)\n+                auto method_types = get_obj_method_types(cx, object);\n+                auto i = 0u;\n+                while (i < _vec::len[@ast::method](object.methods)) {\n+                    write_type_only(cx.node_types,\n+                                    ast::ann_tag(object.methods.(i).node.ann),\n+                                    ty::method_ty_to_fn_ty(cx.tcx,\n+                                        method_types.(i)));\n+                    i += 1u;\n+                }\n+\n+                // Write in the types of the object fields.\n+                //\n+                // FIXME: We want to use _uint::range() here, but that causes\n+                // an assertion in trans.\n+                auto args = ty::ty_fn_args(cx.tcx, tpt._1);\n+                i = 0u;\n+                while (i < _vec::len[ty::arg](args)) {\n+                    auto fld = object.fields.(i);\n+                    write_type_only(cx.node_types, ast::ann_tag(fld.ann),\n+                                    args.(i).ty);\n+                    i += 1u;\n+                }\n+\n+                // Finally, write in the type of the destructor.\n+                alt (object.dtor) {\n+                    case (none[@ast::method]) { /* nothing to do */ }\n+                    case (some[@ast::method](?m)) {\n+                        // TODO: typechecker botch\n+                        let vec[arg] no_args = vec();\n+                        auto t = ty::mk_fn(cx.tcx, ast::proto_fn, no_args,\n+                                           ty::mk_nil(cx.tcx));\n+                        write_type_only(cx.node_types,\n+                                        ast::ann_tag(m.node.ann), t);\n                     }\n                 }\n             }\n             case (_) {\n-                let vec[method] tm = vec();\n-                ret tm;\n-            }\n-        }\n-    }\n-\n-    // Anonymous objects are expressions, not items, but they're enough like\n-    // items that we're going to include them in this fold.\n-    fn fold_expr_anon_obj(&@env e, &span sp,\n-                          &ast::anon_obj ob, &vec[ast::ty_param] tps,\n-                          &ast::obj_def_ids odid, &ast::ann a) -> @ast::expr {\n-\n-        // TODO: Somewhere in here we need to push some stuff onto a vector.\n-\n-        auto expr_anon_obj = ast::expr_anon_obj(ob, tps, odid, a);\n-        ret @fold::respan[ast::expr_](sp, expr_anon_obj);\n-    }\n-\n-    fn fold_item_obj(&@env e, &span sp, &ast::ident i,\n-                    &ast::_obj ob, &vec[ast::ty_param] ty_params,\n-                    &ast::obj_def_ids odid, &ast::ann a) -> @ast::item {\n-        // assert (e.cx.type_cache.contains_key(odid.ctor));\n-        auto t = e.cx.type_cache.get(odid.ctor)._1;\n-        let vec[method] meth_tys = get_ctor_obj_methods(e, t);\n-        let vec[@ast::method] methods = vec();\n-        let vec[ast::obj_field] fields = vec();\n-\n-        for (@ast::method meth in ob.methods) {\n-            let uint ix = ty::method_idx(e.cx.sess,\n-                                        sp, meth.node.ident,\n-                                        meth_tys);\n-            let method meth_ty = meth_tys.(ix);\n-            let ast::method_ m_;\n-            let @ast::method m;\n-            auto meth_tfn = ty::mk_fn(e.cx.tcx,\n-                                      meth_ty.proto,\n-                                      meth_ty.inputs,\n-                                      meth_ty.output);\n-            m_ = rec(ann=triv_ann(ast::ann_tag(meth.node.ann), meth_tfn)\n-                     with meth.node\n-            );\n-            m = @rec(node=m_ with *meth);\n-            write_type_only(e.cx.node_types, ast::ann_tag(meth.node.ann),\n-                            meth_tfn);\n-            _vec::push[@ast::method](methods, m);\n-        }\n-        auto g = bind getter(e.cx, _);\n-        for (ast::obj_field fld in ob.fields) {\n-            let ty::t fty = ast_ty_to_ty(e.cx.tcx, g, fld.ty);\n-            let ast::obj_field f =\n-                rec(ann=triv_ann(ast::ann_tag(fld.ann), fty) with fld);\n-            write_type_only(e.cx.node_types, ast::ann_tag(fld.ann), fty);\n-            _vec::push[ast::obj_field](fields, f);\n-        }\n-\n-        auto dtor = none[@ast::method];\n-        alt (ob.dtor) {\n-            case (some[@ast::method](?d)) {\n-                let vec[arg] inputs = vec();\n-                let ty::t output = ty::mk_nil(e.cx.tcx);\n-                auto dtor_tfn = ty::mk_fn(e.cx.tcx, ast::proto_fn, inputs,\n-                                         output);\n-                auto d_ = rec(\n-                    ann=triv_ann(ast::ann_tag(d.node.ann), dtor_tfn)\n-                    with d.node\n-                );\n-                write_type_only(e.cx.node_types, ast::ann_tag(d.node.ann),\n-                                dtor_tfn);\n-                dtor = some[@ast::method](@rec(node=d_ with *d));\n-            }\n-            case (none[@ast::method]) { }\n-        }\n-\n-        auto ob_ = rec(methods = methods,\n-                       fields = fields,\n-                       dtor = dtor\n-                       with ob);\n-        auto item = ast::item_obj(i, ob_, ty_params, odid,\n-                                  triv_ann(ast::ann_tag(a), t));\n-        write_type_only(e.cx.node_types, ast::ann_tag(a), t);\n-        ret @fold::respan[ast::item_](sp, item);\n-    }\n-\n-    fn fold_item_ty(&@env e, &span sp, &ast::ident i,\n-                    &@ast::ty t, &vec[ast::ty_param] ty_params,\n-                    &ast::def_id id, &ast::ann a) -> @ast::item {\n-        // assert (e.cx.type_cache.contains_key(id));\n-        auto typ = e.cx.type_cache.get(id)._1;\n-        auto item = ast::item_ty(i, t, ty_params, id,\n-                                 triv_ann(ast::ann_tag(a), typ));\n-        write_type_only(e.cx.node_types, ast::ann_tag(a), typ);\n-        ret @fold::respan[ast::item_](sp, item);\n-    }\n-\n-    fn fold_item_tag(&@env e, &span sp, &ast::ident i,\n-                     &vec[ast::variant] variants,\n-                     &vec[ast::ty_param] ty_params,\n-                     &ast::def_id id, &ast::ann a) -> @ast::item {\n-        auto variants_t = get_tag_variant_types(e.cx, id, variants,\n-                                                ty_params);\n-        auto typ = e.cx.type_cache.get(id)._1;\n-        auto item = ast::item_tag(i, variants_t, ty_params, id,\n-                                  ast::ann_type(ast::ann_tag(a), typ,\n-                                                none[vec[ty::t]],\n-                                                none[@ts_ann]));\n-        write_type(e.cx.node_types, ast::ann_tag(a),\n-                   tup(none[vec[ty::t]], typ));\n-        ret @fold::respan[ast::item_](sp, item);\n+                // This call populates the type cache with the converted type\n+                // of the item in passing. All we have to do here is to write\n+                // it into the node type table.\n+                auto tpt = ty_of_item(cx, it);\n+                write_type_only(cx.node_types, ast::ann_tag(ty::item_ann(it)),\n+                                tpt._1);\n+            }\n+        }\n+    }\n+\n+    fn convert_native(@ctxt cx, @mutable option::t[ast::native_abi] abi,\n+                      &@ast::native_item i) {\n+        // As above, this call populates the type table with the converted\n+        // type of the native item. We simply write it into the node type\n+        // table.\n+        auto tpt = ty_of_native_item(cx, i,\n+                                     option::get[ast::native_abi](*abi));\n+\n+        alt (i.node) {\n+            case (ast::native_item_ty(_,_)) {\n+                // FIXME: Native types have no annotation. Should they? --pcw\n+            }\n+            case (ast::native_item_fn(_,_,_,_,_,?a)) {\n+                write_type_only(cx.node_types, ast::ann_tag(a), tpt._1);\n+            }\n+        }\n     }\n \n     fn collect_item_types(&session::session sess, &ty::ctxt tcx,\n                           &@ast::crate crate)\n-            -> tup(@ast::crate, ty::type_cache, @ty_item_table,\n-                   node_type_table) {\n-        // First pass: collect all type item IDs:\n+            -> tup(ty::type_cache, @ty_item_table, node_type_table) {\n+        // First pass: collect all type item IDs.\n         auto module = crate.node.module;\n         auto id_to_ty_item = @common::new_def_hash[any_item]();\n \n@@ -888,29 +808,24 @@ mod collect {\n         // Second pass: translate the types of all items.\n         auto type_cache = common::new_def_hash[ty::ty_param_count_and_ty]();\n \n+        // We have to propagate the surrounding ABI to the native items\n+        // contained within the native module.\n+        auto abi = @mutable none[ast::native_abi];\n+\n         auto cx = @rec(sess=sess,\n                        id_to_ty_item=id_to_ty_item,\n                        type_cache=type_cache,\n                        tcx=tcx,\n                        node_types=ntt);\n \n-        let @env e = @rec(cx=cx, abi=ast::native_abi_cdecl);\n-\n-        auto fld_2 = fold::new_identity_fold[@env]();\n-        fld_2 =\n-            @rec(update_env_for_item = bind convert(_,_),\n-                 update_env_for_native_item = bind convert_native(_,_),\n-                 fold_item_const = bind fold_item_const(_,_,_,_,_,_,_),\n-                 fold_item_fn    = bind fold_item_fn(_,_,_,_,_,_,_),\n-                 fold_native_item_fn =\n-                    bind fold_native_item_fn(_,_,_,_,_,_,_,_),\n-                 fold_item_obj   = bind fold_item_obj(_,_,_,_,_,_,_),\n-                 fold_item_ty    = bind fold_item_ty(_,_,_,_,_,_,_),\n-                 fold_item_tag   = bind fold_item_tag(_,_,_,_,_,_,_),\n-                 fold_expr_anon_obj = bind fold_expr_anon_obj(_,_,_,_,_,_)\n-                 with *fld_2);\n-        auto crate_ = fold::fold_crate[@env](e, fld_2, crate);\n-        ret tup(crate_, type_cache, id_to_ty_item, ntt);\n+        visit = rec(\n+            visit_item_pre = bind convert(cx,abi,_),\n+            visit_native_item_pre = bind convert_native(cx,abi,_)\n+            with walk::default_visitor()\n+        );\n+        walk::walk_crate(visit, *crate);\n+\n+        ret tup(type_cache, id_to_ty_item, ntt);\n     }\n }\n \n@@ -2132,6 +2047,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             if (ty::def_has_ty_params(defn)) {\n                 auto path_tpot = instantiate_path(fcx, pth, tpt, expr.span);\n+                auto did = ast::def_id_of_def(defn);\n                 write_type(fcx.ccx.node_types, ast::ann_tag(old_ann),\n                            path_tpot);\n                 ret @fold::respan[ast::expr_](expr.span,\n@@ -3304,11 +3220,11 @@ fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n     auto unify_cache =\n         map::mk_hashmap[unify_cache_entry,ty::unify::result](hasher, eqer);\n     auto fpt = mk_fn_purity_table(crate); // use a variation on collect\n-    let node_type_table node_types = result._3;\n+    let node_type_table node_types = result._2;\n \n     auto ccx = @rec(sess=sess,\n-                    type_cache=result._1,\n-                    item_items=result._2,\n+                    type_cache=result._0,\n+                    item_items=result._1,\n                     obj_fields=fields,\n                     this_obj=none[ast::def_id],\n                     fn_purity_table = fpt,\n@@ -3326,7 +3242,7 @@ fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n                fold_item_fn = bind check_item_fn(_,_,_,_,_,_,_)\n                with *fld);\n \n-    auto crate_1 = fold::fold_crate[@crate_ctxt](ccx, fld, result._0);\n+    auto crate_1 = fold::fold_crate[@crate_ctxt](ccx, fld, crate);\n \n     log #fmt(\"cache hit rate: %u/%u\", ccx.cache_hits,\n              ccx.cache_hits + ccx.cache_misses);"}]}