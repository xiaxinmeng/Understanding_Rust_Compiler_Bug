{"sha": "e447b54bc3d7b2df8dd1326b09cefad31d2e4153", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NDdiNTRiYzNkN2IyZGY4ZGQxMzI2YjA5Y2VmYWQzMWQyZTQxNTM=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "nashenas88@users.noreply.github.com", "date": "2017-11-21T23:03:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:04:50Z"}, "message": "Add tracking of causes for nll", "tree": {"sha": "74182b5ae885104a0e5daa80c34a54d41565a948", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74182b5ae885104a0e5daa80c34a54d41565a948"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e447b54bc3d7b2df8dd1326b09cefad31d2e4153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e447b54bc3d7b2df8dd1326b09cefad31d2e4153", "html_url": "https://github.com/rust-lang/rust/commit/e447b54bc3d7b2df8dd1326b09cefad31d2e4153", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6741d0a7a434ea108e2f26b7e50e028f1302604", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6741d0a7a434ea108e2f26b7e50e028f1302604", "html_url": "https://github.com/rust-lang/rust/commit/f6741d0a7a434ea108e2f26b7e50e028f1302604"}], "stats": {"total": 224, "additions": 185, "deletions": 39}, "files": [{"sha": "bdacd831cb656ec9699db3e48c2755da99494de1", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=e447b54bc3d7b2df8dd1326b09cefad31d2e4153", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::subst::Substs;\n use rustc::ty::fold::TypeFoldable;\n \n use super::ToRegionVid;\n-use super::region_infer::RegionInferenceContext;\n+use super::region_infer::{RegionInferenceContext, Cause};\n \n pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n@@ -53,14 +53,14 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n     /// We sometimes have `substs` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_substs(&mut self, substs: &&'tcx Substs<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*substs, location);\n+        self.add_regular_live_constraint(*substs, location, Cause::LiveOther(location));\n         self.super_substs(substs);\n     }\n \n     /// We sometimes have `region` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_region(&mut self, region: &ty::Region<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*region, location);\n+        self.add_regular_live_constraint(*region, location, Cause::LiveOther(location));\n         self.super_region(region);\n     }\n \n@@ -75,7 +75,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n                           ty_context);\n             }\n             TyContext::Location(location) => {\n-                self.add_regular_live_constraint(*ty, location);\n+                self.add_regular_live_constraint(*ty, location, Cause::LiveOther(location));\n             }\n         }\n \n@@ -85,7 +85,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n     /// We sometimes have `closure_substs` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_closure_substs(&mut self, substs: &ClosureSubsts<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*substs, location);\n+        self.add_regular_live_constraint(*substs, location, Cause::LiveOther(location));\n         self.super_closure_substs(substs);\n     }\n \n@@ -112,7 +112,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at\n     /// `location`.\n-    fn add_regular_live_constraint<T>(&mut self, live_ty: T, location: Location)\n+    fn add_regular_live_constraint<T>(&mut self, live_ty: T, location: Location, cause: Cause)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -126,7 +126,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             .tcx\n             .for_each_free_region(&live_ty, |live_region| {\n                 let vid = live_region.to_region_vid();\n-                self.regioncx.add_live_point(vid, location);\n+                self.regioncx.add_live_point(vid, location, &cause);\n             });\n     }\n "}, {"sha": "d55b601823245d55dbb5e1110846a8d5e6848c3a", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dfs.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs?ref=e447b54bc3d7b2df8dd1326b09cefad31d2e4153", "patch": "@@ -15,6 +15,7 @@ use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::region_infer::values::{RegionElementIndex, RegionValueElements,\n                                               RegionValues};\n+use syntax::codemap::Span;\n use rustc::mir::{Location, Mir};\n use rustc::ty::RegionVid;\n use rustc_data_structures::fx::FxHashSet;\n@@ -127,6 +128,7 @@ pub(super) struct CopyFromSourceToTarget<'v> {\n     pub target_region: RegionVid,\n     pub inferred_values: &'v mut RegionValues,\n     pub constraint_point: Location,\n+    pub constraint_span: Span,\n }\n \n impl<'v> DfsOp for CopyFromSourceToTarget<'v> {\n@@ -143,14 +145,22 @@ impl<'v> DfsOp for CopyFromSourceToTarget<'v> {\n     }\n \n     fn add_to_target_region(&mut self, point_index: RegionElementIndex) -> Result<bool, !> {\n-        Ok(self.inferred_values.add(self.target_region, point_index))\n+        Ok(self.inferred_values.add_due_to_outlives(\n+            self.source_region,\n+            self.target_region,\n+            point_index,\n+            self.constraint_point,\n+            self.constraint_span,\n+        ))\n     }\n \n     fn add_universal_regions_outlived_by_source_to_target(&mut self) -> Result<bool, !> {\n-        Ok(\n-            self.inferred_values\n-                .add_universal_regions_outlived_by(self.source_region, self.target_region),\n-        )\n+        Ok(self.inferred_values.add_universal_regions_outlived_by(\n+            self.source_region,\n+            self.target_region,\n+            self.constraint_point,\n+            self.constraint_span,\n+        ))\n     }\n }\n "}, {"sha": "28cb1489c43feb082a5522d669be12211a891a1f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 62, "deletions": 8, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=e447b54bc3d7b2df8dd1326b09cefad31d2e4153", "patch": "@@ -17,7 +17,7 @@ use rustc::infer::RegionVariableOrigin;\n use rustc::infer::SubregionOrigin;\n use rustc::infer::region_constraints::{GenericKind, VarOrigins};\n use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-                 Location, Mir};\n+                 Local, Location, Mir};\n use rustc::traits::ObligationCause;\n use rustc::ty::{self, RegionVid, Ty, TypeFoldable};\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -65,6 +65,8 @@ pub struct RegionInferenceContext<'tcx> {\n     universal_regions: UniversalRegions<'tcx>,\n }\n \n+struct TrackCauses(bool);\n+\n struct RegionDefinition<'tcx> {\n     /// Why we created this variable. Mostly these will be\n     /// `RegionVariableOrigin::NLL`, but some variables get created\n@@ -83,6 +85,38 @@ struct RegionDefinition<'tcx> {\n     external_name: Option<ty::Region<'tcx>>,\n }\n \n+/// NB: The variants in `Cause` are intentionally ordered. Lower\n+/// values are preferred when it comes to error messages. Do not\n+/// reorder willy nilly.\n+#[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+pub(crate) enum Cause {\n+    /// point inserted because Local was live at the given Location\n+    LiveVar(Local, Location),\n+\n+    /// point inserted because Local was dropped at the given Location\n+    DropVar(Local, Location),\n+\n+    /// point inserted because the type was live at the given Location,\n+    /// but not as part of some local variable\n+    LiveOther(Location),\n+\n+    /// part of the initial set of values for a universally quantified region\n+    UniversalRegion,\n+\n+    /// Element E was added to R because there was some\n+    /// outlives obligation `R: R1 @ P` and `R1` contained `E`.\n+    Outlives {\n+        /// the reason that R1 had E\n+        original_cause: Rc<Cause>,\n+\n+        /// the point P from the relation\n+        constraint_location: Location,\n+\n+        /// The span indicating why we added the outlives constraint.\n+        constraint_span: Span,\n+    },\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Constraint {\n     // NB. The ordering here is not significant for correctness, but\n@@ -212,7 +246,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mut result = Self {\n             definitions,\n             elements: elements.clone(),\n-            liveness_constraints: RegionValues::new(elements, num_region_variables),\n+            liveness_constraints: RegionValues::new(\n+                elements,\n+                num_region_variables,\n+                TrackCauses(true),\n+            ),\n             inferred_values: None,\n             constraints: Vec::new(),\n             type_tests: Vec::new(),\n@@ -262,11 +300,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             // Add all nodes in the CFG to liveness constraints\n             for point_index in self.elements.all_point_indices() {\n-                self.liveness_constraints.add(variable, point_index);\n+                self.liveness_constraints.add(variable, point_index, &Cause::UniversalRegion);\n             }\n \n             // Add `end(X)` into the set for X.\n-            self.liveness_constraints.add(variable, variable);\n+            self.liveness_constraints.add(variable, variable, &Cause::UniversalRegion);\n         }\n     }\n \n@@ -306,13 +344,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// Returns `true` if this constraint is new and `false` is the\n     /// constraint was already present.\n-    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location) -> bool {\n+    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location, cause: &Cause) -> bool {\n         debug!(\"add_live_point({:?}, {:?})\", v, point);\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n-        debug!(\"add_live_point: @{:?}\", point);\n+        debug!(\"add_live_point: @{:?} Adding cause {:?}\", point, cause);\n \n         let element = self.elements.index(point);\n-        if self.liveness_constraints.add(v, element) {\n+        if self.liveness_constraints.add(v, element, &cause) {\n             true\n         } else {\n             false\n@@ -416,6 +454,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         target_region: constraint.sup,\n                         inferred_values: &mut inferred_values,\n                         constraint_point: constraint.point,\n+                        constraint_span: constraint.span,\n                     },\n                 );\n \n@@ -973,7 +1012,7 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n     /// Given an instance T of the closure type, this method\n     /// instantiates the \"extra\" requirements that we computed for the\n     /// closure into the inference context. This has the effect of\n-    /// adding new subregion obligations to existing variables.\n+    /// adding new outlives obligations to existing variables.\n     ///\n     /// As described on `ClosureRegionRequirements`, the extra\n     /// requirements are expressed in terms of regionvids that index\n@@ -1075,3 +1114,18 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n         })\n     }\n }\n+\n+trait CauseExt {\n+    fn outlives(&self, constraint_location: Location, constraint_span: Span) -> Cause;\n+}\n+\n+impl CauseExt for Rc<Cause> {\n+    /// Creates a derived cause due to an outlives constraint.\n+    fn outlives(&self, constraint_location: Location, constraint_span: Span) -> Cause {\n+        Cause::Outlives {\n+            original_cause: self.clone(),\n+            constraint_location,\n+            constraint_span,\n+        }\n+    }\n+}"}, {"sha": "b60f45bcdc4c8d9d20ec02bdb809817169fab5c9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 77, "deletions": 6, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=e447b54bc3d7b2df8dd1326b09cefad31d2e4153", "patch": "@@ -10,10 +10,14 @@\n \n use std::rc::Rc;\n use rustc_data_structures::bitvec::BitMatrix;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::RegionVid;\n+use syntax::codemap::Span;\n+\n+use super::{Cause, CauseExt, TrackCauses};\n \n /// Maps between the various kinds of elements of a region value to\n /// the internal indices that w use.\n@@ -187,10 +191,22 @@ impl ToElementIndex for RegionElementIndex {\n pub(super) struct RegionValues {\n     elements: Rc<RegionValueElements>,\n     matrix: BitMatrix,\n+\n+    /// If cause tracking is enabled, maps from a pair (r, e)\n+    /// consisting of a region `r` that contains some element `e` to\n+    /// the reason that the element is contained. There should be an\n+    /// entry for every bit set to 1 in `BitMatrix`.\n+    causes: Option<CauseMap>,\n }\n \n+type CauseMap = FxHashMap<(RegionVid, RegionElementIndex), Rc<Cause>>;\n+\n impl RegionValues {\n-    pub(super) fn new(elements: &Rc<RegionValueElements>, num_region_variables: usize) -> Self {\n+    pub(super) fn new(\n+        elements: &Rc<RegionValueElements>,\n+        num_region_variables: usize,\n+        track_causes: TrackCauses,\n+    ) -> Self {\n         assert!(\n             elements.num_universal_regions <= num_region_variables,\n             \"universal regions are a subset of the region variables\"\n@@ -199,31 +215,80 @@ impl RegionValues {\n         Self {\n             elements: elements.clone(),\n             matrix: BitMatrix::new(num_region_variables, elements.num_elements()),\n+            causes: if track_causes.0 {\n+                Some(CauseMap::default())\n+            } else {\n+                None\n+            },\n         }\n     }\n \n     /// Adds the given element to the value for the given region. Returns true if\n     /// the element is newly added (i.e., was not already present).\n-    pub(super) fn add<E: ToElementIndex>(&mut self, r: RegionVid, elem: E) -> bool {\n+    pub(super) fn add<E: ToElementIndex>(&mut self, r: RegionVid, elem: E, cause: &Cause) -> bool {\n         let i = self.elements.index(elem);\n+        self.add_internal(r, i, |_| cause.clone())\n+    }\n+\n+    /// Internal method to add an element to a region.\n+    ///\n+    /// Takes a \"lazy\" cause -- this function will return the cause, but it will only\n+    /// be invoked if cause tracking is enabled.\n+    fn add_internal<F>(&mut self, r: RegionVid, i: RegionElementIndex, make_cause: F) -> bool\n+    where\n+        F: FnOnce(&CauseMap) -> Cause,\n+    {\n         if self.matrix.add(r.index(), i.index()) {\n             debug!(\"add(r={:?}, i={:?})\", r, self.elements.to_element(i));\n+\n+            if let Some(causes) = &mut self.causes {\n+                let cause = Rc::new(make_cause(causes));\n+                causes.insert((r, i), cause);\n+            }\n+\n             true\n         } else {\n+            if let Some(causes) = &mut self.causes {\n+                let cause = make_cause(causes);\n+                let old_cause = causes.get_mut(&(r, i)).unwrap();\n+                if cause < **old_cause {\n+                    *old_cause = Rc::new(cause);\n+                    return true;\n+                }\n+            }\n+\n             false\n         }\n     }\n \n+    /// Adds all the universal regions outlived by `from_region` to\n+    /// `to_region`.\n+    pub(super) fn add_due_to_outlives<T: ToElementIndex>(\n+        &mut self,\n+        from_region: RegionVid,\n+        to_region: RegionVid,\n+        elem: T,\n+        constraint_location: Location,\n+        constraint_span: Span,\n+    ) -> bool {\n+        let elem = self.elements.index(elem);\n+        self.add_internal(to_region, elem, |causes| {\n+            causes[&(from_region, elem)].outlives(constraint_location, constraint_span)\n+        })\n+    }\n+\n     /// Adds all the universal regions outlived by `from_region` to\n     /// `to_region`.\n     pub(super) fn add_universal_regions_outlived_by(\n         &mut self,\n         from_region: RegionVid,\n         to_region: RegionVid,\n+        constraint_location: Location,\n+        constraint_span: Span,\n     ) -> bool {\n-        // FIXME. We could optimize this by improving\n-        // `BitMatrix::merge` so it does not always merge an entire\n-        // row.\n+        // We could optimize this by improving `BitMatrix::merge` so\n+        // it does not always merge an entire row. That would\n+        // complicate causal tracking though.\n         debug!(\n             \"add_universal_regions_outlived_by(from_region={:?}, to_region={:?})\",\n             from_region,\n@@ -232,7 +297,13 @@ impl RegionValues {\n         let mut changed = false;\n         for elem in self.elements.all_universal_region_indices() {\n             if self.contains(from_region, elem) {\n-                changed |= self.add(to_region, elem);\n+                changed |= self.add_due_to_outlives(\n+                    from_region,\n+                    to_region,\n+                    elem,\n+                    constraint_location,\n+                    constraint_span,\n+                );\n             }\n         }\n         changed"}, {"sha": "32728145b29f682b8e733cde1d566acb373e394a", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=e447b54bc3d7b2df8dd1326b09cefad31d2e4153", "patch": "@@ -51,10 +51,10 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n             outlives_sets.len()\n         );\n \n-        for (region, location) in liveness_set {\n+        for (region, location, cause) in liveness_set {\n             debug!(\"generate: {:#?} is live at {:#?}\", region, location);\n             let region_vid = self.to_region_vid(region);\n-            self.regioncx.add_live_point(region_vid, *location);\n+            self.regioncx.add_live_point(region_vid, *location, &cause);\n         }\n \n         for OutlivesSet { locations, data } in outlives_sets {"}, {"sha": "50b38f9b46b618b4b2a03ef43198fee253e71e9d", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=e447b54bc3d7b2df8dd1326b09cefad31d2e4153", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use dataflow::{FlowAtLocation, FlowsAtLocation};\n+use borrow_check::nll::region_infer::Cause;\n use dataflow::MaybeInitializedLvals;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use rustc::mir::{BasicBlock, Location, Mir};\n@@ -79,7 +80,8 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n             .simulate_block(self.mir, bb, |location, live_locals| {\n                 for live_local in live_locals.iter() {\n                     let live_local_ty = self.mir.local_decls[live_local].ty;\n-                    self.push_type_live_constraint(live_local_ty, location);\n+                    let cause = Cause::LiveVar(live_local, location);\n+                    self.push_type_live_constraint(live_local_ty, location, cause);\n                 }\n             });\n \n@@ -121,7 +123,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n                     );\n \n                     let live_local_ty = self.mir.local_decls[live_local].ty;\n-                    self.add_drop_live_constraint(live_local_ty, location);\n+                    self.add_drop_live_constraint(live_local, live_local_ty, location);\n                 }\n             }\n \n@@ -146,7 +148,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at\n     /// `location`.\n-    fn push_type_live_constraint<T>(&mut self, value: T, location: Location)\n+    fn push_type_live_constraint<T>(&mut self, value: T, location: Location, cause: Cause)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -160,7 +162,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n             self.cx\n                 .constraints\n                 .liveness_set\n-                .push((live_region, location));\n+                .push((live_region, location, cause.clone()));\n         });\n     }\n \n@@ -169,9 +171,15 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n     /// the regions in its type must be live at `location`. The\n     /// precise set will depend on the dropck constraints, and in\n     /// particular this takes `#[may_dangle]` into account.\n-    fn add_drop_live_constraint(&mut self, dropped_ty: Ty<'tcx>, location: Location) {\n+    fn add_drop_live_constraint(\n+        &mut self,\n+        dropped_local: Local,\n+        dropped_ty: Ty<'tcx>,\n+        location: Location,\n+    ) {\n         debug!(\n-            \"add_drop_live_constraint(dropped_ty={:?}, location={:?})\",\n+            \"add_drop_live_constraint(dropped_local={:?}, dropped_ty={:?}, location={:?})\",\n+            dropped_local,\n             dropped_ty,\n             location\n         );\n@@ -196,7 +204,8 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n             // All things in the `outlives` array may be touched by\n             // the destructor and must be live at this point.\n             for outlive in outlives {\n-                self.push_type_live_constraint(outlive, location);\n+                let cause = Cause::DropVar(dropped_local, location);\n+                self.push_type_live_constraint(outlive, location, cause);\n             }\n \n             // However, there may also be some types that\n@@ -207,7 +216,8 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n                 let ty = self.cx.normalize(&ty, location);\n                 match ty.sty {\n                     ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n-                        self.push_type_live_constraint(ty, location);\n+                        let cause = Cause::DropVar(dropped_local, location);\n+                        self.push_type_live_constraint(ty, location, cause);\n                     }\n \n                     _ => if known.insert(ty) {"}, {"sha": "32a016e4a0aa4e95e77e7bd0277a0fce34150540", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e447b54bc3d7b2df8dd1326b09cefad31d2e4153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=e447b54bc3d7b2df8dd1326b09cefad31d2e4153", "patch": "@@ -11,6 +11,7 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n+use borrow_check::nll::region_infer::Cause;\n use borrow_check::nll::region_infer::ClosureRegionRequirementsExt;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedLvals;\n@@ -578,15 +579,15 @@ struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n /// A collection of region constraints that must be satisfied for the\n /// program to be considered well-typed.\n #[derive(Default)]\n-pub struct MirTypeckRegionConstraints<'tcx> {\n+pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n     /// In general, the type-checker is not responsible for enforcing\n     /// liveness constraints; this job falls to the region inferencer,\n     /// which performs a liveness analysis. However, in some limited\n     /// cases, the MIR type-checker creates temporary regions that do\n     /// not otherwise appear in the MIR -- in particular, the\n     /// late-bound regions that it instantiates at call-sites -- and\n     /// hence it must report on their liveness constraints.\n-    pub liveness_set: Vec<(ty::Region<'tcx>, Location)>,\n+    pub liveness_set: Vec<(ty::Region<'tcx>, Location, Cause)>,\n \n     /// During the course of type-checking, we will accumulate region\n     /// constraints due to performing subtyping operations or solving\n@@ -889,7 +890,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 for &late_bound_region in map.values() {\n                     self.constraints\n                         .liveness_set\n-                        .push((late_bound_region, term_location));\n+                        .push((late_bound_region, term_location, Cause::LiveOther(term_location)));\n                 }\n \n                 if self.is_box_free(func) {"}]}