{"sha": "09f4c9f5082f78b0adcee83d3ab4337e000cd28e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZjRjOWY1MDgyZjc4YjBhZGNlZTgzZDNhYjQzMzdlMDAwY2QyOGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-07T17:57:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-07T17:57:30Z"}, "message": "Auto merge of #75255 - davidtwco:polymorphisation-symbol-mangling-v0-upvar-closures, r=lcnr\n\ninstance: polymorphize upvar closures/generators\n\nThis PR modifies how instances are polymorphized so that closures and generators have any closures or generators captured within their upvars also polymorphized.\n\nWith the new symbol mangling, a fully polymorphised closure will produce the same symbol regardless of what it was instantiated with. However, when that polymorphised closure captures another closure as an upvar, then the type of that other closure in the upvar substitution wouldn't have been polymorphised. The other closure will still refer to the initial substitutions. Therefore, the polymorphised closure will end up hashing differently but producing the same symbol - triggering `assert_symbols_are_distinct` in MIR partitioning. The old mangling scheme had a hash at the end that meant this didn't happen (this would still have been an issue, we just didn't have a way to notice).\n\nSee [this Zulip discussion for further elaboration](https://rust-lang.zulipchat.com/#narrow/stream/216091-t-compiler.2Fwg-polymorphization/topic/symbol.20mangling.20v0.20.E2.9C.95.20polymorphisation/near/206152008).\n\nr? @eddyb\ncc @lcnr", "tree": {"sha": "a9e5933ed9ccf01acc3f85574fbe7ecf3e036704", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9e5933ed9ccf01acc3f85574fbe7ecf3e036704"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09f4c9f5082f78b0adcee83d3ab4337e000cd28e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09f4c9f5082f78b0adcee83d3ab4337e000cd28e", "html_url": "https://github.com/rust-lang/rust/commit/09f4c9f5082f78b0adcee83d3ab4337e000cd28e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d4342347b71313258a46e506ee0a258f365185c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d4342347b71313258a46e506ee0a258f365185c", "html_url": "https://github.com/rust-lang/rust/commit/4d4342347b71313258a46e506ee0a258f365185c"}, {"sha": "ac50d61785ae5112b9b4e30a58cfcffe096b31ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac50d61785ae5112b9b4e30a58cfcffe096b31ec", "html_url": "https://github.com/rust-lang/rust/commit/ac50d61785ae5112b9b4e30a58cfcffe096b31ec"}], "stats": {"total": 300, "additions": 280, "deletions": 20}, "files": [{"sha": "81f7474962c8d503a6f54c7d1368ac1c592b803e", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=09f4c9f5082f78b0adcee83d3ab4337e000cd28e", "patch": "@@ -85,6 +85,8 @@ impl FlagComputation {\n             }\n \n             &ty::Generator(_, ref substs, _) => {\n+                self.add_flags(TypeFlags::MAY_POLYMORPHIZE);\n+\n                 let substs = substs.as_generator();\n                 let should_remove_further_specializable =\n                     !self.flags.contains(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n@@ -107,6 +109,8 @@ impl FlagComputation {\n             }\n \n             &ty::Closure(_, substs) => {\n+                self.add_flags(TypeFlags::MAY_POLYMORPHIZE);\n+\n                 let substs = substs.as_closure();\n                 let should_remove_further_specializable =\n                     !self.flags.contains(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n@@ -192,6 +196,8 @@ impl FlagComputation {\n             }\n \n             &ty::FnDef(_, substs) => {\n+                self.add_flags(TypeFlags::MAY_POLYMORPHIZE);\n+\n                 self.add_substs(substs);\n             }\n "}, {"sha": "87434f3f26777606c905d4bea721d7676aeb8846", "filename": "src/librustc_middle/ty/fold.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Flibrustc_middle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Flibrustc_middle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffold.rs?ref=09f4c9f5082f78b0adcee83d3ab4337e000cd28e", "patch": "@@ -150,6 +150,12 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.has_type_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE)\n     }\n \n+    /// Does this value contain closures, generators or functions such that it may require\n+    /// polymorphization?\n+    fn may_polymorphize(&self) -> bool {\n+        self.has_type_flags(TypeFlags::MAY_POLYMORPHIZE)\n+    }\n+\n     /// A visitor that does not recurse into types, works like `fn walk_shallow` in `Ty`.\n     fn visit_tys_shallow(&self, visit: impl FnMut(Ty<'tcx>) -> bool) -> bool {\n         pub struct Visitor<F>(F);"}, {"sha": "cf876db26bc76a66f4e8fa7dca30ea468f32051d", "filename": "src/librustc_middle/ty/instance.rs", "status": "modified", "additions": 77, "deletions": 20, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Flibrustc_middle%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Flibrustc_middle%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Finstance.rs?ref=09f4c9f5082f78b0adcee83d3ab4337e000cd28e", "patch": "@@ -474,26 +474,7 @@ impl<'tcx> Instance<'tcx> {\n         }\n \n         if let InstanceDef::Item(def) = self.def {\n-            let unused = tcx.unused_generic_params(def.did);\n-\n-            if unused.is_empty() {\n-                // Exit early if every parameter was used.\n-                return self;\n-            }\n-\n-            debug!(\"polymorphize: unused={:?}\", unused);\n-            let polymorphized_substs =\n-                InternalSubsts::for_item(tcx, def.did, |param, _| match param.kind {\n-                // If parameter is a const or type parameter..\n-                ty::GenericParamDefKind::Const | ty::GenericParamDefKind::Type { .. } if\n-                    // ..and is within range and unused..\n-                    unused.contains(param.index).unwrap_or(false) =>\n-                        // ..then use the identity for this parameter.\n-                        tcx.mk_param_from_def(param),\n-                // Otherwise, use the parameter as before.\n-                _ => self.substs[param.index as usize],\n-            });\n-\n+            let polymorphized_substs = polymorphize(tcx, def.did, self.substs);\n             debug!(\"polymorphize: self={:?} polymorphized_substs={:?}\", self, polymorphized_substs);\n             Self { def: self.def, substs: polymorphized_substs }\n         } else {\n@@ -502,6 +483,82 @@ impl<'tcx> Instance<'tcx> {\n     }\n }\n \n+fn polymorphize<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    substs: SubstsRef<'tcx>,\n+) -> SubstsRef<'tcx> {\n+    debug!(\"polymorphize({:?}, {:?})\", def_id, substs);\n+    let unused = tcx.unused_generic_params(def_id);\n+    debug!(\"polymorphize: unused={:?}\", unused);\n+\n+    struct PolymorphizationFolder<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+    };\n+\n+    impl ty::TypeFolder<'tcx> for PolymorphizationFolder<'tcx> {\n+        fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+            self.tcx\n+        }\n+\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+            debug!(\"fold_ty: ty={:?}\", ty);\n+            match ty.kind {\n+                ty::Closure(def_id, substs) => {\n+                    let polymorphized_substs = polymorphize(self.tcx, def_id, substs);\n+                    if substs == polymorphized_substs {\n+                        ty\n+                    } else {\n+                        self.tcx.mk_closure(def_id, polymorphized_substs)\n+                    }\n+                }\n+                ty::FnDef(def_id, substs) => {\n+                    let polymorphized_substs = polymorphize(self.tcx, def_id, substs);\n+                    if substs == polymorphized_substs {\n+                        ty\n+                    } else {\n+                        self.tcx.mk_fn_def(def_id, polymorphized_substs)\n+                    }\n+                }\n+                ty::Generator(def_id, substs, movability) => {\n+                    let polymorphized_substs = polymorphize(self.tcx, def_id, substs);\n+                    if substs == polymorphized_substs {\n+                        ty\n+                    } else {\n+                        self.tcx.mk_generator(def_id, polymorphized_substs, movability)\n+                    }\n+                }\n+                _ => ty.super_fold_with(self),\n+            }\n+        }\n+    }\n+\n+    InternalSubsts::for_item(tcx, def_id, |param, _| {\n+        let is_unused = unused.contains(param.index).unwrap_or(false);\n+        debug!(\"polymorphize: param={:?} is_unused={:?}\", param, is_unused);\n+        match param.kind {\n+            // If parameter is a const or type parameter..\n+            ty::GenericParamDefKind::Const | ty::GenericParamDefKind::Type { .. } if\n+                // ..and is within range and unused..\n+                unused.contains(param.index).unwrap_or(false) =>\n+                    // ..then use the identity for this parameter.\n+                    tcx.mk_param_from_def(param),\n+\n+            // If the parameter does not contain any closures or generators, then use the\n+            // substitution directly.\n+            _ if !substs.may_polymorphize() => substs[param.index as usize],\n+\n+            // Otherwise, use the substitution after polymorphizing.\n+            _ => {\n+                let arg = substs[param.index as usize];\n+                let polymorphized_arg = arg.fold_with(&mut PolymorphizationFolder { tcx });\n+                debug!(\"polymorphize: arg={:?} polymorphized_arg={:?}\", arg, polymorphized_arg);\n+                ty::GenericArg::from(polymorphized_arg)\n+            }\n+        }\n+    })\n+}\n+\n fn needs_fn_once_adapter_shim(\n     actual_closure_kind: ty::ClosureKind,\n     trait_closure_kind: ty::ClosureKind,"}, {"sha": "c82fb2712c2168737038da2109bbbf89eaff658d", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=09f4c9f5082f78b0adcee83d3ab4337e000cd28e", "patch": "@@ -575,6 +575,10 @@ bitflags! {\n         /// Does this value have parameters/placeholders/inference variables which could be\n         /// replaced later, in a way that would change the results of `impl` specialization?\n         const STILL_FURTHER_SPECIALIZABLE = 1 << 17;\n+\n+        /// Does this value contain closures, generators or functions such that it may require\n+        /// polymorphization?\n+        const MAY_POLYMORPHIZE = 1 << 18;\n     }\n }\n "}, {"sha": "af47b440640afdf36530efd9d64c361cdb9c8088", "filename": "src/test/codegen-units/polymorphization/pr-75255.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Ftest%2Fcodegen-units%2Fpolymorphization%2Fpr-75255.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Ftest%2Fcodegen-units%2Fpolymorphization%2Fpr-75255.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpolymorphization%2Fpr-75255.rs?ref=09f4c9f5082f78b0adcee83d3ab4337e000cd28e", "patch": "@@ -0,0 +1,52 @@\n+// compile-flags:-Zpolymorphize=on -Zprint-mono-items=lazy -Copt-level=1\n+// ignore-tidy-linelength\n+\n+#![crate_type = \"rlib\"]\n+\n+// Test that only one copy of `Iter::map` and `iter::repeat` are generated.\n+\n+fn unused<T>() -> u64 {\n+    42\n+}\n+\n+fn foo<T>() {\n+    let x = [1, 2, 3, std::mem::size_of::<T>()];\n+    x.iter().map(|_| ());\n+}\n+\n+//~ MONO_ITEM fn core::iter[0]::adapters[0]::{{impl}}[29]::new[0]<core::slice[0]::Iter[0]<usize>, pr_75255::foo[0]::{{closure}}[0]<T>> @@ pr_75255-cgu.0[External]\n+//~ MONO_ITEM fn core::iter[0]::traits[0]::iterator[0]::Iterator[0]::map[0]<core::slice[0]::Iter[0]<usize>, (), pr_75255::foo[0]::{{closure}}[0]<T>> @@ pr_75255-cgu.1[Internal]\n+\n+fn bar<T>() {\n+    std::iter::repeat(unused::<T>);\n+}\n+\n+//~ MONO_ITEM fn core::iter[0]::sources[0]::repeat[0]<fn() -> u64> @@ pr_75255-cgu.1[Internal]\n+\n+pub fn dispatch() {\n+    foo::<String>();\n+    foo::<Vec<String>>();\n+\n+    bar::<String>();\n+    bar::<Vec<String>>();\n+}\n+\n+// These are all the items that aren't relevant to the test.\n+//~ MONO_ITEM fn core::mem[0]::size_of[0]<alloc::string[0]::String[0]> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::mem[0]::size_of[0]<alloc::vec[0]::Vec[0]<alloc::string[0]::String[0]>> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::mem[0]::size_of[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::add[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::is_null[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::offset[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::wrapping_add[0]<u8> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::wrapping_offset[0]<u8> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::non_null[0]::{{impl}}[3]::new_unchecked[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::null[0]<u8> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::slice[0]::{{impl}}[0]::as_ptr[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::slice[0]::{{impl}}[0]::iter[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::slice[0]::{{impl}}[0]::len[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn pr_75255::dispatch[0] @@ pr_75255-cgu.1[External]\n+//~ MONO_ITEM fn pr_75255::foo[0]<alloc::string[0]::String[0]> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn pr_75255::foo[0]<alloc::vec[0]::Vec[0]<alloc::string[0]::String[0]>> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn pr_75255::bar[0]<alloc::string[0]::String[0]> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn pr_75255::bar[0]<alloc::vec[0]::Vec[0]<alloc::string[0]::String[0]>> @@ pr_75255-cgu.1[Internal]"}, {"sha": "b0b39dbd3df61c630e009bd35c93c4ba435a8cb2", "filename": "src/test/ui/polymorphization/closure_in_upvar/fn.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffn.rs?ref=09f4c9f5082f78b0adcee83d3ab4337e000cd28e", "patch": "@@ -0,0 +1,29 @@\n+// build-pass\n+// compile-flags:-Zpolymorphize=on -Zsymbol-mangling-version=v0\n+\n+fn foo(f: impl Fn()) {\n+    let x = |_: ()| ();\n+\n+    // Don't use `f` in `y`, but refer to `x` so that the closure substs contain a reference to\n+    // `x` that will differ for each instantiation despite polymorphisation of the varying\n+    // argument.\n+    let y = || x(());\n+\n+    // Consider `f` used in `foo`.\n+    f();\n+    // Use `y` so that it is visited in monomorphisation collection.\n+    y();\n+}\n+\n+fn entry_a() {\n+    foo(|| ());\n+}\n+\n+fn entry_b() {\n+    foo(|| ());\n+}\n+\n+fn main() {\n+    entry_a();\n+    entry_b();\n+}"}, {"sha": "ba75f6c5a1099dc7530965e56ea94e28b9357d30", "filename": "src/test/ui/polymorphization/closure_in_upvar/fnmut.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffnmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffnmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffnmut.rs?ref=09f4c9f5082f78b0adcee83d3ab4337e000cd28e", "patch": "@@ -0,0 +1,34 @@\n+// build-pass\n+// compile-flags:-Zpolymorphize=on -Zsymbol-mangling-version=v0\n+\n+fn foo(f: impl Fn()) {\n+    // Mutate an upvar from `x` so that it implements `FnMut`.\n+    let mut outer = 3;\n+    let mut x = |_: ()| {\n+        outer = 4;\n+        ()\n+    };\n+\n+    // Don't use `f` in `y`, but refer to `x` so that the closure substs contain a reference to\n+    // `x` that will differ for each instantiation despite polymorphisation of the varying\n+    // argument.\n+    let mut y = || x(());\n+\n+    // Consider `f` used in `foo`.\n+    f();\n+    // Use `y` so that it is visited in monomorphisation collection.\n+    y();\n+}\n+\n+fn entry_a() {\n+    foo(|| ());\n+}\n+\n+fn entry_b() {\n+    foo(|| ());\n+}\n+\n+fn main() {\n+    entry_a();\n+    entry_b();\n+}"}, {"sha": "e9761ad0bcb20653d44bf470cde48ceb7258054e", "filename": "src/test/ui/polymorphization/closure_in_upvar/fnonce.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffnonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffnonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffnonce.rs?ref=09f4c9f5082f78b0adcee83d3ab4337e000cd28e", "patch": "@@ -0,0 +1,34 @@\n+// build-pass\n+// compile-flags:-Zpolymorphize=on -Zsymbol-mangling-version=v0\n+\n+fn foo(f: impl Fn()) {\n+    // Move a non-copy type into `x` so that it implements `FnOnce`.\n+    let outer = Vec::<u32>::new();\n+    let x = move |_: ()| {\n+        let inner = outer;\n+        ()\n+    };\n+\n+    // Don't use `f` in `y`, but refer to `x` so that the closure substs contain a reference to\n+    // `x` that will differ for each instantiation despite polymorphisation of the varying\n+    // argument.\n+    let y = || x(());\n+\n+    // Consider `f` used in `foo`.\n+    f();\n+    // Use `y` so that it is visited in monomorphisation collection.\n+    y();\n+}\n+\n+fn entry_a() {\n+    foo(|| ());\n+}\n+\n+fn entry_b() {\n+    foo(|| ());\n+}\n+\n+fn main() {\n+    entry_a();\n+    entry_b();\n+}"}, {"sha": "7614aa83fcd1541fecd0734b45719e383bb6b6e1", "filename": "src/test/ui/polymorphization/closure_in_upvar/other.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Fother.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4c9f5082f78b0adcee83d3ab4337e000cd28e/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Fother.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Fother.rs?ref=09f4c9f5082f78b0adcee83d3ab4337e000cd28e", "patch": "@@ -0,0 +1,38 @@\n+// build-pass\n+// compile-flags:-Zpolymorphize=on -Zsymbol-mangling-version=v0\n+\n+fn y_uses_f(f: impl Fn()) {\n+    let x = |_: ()| ();\n+\n+    let y = || {\n+        f();\n+        x(());\n+    };\n+\n+    f();\n+    y();\n+}\n+\n+fn x_uses_f(f: impl Fn()) {\n+    let x = |_: ()| { f(); };\n+\n+    let y = || x(());\n+\n+    f();\n+    y();\n+}\n+\n+fn entry_a() {\n+    x_uses_f(|| ());\n+    y_uses_f(|| ());\n+}\n+\n+fn entry_b() {\n+    x_uses_f(|| ());\n+    y_uses_f(|| ());\n+}\n+\n+fn main() {\n+    entry_a();\n+    entry_b();\n+}"}]}