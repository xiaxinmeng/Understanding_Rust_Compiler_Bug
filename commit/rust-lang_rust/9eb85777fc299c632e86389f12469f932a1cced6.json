{"sha": "9eb85777fc299c632e86389f12469f932a1cced6", "node_id": "C_kwDOAAsO6NoAKDllYjg1Nzc3ZmMyOTljNjMyZTg2Mzg5ZjEyNDY5ZjkzMmExY2NlZDY", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-11-23T03:42:49Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-11-23T03:57:55Z"}, "message": "Consolidate rustdoc's lint passes into a single pass\n\nThis should improve performance and simplify the code.", "tree": {"sha": "ba5d2b73ca17bb5d8f1cd7a1e98f581e22f0b91a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba5d2b73ca17bb5d8f1cd7a1e98f581e22f0b91a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eb85777fc299c632e86389f12469f932a1cced6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb85777fc299c632e86389f12469f932a1cced6", "html_url": "https://github.com/rust-lang/rust/commit/9eb85777fc299c632e86389f12469f932a1cced6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eb85777fc299c632e86389f12469f932a1cced6/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff8c8dfbe66701531e3e5e335c28c544d0fbc945", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff8c8dfbe66701531e3e5e335c28c544d0fbc945", "html_url": "https://github.com/rust-lang/rust/commit/ff8c8dfbe66701531e3e5e335c28c544d0fbc945"}], "stats": {"total": 946, "additions": 441, "deletions": 505}, "files": [{"sha": "7ff3ccef945c2915c0b12833b0a69c70093187ea", "filename": "src/librustdoc/passes/bare_urls.rs", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/ff8c8dfbe66701531e3e5e335c28c544d0fbc945/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8c8dfbe66701531e3e5e335c28c544d0fbc945/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs?ref=ff8c8dfbe66701531e3e5e335c28c544d0fbc945", "patch": "@@ -1,110 +0,0 @@\n-//! Detects links that are not linkified, e.g., in Markdown such as `Go to https://example.com/.`\n-//! Suggests wrapping the link with angle brackets: `Go to <https://example.com/>.` to linkify it.\n-use super::Pass;\n-use crate::clean::*;\n-use crate::core::DocContext;\n-use crate::html::markdown::main_body_opts;\n-use crate::visit::DocVisitor;\n-use core::ops::Range;\n-use pulldown_cmark::{Event, Parser, Tag};\n-use regex::Regex;\n-use rustc_errors::Applicability;\n-use std::mem;\n-use std::sync::LazyLock;\n-\n-pub(crate) const CHECK_BARE_URLS: Pass = Pass {\n-    name: \"check-bare-urls\",\n-    run: check_bare_urls,\n-    description: \"detects URLs that are not hyperlinks\",\n-};\n-\n-static URL_REGEX: LazyLock<Regex> = LazyLock::new(|| {\n-    Regex::new(concat!(\n-        r\"https?://\",                          // url scheme\n-        r\"([-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.)+\", // one or more subdomains\n-        r\"[a-zA-Z]{2,63}\",                     // root domain\n-        r\"\\b([-a-zA-Z0-9@:%_\\+.~#?&/=]*)\"      // optional query or url fragments\n-    ))\n-    .expect(\"failed to build regex\")\n-});\n-\n-struct BareUrlsLinter<'a, 'tcx> {\n-    cx: &'a mut DocContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> BareUrlsLinter<'a, 'tcx> {\n-    fn find_raw_urls(\n-        &self,\n-        text: &str,\n-        range: Range<usize>,\n-        f: &impl Fn(&DocContext<'_>, &str, &str, Range<usize>),\n-    ) {\n-        trace!(\"looking for raw urls in {}\", text);\n-        // For now, we only check \"full\" URLs (meaning, starting with \"http://\" or \"https://\").\n-        for match_ in URL_REGEX.find_iter(text) {\n-            let url = match_.as_str();\n-            let url_range = match_.range();\n-            f(\n-                self.cx,\n-                \"this URL is not a hyperlink\",\n-                url,\n-                Range { start: range.start + url_range.start, end: range.start + url_range.end },\n-            );\n-        }\n-    }\n-}\n-\n-pub(crate) fn check_bare_urls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n-    BareUrlsLinter { cx }.visit_crate(&krate);\n-    krate\n-}\n-\n-impl<'a, 'tcx> DocVisitor for BareUrlsLinter<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &Item) {\n-        let Some(hir_id) = DocContext::as_local_hir_id(self.cx.tcx, item.item_id)\n-        else {\n-            // If non-local, no need to check anything.\n-            return;\n-        };\n-        let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n-        if !dox.is_empty() {\n-            let report_diag = |cx: &DocContext<'_>, msg: &str, url: &str, range: Range<usize>| {\n-                let sp = super::source_span_for_markdown_range(cx.tcx, &dox, &range, &item.attrs)\n-                    .unwrap_or_else(|| item.attr_span(cx.tcx));\n-                cx.tcx.struct_span_lint_hir(crate::lint::BARE_URLS, hir_id, sp, msg, |lint| {\n-                    lint.note(\"bare URLs are not automatically turned into clickable links\")\n-                        .span_suggestion(\n-                            sp,\n-                            \"use an automatic link instead\",\n-                            format!(\"<{}>\", url),\n-                            Applicability::MachineApplicable,\n-                        )\n-                });\n-            };\n-\n-            let mut p = Parser::new_ext(&dox, main_body_opts()).into_offset_iter();\n-\n-            while let Some((event, range)) = p.next() {\n-                match event {\n-                    Event::Text(s) => self.find_raw_urls(&s, range, &report_diag),\n-                    // We don't want to check the text inside code blocks or links.\n-                    Event::Start(tag @ (Tag::CodeBlock(_) | Tag::Link(..))) => {\n-                        while let Some((event, _)) = p.next() {\n-                            match event {\n-                                Event::End(end)\n-                                    if mem::discriminant(&end) == mem::discriminant(&tag) =>\n-                                {\n-                                    break;\n-                                }\n-                                _ => {}\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-\n-        self.visit_item_recur(item)\n-    }\n-}"}, {"sha": "2e651b5387419fa2441abbda60e515a66b00e4c1", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "removed", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/ff8c8dfbe66701531e3e5e335c28c544d0fbc945/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8c8dfbe66701531e3e5e335c28c544d0fbc945/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=ff8c8dfbe66701531e3e5e335c28c544d0fbc945", "patch": "@@ -1,209 +0,0 @@\n-//! Validates syntax inside Rust code blocks (\\`\\`\\`rust).\n-use rustc_data_structures::sync::{Lock, Lrc};\n-use rustc_errors::{\n-    emitter::Emitter,\n-    translation::{to_fluent_args, Translate},\n-    Applicability, Diagnostic, Handler, LazyFallbackBundle,\n-};\n-use rustc_parse::parse_stream_from_source_str;\n-use rustc_session::parse::ParseSess;\n-use rustc_span::hygiene::{AstPass, ExpnData, ExpnKind, LocalExpnId};\n-use rustc_span::source_map::{FilePathMapping, SourceMap};\n-use rustc_span::{FileName, InnerSpan, DUMMY_SP};\n-\n-use crate::clean;\n-use crate::core::DocContext;\n-use crate::html::markdown::{self, RustCodeBlock};\n-use crate::passes::Pass;\n-use crate::visit::DocVisitor;\n-\n-pub(crate) const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n-    name: \"check-code-block-syntax\",\n-    run: check_code_block_syntax,\n-    description: \"validates syntax inside Rust code blocks\",\n-};\n-\n-pub(crate) fn check_code_block_syntax(\n-    krate: clean::Crate,\n-    cx: &mut DocContext<'_>,\n-) -> clean::Crate {\n-    SyntaxChecker { cx }.visit_crate(&krate);\n-    krate\n-}\n-\n-struct SyntaxChecker<'a, 'tcx> {\n-    cx: &'a DocContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n-    fn check_rust_syntax(&self, item: &clean::Item, dox: &str, code_block: RustCodeBlock) {\n-        let buffer = Lrc::new(Lock::new(Buffer::default()));\n-        let fallback_bundle =\n-            rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n-        let emitter = BufferEmitter { buffer: Lrc::clone(&buffer), fallback_bundle };\n-\n-        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-        let handler = Handler::with_emitter(false, None, Box::new(emitter));\n-        let source = dox[code_block.code].to_owned();\n-        let sess = ParseSess::with_span_handler(handler, sm);\n-\n-        let edition = code_block.lang_string.edition.unwrap_or_else(|| self.cx.tcx.sess.edition());\n-        let expn_data = ExpnData::default(\n-            ExpnKind::AstPass(AstPass::TestHarness),\n-            DUMMY_SP,\n-            edition,\n-            None,\n-            None,\n-        );\n-        let expn_id =\n-            self.cx.tcx.with_stable_hashing_context(|hcx| LocalExpnId::fresh(expn_data, hcx));\n-        let span = DUMMY_SP.fresh_expansion(expn_id);\n-\n-        let is_empty = rustc_driver::catch_fatal_errors(|| {\n-            parse_stream_from_source_str(\n-                FileName::Custom(String::from(\"doctest\")),\n-                source,\n-                &sess,\n-                Some(span),\n-            )\n-            .is_empty()\n-        })\n-        .unwrap_or(false);\n-        let buffer = buffer.borrow();\n-\n-        if !buffer.has_errors && !is_empty {\n-            // No errors in a non-empty program.\n-            return;\n-        }\n-\n-        let Some(local_id) = item.item_id.as_def_id().and_then(|x| x.as_local())\n-        else {\n-            // We don't need to check the syntax for other crates so returning\n-            // without doing anything should not be a problem.\n-            return;\n-        };\n-\n-        let hir_id = self.cx.tcx.hir().local_def_id_to_hir_id(local_id);\n-        let empty_block = code_block.lang_string == Default::default() && code_block.is_fenced;\n-        let is_ignore = code_block.lang_string.ignore != markdown::Ignore::None;\n-\n-        // The span and whether it is precise or not.\n-        let (sp, precise_span) = match super::source_span_for_markdown_range(\n-            self.cx.tcx,\n-            dox,\n-            &code_block.range,\n-            &item.attrs,\n-        ) {\n-            Some(sp) => (sp, true),\n-            None => (item.attr_span(self.cx.tcx), false),\n-        };\n-\n-        let msg = if buffer.has_errors {\n-            \"could not parse code block as Rust code\"\n-        } else {\n-            \"Rust code block is empty\"\n-        };\n-\n-        // Finally build and emit the completed diagnostic.\n-        // All points of divergence have been handled earlier so this can be\n-        // done the same way whether the span is precise or not.\n-        self.cx.tcx.struct_span_lint_hir(\n-            crate::lint::INVALID_RUST_CODEBLOCKS,\n-            hir_id,\n-            sp,\n-            msg,\n-            |lint| {\n-                let explanation = if is_ignore {\n-                    \"`ignore` code blocks require valid Rust code for syntax highlighting; \\\n-                    mark blocks that do not contain Rust code as text\"\n-                } else {\n-                    \"mark blocks that do not contain Rust code as text\"\n-                };\n-\n-                if precise_span {\n-                    if is_ignore {\n-                        // giving an accurate suggestion is hard because `ignore` might not have come first in the list.\n-                        // just give a `help` instead.\n-                        lint.span_help(\n-                            sp.from_inner(InnerSpan::new(0, 3)),\n-                            &format!(\"{}: ```text\", explanation),\n-                        );\n-                    } else if empty_block {\n-                        lint.span_suggestion(\n-                            sp.from_inner(InnerSpan::new(0, 3)).shrink_to_hi(),\n-                            explanation,\n-                            \"text\",\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                } else if empty_block || is_ignore {\n-                    lint.help(&format!(\"{}: ```text\", explanation));\n-                }\n-\n-                // FIXME(#67563): Provide more context for these errors by displaying the spans inline.\n-                for message in buffer.messages.iter() {\n-                    lint.note(message);\n-                }\n-\n-                lint\n-            },\n-        );\n-    }\n-}\n-\n-impl<'a, 'tcx> DocVisitor for SyntaxChecker<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &clean::Item) {\n-        if let Some(dox) = &item.attrs.collapsed_doc_value() {\n-            let sp = item.attr_span(self.cx.tcx);\n-            let extra = crate::html::markdown::ExtraInfo::new_did(\n-                self.cx.tcx,\n-                item.item_id.expect_def_id(),\n-                sp,\n-            );\n-            for code_block in markdown::rust_code_blocks(dox, &extra) {\n-                self.check_rust_syntax(item, dox, code_block);\n-            }\n-        }\n-\n-        self.visit_item_recur(item)\n-    }\n-}\n-\n-#[derive(Default)]\n-struct Buffer {\n-    messages: Vec<String>,\n-    has_errors: bool,\n-}\n-\n-struct BufferEmitter {\n-    buffer: Lrc<Lock<Buffer>>,\n-    fallback_bundle: LazyFallbackBundle,\n-}\n-\n-impl Translate for BufferEmitter {\n-    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n-        None\n-    }\n-\n-    fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n-        &**self.fallback_bundle\n-    }\n-}\n-\n-impl Emitter for BufferEmitter {\n-    fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n-        let mut buffer = self.buffer.borrow_mut();\n-\n-        let fluent_args = to_fluent_args(diag.args());\n-        let translated_main_message = self.translate_message(&diag.message[0].0, &fluent_args);\n-\n-        buffer.messages.push(format!(\"error from rustc: {}\", translated_main_message));\n-        if diag.is_error() {\n-            buffer.has_errors = true;\n-        }\n-    }\n-\n-    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n-        None\n-    }\n-}"}, {"sha": "97031c4f028f45eb1bafc4cfe5d7b34c7eb7de34", "filename": "src/librustdoc/passes/lint.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9eb85777fc299c632e86389f12469f932a1cced6/src%2Flibrustdoc%2Fpasses%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb85777fc299c632e86389f12469f932a1cced6/src%2Flibrustdoc%2Fpasses%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint.rs?ref=9eb85777fc299c632e86389f12469f932a1cced6", "patch": "@@ -0,0 +1,33 @@\n+//! Runs several rustdoc lints, consolidating them into a single pass for\n+//! efficiency and simplicity.\n+\n+mod bare_urls;\n+mod check_code_block_syntax;\n+mod html_tags;\n+\n+use super::Pass;\n+use crate::clean::*;\n+use crate::core::DocContext;\n+use crate::visit::DocVisitor;\n+\n+pub(crate) const RUN_LINTS: Pass =\n+    Pass { name: \"run-lints\", run: run_lints, description: \"runs some of rustdoc's lints\" };\n+\n+struct Linter<'a, 'tcx> {\n+    cx: &'a mut DocContext<'tcx>,\n+}\n+\n+pub(crate) fn run_lints(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+    Linter { cx }.visit_crate(&krate);\n+    krate\n+}\n+\n+impl<'a, 'tcx> DocVisitor for Linter<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &Item) {\n+        bare_urls::visit_item(self.cx, item);\n+        check_code_block_syntax::visit_item(self.cx, item);\n+        html_tags::visit_item(self.cx, item);\n+\n+        self.visit_item_recur(item)\n+    }\n+}"}, {"sha": "423230cfe381e186ba00dc80f40b6aa41525fff6", "filename": "src/librustdoc/passes/lint/bare_urls.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/9eb85777fc299c632e86389f12469f932a1cced6/src%2Flibrustdoc%2Fpasses%2Flint%2Fbare_urls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb85777fc299c632e86389f12469f932a1cced6/src%2Flibrustdoc%2Fpasses%2Flint%2Fbare_urls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Fbare_urls.rs?ref=9eb85777fc299c632e86389f12469f932a1cced6", "patch": "@@ -0,0 +1,89 @@\n+//! Detects links that are not linkified, e.g., in Markdown such as `Go to https://example.com/.`\n+//! Suggests wrapping the link with angle brackets: `Go to <https://example.com/>.` to linkify it.\n+\n+use crate::clean::*;\n+use crate::core::DocContext;\n+use crate::html::markdown::main_body_opts;\n+use crate::passes::source_span_for_markdown_range;\n+use core::ops::Range;\n+use pulldown_cmark::{Event, Parser, Tag};\n+use regex::Regex;\n+use rustc_errors::Applicability;\n+use std::mem;\n+use std::sync::LazyLock;\n+\n+pub(super) fn visit_item(cx: &DocContext<'_>, item: &Item) {\n+    let Some(hir_id) = DocContext::as_local_hir_id(cx.tcx, item.item_id)\n+        else {\n+            // If non-local, no need to check anything.\n+            return;\n+        };\n+    let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n+    if !dox.is_empty() {\n+        let report_diag = |cx: &DocContext<'_>, msg: &str, url: &str, range: Range<usize>| {\n+            let sp = source_span_for_markdown_range(cx.tcx, &dox, &range, &item.attrs)\n+                .unwrap_or_else(|| item.attr_span(cx.tcx));\n+            cx.tcx.struct_span_lint_hir(crate::lint::BARE_URLS, hir_id, sp, msg, |lint| {\n+                lint.note(\"bare URLs are not automatically turned into clickable links\")\n+                    .span_suggestion(\n+                        sp,\n+                        \"use an automatic link instead\",\n+                        format!(\"<{}>\", url),\n+                        Applicability::MachineApplicable,\n+                    )\n+            });\n+        };\n+\n+        let mut p = Parser::new_ext(&dox, main_body_opts()).into_offset_iter();\n+\n+        while let Some((event, range)) = p.next() {\n+            match event {\n+                Event::Text(s) => find_raw_urls(cx, &s, range, &report_diag),\n+                // We don't want to check the text inside code blocks or links.\n+                Event::Start(tag @ (Tag::CodeBlock(_) | Tag::Link(..))) => {\n+                    while let Some((event, _)) = p.next() {\n+                        match event {\n+                            Event::End(end)\n+                                if mem::discriminant(&end) == mem::discriminant(&tag) =>\n+                            {\n+                                break;\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+}\n+\n+static URL_REGEX: LazyLock<Regex> = LazyLock::new(|| {\n+    Regex::new(concat!(\n+        r\"https?://\",                          // url scheme\n+        r\"([-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.)+\", // one or more subdomains\n+        r\"[a-zA-Z]{2,63}\",                     // root domain\n+        r\"\\b([-a-zA-Z0-9@:%_\\+.~#?&/=]*)\"      // optional query or url fragments\n+    ))\n+    .expect(\"failed to build regex\")\n+});\n+\n+fn find_raw_urls(\n+    cx: &DocContext<'_>,\n+    text: &str,\n+    range: Range<usize>,\n+    f: &impl Fn(&DocContext<'_>, &str, &str, Range<usize>),\n+) {\n+    trace!(\"looking for raw urls in {}\", text);\n+    // For now, we only check \"full\" URLs (meaning, starting with \"http://\" or \"https://\").\n+    for match_ in URL_REGEX.find_iter(text) {\n+        let url = match_.as_str();\n+        let url_range = match_.range();\n+        f(\n+            cx,\n+            \"this URL is not a hyperlink\",\n+            url,\n+            Range { start: range.start + url_range.start, end: range.start + url_range.end },\n+        );\n+    }\n+}"}, {"sha": "5aa4f238b2d149e582f79e7c613870fda2ff51de", "filename": "src/librustdoc/passes/lint/check_code_block_syntax.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/9eb85777fc299c632e86389f12469f932a1cced6/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb85777fc299c632e86389f12469f932a1cced6/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs?ref=9eb85777fc299c632e86389f12469f932a1cced6", "patch": "@@ -0,0 +1,170 @@\n+//! Validates syntax inside Rust code blocks (\\`\\`\\`rust).\n+use rustc_data_structures::sync::{Lock, Lrc};\n+use rustc_errors::{\n+    emitter::Emitter,\n+    translation::{to_fluent_args, Translate},\n+    Applicability, Diagnostic, Handler, LazyFallbackBundle,\n+};\n+use rustc_parse::parse_stream_from_source_str;\n+use rustc_session::parse::ParseSess;\n+use rustc_span::hygiene::{AstPass, ExpnData, ExpnKind, LocalExpnId};\n+use rustc_span::source_map::{FilePathMapping, SourceMap};\n+use rustc_span::{FileName, InnerSpan, DUMMY_SP};\n+\n+use crate::clean;\n+use crate::core::DocContext;\n+use crate::html::markdown::{self, RustCodeBlock};\n+use crate::passes::source_span_for_markdown_range;\n+\n+pub(crate) fn visit_item(cx: &DocContext<'_>, item: &clean::Item) {\n+    if let Some(dox) = &item.attrs.collapsed_doc_value() {\n+        let sp = item.attr_span(cx.tcx);\n+        let extra =\n+            crate::html::markdown::ExtraInfo::new_did(cx.tcx, item.item_id.expect_def_id(), sp);\n+        for code_block in markdown::rust_code_blocks(dox, &extra) {\n+            check_rust_syntax(cx, item, dox, code_block);\n+        }\n+    }\n+}\n+\n+fn check_rust_syntax(\n+    cx: &DocContext<'_>,\n+    item: &clean::Item,\n+    dox: &str,\n+    code_block: RustCodeBlock,\n+) {\n+    let buffer = Lrc::new(Lock::new(Buffer::default()));\n+    let fallback_bundle =\n+        rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n+    let emitter = BufferEmitter { buffer: Lrc::clone(&buffer), fallback_bundle };\n+\n+    let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+    let handler = Handler::with_emitter(false, None, Box::new(emitter));\n+    let source = dox[code_block.code].to_owned();\n+    let sess = ParseSess::with_span_handler(handler, sm);\n+\n+    let edition = code_block.lang_string.edition.unwrap_or_else(|| cx.tcx.sess.edition());\n+    let expn_data =\n+        ExpnData::default(ExpnKind::AstPass(AstPass::TestHarness), DUMMY_SP, edition, None, None);\n+    let expn_id = cx.tcx.with_stable_hashing_context(|hcx| LocalExpnId::fresh(expn_data, hcx));\n+    let span = DUMMY_SP.fresh_expansion(expn_id);\n+\n+    let is_empty = rustc_driver::catch_fatal_errors(|| {\n+        parse_stream_from_source_str(\n+            FileName::Custom(String::from(\"doctest\")),\n+            source,\n+            &sess,\n+            Some(span),\n+        )\n+        .is_empty()\n+    })\n+    .unwrap_or(false);\n+    let buffer = buffer.borrow();\n+\n+    if !buffer.has_errors && !is_empty {\n+        // No errors in a non-empty program.\n+        return;\n+    }\n+\n+    let Some(local_id) = item.item_id.as_def_id().and_then(|x| x.as_local())\n+        else {\n+            // We don't need to check the syntax for other crates so returning\n+            // without doing anything should not be a problem.\n+            return;\n+        };\n+\n+    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_id);\n+    let empty_block = code_block.lang_string == Default::default() && code_block.is_fenced;\n+    let is_ignore = code_block.lang_string.ignore != markdown::Ignore::None;\n+\n+    // The span and whether it is precise or not.\n+    let (sp, precise_span) =\n+        match source_span_for_markdown_range(cx.tcx, dox, &code_block.range, &item.attrs) {\n+            Some(sp) => (sp, true),\n+            None => (item.attr_span(cx.tcx), false),\n+        };\n+\n+    let msg = if buffer.has_errors {\n+        \"could not parse code block as Rust code\"\n+    } else {\n+        \"Rust code block is empty\"\n+    };\n+\n+    // Finally build and emit the completed diagnostic.\n+    // All points of divergence have been handled earlier so this can be\n+    // done the same way whether the span is precise or not.\n+    cx.tcx.struct_span_lint_hir(crate::lint::INVALID_RUST_CODEBLOCKS, hir_id, sp, msg, |lint| {\n+        let explanation = if is_ignore {\n+            \"`ignore` code blocks require valid Rust code for syntax highlighting; \\\n+                    mark blocks that do not contain Rust code as text\"\n+        } else {\n+            \"mark blocks that do not contain Rust code as text\"\n+        };\n+\n+        if precise_span {\n+            if is_ignore {\n+                // giving an accurate suggestion is hard because `ignore` might not have come first in the list.\n+                // just give a `help` instead.\n+                lint.span_help(\n+                    sp.from_inner(InnerSpan::new(0, 3)),\n+                    &format!(\"{}: ```text\", explanation),\n+                );\n+            } else if empty_block {\n+                lint.span_suggestion(\n+                    sp.from_inner(InnerSpan::new(0, 3)).shrink_to_hi(),\n+                    explanation,\n+                    \"text\",\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        } else if empty_block || is_ignore {\n+            lint.help(&format!(\"{}: ```text\", explanation));\n+        }\n+\n+        // FIXME(#67563): Provide more context for these errors by displaying the spans inline.\n+        for message in buffer.messages.iter() {\n+            lint.note(message);\n+        }\n+\n+        lint\n+    });\n+}\n+\n+#[derive(Default)]\n+struct Buffer {\n+    messages: Vec<String>,\n+    has_errors: bool,\n+}\n+\n+struct BufferEmitter {\n+    buffer: Lrc<Lock<Buffer>>,\n+    fallback_bundle: LazyFallbackBundle,\n+}\n+\n+impl Translate for BufferEmitter {\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n+        &**self.fallback_bundle\n+    }\n+}\n+\n+impl Emitter for BufferEmitter {\n+    fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n+        let mut buffer = self.buffer.borrow_mut();\n+\n+        let fluent_args = to_fluent_args(diag.args());\n+        let translated_main_message = self.translate_message(&diag.message[0].0, &fluent_args);\n+\n+        buffer.messages.push(format!(\"error from rustc: {}\", translated_main_message));\n+        if diag.is_error() {\n+            buffer.has_errors = true;\n+        }\n+    }\n+\n+    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n+        None\n+    }\n+}"}, {"sha": "070c0aab5868b548f33d7e47d936f00b6c3fc31f", "filename": "src/librustdoc/passes/lint/html_tags.rs", "status": "renamed", "additions": 143, "deletions": 166, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/9eb85777fc299c632e86389f12469f932a1cced6/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb85777fc299c632e86389f12469f932a1cced6/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs?ref=9eb85777fc299c632e86389f12469f932a1cced6", "patch": "@@ -1,30 +1,159 @@\n //! Detects invalid HTML (like an unclosed `<span>`) in doc comments.\n-use super::Pass;\n use crate::clean::*;\n use crate::core::DocContext;\n use crate::html::markdown::main_body_opts;\n-use crate::visit::DocVisitor;\n+use crate::passes::source_span_for_markdown_range;\n \n use pulldown_cmark::{BrokenLink, Event, LinkType, Parser, Tag};\n \n use std::iter::Peekable;\n use std::ops::Range;\n use std::str::CharIndices;\n \n-pub(crate) const CHECK_INVALID_HTML_TAGS: Pass = Pass {\n-    name: \"check-invalid-html-tags\",\n-    run: check_invalid_html_tags,\n-    description: \"detects invalid HTML tags in doc comments\",\n-};\n+pub(crate) fn visit_item(cx: &DocContext<'_>, item: &Item) {\n+    let tcx = cx.tcx;\n+    let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.item_id)\n+    // If non-local, no need to check anything.\n+    else { return };\n+    let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n+    if !dox.is_empty() {\n+        let report_diag = |msg: &str, range: &Range<usize>, is_open_tag: bool| {\n+            let sp = match source_span_for_markdown_range(tcx, &dox, range, &item.attrs) {\n+                Some(sp) => sp,\n+                None => item.attr_span(tcx),\n+            };\n+            tcx.struct_span_lint_hir(crate::lint::INVALID_HTML_TAGS, hir_id, sp, msg, |lint| {\n+                use rustc_lint_defs::Applicability;\n+                // If a tag looks like `<this>`, it might actually be a generic.\n+                // We don't try to detect stuff `<like, this>` because that's not valid HTML,\n+                // and we don't try to detect stuff `<like this>` because that's not valid Rust.\n+                let mut generics_end = range.end;\n+                if let Some(Some(mut generics_start)) = (is_open_tag\n+                    && dox[..generics_end].ends_with('>'))\n+                .then(|| extract_path_backwards(&dox, range.start))\n+                {\n+                    while generics_start != 0\n+                        && generics_end < dox.len()\n+                        && dox.as_bytes()[generics_start - 1] == b'<'\n+                        && dox.as_bytes()[generics_end] == b'>'\n+                    {\n+                        generics_end += 1;\n+                        generics_start -= 1;\n+                        if let Some(new_start) = extract_path_backwards(&dox, generics_start) {\n+                            generics_start = new_start;\n+                        }\n+                        if let Some(new_end) = extract_path_forward(&dox, generics_end) {\n+                            generics_end = new_end;\n+                        }\n+                    }\n+                    if let Some(new_end) = extract_path_forward(&dox, generics_end) {\n+                        generics_end = new_end;\n+                    }\n+                    let generics_sp = match source_span_for_markdown_range(\n+                        tcx,\n+                        &dox,\n+                        &(generics_start..generics_end),\n+                        &item.attrs,\n+                    ) {\n+                        Some(sp) => sp,\n+                        None => item.attr_span(tcx),\n+                    };\n+                    // Sometimes, we only extract part of a path. For example, consider this:\n+                    //\n+                    //     <[u32] as IntoIter<u32>>::Item\n+                    //                       ^^^^^ unclosed HTML tag `u32`\n+                    //\n+                    // We don't have any code for parsing fully-qualified trait paths.\n+                    // In theory, we could add it, but doing it correctly would require\n+                    // parsing the entire path grammar, which is problematic because of\n+                    // overlap between the path grammar and Markdown.\n+                    //\n+                    // The example above shows that ambiguity. Is `[u32]` intended to be an\n+                    // intra-doc link to the u32 primitive, or is it intended to be a slice?\n+                    //\n+                    // If the below conditional were removed, we would suggest this, which is\n+                    // not what the user probably wants.\n+                    //\n+                    //     <[u32] as `IntoIter<u32>`>::Item\n+                    //\n+                    // We know that the user actually wants to wrap the whole thing in a code\n+                    // block, but the only reason we know that is because `u32` does not, in\n+                    // fact, implement IntoIter. If the example looks like this:\n+                    //\n+                    //     <[Vec<i32>] as IntoIter<i32>::Item\n+                    //\n+                    // The ideal fix would be significantly different.\n+                    if (generics_start > 0 && dox.as_bytes()[generics_start - 1] == b'<')\n+                        || (generics_end < dox.len() && dox.as_bytes()[generics_end] == b'>')\n+                    {\n+                        return lint;\n+                    }\n+                    // multipart form is chosen here because ``Vec<i32>`` would be confusing.\n+                    lint.multipart_suggestion(\n+                        \"try marking as source code\",\n+                        vec![\n+                            (generics_sp.shrink_to_lo(), String::from(\"`\")),\n+                            (generics_sp.shrink_to_hi(), String::from(\"`\")),\n+                        ],\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n \n-struct InvalidHtmlTagsLinter<'a, 'tcx> {\n-    cx: &'a mut DocContext<'tcx>,\n-}\n+                lint\n+            });\n+        };\n+\n+        let mut tags = Vec::new();\n+        let mut is_in_comment = None;\n+        let mut in_code_block = false;\n+\n+        let link_names = item.link_names(&cx.cache);\n \n-pub(crate) fn check_invalid_html_tags(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n-    let mut coll = InvalidHtmlTagsLinter { cx };\n-    coll.visit_crate(&krate);\n-    krate\n+        let mut replacer = |broken_link: BrokenLink<'_>| {\n+            if let Some(link) =\n+                link_names.iter().find(|link| *link.original_text == *broken_link.reference)\n+            {\n+                Some((link.href.as_str().into(), link.new_text.as_str().into()))\n+            } else if matches!(\n+                &broken_link.link_type,\n+                LinkType::Reference | LinkType::ReferenceUnknown\n+            ) {\n+                // If the link is shaped [like][this], suppress any broken HTML in the [this] part.\n+                // The `broken_intra_doc_links` will report typos in there anyway.\n+                Some((\n+                    broken_link.reference.to_string().into(),\n+                    broken_link.reference.to_string().into(),\n+                ))\n+            } else {\n+                None\n+            }\n+        };\n+\n+        let p = Parser::new_with_broken_link_callback(&dox, main_body_opts(), Some(&mut replacer))\n+            .into_offset_iter();\n+\n+        for (event, range) in p {\n+            match event {\n+                Event::Start(Tag::CodeBlock(_)) => in_code_block = true,\n+                Event::Html(text) if !in_code_block => {\n+                    extract_tags(&mut tags, &text, range, &mut is_in_comment, &report_diag)\n+                }\n+                Event::End(Tag::CodeBlock(_)) => in_code_block = false,\n+                _ => {}\n+            }\n+        }\n+\n+        for (tag, range) in tags.iter().filter(|(t, _)| {\n+            let t = t.to_lowercase();\n+            !ALLOWED_UNCLOSED.contains(&t.as_str())\n+        }) {\n+            report_diag(&format!(\"unclosed HTML tag `{}`\", tag), range, true);\n+        }\n+\n+        if let Some(range) = is_in_comment {\n+            report_diag(\"Unclosed HTML comment\", &range, false);\n+        }\n+    }\n }\n \n const ALLOWED_UNCLOSED: &[&str] = &[\n@@ -276,155 +405,3 @@ fn extract_tags(\n         }\n     }\n }\n-\n-impl<'a, 'tcx> DocVisitor for InvalidHtmlTagsLinter<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &Item) {\n-        let tcx = self.cx.tcx;\n-        let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.item_id)\n-        // If non-local, no need to check anything.\n-        else { return };\n-        let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n-        if !dox.is_empty() {\n-            let report_diag = |msg: &str, range: &Range<usize>, is_open_tag: bool| {\n-                let sp = match super::source_span_for_markdown_range(tcx, &dox, range, &item.attrs)\n-                {\n-                    Some(sp) => sp,\n-                    None => item.attr_span(tcx),\n-                };\n-                tcx.struct_span_lint_hir(crate::lint::INVALID_HTML_TAGS, hir_id, sp, msg, |lint| {\n-                    use rustc_lint_defs::Applicability;\n-                    // If a tag looks like `<this>`, it might actually be a generic.\n-                    // We don't try to detect stuff `<like, this>` because that's not valid HTML,\n-                    // and we don't try to detect stuff `<like this>` because that's not valid Rust.\n-                    let mut generics_end = range.end;\n-                    if let Some(Some(mut generics_start)) = (is_open_tag\n-                        && dox[..generics_end].ends_with('>'))\n-                    .then(|| extract_path_backwards(&dox, range.start))\n-                    {\n-                        while generics_start != 0\n-                            && generics_end < dox.len()\n-                            && dox.as_bytes()[generics_start - 1] == b'<'\n-                            && dox.as_bytes()[generics_end] == b'>'\n-                        {\n-                            generics_end += 1;\n-                            generics_start -= 1;\n-                            if let Some(new_start) = extract_path_backwards(&dox, generics_start) {\n-                                generics_start = new_start;\n-                            }\n-                            if let Some(new_end) = extract_path_forward(&dox, generics_end) {\n-                                generics_end = new_end;\n-                            }\n-                        }\n-                        if let Some(new_end) = extract_path_forward(&dox, generics_end) {\n-                            generics_end = new_end;\n-                        }\n-                        let generics_sp = match super::source_span_for_markdown_range(\n-                            tcx,\n-                            &dox,\n-                            &(generics_start..generics_end),\n-                            &item.attrs,\n-                        ) {\n-                            Some(sp) => sp,\n-                            None => item.attr_span(tcx),\n-                        };\n-                        // Sometimes, we only extract part of a path. For example, consider this:\n-                        //\n-                        //     <[u32] as IntoIter<u32>>::Item\n-                        //                       ^^^^^ unclosed HTML tag `u32`\n-                        //\n-                        // We don't have any code for parsing fully-qualified trait paths.\n-                        // In theory, we could add it, but doing it correctly would require\n-                        // parsing the entire path grammar, which is problematic because of\n-                        // overlap between the path grammar and Markdown.\n-                        //\n-                        // The example above shows that ambiguity. Is `[u32]` intended to be an\n-                        // intra-doc link to the u32 primitive, or is it intended to be a slice?\n-                        //\n-                        // If the below conditional were removed, we would suggest this, which is\n-                        // not what the user probably wants.\n-                        //\n-                        //     <[u32] as `IntoIter<u32>`>::Item\n-                        //\n-                        // We know that the user actually wants to wrap the whole thing in a code\n-                        // block, but the only reason we know that is because `u32` does not, in\n-                        // fact, implement IntoIter. If the example looks like this:\n-                        //\n-                        //     <[Vec<i32>] as IntoIter<i32>::Item\n-                        //\n-                        // The ideal fix would be significantly different.\n-                        if (generics_start > 0 && dox.as_bytes()[generics_start - 1] == b'<')\n-                            || (generics_end < dox.len() && dox.as_bytes()[generics_end] == b'>')\n-                        {\n-                            return lint;\n-                        }\n-                        // multipart form is chosen here because ``Vec<i32>`` would be confusing.\n-                        lint.multipart_suggestion(\n-                            \"try marking as source code\",\n-                            vec![\n-                                (generics_sp.shrink_to_lo(), String::from(\"`\")),\n-                                (generics_sp.shrink_to_hi(), String::from(\"`\")),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-\n-                    lint\n-                });\n-            };\n-\n-            let mut tags = Vec::new();\n-            let mut is_in_comment = None;\n-            let mut in_code_block = false;\n-\n-            let link_names = item.link_names(&self.cx.cache);\n-\n-            let mut replacer = |broken_link: BrokenLink<'_>| {\n-                if let Some(link) =\n-                    link_names.iter().find(|link| *link.original_text == *broken_link.reference)\n-                {\n-                    Some((link.href.as_str().into(), link.new_text.as_str().into()))\n-                } else if matches!(\n-                    &broken_link.link_type,\n-                    LinkType::Reference | LinkType::ReferenceUnknown\n-                ) {\n-                    // If the link is shaped [like][this], suppress any broken HTML in the [this] part.\n-                    // The `broken_intra_doc_links` will report typos in there anyway.\n-                    Some((\n-                        broken_link.reference.to_string().into(),\n-                        broken_link.reference.to_string().into(),\n-                    ))\n-                } else {\n-                    None\n-                }\n-            };\n-\n-            let p =\n-                Parser::new_with_broken_link_callback(&dox, main_body_opts(), Some(&mut replacer))\n-                    .into_offset_iter();\n-\n-            for (event, range) in p {\n-                match event {\n-                    Event::Start(Tag::CodeBlock(_)) => in_code_block = true,\n-                    Event::Html(text) if !in_code_block => {\n-                        extract_tags(&mut tags, &text, range, &mut is_in_comment, &report_diag)\n-                    }\n-                    Event::End(Tag::CodeBlock(_)) => in_code_block = false,\n-                    _ => {}\n-                }\n-            }\n-\n-            for (tag, range) in tags.iter().filter(|(t, _)| {\n-                let t = t.to_lowercase();\n-                !ALLOWED_UNCLOSED.contains(&t.as_str())\n-            }) {\n-                report_diag(&format!(\"unclosed HTML tag `{}`\", tag), range, true);\n-            }\n-\n-            if let Some(range) = is_in_comment {\n-                report_diag(\"Unclosed HTML comment\", &range, false);\n-            }\n-        }\n-\n-        self.visit_item_recur(item)\n-    }\n-}", "previous_filename": "src/librustdoc/passes/html_tags.rs"}, {"sha": "634e70ec97a0dbad224ca2595f7197d7eb7300f6", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9eb85777fc299c632e86389f12469f932a1cced6/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb85777fc299c632e86389f12469f932a1cced6/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=9eb85777fc299c632e86389f12469f932a1cced6", "patch": "@@ -12,9 +12,6 @@ use crate::core::DocContext;\n mod stripper;\n pub(crate) use stripper::*;\n \n-mod bare_urls;\n-pub(crate) use self::bare_urls::CHECK_BARE_URLS;\n-\n mod strip_hidden;\n pub(crate) use self::strip_hidden::STRIP_HIDDEN;\n \n@@ -36,14 +33,11 @@ pub(crate) use self::check_doc_test_visibility::CHECK_DOC_TEST_VISIBILITY;\n mod collect_trait_impls;\n pub(crate) use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n \n-mod check_code_block_syntax;\n-pub(crate) use self::check_code_block_syntax::CHECK_CODE_BLOCK_SYNTAX;\n-\n mod calculate_doc_coverage;\n pub(crate) use self::calculate_doc_coverage::CALCULATE_DOC_COVERAGE;\n \n-mod html_tags;\n-pub(crate) use self::html_tags::CHECK_INVALID_HTML_TAGS;\n+mod lint;\n+pub(crate) use self::lint::RUN_LINTS;\n \n /// A single pass over the cleaned documentation.\n ///\n@@ -82,11 +76,9 @@ pub(crate) const PASSES: &[Pass] = &[\n     STRIP_PRIV_IMPORTS,\n     PROPAGATE_DOC_CFG,\n     COLLECT_INTRA_DOC_LINKS,\n-    CHECK_CODE_BLOCK_SYNTAX,\n     COLLECT_TRAIT_IMPLS,\n     CALCULATE_DOC_COVERAGE,\n-    CHECK_INVALID_HTML_TAGS,\n-    CHECK_BARE_URLS,\n+    RUN_LINTS,\n ];\n \n /// The list of passes run by default.\n@@ -97,10 +89,8 @@ pub(crate) const DEFAULT_PASSES: &[ConditionalPass] = &[\n     ConditionalPass::new(STRIP_PRIVATE, WhenNotDocumentPrivate),\n     ConditionalPass::new(STRIP_PRIV_IMPORTS, WhenDocumentPrivate),\n     ConditionalPass::always(COLLECT_INTRA_DOC_LINKS),\n-    ConditionalPass::always(CHECK_CODE_BLOCK_SYNTAX),\n-    ConditionalPass::always(CHECK_INVALID_HTML_TAGS),\n     ConditionalPass::always(PROPAGATE_DOC_CFG),\n-    ConditionalPass::always(CHECK_BARE_URLS),\n+    ConditionalPass::always(RUN_LINTS),\n ];\n \n /// The list of default passes run when `--doc-coverage` is passed to rustdoc."}, {"sha": "1678352436315d74046949c81b8f3402974a7db3", "filename": "src/test/rustdoc-ui/issue-91713.stdout", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9eb85777fc299c632e86389f12469f932a1cced6/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9eb85777fc299c632e86389f12469f932a1cced6/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-91713.stdout?ref=9eb85777fc299c632e86389f12469f932a1cced6", "patch": "@@ -5,11 +5,9 @@ check_doc_test_visibility - run various visibility-related lints on doctests\n   strip-priv-imports - strips all private import statements (`use`, `extern crate`) from a crate\n    propagate-doc-cfg - propagates `#[doc(cfg(...))]` to child items\n collect-intra-doc-links - resolves intra-doc links\n-check-code-block-syntax - validates syntax inside Rust code blocks\n  collect-trait-impls - retrieves trait impls for items in the crate\n calculate-doc-coverage - counts the number of items with and without documentation\n-check-invalid-html-tags - detects invalid HTML tags in doc comments\n-     check-bare-urls - detects URLs that are not hyperlinks\n+           run-lints - runs some of rustdoc's lints\n \n Default passes for rustdoc:\n  collect-trait-impls\n@@ -18,10 +16,8 @@ check_doc_test_visibility\n        strip-private  (when not --document-private-items)\n   strip-priv-imports  (when --document-private-items)\n collect-intra-doc-links\n-check-code-block-syntax\n-check-invalid-html-tags\n    propagate-doc-cfg\n-     check-bare-urls\n+           run-lints\n \n Passes run with `--show-coverage`:\n         strip-hidden  (when not --document-hidden-items)"}]}