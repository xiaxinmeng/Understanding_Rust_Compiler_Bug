{"sha": "61fcbfcd59dbc2b8b900aff5ea464330637b210b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZmNiZmNkNTlkYmMyYjhiOTAwYWZmNWVhNDY0MzMwNjM3YjIxMGI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-05-16T12:38:32Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-23T14:27:54Z"}, "message": "rustc_mir: don't rely on mir::UpvarDecl in the MIR borrowck.", "tree": {"sha": "88a54371c9b74e7e89820ce442a0f49eace351a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88a54371c9b74e7e89820ce442a0f49eace351a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61fcbfcd59dbc2b8b900aff5ea464330637b210b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61fcbfcd59dbc2b8b900aff5ea464330637b210b", "html_url": "https://github.com/rust-lang/rust/commit/61fcbfcd59dbc2b8b900aff5ea464330637b210b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61fcbfcd59dbc2b8b900aff5ea464330637b210b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bee49f42b6dfb039d2a8e59e5181e26531c3c11", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bee49f42b6dfb039d2a8e59e5181e26531c3c11", "html_url": "https://github.com/rust-lang/rust/commit/3bee49f42b6dfb039d2a8e59e5181e26531c3c11"}], "stats": {"total": 250, "additions": 159, "deletions": 91}, "files": [{"sha": "04b763f773d9ed089656ceaf854e877dc3117170", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=61fcbfcd59dbc2b8b900aff5ea464330637b210b", "patch": "@@ -133,41 +133,6 @@ impl<'tcx> Place<'tcx> {\n                 proj.base.ty(local_decls, tcx).projection_ty(tcx, &proj.elem),\n         }\n     }\n-\n-    /// If this is a field projection, and the field is being projected from a closure type,\n-    /// then returns the index of the field being projected. Note that this closure will always\n-    /// be `self` in the current MIR, because that is the only time we directly access the fields\n-    /// of a closure type.\n-    pub fn is_upvar_field_projection<'cx, 'gcx>(&self, mir: &'cx Mir<'tcx>,\n-                                                tcx: &TyCtxt<'cx, 'gcx, 'tcx>) -> Option<Field> {\n-        let (place, by_ref) = if let Place::Projection(ref proj) = self {\n-            if let ProjectionElem::Deref = proj.elem {\n-                (&proj.base, true)\n-            } else {\n-                (self, false)\n-            }\n-        } else {\n-            (self, false)\n-        };\n-\n-        match place {\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Field(field, _ty) => {\n-                    let base_ty = proj.base.ty(mir, *tcx).ty;\n-\n-                    if (base_ty.is_closure() || base_ty.is_generator()) &&\n-                        (!by_ref || mir.upvar_decls[field.index()].by_ref)\n-                    {\n-                        Some(field)\n-                    } else {\n-                        None\n-                    }\n-                },\n-                _ => None,\n-            }\n-            _ => None,\n-        }\n-    }\n }\n \n pub enum RvalueInitializationState {"}, {"sha": "12dcea7bd5981d619e16fad91602587925e3afb6", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=61fcbfcd59dbc2b8b900aff5ea464330637b210b", "patch": "@@ -1088,7 +1088,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n                         LocalKind::Var => \"local variable \",\n                         LocalKind::Arg\n-                        if !self.mir.upvar_decls.is_empty()\n+                        if !self.upvars.is_empty()\n                             && local == Local::new(1) => {\n                             \"variable captured by `move` \"\n                         }\n@@ -1632,11 +1632,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n                         let upvar_field_projection =\n-                            place.is_upvar_field_projection(self.mir, &self.infcx.tcx);\n+                            self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n-                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n-                            if self.mir.upvar_decls[var_index].by_ref {\n+                            let name = self.upvars[var_index].name.to_string();\n+                            if self.upvars[var_index].by_ref {\n                                 buf.push_str(&name);\n                             } else {\n                                 buf.push_str(&format!(\"*{}\", &name));\n@@ -1694,10 +1694,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         autoderef = true;\n \n                         let upvar_field_projection =\n-                            place.is_upvar_field_projection(self.mir, &self.infcx.tcx);\n+                            self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n-                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n+                            let name = self.upvars[var_index].name.to_string();\n                             buf.push_str(&name);\n                         } else {\n                             let field_name = self.describe_field(&proj.base, field);"}, {"sha": "14cafdef67d7de8b2cf931f3f22a66bf0009b3e5", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 94, "deletions": 16, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=61fcbfcd59dbc2b8b900aff5ea464330637b210b", "patch": "@@ -1,7 +1,7 @@\n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n-use rustc::hir;\n+use rustc::hir::{self, HirId};\n use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n@@ -27,6 +27,7 @@ use std::collections::BTreeMap;\n use std::mem;\n use std::rc::Rc;\n \n+use syntax::ast::Name;\n use syntax_pos::{Span, DUMMY_SP};\n \n use crate::dataflow::indexes::{BorrowIndex, InitIndex, MoveOutIndex, MovePathIndex};\n@@ -63,6 +64,19 @@ mod used_muts;\n \n pub(crate) mod nll;\n \n+// FIXME(eddyb) perhaps move this somewhere more centrally.\n+#[derive(Debug)]\n+crate struct Upvar {\n+    name: Name,\n+\n+    var_hir_id: HirId,\n+\n+    /// If true, the capture is behind a reference.\n+    by_ref: bool,\n+\n+    mutability: Mutability,\n+}\n+\n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n         mir_borrowck,\n@@ -126,6 +140,36 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         .as_local_hir_id(def_id)\n         .expect(\"do_mir_borrowck: non-local DefId\");\n \n+    // Gather the upvars of a closure, if any.\n+    let tables = tcx.typeck_tables_of(def_id);\n+    let upvars: Vec<_> = tables\n+        .upvar_list\n+        .get(&def_id)\n+        .into_iter()\n+        .flatten()\n+        .map(|upvar_id| {\n+            let var_hir_id = upvar_id.var_path.hir_id;\n+            let var_node_id = tcx.hir().hir_to_node_id(var_hir_id);\n+            let capture = tables.upvar_capture(*upvar_id);\n+            let by_ref = match capture {\n+                ty::UpvarCapture::ByValue => false,\n+                ty::UpvarCapture::ByRef(..) => true,\n+            };\n+            let mut upvar = Upvar {\n+                name: tcx.hir().name(var_node_id),\n+                var_hir_id,\n+                by_ref,\n+                mutability: Mutability::Not,\n+            };\n+            let bm = *tables.pat_binding_modes().get(var_hir_id)\n+                .expect(\"missing binding mode\");\n+            if bm == ty::BindByValue(hir::MutMutable) {\n+                upvar.mutability = Mutability::Mut;\n+            }\n+            upvar\n+        })\n+        .collect();\n+\n     // Replace all regions with fresh inference variables. This\n     // requires first making our own copy of the MIR. This copy will\n     // be modified (in place) to contain non-lexical lifetimes. It\n@@ -168,6 +212,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         def_id,\n         free_regions,\n         mir,\n+        &upvars,\n         location_table,\n         param_env,\n         &mut flow_inits,\n@@ -240,6 +285,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         used_mut_upvars: SmallVec::new(),\n         borrow_set,\n         dominators,\n+        upvars,\n     };\n \n     let mut state = Flows::new(\n@@ -475,6 +521,9 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n \n     /// Dominators for MIR\n     dominators: Dominators<BasicBlock>,\n+\n+    /// Information about upvars not necessarily preserved in types or MIR\n+    upvars: Vec<Upvar>,\n }\n \n // Check that:\n@@ -1287,8 +1336,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let propagate_closure_used_mut_place = |this: &mut Self, place: &Place<'tcx>| {\n             match *place {\n                 Place::Projection { .. } => {\n-                    if let Some(field) = place.is_upvar_field_projection(\n-                            this.mir, &this.infcx.tcx) {\n+                    if let Some(field) = this.is_upvar_field_projection(place) {\n                         this.used_mut_upvars.push(field);\n                     }\n                 }\n@@ -2057,7 +2105,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 place: place @ Place::Projection(_),\n                 is_local_mutation_allowed: _,\n             } => {\n-                if let Some(field) = place.is_upvar_field_projection(self.mir, &self.infcx.tcx) {\n+                if let Some(field) = self.is_upvar_field_projection(place) {\n                     self.used_mut_upvars.push(field);\n                 }\n             }\n@@ -2127,13 +2175,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        let mode = match place.is_upvar_field_projection(\n-                                            self.mir, &self.infcx.tcx)\n-                                        {\n+                                        let mode = match self.is_upvar_field_projection(place) {\n                                             Some(field)\n-                                                if {\n-                                                    self.mir.upvar_decls[field.index()].by_ref\n-                                                } =>\n+                                                if self.upvars[field.index()].by_ref =>\n                                             {\n                                                 is_local_mutation_allowed\n                                             }\n@@ -2173,15 +2217,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. }\n                     | ProjectionElem::Downcast(..) => {\n-                        let upvar_field_projection = place.is_upvar_field_projection(\n-                            self.mir, &self.infcx.tcx);\n+                        let upvar_field_projection = self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n-                            let decl = &self.mir.upvar_decls[field.index()];\n+                            let upvar = &self.upvars[field.index()];\n                             debug!(\n-                                \"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n-                                decl, is_local_mutation_allowed, place\n+                                \"upvar.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n+                                upvar, is_local_mutation_allowed, place\n                             );\n-                            match (decl.mutability, is_local_mutation_allowed) {\n+                            match (upvar.mutability, is_local_mutation_allowed) {\n                                 (Mutability::Not, LocalMutationIsAllowed::No)\n                                 | (Mutability::Not, LocalMutationIsAllowed::ExceptUpvars) => {\n                                     Err(place)\n@@ -2229,6 +2272,41 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n     }\n+\n+    /// If `place` is a field projection, and the field is being projected from a closure type,\n+    /// then returns the index of the field being projected. Note that this closure will always\n+    /// be `self` in the current MIR, because that is the only time we directly access the fields\n+    /// of a closure type.\n+    pub fn is_upvar_field_projection(&self, place: &Place<'tcx>) -> Option<Field> {\n+        let (place, by_ref) = if let Place::Projection(ref proj) = place {\n+            if let ProjectionElem::Deref = proj.elem {\n+                (&proj.base, true)\n+            } else {\n+                (place, false)\n+            }\n+        } else {\n+            (place, false)\n+        };\n+\n+        match place {\n+            Place::Projection(ref proj) => match proj.elem {\n+                ProjectionElem::Field(field, _ty) => {\n+                    let tcx = self.infcx.tcx;\n+                    let base_ty = proj.base.ty(self.mir, tcx).ty;\n+\n+                    if (base_ty.is_closure() || base_ty.is_generator()) &&\n+                        (!by_ref || self.upvars[field.index()].by_ref)\n+                    {\n+                        Some(field)\n+                    } else {\n+                        None\n+                    }\n+                },\n+                _ => None,\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]"}, {"sha": "a7bad44c42c7f500f9b85a2894dabb4506ebfc55", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=61fcbfcd59dbc2b8b900aff5ea464330637b210b", "patch": "@@ -256,7 +256,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             let origin = Origin::Mir;\n             debug!(\"report: original_path={:?} span={:?}, kind={:?} \\\n                    original_path.is_upvar_field_projection={:?}\", original_path, span, kind,\n-                   original_path.is_upvar_field_projection(self.mir, &self.infcx.tcx));\n+                   self.is_upvar_field_projection(original_path));\n             (\n                 match kind {\n                     IllegalMoveOriginKind::Static => {\n@@ -269,16 +269,15 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         let ty = place.ty(self.mir, self.infcx.tcx).ty;\n                         let is_upvar_field_projection =\n                             self.prefixes(&original_path, PrefixSet::All)\n-                            .any(|p| p.is_upvar_field_projection(self.mir, &self.infcx.tcx)\n-                                 .is_some());\n+                            .any(|p| self.is_upvar_field_projection(p).is_some());\n                         debug!(\"report: ty={:?}\", ty);\n                         match ty.sty {\n                             ty::Array(..) | ty::Slice(..) =>\n                                 self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n                                     span, ty, None, origin\n                                 ),\n                             ty::Closure(def_id, closure_substs)\n-                                if !self.mir.upvar_decls.is_empty() && is_upvar_field_projection\n+                                if def_id == self.mir_def_id && is_upvar_field_projection\n                             => {\n                                 let closure_kind_ty =\n                                     closure_substs.closure_kind_ty(def_id, self.infcx.tcx);\n@@ -303,11 +302,8 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                                     span, place_description, origin);\n \n                                 for prefix in self.prefixes(&original_path, PrefixSet::All) {\n-                                    if let Some(field) = prefix.is_upvar_field_projection(\n-                                            self.mir, &self.infcx.tcx) {\n-                                        let upvar_decl = &self.mir.upvar_decls[field.index()];\n-                                        let upvar_hir_id =\n-                                            upvar_decl.var_hir_id.assert_crate_local();\n+                                    if let Some(field) = self.is_upvar_field_projection(prefix) {\n+                                        let upvar_hir_id = self.upvars[field.index()].var_hir_id;\n                                         let upvar_span = self.infcx.tcx.hir().span_by_hir_id(\n                                             upvar_hir_id);\n                                         diag.span_label(upvar_span, \"captured outer variable\");"}, {"sha": "c5ad2b18c23fcf634b31a2ea7c61dd3e58a1d4e6", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=61fcbfcd59dbc2b8b900aff5ea464330637b210b", "patch": "@@ -68,10 +68,10 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                if access_place.is_upvar_field_projection(self.mir, &self.infcx.tcx).is_some() {\n+                if self.is_upvar_field_projection(access_place).is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n-                    let name = self.mir.upvar_decls[upvar_index.index()].debug_name;\n+                    let name = self.upvars[upvar_index.index()].name;\n                     reason = format!(\", as `{}` is not declared as mutable\", name);\n                 }\n             }\n@@ -81,15 +81,14 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Deref,\n             }) => {\n                 if *base == Place::Base(PlaceBase::Local(Local::new(1))) &&\n-                    !self.mir.upvar_decls.is_empty() {\n+                    !self.upvars.is_empty() {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.mir.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n                         the_place_err.ty(self.mir, self.infcx.tcx).ty\n                     ));\n \n-                    reason = if access_place.is_upvar_field_projection(self.mir,\n-                                                                       &self.infcx.tcx).is_some() {\n+                    reason = if self.is_upvar_field_projection(access_place).is_some() {\n                         \", as it is a captured variable in a `Fn` closure\".to_string()\n                     } else {\n                         \", as `Fn` closures cannot mutate their captured variables\".to_string()\n@@ -309,9 +308,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n-                let upvar_hir_id = self.mir.upvar_decls[upvar_index.index()]\n-                    .var_hir_id\n-                    .assert_crate_local();\n+                let upvar_hir_id = self.upvars[upvar_index.index()].var_hir_id;\n                 let upvar_node_id = self.infcx.tcx.hir().hir_to_node_id(upvar_hir_id);\n                 if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_node_id) {\n                     if let hir::PatKind::Binding(\n@@ -452,7 +449,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 base,\n                 elem: ProjectionElem::Deref,\n             }) if *base == Place::Base(PlaceBase::Local(Local::new(1))) &&\n-                  !self.mir.upvar_decls.is_empty() =>\n+                  !self.upvars.is_empty() =>\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_help("}, {"sha": "0430ad307ce8d54a0df4326232eee1c6987d8ae5", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=61fcbfcd59dbc2b8b900aff5ea464330637b210b", "patch": "@@ -298,6 +298,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     let (category, from_closure, span, region_name) =\n                         self.nonlexical_regioncx.free_region_constraint_info(\n                             self.mir,\n+                        &self.upvars,\n                             self.mir_def_id,\n                             self.infcx,\n                             borrow_region_vid,"}, {"sha": "ad43c8ef66f42b5ecf5bc6d52ea46d618745d65a", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=61fcbfcd59dbc2b8b900aff5ea464330637b210b", "patch": "@@ -8,6 +8,7 @@ use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n use crate::transform::MirSource;\n+use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Mir};\n@@ -72,6 +73,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n+    upvars: &[Upvar],\n     location_table: &LocationTable,\n     param_env: ty::ParamEnv<'gcx>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'cx, 'gcx, 'tcx>>,\n@@ -187,7 +189,8 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     });\n \n     // Solve the region constraints.\n-    let closure_region_requirements = regioncx.solve(infcx, &mir, def_id, errors_buffer);\n+    let closure_region_requirements =\n+        regioncx.solve(infcx, &mir, upvars, def_id, errors_buffer);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging."}, {"sha": "abb30d042ca4cd8e819ee4a9ffb3f868e5d60a7a", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=61fcbfcd59dbc2b8b900aff5ea464330637b210b", "patch": "@@ -4,6 +4,7 @@ use crate::borrow_check::nll::type_check::Locations;\n use crate::borrow_check::nll::universal_regions::DefiningTy;\n use crate::borrow_check::nll::ConstraintDescription;\n use crate::util::borrowck_errors::{BorrowckErrors, Origin};\n+use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n@@ -237,6 +238,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(super) fn report_error(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n@@ -273,6 +275,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(infcx, fr) => {\n                 self.report_fnmut_error(\n                     mir,\n+                    upvars,\n                     infcx,\n                     mir_def_id,\n                     fr,\n@@ -284,6 +287,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             (ConstraintCategory::Assignment, true, false)\n             | (ConstraintCategory::CallArgument, true, false) => self.report_escaping_data_error(\n                 mir,\n+                upvars,\n                 infcx,\n                 mir_def_id,\n                 fr,\n@@ -294,6 +298,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             ),\n             _ => self.report_general_error(\n                 mir,\n+                upvars,\n                 infcx,\n                 mir_def_id,\n                 fr,\n@@ -353,6 +358,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn report_fnmut_error(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n         _fr: RegionVid,\n@@ -377,7 +383,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         diag.span_label(span, message);\n \n-        match self.give_region_a_name(infcx, mir, mir_def_id, outlived_fr, &mut 1).unwrap().source {\n+        match self.give_region_a_name(infcx, mir, upvars, mir_def_id, outlived_fr, &mut 1)\n+            .unwrap().source\n+        {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n             | RegionNameSource::NamedFreeRegion(fr_span)\n             | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n@@ -415,6 +423,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn report_escaping_data_error(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n@@ -423,9 +432,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         span: Span,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n-        let fr_name_and_span = self.get_var_name_and_span_for_region(infcx.tcx, mir, fr);\n+        let fr_name_and_span =\n+            self.get_var_name_and_span_for_region(infcx.tcx, mir, upvars, fr);\n         let outlived_fr_name_and_span =\n-            self.get_var_name_and_span_for_region(infcx.tcx, mir, outlived_fr);\n+            self.get_var_name_and_span_for_region(infcx.tcx, mir, upvars, outlived_fr);\n \n         let escapes_from = match self.universal_regions.defining_ty {\n             DefiningTy::Closure(..) => \"closure\",\n@@ -442,6 +452,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         {\n             return self.report_general_error(\n                 mir,\n+                upvars,\n                 infcx,\n                 mir_def_id,\n                 fr,\n@@ -504,6 +515,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn report_general_error(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n@@ -520,10 +532,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         let counter = &mut 1;\n-        let fr_name = self.give_region_a_name(infcx, mir, mir_def_id, fr, counter).unwrap();\n+        let fr_name = self.give_region_a_name(infcx, mir, upvars, mir_def_id, fr, counter).unwrap();\n         fr_name.highlight_region_name(&mut diag);\n         let outlived_fr_name =\n-            self.give_region_a_name(infcx, mir, mir_def_id, outlived_fr, counter).unwrap();\n+            self.give_region_a_name(infcx, mir, upvars, mir_def_id, outlived_fr, counter).unwrap();\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n         let mir_def_name = if infcx.tcx.is_closure(mir_def_id) {\n@@ -656,6 +668,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn free_region_constraint_info(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         borrow_region: RegionVid,\n@@ -664,7 +677,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let (category, from_closure, span) =\n             self.best_blame_constraint(mir, borrow_region, |r| r == outlived_region);\n         let outlived_fr_name =\n-            self.give_region_a_name(infcx, mir, mir_def_id, outlived_region, &mut 1);\n+            self.give_region_a_name(infcx, mir, upvars, mir_def_id, outlived_region, &mut 1);\n         (category, from_closure, span, outlived_fr_name)\n     }\n "}, {"sha": "680e7ce576af04ef6addfb05fb4e43869237da9e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=61fcbfcd59dbc2b8b900aff5ea464330637b210b", "patch": "@@ -2,6 +2,7 @@ use std::fmt::{self, Display};\n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n use crate::borrow_check::nll::universal_regions::DefiningTy;\n use crate::borrow_check::nll::ToRegionVid;\n+use crate::borrow_check::Upvar;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n@@ -144,6 +145,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n@@ -160,7 +162,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_upvars(\n-                    infcx.tcx, mir, fr, counter,\n+                    infcx.tcx, upvars, fr, counter,\n                 )\n             })\n             .or_else(|| {\n@@ -639,13 +641,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn give_name_if_anonymous_region_appears_in_upvars(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         fr: RegionVid,\n         counter: &mut usize,\n     ) -> Option<RegionName> {\n         let upvar_index = self.get_upvar_index_for_region(tcx, fr)?;\n         let (upvar_name, upvar_span) =\n-            self.get_upvar_name_and_span_for_region(tcx, mir, upvar_index);\n+            self.get_upvar_name_and_span_for_region(tcx, upvars, upvar_index);\n         let region_name = self.synthesize_region_name(counter);\n \n         Some(RegionName {"}, {"sha": "d8f34233839b9796d77f437ff6a2fb7603a84235", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=61fcbfcd59dbc2b8b900aff5ea464330637b210b", "patch": "@@ -1,5 +1,6 @@\n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n use crate::borrow_check::nll::ToRegionVid;\n+use crate::borrow_check::Upvar;\n use rustc::mir::{Local, Mir};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -11,6 +12,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         fr: RegionVid,\n     ) -> Option<(Option<Symbol>, Span)> {\n         debug!(\"get_var_name_and_span_for_region(fr={:?})\", fr);\n@@ -19,7 +21,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"get_var_name_and_span_for_region: attempting upvar\");\n         self.get_upvar_index_for_region(tcx, fr)\n             .map(|index| {\n-                let (name, span) = self.get_upvar_name_and_span_for_region(tcx, mir, index);\n+                let (name, span) =\n+                    self.get_upvar_name_and_span_for_region(tcx, upvars, index);\n                 (Some(name), span)\n             })\n             .or_else(|| {\n@@ -67,10 +70,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn get_upvar_name_and_span_for_region(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         upvar_index: usize,\n     ) -> (Symbol, Span) {\n-        let upvar_hir_id = mir.upvar_decls[upvar_index].var_hir_id.assert_crate_local();\n+        let upvar_hir_id = upvars[upvar_index].var_hir_id;\n         debug!(\"get_upvar_name_and_span_for_region: upvar_hir_id={:?}\", upvar_hir_id);\n \n         let upvar_name = tcx.hir().name_by_hir_id(upvar_hir_id);"}, {"sha": "9dd18ab76a5f2268a7d908e255afb2f1e694e148", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=61fcbfcd59dbc2b8b900aff5ea464330637b210b", "patch": "@@ -4,6 +4,7 @@ use crate::borrow_check::nll::constraints::{ConstraintSccIndex, ConstraintSet, O\n use crate::borrow_check::nll::region_infer::values::{\n     PlaceholderIndices, RegionElement, ToElementIndex\n };\n+use crate::borrow_check::Upvar;\n use crate::borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use crate::borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n@@ -400,21 +401,23 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &mut self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n         common::time_ext(\n             infcx.tcx.sess.time_extended(),\n             Some(infcx.tcx.sess),\n             &format!(\"solve_nll_region_constraints({:?})\", mir_def_id),\n-            || self.solve_inner(infcx, mir, mir_def_id, errors_buffer),\n+            || self.solve_inner(infcx, mir, upvars, mir_def_id, errors_buffer),\n         )\n     }\n \n     fn solve_inner<'gcx>(\n         &mut self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n@@ -442,6 +445,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.check_universal_regions(\n             infcx,\n             mir,\n+            upvars,\n             mir_def_id,\n             outlives_requirements.as_mut(),\n             errors_buffer,\n@@ -1102,6 +1106,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n@@ -1115,6 +1120,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_universal_region(\n                         infcx,\n                         mir,\n+                        upvars,\n                         mir_def_id,\n                         fr,\n                         &mut propagated_outlives_requirements,\n@@ -1145,6 +1151,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n@@ -1177,6 +1184,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 representative,\n                 infcx,\n                 mir,\n+                upvars,\n                 mir_def_id,\n                 propagated_outlives_requirements,\n                 errors_buffer,\n@@ -1192,6 +1200,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 shorter_fr,\n                 infcx,\n                 mir,\n+                upvars,\n                 mir_def_id,\n                 propagated_outlives_requirements,\n                 errors_buffer,\n@@ -1208,6 +1217,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         shorter_fr: RegionVid,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n@@ -1265,7 +1275,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         //\n         // Note: in this case, we use the unapproximated regions to report the\n         // error. This gives better error messages in some cases.\n-        self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n+        self.report_error(mir, upvars, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n         Some(ErrorReported)\n     }\n "}, {"sha": "d3cef46b4022d860d77cd9d4808a4d9fb530284c", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61fcbfcd59dbc2b8b900aff5ea464330637b210b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=61fcbfcd59dbc2b8b900aff5ea464330637b210b", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> DefiningTy<'tcx> {\n     /// Returns a list of all the upvar types for this MIR. If this is\n     /// not a closure or generator, there are no upvars, and hence it\n     /// will be an empty list. The order of types in this list will\n-    /// match up with the `upvar_decls` field of `Mir`.\n+    /// match up with the upvar order in the HIR, typesystem, and MIR.\n     pub fn upvar_tys(self, tcx: TyCtxt<'_, '_, 'tcx>) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         match self {\n             DefiningTy::Closure(def_id, substs) => Either::Left(substs.upvar_tys(def_id, tcx)),"}]}