{"sha": "a9f1e1c440ae20f0ea99f5e265f24094f1a613a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ZjFlMWM0NDBhZTIwZjBlYTk5ZjVlMjY1ZjI0MDk0ZjFhNjEzYTU=", "commit": {"author": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-07-13T14:50:40Z"}, "committer": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-07-13T14:50:40Z"}, "message": "WIP partial apply fix", "tree": {"sha": "de78ff399607f92a362d25c6308a783b5c5b69b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de78ff399607f92a362d25c6308a783b5c5b69b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9f1e1c440ae20f0ea99f5e265f24094f1a613a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9f1e1c440ae20f0ea99f5e265f24094f1a613a5", "html_url": "https://github.com/rust-lang/rust/commit/a9f1e1c440ae20f0ea99f5e265f24094f1a613a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9f1e1c440ae20f0ea99f5e265f24094f1a613a5/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c63f1fe92b99a9828e9f999355213b0b73175aa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c63f1fe92b99a9828e9f999355213b0b73175aa0", "html_url": "https://github.com/rust-lang/rust/commit/c63f1fe92b99a9828e9f999355213b0b73175aa0"}], "stats": {"total": 297, "additions": 193, "deletions": 104}, "files": [{"sha": "4f74f86564d1561cdf2b5fbc82c434cce9b57a22", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 167, "deletions": 101, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/a9f1e1c440ae20f0ea99f5e265f24094f1a613a5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f1e1c440ae20f0ea99f5e265f24094f1a613a5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=a9f1e1c440ae20f0ea99f5e265f24094f1a613a5", "patch": "@@ -298,6 +298,7 @@ struct AssocTypeNormalizer<'a, 'b, 'tcx> {\n     cause: ObligationCause<'tcx>,\n     obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n     depth: usize,\n+    universes: Vec<Option<ty::UniverseIndex>>,\n }\n \n impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n@@ -308,12 +309,16 @@ impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n         depth: usize,\n         obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n     ) -> AssocTypeNormalizer<'a, 'b, 'tcx> {\n-        AssocTypeNormalizer { selcx, param_env, cause, obligations, depth }\n+        AssocTypeNormalizer { selcx, param_env, cause, obligations, depth, universes: vec![] }\n     }\n \n     fn fold<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n         let value = self.selcx.infcx().resolve_vars_if_possible(value);\n \n+        if value.has_escaping_bound_vars() {\n+            bug!(\"Normalizing without wrapping in a `Binder`\");\n+        }\n+\n         if !value.has_projections() { value } else { value.fold_with(self) }\n     }\n }\n@@ -323,6 +328,16 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n         self.selcx.tcx()\n     }\n \n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n+        self.universes.push(None);\n+        let t = t.super_fold_with(self);\n+        self.universes.pop();\n+        t\n+    }\n+\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         if !ty.has_projections() {\n             return ty;\n@@ -412,37 +427,40 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 // give up and fall back to pretending like we never tried!\n \n                 let infcx = self.selcx.infcx();\n-                let (data, mapped_regions, mapped_types, mapped_consts, universe_map) =\n-                    BoundVarReplacer::replace_bound_vars(infcx, data);\n-\n-                let normalized_ty = opt_normalize_projection_type(\n-                    self.selcx,\n-                    self.param_env,\n-                    data,\n-                    self.cause.clone(),\n-                    self.depth,\n-                    &mut self.obligations,\n-                )\n-                .ok()\n-                .flatten()\n-                .unwrap_or_else(|| ty);\n-\n-                let normalized_ty = PlaceholderReplacer::replace_placeholders(\n-                    infcx,\n-                    mapped_regions,\n-                    mapped_types,\n-                    mapped_consts,\n-                    universe_map,\n-                    normalized_ty,\n-                );\n-                debug!(\n-                    ?self.depth,\n-                    ?ty,\n-                    ?normalized_ty,\n-                    obligations.len = ?self.obligations.len(),\n-                    \"AssocTypeNormalizer: normalized type\"\n-                );\n-                normalized_ty\n+                let replaced =\n+                    BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n+                if let Some((data, mapped_regions, mapped_types, mapped_consts)) = replaced {\n+                    let normalized_ty = opt_normalize_projection_type(\n+                        self.selcx,\n+                        self.param_env,\n+                        data,\n+                        self.cause.clone(),\n+                        self.depth,\n+                        &mut self.obligations,\n+                    )\n+                    .ok()\n+                    .flatten()\n+                    .unwrap_or_else(|| ty);\n+\n+                    let normalized_ty = PlaceholderReplacer::replace_placeholders(\n+                        infcx,\n+                        mapped_regions,\n+                        mapped_types,\n+                        mapped_consts,\n+                        &self.universes,\n+                        normalized_ty,\n+                    );\n+                    debug!(\n+                        ?self.depth,\n+                        ?ty,\n+                        ?normalized_ty,\n+                        obligations.len = ?self.obligations.len(),\n+                        \"AssocTypeNormalizer: normalized type\"\n+                    );\n+                    normalized_ty\n+                } else {\n+                    ty\n+                }\n             }\n \n             _ => ty,\n@@ -460,26 +478,42 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n }\n \n pub struct BoundVarReplacer<'me, 'tcx> {\n-    pub infcx: &'me InferCtxt<'me, 'tcx>,\n-    pub mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n-    pub mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n-    pub mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n-    pub universes: BTreeMap<ty::DebruijnIndex, ty::UniverseIndex>,\n-    pub universes_inverse: BTreeMap<ty::UniverseIndex, ty::DebruijnIndex>,\n-    pub current_index: ty::DebruijnIndex,\n+    infcx: &'me InferCtxt<'me, 'tcx>,\n+    // These three maps track the bound variable that were replaced by placeholders. It might be\n+    // nice to remove these since we already have the `kind` in the placeholder; we really just need\n+    // the `var` (but we *could* bring that into scope if we were to track them as we pass them).\n+    mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n+    mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n+    mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n+    // The current depth relative to *this* folding, *not* the entire normalization. In other words,\n+    // the depth of binders we've passed here.\n+    current_index: ty::DebruijnIndex,\n+    // The `UniverseIndex` of the binding levels above us. These are optional, since we are lazy:\n+    // we don't actually create a universe until we see a bound var we have to replace.\n+    universe_indices: &'me mut Vec<Option<ty::UniverseIndex>>,\n+    // FIXME: So, this is a less-than-ideal solution to a problem we want to solve eventually. Ideally, we\n+    // shouldn't need to worry about bound vars for which we haven't passed (`self.current_index`)\n+    // or that we don't explicitly know about (`self.universe_indices`). This is true for\n+    // `AssocTypeNormalizer` but not `QueryNormalizer` currently. When we can always know about\n+    // any binding levels above us, we can remove this. (The alternative would be\n+    // `outer_exclusive_binder`, but that only exists on `Ty`. Otherwise, we would have to visit\n+    // through the `T`, which we specifically want to avoid not being lazy.)\n+    failed: bool,\n }\n \n impl<'me, 'tcx> BoundVarReplacer<'me, 'tcx> {\n+    /// Returns `Some` if we *were* able to replace bound vars. If there are any bound vars that\n+    /// use a binding level above `universe_indices.len()`, we fail.\n     pub fn replace_bound_vars<T: TypeFoldable<'tcx>>(\n         infcx: &'me InferCtxt<'me, 'tcx>,\n+        universe_indices: &'me mut Vec<Option<ty::UniverseIndex>>,\n         value: T,\n-    ) -> (\n+    ) -> Option<(\n         T,\n         BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n         BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n         BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n-        BTreeMap<ty::UniverseIndex, ty::DebruijnIndex>,\n-    ) {\n+    )> {\n         let mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion> = BTreeMap::new();\n         let mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy> = BTreeMap::new();\n         let mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar> = BTreeMap::new();\n@@ -489,20 +523,16 @@ impl<'me, 'tcx> BoundVarReplacer<'me, 'tcx> {\n             mapped_regions,\n             mapped_types,\n             mapped_consts,\n-            universes: BTreeMap::new(),\n-            universes_inverse: BTreeMap::new(),\n             current_index: ty::INNERMOST,\n+            universe_indices,\n+            failed: false,\n         };\n \n         let value = value.super_fold_with(&mut replacer);\n \n-        (\n-            value,\n-            replacer.mapped_regions,\n-            replacer.mapped_types,\n-            replacer.mapped_consts,\n-            replacer.universes_inverse,\n-        )\n+        (!replacer.failed).then(|| {\n+            (value, replacer.mapped_regions, replacer.mapped_types, replacer.mapped_consts)\n+        })\n     }\n }\n \n@@ -523,15 +553,24 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReLateBound(debruijn, br) => {\n+            ty::ReLateBound(debruijn, _)\n+                if debruijn.as_usize() + 1\n+                    > self.current_index.as_usize() + self.universe_indices.len() =>\n+            {\n+                self.failed = true;\n+                r\n+            }\n+            ty::ReLateBound(debruijn, br) if debruijn >= self.current_index => {\n                 let infcx = self.infcx;\n-                let placeholder_db_index =\n-                    ty::DebruijnIndex::from_u32(self.current_index.as_u32() - debruijn.as_u32());\n-                let universe = *self\n-                    .universes\n-                    .entry(placeholder_db_index)\n-                    .or_insert_with(|| infcx.create_next_universe());\n-                self.universes_inverse.insert(universe, placeholder_db_index);\n+                let index = self.universe_indices.len() - debruijn.as_usize()\n+                    + self.current_index.as_usize()\n+                    - 1;\n+                let universe = self.universe_indices[index].unwrap_or_else(|| {\n+                    for i in self.universe_indices.iter_mut().take(index + 1) {\n+                        *i = i.or_else(|| Some(infcx.create_next_universe()))\n+                    }\n+                    self.universe_indices[index].unwrap()\n+                });\n                 let p = ty::PlaceholderRegion { universe, name: br.kind };\n                 self.mapped_regions.insert(p.clone(), br);\n                 self.infcx.tcx.mk_region(ty::RePlaceholder(p))\n@@ -542,15 +581,24 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match *t.kind() {\n-            ty::Bound(debruijn, bound_ty) => {\n+            ty::Bound(debruijn, _)\n+                if debruijn.as_usize() + 1\n+                    > self.current_index.as_usize() + self.universe_indices.len() =>\n+            {\n+                self.failed = true;\n+                t\n+            }\n+            ty::Bound(debruijn, bound_ty) if debruijn >= self.current_index => {\n                 let infcx = self.infcx;\n-                let placeholder_db_index =\n-                    ty::DebruijnIndex::from_u32(self.current_index.as_u32() - debruijn.as_u32());\n-                let universe = *self\n-                    .universes\n-                    .entry(placeholder_db_index)\n-                    .or_insert_with(|| infcx.create_next_universe());\n-                self.universes_inverse.insert(universe, placeholder_db_index);\n+                let index = self.universe_indices.len() - debruijn.as_usize()\n+                    + self.current_index.as_usize()\n+                    - 1;\n+                let universe = self.universe_indices[index].unwrap_or_else(|| {\n+                    for i in self.universe_indices.iter_mut().take(index + 1) {\n+                        *i = i.or_else(|| Some(infcx.create_next_universe()))\n+                    }\n+                    self.universe_indices[index].unwrap()\n+                });\n                 let p = ty::PlaceholderType { universe, name: bound_ty.var };\n                 self.mapped_types.insert(p.clone(), bound_ty);\n                 self.infcx.tcx.mk_ty(ty::Placeholder(p))\n@@ -562,15 +610,26 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         match *ct {\n-            ty::Const { val: ty::ConstKind::Bound(debruijn, bound_const), ty } => {\n+            ty::Const { val: ty::ConstKind::Bound(debruijn, _), ty: _ }\n+                if debruijn.as_usize() + 1\n+                    > self.current_index.as_usize() + self.universe_indices.len() =>\n+            {\n+                self.failed = true;\n+                ct\n+            }\n+            ty::Const { val: ty::ConstKind::Bound(debruijn, bound_const), ty }\n+                if debruijn >= self.current_index =>\n+            {\n                 let infcx = self.infcx;\n-                let placeholder_db_index =\n-                    ty::DebruijnIndex::from_u32(self.current_index.as_u32() - debruijn.as_u32());\n-                let universe = *self\n-                    .universes\n-                    .entry(placeholder_db_index)\n-                    .or_insert_with(|| infcx.create_next_universe());\n-                self.universes_inverse.insert(universe, placeholder_db_index);\n+                let index = self.universe_indices.len() - debruijn.as_usize()\n+                    + self.current_index.as_usize()\n+                    - 1;\n+                let universe = self.universe_indices[index].unwrap_or_else(|| {\n+                    for i in self.universe_indices.iter_mut().take(index + 1) {\n+                        *i = i.or_else(|| Some(infcx.create_next_universe()))\n+                    }\n+                    self.universe_indices[index].unwrap()\n+                });\n                 let p = ty::PlaceholderConst {\n                     universe,\n                     name: ty::BoundConst { var: bound_const, ty },\n@@ -584,13 +643,14 @@ impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n     }\n }\n \n+// The inverse of `BoundVarReplacer`: replaces placeholders with the bound vars from which they came.\n pub struct PlaceholderReplacer<'me, 'tcx> {\n-    pub infcx: &'me InferCtxt<'me, 'tcx>,\n-    pub mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n-    pub mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n-    pub mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n-    pub universes_inverse: BTreeMap<ty::UniverseIndex, ty::DebruijnIndex>,\n-    pub current_index: ty::DebruijnIndex,\n+    infcx: &'me InferCtxt<'me, 'tcx>,\n+    mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n+    mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n+    mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n+    universe_indices: &'me Vec<Option<ty::UniverseIndex>>,\n+    current_index: ty::DebruijnIndex,\n }\n \n impl<'me, 'tcx> PlaceholderReplacer<'me, 'tcx> {\n@@ -599,15 +659,15 @@ impl<'me, 'tcx> PlaceholderReplacer<'me, 'tcx> {\n         mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n         mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n         mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n-        universes_inverse: BTreeMap<ty::UniverseIndex, ty::DebruijnIndex>,\n+        universe_indices: &'me Vec<Option<ty::UniverseIndex>>,\n         value: T,\n     ) -> T {\n         let mut replacer = PlaceholderReplacer {\n             infcx,\n             mapped_regions,\n             mapped_types,\n             mapped_consts,\n-            universes_inverse,\n+            universe_indices,\n             current_index: ty::INNERMOST,\n         };\n         value.super_fold_with(&mut replacer)\n@@ -648,13 +708,15 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n                 let replace_var = self.mapped_regions.get(&p);\n                 match replace_var {\n                     Some(replace_var) => {\n-                        let db = self\n-                            .universes_inverse\n-                            .get(&p.universe)\n+                        let index = self\n+                            .universe_indices\n+                            .iter()\n+                            .position(|u| matches!(u, Some(pu) if *pu == p.universe))\n                             .unwrap_or_else(|| bug!(\"Unexpected placeholder universe.\"));\n-                        let index =\n-                            ty::DebruijnIndex::from_u32(db.as_u32() + self.current_index.as_u32());\n-                        self.tcx().mk_region(ty::ReLateBound(index, *replace_var))\n+                        let db = ty::DebruijnIndex::from_usize(\n+                            self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n+                        );\n+                        self.tcx().mk_region(ty::ReLateBound(db, *replace_var))\n                     }\n                     None => r1,\n                 }\n@@ -673,13 +735,15 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n                 let replace_var = self.mapped_types.get(&p);\n                 match replace_var {\n                     Some(replace_var) => {\n-                        let db = self\n-                            .universes_inverse\n-                            .get(&p.universe)\n+                        let index = self\n+                            .universe_indices\n+                            .iter()\n+                            .position(|u| matches!(u, Some(pu) if *pu == p.universe))\n                             .unwrap_or_else(|| bug!(\"Unexpected placeholder universe.\"));\n-                        let index =\n-                            ty::DebruijnIndex::from_u32(db.as_u32() + self.current_index.as_u32());\n-                        self.tcx().mk_ty(ty::Bound(index, *replace_var))\n+                        let db = ty::DebruijnIndex::from_usize(\n+                            self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n+                        );\n+                        self.tcx().mk_ty(ty::Bound(db, *replace_var))\n                     }\n                     None => ty,\n                 }\n@@ -695,14 +759,16 @@ impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n             let replace_var = self.mapped_consts.get(&p);\n             match replace_var {\n                 Some(replace_var) => {\n-                    let db = self\n-                        .universes_inverse\n-                        .get(&p.universe)\n+                    let index = self\n+                        .universe_indices\n+                        .iter()\n+                        .position(|u| matches!(u, Some(pu) if *pu == p.universe))\n                         .unwrap_or_else(|| bug!(\"Unexpected placeholder universe.\"));\n-                    let index =\n-                        ty::DebruijnIndex::from_u32(db.as_u32() + self.current_index.as_u32());\n+                    let db = ty::DebruijnIndex::from_usize(\n+                        self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n+                    );\n                     self.tcx()\n-                        .mk_const(ty::Const { val: ty::ConstKind::Bound(index, *replace_var), ty })\n+                        .mk_const(ty::Const { val: ty::ConstKind::Bound(db, *replace_var), ty })\n                 }\n                 None => ct,\n             }"}, {"sha": "1f0f4a88a73a0fed3fc69f8a7bc4de44d899c841", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a9f1e1c440ae20f0ea99f5e265f24094f1a613a5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f1e1c440ae20f0ea99f5e265f24094f1a613a5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=a9f1e1c440ae20f0ea99f5e265f24094f1a613a5", "patch": "@@ -61,6 +61,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n             error: false,\n             cache: SsoHashMap::new(),\n             anon_depth: 0,\n+            universes: vec![],\n         };\n \n         let result = value.fold_with(&mut normalizer);\n@@ -91,13 +92,24 @@ struct QueryNormalizer<'cx, 'tcx> {\n     cache: SsoHashMap<Ty<'tcx>, Ty<'tcx>>,\n     error: bool,\n     anon_depth: usize,\n+    universes: Vec<Option<ty::UniverseIndex>>,\n }\n \n impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n     fn tcx<'c>(&'c self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n+        self.universes.push(None);\n+        let t = t.super_fold_with(self);\n+        self.universes.pop();\n+        t\n+    }\n+\n     #[instrument(level = \"debug\", skip(self))]\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         if !ty.has_projections() {\n@@ -216,8 +228,19 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n \n                 let tcx = self.infcx.tcx;\n                 let infcx = self.infcx;\n-                let (data, mapped_regions, mapped_types, mapped_consts, universe_map) =\n-                    crate::traits::project::BoundVarReplacer::replace_bound_vars(infcx, data);\n+                let replaced = crate::traits::project::BoundVarReplacer::replace_bound_vars(\n+                    infcx,\n+                    &mut self.universes,\n+                    data,\n+                );\n+                let (data, mapped_regions, mapped_types, mapped_consts) = match replaced {\n+                    Some(r) => r,\n+                    None => {\n+                        bug!(\"{:?} {:?}\", data, self.universes);\n+                        //self.error = true;\n+                        //return ty.super_fold_with(self);\n+                    }\n+                };\n                 let data = data.super_fold_with(self);\n \n                 let mut orig_values = OriginalQueryValues::default();\n@@ -263,7 +286,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                     mapped_regions,\n                     mapped_types,\n                     mapped_consts,\n-                    universe_map,\n+                    &self.universes,\n                     normalized_ty,\n                 )\n             }"}]}