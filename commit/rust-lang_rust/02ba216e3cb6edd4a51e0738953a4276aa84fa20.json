{"sha": "02ba216e3cb6edd4a51e0738953a4276aa84fa20", "node_id": "C_kwDOAAsO6NoAKDAyYmEyMTZlM2NiNmVkZDRhNTFlMDczODk1M2E0Mjc2YWE4NGZhMjA", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-08-30T22:34:35Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-09-02T17:55:05Z"}, "message": "Refactor and re-use BindingAnnotation", "tree": {"sha": "c95feda408690266979d174e2511515d15805785", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c95feda408690266979d174e2511515d15805785"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02ba216e3cb6edd4a51e0738953a4276aa84fa20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02ba216e3cb6edd4a51e0738953a4276aa84fa20", "html_url": "https://github.com/rust-lang/rust/commit/02ba216e3cb6edd4a51e0738953a4276aa84fa20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02ba216e3cb6edd4a51e0738953a4276aa84fa20/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9353538c7bea6edb245457712cec720305c4576e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9353538c7bea6edb245457712cec720305c4576e", "html_url": "https://github.com/rust-lang/rust/commit/9353538c7bea6edb245457712cec720305c4576e"}], "stats": {"total": 397, "additions": 174, "deletions": 223}, "files": [{"sha": "f05f58d63a383f5cc219c3af1f58d320f4bfead1", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 55, "deletions": 22, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -594,7 +594,7 @@ impl Pat {\n             // In a type expression `_` is an inference variable.\n             PatKind::Wild => TyKind::Infer,\n             // An IDENT pattern with no binding mode would be valid as path to a type. E.g. `u32`.\n-            PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None) => {\n+            PatKind::Ident(BindingAnnotation::NONE, ident, None) => {\n                 TyKind::Path(None, Path::from_ident(*ident))\n             }\n             PatKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n@@ -681,10 +681,43 @@ pub struct PatField {\n     pub is_placeholder: bool,\n }\n \n-#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n-pub enum BindingMode {\n-    ByRef(Mutability),\n-    ByValue(Mutability),\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n+pub enum ByRef {\n+    Yes,\n+    No,\n+}\n+\n+impl From<bool> for ByRef {\n+    fn from(b: bool) -> ByRef {\n+        match b {\n+            false => ByRef::No,\n+            true => ByRef::Yes,\n+        }\n+    }\n+}\n+\n+/// Explicit binding annotations given in the HIR for a binding. Note\n+/// that this is not the final binding *mode* that we infer after type\n+/// inference.\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n+pub struct BindingAnnotation(pub ByRef, pub Mutability);\n+\n+impl BindingAnnotation {\n+    pub const NONE: Self = Self(ByRef::No, Mutability::Not);\n+    pub const REF: Self = Self(ByRef::Yes, Mutability::Not);\n+    pub const MUT: Self = Self(ByRef::No, Mutability::Mut);\n+    pub const REF_MUT: Self = Self(ByRef::Yes, Mutability::Mut);\n+\n+    pub fn prefix_str(self) -> &'static str {\n+        match self {\n+            Self::NONE => \"\",\n+            Self::REF => \"ref \",\n+            Self::MUT => \"mut \",\n+            Self::REF_MUT => \"ref mut \",\n+        }\n+    }\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -713,7 +746,7 @@ pub enum PatKind {\n     /// or a unit struct/variant pattern, or a const pattern (in the last two cases the third\n     /// field must be `None`). Disambiguation cannot be done with parser alone, so it happens\n     /// during name resolution.\n-    Ident(BindingMode, Ident, Option<P<Pat>>),\n+    Ident(BindingAnnotation, Ident, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n@@ -2228,7 +2261,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n impl Param {\n     /// Attempts to cast parameter to `ExplicitSelf`.\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.kind {\n+        if let PatKind::Ident(BindingAnnotation(ByRef::No, mutbl), ident, _) = self.pat.kind {\n             if ident.name == kw::SelfLower {\n                 return match self.ty.kind {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n@@ -2258,31 +2291,31 @@ impl Param {\n     pub fn from_self(attrs: AttrVec, eself: ExplicitSelf, eself_ident: Ident) -> Param {\n         let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty { id: DUMMY_NODE_ID, kind: TyKind::ImplicitSelf, span, tokens: None });\n-        let param = |mutbl, ty| Param {\n+        let (mutbl, ty) = match eself.node {\n+            SelfKind::Explicit(ty, mutbl) => (mutbl, ty),\n+            SelfKind::Value(mutbl) => (mutbl, infer_ty),\n+            SelfKind::Region(lt, mutbl) => (\n+                Mutability::Not,\n+                P(Ty {\n+                    id: DUMMY_NODE_ID,\n+                    kind: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl }),\n+                    span,\n+                    tokens: None,\n+                }),\n+            ),\n+        };\n+        Param {\n             attrs,\n             pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n-                kind: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n+                kind: PatKind::Ident(BindingAnnotation(ByRef::No, mutbl), eself_ident, None),\n                 span,\n                 tokens: None,\n             }),\n             span,\n             ty,\n             id: DUMMY_NODE_ID,\n             is_placeholder: false,\n-        };\n-        match eself.node {\n-            SelfKind::Explicit(ty, mutbl) => param(mutbl, ty),\n-            SelfKind::Value(mutbl) => param(mutbl, infer_ty),\n-            SelfKind::Region(lt, mutbl) => param(\n-                Mutability::Not,\n-                P(Ty {\n-                    id: DUMMY_NODE_ID,\n-                    kind: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl }),\n-                    span,\n-                    tokens: None,\n-                }),\n-            ),\n         }\n     }\n }"}, {"sha": "7d3f839c922e5239630e84731128dae5722e7e31", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -577,7 +577,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let (pat, task_context_hid) = self.pat_ident_binding_mode(\n             span,\n             Ident::with_dummy_span(sym::_task_context),\n-            hir::BindingAnnotation::Mutable,\n+            hir::BindingAnnotation::MUT,\n         );\n         let param = hir::Param {\n             hir_id: self.next_id(),\n@@ -671,7 +671,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // this name to identify what is being awaited by a suspended async functions.\n         let awaitee_ident = Ident::with_dummy_span(sym::__awaitee);\n         let (awaitee_pat, awaitee_pat_hid) =\n-            self.pat_ident_binding_mode(span, awaitee_ident, hir::BindingAnnotation::Mutable);\n+            self.pat_ident_binding_mode(span, awaitee_ident, hir::BindingAnnotation::MUT);\n \n         let task_context_ident = Ident::with_dummy_span(sym::_task_context);\n \n@@ -1433,7 +1433,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `mut iter`\n         let iter = Ident::with_dummy_span(sym::iter);\n         let (iter_pat, iter_pat_nid) =\n-            self.pat_ident_binding_mode(head_span, iter, hir::BindingAnnotation::Mutable);\n+            self.pat_ident_binding_mode(head_span, iter, hir::BindingAnnotation::MUT);\n \n         // `match Iterator::next(&mut iter) { ... }`\n         let match_expr = {"}, {"sha": "810ee6eb76db6fd854f652a91065a2e04bcddb41", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -1074,12 +1074,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n                 // `let <pat> = __argN;` statement. In this case, we do not rename the parameter.\n                 let (ident, is_simple_parameter) = match parameter.pat.kind {\n-                    hir::PatKind::Binding(\n-                        hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable,\n-                        _,\n-                        ident,\n-                        _,\n-                    ) => (ident, true),\n+                    hir::PatKind::Binding(hir::BindingAnnotation(ByRef::No, _), _, ident, _) => {\n+                        (ident, true)\n+                    }\n                     // For `ref mut` or wildcard arguments, we can't reuse the binding, but\n                     // we can keep the same name for the parameter.\n                     // This lets rustdoc render it correctly in documentation.\n@@ -1144,7 +1141,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let (move_pat, move_id) = this.pat_ident_binding_mode(\n                         desugared_span,\n                         ident,\n-                        hir::BindingAnnotation::Mutable,\n+                        hir::BindingAnnotation::MUT,\n                     );\n                     let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let move_stmt = this.stmt_let_pat("}, {"sha": "62ea49e8df9d5125933b53e3f4e746e521958c0f", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -1696,10 +1696,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             output,\n             c_variadic,\n             implicit_self: decl.inputs.get(0).map_or(hir::ImplicitSelfKind::None, |arg| {\n-                use BindingMode::{ByRef, ByValue};\n                 let is_mutable_pat = matches!(\n                     arg.pat.kind,\n-                    PatKind::Ident(ByValue(Mutability::Mut) | ByRef(Mutability::Mut), ..)\n+                    PatKind::Ident(hir::BindingAnnotation(_, Mutability::Mut), ..)\n                 );\n \n                 match arg.ty.kind {\n@@ -2361,11 +2360,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn pat_ident(&mut self, span: Span, ident: Ident) -> (&'hir hir::Pat<'hir>, hir::HirId) {\n-        self.pat_ident_binding_mode(span, ident, hir::BindingAnnotation::Unannotated)\n+        self.pat_ident_binding_mode(span, ident, hir::BindingAnnotation::NONE)\n     }\n \n     fn pat_ident_mut(&mut self, span: Span, ident: Ident) -> (hir::Pat<'hir>, hir::HirId) {\n-        self.pat_ident_binding_mode_mut(span, ident, hir::BindingAnnotation::Unannotated)\n+        self.pat_ident_binding_mode_mut(span, ident, hir::BindingAnnotation::NONE)\n     }\n \n     fn pat_ident_binding_mode("}, {"sha": "c185a0d31bd46b5a78f5d48ac95262241240c08c", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let node = loop {\n                 match pattern.kind {\n                     PatKind::Wild => break hir::PatKind::Wild,\n-                    PatKind::Ident(ref binding_mode, ident, ref sub) => {\n+                    PatKind::Ident(binding_mode, ident, ref sub) => {\n                         let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n                         break self.lower_pat_ident(pattern, binding_mode, ident, lower_sub);\n                     }\n@@ -176,9 +176,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut prev_rest_span = None;\n \n         // Lowers `$bm $ident @ ..` to `$bm $ident @ _`.\n-        let lower_rest_sub = |this: &mut Self, pat, bm, ident, sub| {\n+        let lower_rest_sub = |this: &mut Self, pat, ann, ident, sub| {\n             let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n-            let node = this.lower_pat_ident(pat, bm, ident, lower_sub);\n+            let node = this.lower_pat_ident(pat, ann, ident, lower_sub);\n             this.pat_with_node_id_of(pat, node)\n         };\n \n@@ -194,9 +194,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n                 // Found a sub-slice pattern `$binding_mode $ident @ ..`.\n                 // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n-                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(ann, ident, Some(ref sub)) if sub.is_rest() => {\n                     prev_rest_span = Some(sub.span);\n-                    slice = Some(self.arena.alloc(lower_rest_sub(self, pat, bm, ident, sub)));\n+                    slice = Some(self.arena.alloc(lower_rest_sub(self, pat, ann, ident, sub)));\n                     break;\n                 }\n                 // It was not a subslice pattern so lower it normally.\n@@ -209,9 +209,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // There was a previous subslice pattern; make sure we don't allow more.\n             let rest_span = match pat.kind {\n                 PatKind::Rest => Some(pat.span),\n-                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(ann, ident, Some(ref sub)) if sub.is_rest() => {\n                     // #69103: Lower into `binding @ _` as above to avoid ICEs.\n-                    after.push(lower_rest_sub(self, pat, bm, ident, sub));\n+                    after.push(lower_rest_sub(self, pat, ann, ident, sub));\n                     Some(sub.span)\n                 }\n                 _ => None,\n@@ -235,7 +235,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_pat_ident(\n         &mut self,\n         p: &Pat,\n-        binding_mode: &BindingMode,\n+        annotation: BindingAnnotation,\n         ident: Ident,\n         lower_sub: impl FnOnce(&mut Self) -> Option<&'hir hir::Pat<'hir>>,\n     ) -> hir::PatKind<'hir> {\n@@ -248,7 +248,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 };\n \n                 hir::PatKind::Binding(\n-                    self.lower_binding_mode(binding_mode),\n+                    annotation,\n                     self.lower_node_id(canonical_id),\n                     self.lower_ident(ident),\n                     lower_sub(self),\n@@ -265,15 +265,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_binding_mode(&mut self, b: &BindingMode) -> hir::BindingAnnotation {\n-        match *b {\n-            BindingMode::ByValue(Mutability::Not) => hir::BindingAnnotation::Unannotated,\n-            BindingMode::ByRef(Mutability::Not) => hir::BindingAnnotation::Ref,\n-            BindingMode::ByValue(Mutability::Mut) => hir::BindingAnnotation::Mutable,\n-            BindingMode::ByRef(Mutability::Mut) => hir::BindingAnnotation::RefMut,\n-        }\n-    }\n-\n     fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n         self.arena.alloc(self.pat_with_node_id_of(p, hir::PatKind::Wild))\n     }"}, {"sha": "d6d8881a53a146e0c4c62d8fb93123122fb735fe", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -281,8 +281,8 @@ impl<'a> AstValidator<'a> {\n     fn check_decl_no_pat(decl: &FnDecl, mut report_err: impl FnMut(Span, Option<Ident>, bool)) {\n         for Param { pat, .. } in &decl.inputs {\n             match pat.kind {\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Not), _, None) | PatKind::Wild => {}\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ident, None) => {\n+                PatKind::Ident(BindingAnnotation::NONE, _, None) | PatKind::Wild => {}\n+                PatKind::Ident(BindingAnnotation::MUT, ident, None) => {\n                     report_err(pat.span, Some(ident), true)\n                 }\n                 _ => report_err(pat.span, None, false),"}, {"sha": "ed5e7dace4bc4ba1ea971d7c1d61e9e7e244672e", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -11,8 +11,8 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser;\n-use rustc_ast::{self as ast, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n-use rustc_ast::{attr, Term};\n+use rustc_ast::{self as ast, BlockCheckMode, Mutability, PatKind, RangeEnd, RangeSyntax};\n+use rustc_ast::{attr, BindingAnnotation, ByRef, Term};\n use rustc_ast::{GenericArg, MacArgs, MacArgsEq};\n use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n@@ -1399,16 +1399,12 @@ impl<'a> State<'a> {\n         is that it doesn't matter */\n         match pat.kind {\n             PatKind::Wild => self.word(\"_\"),\n-            PatKind::Ident(binding_mode, ident, ref sub) => {\n-                match binding_mode {\n-                    ast::BindingMode::ByRef(mutbl) => {\n-                        self.word_nbsp(\"ref\");\n-                        self.print_mutability(mutbl, false);\n-                    }\n-                    ast::BindingMode::ByValue(ast::Mutability::Not) => {}\n-                    ast::BindingMode::ByValue(ast::Mutability::Mut) => {\n-                        self.word_nbsp(\"mut\");\n-                    }\n+            PatKind::Ident(BindingAnnotation(by_ref, mutbl), ident, ref sub) => {\n+                if by_ref == ByRef::Yes {\n+                    self.word_nbsp(\"ref\");\n+                }\n+                if mutbl == Mutability::Mut {\n+                    self.word_nbsp(\"mut\");\n                 }\n                 self.print_ident(ident);\n                 if let Some(ref p) = *sub {\n@@ -1487,12 +1483,10 @@ impl<'a> State<'a> {\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n                 self.word(\"&\");\n-                if mutbl == ast::Mutability::Mut {\n+                if mutbl == Mutability::Mut {\n                     self.word(\"mut \");\n                 }\n-                if let PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Mut), ..) =\n-                    inner.kind\n-                {\n+                if let PatKind::Ident(ast::BindingAnnotation::MUT, ..) = inner.kind {\n                     self.popen();\n                     self.print_pat(inner);\n                     self.pclose();"}, {"sha": "e2db7f3ead1a4f1041b8516d1dc69efec2dad625", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -367,7 +367,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 if let Some(Node::Pat(pat)) = self.infcx.tcx.hir().find(upvar_hir_id)\n                     && let hir::PatKind::Binding(\n-                        hir::BindingAnnotation::Unannotated,\n+                        hir::BindingAnnotation::NONE,\n                         _,\n                         upvar_ident,\n                         _,"}, {"sha": "3cc160adb5397aa73ed3041e23e8f0d081db2fc5", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -164,7 +164,9 @@ pub use SubstructureFields::*;\n \n use crate::deriving;\n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, EnumDef, Expr, Generics, PatKind};\n+use rustc_ast::{\n+    self as ast, BindingAnnotation, ByRef, EnumDef, Expr, Generics, Mutability, PatKind,\n+};\n use rustc_ast::{GenericArg, GenericParamKind, VariantData};\n use rustc_attr as attr;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n@@ -1063,9 +1065,9 @@ impl<'a> MethodDef<'a> {\n             let mut body = mk_body(cx, selflike_fields);\n \n             let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n-            let use_ref_pat = is_packed && !always_copy;\n+            let by_ref = ByRef::from(is_packed && !always_copy);\n             let patterns =\n-                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, use_ref_pat);\n+                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, by_ref);\n \n             // Do the let-destructuring.\n             let mut stmts: Vec<_> = iter::zip(selflike_args, patterns)\n@@ -1247,13 +1249,13 @@ impl<'a> MethodDef<'a> {\n \n                 let sp = variant.span.with_ctxt(trait_.span.ctxt());\n                 let variant_path = cx.path(sp, vec![type_ident, variant.ident]);\n-                let use_ref_pat = false; // because enums can't be repr(packed)\n+                let by_ref = ByRef::No; // because enums can't be repr(packed)\n                 let mut subpats: Vec<_> = trait_.create_struct_patterns(\n                     cx,\n                     variant_path,\n                     &variant.data,\n                     &prefixes,\n-                    use_ref_pat,\n+                    by_ref,\n                 );\n \n                 // `(VariantK, VariantK, ...)` or just `VariantK`.\n@@ -1414,25 +1416,27 @@ impl<'a> TraitDef<'a> {\n         struct_path: ast::Path,\n         struct_def: &'a VariantData,\n         prefixes: &[String],\n-        use_ref_pat: bool,\n+        by_ref: ByRef,\n     ) -> Vec<P<ast::Pat>> {\n         prefixes\n             .iter()\n             .map(|prefix| {\n                 let pieces_iter =\n                     struct_def.fields().iter().enumerate().map(|(i, struct_field)| {\n                         let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-                        let binding_mode = if use_ref_pat {\n-                            ast::BindingMode::ByRef(ast::Mutability::Not)\n-                        } else {\n-                            ast::BindingMode::ByValue(ast::Mutability::Not)\n-                        };\n                         let ident = self.mk_pattern_ident(prefix, i);\n                         let path = ident.with_span_pos(sp);\n                         (\n                             sp,\n                             struct_field.ident,\n-                            cx.pat(path.span, PatKind::Ident(binding_mode, path, None)),\n+                            cx.pat(\n+                                path.span,\n+                                PatKind::Ident(\n+                                    BindingAnnotation(by_ref, Mutability::Not),\n+                                    path,\n+                                    None,\n+                                ),\n+                            ),\n                         )\n                     });\n "}, {"sha": "cf2c023c2f89f3de35ffb9c5c2d43bd1a2be728f", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -178,8 +178,7 @@ impl<'a> ExtCtxt<'a> {\n         ex: P<ast::Expr>,\n     ) -> ast::Stmt {\n         let pat = if mutbl {\n-            let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mut);\n-            self.pat_ident_binding_mode(sp, ident, binding_mode)\n+            self.pat_ident_binding_mode(sp, ident, ast::BindingAnnotation::MUT)\n         } else {\n             self.pat_ident(sp, ident)\n         };\n@@ -445,17 +444,16 @@ impl<'a> ExtCtxt<'a> {\n         self.pat(span, PatKind::Lit(expr))\n     }\n     pub fn pat_ident(&self, span: Span, ident: Ident) -> P<ast::Pat> {\n-        let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Not);\n-        self.pat_ident_binding_mode(span, ident, binding_mode)\n+        self.pat_ident_binding_mode(span, ident, ast::BindingAnnotation::NONE)\n     }\n \n     pub fn pat_ident_binding_mode(\n         &self,\n         span: Span,\n         ident: Ident,\n-        bm: ast::BindingMode,\n+        ann: ast::BindingAnnotation,\n     ) -> P<ast::Pat> {\n-        let pat = PatKind::Ident(bm, ident.with_span_pos(span), None);\n+        let pat = PatKind::Ident(ann, ident.with_span_pos(span), None);\n         self.pat(span, pat)\n     }\n     pub fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat> {"}, {"sha": "34c4f0bc273fa0e9669d12a7ca1893c011249851", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -7,7 +7,7 @@ use crate::LangItem;\n use rustc_ast as ast;\n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_ast::{Attribute, FloatTy, IntTy, Label, LitKind, TraitObjectSyntax, UintTy};\n-pub use rustc_ast::{BorrowKind, ImplPolarity, IsAuto};\n+pub use rustc_ast::{BindingAnnotation, BorrowKind, ByRef, ImplPolarity, IsAuto};\n pub use rustc_ast::{CaptureBy, Movability, Mutability};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -1049,30 +1049,6 @@ pub struct PatField<'hir> {\n     pub span: Span,\n }\n \n-/// Explicit binding annotations given in the HIR for a binding. Note\n-/// that this is not the final binding *mode* that we infer after type\n-/// inference.\n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n-pub enum BindingAnnotation {\n-    /// No binding annotation given: this means that the final binding mode\n-    /// will depend on whether we have skipped through a `&` reference\n-    /// when matching. For example, the `x` in `Some(x)` will have binding\n-    /// mode `None`; if you do `let Some(x) = &Some(22)`, it will\n-    /// ultimately be inferred to be by-reference.\n-    ///\n-    /// Note that implicit reference skipping is not implemented yet (#42640).\n-    Unannotated,\n-\n-    /// Annotated with `mut x` -- could be either ref or not, similar to `None`.\n-    Mutable,\n-\n-    /// Annotated as `ref`, like `ref x`\n-    Ref,\n-\n-    /// Annotated as `ref mut x`.\n-    RefMut,\n-}\n-\n #[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum RangeEnd {\n     Included,"}, {"sha": "9baaf9390f2c5aa181bfde02841de865236339af", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -1,6 +1,6 @@\n use crate::def::{CtorOf, DefKind, Res};\n use crate::def_id::DefId;\n-use crate::hir::{self, HirId, PatKind};\n+use crate::hir::{self, BindingAnnotation, ByRef, HirId, PatKind};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::Ident;\n@@ -93,12 +93,7 @@ impl hir::Pat<'_> {\n \n     pub fn simple_ident(&self) -> Option<Ident> {\n         match self.kind {\n-            PatKind::Binding(\n-                hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable,\n-                _,\n-                ident,\n-                None,\n-            ) => Some(ident),\n+            PatKind::Binding(BindingAnnotation(ByRef::No, _), _, ident, None) => Some(ident),\n             _ => None,\n         }\n     }\n@@ -135,11 +130,11 @@ impl hir::Pat<'_> {\n     pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n         let mut result = None;\n         self.each_binding(|annotation, _, _, _| match annotation {\n-            hir::BindingAnnotation::Ref => match result {\n+            hir::BindingAnnotation::REF => match result {\n                 None | Some(hir::Mutability::Not) => result = Some(hir::Mutability::Not),\n                 _ => {}\n             },\n-            hir::BindingAnnotation::RefMut => result = Some(hir::Mutability::Mut),\n+            hir::BindingAnnotation::REF_MUT => result = Some(hir::Mutability::Mut),\n             _ => {}\n         });\n         result"}, {"sha": "bb83b371ae89eb6e29c5acaea79059aea81b4a38", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -9,7 +9,9 @@ use rustc_ast_pretty::pp::{self, Breaks};\n use rustc_ast_pretty::pprust::{Comments, PrintState};\n use rustc_hir as hir;\n use rustc_hir::LifetimeParamKind;\n-use rustc_hir::{GenericArg, GenericParam, GenericParamKind, Node, Term};\n+use rustc_hir::{\n+    BindingAnnotation, ByRef, GenericArg, GenericParam, GenericParamKind, Mutability, Node, Term,\n+};\n use rustc_hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, Ident, IdentPrinter, Symbol};\n@@ -1758,20 +1760,12 @@ impl<'a> State<'a> {\n         // is that it doesn't matter\n         match pat.kind {\n             PatKind::Wild => self.word(\"_\"),\n-            PatKind::Binding(binding_mode, _, ident, sub) => {\n-                match binding_mode {\n-                    hir::BindingAnnotation::Ref => {\n-                        self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::Mutability::Not, false);\n-                    }\n-                    hir::BindingAnnotation::RefMut => {\n-                        self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::Mutability::Mut, false);\n-                    }\n-                    hir::BindingAnnotation::Unannotated => {}\n-                    hir::BindingAnnotation::Mutable => {\n-                        self.word_nbsp(\"mut\");\n-                    }\n+            PatKind::Binding(BindingAnnotation(by_ref, mutbl), _, ident, sub) => {\n+                if by_ref == ByRef::Yes {\n+                    self.word_nbsp(\"ref\");\n+                }\n+                if mutbl == Mutability::Mut {\n+                    self.word_nbsp(\"mut\");\n                 }\n                 self.print_ident(ident);\n                 if let Some(p) = sub {"}, {"sha": "6bd5ca7b6066483c8031fc625d834ac46d4bdf85", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -259,17 +259,8 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n                         == Some(cx.tcx.field_index(fieldpat.hir_id, cx.typeck_results()))\n                     {\n                         cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span, |lint| {\n-                            let binding = match binding_annot {\n-                                hir::BindingAnnotation::Unannotated => None,\n-                                hir::BindingAnnotation::Mutable => Some(\"mut\"),\n-                                hir::BindingAnnotation::Ref => Some(\"ref\"),\n-                                hir::BindingAnnotation::RefMut => Some(\"ref mut\"),\n-                            };\n-                            let suggested_ident = if let Some(binding) = binding {\n-                                format!(\"{} {}\", binding, ident)\n-                            } else {\n-                                ident.to_string()\n-                            };\n+                            let suggested_ident =\n+                                format!(\"{}{}\", binding_annot.prefix_str(), ident);\n                             lint.build(fluent::lint::builtin_non_shorthand_field_patterns)\n                                 .set_arg(\"ident\", ident.clone())\n                                 .span_suggestion("}, {"sha": "9a7d722c05a90be163d3b8a83bc506889f0b095f", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -751,7 +751,7 @@ impl UnusedParens {\n         avoid_or: bool,\n         avoid_mut: bool,\n     ) {\n-        use ast::{BindingMode, Mutability, PatKind};\n+        use ast::{BindingAnnotation, PatKind};\n \n         if let PatKind::Paren(inner) = &value.kind {\n             match inner.kind {\n@@ -763,7 +763,9 @@ impl UnusedParens {\n                 // Avoid `p0 | .. | pn` if we should.\n                 PatKind::Or(..) if avoid_or => return,\n                 // Avoid `mut x` and `mut x @ p` if we should:\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ..) if avoid_mut => return,\n+                PatKind::Ident(BindingAnnotation::MUT, ..) if avoid_mut => {\n+                    return;\n+                }\n                 // Otherwise proceed with linting.\n                 _ => {}\n             }"}, {"sha": "a5b05a4f9b526a01fbeb9c67e5106e3e5635006f", "filename": "compiler/rustc_middle/src/ty/binding.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_middle%2Fsrc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_middle%2Fsrc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fbinding.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -1,6 +1,4 @@\n-use rustc_hir::BindingAnnotation;\n-use rustc_hir::BindingAnnotation::*;\n-use rustc_hir::Mutability;\n+use rustc_hir::{BindingAnnotation, ByRef, Mutability};\n \n #[derive(Clone, PartialEq, TyEncodable, TyDecodable, Debug, Copy, HashStable)]\n pub enum BindingMode {\n@@ -11,12 +9,10 @@ pub enum BindingMode {\n TrivialTypeTraversalAndLiftImpls! { BindingMode, }\n \n impl BindingMode {\n-    pub fn convert(ba: BindingAnnotation) -> BindingMode {\n-        match ba {\n-            Unannotated => BindingMode::BindByValue(Mutability::Not),\n-            Mutable => BindingMode::BindByValue(Mutability::Mut),\n-            Ref => BindingMode::BindByReference(Mutability::Not),\n-            RefMut => BindingMode::BindByReference(Mutability::Mut),\n+    pub fn convert(BindingAnnotation(by_ref, mutbl): BindingAnnotation) -> BindingMode {\n+        match by_ref {\n+            ByRef::No => BindingMode::BindByValue(mutbl),\n+            ByRef::Yes => BindingMode::BindByReference(mutbl),\n         }\n     }\n }"}, {"sha": "9b5dd09372cc8cd18a2746948e2f43a01f5ff54d", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -10,9 +10,9 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Lit, LitKind, TokenKind};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{\n-    AngleBracketedArg, AngleBracketedArgs, AnonConst, AttrVec, BinOpKind, BindingMode, Block,\n-    BlockCheckMode, Expr, ExprKind, GenericArg, Generics, Item, ItemKind, Mutability, Param, Pat,\n-    PatKind, Path, PathSegment, QSelf, Ty, TyKind,\n+    AngleBracketedArg, AngleBracketedArgs, AnonConst, AttrVec, BinOpKind, BindingAnnotation, Block,\n+    BlockCheckMode, Expr, ExprKind, GenericArg, Generics, Item, ItemKind, Param, Pat, PatKind,\n+    Path, PathSegment, QSelf, Ty, TyKind,\n };\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n@@ -37,7 +37,7 @@ const TURBOFISH_SUGGESTION_STR: &str =\n pub(super) fn dummy_arg(ident: Ident) -> Param {\n     let pat = P(Pat {\n         id: ast::DUMMY_NODE_ID,\n-        kind: PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None),\n+        kind: PatKind::Ident(BindingAnnotation::NONE, ident, None),\n         span: ident.span,\n         tokens: None,\n     });\n@@ -2961,7 +2961,7 @@ impl<'a> Parser<'a> {\n                                 }\n                                 _ => {}\n                             },\n-                            PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None) => {\n+                            PatKind::Ident(BindingAnnotation::NONE, ident, None) => {\n                                 match &first_pat.kind {\n                                     PatKind::Ident(_, old_ident, _) => {\n                                         let path = PatKind::Path("}, {"sha": "dbdd85ea8e87d5feb428d5e5807b3d5962c0e669", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::token::{self, Delimiter, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use rustc_ast::{self as ast, AttrVec, Attribute, DUMMY_NODE_ID};\n use rustc_ast::{Async, Const, Defaultness, IsAuto, Mutability, Unsafe, UseTree, UseTreeKind};\n-use rustc_ast::{BindingMode, Block, FnDecl, FnSig, Param, SelfKind};\n+use rustc_ast::{BindingAnnotation, Block, FnDecl, FnSig, Param, SelfKind};\n use rustc_ast::{EnumDef, FieldDef, Generics, TraitRef, Ty, TyKind, Variant, VariantData};\n use rustc_ast::{FnHeader, ForeignItem, Path, PathSegment, Visibility, VisibilityKind};\n use rustc_ast::{MacArgs, MacCall, MacDelimiter};\n@@ -2322,7 +2322,7 @@ impl<'a> Parser<'a> {\n                 match ty {\n                     Ok(ty) => {\n                         let ident = Ident::new(kw::Empty, this.prev_token.span);\n-                        let bm = BindingMode::ByValue(Mutability::Not);\n+                        let bm = BindingAnnotation::NONE;\n                         let pat = this.mk_pat_ident(ty.span, bm, ident);\n                         (pat, ty)\n                     }"}, {"sha": "88bd57d37cb657cd1548b66ea24157b6482784ac", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -4,8 +4,8 @@ use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter};\n use rustc_ast::{\n-    self as ast, AttrVec, BindingMode, Expr, ExprKind, MacCall, Mutability, Pat, PatField, PatKind,\n-    Path, QSelf, RangeEnd, RangeSyntax,\n+    self as ast, AttrVec, BindingAnnotation, ByRef, Expr, ExprKind, MacCall, Mutability, Pat,\n+    PatField, PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n };\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n@@ -353,7 +353,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::Ref) {\n             // Parse ref ident @ pat / ref mut ident @ pat\n             let mutbl = self.parse_mutability();\n-            self.parse_pat_ident(BindingMode::ByRef(mutbl))?\n+            self.parse_pat_ident(BindingAnnotation(ByRef::Yes, mutbl))?\n         } else if self.eat_keyword(kw::Box) {\n             self.parse_pat_box()?\n         } else if self.check_inline_const(0) {\n@@ -369,7 +369,7 @@ impl<'a> Parser<'a> {\n             // Parse `ident @ pat`\n             // This can give false positives and parse nullary enums,\n             // they are dealt with later in resolve.\n-            self.parse_pat_ident(BindingMode::ByValue(Mutability::Not))?\n+            self.parse_pat_ident(BindingAnnotation::NONE)?\n         } else if self.is_start_of_pat_with_path() {\n             // Parse pattern starting with a path\n             let (qself, path) = if self.eat_lt() {\n@@ -578,7 +578,8 @@ impl<'a> Parser<'a> {\n         let mut pat = self.parse_pat_no_top_alt(Some(\"identifier\"))?;\n \n         // If we don't have `mut $ident (@ pat)?`, error.\n-        if let PatKind::Ident(BindingMode::ByValue(m @ Mutability::Not), ..) = &mut pat.kind {\n+        if let PatKind::Ident(BindingAnnotation(ByRef::No, m @ Mutability::Not), ..) = &mut pat.kind\n+        {\n             // Don't recurse into the subpattern.\n             // `mut` on the outer binding doesn't affect the inner bindings.\n             *m = Mutability::Mut;\n@@ -604,7 +605,7 @@ impl<'a> Parser<'a> {\n             )\n             .emit();\n \n-        self.parse_pat_ident(BindingMode::ByRef(Mutability::Mut))\n+        self.parse_pat_ident(BindingAnnotation::REF_MUT)\n     }\n \n     /// Turn all by-value immutable bindings in a pattern into mutable bindings.\n@@ -613,7 +614,8 @@ impl<'a> Parser<'a> {\n         struct AddMut(bool);\n         impl MutVisitor for AddMut {\n             fn visit_pat(&mut self, pat: &mut P<Pat>) {\n-                if let PatKind::Ident(BindingMode::ByValue(m @ Mutability::Not), ..) = &mut pat.kind\n+                if let PatKind::Ident(BindingAnnotation(ByRef::No, m @ Mutability::Not), ..) =\n+                    &mut pat.kind\n                 {\n                     self.0 = true;\n                     *m = Mutability::Mut;\n@@ -838,7 +840,7 @@ impl<'a> Parser<'a> {\n     /// Parses `ident` or `ident @ pat`.\n     /// Used by the copy foo and ref foo patterns to give a good\n     /// error message when parsing mistakes like `ref foo(a, b)`.\n-    fn parse_pat_ident(&mut self, binding_mode: BindingMode) -> PResult<'a, PatKind> {\n+    fn parse_pat_ident(&mut self, binding_annotation: BindingAnnotation) -> PResult<'a, PatKind> {\n         let ident = self.parse_ident()?;\n         let sub = if self.eat(&token::At) {\n             Some(self.parse_pat_no_top_alt(Some(\"binding pattern\"))?)\n@@ -856,7 +858,7 @@ impl<'a> Parser<'a> {\n                 .struct_span_err(self.prev_token.span, \"expected identifier, found enum pattern\"));\n         }\n \n-        Ok(PatKind::Ident(binding_mode, ident, sub))\n+        Ok(PatKind::Ident(binding_annotation, ident, sub))\n     }\n \n     /// Parse a struct (\"record\") pattern (e.g. `Foo { ... }` or `Foo::Bar { ... }`).\n@@ -936,11 +938,7 @@ impl<'a> Parser<'a> {\n                 None\n             };\n \n-            Ok(PatKind::Ident(\n-                BindingMode::ByValue(Mutability::Not),\n-                Ident::new(kw::Box, box_span),\n-                sub,\n-            ))\n+            Ok(PatKind::Ident(BindingAnnotation::NONE, Ident::new(kw::Box, box_span), sub))\n         } else {\n             let pat = self.parse_pat_with_range_pat(false, None)?;\n             self.sess.gated_spans.gate(sym::box_patterns, box_span.to(self.prev_token.span));\n@@ -1117,14 +1115,12 @@ impl<'a> Parser<'a> {\n             let fieldname = self.parse_field_name()?;\n             hi = self.prev_token.span;\n \n-            let bind_type = match (is_ref, is_mut) {\n-                (true, true) => BindingMode::ByRef(Mutability::Mut),\n-                (true, false) => BindingMode::ByRef(Mutability::Not),\n-                (false, true) => BindingMode::ByValue(Mutability::Mut),\n-                (false, false) => BindingMode::ByValue(Mutability::Not),\n+            let mutability = match is_mut {\n+                false => Mutability::Not,\n+                true => Mutability::Mut,\n             };\n-\n-            let fieldpat = self.mk_pat_ident(boxed_span.to(hi), bind_type, fieldname);\n+            let ann = BindingAnnotation(ByRef::from(is_ref), mutability);\n+            let fieldpat = self.mk_pat_ident(boxed_span.to(hi), ann, fieldname);\n             let subpat =\n                 if is_box { self.mk_pat(lo.to(hi), PatKind::Box(fieldpat)) } else { fieldpat };\n             (subpat, fieldname, true)\n@@ -1141,8 +1137,8 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub(super) fn mk_pat_ident(&self, span: Span, bm: BindingMode, ident: Ident) -> P<Pat> {\n-        self.mk_pat(span, PatKind::Ident(bm, ident, None))\n+    pub(super) fn mk_pat_ident(&self, span: Span, ann: BindingAnnotation, ident: Ident) -> P<Pat> {\n+        self.mk_pat(span, PatKind::Ident(ann, ident, None))\n     }\n \n     pub(super) fn mk_pat(&self, span: Span, kind: PatKind) -> P<Pat> {"}, {"sha": "607973446fc1e32c3818f682c746013b5e0e250a", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -76,7 +76,7 @@ fn check_no_patterns(tcx: TyCtxt<'_>, params: &[hir::Param<'_>]) {\n     for param in params {\n         match param.pat.kind {\n             hir::PatKind::Wild\n-            | hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, _, None) => {}\n+            | hir::PatKind::Binding(hir::BindingAnnotation::NONE, _, _, None) => {}\n             _ => {\n                 tcx.sess\n                     .struct_span_err("}, {"sha": "b37feb15890ba22ff080b55f34c231a67318536f", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -20,7 +20,7 @@ use rustc_errors::DiagnosticId;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n-use rustc_hir::{PrimTy, TraitCandidate};\n+use rustc_hir::{BindingAnnotation, PrimTy, TraitCandidate};\n use rustc_middle::middle::resolve_lifetime::Set1;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::{bug, span_bug};\n@@ -50,7 +50,7 @@ use diagnostics::{\n #[derive(Copy, Clone, Debug)]\n struct BindingInfo {\n     span: Span,\n-    binding_mode: BindingMode,\n+    annotation: BindingAnnotation,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -2865,10 +2865,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n         pat.walk(&mut |pat| {\n             match pat.kind {\n-                PatKind::Ident(binding_mode, ident, ref sub_pat)\n+                PatKind::Ident(annotation, ident, ref sub_pat)\n                     if sub_pat.is_some() || self.is_base_res_local(pat.id) =>\n                 {\n-                    binding_map.insert(ident, BindingInfo { span: ident.span, binding_mode });\n+                    binding_map.insert(ident, BindingInfo { span: ident.span, annotation });\n                 }\n                 PatKind::Or(ref ps) => {\n                     // Check the consistency of this or-pattern and\n@@ -2925,7 +2925,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         binding_error.target.insert(pat_outer.span);\n                     }\n                     Some(binding_outer) => {\n-                        if binding_outer.binding_mode != binding_inner.binding_mode {\n+                        if binding_outer.annotation != binding_inner.annotation {\n                             // The binding modes in the outer and inner bindings differ.\n                             inconsistent_vars\n                                 .entry(name)\n@@ -3146,14 +3146,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     fn try_resolve_as_non_binding(\n         &mut self,\n         pat_src: PatternSource,\n-        bm: BindingMode,\n+        ann: BindingAnnotation,\n         ident: Ident,\n         has_sub: bool,\n     ) -> Option<Res> {\n         // An immutable (no `mut`) by-value (no `ref`) binding pattern without\n         // a sub pattern (no `@ $pat`) is syntactically ambiguous as it could\n         // also be interpreted as a path to e.g. a constant, variant, etc.\n-        let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Not);\n+        let is_syntactic_ambiguity = !has_sub && ann == BindingAnnotation::NONE;\n \n         let ls_binding = self.maybe_resolve_ident_in_lexical_scope(ident, ValueNS)?;\n         let (res, binding) = match ls_binding {"}, {"sha": "eae1f08310774249b4621d7b3cd88d7e12d53562", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -865,23 +865,12 @@ impl<'l> Visitor<'l> for PathCollector<'l> {\n             hir::PatKind::TupleStruct(ref path, ..) | hir::PatKind::Path(ref path) => {\n                 self.collected_paths.push((p.hir_id, path));\n             }\n-            hir::PatKind::Binding(bm, _, ident, _) => {\n+            hir::PatKind::Binding(hir::BindingAnnotation(_, mutbl), _, ident, _) => {\n                 debug!(\n                     \"PathCollector, visit ident in pat {}: {:?} {:?}\",\n                     ident, p.span, ident.span\n                 );\n-                let immut = match bm {\n-                    // Even if the ref is mut, you can't change the ref, only\n-                    // the data pointed at, so showing the initialising expression\n-                    // is still worthwhile.\n-                    hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Ref => {\n-                        hir::Mutability::Not\n-                    }\n-                    hir::BindingAnnotation::Mutable | hir::BindingAnnotation::RefMut => {\n-                        hir::Mutability::Mut\n-                    }\n-                };\n-                self.collected_idents.push((p.hir_id, ident, immut));\n+                self.collected_idents.push((p.hir_id, ident, mutbl));\n             }\n             _ => {}\n         }"}, {"sha": "b012073f7719d2d4270ea7363483b9c393b75fcb", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -774,7 +774,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             // Get the local name of this closure. This can be inaccurate because\n             // of the possibility of reassignment, but this should be good enough.\n             match &kind {\n-                hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, None) => {\n+                hir::PatKind::Binding(hir::BindingAnnotation::NONE, _, ident, None) => {\n                     Some(ident.name)\n                 }\n                 _ => {"}, {"sha": "9096fc442d49398e882f60ed458b4a99e644f65d", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -569,7 +569,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         // Determine the binding mode...\n         let bm = match ba {\n-            hir::BindingAnnotation::Unannotated => def_bm,\n+            hir::BindingAnnotation::NONE => def_bm,\n             _ => BindingMode::convert(ba),\n         };\n         // ...and store it in a side table:\n@@ -655,7 +655,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ba: hir::BindingAnnotation,\n     ) {\n         match (expected.kind(), actual.kind(), ba) {\n-            (ty::Ref(_, inner_ty, _), _, hir::BindingAnnotation::Unannotated)\n+            (ty::Ref(_, inner_ty, _), _, hir::BindingAnnotation::NONE)\n                 if self.can_eq(self.param_env, *inner_ty, actual).is_ok() =>\n             {\n                 err.span_suggestion_verbose(\n@@ -665,7 +665,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n-            (_, ty::Ref(_, inner_ty, _), hir::BindingAnnotation::Ref)\n+            (_, ty::Ref(_, inner_ty, _), hir::BindingAnnotation::REF)\n                 if self.can_eq(self.param_env, expected, *inner_ty).is_ok() =>\n             {\n                 err.span_suggestion_verbose("}, {"sha": "b779713482e14872e63107276552672c5e06b269", "filename": "compiler/rustc_typeck/src/check/region.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02ba216e3cb6edd4a51e0738953a4276aa84fa20/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs?ref=02ba216e3cb6edd4a51e0738953a4276aa84fa20", "patch": "@@ -587,8 +587,7 @@ fn resolve_local<'tcx>(\n         // & expression, and its lifetime would be extended to the end of the block (due\n         // to a different rule, not the below code).\n         match pat.kind {\n-            PatKind::Binding(hir::BindingAnnotation::Ref, ..)\n-            | PatKind::Binding(hir::BindingAnnotation::RefMut, ..) => true,\n+            PatKind::Binding(hir::BindingAnnotation(hir::ByRef::Yes, _), ..) => true,\n \n             PatKind::Struct(_, ref field_pats, _) => {\n                 field_pats.iter().any(|fp| is_binding_pat(&fp.pat))\n@@ -607,10 +606,7 @@ fn resolve_local<'tcx>(\n             PatKind::Box(ref subpat) => is_binding_pat(&subpat),\n \n             PatKind::Ref(_, _)\n-            | PatKind::Binding(\n-                hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable,\n-                ..,\n-            )\n+            | PatKind::Binding(hir::BindingAnnotation(hir::ByRef::No, _), ..)\n             | PatKind::Wild\n             | PatKind::Path(_)\n             | PatKind::Lit(_)"}]}