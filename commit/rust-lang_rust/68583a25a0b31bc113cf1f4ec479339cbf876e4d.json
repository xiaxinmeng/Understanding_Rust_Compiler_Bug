{"sha": "68583a25a0b31bc113cf1f4ec479339cbf876e4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NTgzYTI1YTBiMzFiYzExM2NmMWY0ZWM0NzkzMzljYmY4NzZlNGQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-15T23:19:01Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-16T00:45:34Z"}, "message": "core::rt: Restructure context switches to take ownership of the Scheduler\n\nIn order to do a context switch you have to give up ownership of the scheduler,\neffectively passing it to the next execution context. This could help avoid\nsome situations here tasks retain unsafe pointers to schedulers between context\nswitches, across which they may have changed threads.\n\nThere are still a number of uses of unsafe scheduler pointers.", "tree": {"sha": "a0d30ca211a59ac96ddec1c01a2596c563752c04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0d30ca211a59ac96ddec1c01a2596c563752c04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68583a25a0b31bc113cf1f4ec479339cbf876e4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68583a25a0b31bc113cf1f4ec479339cbf876e4d", "html_url": "https://github.com/rust-lang/rust/commit/68583a25a0b31bc113cf1f4ec479339cbf876e4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68583a25a0b31bc113cf1f4ec479339cbf876e4d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebefe07792caf17c03c6f90fb1979d4e6c935001", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebefe07792caf17c03c6f90fb1979d4e6c935001", "html_url": "https://github.com/rust-lang/rust/commit/ebefe07792caf17c03c6f90fb1979d4e6c935001"}], "stats": {"total": 156, "additions": 94, "deletions": 62}, "files": [{"sha": "2aaf0a444551c2a761e53225535948798508ec38", "filename": "src/libcore/rt/sched/mod.rs", "status": "modified", "additions": 70, "deletions": 45, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/68583a25a0b31bc113cf1f4ec479339cbf876e4d/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68583a25a0b31bc113cf1f4ec479339cbf876e4d/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=68583a25a0b31bc113cf1f4ec479339cbf876e4d", "patch": "@@ -20,6 +20,7 @@ use super::context::Context;\n #[cfg(test)] use super::uvio::UvEventLoop;\n #[cfg(test)] use unstable::run_in_bare_thread;\n #[cfg(test)] use int;\n+#[cfg(test)] use cell::Cell;\n \n mod local;\n \n@@ -46,14 +47,14 @@ pub struct Scheduler {\n // complaining\n type UnsafeTaskReceiver = sys::Closure;\n trait HackAroundBorrowCk {\n-    fn from_fn(&fn(&mut Scheduler, ~Task)) -> Self;\n-    fn to_fn(self) -> &fn(&mut Scheduler, ~Task);\n+    fn from_fn(&fn(~Task)) -> Self;\n+    fn to_fn(self) -> &fn(~Task);\n }\n impl HackAroundBorrowCk for UnsafeTaskReceiver {\n-    fn from_fn(f: &fn(&mut Scheduler, ~Task)) -> UnsafeTaskReceiver {\n+    fn from_fn(f: &fn(~Task)) -> UnsafeTaskReceiver {\n         unsafe { transmute(f) }\n     }\n-    fn to_fn(self) -> &fn(&mut Scheduler, ~Task) {\n+    fn to_fn(self) -> &fn(~Task) {\n         unsafe { transmute(self) }\n     }\n }\n@@ -97,10 +98,12 @@ pub impl Scheduler {\n \n         let scheduler = Scheduler::unsafe_local_borrow();\n         fn run_scheduler_once() {\n-            let scheduler = Scheduler::unsafe_local_borrow();\n+            let scheduler = Scheduler::local_take();\n             if scheduler.resume_task_from_queue() {\n                 // Ok, a task ran. Nice! We'll do it again later\n-                scheduler.event_loop.callback(run_scheduler_once);\n+                do Scheduler::local_borrow |scheduler| {\n+                    scheduler.event_loop.callback(run_scheduler_once);\n+                }\n             }\n         }\n \n@@ -124,9 +127,13 @@ pub impl Scheduler {\n         local::put(sched);\n     }\n \n+    fn local_take() -> ~Scheduler {\n+        local::take()\n+    }\n+\n     // * Scheduler-context operations\n \n-    fn resume_task_from_queue(&mut self) -> bool {\n+    fn resume_task_from_queue(~self) -> bool {\n         assert!(!self.in_task_context());\n \n         let mut self = self;\n@@ -137,12 +144,14 @@ pub impl Scheduler {\n             }\n             None => {\n                 rtdebug!(\"no tasks in queue\");\n+                local::put(self);\n                 return false;\n             }\n         }\n     }\n \n-    fn resume_task_immediately(&mut self, task: ~Task) {\n+    fn resume_task_immediately(~self, task: ~Task) {\n+        let mut self = self;\n         assert!(!self.in_task_context());\n \n         rtdebug!(\"scheduling a task\");\n@@ -151,39 +160,46 @@ pub impl Scheduler {\n         self.current_task = Some(task);\n         self.enqueue_cleanup_job(DoNothing);\n \n+        local::put(self);\n+\n         // Take pointers to both the task and scheduler's saved registers.\n-        {\n-            let (sched_context, _, next_task_context) = self.get_contexts();\n-            let next_task_context = next_task_context.unwrap();\n-            // Context switch to the task, restoring it's registers\n-            // and saving the scheduler's\n-            Context::swap(sched_context, next_task_context);\n-        }\n+        let sched = Scheduler::unsafe_local_borrow();\n+        let (sched_context, _, next_task_context) = sched.get_contexts();\n+        let next_task_context = next_task_context.unwrap();\n+        // Context switch to the task, restoring it's registers\n+        // and saving the scheduler's\n+        Context::swap(sched_context, next_task_context);\n \n+        let sched = Scheduler::unsafe_local_borrow();\n         // The running task should have passed ownership elsewhere\n-        assert!(self.current_task.is_none());\n+        assert!(sched.current_task.is_none());\n \n         // Running tasks may have asked us to do some cleanup\n-        self.run_cleanup_job();\n+        sched.run_cleanup_job();\n     }\n \n \n     // * Task-context operations\n \n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n-    fn terminate_current_task(&mut self) {\n+    fn terminate_current_task(~self) {\n+        let mut self = self;\n         assert!(self.in_task_context());\n \n         rtdebug!(\"ending running task\");\n \n         let dead_task = self.current_task.swap_unwrap();\n         self.enqueue_cleanup_job(RecycleTask(dead_task));\n-        {\n-            let (sched_context, last_task_context, _) = self.get_contexts();\n-            let last_task_context = last_task_context.unwrap();\n-            Context::swap(last_task_context, sched_context);\n-        }\n+\n+        local::put(self);\n+\n+        let sched = Scheduler::unsafe_local_borrow();\n+        let (sched_context, last_task_context, _) = sched.get_contexts();\n+        let last_task_context = last_task_context.unwrap();\n+        Context::swap(last_task_context, sched_context);\n+\n+        // Control never reaches here\n     }\n \n     /// Block a running task, context switch to the scheduler, then pass the\n@@ -194,22 +210,25 @@ pub impl Scheduler {\n     /// The closure here is a *stack* closure that lives in the\n     /// running task.  It gets transmuted to the scheduler's lifetime\n     /// and called while the task is blocked.\n-    fn deschedule_running_task_and_then(&mut self, f: &fn(&mut Scheduler, ~Task)) {\n+    fn deschedule_running_task_and_then(~self, f: &fn(~Task)) {\n+        let mut self = self;\n         assert!(self.in_task_context());\n \n         rtdebug!(\"blocking task\");\n \n         let blocked_task = self.current_task.swap_unwrap();\n         let f_fake_region = unsafe {\n-            transmute::<&fn(&mut Scheduler, ~Task), &fn(&mut Scheduler, ~Task)>(f)\n+            transmute::<&fn(~Task), &fn(~Task)>(f)\n         };\n         let f_opaque = HackAroundBorrowCk::from_fn(f_fake_region);\n         self.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n-        {\n-            let (sched_context, last_task_context, _) = self.get_contexts();\n-            let last_task_context = last_task_context.unwrap();\n-            Context::swap(last_task_context, sched_context);\n-        }\n+\n+        local::put(self);\n+\n+        let sched = Scheduler::unsafe_local_borrow();\n+        let (sched_context, last_task_context, _) = sched.get_contexts();\n+        let last_task_context = last_task_context.unwrap();\n+        Context::swap(last_task_context, sched_context);\n \n         // We could be executing in a different thread now\n         let sched = Scheduler::unsafe_local_borrow();\n@@ -219,20 +238,23 @@ pub impl Scheduler {\n     /// Switch directly to another task, without going through the scheduler.\n     /// You would want to think hard about doing this, e.g. if there are\n     /// pending I/O events it would be a bad idea.\n-    fn resume_task_from_running_task_direct(&mut self, next_task: ~Task) {\n+    fn resume_task_from_running_task_direct(~self, next_task: ~Task) {\n+        let mut self = self;\n         assert!(self.in_task_context());\n \n         rtdebug!(\"switching tasks\");\n \n         let old_running_task = self.current_task.swap_unwrap();\n         self.enqueue_cleanup_job(RescheduleTask(old_running_task));\n         self.current_task = Some(next_task);\n-        {\n-            let (_, last_task_context, next_task_context) = self.get_contexts();\n-            let last_task_context = last_task_context.unwrap();\n-            let next_task_context = next_task_context.unwrap();\n-            Context::swap(last_task_context, next_task_context);\n-        }\n+\n+        local::put(self);\n+\n+        let sched = Scheduler::unsafe_local_borrow();\n+        let (_, last_task_context, next_task_context) = sched.get_contexts();\n+        let last_task_context = last_task_context.unwrap();\n+        let next_task_context = next_task_context.unwrap();\n+        Context::swap(last_task_context, next_task_context);\n \n         // We could be executing in a different thread now\n         let sched = Scheduler::unsafe_local_borrow();\n@@ -261,7 +283,7 @@ pub impl Scheduler {\n                 self.task_queue.push_front(task);\n             }\n             RecycleTask(task) => task.recycle(&mut self.stack_pool),\n-            GiveTask(task, f) => (f.to_fn())(self, task)\n+            GiveTask(task, f) => (f.to_fn())(task)\n         }\n     }\n \n@@ -338,7 +360,7 @@ pub impl Task {\n \n             start();\n \n-            let sched = Scheduler::unsafe_local_borrow();\n+            let sched = Scheduler::local_take();\n             sched.terminate_current_task();\n         };\n         return wrapper;\n@@ -398,7 +420,7 @@ fn test_swap_tasks() {\n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task1 = ~do Task::new(&mut sched.stack_pool) {\n             unsafe { *count_ptr = *count_ptr + 1; }\n-            let sched = Scheduler::unsafe_local_borrow();\n+            let mut sched = Scheduler::local_take();\n             let task2 = ~do Task::new(&mut sched.stack_pool) {\n                 unsafe { *count_ptr = *count_ptr + 1; }\n             };\n@@ -463,7 +485,7 @@ fn test_run_a_lot_of_tasks_direct() {\n         assert!(count == MAX);\n \n         fn run_task(count_ptr: *mut int) {\n-            let sched = Scheduler::unsafe_local_borrow();\n+            let mut sched = Scheduler::local_take();\n             let task = ~do Task::new(&mut sched.stack_pool) {\n                 unsafe {\n                     *count_ptr = *count_ptr + 1;\n@@ -483,11 +505,14 @@ fn test_block_task() {\n     do run_in_bare_thread {\n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task = ~do Task::new(&mut sched.stack_pool) {\n-            let sched = Scheduler::unsafe_local_borrow();\n+            let sched = Scheduler::local_take();\n             assert!(sched.in_task_context());\n-            do sched.deschedule_running_task_and_then() |sched, task| {\n-                assert!(!sched.in_task_context());\n-                sched.task_queue.push_back(task);\n+            do sched.deschedule_running_task_and_then() |task| {\n+                let task = Cell(task);\n+                do Scheduler::local_borrow |sched| {\n+                    assert!(!sched.in_task_context());\n+                    sched.task_queue.push_back(task.take());\n+                }\n             }\n         };\n         sched.task_queue.push_back(task);"}, {"sha": "e3fed29ddd28372c368460347824b3846724d2d8", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/68583a25a0b31bc113cf1f4ec479339cbf876e4d/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68583a25a0b31bc113cf1f4ec479339cbf876e4d/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=68583a25a0b31bc113cf1f4ec479339cbf876e4d", "patch": "@@ -104,14 +104,16 @@ impl IoFactory for UvIoFactory {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n \n-        let scheduler = Scheduler::unsafe_local_borrow();\n+        let scheduler = Scheduler::local_take();\n         assert!(scheduler.in_task_context());\n \n         // Block this task and take ownership, switch to scheduler context\n-        do scheduler.deschedule_running_task_and_then |scheduler, task| {\n+        do scheduler.deschedule_running_task_and_then |task| {\n \n             rtdebug!(\"connect: entered scheduler context\");\n-            assert!(!scheduler.in_task_context());\n+            do Scheduler::local_borrow |scheduler| {\n+                assert!(!scheduler.in_task_context());\n+            }\n             let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n             let task_cell = Cell(task);\n \n@@ -131,7 +133,7 @@ impl IoFactory for UvIoFactory {\n                 unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n \n                 // Context switch\n-                let scheduler = Scheduler::unsafe_local_borrow();\n+                let scheduler = Scheduler::local_take();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -176,10 +178,10 @@ impl TcpListener for UvTcpListener {\n \n         let server_tcp_watcher = self.watcher();\n \n-        let scheduler = Scheduler::unsafe_local_borrow();\n+        let scheduler = Scheduler::local_take();\n         assert!(scheduler.in_task_context());\n \n-        do scheduler.deschedule_running_task_and_then |_, task| {\n+        do scheduler.deschedule_running_task_and_then |task| {\n             let task_cell = Cell(task);\n             let mut server_tcp_watcher = server_tcp_watcher;\n             do server_tcp_watcher.listen |server_stream_watcher, status| {\n@@ -199,7 +201,7 @@ impl TcpListener for UvTcpListener {\n \n                 rtdebug!(\"resuming task from listen\");\n                 // Context switch\n-                let scheduler = Scheduler::unsafe_local_borrow();\n+                let scheduler = Scheduler::local_take();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -239,13 +241,15 @@ impl Stream for UvStream {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<uint, ()>> = &result_cell;\n \n-        let scheduler = Scheduler::unsafe_local_borrow();\n+        let scheduler = Scheduler::local_take();\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n         let buf_ptr: *&mut [u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |scheduler, task| {\n+        do scheduler.deschedule_running_task_and_then |task| {\n             rtdebug!(\"read: entered scheduler context\");\n-            assert!(!scheduler.in_task_context());\n+            do Scheduler::local_borrow |scheduler| {\n+                assert!(!scheduler.in_task_context());\n+            }\n             let mut watcher = watcher;\n             let task_cell = Cell(task);\n             // XXX: We shouldn't reallocate these callbacks every\n@@ -271,7 +275,7 @@ impl Stream for UvStream {\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n \n-                let scheduler = Scheduler::unsafe_local_borrow();\n+                let scheduler = Scheduler::local_take();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -283,11 +287,11 @@ impl Stream for UvStream {\n     fn write(&mut self, buf: &[u8]) -> Result<(), ()> {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<(), ()>> = &result_cell;\n-        let scheduler = Scheduler::unsafe_local_borrow();\n+        let scheduler = Scheduler::local_take();\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n         let buf_ptr: *&[u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n+        do scheduler.deschedule_running_task_and_then |task| {\n             let mut watcher = watcher;\n             let task_cell = Cell(task);\n             let buf = unsafe { &*buf_ptr };\n@@ -302,7 +306,7 @@ impl Stream for UvStream {\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n \n-                let scheduler = Scheduler::unsafe_local_borrow();\n+                let scheduler = Scheduler::local_take();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -404,12 +408,15 @@ fn test_read_and_block() {\n                 }\n                 reads += 1;\n \n-                let scheduler = Scheduler::unsafe_local_borrow();\n+                let scheduler = Scheduler::local_take();\n                 // Yield to the other task in hopes that it\n                 // will trigger a read callback while we are\n                 // not ready for it\n-                do scheduler.deschedule_running_task_and_then |scheduler, task| {\n-                    scheduler.task_queue.push_back(task);\n+                do scheduler.deschedule_running_task_and_then |task| {\n+                    let task = Cell(task);\n+                    do Scheduler::local_borrow |scheduler| {\n+                        scheduler.task_queue.push_back(task.take());\n+                    }\n                 }\n             }\n "}]}