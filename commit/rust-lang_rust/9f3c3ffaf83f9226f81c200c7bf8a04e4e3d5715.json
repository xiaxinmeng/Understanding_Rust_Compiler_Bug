{"sha": "9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "node_id": "C_kwDOAAsO6NoAKDlmM2MzZmZhZjgzZjkyMjZmODFjMjAwYzdiZjhhMDRlNGUzZDU3MTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-05T17:37:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-05T17:37:09Z"}, "message": "Auto merge of #2804 - saethlin:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "284242248144c20d716fdafea65858586dabbafe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/284242248144c20d716fdafea65858586dabbafe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "html_url": "https://github.com/rust-lang/rust/commit/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72014a8dc30bc93eb987616cfa9d4314d1b3d47e", "url": "https://api.github.com/repos/rust-lang/rust/commits/72014a8dc30bc93eb987616cfa9d4314d1b3d47e", "html_url": "https://github.com/rust-lang/rust/commit/72014a8dc30bc93eb987616cfa9d4314d1b3d47e"}, {"sha": "d56332ece806af134fbbb017d5e989a68bb022e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d56332ece806af134fbbb017d5e989a68bb022e0", "html_url": "https://github.com/rust-lang/rust/commit/d56332ece806af134fbbb017d5e989a68bb022e0"}], "stats": {"total": 23000, "additions": 14366, "deletions": 8634}, "files": [{"sha": "44f789c592ba27822f561806ece1f5f5b3404a11", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -322,7 +322,7 @@ jobs:\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: dist-apple-various\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --host='' --target=aarch64-apple-ios,x86_64-apple-ios,aarch64-apple-ios-sim\"\n@@ -333,7 +333,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: dist-x86_64-apple-alt\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths\"\n@@ -344,7 +344,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: x86_64-apple-1\n             env:\n               SCRIPT: \"./x.py --stage 2 test --exclude tests/ui --exclude tests/rustdoc --exclude tests/run-make-fulldeps\"\n@@ -355,7 +355,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: x86_64-apple-2\n             env:\n               SCRIPT: \"./x.py --stage 2 test tests/ui tests/rustdoc tests/run-make-fulldeps\"\n@@ -366,7 +366,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: dist-aarch64-apple\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --stage 2\"\n@@ -381,7 +381,7 @@ jobs:\n               NO_OVERFLOW_CHECKS: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n               JEMALLOC_SYS_WITH_LG_PAGE: 14\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: x86_64-msvc-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\""}, {"sha": "715bc4d30855ebb638ab7f524db727c2391abbc5", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -15,7 +15,7 @@ Adrien T\u00e9tar <adri-from-59@hotmail.fr>\n Ahmed Charles <ahmedcharles@gmail.com> <acharles@outlook.com>\n Alan Egerton <eggyal@gmail.com>\n Alan Stoate <alan.stoate@gmail.com>\n-Albert Larsan <albert.larsan@gmail.com> Albert Larsan <74931857+albertlarsan68@users.noreply.github.com>\n+Albert Larsan <albert.larsan@gmail.com> <74931857+albertlarsan68@users.noreply.github.com>\n Alessandro Decina <alessandro.d@gmail.com>\n Alex Burka <durka42+github@gmail.com> Alex Burka <aburka@seas.upenn.edu>\n Alex Hansen <ahansen2@trinity.edu>"}, {"sha": "5530541cdd0f1adcd77504814d674d4794dbff8b", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1373,9 +1373,9 @@ dependencies = [\n \n [[package]]\n name = \"ena\"\n-version = \"0.14.0\"\n+version = \"0.14.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d7402b94a93c24e742487327a7cd839dc9d36fec9de9fb25b09f2dae459f36c3\"\n+checksum = \"b2e5d13ca2353ab7d0230988629def93914a8c4015f621f9b13ed2955614731d\"\n dependencies = [\n  \"log\",\n ]\n@@ -1922,15 +1922,6 @@ dependencies = [\n  \"libc\",\n ]\n \n-[[package]]\n-name = \"hermit-abi\"\n-version = \"0.2.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7\"\n-dependencies = [\n- \"libc\",\n-]\n-\n [[package]]\n name = \"hermit-abi\"\n version = \"0.3.0\"\n@@ -2222,14 +2213,14 @@ dependencies = [\n \n [[package]]\n name = \"is-terminal\"\n-version = \"0.4.2\"\n+version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"28dfb6c8100ccc63462345b67d1bbc3679177c75ee4bf59bf29c8b1d110b8189\"\n+checksum = \"21b6b32576413a8e69b90e952e4a026476040d81017b80445deda5f2d3921857\"\n dependencies = [\n- \"hermit-abi 0.2.6\",\n+ \"hermit-abi 0.3.0\",\n  \"io-lifetimes\",\n  \"rustix\",\n- \"windows-sys 0.42.0\",\n+ \"windows-sys 0.45.0\",\n ]\n \n [[package]]\n@@ -2260,9 +2251,9 @@ dependencies = [\n \n [[package]]\n name = \"jobserver\"\n-version = \"0.1.24\"\n+version = \"0.1.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"af25a77299a7f711a01975c35a6a424eb6862092cc2d6c72c4ed6cbc56dfc1fa\"\n+checksum = \"936cfd212a0155903bcbc060e316fb6cc7cbf2e1907329391ebadc1fe0ce77c2\"\n dependencies = [\n  \"libc\",\n ]\n@@ -2328,9 +2319,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.138\"\n+version = \"0.2.139\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"db6d7e329c562c5dfab7a46a2afabc8b987ab9a4834c9d1ca04dc54c1546cef8\"\n+checksum = \"201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -3810,6 +3801,8 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_symbol_mangling\",\n  \"rustc_target\",\n+ \"serde\",\n+ \"serde_json\",\n  \"smallvec\",\n  \"tempfile\",\n  \"tracing\","}, {"sha": "c424bd12ffdbc5c516efc7e28a87ae35fda8ea01", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,5 +1,7 @@\n # The Rust Programming Language\n \n+[![Rust Community](https://img.shields.io/badge/Rust_Community%20-Join_us-brightgreen?style=plastic&logo=rust)](https://www.rust-lang.org/community)\n+\n This is the main source code repository for [Rust]. It contains the compiler,\n standard library, and documentation.\n "}, {"sha": "39574ca558f8b3616dbe9cbeefc4366b88593b8d", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1505,14 +1505,6 @@ pub struct PointeeInfo {\n     pub safe: Option<PointerKind>,\n }\n \n-/// Used in `might_permit_raw_init` to indicate the kind of initialisation\n-/// that is checked to be valid\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum InitKind {\n-    Zero,\n-    UninitMitigated0x01Fill,\n-}\n-\n impl LayoutS {\n     /// Returns `true` if the layout corresponds to an unsized type.\n     pub fn is_unsized(&self) -> bool {"}, {"sha": "3a0af04f9eb98c11304f140d06ba09d0763fc4a3", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -225,7 +225,7 @@ impl AssocOp {\n             AssignOp(_) | // `{ 42 } +=`\n             As | // `{ 42 } as usize`\n             // Equal | // `{ 42 } == { 42 }`    Accepting these here would regress incorrect\n-            // NotEqual | // `{ 42 } != { 42 }  struct literals parser recovery.\n+            // NotEqual | // `{ 42 } != { 42 }` struct literals parser recovery.\n             Colon, // `{ 42 }: usize`\n         )\n     }"}, {"sha": "3ccd84398ec2720b45a71eb71dcbb1cae73f3a10", "filename": "compiler/rustc_ast_lowering/locales/en-US.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_lowering%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_lowering%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Flocales%2Fen-US.ftl?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -22,9 +22,6 @@ ast_lowering_misplaced_impl_trait =\n ast_lowering_misplaced_assoc_ty_binding =\n     associated type bounds are only allowed in where clauses and function signatures, not in {$position}\n \n-ast_lowering_rustc_box_attribute_error =\n-    #[rustc_box] requires precisely one argument and no other attributes are allowed\n-\n ast_lowering_underscore_expr_lhs_assign =\n     in expressions, `_` can only be used on the left-hand side of an assignment\n     .label = `_` not allowed here"}, {"sha": "5e6b6050bc0eaeaa8ba1c96c41be008607745b20", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -87,13 +87,6 @@ pub struct MisplacedAssocTyBinding<'a> {\n     pub position: DiagnosticArgFromDisplay<'a>,\n }\n \n-#[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering_rustc_box_attribute_error)]\n-pub struct RustcBoxAttributeError {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering_underscore_expr_lhs_assign)]\n pub struct UnderscoreExprLhsAssign {"}, {"sha": "ffb30b1b39127972724c914624007b4cd1fe2f87", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -2,7 +2,7 @@ use super::errors::{\n     AsyncGeneratorsNotSupported, AsyncNonMoveClosureNotSupported, AwaitOnlyInAsyncFnAndBlocks,\n     BaseExpressionDoubleDot, ClosureCannotBeStatic, FunctionalRecordUpdateDestructuringAssignemnt,\n     GeneratorTooManyParameters, InclusiveRangeWithNoEnd, NotSupportedForLifetimeBinderAsyncClosure,\n-    RustcBoxAttributeError, UnderscoreExprLhsAssign,\n+    UnderscoreExprLhsAssign,\n };\n use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n@@ -83,15 +83,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 ExprKind::Tup(elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n                 ExprKind::Call(f, args) => {\n-                    if e.attrs.get(0).map_or(false, |a| a.has_name(sym::rustc_box)) {\n-                        if let [inner] = &args[..] && e.attrs.len() == 1 {\n-                            let kind = hir::ExprKind::Box(self.lower_expr(&inner));\n-                            return hir::Expr { hir_id, kind, span: self.lower_span(e.span) };\n-                        } else {\n-                            let guar = self.tcx.sess.emit_err(RustcBoxAttributeError { span: e.span });\n-                            hir::ExprKind::Err(guar)\n-                        }\n-                    } else if let Some(legacy_args) = self.resolver.legacy_const_generic_args(f) {\n+                    if let Some(legacy_args) = self.resolver.legacy_const_generic_args(f) {\n                         self.lower_legacy_const_generics((**f).clone(), args.clone(), &legacy_args)\n                     } else {\n                         let f = self.lower_expr(f);"}, {"sha": "debe0acb04ef6005f79bc93069a1becd81256985", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::PredicateOrigin;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::ty::{DefIdTree, ResolverAstLowering, TyCtxt};\n+use rustc_middle::ty::{ResolverAstLowering, TyCtxt};\n use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -1339,13 +1339,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 .map(|predicate| self.lower_where_predicate(predicate)),\n         );\n \n-        let mut params: SmallVec<[hir::GenericParam<'hir>; 4]> =\n-            self.lower_generic_params_mut(&generics.params).collect();\n+        let mut params: SmallVec<[hir::GenericParam<'hir>; 4]> = self\n+            .lower_generic_params_mut(&generics.params, hir::GenericParamSource::Generics)\n+            .collect();\n \n         // Introduce extra lifetimes if late resolution tells us to.\n         let extra_lifetimes = self.resolver.take_extra_lifetime_params(parent_node_id);\n         params.extend(extra_lifetimes.into_iter().filter_map(|(ident, node_id, res)| {\n-            self.lifetime_res_to_generic_param(ident, node_id, res)\n+            self.lifetime_res_to_generic_param(\n+                ident,\n+                node_id,\n+                res,\n+                hir::GenericParamSource::Generics,\n+            )\n         }));\n \n         let has_where_clause_predicates = !generics.where_clause.predicates.is_empty();\n@@ -1449,7 +1455,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 span,\n             }) => hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                 hir_id: self.next_id(),\n-                bound_generic_params: self.lower_generic_params(bound_generic_params),\n+                bound_generic_params: self\n+                    .lower_generic_params(bound_generic_params, hir::GenericParamSource::Binder),\n                 bounded_ty: self\n                     .lower_ty(bounded_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Bound)),\n                 bounds: self.arena.alloc_from_iter(bounds.iter().map(|bound| {"}, {"sha": "b20157f2c7c8985ad8832ba0364e63eaafeb0b69", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -804,6 +804,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ident: Ident,\n         node_id: NodeId,\n         res: LifetimeRes,\n+        source: hir::GenericParamSource,\n     ) -> Option<hir::GenericParam<'hir>> {\n         let (name, kind) = match res {\n             LifetimeRes::Param { .. } => {\n@@ -837,6 +838,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             pure_wrt_drop: false,\n             kind: hir::GenericParamKind::Lifetime { kind },\n             colon_span: None,\n+            source,\n         })\n     }\n \n@@ -852,11 +854,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         binder: NodeId,\n         generic_params: &[GenericParam],\n     ) -> &'hir [hir::GenericParam<'hir>] {\n-        let mut generic_params: Vec<_> = self.lower_generic_params_mut(generic_params).collect();\n+        let mut generic_params: Vec<_> = self\n+            .lower_generic_params_mut(generic_params, hir::GenericParamSource::Binder)\n+            .collect();\n         let extra_lifetimes = self.resolver.take_extra_lifetime_params(binder);\n         debug!(?extra_lifetimes);\n         generic_params.extend(extra_lifetimes.into_iter().filter_map(|(ident, node_id, res)| {\n-            self.lifetime_res_to_generic_param(ident, node_id, res)\n+            self.lifetime_res_to_generic_param(ident, node_id, res, hir::GenericParamSource::Binder)\n         }));\n         let generic_params = self.arena.alloc_from_iter(generic_params);\n         debug!(?generic_params);\n@@ -1375,8 +1379,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             span,\n                         );\n                         let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n-                        let (param, bounds, path) =\n-                            self.lower_generic_and_bounds(*def_node_id, span, ident, bounds);\n+                        let (param, bounds, path) = self.lower_universal_param_and_bounds(\n+                            *def_node_id,\n+                            span,\n+                            ident,\n+                            bounds,\n+                        );\n                         self.impl_trait_defs.push(param);\n                         if let Some(bounds) = bounds {\n                             self.impl_trait_bounds.push(bounds);\n@@ -1530,6 +1538,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             pure_wrt_drop: false,\n                             kind: hir::GenericParamKind::Lifetime { kind },\n                             colon_span: None,\n+                            source: hir::GenericParamSource::Generics,\n                         }\n                     },\n                 ));\n@@ -1598,7 +1607,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::OwnerNode::Item(self.arena.alloc(opaque_ty_item))\n     }\n \n-    /// Given a `parent_def_id`, a list of `lifetimes_in_bounds and a `remapping` hash to be\n+    /// Given a `parent_def_id`, a list of `lifetimes_in_bounds` and a `remapping` hash to be\n     /// filled, this function creates new definitions for `Param` and `Fresh` lifetimes, inserts the\n     /// new definition, adds it to the remapping with the definition of the given lifetime and\n     /// returns a list of lifetimes to be lowered afterwards.\n@@ -1987,6 +1996,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             pure_wrt_drop: false,\n                             kind: hir::GenericParamKind::Lifetime { kind },\n                             colon_span: None,\n+                            source: hir::GenericParamSource::Generics,\n                         }\n                     },\n                 ));\n@@ -2152,16 +2162,25 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_generic_params_mut<'s>(\n         &'s mut self,\n         params: &'s [GenericParam],\n+        source: hir::GenericParamSource,\n     ) -> impl Iterator<Item = hir::GenericParam<'hir>> + Captures<'a> + Captures<'s> {\n-        params.iter().map(move |param| self.lower_generic_param(param))\n+        params.iter().map(move |param| self.lower_generic_param(param, source))\n     }\n \n-    fn lower_generic_params(&mut self, params: &[GenericParam]) -> &'hir [hir::GenericParam<'hir>] {\n-        self.arena.alloc_from_iter(self.lower_generic_params_mut(params))\n+    fn lower_generic_params(\n+        &mut self,\n+        params: &[GenericParam],\n+        source: hir::GenericParamSource,\n+    ) -> &'hir [hir::GenericParam<'hir>] {\n+        self.arena.alloc_from_iter(self.lower_generic_params_mut(params, source))\n     }\n \n     #[instrument(level = \"trace\", skip(self))]\n-    fn lower_generic_param(&mut self, param: &GenericParam) -> hir::GenericParam<'hir> {\n+    fn lower_generic_param(\n+        &mut self,\n+        param: &GenericParam,\n+        source: hir::GenericParamSource,\n+    ) -> hir::GenericParam<'hir> {\n         let (name, kind) = self.lower_generic_param_kind(param);\n \n         let hir_id = self.lower_node_id(param.id);\n@@ -2174,6 +2193,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             pure_wrt_drop: self.tcx.sess.contains_name(&param.attrs, sym::may_dangle),\n             kind,\n             colon_span: param.colon_span.map(|s| self.lower_span(s)),\n+            source,\n         }\n     }\n \n@@ -2266,7 +2286,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     #[instrument(level = \"debug\", skip(self), ret)]\n-    fn lower_generic_and_bounds(\n+    fn lower_universal_param_and_bounds(\n         &mut self,\n         node_id: NodeId,\n         span: Span,\n@@ -2286,6 +2306,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             span,\n             kind: hir::GenericParamKind::Type { default: None, synthetic: true },\n             colon_span: None,\n+            source: hir::GenericParamSource::Generics,\n         };\n \n         let preds = self.lower_generic_bound_predicate("}, {"sha": "539c822ea09777ba775dd2ccf46bcadb6de67a2c", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -12,7 +12,7 @@ use rustc_ast::visit::{self, AssocCtxt, BoundKind, FnCtxt, FnKind, Visitor};\n use rustc_ast::walk_list;\n use rustc_ast::*;\n use rustc_ast_pretty::pprust::{self, State};\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_macros::Subdiagnostic;\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::{\n@@ -192,7 +192,7 @@ impl<'a> AstValidator<'a> {\n                 // We allow these:\n                 //  - `Option<impl Trait>`\n                 //  - `option::Option<impl Trait>`\n-                //  - `option::Option<T>::Foo<impl Trait>\n+                //  - `option::Option<T>::Foo<impl Trait>`\n                 //\n                 // But not these:\n                 //  - `<impl Trait>::Foo`\n@@ -643,7 +643,7 @@ fn validate_generic_param_order(\n     span: Span,\n ) {\n     let mut max_param: Option<ParamKindOrd> = None;\n-    let mut out_of_order = FxHashMap::default();\n+    let mut out_of_order = FxIndexMap::default();\n     let mut param_idents = Vec::with_capacity(generics.len());\n \n     for (idx, param) in generics.iter().enumerate() {"}, {"sha": "96042ea30787eb70e7459a975ae463dd719d5b6c", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -386,7 +386,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ).span_suggestion_verbose(\n                 lhs.span.shrink_to_lo(),\n                 \"you might have meant to introduce a new binding\",\n-                \"let \".to_string(),\n+                \"let \",\n                 Applicability::MachineApplicable,\n             ).emit();\n         }"}, {"sha": "6207a32b28de6ce2f5761a3f597c36d433a597a0", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -4,7 +4,6 @@\n //!\n //! The crate also contains other misc AST visitors, e.g. `node_count` and `show_span`.\n \n-#![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n #![feature(if_let_guard)]\n #![feature(iter_is_partitioned)]"}, {"sha": "a622a215a2e8e20583b9eec925043cf602f90c66", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::{\n     struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, LangItem};\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -236,10 +236,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty = used_place.ty(self.body, self.infcx.tcx).ty;\n             let needs_note = match ty.kind() {\n                 ty::Closure(id, _) => {\n-                    let tables = self.infcx.tcx.typeck(id.expect_local());\n-                    let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(id.expect_local());\n-\n-                    tables.closure_kind_origins().get(hir_id).is_none()\n+                    self.infcx.tcx.closure_kind_origin(id.expect_local()).is_none()\n                 }\n                 _ => true,\n             };\n@@ -1470,6 +1467,32 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Reports StorageDeadOrDrop of `place` conflicts with `borrow`.\n     ///\n+    /// Depending on the origin of the StorageDeadOrDrop, this may be\n+    /// reported as either a drop or an illegal mutation of a borrowed value.\n+    /// The latter is preferred when the this is a drop triggered by a\n+    /// reassignment, as it's more user friendly to report a problem with the\n+    /// explicit assignment than the implicit drop.\n+    #[instrument(level = \"debug\", skip(self))]\n+    pub(crate) fn report_storage_dead_or_drop_of_borrowed(\n+        &mut self,\n+        location: Location,\n+        place_span: (Place<'tcx>, Span),\n+        borrow: &BorrowData<'tcx>,\n+    ) {\n+        // It's sufficient to check the last desugaring as Replace is the last\n+        // one to be applied.\n+        if let Some(DesugaringKind::Replace) = place_span.1.desugaring_kind() {\n+            self.report_illegal_mutation_of_borrowed(location, place_span, borrow)\n+        } else {\n+            self.report_borrowed_value_does_not_live_long_enough(\n+                location,\n+                borrow,\n+                place_span,\n+                Some(WriteKind::StorageDeadOrDrop),\n+            )\n+        }\n+    }\n+\n     /// This means that some data referenced by `borrow` needs to live\n     /// past the point where the StorageDeadOrDrop of `place` occurs.\n     /// This is usually interpreted as meaning that `place` has too\n@@ -1670,27 +1693,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n             );\n \n-            let fn_hir_id = self.mir_hir_id();\n             err.span_label(\n                 drop_span,\n                 format!(\n                     \"...but `{}` will be dropped here, when the {} returns\",\n                     name,\n                     self.infcx\n                         .tcx\n-                        .hir()\n-                        .opt_name(fn_hir_id)\n+                        .opt_item_name(self.mir_def_id().to_def_id())\n                         .map(|name| format!(\"function `{}`\", name))\n                         .unwrap_or_else(|| {\n-                            match &self\n-                                .infcx\n-                                .tcx\n-                                .typeck(self.mir_def_id())\n-                                .node_type(fn_hir_id)\n-                                .kind()\n-                            {\n-                                ty::Closure(..) => \"enclosing closure\",\n-                                ty::Generator(..) => \"enclosing generator\",\n+                            match &self.infcx.tcx.def_kind(self.mir_def_id()) {\n+                                DefKind::Closure => \"enclosing closure\",\n+                                DefKind::Generator => \"enclosing generator\",\n                                 kind => bug!(\"expected closure or generator, found {:?}\", kind),\n                             }\n                             .to_string()"}, {"sha": "af705e6a80fef765fb8ba8e5f576b725be8c6a88", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::mir::{\n     Place, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty::print::Print;\n-use rustc_middle::ty::{self, DefIdTree, Instance, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n use rustc_mir_dataflow::move_paths::{InitLocation, LookupResult};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n@@ -115,11 +115,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n                     if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind() {\n                         let did = did.expect_local();\n-                        let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did);\n-\n-                        if let Some((span, hir_place)) =\n-                            self.infcx.tcx.typeck(did).closure_kind_origins().get(hir_id)\n-                        {\n+                        if let Some((span, hir_place)) = self.infcx.tcx.closure_kind_origin(did) {\n                             diag.span_note(\n                                 *span,\n                                 &format!(\n@@ -139,11 +135,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let Some(target) = target {\n             if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind() {\n                 let did = did.expect_local();\n-                let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did);\n-\n-                if let Some((span, hir_place)) =\n-                    self.infcx.tcx.typeck(did).closure_kind_origins().get(hir_id)\n-                {\n+                if let Some((span, hir_place)) = self.infcx.tcx.closure_kind_origin(did) {\n                     diag.span_note(\n                         *span,\n                         &format!(\n@@ -373,14 +365,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     //\n                     // We know the field exists so it's safe to call operator[] and `unwrap` here.\n                     let def_id = def_id.expect_local();\n-                    let var_id = self\n-                        .infcx\n-                        .tcx\n-                        .typeck(def_id)\n-                        .closure_min_captures_flattened(def_id)\n-                        .nth(field.index())\n-                        .unwrap()\n-                        .get_root_variable();\n+                    let var_id =\n+                        self.infcx.tcx.closure_captures(def_id)[field.index()].get_root_variable();\n \n                     Some(self.infcx.tcx.hir().name(var_id).to_string())\n                 }\n@@ -939,7 +925,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             return OtherUse(use_span);\n         }\n \n-        for stmt in &self.body[location.block].statements[location.statement_index + 1..] {\n+        // drop and replace might have moved the assignment to the next block\n+        let maybe_additional_statement =\n+            if let TerminatorKind::Drop { target: drop_target, .. } =\n+                self.body[location.block].terminator().kind\n+            {\n+                self.body[drop_target].statements.first()\n+            } else {\n+                None\n+            };\n+\n+        let statements =\n+            self.body[location.block].statements[location.statement_index + 1..].iter();\n+\n+        for stmt in statements.chain(maybe_additional_statement) {\n             if let StatementKind::Assign(box (_, Rvalue::Aggregate(kind, places))) = &stmt.kind {\n                 let (&def_id, is_generator) = match kind {\n                     box AggregateKind::Closure(def_id, _) => (def_id, false),\n@@ -987,7 +986,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, .. }) = expr {\n             for (captured_place, place) in\n-                self.infcx.tcx.typeck(def_id).closure_min_captures_flattened(def_id).zip(places)\n+                self.infcx.tcx.closure_captures(def_id).iter().zip(places)\n             {\n                 match place {\n                     Operand::Copy(place) | Operand::Move(place)"}, {"sha": "5e4c7292e590d27d5f51fbbd90f4ceea435000ea", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -467,7 +467,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 err.span_suggestion_verbose(\n                     span.shrink_to_lo(),\n                     \"consider borrowing here\",\n-                    \"&\".to_string(),\n+                    '&',\n                     Applicability::MaybeIncorrect,\n                 );\n             }"}, {"sha": "eded913ae9681af5b5105ccb41c59c38298521e4", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -385,7 +385,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     err.span_suggestion_verbose(\n                         local_decl.source_info.span.shrink_to_lo(),\n                         \"consider changing this to be mutable\",\n-                        \"mut \".to_string(),\n+                        \"mut \",\n                         Applicability::MachineApplicable,\n                     );\n                     let tcx = self.infcx.tcx;\n@@ -828,7 +828,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             let Some(hir::Node::Item(item)) = node else { return; };\n             let hir::ItemKind::Fn(.., body_id) = item.kind else { return; };\n             let body = self.infcx.tcx.hir().body(body_id);\n-            let mut v = V { assign_span: span, err, ty, suggested: false };\n+            let mut assign_span = span;\n+            // Drop desugaring is done at MIR build so it's not in the HIR\n+            if let Some(DesugaringKind::Replace) = span.desugaring_kind() {\n+                assign_span.remove_mark();\n+            }\n+\n+            let mut v = V { assign_span, err, ty, suggested: false };\n             v.visit_body(body);\n             if !v.suggested {\n                 err.help(&format!(\n@@ -901,10 +907,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err: &mut Diagnostic,\n     ) {\n         let tables = tcx.typeck(closure_local_def_id);\n-        let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_local_def_id);\n-        if let Some((span, closure_kind_origin)) =\n-            &tables.closure_kind_origins().get(closure_hir_id)\n-        {\n+        if let Some((span, closure_kind_origin)) = tcx.closure_kind_origin(closure_local_def_id) {\n             let reason = if let PlaceBase::Upvar(upvar_id) = closure_kind_origin.base {\n                 let upvar = ty::place_to_string_for_capture(tcx, closure_kind_origin);\n                 let root_hir_id = upvar_id.var_path.hir_id;"}, {"sha": "ffe82b46cfd678ae4fa1921b821a180f135d54d1", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -415,7 +415,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n     /// ```\n     ///\n-    /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n+    /// Here we would be invoked with `fr = 'a` and `outlived_fr = 'b`.\n     pub(crate) fn report_region_error(\n         &mut self,\n         fr: RegionVid,\n@@ -949,7 +949,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     .push_span_label(*span, \"this has an implicit `'static` lifetime requirement\");\n                 multi_span.push_span_label(\n                     ident.span,\n-                    \"calling this method introduces the `impl`'s 'static` requirement\",\n+                    \"calling this method introduces the `impl`'s `'static` requirement\",\n                 );\n                 err.subdiagnostic(RequireStaticErr::UsedImpl { multi_span });\n                 err.span_suggestion_verbose("}, {"sha": "cc5a1f5ab122d4af2e21699e1cdec868ca7ba5b7", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -6,7 +6,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_middle::ty::print::RegionHighlightMode;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc_middle::ty::{self, DefIdTree, RegionVid, Ty};\n+use rustc_middle::ty::{self, RegionVid, Ty};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n "}, {"sha": "115e512a974294f9b3a50dfd07c2087abdd244fc", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -202,14 +202,14 @@ fn do_mir_borrowck<'tcx>(\n     let mut errors = error::BorrowckErrors::new(infcx.tcx);\n \n     // Gather the upvars of a closure, if any.\n-    let tables = tcx.typeck_opt_const_arg(def);\n-    if let Some(e) = tables.tainted_by_errors {\n+    if let Some(e) = input_body.tainted_by_errors {\n         infcx.set_tainted_by_errors(e);\n         errors.set_tainted_by_errors(e);\n     }\n-    let upvars: Vec<_> = tables\n-        .closure_min_captures_flattened(def.did)\n-        .map(|captured_place| {\n+    let upvars: Vec<_> = tcx\n+        .closure_captures(def.did)\n+        .iter()\n+        .map(|&captured_place| {\n             let capture = captured_place.info.capture_kind;\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue => false,\n@@ -1185,12 +1185,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             this.buffer_error(err);\n                         }\n                         WriteKind::StorageDeadOrDrop => this\n-                            .report_borrowed_value_does_not_live_long_enough(\n-                                location,\n-                                borrow,\n-                                place_span,\n-                                Some(kind),\n-                            ),\n+                            .report_storage_dead_or_drop_of_borrowed(location, place_span, borrow),\n                         WriteKind::Mutate => {\n                             this.report_illegal_mutation_of_borrowed(location, place_span, borrow)\n                         }"}, {"sha": "21b5bd7cb94dea7be8e2be6e147ad277bd0309ff", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -889,7 +889,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// from a universe it can't name; at present, the only way for\n     /// this to be true is if `scc` outlives `'static`. This is\n     /// actually stricter than necessary: ideally, we'd support bounds\n-    /// like `for<'a: 'b`>` that might then allow us to approximate\n+    /// like `for<'a: 'b>` that might then allow us to approximate\n     /// `'a` with `'b` and not `'static`. But it will have to do for\n     /// now.\n     fn add_incompatible_universe(&mut self, scc: ConstraintSccIndex) {"}, {"sha": "8132800f107a7b385680235bb0622a267e558776", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -235,7 +235,7 @@ pub(crate) struct RegionValues<N: Idx> {\n     free_regions: SparseBitMatrix<N, RegionVid>,\n \n     /// Placeholders represent bound regions -- so something like `'a`\n-    /// in for<'a> fn(&'a u32)`.\n+    /// in `for<'a> fn(&'a u32)`.\n     placeholders: SparseBitMatrix<N, PlaceholderIndex>,\n }\n "}, {"sha": "717020ea5b89428bd196a56c6db01ac5f90af738", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -26,11 +26,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if !self.tcx().is_closure(mir_def_id.to_def_id()) {\n             return;\n         }\n-        let Some(user_provided_poly_sig) =\n-            self.tcx().typeck(mir_def_id).user_provided_sigs.get(&mir_def_id)\n-        else {\n-            return;\n-        };\n+        let user_provided_poly_sig = self.tcx().closure_user_provided_sig(mir_def_id);\n \n         // Instantiate the canonicalized variables from user-provided signature\n         // (e.g., the `_` in the code above) with fresh variables."}, {"sha": "76d0b8754248e2965518e3b133264fd756176c15", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -18,13 +18,11 @@ use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{BodyOwnerKind, HirId};\n+use rustc_hir::BodyOwnerKind;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::{\n-    self, DefIdTree, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt,\n-};\n+use rustc_middle::ty::{self, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_span::Symbol;\n use std::iter;\n@@ -231,9 +229,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n         mir_def: ty::WithOptConstParam<LocalDefId>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n-        let tcx = infcx.tcx;\n-        let mir_hir_id = tcx.hir().local_def_id_to_hir_id(mir_def.did);\n-        UniversalRegionsBuilder { infcx, mir_def, mir_hir_id, param_env }.build()\n+        UniversalRegionsBuilder { infcx, mir_def, param_env }.build()\n     }\n \n     /// Given a reference to a closure type, extracts all the values\n@@ -390,7 +386,6 @@ impl<'tcx> UniversalRegions<'tcx> {\n struct UniversalRegionsBuilder<'cx, 'tcx> {\n     infcx: &'cx BorrowckInferCtxt<'cx, 'tcx>,\n     mir_def: ty::WithOptConstParam<LocalDefId>,\n-    mir_hir_id: HirId,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n@@ -560,12 +555,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         match tcx.hir().body_owner_kind(self.mir_def.did) {\n             BodyOwnerKind::Closure | BodyOwnerKind::Fn => {\n-                let defining_ty = if self.mir_def.did.to_def_id() == typeck_root_def_id {\n-                    tcx.type_of(typeck_root_def_id).subst_identity()\n-                } else {\n-                    let tables = tcx.typeck(self.mir_def.did);\n-                    tables.node_type(self.mir_hir_id)\n-                };\n+                let defining_ty = tcx.type_of(self.mir_def.def_id_for_type_of()).subst_identity();\n \n                 debug!(\"defining_ty (pre-replacement): {:?}\", defining_ty);\n \n@@ -594,7 +584,18 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                         self.infcx.replace_free_regions_with_nll_infer_vars(FR, identity_substs);\n                     DefiningTy::Const(self.mir_def.did.to_def_id(), substs)\n                 } else {\n-                    let ty = tcx.typeck(self.mir_def.did).node_type(self.mir_hir_id);\n+                    // FIXME this line creates a dependency between borrowck and typeck.\n+                    //\n+                    // This is required for `AscribeUserType` canonical query, which will call\n+                    // `type_of(inline_const_def_id)`. That `type_of` would inject erased lifetimes\n+                    // into borrowck, which is ICE #78174.\n+                    //\n+                    // As a workaround, inline consts have an additional generic param (`ty`\n+                    // below), so that `type_of(inline_const_def_id).substs(substs)` uses the\n+                    // proper type with NLL infer vars.\n+                    let ty = tcx\n+                        .typeck(self.mir_def.did)\n+                        .node_type(tcx.local_def_id_to_hir_id(self.mir_def.did));\n                     let substs = InlineConstSubsts::new(\n                         tcx,\n                         InlineConstSubstsParts { parent_substs: identity_substs, ty },"}, {"sha": "f011cb754cb4a7f93ea0d5d9944410d7318f77d0", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -53,7 +53,7 @@ pub fn expand_env<'cx>(\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n     let mut exprs = match get_exprs_from_tts(cx, tts) {\n-        Some(exprs) if exprs.is_empty() => {\n+        Some(exprs) if exprs.is_empty() || exprs.len() > 2 => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::any(sp);\n         }\n@@ -64,28 +64,48 @@ pub fn expand_env<'cx>(\n     let Some((var, _style)) = expr_to_string(cx, exprs.next().unwrap(), \"expected string literal\") else {\n         return DummyResult::any(sp);\n     };\n-    let msg = match exprs.next() {\n-        None => Symbol::intern(&format!(\"environment variable `{}` not defined\", var)),\n+\n+    let custom_msg = match exprs.next() {\n+        None => None,\n         Some(second) => match expr_to_string(cx, second, \"expected string literal\") {\n             None => return DummyResult::any(sp),\n-            Some((s, _style)) => s,\n+            Some((s, _style)) => Some(s),\n         },\n     };\n \n-    if exprs.next().is_some() {\n-        cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n-        return DummyResult::any(sp);\n-    }\n-\n     let sp = cx.with_def_site_ctxt(sp);\n     let value = env::var(var.as_str()).ok().as_deref().map(Symbol::intern);\n     cx.sess.parse_sess.env_depinfo.borrow_mut().insert((var, value));\n     let e = match value {\n         None => {\n-            cx.span_err(sp, msg.as_str());\n+            let (msg, help) = match custom_msg {\n+                None => (\n+                    format!(\"environment variable `{var}` not defined at compile time\"),\n+                    Some(help_for_missing_env_var(var.as_str())),\n+                ),\n+                Some(s) => (s.to_string(), None),\n+            };\n+            let mut diag = cx.struct_span_err(sp, &msg);\n+            if let Some(help) = help {\n+                diag.help(help);\n+            }\n+            diag.emit();\n             return DummyResult::any(sp);\n         }\n         Some(value) => cx.expr_str(sp, value),\n     };\n     MacEager::expr(e)\n }\n+\n+fn help_for_missing_env_var(var: &str) -> String {\n+    if var.starts_with(\"CARGO_\")\n+        || var.starts_with(\"DEP_\")\n+        || matches!(var, \"OUT_DIR\" | \"OPT_LEVEL\" | \"PROFILE\" | \"HOST\" | \"TARGET\")\n+    {\n+        format!(\n+            \"Cargo sets build script variables at run time. Use `std::env::var(\\\"{var}\\\")` instead\"\n+        )\n+    } else {\n+        format!(\"Use `std::env::var(\\\"{var}\\\")` to read the variable at run time\")\n+    }\n+}"}, {"sha": "e74aabf2fcb0d3a643ef277018de8d1b306c5a37", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 32, "deletions": 46, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -21,7 +21,8 @@ mod simd;\n pub(crate) use cpuid::codegen_cpuid_call;\n pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n-use rustc_middle::ty::layout::HasParamEnv;\n+use rustc_middle::ty;\n+use rustc_middle::ty::layout::{HasParamEnv, ValidityRequirement};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -627,54 +628,39 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             intrinsic_args!(fx, args => (); intrinsic);\n \n             let ty = substs.type_at(0);\n-            let layout = fx.layout_of(ty);\n-            if layout.abi.is_uninhabited() {\n-                with_no_trimmed_paths!({\n-                    crate::base::codegen_panic_nounwind(\n-                        fx,\n-                        &format!(\"attempted to instantiate uninhabited type `{}`\", layout.ty),\n-                        source_info,\n-                    )\n-                });\n-                return;\n-            }\n \n-            if intrinsic == sym::assert_zero_valid\n-                && !fx\n-                    .tcx\n-                    .permits_zero_init(fx.param_env().and(ty))\n-                    .expect(\"expected to have layout during codegen\")\n-            {\n-                with_no_trimmed_paths!({\n-                    crate::base::codegen_panic_nounwind(\n-                        fx,\n-                        &format!(\n-                            \"attempted to zero-initialize type `{}`, which is invalid\",\n-                            layout.ty\n-                        ),\n-                        source_info,\n-                    );\n-                });\n-                return;\n-            }\n+            let requirement = ValidityRequirement::from_intrinsic(intrinsic);\n \n-            if intrinsic == sym::assert_mem_uninitialized_valid\n-                && !fx\n+            if let Some(requirement) = requirement {\n+                let do_panic = !fx\n                     .tcx\n-                    .permits_uninit_init(fx.param_env().and(ty))\n-                    .expect(\"expected to have layout during codegen\")\n-            {\n-                with_no_trimmed_paths!({\n-                    crate::base::codegen_panic_nounwind(\n-                        fx,\n-                        &format!(\n-                            \"attempted to leave type `{}` uninitialized, which is invalid\",\n-                            layout.ty\n-                        ),\n-                        source_info,\n-                    )\n-                });\n-                return;\n+                    .check_validity_requirement((requirement, fx.param_env().and(ty)))\n+                    .expect(\"expect to have layout during codegen\");\n+\n+                if do_panic {\n+                    let layout = fx.layout_of(ty);\n+\n+                    with_no_trimmed_paths!({\n+                        crate::base::codegen_panic_nounwind(\n+                            fx,\n+                            &if layout.abi.is_uninhabited() {\n+                                format!(\"attempted to instantiate uninhabited type `{}`\", layout.ty)\n+                            } else if requirement == ValidityRequirement::Zero {\n+                                format!(\n+                                    \"attempted to zero-initialize type `{}`, which is invalid\",\n+                                    layout.ty\n+                                )\n+                            } else {\n+                                format!(\n+                                    \"attempted to leave type `{}` uninitialized, which is invalid\",\n+                                    layout.ty\n+                                )\n+                            },\n+                            source_info,\n+                        )\n+                    });\n+                    return;\n+                }\n             }\n         }\n "}, {"sha": "a7ba2f8b69533d8a7f6048671845ee78f77a8763", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -36,3 +36,5 @@ smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n tempfile = \"3.2.0\"\n+serde = { version = \"1\", features = [ \"derive\" ]}\n+serde_json = \"1\""}, {"sha": "a4ae1b01e869d48428d5af05b75df55bc1647d71", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -761,6 +761,7 @@ pub(crate) unsafe fn codegen(\n             EmitObj::None => {}\n         }\n \n+        record_llvm_cgu_instructions_stats(&cgcx.prof, llmod);\n         drop(handlers);\n     }\n \n@@ -974,3 +975,23 @@ fn record_artifact_size(\n         self_profiler_ref.artifact_size(artifact_kind, artifact_name.to_string_lossy(), file_size);\n     }\n }\n+\n+fn record_llvm_cgu_instructions_stats(prof: &SelfProfilerRef, llmod: &llvm::Module) {\n+    if !prof.enabled() {\n+        return;\n+    }\n+\n+    let raw_stats =\n+        llvm::build_string(|s| unsafe { llvm::LLVMRustModuleInstructionStats(&llmod, s) })\n+            .expect(\"cannot get module instruction stats\");\n+\n+    #[derive(serde::Deserialize)]\n+    struct InstructionsStats {\n+        module: String,\n+        total: u64,\n+    }\n+\n+    let InstructionsStats { module, total } =\n+        serde_json::from_str(&raw_stats).expect(\"cannot parse llvm cgu instructions stats\");\n+    prof.artifact_size(\"cgu_instructions\", module, total);\n+}"}, {"sha": "b0a9a30ab463b71110c1aa1114b975c1c4274721", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -10,6 +10,7 @@ use crate::value::Value;\n use rustc_ast::Mutability;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::DefId;\n use rustc_middle::bug;\n use rustc_middle::mir::interpret::{ConstAllocation, GlobalAlloc, Scalar};\n@@ -252,8 +253,13 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                             Mutability::Mut => self.static_addr_of_mut(init, alloc.align, None),\n                             _ => self.static_addr_of(init, alloc.align, None),\n                         };\n-                        if !self.sess().fewer_names() {\n-                            llvm::set_value_name(value, format!(\"{:?}\", alloc_id).as_bytes());\n+                        if !self.sess().fewer_names() && llvm::get_value_name(value).is_empty() {\n+                            let hash = self.tcx.with_stable_hashing_context(|mut hcx| {\n+                                let mut hasher = StableHasher::new();\n+                                alloc.hash_stable(&mut hcx, &mut hasher);\n+                                hasher.finish::<u128>()\n+                            });\n+                            llvm::set_value_name(value, format!(\"alloc_{hash:032x}\").as_bytes());\n                         }\n                         (value, AddressSpace::DATA)\n                     }"}, {"sha": "6bcd3e5bf58f3030e0f164681fc2780df3c8e7d1", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -5,7 +5,7 @@ use super::CodegenUnitDebugContext;\n \n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::layout::{HasParamEnv, LayoutOf};\n-use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_middle::ty::{self, Ty};\n use trace;\n \n use crate::common::CodegenCx;"}, {"sha": "253c2ca7c768e15a59ad1dd73728506a9c648dd0", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1814,8 +1814,6 @@ extern \"C\" {\n     /// Creates a legacy pass manager -- only used for final codegen.\n     pub fn LLVMCreatePassManager<'a>() -> &'a mut PassManager<'a>;\n \n-    pub fn LLVMInitializePasses();\n-\n     pub fn LLVMTimeTraceProfilerInitialize();\n \n     pub fn LLVMTimeTraceProfilerFinishThread();\n@@ -2410,6 +2408,8 @@ extern \"C\" {\n     pub fn LLVMRustModuleBufferLen(p: &ModuleBuffer) -> usize;\n     pub fn LLVMRustModuleBufferFree(p: &'static mut ModuleBuffer);\n     pub fn LLVMRustModuleCost(M: &Module) -> u64;\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustModuleInstructionStats(M: &Module, Str: &RustString);\n \n     pub fn LLVMRustThinLTOBufferCreate(M: &Module, is_thin: bool) -> &'static mut ThinLTOBuffer;\n     pub fn LLVMRustThinLTOBufferFree(M: &'static mut ThinLTOBuffer);"}, {"sha": "ba58a2e68e91b75b319822783db4b4bef383b832", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -120,8 +120,6 @@ unsafe fn configure_llvm(sess: &Session) {\n         llvm::LLVMTimeTraceProfilerInitialize();\n     }\n \n-    llvm::LLVMInitializePasses();\n-\n     rustc_llvm::initialize_available_targets();\n \n     llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int, llvm_args.as_ptr());"}, {"sha": "4ab56699922f54022d74f054dd5669ba818d79e0", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -306,7 +306,13 @@ pub fn create_compressed_metadata_file(\n     symbol_name: &str,\n ) -> Vec<u8> {\n     let mut compressed = rustc_metadata::METADATA_HEADER.to_vec();\n+    // Our length will be backfilled once we're done writing\n+    compressed.write_all(&[0; 4]).unwrap();\n     FrameEncoder::new(&mut compressed).write_all(metadata.raw_data()).unwrap();\n+    let meta_len = rustc_metadata::METADATA_HEADER.len();\n+    let data_len = (compressed.len() - meta_len - 4) as u32;\n+    compressed[meta_len..meta_len + 4].copy_from_slice(&data_len.to_be_bytes());\n+\n     let Some(mut file) = create_object_file(sess) else {\n         return compressed.to_vec();\n     };"}, {"sha": "fd81b1c6fe1e5184cce5cde6bc9d9d18746bd6c3", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::middle::exported_symbols::{\n use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::Instance;\n-use rustc_middle::ty::{self, DefIdTree, SymbolName, TyCtxt};\n+use rustc_middle::ty::{self, SymbolName, TyCtxt};\n use rustc_session::config::{CrateType, OomStrategy};\n use rustc_target::spec::SanitizerSet;\n "}, {"sha": "c62968e5354206ca88fa97ee61121a524d82ec1b", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::{lang_items, weak_lang_items::WEAK_LANG_ITEMS, LangItem};\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::Linkage;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self as ty, DefIdTree, TyCtxt};\n+use rustc_middle::ty::{self as ty, TyCtxt};\n use rustc_session::{lint, parse::feature_err};\n use rustc_span::{sym, Span};\n use rustc_target::spec::{abi, SanitizerSet};"}, {"sha": "57a19a4ab1eab8250e1c0e05a2d874c308c761a3", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -14,7 +14,7 @@ use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, AssertKind, SwitchTargets};\n-use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n+use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf, ValidityRequirement};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Instance, Ty, TypeVisitableExt};\n use rustc_session::config::OptLevel;\n@@ -655,41 +655,24 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Emit a panic or a no-op for `assert_*` intrinsics.\n         // These are intrinsics that compile to panics so that we can get a message\n         // which mentions the offending type, even from a const context.\n-        #[derive(Debug, PartialEq)]\n-        enum AssertIntrinsic {\n-            Inhabited,\n-            ZeroValid,\n-            MemUninitializedValid,\n-        }\n-        let panic_intrinsic = intrinsic.and_then(|i| match i {\n-            sym::assert_inhabited => Some(AssertIntrinsic::Inhabited),\n-            sym::assert_zero_valid => Some(AssertIntrinsic::ZeroValid),\n-            sym::assert_mem_uninitialized_valid => Some(AssertIntrinsic::MemUninitializedValid),\n-            _ => None,\n-        });\n-        if let Some(intrinsic) = panic_intrinsic {\n-            use AssertIntrinsic::*;\n-\n+        let panic_intrinsic = intrinsic.and_then(|s| ValidityRequirement::from_intrinsic(s));\n+        if let Some(requirement) = panic_intrinsic {\n             let ty = instance.unwrap().substs.type_at(0);\n+\n+            let do_panic = !bx\n+                .tcx()\n+                .check_validity_requirement((requirement, bx.param_env().and(ty)))\n+                .expect(\"expect to have layout during codegen\");\n+\n             let layout = bx.layout_of(ty);\n-            let do_panic = match intrinsic {\n-                Inhabited => layout.abi.is_uninhabited(),\n-                ZeroValid => !bx\n-                    .tcx()\n-                    .permits_zero_init(bx.param_env().and(ty))\n-                    .expect(\"expected to have layout during codegen\"),\n-                MemUninitializedValid => !bx\n-                    .tcx()\n-                    .permits_uninit_init(bx.param_env().and(ty))\n-                    .expect(\"expected to have layout during codegen\"),\n-            };\n+\n             Some(if do_panic {\n                 let msg_str = with_no_visible_paths!({\n                     with_no_trimmed_paths!({\n                         if layout.abi.is_uninhabited() {\n                             // Use this error even for the other intrinsics as it is more precise.\n                             format!(\"attempted to instantiate uninhabited type `{}`\", ty)\n-                        } else if intrinsic == ZeroValid {\n+                        } else if requirement == ValidityRequirement::Zero {\n                             format!(\"attempted to zero-initialize type `{}`, which is invalid\", ty)\n                         } else {\n                             format!("}, {"sha": "4301e4fe69bedd371382f15edae007a6e9541cb3", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{DefIdTree, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n@@ -185,7 +185,7 @@ const X86_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"avx512vpopcntdq\", Some(sym::avx512_target_feature)),\n     (\"bmi1\", None),\n     (\"bmi2\", None),\n-    (\"cmpxchg16b\", Some(sym::cmpxchg16b_target_feature)),\n+    (\"cmpxchg16b\", None),\n     (\"ermsb\", Some(sym::ermsb_target_feature)),\n     (\"f16c\", None),\n     (\"fma\", None),\n@@ -394,7 +394,6 @@ pub fn from_target_feature(\n                 Some(sym::sse4a_target_feature) => rust_features.sse4a_target_feature,\n                 Some(sym::tbm_target_feature) => rust_features.tbm_target_feature,\n                 Some(sym::wasm_target_feature) => rust_features.wasm_target_feature,\n-                Some(sym::cmpxchg16b_target_feature) => rust_features.cmpxchg16b_target_feature,\n                 Some(sym::movbe_target_feature) => rust_features.movbe_target_feature,\n                 Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n                 Some(sym::ermsb_target_feature) => rust_features.ermsb_target_feature,"}, {"sha": "04c90f285516ae2fa41e12105f6c3048e6e9ea79", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -2,7 +2,7 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{DefIdTree, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::Symbol;\n \n /// Whether the `def_id` is an unstable const fn and what feature gate is necessary to enable it"}, {"sha": "a29cdade0234304cca3376a37302e1a492259353", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 29, "deletions": 47, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::{\n     BinOp, NonDivergingIntrinsic,\n };\n use rustc_middle::ty;\n-use rustc_middle::ty::layout::LayoutOf as _;\n+use rustc_middle::ty::layout::{LayoutOf as _, ValidityRequirement};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n@@ -418,54 +418,36 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | sym::assert_zero_valid\n             | sym::assert_mem_uninitialized_valid => {\n                 let ty = instance.substs.type_at(0);\n-                let layout = self.layout_of(ty)?;\n-\n-                // For *all* intrinsics we first check `is_uninhabited` to give a more specific\n-                // error message.\n-                if layout.abi.is_uninhabited() {\n-                    // The run-time intrinsic panics just to get a good backtrace; here we abort\n-                    // since there is no problem showing a backtrace even for aborts.\n-                    M::abort(\n-                        self,\n-                        format!(\n+                let requirement = ValidityRequirement::from_intrinsic(intrinsic_name).unwrap();\n+\n+                let should_panic = !self\n+                    .tcx\n+                    .check_validity_requirement((requirement, self.param_env.and(ty)))\n+                    .map_err(|_| err_inval!(TooGeneric))?;\n+\n+                if should_panic {\n+                    let layout = self.layout_of(ty)?;\n+\n+                    let msg = match requirement {\n+                        // For *all* intrinsics we first check `is_uninhabited` to give a more specific\n+                        // error message.\n+                        _ if layout.abi.is_uninhabited() => format!(\n                             \"aborted execution: attempted to instantiate uninhabited type `{}`\",\n                             ty\n                         ),\n-                    )?;\n-                }\n-\n-                if intrinsic_name == sym::assert_zero_valid {\n-                    let should_panic = !self\n-                        .tcx\n-                        .permits_zero_init(self.param_env.and(ty))\n-                        .map_err(|_| err_inval!(TooGeneric))?;\n-\n-                    if should_panic {\n-                        M::abort(\n-                            self,\n-                            format!(\n-                                \"aborted execution: attempted to zero-initialize type `{}`, which is invalid\",\n-                                ty\n-                            ),\n-                        )?;\n-                    }\n-                }\n+                        ValidityRequirement::Inhabited => bug!(\"handled earlier\"),\n+                        ValidityRequirement::Zero => format!(\n+                            \"aborted execution: attempted to zero-initialize type `{}`, which is invalid\",\n+                            ty\n+                        ),\n+                        ValidityRequirement::UninitMitigated0x01Fill => format!(\n+                            \"aborted execution: attempted to leave type `{}` uninitialized, which is invalid\",\n+                            ty\n+                        ),\n+                        ValidityRequirement::Uninit => bug!(\"assert_uninit_valid doesn't exist\"),\n+                    };\n \n-                if intrinsic_name == sym::assert_mem_uninitialized_valid {\n-                    let should_panic = !self\n-                        .tcx\n-                        .permits_uninit_init(self.param_env.and(ty))\n-                        .map_err(|_| err_inval!(TooGeneric))?;\n-\n-                    if should_panic {\n-                        M::abort(\n-                            self,\n-                            format!(\n-                                \"aborted execution: attempted to leave type `{}` uninitialized, which is invalid\",\n-                                ty\n-                            ),\n-                        )?;\n-                    }\n+                    M::abort(self, msg)?;\n                 }\n             }\n             sym::simd_insert => {\n@@ -476,7 +458,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert_eq!(input_len, dest_len, \"Return vector length must match input length\");\n                 assert!(\n                     index < dest_len,\n-                    \"Index `{}` must be in bounds of vector with length {}`\",\n+                    \"Index `{}` must be in bounds of vector with length {}\",\n                     index,\n                     dest_len\n                 );\n@@ -496,7 +478,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (input, input_len) = self.operand_to_simd(&args[0])?;\n                 assert!(\n                     index < input_len,\n-                    \"index `{}` must be in bounds of vector with length `{}`\",\n+                    \"index `{}` must be in bounds of vector with length {}\",\n                     index,\n                     input_len\n                 );"}, {"sha": "92fa59aec6e5f0fc462beb0babf219d53f5026ee", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -16,8 +16,8 @@ use rustc_target::spec::abi::Abi as CallAbi;\n use crate::const_eval::CheckAlignment;\n \n use super::{\n-    AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n+    AllocBytes, AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx,\n+    InterpResult, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -105,10 +105,16 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Extra data stored in every allocation.\n     type AllocExtra: Debug + Clone + 'static;\n \n+    /// Type for the bytes of the allocation.\n+    type Bytes: AllocBytes + 'static;\n+\n     /// Memory's allocation map\n     type MemoryMap: AllocMap<\n             AllocId,\n-            (MemoryKind<Self::MemoryKind>, Allocation<Self::Provenance, Self::AllocExtra>),\n+            (\n+                MemoryKind<Self::MemoryKind>,\n+                Allocation<Self::Provenance, Self::AllocExtra, Self::Bytes>,\n+            ),\n         > + Default\n         + Clone;\n \n@@ -338,7 +344,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n-    ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra>>>;\n+    ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra, Self::Bytes>>>;\n \n     fn eval_inline_asm(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -459,6 +465,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n \n     type AllocExtra = ();\n     type FrameExtra = ();\n+    type Bytes = Box<[u8]>;\n \n     #[inline(always)]\n     fn use_addr_for_alignment_check(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {"}, {"sha": "a3764a7d142663d454030eac69b3a3eda82768cd", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -21,8 +21,9 @@ use rustc_target::abi::{Align, HasDataLayout, Size};\n use crate::const_eval::CheckAlignment;\n \n use super::{\n-    alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc, InterpCx,\n-    InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance, Scalar,\n+    alloc_range, AllocBytes, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg,\n+    GlobalAlloc, InterpCx, InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance,\n+    Scalar,\n };\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n@@ -114,16 +115,16 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n /// A reference to some allocation that was already bounds-checked for the given region\n /// and had the on-access machine hooks run.\n #[derive(Copy, Clone)]\n-pub struct AllocRef<'a, 'tcx, Prov: Provenance, Extra> {\n-    alloc: &'a Allocation<Prov, Extra>,\n+pub struct AllocRef<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes = Box<[u8]>> {\n+    alloc: &'a Allocation<Prov, Extra, Bytes>,\n     range: AllocRange,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n }\n /// A reference to some allocation that was already bounds-checked for the given region\n /// and had the on-access machine hooks run.\n-pub struct AllocRefMut<'a, 'tcx, Prov: Provenance, Extra> {\n-    alloc: &'a mut Allocation<Prov, Extra>,\n+pub struct AllocRefMut<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes = Box<[u8]>> {\n+    alloc: &'a mut Allocation<Prov, Extra, Bytes>,\n     range: AllocRange,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n@@ -483,7 +484,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         id: AllocId,\n         is_write: bool,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::Provenance, M::AllocExtra, M::Bytes>>> {\n         let (alloc, def_id) = match self.tcx.try_get_global_alloc(id) {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n@@ -526,14 +527,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         )\n     }\n \n+    /// Get the base address for the bytes in an `Allocation` specified by the\n+    /// `AllocID` passed in; error if no such allocation exists.\n+    ///\n+    /// It is up to the caller to take sufficient care when using this address:\n+    /// there could be provenance or uninit memory in there, and other memory\n+    /// accesses could invalidate the exposed pointer.\n+    pub fn alloc_base_addr(&self, id: AllocId) -> InterpResult<'tcx, *const u8> {\n+        let alloc = self.get_alloc_raw(id)?;\n+        Ok(alloc.base_addr())\n+    }\n+\n     /// Gives raw access to the `Allocation`, without bounds or alignment checks.\n     /// The caller is responsible for calling the access hooks!\n     ///\n     /// You almost certainly want to use `get_ptr_alloc`/`get_ptr_alloc_mut` instead.\n     fn get_alloc_raw(\n         &self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, &Allocation<M::Provenance, M::AllocExtra>> {\n+    ) -> InterpResult<'tcx, &Allocation<M::Provenance, M::AllocExtra, M::Bytes>> {\n         // The error type of the inner closure here is somewhat funny. We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n@@ -569,7 +581,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>>\n+    {\n         let ptr_and_alloc = self.check_and_deref_ptr(\n             ptr,\n             size,\n@@ -612,7 +625,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn get_alloc_raw_mut(\n         &mut self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, (&mut Allocation<M::Provenance, M::AllocExtra>, &mut M)> {\n+    ) -> InterpResult<'tcx, (&mut Allocation<M::Provenance, M::AllocExtra, M::Bytes>, &mut M)> {\n         // We have \"NLL problem case #3\" here, which cannot be worked around without loss of\n         // efficiency even for the common case where the key is in the map.\n         // <https://rust-lang.github.io/rfcs/2094-nll.html#problem-case-3-conditional-control-flow-across-functions>\n@@ -641,7 +654,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>>\n+    {\n         let parts = self.get_ptr_access(ptr, size, align)?;\n         if let Some((alloc_id, offset, prov)) = parts {\n             let tcx = *self.tcx;\n@@ -840,11 +854,11 @@ pub struct DumpAllocs<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a, 'mir, 'tcx, M> {\n     fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Cannot be a closure because it is generic in `Prov`, `Extra`.\n-        fn write_allocation_track_relocs<'tcx, Prov: Provenance, Extra>(\n+        fn write_allocation_track_relocs<'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n             fmt: &mut std::fmt::Formatter<'_>,\n             tcx: TyCtxt<'tcx>,\n             allocs_to_print: &mut VecDeque<AllocId>,\n-            alloc: &Allocation<Prov, Extra>,\n+            alloc: &Allocation<Prov, Extra, Bytes>,\n         ) -> std::fmt::Result {\n             for alloc_id in alloc.provenance().provenances().filter_map(|prov| prov.get_alloc_id())\n             {\n@@ -912,7 +926,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n }\n \n /// Reading and writing.\n-impl<'tcx, 'a, Prov: Provenance, Extra> AllocRefMut<'a, 'tcx, Prov, Extra> {\n+impl<'tcx, 'a, Prov: Provenance, Extra, Bytes: AllocBytes>\n+    AllocRefMut<'a, 'tcx, Prov, Extra, Bytes>\n+{\n     /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn write_scalar(&mut self, range: AllocRange, val: Scalar<Prov>) -> InterpResult<'tcx> {\n         let range = self.range.subrange(range);\n@@ -937,7 +953,7 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRefMut<'a, 'tcx, Prov, Extra> {\n     }\n }\n \n-impl<'tcx, 'a, Prov: Provenance, Extra> AllocRef<'a, 'tcx, Prov, Extra> {\n+impl<'tcx, 'a, Prov: Provenance, Extra, Bytes: AllocBytes> AllocRef<'a, 'tcx, Prov, Extra, Bytes> {\n     /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn read_scalar(\n         &self,"}, {"sha": "3c463500a609e1f7c12cd3a9cad823144f8c4c32", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -353,7 +353,8 @@ where\n     pub(super) fn get_place_alloc(\n         &self,\n         place: &MPlaceTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>>\n+    {\n         assert!(place.layout.is_sized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;\n@@ -364,7 +365,8 @@ where\n     pub(super) fn get_place_alloc_mut(\n         &mut self,\n         place: &MPlaceTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>>\n+    {\n         assert!(place.layout.is_sized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;"}, {"sha": "f7881c5096021d6f710afcac1634e41d29284ef6", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -240,10 +240,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // FIXME this should be more descriptive i.e. CapturePlace instead of CapturedVar\n                 // https://github.com/rust-lang/project-rfc-2229/issues/46\n                 if let Some(local_def_id) = def_id.as_local() {\n-                    let tables = self.ecx.tcx.typeck(local_def_id);\n-                    if let Some(captured_place) =\n-                        tables.closure_min_captures_flattened(local_def_id).nth(field)\n-                    {\n+                    let captures = self.ecx.tcx.closure_captures(local_def_id);\n+                    if let Some(captured_place) = captures.get(field) {\n                         // Sometimes the index is beyond the number of upvars (seen\n                         // for a generator).\n                         let var_hir_id = captured_place.get_root_variable();"}, {"sha": "ed9efe568fb303ff268f90f76076bcfec6bc2dfd", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -38,7 +38,6 @@ use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_macros::fluent_messages;\n use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n-use rustc_target::abi::InitKind;\n \n fluent_messages! { \"../locales/en-US.ftl\" }\n \n@@ -62,9 +61,7 @@ pub fn provide(providers: &mut Providers) {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::deref_mir_constant(tcx, param_env, value)\n     };\n-    providers.permits_uninit_init = |tcx, param_env_and_ty| {\n-        util::might_permit_raw_init(tcx, param_env_and_ty, InitKind::UninitMitigated0x01Fill)\n+    providers.check_validity_requirement = |tcx, (init_kind, param_env_and_ty)| {\n+        util::check_validity_requirement(tcx, init_kind, param_env_and_ty)\n     };\n-    providers.permits_zero_init =\n-        |tcx, param_env_and_ty| util::might_permit_raw_init(tcx, param_env_and_ty, InitKind::Zero);\n }"}, {"sha": "aa24d9053b98a78b614f753c02c03b6084924e5d", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -332,7 +332,7 @@ impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n \n     fn check_static(&mut self, def_id: DefId, span: Span) {\n         if self.tcx.is_thread_local_static(def_id) {\n-            self.tcx.sess.delay_span_bug(span, \"tls access is checked in `Rvalue::ThreadLocalRef\");\n+            self.tcx.sess.delay_span_bug(span, \"tls access is checked in `Rvalue::ThreadLocalRef`\");\n         }\n         self.check_op_spanned(ops::StaticAccess, span)\n     }"}, {"sha": "e586720a0d0886de922c5020440762c1de206ed9", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -12,9 +12,7 @@ use rustc_infer::traits::{ImplSource, Obligation, ObligationCause};\n use rustc_middle::mir;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc_middle::ty::{\n-    suggest_constraining_type_param, Adt, Closure, DefIdTree, FnDef, FnPtr, Param, Ty,\n-};\n+use rustc_middle::ty::{suggest_constraining_type_param, Adt, Closure, FnDef, FnPtr, Param, Ty};\n use rustc_middle::ty::{Binder, TraitRef};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;"}, {"sha": "fb37eb79a335fa3304452fd5a944aaaf1b1e6e09", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -755,8 +755,26 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.fail(location, format!(\"explicit `{:?}` is forbidden\", kind));\n                 }\n             }\n-            StatementKind::StorageLive(..)\n-            | StatementKind::StorageDead(..)\n+            StatementKind::StorageLive(local) => {\n+                // We check that the local is not live when entering a `StorageLive` for it.\n+                // Technically, violating this restriction is only UB and not actually indicative\n+                // of not well-formed MIR. This means that an optimization which turns MIR that\n+                // already has UB into MIR that fails this check is not necessarily wrong. However,\n+                // we have no such optimizations at the moment, and so we include this check anyway\n+                // to help us catch bugs. If you happen to write an optimization that might cause\n+                // this to incorrectly fire, feel free to remove this check.\n+                if self.reachable_blocks.contains(location.block) {\n+                    self.storage_liveness.seek_before_primary_effect(location);\n+                    let locals_with_storage = self.storage_liveness.get();\n+                    if locals_with_storage.contains(*local) {\n+                        self.fail(\n+                            location,\n+                            format!(\"StorageLive({local:?}) which already has storage here\"),\n+                        );\n+                    }\n+                }\n+            }\n+            StatementKind::StorageDead(_)\n             | StatementKind::Coverage(_)\n             | StatementKind::ConstEvalCounter\n             | StatementKind::Nop => {}"}, {"sha": "23fcd22c52b8e02b0868a0a33d9b8a4bfa0f5efe", "filename": "compiler/rustc_const_eval/src/util/check_validity_requirement.rs", "status": "renamed", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcheck_validity_requirement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcheck_validity_requirement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcheck_validity_requirement.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,7 +1,7 @@\n-use rustc_middle::ty::layout::{LayoutCx, LayoutError, LayoutOf, TyAndLayout};\n+use rustc_middle::ty::layout::{LayoutCx, LayoutError, LayoutOf, TyAndLayout, ValidityRequirement};\n use rustc_middle::ty::{ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n use rustc_session::Limit;\n-use rustc_target::abi::{Abi, FieldsShape, InitKind, Scalar, Variants};\n+use rustc_target::abi::{Abi, FieldsShape, Scalar, Variants};\n \n use crate::const_eval::{CheckAlignment, CompileTimeInterpreter};\n use crate::interpret::{InterpCx, MemoryKind, OpTy};\n@@ -18,16 +18,23 @@ use crate::interpret::{InterpCx, MemoryKind, OpTy};\n /// Rust UB as long as there is no risk of miscompilations. The `strict_init_checks` can be set to\n /// do a full check against Rust UB instead (in which case we will also ignore the 0x01-filling and\n /// to the full uninit check).\n-pub fn might_permit_raw_init<'tcx>(\n+pub fn check_validity_requirement<'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    kind: ValidityRequirement,\n     param_env_and_ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    kind: InitKind,\n ) -> Result<bool, LayoutError<'tcx>> {\n-    if tcx.sess.opts.unstable_opts.strict_init_checks {\n-        might_permit_raw_init_strict(tcx.layout_of(param_env_and_ty)?, tcx, kind)\n+    let layout = tcx.layout_of(param_env_and_ty)?;\n+\n+    // There is nothing strict or lax about inhabitedness.\n+    if kind == ValidityRequirement::Inhabited {\n+        return Ok(!layout.abi.is_uninhabited());\n+    }\n+\n+    if kind == ValidityRequirement::Uninit || tcx.sess.opts.unstable_opts.strict_init_checks {\n+        might_permit_raw_init_strict(layout, tcx, kind)\n     } else {\n         let layout_cx = LayoutCx { tcx, param_env: param_env_and_ty.param_env };\n-        might_permit_raw_init_lax(tcx.layout_of(param_env_and_ty)?, &layout_cx, kind)\n+        might_permit_raw_init_lax(layout, &layout_cx, kind)\n     }\n }\n \n@@ -36,7 +43,7 @@ pub fn might_permit_raw_init<'tcx>(\n fn might_permit_raw_init_strict<'tcx>(\n     ty: TyAndLayout<'tcx>,\n     tcx: TyCtxt<'tcx>,\n-    kind: InitKind,\n+    kind: ValidityRequirement,\n ) -> Result<bool, LayoutError<'tcx>> {\n     let machine = CompileTimeInterpreter::new(\n         Limit::new(0),\n@@ -50,7 +57,7 @@ fn might_permit_raw_init_strict<'tcx>(\n         .allocate(ty, MemoryKind::Machine(crate::const_eval::MemoryKind::Heap))\n         .expect(\"OOM: failed to allocate for uninit check\");\n \n-    if kind == InitKind::Zero {\n+    if kind == ValidityRequirement::Zero {\n         cx.write_bytes_ptr(\n             allocated.ptr,\n             std::iter::repeat(0_u8).take(ty.layout.size().bytes_usize()),\n@@ -72,15 +79,18 @@ fn might_permit_raw_init_strict<'tcx>(\n fn might_permit_raw_init_lax<'tcx>(\n     this: TyAndLayout<'tcx>,\n     cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n-    init_kind: InitKind,\n+    init_kind: ValidityRequirement,\n ) -> Result<bool, LayoutError<'tcx>> {\n     let scalar_allows_raw_init = move |s: Scalar| -> bool {\n         match init_kind {\n-            InitKind::Zero => {\n+            ValidityRequirement::Inhabited => {\n+                bug!(\"ValidityRequirement::Inhabited should have been handled above\")\n+            }\n+            ValidityRequirement::Zero => {\n                 // The range must contain 0.\n                 s.valid_range(cx).contains(0)\n             }\n-            InitKind::UninitMitigated0x01Fill => {\n+            ValidityRequirement::UninitMitigated0x01Fill => {\n                 // The range must include an 0x01-filled buffer.\n                 let mut val: u128 = 0x01;\n                 for _ in 1..s.size(cx).bytes() {\n@@ -89,6 +99,9 @@ fn might_permit_raw_init_lax<'tcx>(\n                 }\n                 s.valid_range(cx).contains(val)\n             }\n+            ValidityRequirement::Uninit => {\n+                bug!(\"ValidityRequirement::Uninit should have been handled above\")\n+            }\n         }\n     };\n ", "previous_filename": "compiler/rustc_const_eval/src/util/might_permit_raw_init.rs"}, {"sha": "c0aabd77ceeadb3153cc8750b2ca556ff93c1f37", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,14 +1,14 @@\n mod alignment;\n mod call_kind;\n+mod check_validity_requirement;\n pub mod collect_writes;\n mod compare_types;\n mod find_self_call;\n-mod might_permit_raw_init;\n mod type_name;\n \n pub use self::alignment::is_disaligned;\n pub use self::call_kind::{call_kind, CallDesugaringKind, CallKind};\n+pub use self::check_validity_requirement::check_validity_requirement;\n pub use self::compare_types::{is_equal_up_to_subtyping, is_subtype};\n pub use self::find_self_call::find_self_call;\n-pub use self::might_permit_raw_init::might_permit_raw_init;\n pub use self::type_name::type_name;"}, {"sha": "29cb2c0a33e6c40402040acdf33719c6c1889a58", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -9,7 +9,7 @@ edition = \"2021\"\n arrayvec = { version = \"0.7\", default-features = false }\n bitflags = \"1.2.1\"\n cfg-if = \"1.0\"\n-ena = \"0.14\"\n+ena = \"0.14.1\"\n indexmap = { version = \"1.9.1\" }\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }\n libc = \"0.2\""}, {"sha": "91abdaadabdbd4453fc38881ab96ebc0d0805394", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -426,6 +426,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             // nodes. Therefore we use a `while` loop.\n             let mut index = 0;\n             while let Some(node) = self.nodes.get_mut(index) {\n+                // This test is extremely hot.\n                 if node.state.get() != NodeState::Pending\n                     || !processor.needs_process_obligation(&node.obligation)\n                 {\n@@ -439,6 +440,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 // out of sync with `nodes`. It's not very common, but it does\n                 // happen, and code in `compress` has to allow for it.\n \n+                // This code is much less hot.\n                 match processor.process_obligation(&mut node.obligation) {\n                     ProcessResult::Unchanged => {\n                         // No change in state."}, {"sha": "7d23ff5194870cf547ae97ef3eb952e332a7bbb0", "filename": "compiler/rustc_data_structures/src/sorted_map/index_map.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -100,6 +100,11 @@ impl<I: Idx, K: Ord, V> SortedIndexMultiMap<I, K, V> {\n             (k == &key).then_some((i, v))\n         })\n     }\n+\n+    #[inline]\n+    pub fn contains_key(&self, key: K) -> bool {\n+        self.get_by_key(key).next().is_some()\n+    }\n }\n \n impl<I: Idx, K: Eq, V: Eq> Eq for SortedIndexMultiMap<I, K, V> {}"}, {"sha": "def7a7112fb3f2acf6f34d74cf58dd2649970338", "filename": "compiler/rustc_data_structures/src/sorted_map/tests.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -17,6 +17,10 @@ fn test_sorted_index_multi_map() {\n     assert_eq!(set.get_by_key(3).copied().collect::<Vec<_>>(), vec![0]);\n     assert!(set.get_by_key(4).next().is_none());\n \n+    // `contains_key` works\n+    assert!(set.contains_key(3));\n+    assert!(!set.contains_key(4));\n+\n     // `get_by_key` returns items in insertion order.\n     let twos: Vec<_> = set.get_by_key_enumerated(2).collect();\n     let idxs: Vec<usize> = twos.iter().map(|(i, _)| *i).collect();"}, {"sha": "724be5888ddb46da7e35744835fc60aeb15e331f", "filename": "compiler/rustc_data_structures/src/stable_hasher/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -150,7 +150,7 @@ fn test_isize_compression() {\n         let hash_b = hash(&(b as isize, a as isize));\n         assert_ne!(\n             hash_a, hash_b,\n-            \"The hash stayed the same when permuting values `{a}` and `{b}!\",\n+            \"The hash stayed the same when permuting values `{a}` and `{b}`!\",\n         );\n     }\n "}, {"sha": "1b2e7b7e083b4f7275a22fbaaca320608ef4f648", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1895,7 +1895,7 @@ impl EmitterWriter {\n                         self.draw_code_line(\n                             &mut buffer,\n                             &mut row_num,\n-                            &Vec::new(),\n+                            &[],\n                             p + line_start,\n                             l,\n                             show_code_change,\n@@ -1919,7 +1919,7 @@ impl EmitterWriter {\n                             self.draw_code_line(\n                                 &mut buffer,\n                                 &mut row_num,\n-                                &Vec::new(),\n+                                &[],\n                                 p + line_start,\n                                 l,\n                                 show_code_change,\n@@ -1936,7 +1936,7 @@ impl EmitterWriter {\n                             self.draw_code_line(\n                                 &mut buffer,\n                                 &mut row_num,\n-                                &Vec::new(),\n+                                &[],\n                                 p + line_start,\n                                 l,\n                                 show_code_change,\n@@ -1951,7 +1951,7 @@ impl EmitterWriter {\n                 self.draw_code_line(\n                     &mut buffer,\n                     &mut row_num,\n-                    highlight_parts,\n+                    &highlight_parts,\n                     line_pos + line_start,\n                     line,\n                     show_code_change,\n@@ -2176,7 +2176,7 @@ impl EmitterWriter {\n         &self,\n         buffer: &mut StyledBuffer,\n         row_num: &mut usize,\n-        highlight_parts: &Vec<SubstitutionHighlight>,\n+        highlight_parts: &[SubstitutionHighlight],\n         line_num: usize,\n         line_to_add: &str,\n         show_code_change: DisplaySuggestion,"}, {"sha": "99af872f07f305d8e32752795f999239d41e4946", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -331,7 +331,7 @@ impl CodeSuggestion {\n                     });\n                     buf.push_str(&part.snippet);\n                     let cur_hi = sm.lookup_char_pos(part.span.hi());\n-                    if prev_hi.line == cur_lo.line && cur_hi.line == cur_lo.line {\n+                    if cur_hi.line == cur_lo.line {\n                         // Account for the difference between the width of the current code and the\n                         // snippet being suggested, so that the *later* suggestions are correctly\n                         // aligned on the screen."}, {"sha": "cfae781bdee5fea39d1b0b6f3c648b16e0b60a47", "filename": "compiler/rustc_expand/locales/en-US.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_expand%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_expand%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Flocales%2Fen-US.ftl?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -133,3 +133,6 @@ expand_trace_macro = trace_macro\n expand_proc_macro_panicked =\n     proc macro panicked\n     .help = message: {$message}\n+\n+expand_proc_macro_derive_tokens =\n+    proc-macro derive produced unparseable tokens"}, {"sha": "e5102a952e741db5d6deec231c1eb3532ad2f0cd", "filename": "compiler/rustc_expand/src/errors.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -390,3 +390,10 @@ pub(crate) struct ProcMacroPanicked {\n pub(crate) struct ProcMacroPanickedHelp {\n     pub message: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_proc_macro_derive_tokens)]\n+pub struct ProcMacroDeriveTokens {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "47a8b4bc48885515c701122f62ee6622b0113373", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -282,7 +282,7 @@ pub(super) fn transcribe<'a>(\n             }\n \n             // There should be no meta-var declarations in the invocation of a macro.\n-            mbe::TokenTree::MetaVarDecl(..) => panic!(\"unexpected `TokenTree::MetaVarDecl\"),\n+            mbe::TokenTree::MetaVarDecl(..) => panic!(\"unexpected `TokenTree::MetaVarDecl`\"),\n         }\n     }\n }"}, {"sha": "ddba14417195be0e349abf6f7094463ff20d560f", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -176,7 +176,7 @@ impl MultiItemModifier for DeriveProcMacro {\n \n         // fail if there have been errors emitted\n         if ecx.sess.parse_sess.span_diagnostic.err_count() > error_count_before {\n-            ecx.struct_span_err(span, \"proc-macro derive produced unparseable tokens\").emit();\n+            ecx.sess.emit_err(errors::ProcMacroDeriveTokens { span });\n         }\n \n         ExpandResult::Ready(items)"}, {"sha": "480d95b77e901f540c12fd1a560fdf1f342b8fe1", "filename": "compiler/rustc_expand/src/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftests.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -43,7 +43,6 @@ pub(crate) fn string_to_stream(source_str: String) -> TokenStream {\n         ps.source_map().new_source_file(PathBuf::from(\"bogofile\").into(), source_str),\n         None,\n     )\n-    .0\n }\n \n /// Parses a string, returns a crate."}, {"sha": "e7b2df34ccca2bd27698e21e12ac719ea7d22d42", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -90,6 +90,8 @@ declare_features! (\n     (accepted, clone_closures, \"1.26.0\", Some(44490), None),\n     /// Allows coercing non capturing closures to function pointers.\n     (accepted, closure_to_fn_coercion, \"1.19.0\", Some(39817), None),\n+    /// Allows using `cmpxchg16b` from `core::arch::x86_64`.\n+    (accepted, cmpxchg16b_target_feature, \"CURRENT_RUSTC_VERSION\", Some(44839), None),\n     /// Allows usage of the `compile_error!` macro.\n     (accepted, compile_error, \"1.20.0\", Some(40872), None),\n     /// Allows `impl Trait` in function return types."}, {"sha": "a01914f969eb725343b00a35d08f0a3105c3dcd7", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -256,7 +256,6 @@ declare_features! (\n     (active, arm_target_feature, \"1.27.0\", Some(44839), None),\n     (active, avx512_target_feature, \"1.27.0\", Some(44839), None),\n     (active, bpf_target_feature, \"1.54.0\", Some(44839), None),\n-    (active, cmpxchg16b_target_feature, \"1.32.0\", Some(44839), None),\n     (active, ermsb_target_feature, \"1.49.0\", Some(44839), None),\n     (active, hexagon_target_feature, \"1.27.0\", Some(44839), None),\n     (active, mips_target_feature, \"1.27.0\", Some(44839), None),\n@@ -317,8 +316,6 @@ declare_features! (\n     (active, c_unwind, \"1.52.0\", Some(74990), None),\n     /// Allows using C-variadics.\n     (active, c_variadic, \"1.34.0\", Some(44930), None),\n-    /// Allows capturing disjoint fields in a closure/generator (RFC 2229).\n-    (incomplete, capture_disjoint_fields, \"1.49.0\", Some(53488), None),\n     /// Allows the use of `#[cfg(sanitize = \"option\")]`; set when -Zsanitizer is used.\n     (active, cfg_sanitize, \"1.41.0\", Some(39699), None),\n     /// Allows `cfg(target_abi = \"...\")`."}, {"sha": "04d4f6cb14e4ceb6ea6c06e2357d13a7520d0ef4", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -52,6 +52,8 @@ declare_features! (\n     (removed, allow_fail, \"1.19.0\", Some(46488), None, Some(\"removed due to no clear use cases\")),\n     (removed, await_macro, \"1.38.0\", Some(50547), None,\n      Some(\"subsumed by `.await` syntax\")),\n+    /// Allows capturing disjoint fields in a closure/generator (RFC 2229).\n+    (removed, capture_disjoint_fields, \"1.49.0\", Some(53488), None, Some(\"stabilized in Rust 2021\")),\n     /// Allows comparing raw pointers during const eval.\n     (removed, const_compare_raw_pointers, \"1.46.0\", Some(53020), None,\n      Some(\"cannot be allowed in const eval in any meaningful way\")),"}, {"sha": "19d3d41c9841c2a52ad26f798e286bdc25f6f73d", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -498,6 +498,7 @@ pub struct GenericParam<'hir> {\n     pub pure_wrt_drop: bool,\n     pub kind: GenericParamKind<'hir>,\n     pub colon_span: Option<Span>,\n+    pub source: GenericParamSource,\n }\n \n impl<'hir> GenericParam<'hir> {\n@@ -516,6 +517,20 @@ impl<'hir> GenericParam<'hir> {\n     }\n }\n \n+/// Records where the generic parameter originated from.\n+///\n+/// This can either be from an item's generics, in which case it's typically\n+/// early-bound (but can be a late-bound lifetime in functions, for example),\n+/// or from a `for<...>` binder, in which case it's late-bound (and notably,\n+/// does not show up in the parent item's generics).\n+#[derive(Debug, HashStable_Generic, PartialEq, Eq, Copy, Clone)]\n+pub enum GenericParamSource {\n+    // Early or late-bound parameters defined on an item\n+    Generics,\n+    // Late-bound parameters defined via a `for<...>`\n+    Binder,\n+}\n+\n #[derive(Default)]\n pub struct GenericParamCount {\n     pub lifetimes: usize,"}, {"sha": "1d313945b529cc0d12fc1b038ab387dd38d62ccb", "filename": "compiler/rustc_hir_analysis/locales/en-US.ftl", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -62,14 +62,6 @@ hir_analysis_manual_implementation =\n \n hir_analysis_substs_on_overridden_impl = could not resolve substs on overridden impl\n \n-hir_analysis_unused_extern_crate =\n-    unused extern crate\n-    .suggestion = remove it\n-\n-hir_analysis_extern_crate_not_idiomatic =\n-    `extern crate` is not idiomatic in the new edition\n-    .suggestion = convert it to a `{$msg_code}`\n-\n hir_analysis_trait_object_declared_with_no_traits =\n     at least one trait is required for an object type\n     .alias_span = this alias does not contain a trait\n@@ -155,3 +147,11 @@ hir_analysis_main_function_generic_parameters = `main` function is not allowed t\n \n hir_analysis_variadic_function_compatible_convention = C-variadic function must have a compatible calling convention, like {$conventions}\n     .label = C-variadic function must have a compatible calling convention\n+\n+hir_analysis_cannot_capture_late_bound_ty_in_anon_const =\n+    cannot capture late-bound type parameter in a constant\n+    .label = parameter defined here\n+\n+hir_analysis_cannot_capture_late_bound_const_in_anon_const =\n+    cannot capture late-bound const parameter in a constant\n+    .label = parameter defined here"}, {"sha": "899029d98e0c472d3498688b61935eac940a3968", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -35,7 +35,7 @@ use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::DynKind;\n use rustc_middle::ty::GenericParamDefKind;\n-use rustc_middle::ty::{self, Const, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_middle::ty::{self, Const, IsSuggestable, Ty, TyCtxt, TypeVisitableExt};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECTS};\n use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n@@ -50,6 +50,7 @@ use rustc_trait_selection::traits::{self, astconv_object_safety_violations, Obli\n \n use smallvec::{smallvec, SmallVec};\n use std::collections::BTreeSet;\n+use std::fmt::Display;\n use std::slice;\n \n #[derive(Debug)]\n@@ -1095,11 +1096,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // those that do.\n                 self.one_bound_for_assoc_type(\n                     || traits::supertraits(tcx, trait_ref),\n-                    || trait_ref.print_only_trait_path().to_string(),\n+                    trait_ref.print_only_trait_path(),\n                     binding.item_name,\n                     path_span,\n-                    || match binding.kind {\n-                        ConvertedBindingKind::Equality(ty) => Some(ty.to_string()),\n+                    match binding.kind {\n+                        ConvertedBindingKind::Equality(term) => Some(term),\n                         _ => None,\n                     },\n                 )?\n@@ -1789,10 +1790,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     assoc_name,\n                 )\n             },\n-            || param_name.to_string(),\n+            param_name,\n             assoc_name,\n             span,\n-            || None,\n+            None,\n         )\n     }\n \n@@ -1802,10 +1803,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn one_bound_for_assoc_type<I>(\n         &self,\n         all_candidates: impl Fn() -> I,\n-        ty_param_name: impl Fn() -> String,\n+        ty_param_name: impl Display,\n         assoc_name: Ident,\n         span: Span,\n-        is_equality: impl Fn() -> Option<String>,\n+        is_equality: Option<ty::Term<'tcx>>,\n     ) -> Result<ty::PolyTraitRef<'tcx>, ErrorGuaranteed>\n     where\n         I: Iterator<Item = ty::PolyTraitRef<'tcx>>,\n@@ -1821,7 +1822,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             (None, None) => {\n                 let reported = self.complain_about_assoc_type_not_found(\n                     all_candidates,\n-                    &ty_param_name(),\n+                    &ty_param_name.to_string(),\n                     assoc_name,\n                     span,\n                 );\n@@ -1833,7 +1834,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if let Some(bound2) = next_cand {\n             debug!(?bound2);\n \n-            let is_equality = is_equality();\n             let bounds = IntoIterator::into_iter([bound, bound2]).chain(matching_candidates);\n             let mut err = if is_equality.is_some() {\n                 // More specific Error Index entry.\n@@ -1843,7 +1843,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     E0222,\n                     \"ambiguous associated type `{}` in bounds of `{}`\",\n                     assoc_name,\n-                    ty_param_name()\n+                    ty_param_name\n                 )\n             } else {\n                 struct_span_err!(\n@@ -1852,7 +1852,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     E0221,\n                     \"ambiguous associated type `{}` in bounds of `{}`\",\n                     assoc_name,\n-                    ty_param_name()\n+                    ty_param_name\n                 )\n             };\n             err.span_label(span, format!(\"ambiguous associated type `{}`\", assoc_name));\n@@ -1886,18 +1886,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         err.span_suggestion_verbose(\n                             span.with_hi(assoc_name.span.lo()),\n                             \"use fully qualified syntax to disambiguate\",\n-                            format!(\n-                                \"<{} as {}>::\",\n-                                ty_param_name(),\n-                                bound.print_only_trait_path(),\n-                            ),\n+                            format!(\"<{} as {}>::\", ty_param_name, bound.print_only_trait_path()),\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n                 } else {\n                     err.note(&format!(\n                         \"associated type `{}` could derive from `{}`\",\n-                        ty_param_name(),\n+                        ty_param_name,\n                         bound.print_only_trait_path(),\n                     ));\n                 }\n@@ -1906,7 +1902,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 err.help(&format!(\n                     \"consider introducing a new type parameter `T` and adding `where` constraints:\\\n                      \\n    where\\n        T: {},\\n{}\",\n-                    ty_param_name(),\n+                    ty_param_name,\n                     where_bounds.join(\",\\n\"),\n                 ));\n             }\n@@ -2070,10 +2066,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                 self.one_bound_for_assoc_type(\n                     || traits::supertraits(tcx, ty::Binder::dummy(trait_ref.subst_identity())),\n-                    || \"Self\".to_string(),\n+                    kw::SelfUpper,\n                     assoc_ident,\n                     span,\n-                    || None,\n+                    None,\n                 )?\n             }\n             (\n@@ -2403,8 +2399,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 infcx\n                                     .can_eq(\n                                         ty::ParamEnv::empty(),\n-                                        tcx.erase_regions(impl_.self_ty()),\n-                                        tcx.erase_regions(qself_ty),\n+                                        impl_.self_ty(),\n+                                        // Must fold past escaping bound vars too,\n+                                        // since we have those at this point in astconv.\n+                                        tcx.fold_regions(qself_ty, |_, _| tcx.lifetimes.re_erased),\n                                     )\n                             })\n                             && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative"}, {"sha": "9693a59defbb014da5eb7ee75c92231620692bdd", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -22,8 +22,7 @@ use rustc_middle::ty::layout::{LayoutError, MAX_SIMD_LANES};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n use rustc_middle::ty::{\n-    self, AdtDef, DefIdTree, ParamEnv, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable,\n-    TypeVisitableExt,\n+    self, AdtDef, ParamEnv, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n };\n use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVENTIONS};\n use rustc_span::symbol::sym;\n@@ -792,17 +791,19 @@ fn check_impl_items_against_trait<'tcx>(\n             trait_def.must_implement_one_of.as_deref();\n \n         for &trait_item_id in tcx.associated_item_def_ids(impl_trait_ref.def_id) {\n-            let is_implemented = ancestors\n-                .leaf_def(tcx, trait_item_id)\n+            let leaf_def = ancestors.leaf_def(tcx, trait_item_id);\n+\n+            let is_implemented = leaf_def\n+                .as_ref()\n                 .map_or(false, |node_item| node_item.item.defaultness(tcx).has_value());\n \n             if !is_implemented && tcx.impl_defaultness(impl_id).is_final() {\n                 missing_items.push(tcx.associated_item(trait_item_id));\n             }\n \n             // true if this item is specifically implemented in this impl\n-            let is_implemented_here = ancestors\n-                .leaf_def(tcx, trait_item_id)\n+            let is_implemented_here = leaf_def\n+                .as_ref()\n                 .map_or(false, |node_item| !node_item.defining_node.is_from_trait());\n \n             if !is_implemented_here {\n@@ -831,6 +832,36 @@ fn check_impl_items_against_trait<'tcx>(\n                     }\n                 }\n             }\n+\n+            if let Some(leaf_def) = &leaf_def\n+                && !leaf_def.is_final()\n+                && let def_id = leaf_def.item.def_id\n+                && tcx.impl_method_has_trait_impl_trait_tys(def_id)\n+            {\n+                let def_kind = tcx.def_kind(def_id);\n+                let descr = tcx.def_kind_descr(def_kind, def_id);\n+                let (msg, feature) = if tcx.asyncness(def_id).is_async() {\n+                    (\n+                        format!(\"async {descr} in trait cannot be specialized\"),\n+                        sym::async_fn_in_trait,\n+                    )\n+                } else {\n+                    (\n+                        format!(\n+                            \"{descr} with return-position `impl Trait` in trait cannot be specialized\"\n+                        ),\n+                        sym::return_position_impl_trait_in_trait,\n+                    )\n+                };\n+                tcx.sess\n+                    .struct_span_err(tcx.def_span(def_id), msg)\n+                    .note(format!(\n+                        \"specialization behaves in inconsistent and \\\n+                        surprising ways with `#![feature({feature})]`, \\\n+                        and for now is disallowed\"\n+                    ))\n+                    .emit();\n+            }\n         }\n \n         if !missing_items.is_empty() {"}, {"sha": "5adc7a8732373686ab70ba42590cdeb523db8478", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -16,8 +16,7 @@ use rustc_infer::traits::util;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::util::ExplicitSelf;\n use rustc_middle::ty::{\n-    self, DefIdTree, InternalSubsts, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable,\n-    TypeVisitableExt,\n+    self, InternalSubsts, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitableExt,\n };\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n@@ -648,6 +647,13 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n             tcx.fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs),\n         )\n         .fold_with(&mut collector);\n+\n+    debug_assert_ne!(\n+        collector.types.len(),\n+        0,\n+        \"expect >1 RPITITs in call to `collect_return_position_impl_trait_in_trait_tys`\"\n+    );\n+\n     let trait_sig = ocx.normalize(&norm_cause, param_env, unnormalized_trait_sig);\n     trait_sig.error_reported()?;\n     let trait_return_ty = trait_sig.output();\n@@ -1866,7 +1872,7 @@ pub(super) fn check_type_bounds<'tcx>(\n     //     type Bar<C> =...\n     // }\n     //\n-    // - `impl_trait_ref` would be `<(A, B) as Foo<u32>>\n+    // - `impl_trait_ref` would be `<(A, B) as Foo<u32>>`\n     // - `impl_ty_substs` would be `[A, B, ^0.0]` (`^0.0` here is the bound var with db 0 and index 0)\n     // - `rebased_substs` would be `[(A, B), u32, ^0.0]`, combining the substs from\n     //    the *trait* with the generic associated type parameters (as bound vars)."}, {"sha": "f3f5851d8f92cab6977cc1029695d11c4db5a091", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 132, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,12 +1,8 @@\n-use crate::errors::{ExternCrateNotIdiomatic, UnusedExternCrate};\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unord::UnordSet;\n-use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint;\n-use rustc_span::{Span, Symbol};\n \n pub fn check_crate(tcx: TyCtxt<'_>) {\n     let mut used_trait_imports: UnordSet<LocalDefId> = Default::default();\n@@ -43,131 +39,4 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n             |lint| lint,\n         );\n     }\n-\n-    unused_crates_lint(tcx);\n-}\n-\n-fn unused_crates_lint(tcx: TyCtxt<'_>) {\n-    let lint = lint::builtin::UNUSED_EXTERN_CRATES;\n-\n-    // Collect first the crates that are completely unused. These we\n-    // can always suggest removing (no matter which edition we are\n-    // in).\n-    let unused_extern_crates: FxHashMap<LocalDefId, Span> = tcx\n-        .maybe_unused_extern_crates(())\n-        .iter()\n-        .filter(|&&(def_id, _)| {\n-            tcx.extern_mod_stmt_cnum(def_id).map_or(true, |cnum| {\n-                !tcx.is_compiler_builtins(cnum)\n-                    && !tcx.is_panic_runtime(cnum)\n-                    && !tcx.has_global_allocator(cnum)\n-                    && !tcx.has_panic_handler(cnum)\n-            })\n-        })\n-        .cloned()\n-        .collect();\n-\n-    // Collect all the extern crates (in a reliable order).\n-    let mut crates_to_lint = vec![];\n-\n-    for id in tcx.hir().items() {\n-        if matches!(tcx.def_kind(id.owner_id), DefKind::ExternCrate) {\n-            let item = tcx.hir().item(id);\n-            if let hir::ItemKind::ExternCrate(orig_name) = item.kind {\n-                crates_to_lint.push(ExternCrateToLint {\n-                    def_id: item.owner_id.to_def_id(),\n-                    span: item.span,\n-                    orig_name,\n-                    warn_if_unused: !item.ident.as_str().starts_with('_'),\n-                });\n-            }\n-        }\n-    }\n-\n-    let extern_prelude = &tcx.resolutions(()).extern_prelude;\n-\n-    for extern_crate in &crates_to_lint {\n-        let def_id = extern_crate.def_id.expect_local();\n-        let item = tcx.hir().expect_item(def_id);\n-\n-        // If the crate is fully unused, we suggest removing it altogether.\n-        // We do this in any edition.\n-        if extern_crate.warn_if_unused {\n-            if let Some(&span) = unused_extern_crates.get(&def_id) {\n-                // Removal suggestion span needs to include attributes (Issue #54400)\n-                let id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                let span_with_attrs = tcx\n-                    .hir()\n-                    .attrs(id)\n-                    .iter()\n-                    .map(|attr| attr.span)\n-                    .fold(span, |acc, attr_span| acc.to(attr_span));\n-\n-                tcx.emit_spanned_lint(lint, id, span, UnusedExternCrate { span: span_with_attrs });\n-                continue;\n-            }\n-        }\n-\n-        // If we are not in Rust 2018 edition, then we don't make any further\n-        // suggestions.\n-        if !tcx.sess.rust_2018() {\n-            continue;\n-        }\n-\n-        // If the extern crate isn't in the extern prelude,\n-        // there is no way it can be written as a `use`.\n-        let orig_name = extern_crate.orig_name.unwrap_or(item.ident.name);\n-        if !extern_prelude.get(&orig_name).map_or(false, |from_item| !from_item) {\n-            continue;\n-        }\n-\n-        // If the extern crate is renamed, then we cannot suggest replacing it with a use as this\n-        // would not insert the new name into the prelude, where other imports in the crate may be\n-        // expecting it.\n-        if extern_crate.orig_name.is_some() {\n-            continue;\n-        }\n-\n-        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        // If the extern crate has any attributes, they may have funky\n-        // semantics we can't faithfully represent using `use` (most\n-        // notably `#[macro_use]`). Ignore it.\n-        if !tcx.hir().attrs(id).is_empty() {\n-            continue;\n-        }\n-\n-        let base_replacement = match extern_crate.orig_name {\n-            Some(orig_name) => format!(\"use {} as {};\", orig_name, item.ident.name),\n-            None => format!(\"use {};\", item.ident.name),\n-        };\n-        let vis = tcx.sess.source_map().span_to_snippet(item.vis_span).unwrap_or_default();\n-        let add_vis = |to| if vis.is_empty() { to } else { format!(\"{} {}\", vis, to) };\n-        tcx.emit_spanned_lint(\n-            lint,\n-            id,\n-            extern_crate.span,\n-            ExternCrateNotIdiomatic {\n-                span: extern_crate.span,\n-                msg_code: add_vis(\"use\".to_string()),\n-                suggestion_code: add_vis(base_replacement),\n-            },\n-        );\n-    }\n-}\n-\n-struct ExternCrateToLint {\n-    /// `DefId` of the extern crate\n-    def_id: DefId,\n-\n-    /// span from the item\n-    span: Span,\n-\n-    /// if `Some`, then this is renamed (`extern crate orig_name as\n-    /// crate_name`), and -- perhaps surprisingly -- this stores the\n-    /// *original* name (`item.name` will contain the new name)\n-    orig_name: Option<Symbol>,\n-\n-    /// if `false`, the original name started with `_`, so we shouldn't lint\n-    /// about it going unused (but we should still emit idiom lints).\n-    warn_if_unused: bool,\n }"}, {"sha": "ffb68abf978de6a34c2360d02edd207c0ac3c658", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -437,7 +437,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n             }\n \n             // Here we are considering a case of converting\n-            // `S<P0...Pn>` to S<Q0...Qn>`. As an example, let's imagine a struct `Foo<T, U>`,\n+            // `S<P0...Pn>` to `S<Q0...Qn>`. As an example, let's imagine a struct `Foo<T, U>`,\n             // which acts like a pointer to `U`, but carries along some extra data of type `T`:\n             //\n             //     struct Foo<T, U> {"}, {"sha": "6f6f993f727170c4487b12db29a9b68f2cdfdcad", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -3,7 +3,7 @@ use crate::astconv::AstConv;\n use rustc_hir as hir;\n use rustc_infer::traits::util;\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n "}, {"sha": "e9963e67741ba05e6eec4582eca9a52325a1e8bc", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 103, "deletions": 42, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -17,13 +17,15 @@ use rustc_hir::{GenericArg, GenericParam, GenericParamKind, HirIdMap, LifetimeNa\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_bound_vars::*;\n-use rustc_middle::ty::{self, DefIdTree, TyCtxt, TypeSuperVisitable, TypeVisitor};\n+use rustc_middle::ty::{self, TyCtxt, TypeSuperVisitable, TypeVisitor};\n use rustc_session::lint;\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use std::fmt;\n \n+use crate::errors;\n+\n trait RegionExt {\n     fn early(param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg);\n \n@@ -161,6 +163,15 @@ enum Scope<'a> {\n         s: ScopeRef<'a>,\n     },\n \n+    /// Disallows capturing non-lifetime binders from parent scopes.\n+    ///\n+    /// This is necessary for something like `for<T> [(); { /* references T */ }]:`,\n+    /// since we don't do something more correct like replacing any captured\n+    /// late-bound vars with early-bound params in the const's own generics.\n+    AnonConstBoundary {\n+        s: ScopeRef<'a>,\n+    },\n+\n     Root {\n         opt_parent_item: Option<LocalDefId>,\n     },\n@@ -211,6 +222,7 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::TraitRefBoundary { s: _ } => f.debug_struct(\"TraitRefBoundary\").finish(),\n+            Scope::AnonConstBoundary { s: _ } => f.debug_struct(\"AnonConstBoundary\").finish(),\n             Scope::Root { opt_parent_item } => {\n                 f.debug_struct(\"Root\").field(\"opt_parent_item\", &opt_parent_item).finish()\n             }\n@@ -312,7 +324,9 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                     break (vec![], BinderScopeType::Normal);\n                 }\n \n-                Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n+                Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::AnonConstBoundary { s } => {\n                     scope = s;\n                 }\n \n@@ -1029,50 +1043,64 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n     fn visit_poly_trait_ref(&mut self, trait_ref: &'tcx hir::PolyTraitRef<'tcx>) {\n         self.visit_poly_trait_ref_inner(trait_ref, NonLifetimeBinderAllowed::Allow);\n     }\n+\n+    fn visit_anon_const(&mut self, c: &'tcx hir::AnonConst) {\n+        self.with(Scope::AnonConstBoundary { s: self.scope }, |this| {\n+            intravisit::walk_anon_const(this, c);\n+        });\n+    }\n }\n \n fn object_lifetime_default(tcx: TyCtxt<'_>, param_def_id: DefId) -> ObjectLifetimeDefault {\n     debug_assert_eq!(tcx.def_kind(param_def_id), DefKind::TyParam);\n     let param_def_id = param_def_id.expect_local();\n-    let parent_def_id = tcx.local_parent(param_def_id);\n-    let generics = tcx.hir().get_generics(parent_def_id).unwrap();\n-    let param_hir_id = tcx.local_def_id_to_hir_id(param_def_id);\n-    let param = generics.params.iter().find(|p| p.hir_id == param_hir_id).unwrap();\n-\n-    // Scan the bounds and where-clauses on parameters to extract bounds\n-    // of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n-    // for each type parameter.\n-    match param.kind {\n-        GenericParamKind::Type { .. } => {\n-            let mut set = Set1::Empty;\n-\n-            // Look for `type: ...` where clauses.\n-            for bound in generics.bounds_for_param(param_def_id) {\n-                // Ignore `for<'a> type: ...` as they can change what\n-                // lifetimes mean (although we could \"just\" handle it).\n-                if !bound.bound_generic_params.is_empty() {\n-                    continue;\n-                }\n+    let hir::Node::GenericParam(param) = tcx.hir().get_by_def_id(param_def_id) else {\n+        bug!(\"expected GenericParam for object_lifetime_default\");\n+    };\n+    match param.source {\n+        hir::GenericParamSource::Generics => {\n+            let parent_def_id = tcx.local_parent(param_def_id);\n+            let generics = tcx.hir().get_generics(parent_def_id).unwrap();\n+            let param_hir_id = tcx.local_def_id_to_hir_id(param_def_id);\n+            let param = generics.params.iter().find(|p| p.hir_id == param_hir_id).unwrap();\n+\n+            // Scan the bounds and where-clauses on parameters to extract bounds\n+            // of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n+            // for each type parameter.\n+            match param.kind {\n+                GenericParamKind::Type { .. } => {\n+                    let mut set = Set1::Empty;\n+\n+                    // Look for `type: ...` where clauses.\n+                    for bound in generics.bounds_for_param(param_def_id) {\n+                        // Ignore `for<'a> type: ...` as they can change what\n+                        // lifetimes mean (although we could \"just\" handle it).\n+                        if !bound.bound_generic_params.is_empty() {\n+                            continue;\n+                        }\n \n-                for bound in bound.bounds {\n-                    if let hir::GenericBound::Outlives(lifetime) = bound {\n-                        set.insert(lifetime.res);\n+                        for bound in bound.bounds {\n+                            if let hir::GenericBound::Outlives(lifetime) = bound {\n+                                set.insert(lifetime.res);\n+                            }\n+                        }\n                     }\n-                }\n-            }\n \n-            match set {\n-                Set1::Empty => ObjectLifetimeDefault::Empty,\n-                Set1::One(hir::LifetimeName::Static) => ObjectLifetimeDefault::Static,\n-                Set1::One(hir::LifetimeName::Param(param_def_id)) => {\n-                    ObjectLifetimeDefault::Param(param_def_id.to_def_id())\n+                    match set {\n+                        Set1::Empty => ObjectLifetimeDefault::Empty,\n+                        Set1::One(hir::LifetimeName::Static) => ObjectLifetimeDefault::Static,\n+                        Set1::One(hir::LifetimeName::Param(param_def_id)) => {\n+                            ObjectLifetimeDefault::Param(param_def_id.to_def_id())\n+                        }\n+                        _ => ObjectLifetimeDefault::Ambiguous,\n+                    }\n+                }\n+                _ => {\n+                    bug!(\"object_lifetime_default_raw must only be called on a type parameter\")\n                 }\n-                _ => ObjectLifetimeDefault::Ambiguous,\n             }\n         }\n-        _ => {\n-            bug!(\"object_lifetime_default_raw must only be called on a type parameter\")\n-        }\n+        hir::GenericParamSource::Binder => ObjectLifetimeDefault::Empty,\n     }\n }\n \n@@ -1267,7 +1295,8 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                 Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n                 | Scope::Supertrait { s, .. }\n-                | Scope::TraitRefBoundary { s, .. } => {\n+                | Scope::TraitRefBoundary { s, .. }\n+                | Scope::AnonConstBoundary { s } => {\n                     scope = s;\n                 }\n             }\n@@ -1332,7 +1361,8 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n                 | Scope::Supertrait { s, .. }\n-                | Scope::TraitRefBoundary { s, .. } => {\n+                | Scope::TraitRefBoundary { s, .. }\n+                | Scope::AnonConstBoundary { s } => {\n                     scope = s;\n                 }\n             }\n@@ -1351,6 +1381,7 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n         // search.\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n+        let mut crossed_anon_const = false;\n         let result = loop {\n             match *scope {\n                 Scope::Body { s, .. } => {\n@@ -1384,17 +1415,44 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                 | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n                 }\n+\n+                Scope::AnonConstBoundary { s } => {\n+                    crossed_anon_const = true;\n+                    scope = s;\n+                }\n             }\n         };\n \n         if let Some(def) = result {\n+            if let ResolvedArg::LateBound(..) = def && crossed_anon_const {\n+                let use_span = self.tcx.hir().span(hir_id);\n+                let def_span = self.tcx.def_span(param_def_id);\n+                match self.tcx.def_kind(param_def_id) {\n+                    DefKind::ConstParam => {\n+                        self.tcx.sess.emit_err(errors::CannotCaptureLateBoundInAnonConst::Const {\n+                            use_span,\n+                            def_span,\n+                        });\n+                    }\n+                    DefKind::TyParam => {\n+                        self.tcx.sess.emit_err(errors::CannotCaptureLateBoundInAnonConst::Type {\n+                            use_span,\n+                            def_span,\n+                        });\n+                    }\n+                    _ => unreachable!(),\n+                }\n+                return;\n+            }\n+\n             self.map.defs.insert(hir_id, def);\n             return;\n         }\n \n-        self.tcx\n-            .sess\n-            .delay_span_bug(self.tcx.hir().span(hir_id), \"could not resolve {param_def_id:?}\");\n+        self.tcx.sess.delay_span_bug(\n+            self.tcx.hir().span(hir_id),\n+            format!(\"could not resolve {param_def_id:?}\"),\n+        );\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n@@ -1465,7 +1523,8 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                         | Scope::Elision { s, .. }\n                         | Scope::ObjectLifetimeDefault { s, .. }\n                         | Scope::Supertrait { s, .. }\n-                        | Scope::TraitRefBoundary { s, .. } => {\n+                        | Scope::TraitRefBoundary { s, .. }\n+                        | Scope::AnonConstBoundary { s } => {\n                             scope = s;\n                         }\n                     }\n@@ -1701,7 +1760,9 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n \n                 Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l,\n \n-                Scope::Supertrait { s, .. } | Scope::TraitRefBoundary { s, .. } => {\n+                Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. }\n+                | Scope::AnonConstBoundary { s } => {\n                     scope = s;\n                 }\n             }"}, {"sha": "acd9f8a5c8eebc97127e76b68657f4f749fb4f78", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::ty::print::with_forced_trimmed_paths;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{\n-    self, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitableExt,\n+    self, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitableExt,\n };\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};"}, {"sha": "3e0692757754fa20e75d40b2c6653da8d10bb3b8", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -5,7 +5,7 @@ use rustc_errors::{\n     error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, Handler, IntoDiagnostic,\n     MultiSpan,\n };\n-use rustc_macros::{Diagnostic, LintDiagnostic};\n+use rustc_macros::Diagnostic;\n use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n@@ -247,26 +247,6 @@ pub struct SubstsOnOverriddenImpl {\n     pub span: Span,\n }\n \n-#[derive(LintDiagnostic)]\n-#[diag(hir_analysis_unused_extern_crate)]\n-pub struct UnusedExternCrate {\n-    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n-    pub span: Span,\n-}\n-\n-#[derive(LintDiagnostic)]\n-#[diag(hir_analysis_extern_crate_not_idiomatic)]\n-pub struct ExternCrateNotIdiomatic {\n-    #[suggestion(\n-        style = \"short\",\n-        applicability = \"machine-applicable\",\n-        code = \"{suggestion_code}\"\n-    )]\n-    pub span: Span,\n-    pub msg_code: String,\n-    pub suggestion_code: String,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(hir_analysis_const_impl_for_non_const_trait)]\n pub struct ConstImplForNonConstTrait {\n@@ -401,3 +381,21 @@ pub(crate) struct VariadicFunctionCompatibleConvention<'a> {\n     pub span: Span,\n     pub conventions: &'a str,\n }\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum CannotCaptureLateBoundInAnonConst {\n+    #[diag(hir_analysis_cannot_capture_late_bound_ty_in_anon_const)]\n+    Type {\n+        #[primary_span]\n+        use_span: Span,\n+        #[label]\n+        def_span: Span,\n+    },\n+    #[diag(hir_analysis_cannot_capture_late_bound_const_in_anon_const)]\n+    Const {\n+        #[primary_span]\n+        use_span: Span,\n+        #[label]\n+        def_span: Span,\n+    },\n+}"}, {"sha": "d53c429ca15ca7fc6effa28ce37dea8d9879a588", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{GenericArg, GenericArgKind};\n use rustc_span::Span;\n "}, {"sha": "a8b7699b66750a1658781316be4f1837475c9379", "filename": "compiler/rustc_hir_analysis/src/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, CrateVariancesMap, SubstsRef, Ty, TyCtxt};\n-use rustc_middle::ty::{DefIdTree, TypeSuperVisitable, TypeVisitable};\n+use rustc_middle::ty::{TypeSuperVisitable, TypeVisitable};\n use std::ops::ControlFlow;\n \n /// Defines the `TermsContext` basically houses an arena where we can"}, {"sha": "7ba57b3b7a266d51761aa538e0d897ad5a67bea9", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -315,7 +315,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     probe::ProbeScope::TraitsInScope,\n                     None,\n                 ) {\n-                    Ok(pick) => pick.self_ty,\n+                    Ok(pick) => eraser.fold_ty(pick.self_ty),\n                     Err(_) => rcvr_ty,\n                 };\n                 // Remove one layer of references to account for `&mut self` and"}, {"sha": "a8f8121153fafe8bee80d44f136a482a06c6353f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -25,7 +25,7 @@ use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::{TypeVisitable, TypeVisitableExt};\n use rustc_middle::ty::{\n-    self, AdtKind, CanonicalUserType, DefIdTree, GenericParamDefKind, Ty, TyCtxt, UserType,\n+    self, AdtKind, CanonicalUserType, GenericParamDefKind, Ty, TyCtxt, UserType,\n };\n use rustc_middle::ty::{GenericArgKind, SubstsRef, UserSelfTy, UserSubsts};\n use rustc_session::lint;"}, {"sha": "ec14bd3c6f43ee3f0a7f264b070a78e924e58e93", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -3,9 +3,7 @@ use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::ObligationCauseCode;\n-use rustc_middle::ty::{\n-    self, DefIdTree, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n-};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n use rustc_span::{self, Span};\n use rustc_trait_selection::traits;\n \n@@ -714,12 +712,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.tcx.parent(expr_ctor_def_id)\n                 }\n                 hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, hir::def::CtorKind::Fn) => {\n-                    // If this is a variant, its parent is the type definition.\n-                    if in_ty_adt.did() != self.tcx.parent(expr_ctor_def_id) {\n+                    // For a typical enum like\n+                    // `enum Blah<T> { Variant(T) }`\n+                    // we get the following resolutions:\n+                    // - expr_ctor_def_id :::                                   DefId(0:29 ~ source_file[b442]::Blah::Variant::{constructor#0})\n+                    // - self.tcx.parent(expr_ctor_def_id) :::                  DefId(0:28 ~ source_file[b442]::Blah::Variant)\n+                    // - self.tcx.parent(self.tcx.parent(expr_ctor_def_id)) ::: DefId(0:26 ~ source_file[b442]::Blah)\n+\n+                    // Therefore, we need to go up once to obtain the variant and up twice to obtain the type.\n+                    // Note that this pattern still holds even when we `use` a variant or `use` an enum type to rename it, or chain `use` expressions\n+                    // together; this resolution is handled automatically by `qpath_res`.\n+\n+                    // FIXME: Deal with type aliases?\n+                    if in_ty_adt.did() == self.tcx.parent(self.tcx.parent(expr_ctor_def_id)) {\n+                        // The constructor definition refers to the \"constructor\" of the variant:\n+                        // For example, `Some(5)` triggers this case.\n+                        self.tcx.parent(expr_ctor_def_id)\n+                    } else {\n                         // FIXME: Deal with type aliases?\n                         return Err(expr);\n                     }\n-                    expr_ctor_def_id\n                 }\n                 _ => {\n                     return Err(expr);"}, {"sha": "ea54b76bdec962c350d8bb41f9ba5d09ac49ab6c", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -28,15 +28,14 @@ use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::visit::TypeVisitableExt;\n-use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty};\n+use rustc_middle::ty::{self, IsSuggestable, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{self, sym, Span};\n use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext};\n \n use std::iter;\n use std::mem;\n-use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn check_casts(&mut self) {\n@@ -1507,11 +1506,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let coerce = if blk.targeted_by_break {\n             CoerceMany::new(coerce_to_ty)\n         } else {\n-            let tail_expr: &[&hir::Expr<'_>] = match tail_expr {\n-                Some(e) => slice::from_ref(e),\n-                None => &[],\n-            };\n-            CoerceMany::with_coercion_sites(coerce_to_ty, tail_expr)\n+            CoerceMany::with_coercion_sites(coerce_to_ty, blk.expr.as_slice())\n         };\n \n         let prev_diverges = self.diverges.get();"}, {"sha": "c77251a156fc099f0c7458bfa2019b0b08507372", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -16,7 +16,7 @@ use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{\n-    self, suggest_constraining_type_params, Binder, DefIdTree, IsSuggestable, ToPredicate, Ty,\n+    self, suggest_constraining_type_params, Binder, IsSuggestable, ToPredicate, Ty,\n     TypeVisitableExt,\n };\n use rustc_session::errors::ExprParenthesesNeeded;"}, {"sha": "e397dfd45706bcc20291b770054c661434f04017", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -5,6 +5,7 @@\n #![feature(min_specialization)]\n #![feature(control_flow_enum)]\n #![feature(drain_filter)]\n+#![feature(option_as_slice)]\n #![allow(rustc::potential_query_instability)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "4d3969d28aa2d6f95ab1f97fbc6e919eb85d64a4", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -636,7 +636,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // `&&Some(x,)` `place_foo`\n         //  `&Some(x,)` `deref { place_foo}`\n         //   `Some(x,)` `deref { deref { place_foo }}`\n-        //        (x,)` `field0 { deref { deref { place_foo }}}` <- resulting place\n+        //       `(x,)` `field0 { deref { deref { place_foo }}}` <- resulting place\n         //\n         // The above example has no adjustments. If the code were instead the (after adjustments,\n         // equivalent) version"}, {"sha": "4f4779d1543953374228bd92ea74aa411b1efde1", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -27,7 +27,7 @@ use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::DeepRejectCtxt;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::{with_crate_prefix, with_forced_trimmed_paths};\n-use rustc_middle::ty::{self, DefIdTree, GenericArgKind, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_middle::ty::{self, GenericArgKind, Ty, TyCtxt, TypeVisitableExt};\n use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n@@ -333,6 +333,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             rcvr_ty.prefix_string(self.tcx),\n             ty_str_reported,\n         );\n+        if tcx.sess.source_map().is_multiline(sugg_span) {\n+            err.span_label(sugg_span.with_hi(span.lo()), \"\");\n+        }\n         let ty_str = if short_ty_str.len() < ty_str.len() && ty_str.len() > 10 {\n             short_ty_str\n         } else {"}, {"sha": "eecded557a5b84a91c8037c04be2cb06b40cc6cc", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::ty::adjustment::{\n };\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{\n-    self, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitableExt,\n+    self, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitableExt,\n };\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n@@ -749,14 +749,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         let opname = Ident::with_dummy_span(opname);\n-        let input_types =\n-            opt_rhs.as_ref().map(|(_, ty)| std::slice::from_ref(ty)).unwrap_or_default();\n+        let (opt_rhs_expr, opt_rhs_ty) = opt_rhs.unzip();\n+        let input_types = opt_rhs_ty.as_slice();\n         let cause = self.cause(\n             span,\n             traits::BinOp {\n-                rhs_span: opt_rhs.map(|(expr, _)| expr.span),\n-                is_lit: opt_rhs\n-                    .map_or(false, |(expr, _)| matches!(expr.kind, hir::ExprKind::Lit(_))),\n+                rhs_span: opt_rhs_expr.map(|expr| expr.span),\n+                is_lit: opt_rhs_expr\n+                    .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n                 output_ty: expected.only_has_type(self),\n             },\n         );"}, {"sha": "2cca45de5e9714e8c802b6865dcb566ad157b5f9", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -11,7 +11,6 @@ use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutabili\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n-use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Type-check `*oprnd_expr` with `oprnd_expr` type-checked already.\n@@ -393,11 +392,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(self.typeck_results.borrow().node_substs(expr.hir_id).type_at(1))\n             }\n         };\n-        let arg_tys = match arg_ty {\n-            None => &[],\n-            Some(ref ty) => slice::from_ref(ty),\n-        };\n-\n+        let arg_tys = arg_ty.as_slice();\n         let method = self.try_mutable_overloaded_place_op(expr.span, base_ty, arg_tys, op);\n         let method = match method {\n             Some(ok) => self.register_infer_ok_obligations(ok),"}, {"sha": "4a432328c4d1bcb7891ccb8d8aeaea5d1c532ecf", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -231,7 +231,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // We now fake capture information for all variables that are mentioned within the closure\n         // We do this after handling migrations so that min_captures computes before\n-        if !enable_precise_capture(self.tcx, span) {\n+        if !enable_precise_capture(span) {\n             let mut capture_information: InferredCaptureInformation<'tcx> = Default::default();\n \n             if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n@@ -265,7 +265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // If we have an origin, store it.\n             if let Some(origin) = origin {\n-                let origin = if enable_precise_capture(self.tcx, span) {\n+                let origin = if enable_precise_capture(span) {\n                     (origin.0, origin.1)\n                 } else {\n                     (origin.0, Place { projections: vec![], ..origin.1 })\n@@ -526,10 +526,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n+            let var_ident = self.tcx.hir().ident(var_hir_id);\n \n             let Some(min_cap_list) = root_var_min_capture_list.get_mut(&var_hir_id) else {\n                 let mutability = self.determine_capture_mutability(&typeck_results, &place);\n                 let min_cap_list = vec![ty::CapturedPlace {\n+                    var_ident,\n                     place,\n                     info: capture_info,\n                     mutability,\n@@ -628,6 +630,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if !ancestor_found {\n                 let mutability = self.determine_capture_mutability(&typeck_results, &place);\n                 let captured_place = ty::CapturedPlace {\n+                    var_ident,\n                     place,\n                     info: updated_capture_info,\n                     mutability,\n@@ -1240,8 +1243,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// This will make more sense with an example:\n     ///\n-    /// ```rust\n-    /// #![feature(capture_disjoint_fields)]\n+    /// ```rust,edition2021\n     ///\n     /// struct FancyInteger(i32); // This implements Drop\n     ///\n@@ -2221,7 +2223,7 @@ fn determine_place_ancestry_relation<'tcx>(\n ///     || drop(&*m.a.field_of_a)\n ///     // Here we really do want to capture `*m.a` because that outlives `'static`\n ///\n-///     // If we capture `m`, then the closure no longer outlives `'static'\n+///     // If we capture `m`, then the closure no longer outlives `'static`\n ///     // it is constrained to `'a`\n /// }\n /// ```\n@@ -2247,12 +2249,10 @@ fn truncate_capture_for_optimization(\n     (place, curr_mode)\n }\n \n-/// Precise capture is enabled if the feature gate `capture_disjoint_fields` is enabled or if\n-/// user is using Rust Edition 2021 or higher.\n-///\n+/// Precise capture is enabled if user is using Rust Edition 2021 or higher.\n /// `span` is the span of the closure.\n-fn enable_precise_capture(tcx: TyCtxt<'_>, span: Span) -> bool {\n+fn enable_precise_capture(span: Span) -> bool {\n     // We use span here to ensure that if the closure was generated by a macro with a different\n     // edition.\n-    tcx.features().capture_disjoint_fields || span.rust_2021()\n+    span.rust_2021()\n }"}, {"sha": "c550e553bb032990d92d9e19947a0b4d41072163", "filename": "compiler/rustc_incremental/src/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -18,7 +18,7 @@\n //! the HIR doesn't change as a result of the annotations, which might\n //! perturb the reuse results.\n //!\n-//! `#![rustc_expected_cgu_reuse(module=\"spike\", cfg=\"rpass2\", kind=\"post-lto\")]\n+//! `#![rustc_expected_cgu_reuse(module=\"spike\", cfg=\"rpass2\", kind=\"post-lto\")]`\n //! allows for doing a more fine-grained check to see if pre- or post-lto data\n //! was re-used.\n "}, {"sha": "cbf169afb18c19a84084d6820cc8c9d9d6561a1e", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1870,7 +1870,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         }\n     }\n \n-    /// Subtracts `set from `row`. `set` can be either `BitSet` or\n+    /// Subtracts `set` from `row`. `set` can be either `BitSet` or\n     /// `HybridBitSet`. Has no effect if `row` does not exist.\n     ///\n     /// Returns true if the row was changed."}, {"sha": "15780898dc6ab42110da1b11fd2db6f0d6768482", "filename": "compiler/rustc_infer/locales/en-US.ftl", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Flocales%2Fen-US.ftl?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -79,7 +79,7 @@ infer_subtype = ...so that the {$requirement ->\n     [if_else_different] `if` and `else` have incompatible types\n     [no_else] `if` missing an `else` returns `()`\n     [fn_main_correct_type] `main` function has the correct type\n-    [fn_start_correct_type] #[start]` function has the correct type\n+    [fn_start_correct_type] `#[start]` function has the correct type\n     [intristic_correct_type] intrinsic has the correct type\n     [method_correct_type] method receiver has the correct type\n     *[other] types are compatible\n@@ -92,7 +92,7 @@ infer_subtype_2 = ...so that {$requirement ->\n     [if_else_different] `if` and `else` have incompatible types\n     [no_else] `if` missing an `else` returns `()`\n     [fn_main_correct_type] `main` function has the correct type\n-    [fn_start_correct_type] #[start]` function has the correct type\n+    [fn_start_correct_type] `#[start]` function has the correct type\n     [intristic_correct_type] intrinsic has the correct type\n     [method_correct_type] method receiver has the correct type\n     *[other] types are compatible\n@@ -277,7 +277,7 @@ infer_tid_consider_borrowing = consider borrowing this type parameter in the tra\n infer_tid_param_help = the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n \n infer_dtcs_has_lifetime_req_label = this has an implicit `'static` lifetime requirement\n-infer_dtcs_introduces_requirement = calling this method introduces the `impl`'s 'static` requirement\n+infer_dtcs_introduces_requirement = calling this method introduces the `impl`'s `'static` requirement\n infer_dtcs_has_req_note = the used `impl` has a `'static` requirement\n infer_dtcs_suggestion = consider relaxing the implicit `'static` requirement\n \n@@ -313,7 +313,7 @@ infer_but_needs_to_satisfy = {$has_param_name ->\n         [false] ...and is required to live as long as `'static` here\n     }\n     .used_here = ...is used here...\n-    .introduced_by_bound = 'static` lifetime requirement introduced by this bound\n+    .introduced_by_bound = `'static` lifetime requirement introduced by this bound\n \n infer_more_targeted = {$has_param_name ->\n     [true] `{$param_name}`\n@@ -345,3 +345,6 @@ infer_prlf_defined_without_sub = the lifetime defined here...\n infer_prlf_must_oultive_with_sup = ...must outlive the lifetime `{$sup_symbol}` defined here\n infer_prlf_must_oultive_without_sup = ...must outlive the lifetime defined here\n infer_prlf_known_limitation = this is a known limitation that will be removed in the future (see issue #100013 <https://github.com/rust-lang/rust/issues/100013> for more information)\n+\n+infer_opaque_captures_lifetime = hidden type for `{$opaque_ty}` captures lifetime that does not appear in bounds\n+    .label = opaque type defined here"}, {"sha": "6bbd3fd3e6e75cb818050d9401217173cd83e2c3", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1147,3 +1147,13 @@ pub enum PlaceholderRelationLfNotSatisfied {\n         note: (),\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_opaque_captures_lifetime, code = \"E0700\")]\n+pub struct OpaqueCapturesLifetime<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub opaque_ty_span: Span,\n+    pub opaque_ty: Ty<'tcx>,\n+}"}, {"sha": "7d9bae735e55d7e481389b89e025b31f2c2baf32", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -369,6 +369,34 @@ impl<'tcx> ToTrace<'tcx> for Const<'tcx> {\n     }\n }\n \n+impl<'tcx> ToTrace<'tcx> for ty::GenericArg<'tcx> {\n+    fn to_trace(\n+        _: TyCtxt<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Self,\n+        b: Self,\n+    ) -> TypeTrace<'tcx> {\n+        use GenericArgKind::*;\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: match (a.unpack(), b.unpack()) {\n+                (Lifetime(a), Lifetime(b)) => Regions(ExpectedFound::new(a_is_expected, a, b)),\n+                (Type(a), Type(b)) => Terms(ExpectedFound::new(a_is_expected, a.into(), b.into())),\n+                (Const(a), Const(b)) => {\n+                    Terms(ExpectedFound::new(a_is_expected, a.into(), b.into()))\n+                }\n+\n+                (Lifetime(_), Type(_) | Const(_))\n+                | (Type(_), Lifetime(_) | Const(_))\n+                | (Const(_), Lifetime(_) | Type(_)) => {\n+                    bug!(\"relating different kinds: {a:?} {b:?}\")\n+                }\n+            },\n+        }\n+    }\n+}\n+\n impl<'tcx> ToTrace<'tcx> for ty::Term<'tcx> {\n     fn to_trace(\n         _: TyCtxt<'tcx>,"}, {"sha": "678c4a0beb63e8421c2bed59c2ac3839625688c0", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> InferCtxt<'tcx> {\n \n     /// Like [Self::canonicalize_query], but preserves distinct universes. For\n     /// example, canonicalizing `&'?0: Trait<'?1>`, where `'?0` is in `U1` and\n-    /// `'?1` is in `U3` would be canonicalized to have ?0` in `U1` and `'?1`\n+    /// `'?1` is in `U3` would be canonicalized to have `?0` in `U1` and `'?1`\n     /// in `U2`.\n     ///\n     /// This is used for Chalk integration."}, {"sha": "ce230afdab3ce2629474c4bf2ed8f37c1c6622fa", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::ty::{self, List, TyCtxt};\n use rustc_span::source_map::Span;\n \n pub use rustc_middle::infer::canonical::*;\n-use substitute::CanonicalExt;\n+pub use substitute::CanonicalExt;\n \n mod canonicalizer;\n pub mod query_response;\n@@ -100,7 +100,11 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// variable for it. If this is an existentially quantified\n     /// variable, then you'll get a new inference variable; if it is a\n     /// universally quantified variable, you get a placeholder.\n-    fn instantiate_canonical_var(\n+    ///\n+    /// FIXME(-Ztrait-solver=next): This is public because it's used by the\n+    /// new trait solver which has a different canonicalization routine.\n+    /// We should somehow deduplicate all of this.\n+    pub fn instantiate_canonical_var(\n         &self,\n         span: Span,\n         cv_info: CanonicalVarInfo<'tcx>,"}, {"sha": "436d29c2449e4f925b2d748a2ec0d4ea3fca2e2f", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -151,11 +151,21 @@ impl<'tcx> InferCtxt<'tcx> {\n         })\n     }\n \n-    /// FIXME: This method should only be used for canonical queries and therefore be private.\n-    ///\n-    /// As the new solver does canonicalization slightly differently, this is also used there\n-    /// for now. This should hopefully change fairly soon.\n-    pub fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+    /// Used by the new solver as that one takes the opaque types at the end of a probe\n+    /// to deal with multiple candidates without having to recompute them.\n+    pub fn clone_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+        self.inner\n+            .borrow()\n+            .opaque_type_storage\n+            .opaque_types\n+            .iter()\n+            .map(|&(k, ref v)| {\n+                (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty)\n+            })\n+            .collect()\n+    }\n+\n+    fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n         std::mem::take(&mut self.inner.borrow_mut().opaque_type_storage.opaque_types)\n             .into_iter()\n             .map(|(k, v)| (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty))"}, {"sha": "cac3b40725158d73164b1568e56c3b0cc6561fc5", "filename": "compiler/rustc_infer/src/infer/canonical/substitute.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -11,7 +11,9 @@ use rustc_middle::ty::fold::{FnMutDelegate, TypeFoldable};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, TyCtxt};\n \n-pub(super) trait CanonicalExt<'tcx, V> {\n+/// FIXME(-Ztrait-solver=next): This or public because it is shared with the\n+/// new trait solver implementation. We should deduplicate canonicalization.\n+pub trait CanonicalExt<'tcx, V> {\n     /// Instantiate the wrapped value, replacing each canonical value\n     /// with the value given in `var_values`.\n     fn substitute(&self, tcx: TyCtxt<'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V"}, {"sha": "8a2b800af0e81c174fed4524fd0acdeaed4d01ea", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -49,6 +49,7 @@ use super::lexical_region_resolve::RegionResolutionError;\n use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n+use crate::errors;\n use crate::infer;\n use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::infer::ExpectedFound;\n@@ -281,15 +282,13 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n     span: Span,\n     hidden_ty: Ty<'tcx>,\n     hidden_region: ty::Region<'tcx>,\n-    opaque_ty: ty::OpaqueTypeKey<'tcx>,\n+    opaque_ty_key: ty::OpaqueTypeKey<'tcx>,\n ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-    let opaque_ty = tcx.mk_opaque(opaque_ty.def_id.to_def_id(), opaque_ty.substs);\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n+    let mut err = tcx.sess.create_err(errors::OpaqueCapturesLifetime {\n         span,\n-        E0700,\n-        \"hidden type for `{opaque_ty}` captures lifetime that does not appear in bounds\",\n-    );\n+        opaque_ty: tcx.mk_opaque(opaque_ty_key.def_id.to_def_id(), opaque_ty_key.substs),\n+        opaque_ty_span: tcx.def_span(opaque_ty_key.def_id),\n+    });\n \n     // Explain the region we are capturing.\n     match *hidden_region {\n@@ -1690,7 +1689,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                                 format!(\"{name} is defined in the current crate\")\n                             } else {\n                                 let crate_name = self.tcx.crate_name(defid.krate);\n-                                format!(\"{name} is defined in crate `{crate_name}\")\n+                                format!(\"{name} is defined in crate `{crate_name}`\")\n                             };\n                             diagnostic.span_note(def_span, msg);\n                         };"}, {"sha": "a3151d2d3657776124dffd0d129a85334df84e50", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Print, Printer};\n-use rustc_middle::ty::{self, DefIdTree, InferConst};\n+use rustc_middle::ty::{self, InferConst};\n use rustc_middle::ty::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{IsSuggestable, Ty, TyCtxt, TypeckResults};\n use rustc_span::symbol::{kw, sym, Ident};"}, {"sha": "c5ef48fe3da251c814fbbf217964faedf1c7020f", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -5,7 +5,7 @@ use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::TyCtxt;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_middle::ty::{self, Binder, DefIdTree, Region, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, Binder, Region, Ty, TypeVisitable};\n use rustc_span::Span;\n \n /// Information about the anonymous region we are searching for."}, {"sha": "2c480355085efc5fcb9ef24a049010e825cb12d3", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -70,7 +70,7 @@ pub enum RegionResolutionError<'tcx> {\n     /// `o` requires that `a <= b`, but this does not hold\n     ConcreteFailure(SubregionOrigin<'tcx>, Region<'tcx>, Region<'tcx>),\n \n-    /// `GenericBoundFailure(p, s, a)\n+    /// `GenericBoundFailure(p, s, a)`:\n     ///\n     /// The parameter/associated-type `p` must be known to outlive the lifetime\n     /// `a` (but none of the known bounds are sufficient).\n@@ -438,7 +438,11 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n             (VarValue::Value(a), VarValue::Empty(_)) => {\n                 match *a {\n-                    ReLateBound(..) | ReErased | ReError(_) => {\n+                    // this is always on an error path,\n+                    // so it doesn't really matter if it's shorter or longer than an empty region\n+                    ReError(_) => false,\n+\n+                    ReLateBound(..) | ReErased => {\n                         bug!(\"cannot relate region: {:?}\", a);\n                     }\n \n@@ -467,7 +471,11 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n             (VarValue::Empty(a_ui), VarValue::Value(b)) => {\n                 match *b {\n-                    ReLateBound(..) | ReErased | ReError(_) => {\n+                    // this is always on an error path,\n+                    // so it doesn't really matter if it's shorter or longer than an empty region\n+                    ReError(_) => false,\n+\n+                    ReLateBound(..) | ReErased => {\n                         bug!(\"cannot relate region: {:?}\", b);\n                     }\n "}, {"sha": "387843ee69333fc29793cccda632aa85e62164a9", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 42, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -94,10 +94,10 @@ pub(crate) type UnificationTable<'a, 'tcx, T> = ut::UnificationTable<\n /// call to `start_snapshot` and `rollback_to`.\n #[derive(Clone)]\n pub struct InferCtxtInner<'tcx> {\n-    /// Cache for projections. This cache is snapshotted along with the infcx.\n+    /// Cache for projections.\n     ///\n-    /// Public so that `traits::project` can use it.\n-    pub projection_cache: traits::ProjectionCacheStorage<'tcx>,\n+    /// This cache is snapshotted along with the infcx.\n+    projection_cache: traits::ProjectionCacheStorage<'tcx>,\n \n     /// We instantiate `UnificationTable` with `bounds<Ty>` because the types\n     /// that might instantiate a general type variable have an order,\n@@ -156,7 +156,7 @@ pub struct InferCtxtInner<'tcx> {\n     undo_log: InferCtxtUndoLogs<'tcx>,\n \n     /// Caches for opaque type inference.\n-    pub opaque_type_storage: OpaqueTypeStorage<'tcx>,\n+    opaque_type_storage: OpaqueTypeStorage<'tcx>,\n }\n \n impl<'tcx> InferCtxtInner<'tcx> {\n@@ -195,41 +195,17 @@ impl<'tcx> InferCtxtInner<'tcx> {\n     }\n \n     #[inline]\n-    fn int_unification_table(\n-        &mut self,\n-    ) -> ut::UnificationTable<\n-        ut::InPlace<\n-            ty::IntVid,\n-            &mut ut::UnificationStorage<ty::IntVid>,\n-            &mut InferCtxtUndoLogs<'tcx>,\n-        >,\n-    > {\n+    fn int_unification_table(&mut self) -> UnificationTable<'_, 'tcx, ty::IntVid> {\n         self.int_unification_storage.with_log(&mut self.undo_log)\n     }\n \n     #[inline]\n-    fn float_unification_table(\n-        &mut self,\n-    ) -> ut::UnificationTable<\n-        ut::InPlace<\n-            ty::FloatVid,\n-            &mut ut::UnificationStorage<ty::FloatVid>,\n-            &mut InferCtxtUndoLogs<'tcx>,\n-        >,\n-    > {\n+    fn float_unification_table(&mut self) -> UnificationTable<'_, 'tcx, ty::FloatVid> {\n         self.float_unification_storage.with_log(&mut self.undo_log)\n     }\n \n     #[inline]\n-    fn const_unification_table(\n-        &mut self,\n-    ) -> ut::UnificationTable<\n-        ut::InPlace<\n-            ty::ConstVid<'tcx>,\n-            &mut ut::UnificationStorage<ty::ConstVid<'tcx>>,\n-            &mut InferCtxtUndoLogs<'tcx>,\n-        >,\n-    > {\n+    fn const_unification_table(&mut self) -> UnificationTable<'_, 'tcx, ty::ConstVid<'tcx>> {\n         self.const_unification_storage.with_log(&mut self.undo_log)\n     }\n \n@@ -1429,17 +1405,14 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n     }\n \n+    /// Attempts to resolve all type/region/const variables in\n+    /// `value`. Region inference must have been run already (e.g.,\n+    /// by calling `resolve_regions_and_report_errors`). If some\n+    /// variable was never unified, an `Err` results.\n+    ///\n+    /// This method is idempotent, but it not typically not invoked\n+    /// except during the writeback phase.\n     pub fn fully_resolve<T: TypeFoldable<TyCtxt<'tcx>>>(&self, value: T) -> FixupResult<'tcx, T> {\n-        /*!\n-         * Attempts to resolve all type/region/const variables in\n-         * `value`. Region inference must have been run already (e.g.,\n-         * by calling `resolve_regions_and_report_errors`). If some\n-         * variable was never unified, an `Err` results.\n-         *\n-         * This method is idempotent, but it not typically not invoked\n-         * except during the writeback phase.\n-         */\n-\n         let value = resolve::fully_resolve(self, value);\n         assert!(\n             value.as_ref().map_or(true, |value| !value.needs_infer()),\n@@ -1754,7 +1727,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     // in this case. The typechecker should only ever report type errors involving mismatched\n     // types using one of these methods, and should not call span_err directly for such\n     // errors.\n-\n     pub fn type_error_struct_with_diag<M>(\n         &self,\n         sp: Span,"}, {"sha": "573cd91a2a2a65946704be04e95947626562eb28", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -50,7 +50,7 @@ where\n     ///\n     /// - Covariant means `a <: b`.\n     /// - Contravariant means `b <: a`.\n-    /// - Invariant means `a == b.\n+    /// - Invariant means `a == b`.\n     /// - Bivariant means that it doesn't matter.\n     ambient_variance: ty::Variance,\n "}, {"sha": "872f617474c066e616090af3a1072be297c6c96a", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -249,7 +249,7 @@ pub enum VerifyBound<'tcx> {\n /// in that case we can show `'b: 'c`. But if `'?x` winds up being something\n /// else, the bound isn't relevant.\n ///\n-/// In the [`VerifyBound`], this struct is enclosed in `Binder to account\n+/// In the [`VerifyBound`], this struct is enclosed in `Binder` to account\n /// for cases like\n ///\n /// ```rust"}, {"sha": "37994899a2038acb3eb4aac39127f73c2c684820", "filename": "compiler/rustc_interface/locales/en-US.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_interface%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_interface%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Flocales%2Fen-US.ftl?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -33,7 +33,7 @@ interface_rustc_error_fatal =\n     fatal error triggered by #[rustc_error]\n \n interface_rustc_error_unexpected_annotation =\n-    unexpected annotation used with `#[rustc_error(...)]!\n+    unexpected annotation used with `#[rustc_error(...)]`!\n \n interface_failed_writing_file =\n     failed to write file {$path}: {$error}\""}, {"sha": "322ec31fb2cff9b66418600e32efa22bc780ce76", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -166,15 +166,17 @@ pub enum DocStyle {\n     Inner,\n }\n \n-// Note that the suffix is *not* considered when deciding the `LiteralKind` in\n-// this type. This means that float literals like `1f32` are classified by this\n-// type as `Int`. (Compare against `rustc_ast::token::LitKind` and\n-// `rustc_ast::ast::LitKind.)\n+/// Enum representing the literal types supported by the lexer.\n+///\n+/// Note that the suffix is *not* considered when deciding the `LiteralKind` in\n+/// this type. This means that float literals like `1f32` are classified by this\n+/// type as `Int`. (Compare against `rustc_ast::token::LitKind` and\n+/// `rustc_ast::ast::LitKind`).\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum LiteralKind {\n     /// \"12_u8\", \"0o100\", \"0b120i99\", \"1f32\".\n     Int { base: Base, empty_int: bool },\n-    /// \"12.34f32\", \"1e3\", but not \"1f32`.\n+    /// \"12.34f32\", \"1e3\", but not \"1f32\".\n     Float { base: Base, empty_exponent: bool },\n     /// \"'a'\", \"'\\\\'\", \"'''\", \"';\"\n     Char { terminated: bool },"}, {"sha": "5b2100b5da9d1510b8e848bf17ab3a9c5be94c29", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1288,7 +1288,7 @@ declare_lint! {\n }\n \n declare_lint_pass!(\n-    /// Explains corresponding feature flag must be enabled for the `#[track_caller] attribute to\n+    /// Explains corresponding feature flag must be enabled for the `#[track_caller]` attribute to\n     /// do anything\n     UngatedAsyncFnTrackCaller => [UNGATED_ASYNC_FN_TRACK_CALLER]\n );"}, {"sha": "f5a711315ea4c5773ab6ee03139cb9204903bb8e", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -893,6 +893,23 @@ pub trait LintContext: Sized {\n                 BuiltinLintDiagnostics::ByteSliceInPackedStructWithDerive => {\n                     db.help(\"consider implementing the trait by hand, or remove the `packed` attribute\");\n                 }\n+                BuiltinLintDiagnostics::UnusedExternCrate { removal_span }=> {\n+                    db.span_suggestion(\n+                        removal_span,\n+                        \"remove it\",\n+                        \"\",\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                BuiltinLintDiagnostics::ExternCrateNotIdiomatic { vis_span, ident_span }=> {\n+                    let suggestion_span = vis_span.between(ident_span);\n+                    db.span_suggestion_verbose(\n+                        suggestion_span,\n+                        \"convert it to a `use`\",\n+                        if vis_span.is_empty() { \"use \" } else { \" use \" },\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n             }\n             // Rewrap `db`, and pass control to the user.\n             decorate(db)"}, {"sha": "7ca50f5a2db707a692dfd3488a6c76b89eafe5c2", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -17,7 +17,7 @@ use rustc_hir::{is_range_literal, Expr, ExprKind, Node};\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{\n-    self, AdtKind, DefIdTree, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n+    self, AdtKind, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n };\n use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map;"}, {"sha": "c43162f63258b5027ea66eb4fcb703b0c3b95967", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::util::elaborate_predicates_with_span;\n use rustc_middle::ty::adjustment;\n-use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::Symbol;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span};"}, {"sha": "534aff7fb620f647686e275bcbdd313584a5d3a9", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -522,6 +522,13 @@ pub enum BuiltinLintDiagnostics {\n         is_formatting_arg: bool,\n     },\n     ByteSliceInPackedStructWithDerive,\n+    UnusedExternCrate {\n+        removal_span: Span,\n+    },\n+    ExternCrateNotIdiomatic {\n+        vis_span: Span,\n+        ident_span: Span,\n+    },\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "05890628378666e3e1dc77de42e898879e341ffa", "filename": "compiler/rustc_llvm/llvm-wrapper/LLVMWrapper.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -14,6 +14,7 @@\n #include \"llvm/Support/Debug.h\"\n #include \"llvm/Support/DynamicLibrary.h\"\n #include \"llvm/Support/FormattedStream.h\"\n+#include \"llvm/Support/JSON.h\"\n #include \"llvm/Support/Host.h\"\n #include \"llvm/Support/Memory.h\"\n #include \"llvm/Support/SourceMgr.h\""}, {"sha": "4761ce83fabf18524c4255efb1cee290e70a5262", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -9,7 +9,6 @@\n #include \"llvm/Analysis/TargetLibraryInfo.h\"\n #include \"llvm/Analysis/TargetTransformInfo.h\"\n #include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n-#include \"llvm/InitializePasses.h\"\n #include \"llvm/IR/AutoUpgrade.h\"\n #include \"llvm/IR/AssemblyAnnotationWriter.h\"\n #include \"llvm/IR/IntrinsicInst.h\"\n@@ -58,22 +57,6 @@ typedef struct LLVMOpaqueTargetMachine *LLVMTargetMachineRef;\n DEFINE_STDCXX_CONVERSION_FUNCTIONS(Pass, LLVMPassRef)\n DEFINE_STDCXX_CONVERSION_FUNCTIONS(TargetMachine, LLVMTargetMachineRef)\n \n-extern \"C\" void LLVMInitializePasses() {\n-  PassRegistry &Registry = *PassRegistry::getPassRegistry();\n-  initializeCore(Registry);\n-  initializeCodeGen(Registry);\n-  initializeScalarOpts(Registry);\n-  initializeVectorization(Registry);\n-  initializeIPO(Registry);\n-  initializeAnalysis(Registry);\n-  initializeTransformUtils(Registry);\n-  initializeInstCombine(Registry);\n-#if LLVM_VERSION_LT(16, 0)\n-  initializeInstrumentation(Registry);\n-#endif\n-  initializeTarget(Registry);\n-}\n-\n extern \"C\" void LLVMTimeTraceProfilerInitialize() {\n   timeTraceProfilerInitialize(\n       /* TimeTraceGranularity */ 0,\n@@ -1004,23 +987,8 @@ LLVMRustPrintModule(LLVMModuleRef M, const char *Path, DemangleFn Demangle) {\n }\n \n extern \"C\" void LLVMRustPrintPasses() {\n-  LLVMInitializePasses();\n-  struct MyListener : PassRegistrationListener {\n-    void passEnumerate(const PassInfo *Info) {\n-      StringRef PassArg = Info->getPassArgument();\n-      StringRef PassName = Info->getPassName();\n-      if (!PassArg.empty()) {\n-        // These unsigned->signed casts could theoretically overflow, but\n-        // realistically never will (and even if, the result is implementation\n-        // defined rather plain UB).\n-        printf(\"%15.*s - %.*s\\n\", (int)PassArg.size(), PassArg.data(),\n-               (int)PassName.size(), PassName.data());\n-      }\n-    }\n-  } Listener;\n-\n-  PassRegistry *PR = PassRegistry::getPassRegistry();\n-  PR->enumerateWith(&Listener);\n+  PassBuilder PB;\n+  PB.printPassNames(outs());\n }\n \n extern \"C\" void LLVMRustRunRestrictionPass(LLVMModuleRef M, char **Symbols,"}, {"sha": "e3493caaaf74e35b1308166a3696e92eb345d3c2", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1751,6 +1751,19 @@ LLVMRustModuleCost(LLVMModuleRef M) {\n   return std::distance(std::begin(f), std::end(f));\n }\n \n+extern \"C\" void\n+LLVMRustModuleInstructionStats(LLVMModuleRef M, RustStringRef Str)\n+{\n+  RawRustStringOstream OS(Str);\n+  llvm::json::OStream JOS(OS);\n+  auto Module = unwrap(M);\n+\n+  JOS.object([&] {\n+    JOS.attribute(\"module\", Module->getName());\n+    JOS.attribute(\"total\", Module->getInstructionCount());\n+  });\n+}\n+\n // Vector reductions:\n extern \"C\" LLVMValueRef\n LLVMRustBuildVectorReduceFAdd(LLVMBuilderRef B, LLVMValueRef Acc, LLVMValueRef Src) {"}, {"sha": "8d017d149f62901fefa99176f30d39e1e653e6fc", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -42,6 +42,12 @@ fn decodable_body(\n     }\n     let ty_name = s.ast().ident.to_string();\n     let decode_body = match s.variants() {\n+        [] => {\n+            let message = format!(\"`{}` has no variants to decode\", ty_name);\n+            quote! {\n+                panic!(#message)\n+            }\n+        }\n         [vi] => vi.construct(|field, _index| decode_field(field)),\n         variants => {\n             let match_inner: TokenStream = variants\n@@ -139,6 +145,11 @@ fn encodable_body(\n     });\n \n     let encode_body = match s.variants() {\n+        [] => {\n+            quote! {\n+                match *self {}\n+            }\n+        }\n         [_] => {\n             let encode_inner = s.each_variant(|vi| {\n                 vi.bindings()\n@@ -160,6 +171,23 @@ fn encodable_body(\n             }\n         }\n         _ => {\n+            let disc = {\n+                let mut variant_idx = 0usize;\n+                let encode_inner = s.each_variant(|_| {\n+                    let result = quote! {\n+                        #variant_idx\n+                    };\n+                    variant_idx += 1;\n+                    result\n+                });\n+                quote! {\n+                    let disc = match *self {\n+                        #encode_inner\n+                    };\n+                    ::rustc_serialize::Encoder::emit_usize(__encoder, disc);\n+                }\n+            };\n+\n             let mut variant_idx = 0usize;\n             let encode_inner = s.each_variant(|vi| {\n                 let encode_fields: TokenStream = vi\n@@ -176,26 +204,11 @@ fn encodable_body(\n                         result\n                     })\n                     .collect();\n-\n-                let result = if !vi.bindings().is_empty() {\n-                    quote! {\n-                        ::rustc_serialize::Encoder::emit_enum_variant(\n-                            __encoder,\n-                            #variant_idx,\n-                            |__encoder| { #encode_fields }\n-                        )\n-                    }\n-                } else {\n-                    quote! {\n-                        ::rustc_serialize::Encoder::emit_fieldless_enum_variant::<#variant_idx>(\n-                            __encoder,\n-                        )\n-                    }\n-                };\n                 variant_idx += 1;\n-                result\n+                encode_fields\n             });\n             quote! {\n+                #disc\n                 match *self {\n                     #encode_inner\n                 }"}, {"sha": "c48e681eb94ad610f46cbddb9817c7391dc674a7", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -789,6 +789,9 @@ fn get_metadata_section<'p>(\n                 loader.get_dylib_metadata(target, filename).map_err(MetadataError::LoadFailure)?;\n             // The header is uncompressed\n             let header_len = METADATA_HEADER.len();\n+            // header + u32 length of data\n+            let data_start = header_len + 4;\n+\n             debug!(\"checking {} bytes of metadata-version stamp\", header_len);\n             let header = &buf[..cmp::min(header_len, buf.len())];\n             if header != METADATA_HEADER {\n@@ -798,8 +801,14 @@ fn get_metadata_section<'p>(\n                 )));\n             }\n \n+            // Length of the compressed stream - this allows linkers to pad the section if they want\n+            let Ok(len_bytes) = <[u8; 4]>::try_from(&buf[header_len..cmp::min(data_start, buf.len())]) else {\n+                return Err(MetadataError::LoadFailure(\"invalid metadata length found\".to_string()));\n+            };\n+            let compressed_len = u32::from_be_bytes(len_bytes) as usize;\n+\n             // Header is okay -> inflate the actual metadata\n-            let compressed_bytes = &buf[header_len..];\n+            let compressed_bytes = &buf[data_start..(data_start + compressed_len)];\n             debug!(\"inflating {} bytes of compressed metadata\", compressed_bytes.len());\n             // Assume the decompressed data will be at least the size of the compressed data, so we\n             // don't have to grow the buffer as much."}, {"sha": "3ab01f7809b041c1ec829500523977fd22687a1b", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1101,37 +1101,18 @@ fn should_encode_const(def_kind: DefKind) -> bool {\n     }\n }\n \n-fn should_encode_trait_impl_trait_tys(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    if tcx.def_kind(def_id) != DefKind::AssocFn {\n-        return false;\n-    }\n-\n-    let Some(item) = tcx.opt_associated_item(def_id) else { return false; };\n-    if item.container != ty::AssocItemContainer::ImplContainer {\n-        return false;\n+// We only encode impl trait in trait when using `lower-impl-trait-in-trait-to-assoc-ty` unstable\n+// option.\n+fn should_encode_fn_impl_trait_in_trait<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+    if tcx.sess.opts.unstable_opts.lower_impl_trait_in_trait_to_assoc_ty\n+        && let Some(assoc_item) = tcx.opt_associated_item(def_id)\n+        && assoc_item.container == ty::AssocItemContainer::TraitContainer\n+        && assoc_item.kind == ty::AssocKind::Fn\n+    {\n+        true\n+    } else {\n+        false\n     }\n-\n-    let Some(trait_item_def_id) = item.trait_item_def_id else { return false; };\n-\n-    // FIXME(RPITIT): This does a somewhat manual walk through the signature\n-    // of the trait fn to look for any RPITITs, but that's kinda doing a lot\n-    // of work. We can probably remove this when we refactor RPITITs to be\n-    // associated types.\n-    tcx.fn_sig(trait_item_def_id).subst_identity().skip_binder().output().walk().any(|arg| {\n-        if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Alias(ty::Projection, data) = ty.kind()\n-            && tcx.def_kind(data.def_id) == DefKind::ImplTraitPlaceholder\n-        {\n-            true\n-        } else {\n-            false\n-        }\n-    })\n-}\n-\n-// Return `false` to avoid encoding impl trait in trait, while we don't use the query.\n-fn should_encode_fn_impl_trait_in_trait<'tcx>(_tcx: TyCtxt<'tcx>, _def_id: DefId) -> bool {\n-    false\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n@@ -1211,7 +1192,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             if let DefKind::Enum | DefKind::Struct | DefKind::Union = def_kind {\n                 self.encode_info_for_adt(def_id);\n             }\n-            if should_encode_trait_impl_trait_tys(tcx, def_id)\n+            if tcx.impl_method_has_trait_impl_trait_tys(def_id)\n                 && let Ok(table) = self.tcx.collect_return_position_impl_trait_in_trait_tys(def_id)\n             {\n                 record!(self.tables.trait_impl_trait_tys[def_id] <- table);\n@@ -1640,7 +1621,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn encode_info_for_closure(&mut self, def_id: LocalDefId) {\n         // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n-        // including on the signature, which is inferred in `typeck.\n+        // including on the signature, which is inferred in `typeck`.\n         let typeck_result: &'tcx ty::TypeckResults<'tcx> = self.tcx.typeck(def_id);\n         let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let ty = typeck_result.node_type(hir_id);"}, {"sha": "1d2541a67881972cc57ef405111953227756e4f3", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -55,13 +55,13 @@ pub(crate) fn rustc_version() -> String {\n /// Metadata encoding version.\n /// N.B., increment this if you change the format of metadata such that\n /// the rustc version can't be found to compare with `rustc_version()`.\n-const METADATA_VERSION: u8 = 6;\n+const METADATA_VERSION: u8 = 7;\n \n /// Metadata header which includes `METADATA_VERSION`.\n ///\n-/// This header is followed by the position of the `CrateRoot`,\n-/// which is encoded as a 32-bit big-endian unsigned integer,\n-/// and further followed by the rustc version string.\n+/// This header is followed by the length of the compressed data, then\n+/// the position of the `CrateRoot`, which is encoded as a 32-bit big-endian\n+/// unsigned integer, and further followed by the rustc version string.\n pub const METADATA_HEADER: &[u8] = &[b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n /// A value of type T referred to by its absolute position"}, {"sha": "62e44b6298baa16522755d5eaa0fe9900cf62c1a", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -116,6 +116,7 @@ macro_rules! arena_types {\n             [] bit_set_u32: rustc_index::bit_set::BitSet<u32>,\n             [] external_constraints: rustc_middle::traits::solve::ExternalConstraintsData<'tcx>,\n             [decode] doc_link_resolutions: rustc_hir::def::DocLinkResMap,\n+            [] closure_kind_origin: (rustc_span::Span, rustc_middle::hir::place::Place<'tcx>),\n         ]);\n     )\n }"}, {"sha": "43eef1c770c96fe6e8d7809c256f7c6cc85c192a", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,5 +1,5 @@\n use crate::hir::{ModuleItems, Owner};\n-use crate::ty::{DefIdTree, TyCtxt};\n+use crate::ty::TyCtxt;\n use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -902,6 +902,11 @@ impl<'hir> Map<'hir> {\n         self.opt_ident(id).map(|ident| ident.span)\n     }\n \n+    #[inline]\n+    pub fn ident(self, id: HirId) -> Ident {\n+        self.opt_ident(id).unwrap()\n+    }\n+\n     #[inline]\n     pub fn opt_name(self, id: HirId) -> Option<Symbol> {\n         self.opt_ident(id).map(|ident| ident.name)"}, {"sha": "6706b9db3f5449f844d11becdf47741fd0cce497", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -7,7 +7,7 @@ pub mod nested_filter;\n pub mod place;\n \n use crate::ty::query::Providers;\n-use crate::ty::{DefIdTree, ImplSubject, TyCtxt};\n+use crate::ty::{ImplSubject, TyCtxt};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n@@ -64,13 +64,17 @@ impl ModuleItems {\n         self.foreign_items.iter().copied()\n     }\n \n-    pub fn definitions(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n+    pub fn owners(&self) -> impl Iterator<Item = OwnerId> + '_ {\n         self.items\n             .iter()\n-            .map(|id| id.owner_id.def_id)\n-            .chain(self.trait_items.iter().map(|id| id.owner_id.def_id))\n-            .chain(self.impl_items.iter().map(|id| id.owner_id.def_id))\n-            .chain(self.foreign_items.iter().map(|id| id.owner_id.def_id))\n+            .map(|id| id.owner_id)\n+            .chain(self.trait_items.iter().map(|id| id.owner_id))\n+            .chain(self.impl_items.iter().map(|id| id.owner_id))\n+            .chain(self.foreign_items.iter().map(|id| id.owner_id))\n+    }\n+\n+    pub fn definitions(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n+        self.owners().map(|id| id.def_id)\n     }\n \n     pub fn par_items(&self, f: impl Fn(ItemId) + Send + Sync) {\n@@ -173,6 +177,7 @@ pub fn provide(providers: &mut Providers) {\n         }\n     };\n     providers.opt_def_kind = |tcx, def_id| tcx.hir().opt_def_kind(def_id.expect_local());\n+    providers.opt_rpitit_info = |_, _| None;\n     providers.all_local_trait_impls = |tcx, ()| &tcx.resolutions(()).trait_impls;\n     providers.expn_that_defined = |tcx, id| {\n         let id = id.expect_local();"}, {"sha": "7f8fc17744dc9f459111ce18e30eb054644445df", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -123,6 +123,11 @@ impl<'tcx> CanonicalVarInfo<'tcx> {\n         self.kind.universe()\n     }\n \n+    #[must_use]\n+    pub fn with_updated_universe(self, ui: ty::UniverseIndex) -> CanonicalVarInfo<'tcx> {\n+        CanonicalVarInfo { kind: self.kind.with_updated_universe(ui) }\n+    }\n+\n     pub fn is_existential(&self) -> bool {\n         match self.kind {\n             CanonicalVarKind::Ty(_) => true,\n@@ -133,6 +138,28 @@ impl<'tcx> CanonicalVarInfo<'tcx> {\n             CanonicalVarKind::PlaceholderConst(_, _) => false,\n         }\n     }\n+\n+    pub fn is_region(&self) -> bool {\n+        match self.kind {\n+            CanonicalVarKind::Region(_) | CanonicalVarKind::PlaceholderRegion(_) => true,\n+            CanonicalVarKind::Ty(_)\n+            | CanonicalVarKind::PlaceholderTy(_)\n+            | CanonicalVarKind::Const(_, _)\n+            | CanonicalVarKind::PlaceholderConst(_, _) => false,\n+        }\n+    }\n+\n+    pub fn expect_anon_placeholder(self) -> u32 {\n+        match self.kind {\n+            CanonicalVarKind::Ty(_)\n+            | CanonicalVarKind::Region(_)\n+            | CanonicalVarKind::Const(_, _) => bug!(\"expected placeholder: {self:?}\"),\n+\n+            CanonicalVarKind::PlaceholderRegion(placeholder) => placeholder.name.expect_anon(),\n+            CanonicalVarKind::PlaceholderTy(placeholder) => placeholder.name.expect_anon(),\n+            CanonicalVarKind::PlaceholderConst(placeholder, _) => placeholder.name.as_u32(),\n+        }\n+    }\n }\n \n /// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n@@ -177,6 +204,38 @@ impl<'tcx> CanonicalVarKind<'tcx> {\n             CanonicalVarKind::PlaceholderConst(placeholder, _) => placeholder.universe,\n         }\n     }\n+\n+    /// Replaces the universe of this canonical variable with `ui`.\n+    ///\n+    /// In case this is a float or int variable, this causes an ICE if\n+    /// the updated universe is not the root.\n+    pub fn with_updated_universe(self, ui: ty::UniverseIndex) -> CanonicalVarKind<'tcx> {\n+        match self {\n+            CanonicalVarKind::Ty(kind) => match kind {\n+                CanonicalTyVarKind::General(_) => {\n+                    CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui))\n+                }\n+                CanonicalTyVarKind::Int | CanonicalTyVarKind::Float => {\n+                    assert_eq!(ui, ty::UniverseIndex::ROOT);\n+                    CanonicalVarKind::Ty(kind)\n+                }\n+            },\n+            CanonicalVarKind::PlaceholderTy(placeholder) => {\n+                CanonicalVarKind::PlaceholderTy(ty::Placeholder { universe: ui, ..placeholder })\n+            }\n+            CanonicalVarKind::Region(_) => CanonicalVarKind::Region(ui),\n+            CanonicalVarKind::PlaceholderRegion(placeholder) => {\n+                CanonicalVarKind::PlaceholderRegion(ty::Placeholder { universe: ui, ..placeholder })\n+            }\n+            CanonicalVarKind::Const(_, ty) => CanonicalVarKind::Const(ui, ty),\n+            CanonicalVarKind::PlaceholderConst(placeholder, ty) => {\n+                CanonicalVarKind::PlaceholderConst(\n+                    ty::Placeholder { universe: ui, ..placeholder },\n+                    ty,\n+                )\n+            }\n+        }\n+    }\n }\n \n /// Rust actually has more than one category of type variables;\n@@ -213,7 +272,8 @@ pub struct QueryResponse<'tcx, R> {\n     pub value: R,\n }\n \n-#[derive(Clone, Debug, Default, HashStable, TypeFoldable, TypeVisitable, Lift)]\n+#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct QueryRegionConstraints<'tcx> {\n     pub outlives: Vec<QueryOutlivesConstraint<'tcx>>,\n     pub member_constraints: Vec<MemberConstraint<'tcx>>,"}, {"sha": "2db59f37f4072d1b0a49cd24de531bdc8729d3e2", "filename": "compiler/rustc_middle/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -12,7 +12,8 @@ use rustc_span::Span;\n /// ```text\n /// R0 member of [O1..On]\n /// ```\n-#[derive(Debug, Clone, HashStable, TypeFoldable, TypeVisitable, Lift)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct MemberConstraint<'tcx> {\n     /// The `DefId` and substs of the opaque type causing this constraint.\n     /// Used for error reporting."}, {"sha": "171cf1c1ab1739ae466033fc529bf6f3b6abce98", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,7 +1,7 @@\n //! A pass that checks to make sure private fields and methods aren't used\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n-use crate::ty::{DefIdTree, TyCtxt, Visibility};\n+use crate::ty::{TyCtxt, Visibility};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n@@ -112,7 +112,7 @@ impl EffectiveVisibilities {\n         &mut self,\n         def_id: LocalDefId,\n         eff_vis: &EffectiveVisibility,\n-        tree: impl DefIdTree,\n+        tcx: TyCtxt<'_>,\n     ) {\n         use std::collections::hash_map::Entry;\n         match self.map.entry(def_id) {\n@@ -122,7 +122,7 @@ impl EffectiveVisibilities {\n                     let vis_at_level = eff_vis.at_level(l);\n                     let old_vis_at_level = old_eff_vis.at_level_mut(l);\n                     if vis_at_level != old_vis_at_level\n-                        && vis_at_level.is_at_least(*old_vis_at_level, tree)\n+                        && vis_at_level.is_at_least(*old_vis_at_level, tcx)\n                     {\n                         *old_vis_at_level = *vis_at_level\n                     }\n@@ -219,7 +219,7 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n         lazy_private_vis: impl FnOnce() -> Visibility,\n         inherited_effective_vis: EffectiveVisibility,\n         level: Level,\n-        tree: impl DefIdTree,\n+        tcx: TyCtxt<'_>,\n     ) -> bool {\n         let mut changed = false;\n         let mut current_effective_vis = self\n@@ -240,7 +240,7 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n                     && level != l)\n                 {\n                     calculated_effective_vis =\n-                        if nominal_vis.is_at_least(inherited_effective_vis_at_level, tree) {\n+                        if nominal_vis.is_at_least(inherited_effective_vis_at_level, tcx) {\n                             inherited_effective_vis_at_level\n                         } else {\n                             nominal_vis\n@@ -249,7 +249,7 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n                 // effective visibility can't be decreased at next update call for the\n                 // same id\n                 if *current_effective_vis_at_level != calculated_effective_vis\n-                    && calculated_effective_vis.is_at_least(*current_effective_vis_at_level, tree)\n+                    && calculated_effective_vis.is_at_least(*current_effective_vis_at_level, tcx)\n                 {\n                     changed = true;\n                     *current_effective_vis_at_level = calculated_effective_vis;"}, {"sha": "b61f7806b7a993cbab4801dc0f868cb532507582", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -3,7 +3,7 @@\n \n pub use self::StabilityLevel::*;\n \n-use crate::ty::{self, DefIdTree, TyCtxt};\n+use crate::ty::{self, TyCtxt};\n use rustc_ast::NodeId;\n use rustc_attr::{self as attr, ConstStability, DefaultBodyStability, Deprecation, Stability};\n use rustc_data_structures::fx::FxHashMap;"}, {"sha": "48375ed301d22cd3331e88e91ed05787b88e2087", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 67, "deletions": 15, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -8,7 +8,8 @@ mod tests;\n use std::borrow::Cow;\n use std::fmt;\n use std::hash;\n-use std::ops::Range;\n+use std::hash::Hash;\n+use std::ops::{Deref, DerefMut, Range};\n use std::ptr;\n \n use either::{Left, Right};\n@@ -29,6 +30,39 @@ use provenance_map::*;\n \n pub use init_mask::{InitChunk, InitChunkIter};\n \n+/// Functionality required for the bytes of an `Allocation`.\n+pub trait AllocBytes:\n+    Clone + fmt::Debug + Eq + PartialEq + Hash + Deref<Target = [u8]> + DerefMut<Target = [u8]>\n+{\n+    /// Adjust the bytes to the specified alignment -- by default, this is a no-op.\n+    fn adjust_to_align(self, _align: Align) -> Self;\n+\n+    /// Create an `AllocBytes` from a slice of `u8`.\n+    fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, _align: Align) -> Self;\n+\n+    /// Create a zeroed `AllocBytes` of the specified size and alignment;\n+    /// call the callback error handler if there is an error in allocating the memory.\n+    fn zeroed(size: Size, _align: Align) -> Option<Self>;\n+}\n+\n+// Default `bytes` for `Allocation` is a `Box<[u8]>`.\n+impl AllocBytes for Box<[u8]> {\n+    fn adjust_to_align(self, _align: Align) -> Self {\n+        self\n+    }\n+\n+    fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, _align: Align) -> Self {\n+        Box::<[u8]>::from(slice.into())\n+    }\n+\n+    fn zeroed(size: Size, _align: Align) -> Option<Self> {\n+        let bytes = Box::<[u8]>::try_new_zeroed_slice(size.bytes_usize()).ok()?;\n+        // SAFETY: the box was zero-allocated, which is a valid initial value for Box<[u8]>\n+        let bytes = unsafe { bytes.assume_init() };\n+        Some(bytes)\n+    }\n+}\n+\n /// This type represents an Allocation in the Miri/CTFE core engine.\n ///\n /// Its public API is rather low-level, working directly with allocation offsets and a custom error\n@@ -38,10 +72,10 @@ pub use init_mask::{InitChunk, InitChunkIter};\n // hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n #[derive(Clone, Eq, PartialEq, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n-pub struct Allocation<Prov: Provenance = AllocId, Extra = ()> {\n+pub struct Allocation<Prov: Provenance = AllocId, Extra = (), Bytes = Box<[u8]>> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer.\n-    bytes: Box<[u8]>,\n+    bytes: Bytes,\n     /// Maps from byte addresses to extra provenance data for each pointer.\n     /// Only the first byte of a pointer is inserted into the map; i.e.,\n     /// every entry in this map applies to `pointer_size` consecutive bytes starting\n@@ -220,14 +254,27 @@ impl AllocRange {\n }\n \n // The constructors are all without extra; the extra gets added by a machine hook later.\n-impl<Prov: Provenance> Allocation<Prov> {\n+impl<Prov: Provenance, Bytes: AllocBytes> Allocation<Prov, (), Bytes> {\n+    /// Creates an allocation from an existing `Bytes` value - this is needed for miri FFI support\n+    pub fn from_raw_bytes(bytes: Bytes, align: Align, mutability: Mutability) -> Self {\n+        let size = Size::from_bytes(bytes.len());\n+        Self {\n+            bytes,\n+            provenance: ProvenanceMap::new(),\n+            init_mask: InitMask::new(size, true),\n+            align,\n+            mutability,\n+            extra: (),\n+        }\n+    }\n+\n     /// Creates an allocation initialized by the given bytes\n     pub fn from_bytes<'a>(\n         slice: impl Into<Cow<'a, [u8]>>,\n         align: Align,\n         mutability: Mutability,\n     ) -> Self {\n-        let bytes = Box::<[u8]>::from(slice.into());\n+        let bytes = Bytes::from_bytes(slice, align);\n         let size = Size::from_bytes(bytes.len());\n         Self {\n             bytes,\n@@ -248,7 +295,7 @@ impl<Prov: Provenance> Allocation<Prov> {\n     ///\n     /// If `panic_on_fail` is true, this will never return `Err`.\n     pub fn uninit<'tcx>(size: Size, align: Align, panic_on_fail: bool) -> InterpResult<'tcx, Self> {\n-        let bytes = Box::<[u8]>::try_new_zeroed_slice(size.bytes_usize()).map_err(|_| {\n+        let bytes = Bytes::zeroed(size, align).ok_or_else(|| {\n             // This results in an error that can happen non-deterministically, since the memory\n             // available to the compiler can change between runs. Normally queries are always\n             // deterministic. However, we can be non-deterministic here because all uses of const\n@@ -262,8 +309,7 @@ impl<Prov: Provenance> Allocation<Prov> {\n             });\n             InterpError::ResourceExhaustion(ResourceExhaustionInfo::MemoryExhausted)\n         })?;\n-        // SAFETY: the box was zero-allocated, which is a valid initial value for Box<[u8]>\n-        let bytes = unsafe { bytes.assume_init() };\n+\n         Ok(Allocation {\n             bytes,\n             provenance: ProvenanceMap::new(),\n@@ -275,17 +321,19 @@ impl<Prov: Provenance> Allocation<Prov> {\n     }\n }\n \n-impl Allocation {\n+impl<Bytes: AllocBytes> Allocation<AllocId, (), Bytes> {\n     /// Adjust allocation from the ones in tcx to a custom Machine instance\n     /// with a different Provenance and Extra type.\n     pub fn adjust_from_tcx<Prov: Provenance, Extra, Err>(\n         self,\n         cx: &impl HasDataLayout,\n         extra: Extra,\n         mut adjust_ptr: impl FnMut(Pointer<AllocId>) -> Result<Pointer<Prov>, Err>,\n-    ) -> Result<Allocation<Prov, Extra>, Err> {\n-        // Compute new pointer provenance, which also adjusts the bytes.\n-        let mut bytes = self.bytes;\n+    ) -> Result<Allocation<Prov, Extra, Bytes>, Err> {\n+        // Compute new pointer provenance, which also adjusts the bytes, and realign the pointer if\n+        // necessary.\n+        let mut bytes = self.bytes.adjust_to_align(self.align);\n+\n         let mut new_provenance = Vec::with_capacity(self.provenance.ptrs().len());\n         let ptr_size = cx.data_layout().pointer_size.bytes_usize();\n         let endian = cx.data_layout().endian;\n@@ -311,7 +359,7 @@ impl Allocation {\n }\n \n /// Raw accessors. Provide access to otherwise private bytes.\n-impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n+impl<Prov: Provenance, Extra, Bytes: AllocBytes> Allocation<Prov, Extra, Bytes> {\n     pub fn len(&self) -> usize {\n         self.bytes.len()\n     }\n@@ -340,7 +388,11 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n }\n \n /// Byte accessors.\n-impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n+impl<Prov: Provenance, Extra, Bytes: AllocBytes> Allocation<Prov, Extra, Bytes> {\n+    pub fn base_addr(&self) -> *const u8 {\n+        self.bytes.as_ptr()\n+    }\n+\n     /// This is the entirely abstraction-violating way to just grab the raw bytes without\n     /// caring about provenance or initialization.\n     ///\n@@ -412,7 +464,7 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n }\n \n /// Reading and writing.\n-impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n+impl<Prov: Provenance, Extra, Bytes: AllocBytes> Allocation<Prov, Extra, Bytes> {\n     /// Sets the init bit for the given range.\n     fn mark_init(&mut self, range: AllocRange, is_init: bool) {\n         if range.size.bytes() == 0 {"}, {"sha": "1766d7a66980461e51b54de99105b39dd89b74f9", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -127,8 +127,8 @@ pub use self::error::{\n pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar};\n \n pub use self::allocation::{\n-    alloc_range, AllocError, AllocRange, AllocResult, Allocation, ConstAllocation, InitChunk,\n-    InitChunkIter,\n+    alloc_range, AllocBytes, AllocError, AllocRange, AllocResult, Allocation, ConstAllocation,\n+    InitChunk, InitChunkIter,\n };\n \n pub use self::pointer::{Pointer, PointerArithmetic, Provenance};"}, {"sha": "6e6bb8ce95e53299d11d62e784e233e60cb8cd7f", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -10,7 +10,7 @@ use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable};\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::visit::{TypeVisitable, TypeVisitableExt, TypeVisitor};\n-use crate::ty::{self, DefIdTree, List, Ty, TyCtxt};\n+use crate::ty::{self, List, Ty, TyCtxt};\n use crate::ty::{AdtDef, InstanceDef, ScalarInt, UserTypeAnnotationIndex};\n use crate::ty::{GenericArg, InternalSubsts, SubstsRef};\n \n@@ -2908,7 +2908,7 @@ fn pretty_print_const_value<'tcx>(\n             // the `destructure_const` query with an empty `ty::ParamEnv` without\n             // introducing ICEs (e.g. via `layout_of`) from missing bounds.\n             // E.g. `transmute([0usize; 2]): (u8, *mut T)` needs to know `T: Sized`\n-            // to be able to destructure the tuple into `(0u8, *mut T)\n+            // to be able to destructure the tuple into `(0u8, *mut T)`\n             //\n             // FIXME(eddyb) for `--emit=mir`/`-Z dump-mir`, we should provide the\n             // correct `ty::ParamEnv` to allow printing *all* constant values."}, {"sha": "d8829e3e782c5c40b931714cfa30d717cc9f9f55", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -12,8 +12,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{\n-    alloc_range, read_target_uint, AllocId, Allocation, ConstAllocation, ConstValue, GlobalAlloc,\n-    Pointer, Provenance,\n+    alloc_range, read_target_uint, AllocBytes, AllocId, Allocation, ConstAllocation, ConstValue,\n+    GlobalAlloc, Pointer, Provenance,\n };\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n@@ -787,21 +787,21 @@ pub fn write_allocations<'tcx>(\n /// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n /// characters or characters whose value is larger than 127) with a `.`\n /// This also prints provenance adequately.\n-pub fn display_allocation<'a, 'tcx, Prov: Provenance, Extra>(\n+pub fn display_allocation<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n     tcx: TyCtxt<'tcx>,\n-    alloc: &'a Allocation<Prov, Extra>,\n-) -> RenderAllocation<'a, 'tcx, Prov, Extra> {\n+    alloc: &'a Allocation<Prov, Extra, Bytes>,\n+) -> RenderAllocation<'a, 'tcx, Prov, Extra, Bytes> {\n     RenderAllocation { tcx, alloc }\n }\n \n #[doc(hidden)]\n-pub struct RenderAllocation<'a, 'tcx, Prov: Provenance, Extra> {\n+pub struct RenderAllocation<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes> {\n     tcx: TyCtxt<'tcx>,\n-    alloc: &'a Allocation<Prov, Extra>,\n+    alloc: &'a Allocation<Prov, Extra, Bytes>,\n }\n \n-impl<'a, 'tcx, Prov: Provenance, Extra> std::fmt::Display\n-    for RenderAllocation<'a, 'tcx, Prov, Extra>\n+impl<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes> std::fmt::Display\n+    for RenderAllocation<'a, 'tcx, Prov, Extra, Bytes>\n {\n     fn fmt(&self, w: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         let RenderAllocation { tcx, alloc } = *self;\n@@ -845,9 +845,9 @@ fn write_allocation_newline(\n /// The `prefix` argument allows callers to add an arbitrary prefix before each line (even if there\n /// is only one line). Note that your prefix should contain a trailing space as the lines are\n /// printed directly after it.\n-fn write_allocation_bytes<'tcx, Prov: Provenance, Extra>(\n+fn write_allocation_bytes<'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n     tcx: TyCtxt<'tcx>,\n-    alloc: &Allocation<Prov, Extra>,\n+    alloc: &Allocation<Prov, Extra, Bytes>,\n     w: &mut dyn std::fmt::Write,\n     prefix: &str,\n ) -> std::fmt::Result {"}, {"sha": "28a3b51b7fc925cfaa3bc3f0de86fdaf3cba0052", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -11,7 +11,7 @@ use std::io::{self, Write};\n pub const TOOLTIP_INDENT: &str = \"    \";\n \n const CARET: char = '\\u{2038}'; // Unicode `CARET`\n-const ANNOTATION_LEFT_BRACKET: char = '\\u{298a}'; // Unicode `Z NOTATION RIGHT BINDING BRACKET\n+const ANNOTATION_LEFT_BRACKET: char = '\\u{298a}'; // Unicode `Z NOTATION RIGHT BINDING BRACKET`\n const ANNOTATION_RIGHT_BRACKET: char = '\\u{2989}'; // Unicode `Z NOTATION LEFT BINDING BRACKET`\n const NEW_LINE_SPAN: &str = \"</span>\\n<span class=\\\"line\\\">\";\n const HEADER: &str = r#\"<!DOCTYPE html>"}, {"sha": "78ee8a6a8fd64aacbe6573f19dd116d35097e062", "filename": "compiler/rustc_middle/src/query/keys.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -4,8 +4,9 @@ use crate::infer::canonical::Canonical;\n use crate::mir;\n use crate::traits;\n use crate::ty::fast_reject::SimplifiedType;\n+use crate::ty::layout::{TyAndLayout, ValidityRequirement};\n use crate::ty::subst::{GenericArg, SubstsRef};\n-use crate::ty::{self, layout::TyAndLayout, Ty, TyCtxt};\n+use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::hir_id::{HirId, OwnerId};\n use rustc_query_system::query::{DefaultCacheSelector, SingleCacheSelector, VecCacheSelector};\n@@ -696,3 +697,24 @@ impl Key for HirId {\n         None\n     }\n }\n+\n+impl<'tcx> Key for (ValidityRequirement, ty::ParamEnvAnd<'tcx, Ty<'tcx>>) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n+    // Just forward to `Ty<'tcx>`\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+\n+    fn ty_adt_id(&self) -> Option<DefId> {\n+        match self.1.value.kind() {\n+            ty::Adt(adt, _) => Some(adt.did()),\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "5133da3429a9c54b6de756ee5e4491300c79ec0f", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -90,6 +90,7 @@ rustc_queries! {\n     /// Definitions that were generated with no HIR, would be feeded to return `None`.\n     query opt_local_def_id_to_hir_id(key: LocalDefId) -> Option<hir::HirId>{\n         desc { |tcx| \"getting HIR ID of `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        feedable\n     }\n \n     /// Gives access to the HIR node's parent for the HIR owner `key`.\n@@ -166,6 +167,7 @@ rustc_queries! {\n         }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n+        feedable\n     }\n \n     query collect_return_position_impl_trait_in_trait_tys(key: DefId)\n@@ -222,6 +224,7 @@ rustc_queries! {\n         arena_cache\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n+        feedable\n     }\n \n     /// Maps from the `DefId` of an item (trait/struct/enum/fn) to the\n@@ -264,6 +267,7 @@ rustc_queries! {\n         desc { |tcx| \"finding item bounds for `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n+        feedable\n     }\n \n     /// Elaborated version of the predicates from `explicit_item_bounds`.\n@@ -475,14 +479,10 @@ rustc_queries! {\n         }\n     }\n \n-    query symbols_for_closure_captures(\n-        key: (LocalDefId, LocalDefId)\n-    ) -> &'tcx Vec<rustc_span::Symbol> {\n-        arena_cache\n+    query closure_typeinfo(key: LocalDefId) -> ty::ClosureTypeInfo<'tcx> {\n         desc {\n-            |tcx| \"finding symbols for captures of closure `{}` in `{}`\",\n-            tcx.def_path_str(key.1.to_def_id()),\n-            tcx.def_path_str(key.0.to_def_id())\n+            |tcx| \"finding symbols for captures of closure `{}`\",\n+            tcx.def_path_str(key.to_def_id())\n         }\n     }\n \n@@ -592,6 +592,7 @@ rustc_queries! {\n         desc { |tcx| \"computing explicit predicates of `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n+        feedable\n     }\n \n     /// Returns the inferred outlives predicates (e.g., for `struct\n@@ -600,6 +601,7 @@ rustc_queries! {\n         desc { |tcx| \"computing inferred outlives predicates of `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n+        feedable\n     }\n \n     /// Maps from the `DefId` of a trait to the list of\n@@ -732,6 +734,7 @@ rustc_queries! {\n         desc { |tcx| \"computing associated item data for `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n+        feedable\n     }\n \n     /// Collects the associated items defined on a trait or impl.\n@@ -1146,6 +1149,15 @@ rustc_queries! {\n         desc { |tcx| \"looking up definition kind of `{}`\", tcx.def_path_str(def_id) }\n         cache_on_disk_if { def_id.is_local() }\n         separate_provide_extern\n+        feedable\n+    }\n+\n+    /// The `opt_rpitit_info` query returns the pair of the def id of the function where the RPIT\n+    /// is defined and the opaque def id if any.\n+    query opt_rpitit_info(def_id: DefId) -> Option<ty::ImplTraitInTraitData> {\n+        desc { |tcx| \"opt_rpitit_info `{}`\", tcx.def_path_str(def_id) }\n+        cache_on_disk_if { def_id.is_local() }\n+        feedable\n     }\n \n     /// Gets the span for the definition.\n@@ -1161,6 +1173,7 @@ rustc_queries! {\n         desc { |tcx| \"looking up span for `{}`'s identifier\", tcx.def_path_str(def_id) }\n         cache_on_disk_if { def_id.is_local() }\n         separate_provide_extern\n+        feedable\n     }\n \n     query lookup_stability(def_id: DefId) -> Option<attr::Stability> {\n@@ -1502,6 +1515,7 @@ rustc_queries! {\n         desc { |tcx| \"looking up whether `{}` is a default impl\", tcx.def_path_str(def_id) }\n         cache_on_disk_if { def_id.is_local() }\n         separate_provide_extern\n+        feedable\n     }\n \n     query check_well_formed(key: hir::OwnerId) -> () {\n@@ -1658,7 +1672,7 @@ rustc_queries! {\n \n     /// Does lifetime resolution on items. Importantly, we can't resolve\n     /// lifetimes directly on things like trait methods, because of trait params.\n-    /// See `rustc_resolve::late::lifetimes for details.\n+    /// See `rustc_resolve::late::lifetimes` for details.\n     query resolve_bound_vars(_: hir::OwnerId) -> &'tcx ResolveBoundVars {\n         arena_cache\n         desc { \"resolving lifetimes\" }\n@@ -1699,6 +1713,7 @@ rustc_queries! {\n     query visibility(def_id: DefId) -> ty::Visibility<DefId> {\n         desc { |tcx| \"computing visibility of `{}`\", tcx.def_path_str(def_id) }\n         separate_provide_extern\n+        feedable\n     }\n \n     query inhabited_predicate_adt(key: DefId) -> ty::inhabitedness::InhabitedPredicate<'tcx> {\n@@ -1830,9 +1845,6 @@ rustc_queries! {\n     query maybe_unused_trait_imports(_: ()) -> &'tcx FxIndexSet<LocalDefId> {\n         desc { \"fetching potentially unused trait imports\" }\n     }\n-    query maybe_unused_extern_crates(_: ()) -> &'tcx [(LocalDefId, Span)] {\n-        desc { \"looking up all possibly unused extern crates\" }\n-    }\n     query names_imported_by_glob_use(def_id: LocalDefId) -> &'tcx FxHashSet<Symbol> {\n         desc { |tcx| \"finding names imported by glob use for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n@@ -2173,12 +2185,8 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query permits_uninit_init(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> Result<bool, ty::layout::LayoutError<'tcx>> {\n-        desc { \"checking to see if `{}` permits being left uninit\", key.value }\n-    }\n-\n-    query permits_zero_init(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> Result<bool, ty::layout::LayoutError<'tcx>> {\n-        desc { \"checking to see if `{}` permits being left zeroed\", key.value }\n+    query check_validity_requirement(key: (ValidityRequirement, ty::ParamEnvAnd<'tcx, Ty<'tcx>>)) -> Result<bool, ty::layout::LayoutError<'tcx>> {\n+        desc { \"checking validity requirement for `{}`: {}\", key.1.value, key.0 }\n     }\n \n     query compare_impl_const("}, {"sha": "3b11fab8cdf57c575d302e531129fcfd431762a0", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::mir::interpret::AllocId;\n use rustc_middle::mir::{self, BinOp, BorrowKind, FakeReadCause, Field, Mutability, UnOp};\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtDef, Ty, UpvarSubsts};\n+use rustc_middle::ty::{self, AdtDef, FnSig, Ty, UpvarSubsts};\n use rustc_middle::ty::{CanonicalUserType, CanonicalUserTypeAnnotation};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n@@ -29,11 +29,15 @@ use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::fmt;\n use std::ops::Index;\n \n-pub mod print;\n pub mod visit;\n \n macro_rules! thir_with_elements {\n-    ($($name:ident: $id:ty => $value:ty => $format:literal,)*) => {\n+    (\n+        $($field_name:ident: $field_ty:ty,)*\n+\n+    @elements:\n+        $($name:ident: $id:ty => $value:ty => $format:literal,)*\n+    ) => {\n         $(\n             newtype_index! {\n                 #[derive(HashStable)]\n@@ -47,14 +51,20 @@ macro_rules! thir_with_elements {\n         /// This can be indexed directly by any THIR index (e.g. [`ExprId`]).\n         #[derive(Debug, HashStable, Clone)]\n         pub struct Thir<'tcx> {\n+            $(\n+                pub $field_name: $field_ty,\n+            )*\n             $(\n                 pub $name: IndexVec<$id, $value>,\n             )*\n         }\n \n         impl<'tcx> Thir<'tcx> {\n-            pub fn new() -> Thir<'tcx> {\n+            pub fn new($($field_name: $field_ty,)*) -> Thir<'tcx> {\n                 Thir {\n+                    $(\n+                        $field_name,\n+                    )*\n                     $(\n                         $name: IndexVec::new(),\n                     )*\n@@ -76,13 +86,22 @@ macro_rules! thir_with_elements {\n pub const UPVAR_ENV_PARAM: ParamId = ParamId::from_u32(0);\n \n thir_with_elements! {\n+    body_type: BodyTy<'tcx>,\n+\n+@elements:\n     arms: ArmId => Arm<'tcx> => \"a{}\",\n     blocks: BlockId => Block => \"b{}\",\n     exprs: ExprId => Expr<'tcx> => \"e{}\",\n     stmts: StmtId => Stmt<'tcx> => \"s{}\",\n     params: ParamId => Param<'tcx> => \"p{}\",\n }\n \n+#[derive(Debug, HashStable, Clone)]\n+pub enum BodyTy<'tcx> {\n+    Const(Ty<'tcx>),\n+    Fn(FnSig<'tcx>),\n+}\n+\n /// Description of a type-checked function parameter.\n #[derive(Clone, Debug, HashStable)]\n pub struct Param<'tcx> {\n@@ -218,6 +237,9 @@ pub struct LocalVarId(pub hir::HirId);\n /// A THIR expression.\n #[derive(Clone, Debug, HashStable)]\n pub struct Expr<'tcx> {\n+    /// kind of expression\n+    pub kind: ExprKind<'tcx>,\n+\n     /// The type of this expression\n     pub ty: Ty<'tcx>,\n \n@@ -227,9 +249,6 @@ pub struct Expr<'tcx> {\n \n     /// span of the expression in the source\n     pub span: Span,\n-\n-    /// kind of expression\n-    pub kind: ExprKind<'tcx>,\n }\n \n #[derive(Clone, Debug, HashStable)]"}, {"sha": "bd43867a3da805db3fa5c0ea901f1c59af210cdb", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -2,6 +2,7 @@ use std::ops::ControlFlow;\n \n use rustc_data_structures::intern::Interned;\n \n+use crate::infer::canonical::QueryRegionConstraints;\n use crate::ty::{\n     FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeVisitable, TypeVisitor,\n };\n@@ -18,20 +19,25 @@ impl<'tcx> std::ops::Deref for ExternalConstraints<'tcx> {\n }\n \n /// Additional constraints returned on success.\n-#[derive(Debug, PartialEq, Eq, Clone, Hash, Default)]\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, Default, TypeFoldable, TypeVisitable)]\n pub struct ExternalConstraintsData<'tcx> {\n     // FIXME: implement this.\n-    pub regions: (),\n+    pub region_constraints: QueryRegionConstraints<'tcx>,\n     pub opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n }\n \n+// FIXME: Having to clone `region_constraints` for folding feels bad and\n+// probably isn't great wrt performance.\n+//\n+// Not sure how to fix this, maybe we should also intern `opaque_types` and\n+// `region_constraints` here or something.\n impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for ExternalConstraints<'tcx> {\n     fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(\n         self,\n         folder: &mut F,\n     ) -> Result<Self, F::Error> {\n         Ok(FallibleTypeFolder::interner(folder).mk_external_constraints(ExternalConstraintsData {\n-            regions: (),\n+            region_constraints: self.region_constraints.clone().try_fold_with(folder)?,\n             opaque_types: self\n                 .opaque_types\n                 .iter()\n@@ -42,7 +48,7 @@ impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for ExternalConstraints<'tcx> {\n \n     fn fold_with<F: TypeFolder<TyCtxt<'tcx>>>(self, folder: &mut F) -> Self {\n         TypeFolder::interner(folder).mk_external_constraints(ExternalConstraintsData {\n-            regions: (),\n+            region_constraints: self.region_constraints.clone().fold_with(folder),\n             opaque_types: self.opaque_types.iter().map(|opaque| opaque.fold_with(folder)).collect(),\n         })\n     }\n@@ -53,7 +59,7 @@ impl<'tcx> TypeVisitable<TyCtxt<'tcx>> for ExternalConstraints<'tcx> {\n         &self,\n         visitor: &mut V,\n     ) -> std::ops::ControlFlow<V::BreakTy> {\n-        self.regions.visit_with(visitor)?;\n+        self.region_constraints.visit_with(visitor)?;\n         self.opaque_types.visit_with(visitor)?;\n         ControlFlow::Continue(())\n     }"}, {"sha": "dfe23cf991f8c8999353586e5da6aa0efb43af83", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,6 +1,6 @@\n pub use self::AssocItemContainer::*;\n \n-use crate::ty::{self, DefIdTree};\n+use crate::ty;\n use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace};"}, {"sha": "dc2bd54b7fe484687eb6e23d9d4038d63a8d21fa", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -5,10 +5,10 @@ use crate::{mir, ty};\n \n use std::fmt::Write;\n \n-use hir::LangItem;\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n-use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::{self as hir, LangItem};\n+use rustc_span::symbol::Ident;\n use rustc_span::{Span, Symbol};\n \n use super::{Ty, TyCtxt};\n@@ -129,6 +129,9 @@ impl<'tcx> ClosureKind {\n #[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub struct CapturedPlace<'tcx> {\n+    /// Name and span where the binding happens.\n+    pub var_ident: Ident,\n+\n     /// The `Place` that is captured.\n     pub place: HirPlace<'tcx>,\n \n@@ -148,12 +151,8 @@ impl<'tcx> CapturedPlace<'tcx> {\n     }\n \n     /// Returns a symbol of the captured upvar, which looks like `name__field1__field2`.\n-    fn to_symbol(&self, tcx: TyCtxt<'tcx>) -> Symbol {\n-        let hir_id = match self.place.base {\n-            HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n-            base => bug!(\"Expected an upvar, found {:?}\", base),\n-        };\n-        let mut symbol = tcx.hir().name(hir_id).as_str().to_string();\n+    pub fn to_symbol(&self) -> Symbol {\n+        let mut symbol = self.var_ident.to_string();\n \n         let mut ty = self.place.base_ty;\n         for proj in self.place.projections.iter() {\n@@ -169,11 +168,7 @@ impl<'tcx> CapturedPlace<'tcx> {\n                         .unwrap();\n                     }\n                     ty => {\n-                        span_bug!(\n-                            self.get_capture_kind_span(tcx),\n-                            \"Unexpected type {:?} for `Field` projection\",\n-                            ty\n-                        )\n+                        bug!(\"Unexpected type {:?} for `Field` projection\", ty)\n                     }\n                 },\n \n@@ -238,10 +233,39 @@ impl<'tcx> CapturedPlace<'tcx> {\n     }\n }\n \n-fn symbols_for_closure_captures(tcx: TyCtxt<'_>, def_id: (LocalDefId, LocalDefId)) -> Vec<Symbol> {\n-    let typeck_results = tcx.typeck(def_id.0);\n-    let captures = typeck_results.closure_min_captures_flattened(def_id.1);\n-    captures.into_iter().map(|captured_place| captured_place.to_symbol(tcx)).collect()\n+#[derive(Copy, Clone, Debug, HashStable)]\n+pub struct ClosureTypeInfo<'tcx> {\n+    user_provided_sig: ty::CanonicalPolyFnSig<'tcx>,\n+    captures: &'tcx [&'tcx ty::CapturedPlace<'tcx>],\n+    kind_origin: Option<&'tcx (Span, HirPlace<'tcx>)>,\n+}\n+\n+fn closure_typeinfo<'tcx>(tcx: TyCtxt<'tcx>, def: LocalDefId) -> ClosureTypeInfo<'tcx> {\n+    debug_assert!(tcx.is_closure(def.to_def_id()));\n+    let typeck_results = tcx.typeck(def);\n+    let user_provided_sig = typeck_results.user_provided_sigs[&def];\n+    let captures = typeck_results.closure_min_captures_flattened(def);\n+    let captures = tcx.arena.alloc_from_iter(captures);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def);\n+    let kind_origin = typeck_results.closure_kind_origins().get(hir_id);\n+    ClosureTypeInfo { user_provided_sig, captures, kind_origin }\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    pub fn closure_kind_origin(self, def_id: LocalDefId) -> Option<&'tcx (Span, HirPlace<'tcx>)> {\n+        self.closure_typeinfo(def_id).kind_origin\n+    }\n+\n+    pub fn closure_user_provided_sig(self, def_id: LocalDefId) -> ty::CanonicalPolyFnSig<'tcx> {\n+        self.closure_typeinfo(def_id).user_provided_sig\n+    }\n+\n+    pub fn closure_captures(self, def_id: LocalDefId) -> &'tcx [&'tcx ty::CapturedPlace<'tcx>] {\n+        if !self.is_closure(def_id.to_def_id()) {\n+            return &[];\n+        };\n+        self.closure_typeinfo(def_id).captures\n+    }\n }\n \n /// Return true if the `proj_possible_ancestor` represents an ancestor path\n@@ -434,5 +458,5 @@ impl BorrowKind {\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {\n-    *providers = ty::query::Providers { symbols_for_closure_captures, ..*providers }\n+    *providers = ty::query::Providers { closure_typeinfo, ..*providers }\n }"}, {"sha": "5d0cf23280bc8566a5c46c6df7ce3d57a64b0341", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,6 +1,6 @@\n use crate::middle::resolve_bound_vars as rbv;\n use crate::mir::interpret::LitToConstInput;\n-use crate::ty::{self, DefIdTree, InternalSubsts, ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n+use crate::ty::{self, InternalSubsts, ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -16,7 +16,7 @@ pub use int::*;\n pub use kind::*;\n pub use valtree::*;\n \n-/// Use this rather than `ConstData, whenever possible.\n+/// Use this rather than `ConstData`, whenever possible.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n #[rustc_pass_by_value]\n pub struct Const<'tcx>(pub(super) Interned<'tcx, ConstData<'tcx>>);"}, {"sha": "70091477e39f4b0a4810e5d65972393cef5b1a51", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -20,11 +20,10 @@ use crate::traits;\n use crate::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n-    self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstData, DefIdTree, FloatTy, FloatVar,\n-    FloatVid, GenericParamDefKind, ImplPolarity, InferTy, IntTy, IntVar, IntVid, List, ParamConst,\n-    ParamTy, PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, Region, RegionKind,\n-    ReprOptions, TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, TypeckResults, UintTy,\n-    Visibility,\n+    self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstData, FloatTy, FloatVar, FloatVid,\n+    GenericParamDefKind, ImplPolarity, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n+    PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, Region, RegionKind, ReprOptions,\n+    TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, TypeckResults, UintTy, Visibility,\n };\n use crate::ty::{GenericArg, InternalSubsts, SubstsRef};\n use rustc_ast as ast;\n@@ -310,7 +309,7 @@ pub struct CommonLifetimes<'tcx> {\n     pub re_vars: Vec<Region<'tcx>>,\n \n     /// Pre-interned values of the form:\n-    /// `ReLateBound(DebruijnIndex(i), BoundRegion { var: v, kind: BrAnon(v, None) })\n+    /// `ReLateBound(DebruijnIndex(i), BoundRegion { var: v, kind: BrAnon(v, None) })`\n     /// for small values of `i` and `v`.\n     pub re_late_bounds: Vec<Vec<Region<'tcx>>>,\n }\n@@ -794,8 +793,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn consider_optimizing<T: Fn() -> String>(self, msg: T) -> bool {\n-        let cname = self.crate_name(LOCAL_CRATE);\n-        self.sess.consider_optimizing(cname.as_str(), msg)\n+        self.sess.consider_optimizing(|| self.crate_name(LOCAL_CRATE), msg)\n     }\n \n     /// Obtain all lang items of this crate and all dependencies (recursively)\n@@ -2187,7 +2185,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // Actually intern type lists as lists of `GenericArg`s.\n         //\n         // Transmuting from `Ty<'tcx>` to `GenericArg<'tcx>` is sound\n-        // as explained in ty_slice_as_generic_arg`. With this,\n+        // as explained in `ty_slice_as_generic_arg`. With this,\n         // we guarantee that even when transmuting between `List<Ty<'tcx>>`\n         // and `List<GenericArg<'tcx>>`, the uniqueness requirement for\n         // lists is upheld.\n@@ -2450,7 +2448,7 @@ impl<'tcx> TyCtxtAt<'tcx> {\n         self.tcx.ty_error_with_message(self.span, \"TyKind::Error constructed but no error reported\")\n     }\n \n-    /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg to\n+    /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg` to\n     /// ensure it gets used.\n     #[track_caller]\n     pub fn ty_error_with_message(self, msg: &str) -> Ty<'tcx> {\n@@ -2487,8 +2485,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         |tcx, id| tcx.resolutions(()).reexport_map.get(&id).map(|v| &v[..]);\n     providers.maybe_unused_trait_imports =\n         |tcx, ()| &tcx.resolutions(()).maybe_unused_trait_imports;\n-    providers.maybe_unused_extern_crates =\n-        |tcx, ()| &tcx.resolutions(()).maybe_unused_extern_crates[..];\n     providers.names_imported_by_glob_use = |tcx, id| {\n         tcx.arena.alloc(tcx.resolutions(()).glob_map.get(&id).cloned().unwrap_or_default())\n     };"}, {"sha": "3ca17e7273eb996f308f34f5e4e341d759e4354f", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -3,9 +3,9 @@\n use std::ops::ControlFlow;\n \n use crate::ty::{\n-    AliasTy, Const, ConstKind, DefIdTree, FallibleTypeFolder, InferConst, InferTy, Opaque,\n-    PolyTraitPredicate, Projection, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable,\n-    TypeSuperVisitable, TypeVisitable, TypeVisitor,\n+    AliasTy, Const, ConstKind, FallibleTypeFolder, InferConst, InferTy, Opaque, PolyTraitPredicate,\n+    Projection, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable, TypeSuperVisitable, TypeVisitable,\n+    TypeVisitor,\n };\n \n use rustc_data_structures::fx::FxHashMap;"}, {"sha": "ac42d6e05100fee5d59bad0e4d9dc80cc09b7679", "filename": "compiler/rustc_middle/src/ty/inhabitedness/inhabited_predicate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,5 +1,5 @@\n use crate::ty::context::TyCtxt;\n-use crate::ty::{self, DefId, DefIdTree, ParamEnv, Ty};\n+use crate::ty::{self, DefId, ParamEnv, Ty};\n \n /// Represents whether some type is inhabited in a given context.\n /// Examples of uninhabited types are `!`, `enum Void {}`, or a struct"}, {"sha": "92a040068dd75833d5b51b0a5fe9fff786c96fa0", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> VariantDef {\n impl<'tcx> Ty<'tcx> {\n     pub fn inhabited_predicate(self, tcx: TyCtxt<'tcx>) -> InhabitedPredicate<'tcx> {\n         match self.kind() {\n-            // For now, union`s are always considered inhabited\n+            // For now, unions are always considered inhabited\n             Adt(adt, _) if adt.is_union() => InhabitedPredicate::True,\n             // Non-exhaustive ADTs from other crates are always considered inhabited\n             Adt(adt, _) if adt.is_variant_list_non_exhaustive() && !adt.did().is_local() => {"}, {"sha": "254ffc33c96f0147b20c84335a067edc73ed4335", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -7,6 +7,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_session::config::OptLevel;\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::*;\n@@ -92,7 +93,7 @@ impl IntegerExt for Integer {\n             if discr < fit {\n                 bug!(\n                     \"Integer::repr_discr: `#[repr]` hint too small for \\\n-                      discriminant range of enum `{}\",\n+                      discriminant range of enum `{}`\",\n                     ty\n                 )\n             }\n@@ -169,6 +170,41 @@ pub const FAT_PTR_EXTRA: usize = 1;\n /// * Cranelift stores the base-2 log of the lane count in a 4 bit integer.\n pub const MAX_SIMD_LANES: u64 = 1 << 0xF;\n \n+/// Used in `check_validity_requirement` to indicate the kind of initialization\n+/// that is checked to be valid\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable)]\n+pub enum ValidityRequirement {\n+    Inhabited,\n+    Zero,\n+    /// The return value of mem::uninitialized, 0x01\n+    /// (unless -Zstrict-init-checks is on, in which case it's the same as Uninit).\n+    UninitMitigated0x01Fill,\n+    /// True uninitialized memory.\n+    Uninit,\n+}\n+\n+impl ValidityRequirement {\n+    pub fn from_intrinsic(intrinsic: Symbol) -> Option<Self> {\n+        match intrinsic {\n+            sym::assert_inhabited => Some(Self::Inhabited),\n+            sym::assert_zero_valid => Some(Self::Zero),\n+            sym::assert_mem_uninitialized_valid => Some(Self::UninitMitigated0x01Fill),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for ValidityRequirement {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::Inhabited => f.write_str(\"is inhabited\"),\n+            Self::Zero => f.write_str(\"allows being left zeroed\"),\n+            Self::UninitMitigated0x01Fill => f.write_str(\"allows being filled with 0x01\"),\n+            Self::Uninit => f.write_str(\"allows being left uninitialized\"),\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, HashStable, TyEncodable, TyDecodable)]\n pub enum LayoutError<'tcx> {\n     Unknown(Ty<'tcx>),"}, {"sha": "8cc8a0573bb0f176a2ca280767185a727464a9ec", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 50, "deletions": 24, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -73,7 +73,7 @@ pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n pub use self::closure::{\n     is_ancestor_or_same_capture, place_to_string_for_capture, BorrowKind, CaptureInfo,\n-    CapturedPlace, ClosureKind, MinCaptureInformationMap, MinCaptureList,\n+    CapturedPlace, ClosureKind, ClosureTypeInfo, MinCaptureInformationMap, MinCaptureList,\n     RootVariableMinCaptureList, UpvarCapture, UpvarCaptureMap, UpvarId, UpvarListMap, UpvarPath,\n     CAPTURE_STRUCT_LOCAL,\n };\n@@ -165,12 +165,8 @@ pub struct ResolverGlobalCtxt {\n     pub effective_visibilities: EffectiveVisibilities,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     pub maybe_unused_trait_imports: FxIndexSet<LocalDefId>,\n-    pub maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n     pub reexport_map: FxHashMap<LocalDefId, Vec<ModChild>>,\n     pub glob_map: FxHashMap<LocalDefId, FxHashSet<Symbol>>,\n-    /// Extern prelude entries. The value is `true` if the entry was introduced\n-    /// via `extern crate` item and not `--extern` option or compiler built-in.\n-    pub extern_prelude: FxHashMap<Symbol, bool>,\n     pub main_def: Option<MainDefinition>,\n     pub trait_impls: FxIndexMap<DefId, Vec<LocalDefId>>,\n     /// A list of proc macro LocalDefIds, written out in the order in which\n@@ -329,12 +325,15 @@ pub struct ClosureSizeProfileData<'tcx> {\n     pub after_feature_tys: Ty<'tcx>,\n }\n \n-pub trait DefIdTree: Copy {\n-    fn opt_parent(self, id: DefId) -> Option<DefId>;\n+impl TyCtxt<'_> {\n+    #[inline]\n+    pub fn opt_parent(self, id: DefId) -> Option<DefId> {\n+        self.def_key(id).parent.map(|index| DefId { index, ..id })\n+    }\n \n     #[inline]\n     #[track_caller]\n-    fn parent(self, id: DefId) -> DefId {\n+    pub fn parent(self, id: DefId) -> DefId {\n         match self.opt_parent(id) {\n             Some(id) => id,\n             // not `unwrap_or_else` to avoid breaking caller tracking\n@@ -344,17 +343,17 @@ pub trait DefIdTree: Copy {\n \n     #[inline]\n     #[track_caller]\n-    fn opt_local_parent(self, id: LocalDefId) -> Option<LocalDefId> {\n+    pub fn opt_local_parent(self, id: LocalDefId) -> Option<LocalDefId> {\n         self.opt_parent(id.to_def_id()).map(DefId::expect_local)\n     }\n \n     #[inline]\n     #[track_caller]\n-    fn local_parent(self, id: LocalDefId) -> LocalDefId {\n+    pub fn local_parent(self, id: LocalDefId) -> LocalDefId {\n         self.parent(id.to_def_id()).expect_local()\n     }\n \n-    fn is_descendant_of(self, mut descendant: DefId, ancestor: DefId) -> bool {\n+    pub fn is_descendant_of(self, mut descendant: DefId, ancestor: DefId) -> bool {\n         if descendant.krate != ancestor.krate {\n             return false;\n         }\n@@ -369,13 +368,6 @@ pub trait DefIdTree: Copy {\n     }\n }\n \n-impl<'tcx> DefIdTree for TyCtxt<'tcx> {\n-    #[inline]\n-    fn opt_parent(self, id: DefId) -> Option<DefId> {\n-        self.def_key(id).parent.map(|index| DefId { index, ..id })\n-    }\n-}\n-\n impl<Id> Visibility<Id> {\n     pub fn is_public(self) -> bool {\n         matches!(self, Visibility::Public)\n@@ -395,19 +387,19 @@ impl<Id: Into<DefId>> Visibility<Id> {\n     }\n \n     /// Returns `true` if an item with this visibility is accessible from the given module.\n-    pub fn is_accessible_from(self, module: impl Into<DefId>, tree: impl DefIdTree) -> bool {\n+    pub fn is_accessible_from(self, module: impl Into<DefId>, tcx: TyCtxt<'_>) -> bool {\n         match self {\n             // Public items are visible everywhere.\n             Visibility::Public => true,\n-            Visibility::Restricted(id) => tree.is_descendant_of(module.into(), id.into()),\n+            Visibility::Restricted(id) => tcx.is_descendant_of(module.into(), id.into()),\n         }\n     }\n \n     /// Returns `true` if this visibility is at least as accessible as the given visibility\n-    pub fn is_at_least(self, vis: Visibility<impl Into<DefId>>, tree: impl DefIdTree) -> bool {\n+    pub fn is_at_least(self, vis: Visibility<impl Into<DefId>>, tcx: TyCtxt<'_>) -> bool {\n         match vis {\n             Visibility::Public => self.is_public(),\n-            Visibility::Restricted(id) => self.is_accessible_from(id, tree),\n+            Visibility::Restricted(id) => self.is_accessible_from(id, tcx),\n         }\n     }\n }\n@@ -714,7 +706,7 @@ impl<'tcx> Predicate<'tcx> {\n         //   The substitution from the input trait-ref is therefore going to be\n         //   `'a => 'x` (where `'x` has a DB index of 1).\n         // - The supertrait-ref is `for<'b> Bar1<'a,'b>`, where `'a` is an\n-        //   early-bound parameter and `'b' is a late-bound parameter with a\n+        //   early-bound parameter and `'b` is a late-bound parameter with a\n         //   DB index of 1.\n         // - If we replace `'a` with `'x` from the input, it too will have\n         //   a DB index of 1, and thus we'll have `for<'x,'b> Bar1<'x,'b>`\n@@ -2075,6 +2067,12 @@ pub enum ImplOverlapKind {\n     Issue33140,\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n+pub enum ImplTraitInTraitData {\n+    Trait { fn_def_id: DefId, opaque_def_id: DefId },\n+    Impl { fn_def_id: DefId },\n+}\n+\n impl<'tcx> TyCtxt<'tcx> {\n     pub fn typeck_body(self, body: hir::BodyId) -> &'tcx TypeckResults<'tcx> {\n         self.typeck(self.hir().body_owner_def_id(body))\n@@ -2442,7 +2440,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         None\n     }\n \n-    /// Check if the given `DefId` is `#\\[automatically_derived\\], *and*\n+    /// Check if the given `DefId` is `#\\[automatically_derived\\]`, *and*\n     /// whether it was produced by expanding a builtin derive macro.\n     pub fn is_builtin_derived(self, def_id: DefId) -> bool {\n         if self.is_automatically_derived(def_id)\n@@ -2545,6 +2543,34 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n         def_id\n     }\n+\n+    pub fn impl_method_has_trait_impl_trait_tys(self, def_id: DefId) -> bool {\n+        if self.def_kind(def_id) != DefKind::AssocFn {\n+            return false;\n+        }\n+\n+        let Some(item) = self.opt_associated_item(def_id) else { return false; };\n+        if item.container != ty::AssocItemContainer::ImplContainer {\n+            return false;\n+        }\n+\n+        let Some(trait_item_def_id) = item.trait_item_def_id else { return false; };\n+\n+        // FIXME(RPITIT): This does a somewhat manual walk through the signature\n+        // of the trait fn to look for any RPITITs, but that's kinda doing a lot\n+        // of work. We can probably remove this when we refactor RPITITs to be\n+        // associated types.\n+        self.fn_sig(trait_item_def_id).subst_identity().skip_binder().output().walk().any(|arg| {\n+            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                && let ty::Alias(ty::Projection, data) = ty.kind()\n+                && self.def_kind(data.def_id) == DefKind::ImplTraitPlaceholder\n+            {\n+                true\n+            } else {\n+                false\n+            }\n+        })\n+    }\n }\n \n /// Yields the parent function's `LocalDefId` if `def_id` is an `impl Trait` definition."}, {"sha": "578cd82aa4c2afdd97b31f5854392e840a12dde5", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -7,7 +7,6 @@\n //! `normalize_generic_arg_after_erasing_regions` query for each type\n //! or constant found within. (This underlying query is what is cached.)\n \n-use crate::mir;\n use crate::traits::query::NoSolution;\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeFolder};\n use crate::ty::{self, EarlyBinder, SubstsRef, Ty, TyCtxt, TypeVisitableExt};\n@@ -16,15 +15,13 @@ use crate::ty::{self, EarlyBinder, SubstsRef, Ty, TyCtxt, TypeVisitableExt};\n pub enum NormalizationError<'tcx> {\n     Type(Ty<'tcx>),\n     Const(ty::Const<'tcx>),\n-    ConstantKind(mir::ConstantKind<'tcx>),\n }\n \n impl<'tcx> NormalizationError<'tcx> {\n     pub fn get_type_for_failure(&self) -> String {\n         match self {\n             NormalizationError::Type(t) => format!(\"{}\", t),\n             NormalizationError::Const(c) => format!(\"{}\", c),\n-            NormalizationError::ConstantKind(ck) => format!(\"{}\", ck),\n         }\n     }\n }"}, {"sha": "d947d96041ef7ebc702a74f4ce0a64dca9031dec", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,5 +1,5 @@\n use crate::ty::GenericArg;\n-use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n+use crate::ty::{self, Ty, TyCtxt};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sso::SsoHashSet;"}, {"sha": "b3139d23d36e3602ce706e3646c688e188efcf5c", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,6 +1,6 @@\n use crate::mir::interpret::{AllocRange, GlobalAlloc, Pointer, Provenance, Scalar};\n use crate::ty::{\n-    self, ConstInt, DefIdTree, ParamConst, ScalarInt, Term, TermKind, Ty, TyCtxt, TypeFoldable,\n+    self, ConstInt, ParamConst, ScalarInt, Term, TermKind, Ty, TyCtxt, TypeFoldable,\n     TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n };\n use crate::ty::{GenericArg, GenericArgKind};"}, {"sha": "2bc51baf87905b3247db503429b739a83121b148", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -32,6 +32,7 @@ use crate::traits::specialization_graph;\n use crate::traits::{self, ImplSource};\n use crate::ty::context::TyCtxtFeed;\n use crate::ty::fast_reject::SimplifiedType;\n+use crate::ty::layout::ValidityRequirement;\n use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::GeneratorDiagnosticData;"}, {"sha": "ef643531bb288658368f3d94da959f67a5509126", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -263,6 +263,7 @@ TrivialTypeTraversalAndLiftImpls! {\n     crate::ty::UniverseIndex,\n     crate::ty::Variance,\n     ::rustc_span::Span,\n+    ::rustc_span::symbol::Ident,\n     ::rustc_errors::ErrorGuaranteed,\n     Field,\n     interpret::Scalar,"}, {"sha": "52d114bae3007203b50d94e5160363ffb038df53", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -7,7 +7,7 @@ use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use crate::ty::visit::ValidateBoundVars;\n use crate::ty::InferTy::*;\n use crate::ty::{\n-    self, AdtDef, DefIdTree, Discr, FallibleTypeFolder, Term, Ty, TyCtxt, TypeFlags, TypeFoldable,\n+    self, AdtDef, Discr, FallibleTypeFolder, Term, Ty, TyCtxt, TypeFlags, TypeFoldable,\n     TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor,\n };\n use crate::ty::{List, ParamEnv};\n@@ -107,6 +107,15 @@ impl BoundRegionKind {\n             _ => None,\n         }\n     }\n+\n+    pub fn expect_anon(&self) -> u32 {\n+        match *self {\n+            BoundRegionKind::BrNamed(_, _) | BoundRegionKind::BrEnv => {\n+                bug!(\"expected anon region: {self:?}\")\n+            }\n+            BoundRegionKind::BrAnon(idx, _) => idx,\n+        }\n+    }\n }\n \n pub trait Article {"}, {"sha": "586958247fcdca9303873bb0df2f4cd08a02d92d", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -569,7 +569,7 @@ impl<'a, V> LocalTableInContext<'a, V> {\n         self.data.contains_key(&id.local_id)\n     }\n \n-    pub fn get(&self, id: hir::HirId) -> Option<&V> {\n+    pub fn get(&self, id: hir::HirId) -> Option<&'a V> {\n         validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.data.get(&id.local_id)\n     }"}, {"sha": "8b5469743dad6d70ebf4f2a7dee5ca7200c9ed23", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -4,8 +4,8 @@ use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir;\n use crate::ty::layout::IntegerExt;\n use crate::ty::{\n-    self, DefIdTree, FallibleTypeFolder, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder,\n-    TypeSuperFoldable, TypeVisitableExt,\n+    self, FallibleTypeFolder, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n+    TypeVisitableExt,\n };\n use crate::ty::{GenericArgKind, SubstsRef};\n use rustc_apfloat::Float as _;"}, {"sha": "55aa4fcff2cdb4890d81680a0734b1dbbed1d6c6", "filename": "compiler/rustc_middle/src/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -4,7 +4,7 @@ use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_middle::ty::Representability;\n-use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_query_system::query::QueryInfo;\n use rustc_query_system::Value;\n use rustc_span::def_id::LocalDefId;"}, {"sha": "93e7fb330e093e165a6f38dd37701af5eb535874", "filename": "compiler/rustc_mir_build/locales/en-US.ftl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Flocales%2Fen-US.ftl?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -374,3 +374,9 @@ mir_build_suggest_let_else = you might want to use `let else` to handle the {$co\n     } matched\n \n mir_build_suggest_attempted_int_lit = alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n+\n+\n+mir_build_rustc_box_attribute_error = `#[rustc_box]` attribute used incorrectly\n+    .attributes = no other attributes may be applied\n+    .not_box = `#[rustc_box]` may only be applied to a `Box::new()` call\n+    .missing_box = `#[rustc_box]` requires the `owned_box` lang item"}, {"sha": "cfacb5ea327771b9f36df61da61f80c55107f841", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -55,7 +55,7 @@ pub fn as_constant_inner<'tcx>(\n                         ConstantKind::Ty(tcx.const_error_with_guaranteed(ty, guar))\n                     }\n                     Err(LitToConstError::TypeError) => {\n-                        bug!(\"encountered type error in `lit_to_mir_constant\")\n+                        bug!(\"encountered type error in `lit_to_mir_constant`\")\n                     }\n                 };\n "}, {"sha": "33200b80a572d82fa95b038376781eaa274d04db", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::AssertKind::BoundsCheck;\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n use rustc_middle::ty::AdtDef;\n-use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n+use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, Variance};\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n \n@@ -183,7 +183,7 @@ fn to_upvars_resolved_place_builder<'tcx>(\n             &projection,\n         ) else {\n         let closure_span = cx.tcx.def_span(closure_def_id);\n-        if !enable_precise_capture(cx.tcx, closure_span) {\n+        if !enable_precise_capture(closure_span) {\n             bug!(\n                 \"No associated capture found for {:?}[{:#?}] even though \\\n                     capture_disjoint_fields isn't enabled\",\n@@ -745,8 +745,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n }\n \n-/// Precise capture is enabled if the feature gate `capture_disjoint_fields` is enabled or if\n-/// user is using Rust Edition 2021 or higher.\n-fn enable_precise_capture(tcx: TyCtxt<'_>, closure_span: Span) -> bool {\n-    tcx.features().capture_disjoint_fields || closure_span.rust_2021()\n+/// Precise capture is enabled if user is using Rust Edition 2021 or higher.\n+fn enable_precise_capture(closure_span: Span) -> bool {\n+    closure_span.rust_2021()\n }"}, {"sha": "ea5aeb67d8576af803565b1fadb9c80b53c18335", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Generate better code for things that don't need to be\n                 // dropped.\n                 if lhs.ty.needs_drop(this.tcx, this.param_env) {\n-                    let rhs = unpack!(block = this.as_local_operand(block, rhs));\n+                    let rhs = unpack!(block = this.as_local_rvalue(block, rhs));\n                     let lhs = unpack!(block = this.as_place(block, lhs));\n                     unpack!(block = this.build_drop_and_replace(block, lhs_span, lhs, rhs));\n                 } else {"}, {"sha": "b3f9d82829f1306b7d97c727609356272d831165", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 79, "deletions": 107, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::mir::*;\n use rustc_middle::thir::{\n     self, BindingMode, Expr, ExprId, LintLevel, LocalVarId, Param, ParamId, PatKind, Thir,\n };\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt, TypeckResults};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_span::Symbol;\n@@ -47,8 +47,6 @@ pub(crate) fn mir_built(\n \n /// Construct the MIR for a given `DefId`.\n fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_> {\n-    let body_owner_kind = tcx.hir().body_owner_kind(def.did);\n-\n     // Ensure unsafeck and abstract const building is ran before we steal the THIR.\n     // We can't use `ensure()` for `thir_abstract_const` as it doesn't compute the query\n     // if inputs are green. This can cause ICEs when calling `thir_abstract_const` after\n@@ -65,16 +63,15 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n     }\n \n     let body = match tcx.thir_body(def) {\n-        Err(error_reported) => construct_error(tcx, def.did, body_owner_kind, error_reported),\n+        Err(error_reported) => construct_error(tcx, def.did, error_reported),\n         Ok((thir, expr)) => {\n             // We ran all queries that depended on THIR at the beginning\n             // of `mir_build`, so now we can steal it\n             let thir = thir.steal();\n \n-            if body_owner_kind.is_fn_or_closure() {\n-                construct_fn(tcx, def, &thir, expr)\n-            } else {\n-                construct_const(tcx, def, &thir, expr)\n+            match thir.body_type {\n+                thir::BodyTy::Fn(fn_sig) => construct_fn(tcx, def, &thir, expr, fn_sig),\n+                thir::BodyTy::Const(ty) => construct_const(tcx, def, &thir, expr, ty),\n             }\n         }\n     };\n@@ -158,13 +155,13 @@ struct BlockContext(Vec<BlockFrame>);\n struct Builder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     infcx: InferCtxt<'tcx>,\n-    typeck_results: &'tcx TypeckResults<'tcx>,\n     region_scope_tree: &'tcx region::ScopeTree,\n     param_env: ty::ParamEnv<'tcx>,\n \n     thir: &'a Thir<'tcx>,\n     cfg: CFG<'tcx>,\n \n+    def: ty::WithOptConstParam<LocalDefId>,\n     def_id: DefId,\n     hir_id: hir::HirId,\n     parent_module: DefId,\n@@ -434,6 +431,7 @@ fn construct_fn<'tcx>(\n     fn_def: ty::WithOptConstParam<LocalDefId>,\n     thir: &Thir<'tcx>,\n     expr: ExprId,\n+    fn_sig: ty::FnSig<'tcx>,\n ) -> Body<'tcx> {\n     let span = tcx.def_span(fn_def.did);\n     let fn_id = tcx.hir().local_def_id_to_hir_id(fn_def.did);\n@@ -453,11 +451,6 @@ fn construct_fn<'tcx>(\n         .output\n         .span();\n \n-    // fetch the fully liberated fn signature (that is, all bound\n-    // types/lifetimes replaced)\n-    let typeck_results = tcx.typeck_opt_const_arg(fn_def);\n-    let fn_sig = typeck_results.liberated_fn_sigs()[fn_id];\n-\n     let safety = match fn_sig.unsafety {\n         hir::Unsafety::Normal => Safety::Safe,\n         hir::Unsafety::Unsafe => Safety::FnUnsafe,\n@@ -529,13 +522,7 @@ fn construct_fn<'tcx>(\n         let return_block =\n             unpack!(builder.in_breakable_scope(None, Place::return_place(), fn_end, |builder| {\n                 Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n-                    builder.args_and_body(\n-                        START_BLOCK,\n-                        fn_def.did,\n-                        arguments,\n-                        arg_scope,\n-                        &thir[expr],\n-                    )\n+                    builder.args_and_body(START_BLOCK, arguments, arg_scope, &thir[expr])\n                 }))\n             }));\n         let source_info = builder.source_info(fn_end);\n@@ -563,6 +550,7 @@ fn construct_const<'a, 'tcx>(\n     def: ty::WithOptConstParam<LocalDefId>,\n     thir: &'a Thir<'tcx>,\n     expr: ExprId,\n+    const_ty: Ty<'tcx>,\n ) -> Body<'tcx> {\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n \n@@ -586,20 +574,6 @@ fn construct_const<'a, 'tcx>(\n         _ => span_bug!(tcx.def_span(def.did), \"can't build MIR for {:?}\", def.did),\n     };\n \n-    // Get the revealed type of this const. This is *not* the adjusted\n-    // type of its body, which may be a subtype of this type. For\n-    // example:\n-    //\n-    // fn foo(_: &()) {}\n-    // static X: fn(&'static ()) = foo;\n-    //\n-    // The adjusted type of the body of X is `for<'a> fn(&'a ())` which\n-    // is not the same as the type of X. We need the type of the return\n-    // place to be the type of the constant because NLL typeck will\n-    // equate them.\n-    let typeck_results = tcx.typeck_opt_const_arg(def);\n-    let const_ty = typeck_results.node_type(hir_id);\n-\n     let infcx = tcx.infer_ctxt().build();\n     let mut builder = Builder::new(\n         thir,\n@@ -629,15 +603,11 @@ fn construct_const<'a, 'tcx>(\n ///\n /// This is required because we may still want to run MIR passes on an item\n /// with type errors, but normal MIR construction can't handle that in general.\n-fn construct_error(\n-    tcx: TyCtxt<'_>,\n-    def: LocalDefId,\n-    body_owner_kind: hir::BodyOwnerKind,\n-    err: ErrorGuaranteed,\n-) -> Body<'_> {\n+fn construct_error(tcx: TyCtxt<'_>, def: LocalDefId, err: ErrorGuaranteed) -> Body<'_> {\n     let span = tcx.def_span(def);\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def);\n     let generator_kind = tcx.generator_kind(def);\n+    let body_owner_kind = tcx.hir().body_owner_kind(def);\n \n     let ty = tcx.ty_error(err);\n     let num_params = match body_owner_kind {\n@@ -728,9 +698,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             thir,\n             tcx,\n             infcx,\n-            typeck_results: tcx.typeck_opt_const_arg(def),\n             region_scope_tree: tcx.region_scope_tree(def.did),\n             param_env,\n+            def,\n             def_id: def.did.to_def_id(),\n             hir_id,\n             parent_module: tcx.parent_module(hir_id).to_def_id(),\n@@ -780,14 +750,78 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.var_debug_info,\n             self.fn_span,\n             self.generator_kind,\n-            self.typeck_results.tainted_by_errors,\n+            None,\n         )\n     }\n \n+    fn insert_upvar_arg(&mut self) {\n+        let Some(closure_arg) = self.local_decls.get(ty::CAPTURE_STRUCT_LOCAL) else { return };\n+\n+        let mut closure_ty = closure_arg.ty;\n+        let mut closure_env_projs = vec![];\n+        if let ty::Ref(_, ty, _) = closure_ty.kind() {\n+            closure_env_projs.push(ProjectionElem::Deref);\n+            closure_ty = *ty;\n+        }\n+\n+        let upvar_substs = match closure_ty.kind() {\n+            ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n+            ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n+            _ => return,\n+        };\n+\n+        // In analyze_closure() in upvar.rs we gathered a list of upvars used by an\n+        // indexed closure and we stored in a map called closure_min_captures in TypeckResults\n+        // with the closure's DefId. Here, we run through that vec of UpvarIds for\n+        // the given closure and use the necessary information to create upvar\n+        // debuginfo and to fill `self.upvars`.\n+        let capture_tys = upvar_substs.upvar_tys();\n+\n+        let tcx = self.tcx;\n+        self.upvars = tcx\n+            .closure_captures(self.def.did)\n+            .iter()\n+            .zip(capture_tys)\n+            .enumerate()\n+            .map(|(i, (captured_place, ty))| {\n+                let name = captured_place.to_symbol();\n+\n+                let capture = captured_place.info.capture_kind;\n+                let var_id = match captured_place.place.base {\n+                    HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+                    _ => bug!(\"Expected an upvar\"),\n+                };\n+\n+                let mutability = captured_place.mutability;\n+\n+                let mut projs = closure_env_projs.clone();\n+                projs.push(ProjectionElem::Field(Field::new(i), ty));\n+                match capture {\n+                    ty::UpvarCapture::ByValue => {}\n+                    ty::UpvarCapture::ByRef(..) => {\n+                        projs.push(ProjectionElem::Deref);\n+                    }\n+                };\n+\n+                let use_place = Place {\n+                    local: ty::CAPTURE_STRUCT_LOCAL,\n+                    projection: tcx.mk_place_elems(&projs),\n+                };\n+                self.var_debug_info.push(VarDebugInfo {\n+                    name,\n+                    source_info: SourceInfo::outermost(captured_place.var_ident.span),\n+                    value: VarDebugInfoContents::Place(use_place),\n+                });\n+\n+                let capture = Capture { captured_place, use_place, mutability };\n+                (var_id, capture)\n+            })\n+            .collect();\n+    }\n+\n     fn args_and_body(\n         &mut self,\n         mut block: BasicBlock,\n-        fn_def_id: LocalDefId,\n         arguments: &IndexVec<ParamId, Param<'tcx>>,\n         argument_scope: region::Scope,\n         expr: &Expr<'tcx>,\n@@ -809,69 +843,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        let tcx = self.tcx;\n-        let tcx_hir = tcx.hir();\n-        let hir_typeck_results = self.typeck_results;\n-\n-        // In analyze_closure() in upvar.rs we gathered a list of upvars used by an\n-        // indexed closure and we stored in a map called closure_min_captures in TypeckResults\n-        // with the closure's DefId. Here, we run through that vec of UpvarIds for\n-        // the given closure and use the necessary information to create upvar\n-        // debuginfo and to fill `self.upvars`.\n-        if hir_typeck_results.closure_min_captures.get(&fn_def_id).is_some() {\n-            let mut closure_env_projs = vec![];\n-            let mut closure_ty = self.local_decls[ty::CAPTURE_STRUCT_LOCAL].ty;\n-            if let ty::Ref(_, ty, _) = closure_ty.kind() {\n-                closure_env_projs.push(ProjectionElem::Deref);\n-                closure_ty = *ty;\n-            }\n-            let upvar_substs = match closure_ty.kind() {\n-                ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n-                ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n-                _ => span_bug!(self.fn_span, \"upvars with non-closure env ty {:?}\", closure_ty),\n-            };\n-            let def_id = self.def_id.as_local().unwrap();\n-            let capture_syms = tcx.symbols_for_closure_captures((def_id, fn_def_id));\n-            let capture_tys = upvar_substs.upvar_tys();\n-            let captures_with_tys = hir_typeck_results\n-                .closure_min_captures_flattened(fn_def_id)\n-                .zip(capture_tys.zip(capture_syms));\n-\n-            self.upvars = captures_with_tys\n-                .enumerate()\n-                .map(|(i, (captured_place, (ty, sym)))| {\n-                    let capture = captured_place.info.capture_kind;\n-                    let var_id = match captured_place.place.base {\n-                        HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n-                        _ => bug!(\"Expected an upvar\"),\n-                    };\n-\n-                    let mutability = captured_place.mutability;\n-\n-                    let mut projs = closure_env_projs.clone();\n-                    projs.push(ProjectionElem::Field(Field::new(i), ty));\n-                    match capture {\n-                        ty::UpvarCapture::ByValue => {}\n-                        ty::UpvarCapture::ByRef(..) => {\n-                            projs.push(ProjectionElem::Deref);\n-                        }\n-                    };\n-\n-                    let use_place = Place {\n-                        local: ty::CAPTURE_STRUCT_LOCAL,\n-                        projection: tcx.mk_place_elems(&projs),\n-                    };\n-                    self.var_debug_info.push(VarDebugInfo {\n-                        name: *sym,\n-                        source_info: SourceInfo::outermost(tcx_hir.span(var_id)),\n-                        value: VarDebugInfoContents::Place(use_place),\n-                    });\n-\n-                    let capture = Capture { captured_place, use_place, mutability };\n-                    (var_id, capture)\n-                })\n-                .collect();\n-        }\n+        self.insert_upvar_arg();\n \n         let mut scope = None;\n         // Bind the argument patterns"}, {"sha": "770701b3750dfa3e1275a3761fd069bf60e88775", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -91,7 +91,7 @@ use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::thir::{Expr, LintLevel};\n \n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::{DesugaringKind, Span, DUMMY_SP};\n \n #[derive(Debug)]\n pub struct Scopes<'tcx> {\n@@ -1118,24 +1118,35 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Utility function for *non*-scope code to build their own drops\n+    /// Force a drop at this point in the MIR by creating a new block.\n     pub(crate) fn build_drop_and_replace(\n         &mut self,\n         block: BasicBlock,\n         span: Span,\n         place: Place<'tcx>,\n-        value: Operand<'tcx>,\n+        value: Rvalue<'tcx>,\n     ) -> BlockAnd<()> {\n+        let span = self.tcx.with_stable_hashing_context(|hcx| {\n+            span.mark_with_reason(None, DesugaringKind::Replace, self.tcx.sess.edition(), hcx)\n+        });\n         let source_info = self.source_info(span);\n-        let next_target = self.cfg.start_new_block();\n+\n+        // create the new block for the assignment\n+        let assign = self.cfg.start_new_block();\n+        self.cfg.push_assign(assign, source_info, place, value.clone());\n+\n+        // create the new block for the assignment in the case of unwinding\n+        let assign_unwind = self.cfg.start_new_cleanup_block();\n+        self.cfg.push_assign(assign_unwind, source_info, place, value.clone());\n \n         self.cfg.terminate(\n             block,\n             source_info,\n-            TerminatorKind::DropAndReplace { place, value, target: next_target, unwind: None },\n+            TerminatorKind::Drop { place, target: assign, unwind: Some(assign_unwind) },\n         );\n         self.diverge_from(block);\n \n-        next_target.unit()\n+        assign.unit()\n     }\n \n     /// Creates an `Assert` terminator and return the success block.\n@@ -1413,8 +1424,15 @@ impl<'tcx> DropTreeBuilder<'tcx> for Unwind {\n     fn add_entry(cfg: &mut CFG<'tcx>, from: BasicBlock, to: BasicBlock) {\n         let term = &mut cfg.block_data_mut(from).terminator_mut();\n         match &mut term.kind {\n-            TerminatorKind::Drop { unwind, .. }\n-            | TerminatorKind::DropAndReplace { unwind, .. }\n+            TerminatorKind::Drop { unwind, .. } => {\n+                if let Some(unwind) = *unwind {\n+                    let source_info = term.source_info;\n+                    cfg.terminate(unwind, source_info, TerminatorKind::Goto { target: to });\n+                } else {\n+                    *unwind = Some(to);\n+                }\n+            }\n+            TerminatorKind::DropAndReplace { unwind, .. }\n             | TerminatorKind::FalseUnwind { unwind, .. }\n             | TerminatorKind::Call { cleanup: unwind, .. }\n             | TerminatorKind::Assert { cleanup: unwind, .. }"}, {"sha": "dc4d2276e4aab43439bb00f729f4a64b52f40b04", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -888,3 +888,22 @@ pub enum MiscPatternSuggestion {\n         start_span: Span,\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_rustc_box_attribute_error)]\n+pub struct RustcBoxAttributeError {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub reason: RustcBoxAttrReason,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum RustcBoxAttrReason {\n+    #[note(mir_build_attributes)]\n+    Attributes,\n+    #[note(mir_build_not_box)]\n+    NotBoxNew,\n+    #[note(mir_build_missing_box)]\n+    MissingBox,\n+}"}, {"sha": "e10a264d385d0623e6eb7bbde6b9fced20c58e90", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -38,6 +38,6 @@ pub fn provide(providers: &mut Providers) {\n     providers.thir_check_unsafety = check_unsafety::thir_check_unsafety;\n     providers.thir_check_unsafety_for_const_arg = check_unsafety::thir_check_unsafety_for_const_arg;\n     providers.thir_body = thir::cx::thir_body;\n-    providers.thir_tree = thir::cx::thir_tree;\n-    providers.thir_flat = thir::cx::thir_flat;\n+    providers.thir_tree = thir::print::thir_tree;\n+    providers.thir_flat = thir::print::thir_flat;\n }"}, {"sha": "9086412c09a1cc34935f6192be9ce90628edfe69", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n use crate::thir::cx::region::Scope;\n use crate::thir::cx::Cx;\n use crate::thir::util::UserAnnotatedTyHelpers;\n@@ -18,7 +19,7 @@ use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{\n     self, AdtKind, InlineConstSubsts, InlineConstSubstsParts, ScalarInt, Ty, UpvarSubsts, UserType,\n };\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n use rustc_target::abi::VariantIdx;\n \n impl<'tcx> Cx<'tcx> {\n@@ -33,8 +34,6 @@ impl<'tcx> Cx<'tcx> {\n \n     #[instrument(level = \"trace\", skip(self, hir_expr))]\n     pub(super) fn mirror_expr_inner(&mut self, hir_expr: &'tcx hir::Expr<'tcx>) -> ExprId {\n-        let temp_lifetime =\n-            self.rvalue_scopes.temporary_scope(self.region_scope_tree, hir_expr.hir_id.local_id);\n         let expr_scope =\n             region::Scope { id: hir_expr.hir_id.local_id, data: region::ScopeData::Node };\n \n@@ -67,7 +66,7 @@ impl<'tcx> Cx<'tcx> {\n \n         // Next, wrap this up in the expr's scope.\n         expr = Expr {\n-            temp_lifetime,\n+            temp_lifetime: expr.temp_lifetime,\n             ty: expr.ty,\n             span: hir_expr.span,\n             kind: ExprKind::Scope {\n@@ -82,7 +81,7 @@ impl<'tcx> Cx<'tcx> {\n             self.region_scope_tree.opt_destruction_scope(hir_expr.hir_id.local_id)\n         {\n             expr = Expr {\n-                temp_lifetime,\n+                temp_lifetime: expr.temp_lifetime,\n                 ty: expr.ty,\n                 span: hir_expr.span,\n                 kind: ExprKind::Scope {\n@@ -262,6 +261,7 @@ impl<'tcx> Cx<'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn make_mirror_unadjusted(&mut self, expr: &'tcx hir::Expr<'tcx>) -> Expr<'tcx> {\n         let tcx = self.tcx;\n         let expr_ty = self.typeck_results().expr_ty(expr);\n@@ -322,6 +322,34 @@ impl<'tcx> Cx<'tcx> {\n                         fn_span: expr.span,\n                     }\n                 } else {\n+                    let attrs = tcx.hir().attrs(expr.hir_id);\n+                    if attrs.iter().any(|a| a.name_or_empty() == sym::rustc_box) {\n+                        if attrs.len() != 1 {\n+                            tcx.sess.emit_err(errors::RustcBoxAttributeError {\n+                                span: attrs[0].span,\n+                                reason: errors::RustcBoxAttrReason::Attributes,\n+                            });\n+                        } else if let Some(box_item) = tcx.lang_items().owned_box() {\n+                            if let hir::ExprKind::Path(hir::QPath::TypeRelative(ty, fn_path)) = fun.kind\n+                                && let hir::TyKind::Path(hir::QPath::Resolved(_, path)) = ty.kind\n+                                && path.res.opt_def_id().map_or(false, |did| did == box_item)\n+                                && fn_path.ident.name == sym::new\n+                                && let [value] = args\n+                            {\n+                                return Expr { temp_lifetime, ty: expr_ty, span: expr.span, kind: ExprKind::Box { value: self.mirror_expr(value) } }\n+                            } else {\n+                                tcx.sess.emit_err(errors::RustcBoxAttributeError {\n+                                    span: expr.span,\n+                                    reason: errors::RustcBoxAttrReason::NotBoxNew\n+                                });\n+                            }\n+                        } else {\n+                            tcx.sess.emit_err(errors::RustcBoxAttributeError {\n+                                span: attrs[0].span,\n+                                reason: errors::RustcBoxAttrReason::MissingBox,\n+                            });\n+                        }\n+                    }\n                     let adt_data =\n                         if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = fun.kind {\n                             // Tuple-like ADTs are represented as ExprKind::Call. We convert them here.\n@@ -541,8 +569,9 @@ impl<'tcx> Cx<'tcx> {\n                 let def_id = def_id.expect_local();\n \n                 let upvars = self\n-                    .typeck_results\n-                    .closure_min_captures_flattened(def_id)\n+                    .tcx\n+                    .closure_captures(def_id)\n+                    .iter()\n                     .zip(substs.upvar_tys())\n                     .map(|(captured_place, ty)| {\n                         let upvars = self.capture_upvar(expr, captured_place, ty);"}, {"sha": "070544446e3488549b322e3c51637673da3de4aa", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -52,23 +52,6 @@ pub(crate) fn thir_body(\n     Ok((tcx.alloc_steal_thir(cx.thir), expr))\n }\n \n-pub(crate) fn thir_tree(tcx: TyCtxt<'_>, owner_def: ty::WithOptConstParam<LocalDefId>) -> String {\n-    match thir_body(tcx, owner_def) {\n-        Ok((thir, _)) => {\n-            let thir = thir.steal();\n-            tcx.thir_tree_representation(&thir)\n-        }\n-        Err(_) => \"error\".into(),\n-    }\n-}\n-\n-pub(crate) fn thir_flat(tcx: TyCtxt<'_>, owner_def: ty::WithOptConstParam<LocalDefId>) -> String {\n-    match thir_body(tcx, owner_def) {\n-        Ok((thir, _)) => format!(\"{:#?}\", thir.steal()),\n-        Err(_) => \"error\".into(),\n-    }\n-}\n-\n struct Cx<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     thir: Thir<'tcx>,\n@@ -99,17 +82,38 @@ impl<'tcx> Cx<'tcx> {\n         let typeck_results = tcx.typeck_opt_const_arg(def);\n         let did = def.did;\n         let hir = tcx.hir();\n+        let hir_id = hir.local_def_id_to_hir_id(did);\n+\n+        let body_type = if hir.body_owner_kind(did).is_fn_or_closure() {\n+            // fetch the fully liberated fn signature (that is, all bound\n+            // types/lifetimes replaced)\n+            BodyTy::Fn(typeck_results.liberated_fn_sigs()[hir_id])\n+        } else {\n+            // Get the revealed type of this const. This is *not* the adjusted\n+            // type of its body, which may be a subtype of this type. For\n+            // example:\n+            //\n+            // fn foo(_: &()) {}\n+            // static X: fn(&'static ()) = foo;\n+            //\n+            // The adjusted type of the body of X is `for<'a> fn(&'a ())` which\n+            // is not the same as the type of X. We need the type of the return\n+            // place to be the type of the constant because NLL typeck will\n+            // equate them.\n+            BodyTy::Const(typeck_results.node_type(hir_id))\n+        };\n+\n         Cx {\n             tcx,\n-            thir: Thir::new(),\n+            thir: Thir::new(body_type),\n             param_env: tcx.param_env(def.did),\n             region_scope_tree: tcx.region_scope_tree(def.did),\n             typeck_results,\n             rvalue_scopes: &typeck_results.rvalue_scopes,\n             body_owner: did.to_def_id(),\n             adjustment_span: None,\n             apply_adjustments: hir\n-                .attrs(hir.local_def_id_to_hir_id(did))\n+                .attrs(hir_id)\n                 .iter()\n                 .all(|attr| attr.name_or_empty() != rustc_span::sym::custom_mir),\n         }"}, {"sha": "ca26cc13b5e877944c04280137c37dfbbb6541b1", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -5,9 +5,7 @@\n //! structures.\n \n pub(crate) mod constant;\n-\n pub(crate) mod cx;\n-\n pub(crate) mod pattern;\n-\n+pub(crate) mod print;\n mod util;"}, {"sha": "f356c8a68380c393532db2e1e17e8a24d2854388", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -25,7 +25,7 @@ use rustc_middle::mir::{BorrowKind, Field, Mutability};\n use rustc_middle::thir::{Ascription, BindingMode, FieldPat, LocalVarId, Pat, PatKind, PatRange};\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n use rustc_middle::ty::CanonicalUserTypeAnnotation;\n-use rustc_middle::ty::{self, AdtDef, ConstKind, DefIdTree, Region, Ty, TyCtxt, UserType};\n+use rustc_middle::ty::{self, AdtDef, ConstKind, Region, Ty, TyCtxt, UserType};\n use rustc_span::{Span, Symbol};\n \n use std::cmp::Ordering;"}, {"sha": "8028227aafd2acc4ac302aa06d757b1c0fc27227", "filename": "compiler/rustc_mir_build/src/thir/print.rs", "status": "renamed", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fprint.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,13 +1,24 @@\n-use crate::thir::*;\n-use crate::ty::{self, TyCtxt};\n-\n+use rustc_middle::thir::*;\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_span::def_id::LocalDefId;\n use std::fmt::{self, Write};\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn thir_tree_representation<'a>(self, thir: &'a Thir<'tcx>) -> String {\n-        let mut printer = ThirPrinter::new(thir);\n-        printer.print();\n-        printer.into_buffer()\n+pub(crate) fn thir_tree(tcx: TyCtxt<'_>, owner_def: ty::WithOptConstParam<LocalDefId>) -> String {\n+    match super::cx::thir_body(tcx, owner_def) {\n+        Ok((thir, _)) => {\n+            let thir = thir.steal();\n+            let mut printer = ThirPrinter::new(&thir);\n+            printer.print();\n+            printer.into_buffer()\n+        }\n+        Err(_) => \"error\".into(),\n+    }\n+}\n+\n+pub(crate) fn thir_flat(tcx: TyCtxt<'_>, owner_def: ty::WithOptConstParam<LocalDefId>) -> String {\n+    match super::cx::thir_body(tcx, owner_def) {\n+        Ok((thir, _)) => format!(\"{:#?}\", thir.steal()),\n+        Err(_) => \"error\".into(),\n     }\n }\n ", "previous_filename": "compiler/rustc_middle/src/thir/print.rs"}, {"sha": "536745d2cfea94de15c82bbe57654c1926d5dd11", "filename": "compiler/rustc_mir_transform/src/check_const_item_mutation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> ConstMutationChecker<'_, 'tcx> {\n         //\n         // `unsafe { *FOO = 0; *BAR.field = 1; }`\n         // `unsafe { &mut *FOO }`\n-        // `unsafe { (*ARRAY)[0] = val; }\n+        // `unsafe { (*ARRAY)[0] = val; }`\n         if !place.projection.iter().any(|p| matches!(p, PlaceElem::Deref)) {\n             let source_info = self.body.source_info(location);\n             let lint_root = self.body.source_scopes[source_info.scope]"}, {"sha": "8ee316773aeaf0daeef4f5428b381e9bce866278", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -407,7 +407,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                 if self.prev().is_macro_expansion() && self.curr().is_macro_expansion() {\n                     // Macros that expand to include branching (such as\n                     // `assert_eq!()`, `assert_ne!()`, `info!()`, `debug!()`, or\n-                    // `trace!()) typically generate callee spans with identical\n+                    // `trace!()`) typically generate callee spans with identical\n                     // ranges (typically the full span of the macro) for all\n                     // `BasicBlocks`. This makes it impossible to distinguish\n                     // the condition (`if val1 != val2`) from the optional\n@@ -694,7 +694,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     /// `prev.span.hi()` will be greater than (further right of) `prev_original_span.hi()`.\n     /// If prev.span() was split off to the right of a closure, prev.span().lo() will be\n     /// greater than prev_original_span.lo(). The actual span of `prev_original_span` is\n-    /// not as important as knowing that `prev()` **used to have the same span** as `curr(),\n+    /// not as important as knowing that `prev()` **used to have the same span** as `curr()`,\n     /// which means their sort order is still meaningful for determining the dominator\n     /// relationship.\n     ///"}, {"sha": "29424f09695f1d123e5c8dc5f53ba4a364c4308f", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -14,7 +14,7 @@ use rustc_mir_dataflow::un_derefer::UnDerefer;\n use rustc_mir_dataflow::MoveDataParamEnv;\n use rustc_mir_dataflow::{on_all_children_bits, on_all_drop_children_bits};\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n-use rustc_span::Span;\n+use rustc_span::{DesugaringKind, Span};\n use rustc_target::abi::VariantIdx;\n use std::fmt;\n \n@@ -425,10 +425,19 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                             bb,\n                         ),\n                         LookupResult::Parent(..) => {\n-                            self.tcx.sess.delay_span_bug(\n-                                terminator.source_info.span,\n-                                &format!(\"drop of untracked value {:?}\", bb),\n-                            );\n+                            if !matches!(\n+                                terminator.source_info.span.desugaring_kind(),\n+                                Some(DesugaringKind::Replace),\n+                            ) {\n+                                self.tcx.sess.delay_span_bug(\n+                                    terminator.source_info.span,\n+                                    &format!(\"drop of untracked value {:?}\", bb),\n+                                );\n+                            }\n+                            // A drop and replace behind a pointer/array/whatever.\n+                            // The borrow checker requires that these locations are initialized before the assignment,\n+                            // so we just leave an unconditional drop.\n+                            assert!(!data.is_cleanup);\n                         }\n                     }\n                 }"}, {"sha": "4182da1957e39d9ac662f18bd774ed47b2505d88", "filename": "compiler/rustc_mir_transform/src/instcombine.rs", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -6,9 +6,9 @@ use rustc_middle::mir::{\n     BinOp, Body, Constant, ConstantKind, LocalDecls, Operand, Place, ProjectionElem, Rvalue,\n     SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UnOp,\n };\n-use rustc_middle::ty::layout::LayoutError;\n-use rustc_middle::ty::{self, ParamEnv, ParamEnvAnd, SubstsRef, Ty, TyCtxt};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_middle::ty::layout::ValidityRequirement;\n+use rustc_middle::ty::{self, ParamEnv, SubstsRef, Ty, TyCtxt};\n+use rustc_span::symbol::Symbol;\n \n pub struct InstCombine;\n \n@@ -234,16 +234,15 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n         }\n         let ty = substs.type_at(0);\n \n-        // Check this is a foldable intrinsic before we query the layout of our generic parameter\n-        let Some(assert_panics) = intrinsic_assert_panics(intrinsic_name) else { return; };\n-        match assert_panics(self.tcx, self.param_env.and(ty)) {\n-            // We don't know the layout, don't touch the assertion\n-            Err(_) => {}\n-            Ok(true) => {\n+        let known_is_valid = intrinsic_assert_panics(self.tcx, self.param_env, ty, intrinsic_name);\n+        match known_is_valid {\n+            // We don't know the layout or it's not validity assertion at all, don't touch it\n+            None => {}\n+            Some(true) => {\n                 // If we know the assert panics, indicate to later opts that the call diverges\n                 *target = None;\n             }\n-            Ok(false) => {\n+            Some(false) => {\n                 // If we know the assert does not panic, turn the call into a Goto\n                 terminator.kind = TerminatorKind::Goto { target: *target_block };\n             }\n@@ -252,33 +251,13 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n }\n \n fn intrinsic_assert_panics<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n     intrinsic_name: Symbol,\n-) -> Option<fn(TyCtxt<'tcx>, ParamEnvAnd<'tcx, Ty<'tcx>>) -> Result<bool, LayoutError<'tcx>>> {\n-    fn inhabited_predicate<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        param_env_and_ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Result<bool, LayoutError<'tcx>> {\n-        Ok(tcx.layout_of(param_env_and_ty)?.abi.is_uninhabited())\n-    }\n-    fn zero_valid_predicate<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        param_env_and_ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Result<bool, LayoutError<'tcx>> {\n-        Ok(!tcx.permits_zero_init(param_env_and_ty)?)\n-    }\n-    fn mem_uninitialized_valid_predicate<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        param_env_and_ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Result<bool, LayoutError<'tcx>> {\n-        Ok(!tcx.permits_uninit_init(param_env_and_ty)?)\n-    }\n-\n-    match intrinsic_name {\n-        sym::assert_inhabited => Some(inhabited_predicate),\n-        sym::assert_zero_valid => Some(zero_valid_predicate),\n-        sym::assert_mem_uninitialized_valid => Some(mem_uninitialized_valid_predicate),\n-        _ => None,\n-    }\n+) -> Option<bool> {\n+    let requirement = ValidityRequirement::from_intrinsic(intrinsic_name)?;\n+    Some(!tcx.check_validity_requirement((requirement, param_env.and(ty))).ok()?)\n }\n \n fn resolve_rust_intrinsic<'tcx>("}, {"sha": "cdd28ae0c0197df622981fb0221a8b4babfdd7ed", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -248,7 +248,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) ->\n \n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_promoted()`, which steals\n-    // from `mir_const(), forces this query to execute before\n+    // from `mir_const()`, forces this query to execute before\n     // performing the steal.\n     let body = &tcx.mir_const(def).borrow();\n "}, {"sha": "c6e7468aab4299424d3e36c9ed5ca763ba77be01", "filename": "compiler/rustc_mir_transform/src/lower_slice_len.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -68,8 +68,11 @@ fn lower_slice_len_call<'tcx>(\n                 ty::FnDef(fn_def_id, _) if fn_def_id == &slice_len_fn_item_def_id => {\n                     // perform modifications\n                     // from something like `_5 = core::slice::<impl [u8]>::len(move _6) -> bb1`\n-                    // into `_5 = Len(*_6)\n+                    // into:\n+                    // ```\n+                    // _5 = Len(*_6)\n                     // goto bb1\n+                    // ```\n \n                     // make new RValue for Len\n                     let deref_arg = tcx.mk_place_deref(arg);"}, {"sha": "3c7425d83c4880b387c82d22f449379337a1fd27", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::middle::exported_symbols::{SymbolExportInfo, SymbolExportLevel\n use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, Linkage, Visibility};\n use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n use rustc_middle::ty::print::characteristic_def_id_of_type;\n-use rustc_middle::ty::{self, visit::TypeVisitableExt, DefIdTree, InstanceDef, TyCtxt};\n+use rustc_middle::ty::{self, visit::TypeVisitableExt, InstanceDef, TyCtxt};\n use rustc_span::symbol::Symbol;\n \n use super::PartitioningCx;"}, {"sha": "e76e91fc1b1351eb00cd8aa6c4923a47e2b76e40", "filename": "compiler/rustc_parse/locales/en-US.ftl", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Flocales%2Fen-US.ftl?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -151,6 +151,10 @@ parse_missing_in_in_for_loop = missing `in` in `for` loop\n parse_missing_expression_in_for_loop = missing expression to iterate on in `for` loop\n     .suggestion = try adding an expression to the `for` loop\n \n+parse_loop_else = `{$loop_kind}...else` loops are not supported\n+    .note = consider moving this `else` clause to a separate `if` statement and use a `bool` variable to control if it should run\n+    .loop_keyword = `else` is attached to this loop\n+\n parse_missing_comma_after_match_arm = expected `,` following `match` arm\n     .suggestion = missing a comma here to end this `match` arm\n \n@@ -220,7 +224,7 @@ parse_match_arm_body_without_braces = `match` arm body without braces\n             [one] statement\n            *[other] statements\n         } with a body\n-    .suggestion_use_comma_not_semicolon = use a comma to end a `match` arm expression\n+    .suggestion_use_comma_not_semicolon = replace `;` with `,` to end a `match` arm expression\n \n parse_inclusive_range_extra_equals = unexpected `=` after inclusive range\n     .suggestion_remove_eq = use `..=` instead"}, {"sha": "1662db36d10f915372baef23964aa54e7ef3b337", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -451,6 +451,17 @@ pub(crate) struct MissingExpressionInForLoop {\n     pub span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(parse_loop_else)]\n+#[note]\n+pub(crate) struct LoopElseNotSupported {\n+    #[primary_span]\n+    pub span: Span,\n+    pub loop_kind: &'static str,\n+    #[label(parse_loop_keyword)]\n+    pub loop_kw: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(parse_missing_comma_after_match_arm)]\n pub(crate) struct MissingCommaAfterMatchArm {"}, {"sha": "27f4428d306cd47604dd8a30e35e7cf3022dd73a", "filename": "compiler/rustc_parse/src/lexer/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fdiagnostics.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,4 +1,4 @@\n-use super::UnmatchedBrace;\n+use super::UnmatchedDelim;\n use rustc_ast::token::Delimiter;\n use rustc_errors::Diagnostic;\n use rustc_span::source_map::SourceMap;\n@@ -8,7 +8,7 @@ use rustc_span::Span;\n pub struct TokenTreeDiagInfo {\n     /// Stack of open delimiters and their spans. Used for error message.\n     pub open_braces: Vec<(Delimiter, Span)>,\n-    pub unmatched_braces: Vec<UnmatchedBrace>,\n+    pub unmatched_delims: Vec<UnmatchedDelim>,\n \n     /// Used only for error recovery when arriving to EOF with mismatched braces.\n     pub last_unclosed_found_span: Option<Span>,\n@@ -32,10 +32,10 @@ pub fn same_identation_level(sm: &SourceMap, open_sp: Span, close_sp: Span) -> b\n // it's more friendly compared to report `unmatched error` in later phase\n pub fn report_missing_open_delim(\n     err: &mut Diagnostic,\n-    unmatched_braces: &[UnmatchedBrace],\n+    unmatched_delims: &[UnmatchedDelim],\n ) -> bool {\n     let mut reported_missing_open = false;\n-    for unmatch_brace in unmatched_braces.iter() {\n+    for unmatch_brace in unmatched_delims.iter() {\n         if let Some(delim) = unmatch_brace.found_delim\n             && matches!(delim, Delimiter::Parenthesis | Delimiter::Bracket)\n         {\n@@ -60,7 +60,7 @@ pub fn report_suspicious_mismatch_block(\n     sm: &SourceMap,\n     delim: Delimiter,\n ) {\n-    if report_missing_open_delim(err, &diag_info.unmatched_braces) {\n+    if report_missing_open_delim(err, &diag_info.unmatched_delims) {\n         return;\n     }\n "}, {"sha": "9dbddee5a56f0ddc0c45831b8ab3ee881391ed30", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,10 +1,11 @@\n use crate::errors;\n use crate::lexer::unicode_chars::UNICODE_ARRAY;\n+use crate::make_unclosed_delims_error;\n use rustc_ast::ast::{self, AttrStyle};\n use rustc_ast::token::{self, CommentKind, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::util::unicode::contains_text_flow_control_chars;\n-use rustc_errors::{error_code, Applicability, DiagnosticBuilder, PResult, StashKey};\n+use rustc_errors::{error_code, Applicability, Diagnostic, DiagnosticBuilder, StashKey};\n use rustc_lexer::unescape::{self, Mode};\n use rustc_lexer::Cursor;\n use rustc_lexer::{Base, DocStyle, RawStrError};\n@@ -31,7 +32,7 @@ use unescape_error_reporting::{emit_unescape_error, escaped_char};\n rustc_data_structures::static_assert_size!(rustc_lexer::Token, 12);\n \n #[derive(Clone, Debug)]\n-pub struct UnmatchedBrace {\n+pub struct UnmatchedDelim {\n     pub expected_delim: Delimiter,\n     pub found_delim: Option<Delimiter>,\n     pub found_span: Span,\n@@ -44,7 +45,7 @@ pub(crate) fn parse_token_trees<'a>(\n     mut src: &'a str,\n     mut start_pos: BytePos,\n     override_span: Option<Span>,\n-) -> (PResult<'a, TokenStream>, Vec<UnmatchedBrace>) {\n+) -> Result<TokenStream, Vec<Diagnostic>> {\n     // Skip `#!`, if present.\n     if let Some(shebang_len) = rustc_lexer::strip_shebang(src) {\n         src = &src[shebang_len..];\n@@ -61,7 +62,29 @@ pub(crate) fn parse_token_trees<'a>(\n         override_span,\n         nbsp_is_whitespace: false,\n     };\n-    tokentrees::TokenTreesReader::parse_all_token_trees(string_reader)\n+    let (token_trees, unmatched_delims) =\n+        tokentrees::TokenTreesReader::parse_all_token_trees(string_reader);\n+    match token_trees {\n+        Ok(stream) if unmatched_delims.is_empty() => Ok(stream),\n+        _ => {\n+            // Return error if there are unmatched delimiters or unclosng delimiters.\n+            // We emit delimiter mismatch errors first, then emit the unclosing delimiter mismatch\n+            // because the delimiter mismatch is more likely to be the root cause of error\n+\n+            let mut buffer = Vec::with_capacity(1);\n+            // Not using `emit_unclosed_delims` to use `db.buffer`\n+            for unmatched in unmatched_delims {\n+                if let Some(err) = make_unclosed_delims_error(unmatched, &sess) {\n+                    err.buffer(&mut buffer);\n+                }\n+            }\n+            if let Err(err) = token_trees {\n+                // Add unclosing delimiter error\n+                err.buffer(&mut buffer);\n+            }\n+            Err(buffer)\n+        }\n+    }\n }\n \n struct StringReader<'a> {"}, {"sha": "36fd1e37d651ebbd08388bb67f8d028bd7c5b630", "filename": "compiler/rustc_parse/src/lexer/tokentrees.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,7 +1,7 @@\n use super::diagnostics::report_suspicious_mismatch_block;\n use super::diagnostics::same_identation_level;\n use super::diagnostics::TokenTreeDiagInfo;\n-use super::{StringReader, UnmatchedBrace};\n+use super::{StringReader, UnmatchedDelim};\n use rustc_ast::token::{self, Delimiter, Token};\n use rustc_ast::tokenstream::{DelimSpan, Spacing, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust::token_to_string;\n@@ -18,14 +18,14 @@ pub(super) struct TokenTreesReader<'a> {\n impl<'a> TokenTreesReader<'a> {\n     pub(super) fn parse_all_token_trees(\n         string_reader: StringReader<'a>,\n-    ) -> (PResult<'a, TokenStream>, Vec<UnmatchedBrace>) {\n+    ) -> (PResult<'a, TokenStream>, Vec<UnmatchedDelim>) {\n         let mut tt_reader = TokenTreesReader {\n             string_reader,\n             token: Token::dummy(),\n             diag_info: TokenTreeDiagInfo::default(),\n         };\n         let res = tt_reader.parse_token_trees(/* is_delimited */ false);\n-        (res, tt_reader.diag_info.unmatched_braces)\n+        (res, tt_reader.diag_info.unmatched_delims)\n     }\n \n     // Parse a stream of tokens into a list of `TokenTree`s.\n@@ -34,7 +34,7 @@ impl<'a> TokenTreesReader<'a> {\n         let mut buf = Vec::new();\n         loop {\n             match self.token.kind {\n-                token::OpenDelim(delim) => buf.push(self.parse_token_tree_open_delim(delim)),\n+                token::OpenDelim(delim) => buf.push(self.parse_token_tree_open_delim(delim)?),\n                 token::CloseDelim(delim) => {\n                     return if is_delimited {\n                         Ok(TokenStream::new(buf))\n@@ -43,10 +43,11 @@ impl<'a> TokenTreesReader<'a> {\n                     };\n                 }\n                 token::Eof => {\n-                    if is_delimited {\n-                        self.eof_err().emit();\n-                    }\n-                    return Ok(TokenStream::new(buf));\n+                    return if is_delimited {\n+                        Err(self.eof_err())\n+                    } else {\n+                        Ok(TokenStream::new(buf))\n+                    };\n                 }\n                 _ => {\n                     // Get the next normal token. This might require getting multiple adjacent\n@@ -78,7 +79,7 @@ impl<'a> TokenTreesReader<'a> {\n         let mut err = self.string_reader.sess.span_diagnostic.struct_span_err(self.token.span, msg);\n         for &(_, sp) in &self.diag_info.open_braces {\n             err.span_label(sp, \"unclosed delimiter\");\n-            self.diag_info.unmatched_braces.push(UnmatchedBrace {\n+            self.diag_info.unmatched_delims.push(UnmatchedDelim {\n                 expected_delim: Delimiter::Brace,\n                 found_delim: None,\n                 found_span: self.token.span,\n@@ -98,7 +99,7 @@ impl<'a> TokenTreesReader<'a> {\n         err\n     }\n \n-    fn parse_token_tree_open_delim(&mut self, open_delim: Delimiter) -> TokenTree {\n+    fn parse_token_tree_open_delim(&mut self, open_delim: Delimiter) -> PResult<'a, TokenTree> {\n         // The span for beginning of the delimited section\n         let pre_span = self.token.span;\n \n@@ -107,7 +108,7 @@ impl<'a> TokenTreesReader<'a> {\n         // Parse the token trees within the delimiters.\n         // We stop at any delimiter so we can try to recover if the user\n         // uses an incorrect delimiter.\n-        let tts = self.parse_token_trees(/* is_delimited */ true).unwrap();\n+        let tts = self.parse_token_trees(/* is_delimited */ true)?;\n \n         // Expand to cover the entire delimited token tree\n         let delim_span = DelimSpan::from_pair(pre_span, self.token.span);\n@@ -160,7 +161,7 @@ impl<'a> TokenTreesReader<'a> {\n                         }\n                     }\n                     let (tok, _) = self.diag_info.open_braces.pop().unwrap();\n-                    self.diag_info.unmatched_braces.push(UnmatchedBrace {\n+                    self.diag_info.unmatched_delims.push(UnmatchedDelim {\n                         expected_delim: tok,\n                         found_delim: Some(close_delim),\n                         found_span: self.token.span,\n@@ -190,7 +191,7 @@ impl<'a> TokenTreesReader<'a> {\n             _ => unreachable!(),\n         }\n \n-        TokenTree::Delimited(delim_span, open_delim, tts)\n+        Ok(TokenTree::Delimited(delim_span, open_delim, tts))\n     }\n \n     fn close_delim_err(&mut self, delim: Delimiter) -> PErr<'a> {"}, {"sha": "d1c3fd0cd0f8f7559e412a799bfe6e7bce2d2448", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -30,7 +30,7 @@ pub const MACRO_ARGUMENTS: Option<&str> = Some(\"macro arguments\");\n \n #[macro_use]\n pub mod parser;\n-use parser::{emit_unclosed_delims, make_unclosed_delims_error, Parser};\n+use parser::{make_unclosed_delims_error, Parser};\n pub mod lexer;\n pub mod validate_attr;\n \n@@ -96,10 +96,7 @@ pub fn parse_stream_from_source_str(\n     sess: &ParseSess,\n     override_span: Option<Span>,\n ) -> TokenStream {\n-    let (stream, mut errors) =\n-        source_file_to_stream(sess, sess.source_map().new_source_file(name, source), override_span);\n-    emit_unclosed_delims(&mut errors, &sess);\n-    stream\n+    source_file_to_stream(sess, sess.source_map().new_source_file(name, source), override_span)\n }\n \n /// Creates a new parser from a source string.\n@@ -135,9 +132,8 @@ fn maybe_source_file_to_parser(\n     source_file: Lrc<SourceFile>,\n ) -> Result<Parser<'_>, Vec<Diagnostic>> {\n     let end_pos = source_file.end_pos;\n-    let (stream, unclosed_delims) = maybe_file_to_stream(sess, source_file, None)?;\n+    let stream = maybe_file_to_stream(sess, source_file, None)?;\n     let mut parser = stream_to_parser(sess, stream, None);\n-    parser.unclosed_delims = unclosed_delims;\n     if parser.token == token::Eof {\n         parser.token.span = Span::new(end_pos, end_pos, parser.token.span.ctxt(), None);\n     }\n@@ -182,7 +178,7 @@ pub fn source_file_to_stream(\n     sess: &ParseSess,\n     source_file: Lrc<SourceFile>,\n     override_span: Option<Span>,\n-) -> (TokenStream, Vec<lexer::UnmatchedBrace>) {\n+) -> TokenStream {\n     panictry_buffer!(&sess.span_diagnostic, maybe_file_to_stream(sess, source_file, override_span))\n }\n \n@@ -192,31 +188,15 @@ pub fn maybe_file_to_stream(\n     sess: &ParseSess,\n     source_file: Lrc<SourceFile>,\n     override_span: Option<Span>,\n-) -> Result<(TokenStream, Vec<lexer::UnmatchedBrace>), Vec<Diagnostic>> {\n+) -> Result<TokenStream, Vec<Diagnostic>> {\n     let src = source_file.src.as_ref().unwrap_or_else(|| {\n         sess.span_diagnostic.bug(&format!(\n             \"cannot lex `source_file` without source: {}\",\n             sess.source_map().filename_for_diagnostics(&source_file.name)\n         ));\n     });\n \n-    let (token_trees, unmatched_braces) =\n-        lexer::parse_token_trees(sess, src.as_str(), source_file.start_pos, override_span);\n-\n-    match token_trees {\n-        Ok(stream) => Ok((stream, unmatched_braces)),\n-        Err(err) => {\n-            let mut buffer = Vec::with_capacity(1);\n-            err.buffer(&mut buffer);\n-            // Not using `emit_unclosed_delims` to use `db.buffer`\n-            for unmatched in unmatched_braces {\n-                if let Some(err) = make_unclosed_delims_error(unmatched, &sess) {\n-                    err.buffer(&mut buffer);\n-                }\n-            }\n-            Err(buffer)\n-        }\n-    }\n+    lexer::parse_token_trees(sess, src.as_str(), source_file.start_pos, override_span)\n }\n \n /// Given a stream and the `ParseSess`, produces a parser."}, {"sha": "b0ab0f1062471523a87d3ccec098dbff86c1a6cd", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -134,11 +134,11 @@ impl ToAttrTokenStream for LazyAttrTokenStreamImpl {\n             // Process the replace ranges, starting from the highest start\n             // position and working our way back. If have tokens like:\n             //\n-            // `#[cfg(FALSE)]` struct Foo { #[cfg(FALSE)] field: bool }`\n+            // `#[cfg(FALSE)] struct Foo { #[cfg(FALSE)] field: bool }`\n             //\n             // Then we will generate replace ranges for both\n             // the `#[cfg(FALSE)] field: bool` and the entire\n-            // `#[cfg(FALSE)]` struct Foo { #[cfg(FALSE)] field: bool }`\n+            // `#[cfg(FALSE)] struct Foo { #[cfg(FALSE)] field: bool }`\n             //\n             // By starting processing from the replace range with the greatest\n             // start position, we ensure that any replace range which encloses"}, {"sha": "0a65c37ea7b79332c1c8e3e86da1979ffd452c48", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 115, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -19,7 +19,6 @@ use crate::errors::{\n };\n \n use crate::fluent_generated as fluent;\n-use crate::lexer::UnmatchedBrace;\n use crate::parser;\n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n@@ -165,8 +164,6 @@ enum IsStandalone {\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n enum IncOrDec {\n     Inc,\n-    // FIXME: `i--` recovery isn't implemented yet\n-    #[allow(dead_code)]\n     Dec,\n }\n \n@@ -222,7 +219,6 @@ impl MultiSugg {\n /// is dropped.\n pub struct SnapshotParser<'a> {\n     parser: Parser<'a>,\n-    unclosed_delims: Vec<UnmatchedBrace>,\n }\n \n impl<'a> Deref for SnapshotParser<'a> {\n@@ -257,27 +253,15 @@ impl<'a> Parser<'a> {\n         &self.sess.span_diagnostic\n     }\n \n-    /// Replace `self` with `snapshot.parser` and extend `unclosed_delims` with `snapshot.unclosed_delims`.\n-    /// This is to avoid losing unclosed delims errors `create_snapshot_for_diagnostic` clears.\n+    /// Replace `self` with `snapshot.parser`.\n     pub(super) fn restore_snapshot(&mut self, snapshot: SnapshotParser<'a>) {\n         *self = snapshot.parser;\n-        self.unclosed_delims.extend(snapshot.unclosed_delims);\n-    }\n-\n-    pub fn unclosed_delims(&self) -> &[UnmatchedBrace] {\n-        &self.unclosed_delims\n     }\n \n     /// Create a snapshot of the `Parser`.\n     pub fn create_snapshot_for_diagnostic(&self) -> SnapshotParser<'a> {\n-        let mut snapshot = self.clone();\n-        let unclosed_delims = self.unclosed_delims.clone();\n-        // Clear `unclosed_delims` in snapshot to avoid\n-        // duplicate errors being emitted when the `Parser`\n-        // is dropped (which may or may not happen, depending\n-        // if the parsing the snapshot is created for is successful)\n-        snapshot.unclosed_delims.clear();\n-        SnapshotParser { parser: snapshot, unclosed_delims }\n+        let snapshot = self.clone();\n+        SnapshotParser { parser: snapshot }\n     }\n \n     pub(super) fn span_to_snippet(&self, span: Span) -> Result<String, SpanSnippetError> {\n@@ -581,21 +565,6 @@ impl<'a> Parser<'a> {\n         } else {\n             label_sp\n         };\n-        match self.recover_closing_delimiter(\n-            &expected\n-                .iter()\n-                .filter_map(|tt| match tt {\n-                    TokenType::Token(t) => Some(t.clone()),\n-                    _ => None,\n-                })\n-                .collect::<Vec<_>>(),\n-            err,\n-        ) {\n-            Err(e) => err = e,\n-            Ok(recovered) => {\n-                return Ok(recovered);\n-            }\n-        }\n \n         if self.check_too_many_raw_str_terminators(&mut err) {\n             if expected.contains(&TokenType::Token(token::Semi)) && self.eat(&token::Semi) {\n@@ -1357,6 +1326,20 @@ impl<'a> Parser<'a> {\n         self.recover_from_inc_dec(operand_expr, kind, op_span)\n     }\n \n+    pub(super) fn recover_from_postfix_decrement(\n+        &mut self,\n+        operand_expr: P<Expr>,\n+        op_span: Span,\n+        start_stmt: bool,\n+    ) -> PResult<'a, P<Expr>> {\n+        let kind = IncDecRecovery {\n+            standalone: if start_stmt { IsStandalone::Standalone } else { IsStandalone::Subexpr },\n+            op: IncOrDec::Dec,\n+            fixity: UnaryFixity::Post,\n+        };\n+        self.recover_from_inc_dec(operand_expr, kind, op_span)\n+    }\n+\n     fn recover_from_inc_dec(\n         &mut self,\n         base: P<Expr>,\n@@ -1561,12 +1544,6 @@ impl<'a> Parser<'a> {\n         );\n         let mut err = self.struct_span_err(sp, &msg);\n         let label_exp = format!(\"expected `{token_str}`\");\n-        match self.recover_closing_delimiter(&[t.clone()], err) {\n-            Err(e) => err = e,\n-            Ok(recovered) => {\n-                return Ok(recovered);\n-            }\n-        }\n         let sm = self.sess.source_map();\n         if !sm.is_multiline(prev_sp.until(sp)) {\n             // When the spans are in the same line, it means that the only content\n@@ -1783,81 +1760,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn recover_closing_delimiter(\n-        &mut self,\n-        tokens: &[TokenKind],\n-        mut err: DiagnosticBuilder<'a, ErrorGuaranteed>,\n-    ) -> PResult<'a, bool> {\n-        let mut pos = None;\n-        // We want to use the last closing delim that would apply.\n-        for (i, unmatched) in self.unclosed_delims.iter().enumerate().rev() {\n-            if tokens.contains(&token::CloseDelim(unmatched.expected_delim))\n-                && Some(self.token.span) > unmatched.unclosed_span\n-            {\n-                pos = Some(i);\n-            }\n-        }\n-        match pos {\n-            Some(pos) => {\n-                // Recover and assume that the detected unclosed delimiter was meant for\n-                // this location. Emit the diagnostic and act as if the delimiter was\n-                // present for the parser's sake.\n-\n-                // Don't attempt to recover from this unclosed delimiter more than once.\n-                let unmatched = self.unclosed_delims.remove(pos);\n-                let delim = TokenType::Token(token::CloseDelim(unmatched.expected_delim));\n-                if unmatched.found_delim.is_none() {\n-                    // We encountered `Eof`, set this fact here to avoid complaining about missing\n-                    // `fn main()` when we found place to suggest the closing brace.\n-                    *self.sess.reached_eof.borrow_mut() = true;\n-                }\n-\n-                // We want to suggest the inclusion of the closing delimiter where it makes\n-                // the most sense, which is immediately after the last token:\n-                //\n-                //  {foo(bar {}}\n-                //      ^      ^\n-                //      |      |\n-                //      |      help: `)` may belong here\n-                //      |\n-                //      unclosed delimiter\n-                if let Some(sp) = unmatched.unclosed_span {\n-                    let mut primary_span: Vec<Span> =\n-                        err.span.primary_spans().iter().cloned().collect();\n-                    primary_span.push(sp);\n-                    let mut primary_span: MultiSpan = primary_span.into();\n-                    for span_label in err.span.span_labels() {\n-                        if let Some(label) = span_label.label {\n-                            primary_span.push_span_label(span_label.span, label);\n-                        }\n-                    }\n-                    err.set_span(primary_span);\n-                    err.span_label(sp, \"unclosed delimiter\");\n-                }\n-                // Backticks should be removed to apply suggestions.\n-                let mut delim = delim.to_string();\n-                delim.retain(|c| c != '`');\n-                err.span_suggestion_short(\n-                    self.prev_token.span.shrink_to_hi(),\n-                    &format!(\"`{delim}` may belong here\"),\n-                    delim,\n-                    Applicability::MaybeIncorrect,\n-                );\n-                if unmatched.found_delim.is_none() {\n-                    // Encountered `Eof` when lexing blocks. Do not recover here to avoid knockdown\n-                    // errors which would be emitted elsewhere in the parser and let other error\n-                    // recovery consume the rest of the file.\n-                    Err(err)\n-                } else {\n-                    err.emit();\n-                    self.expected_tokens.clear(); // Reduce the number of errors.\n-                    Ok(true)\n-                }\n-            }\n-            _ => Err(err),\n-        }\n-    }\n-\n     /// Eats tokens until we can be relatively sure we reached the end of the\n     /// statement. This is something of a best-effort heuristic.\n     ///"}, {"sha": "e00eda47c663ee0cc811b370bc8cf8375511c980", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -282,6 +282,18 @@ impl<'a> Parser<'a> {\n                 continue;\n             }\n \n+            if self.prev_token == token::BinOp(token::Minus)\n+                && self.token == token::BinOp(token::Minus)\n+                && self.prev_token.span.between(self.token.span).is_empty()\n+                && !self.look_ahead(1, |tok| tok.can_begin_expr())\n+            {\n+                let op_span = self.prev_token.span.to(self.token.span);\n+                // Eat the second `-`\n+                self.bump();\n+                lhs = self.recover_from_postfix_decrement(lhs, op_span, starts_stmt)?;\n+                continue;\n+            }\n+\n             let op = op.node;\n             // Special cases:\n             if op == AssocOp::As {\n@@ -1198,8 +1210,13 @@ impl<'a> Parser<'a> {\n                         // `Enum::Foo { a: 3, b: 4 }` or `Enum::Foo(3, 4)`.\n                         self.restore_snapshot(snapshot);\n                         let close_paren = self.prev_token.span;\n-                        let span = lo.to(self.prev_token.span);\n-                        if !fields.is_empty() {\n+                        let span = lo.to(close_paren);\n+                        if !fields.is_empty() &&\n+                            // `token.kind` should not be compared here.\n+                            // This is because the `snapshot.token.kind` is treated as the same as\n+                            // that of the open delim in `TokenTreesReader::parse_token_tree`, even if they are different.\n+                            self.span_to_snippet(close_paren).map_or(false, |snippet| snippet == \")\")\n+                        {\n                             let mut replacement_err = errors::ParenthesesWithStructFields {\n                                 span,\n                                 r#type: path,\n@@ -1377,19 +1394,6 @@ impl<'a> Parser<'a> {\n             self.parse_expr_let()\n         } else if self.eat_keyword(kw::Underscore) {\n             Ok(self.mk_expr(self.prev_token.span, ExprKind::Underscore))\n-        } else if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n-            // Don't complain about bare semicolons after unclosed braces\n-            // recovery in order to keep the error count down. Fixing the\n-            // delimiters will possibly also fix the bare semicolon found in\n-            // expression context. For example, silence the following error:\n-            //\n-            //     error: expected expression, found `;`\n-            //      --> file.rs:2:13\n-            //       |\n-            //     2 |     foo(bar(;\n-            //       |             ^ expected expression\n-            self.bump();\n-            Ok(self.mk_expr_err(self.token.span))\n         } else if self.token.uninterpolated_span().rust_2018() {\n             // `Span::rust_2018()` is somewhat expensive; don't get it repeatedly.\n             if self.check_keyword(kw::Async) {\n@@ -2491,9 +2495,27 @@ impl<'a> Parser<'a> {\n         let (attrs, loop_block) = self.parse_inner_attrs_and_block()?;\n \n         let kind = ExprKind::ForLoop(pat, expr, loop_block, opt_label);\n+\n+        self.recover_loop_else(\"for\", lo)?;\n+\n         Ok(self.mk_expr_with_attrs(lo.to(self.prev_token.span), kind, attrs))\n     }\n \n+    /// Recovers from an `else` clause after a loop (`for...else`, `while...else`)\n+    fn recover_loop_else(&mut self, loop_kind: &'static str, loop_kw: Span) -> PResult<'a, ()> {\n+        if self.token.is_keyword(kw::Else) && self.may_recover() {\n+            let else_span = self.token.span;\n+            self.bump();\n+            let else_clause = self.parse_expr_else()?;\n+            self.sess.emit_err(errors::LoopElseNotSupported {\n+                span: else_span.to(else_clause.span),\n+                loop_kind,\n+                loop_kw,\n+            });\n+        }\n+        Ok(())\n+    }\n+\n     fn error_missing_in_for_loop(&mut self) {\n         let (span, sub): (_, fn(_) -> _) = if self.token.is_ident_named(sym::of) {\n             // Possibly using JS syntax (#75311).\n@@ -2518,6 +2540,9 @@ impl<'a> Parser<'a> {\n             err.span_label(cond.span, \"this `while` condition successfully parsed\");\n             err\n         })?;\n+\n+        self.recover_loop_else(\"while\", lo)?;\n+\n         Ok(self.mk_expr_with_attrs(\n             lo.to(self.prev_token.span),\n             ExprKind::While(cond, body, opt_label),\n@@ -2529,6 +2554,7 @@ impl<'a> Parser<'a> {\n     fn parse_expr_loop(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n         let loop_span = self.prev_token.span;\n         let (attrs, body) = self.parse_inner_attrs_and_block()?;\n+        self.recover_loop_else(\"loop\", lo)?;\n         Ok(self.mk_expr_with_attrs(\n             lo.to(self.prev_token.span),\n             ExprKind::Loop(body, opt_label, loop_span),"}, {"sha": "85cc8ca02a9779038658adbf6c71bb77e1d2b360", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -125,16 +125,13 @@ impl<'a> Parser<'a> {\n             return Ok(Some(item.into_inner()));\n         };\n \n-        let mut unclosed_delims = vec![];\n         let item =\n             self.collect_tokens_trailing_token(attrs, force_collect, |this: &mut Self, attrs| {\n                 let item =\n                     this.parse_item_common_(attrs, mac_allowed, attrs_allowed, fn_parse_mode);\n-                unclosed_delims.append(&mut this.unclosed_delims);\n                 Ok((item?, TrailingToken::None))\n             })?;\n \n-        self.unclosed_delims.append(&mut unclosed_delims);\n         Ok(item)\n     }\n \n@@ -1960,21 +1957,12 @@ impl<'a> Parser<'a> {\n         // FIXME: This will make us not emit the help even for declarative\n         // macros within the same crate (that we can fix), which is sad.\n         if !span.from_expansion() {\n-            if self.unclosed_delims.is_empty() {\n-                let DelimSpan { open, close } = args.dspan;\n-                err.multipart_suggestion(\n-                    \"change the delimiters to curly braces\",\n-                    vec![(open, \"{\".to_string()), (close, '}'.to_string())],\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                err.span_suggestion(\n-                    span,\n-                    \"change the delimiters to curly braces\",\n-                    \" { /* items */ }\",\n-                    Applicability::HasPlaceholders,\n-                );\n-            }\n+            let DelimSpan { open, close } = args.dspan;\n+            err.multipart_suggestion(\n+                \"change the delimiters to curly braces\",\n+                vec![(open, \"{\".to_string()), (close, '}'.to_string())],\n+                Applicability::MaybeIncorrect,\n+            );\n             err.span_suggestion(\n                 span.shrink_to_hi(),\n                 \"add a semicolon\","}, {"sha": "6e9b447fa61a91494311475d54e89d88db88b152", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -10,7 +10,7 @@ mod path;\n mod stmt;\n mod ty;\n \n-use crate::lexer::UnmatchedBrace;\n+use crate::lexer::UnmatchedDelim;\n pub use attr_wrapper::AttrWrapper;\n pub use diagnostics::AttemptLocalParseRecovery;\n pub(crate) use item::FnParseMode;\n@@ -146,10 +146,7 @@ pub struct Parser<'a> {\n     /// See the comments in the `parse_path_segment` function for more details.\n     unmatched_angle_bracket_count: u32,\n     max_angle_bracket_count: u32,\n-    /// A list of all unclosed delimiters found by the lexer. If an entry is used for error recovery\n-    /// it gets removed from here. Every entry left at the end gets emitted as an independent\n-    /// error.\n-    pub(super) unclosed_delims: Vec<UnmatchedBrace>,\n+\n     last_unexpected_token_span: Option<Span>,\n     /// Span pointing at the `:` for the last type ascription the parser has seen, and whether it\n     /// looked like it could have been a mistyped path or literal `Option:Some(42)`).\n@@ -168,7 +165,7 @@ pub struct Parser<'a> {\n // This type is used a lot, e.g. it's cloned when matching many declarative macro rules with nonterminals. Make sure\n // it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Parser<'_>, 312);\n+rustc_data_structures::static_assert_size!(Parser<'_>, 288);\n \n /// Stores span information about a closure.\n #[derive(Clone)]\n@@ -215,12 +212,6 @@ struct CaptureState {\n     inner_attr_ranges: FxHashMap<AttrId, ReplaceRange>,\n }\n \n-impl<'a> Drop for Parser<'a> {\n-    fn drop(&mut self) {\n-        emit_unclosed_delims(&mut self.unclosed_delims, &self.sess);\n-    }\n-}\n-\n /// Iterator over a `TokenStream` that produces `Token`s. It's a bit odd that\n /// we (a) lex tokens into a nice tree structure (`TokenStream`), and then (b)\n /// use this type to emit them as a linear sequence. But a linear sequence is\n@@ -335,7 +326,7 @@ impl TokenCursor {\n             num_of_hashes = cmp::max(num_of_hashes, count);\n         }\n \n-        // `/// foo` becomes `doc = r\"foo\".\n+        // `/// foo` becomes `doc = r\"foo\"`.\n         let delim_span = DelimSpan::from_single(span);\n         let body = TokenTree::Delimited(\n             delim_span,\n@@ -478,7 +469,6 @@ impl<'a> Parser<'a> {\n             desugar_doc_comments,\n             unmatched_angle_bracket_count: 0,\n             max_angle_bracket_count: 0,\n-            unclosed_delims: Vec::new(),\n             last_unexpected_token_span: None,\n             last_type_ascription: None,\n             subparser_name,\n@@ -859,7 +849,6 @@ impl<'a> Parser<'a> {\n         let mut recovered = false;\n         let mut trailing = false;\n         let mut v = ThinVec::new();\n-        let unclosed_delims = !self.unclosed_delims.is_empty();\n \n         while !self.expect_any_with_type(kets, expect) {\n             if let token::CloseDelim(..) | token::Eof = self.token.kind {\n@@ -901,7 +890,7 @@ impl<'a> Parser<'a> {\n                                 _ => {\n                                     // Attempt to keep parsing if it was a similar separator.\n                                     if let Some(tokens) = t.similar_tokens() {\n-                                        if tokens.contains(&self.token.kind) && !unclosed_delims {\n+                                        if tokens.contains(&self.token.kind) {\n                                             self.bump();\n                                         }\n                                     }\n@@ -1521,11 +1510,11 @@ impl<'a> Parser<'a> {\n }\n \n pub(crate) fn make_unclosed_delims_error(\n-    unmatched: UnmatchedBrace,\n+    unmatched: UnmatchedDelim,\n     sess: &ParseSess,\n ) -> Option<DiagnosticBuilder<'_, ErrorGuaranteed>> {\n     // `None` here means an `Eof` was found. We already emit those errors elsewhere, we add them to\n-    // `unmatched_braces` only for error recovery in the `Parser`.\n+    // `unmatched_delims` only for error recovery in the `Parser`.\n     let found_delim = unmatched.found_delim?;\n     let mut spans = vec![unmatched.found_span];\n     if let Some(sp) = unmatched.unclosed_span {\n@@ -1542,7 +1531,7 @@ pub(crate) fn make_unclosed_delims_error(\n     Some(err)\n }\n \n-pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, sess: &ParseSess) {\n+pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedDelim>, sess: &ParseSess) {\n     *sess.reached_eof.borrow_mut() |=\n         unclosed_delims.iter().any(|unmatched_delim| unmatched_delim.found_delim.is_none());\n     for unmatched in unclosed_delims.drain(..) {"}, {"sha": "3fa78efc290ba2406cd46cd7723e2dbf2460fd1c", "filename": "compiler/rustc_passes/locales/en-US.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Flocales%2Fen-US.ftl?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -402,9 +402,6 @@ passes_invalid_attr_at_crate_level =\n     `{$name}` attribute cannot be used at crate level\n     .suggestion = perhaps you meant to use an outer attribute\n \n-passes_duplicate_diagnostic_item =\n-    duplicate diagnostic item found: `{$name}`.\n-\n passes_duplicate_diagnostic_item_in_crate =\n     duplicate diagnostic item in crate `{$crate_name}`: `{$name}`.\n     .note = the diagnostic item is first defined in crate `{$orig_crate_name}`."}, {"sha": "28e06e5bb3ef298564845a3a5b9c2bf399b7b3e3", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::{Node, PatKind, TyKind};\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::middle::privacy::Level;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint;\n use rustc_span::symbol::{sym, Symbol};\n use std::mem;"}, {"sha": "110eb210df9ad71b0184fd8ac53fafcc145a03a8", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -11,43 +11,49 @@\n \n use rustc_ast as ast;\n use rustc_hir::diagnostic_items::DiagnosticItems;\n+use rustc_hir::OwnerId;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use rustc_span::symbol::{kw::Empty, sym, Symbol};\n+use rustc_span::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_span::symbol::{sym, Symbol};\n \n-use crate::errors::{DuplicateDiagnosticItem, DuplicateDiagnosticItemInCrate};\n+use crate::errors::DuplicateDiagnosticItemInCrate;\n \n-fn observe_item(tcx: TyCtxt<'_>, diagnostic_items: &mut DiagnosticItems, def_id: LocalDefId) {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let attrs = tcx.hir().attrs(hir_id);\n+fn observe_item<'tcx>(tcx: TyCtxt<'tcx>, diagnostic_items: &mut DiagnosticItems, owner: OwnerId) {\n+    let attrs = tcx.hir().attrs(owner.into());\n     if let Some(name) = extract(attrs) {\n         // insert into our table\n-        collect_item(tcx, diagnostic_items, name, def_id.to_def_id());\n+        collect_item(tcx, diagnostic_items, name, owner.to_def_id());\n     }\n }\n \n fn collect_item(tcx: TyCtxt<'_>, items: &mut DiagnosticItems, name: Symbol, item_def_id: DefId) {\n     items.id_to_name.insert(item_def_id, name);\n     if let Some(original_def_id) = items.name_to_id.insert(name, item_def_id) {\n         if original_def_id != item_def_id {\n-            let orig_span = tcx.hir().span_if_local(original_def_id);\n-            let orig_crate_name =\n-                orig_span.is_none().then(|| tcx.crate_name(original_def_id.krate));\n-            match tcx.hir().span_if_local(item_def_id) {\n-                Some(span) => tcx.sess.emit_err(DuplicateDiagnosticItem { span, name }),\n-                None => tcx.sess.emit_err(DuplicateDiagnosticItemInCrate {\n-                    span: orig_span,\n-                    orig_crate_name: orig_crate_name.unwrap_or(Empty),\n-                    have_orig_crate_name: orig_crate_name.map(|_| ()),\n-                    crate_name: tcx.crate_name(item_def_id.krate),\n-                    name,\n-                }),\n-            };\n+            report_duplicate_item(tcx, name, original_def_id, item_def_id);\n         }\n     }\n }\n \n+fn report_duplicate_item(\n+    tcx: TyCtxt<'_>,\n+    name: Symbol,\n+    original_def_id: DefId,\n+    item_def_id: DefId,\n+) {\n+    let orig_span = tcx.hir().span_if_local(original_def_id);\n+    let duplicate_span = tcx.hir().span_if_local(item_def_id);\n+    tcx.sess.emit_err(DuplicateDiagnosticItemInCrate {\n+        duplicate_span,\n+        orig_span,\n+        crate_name: tcx.crate_name(item_def_id.krate),\n+        orig_crate_name: tcx.crate_name(original_def_id.krate),\n+        different_crates: (item_def_id.krate != original_def_id.krate).then_some(()),\n+        name,\n+    });\n+}\n+\n /// Extract the first `rustc_diagnostic_item = \"$name\"` out of a list of attributes.\n fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     attrs.iter().find_map(|attr| {\n@@ -64,21 +70,8 @@ fn diagnostic_items(tcx: TyCtxt<'_>, cnum: CrateNum) -> DiagnosticItems {\n \n     // Collect diagnostic items in this crate.\n     let crate_items = tcx.hir_crate_items(());\n-\n-    for id in crate_items.items() {\n-        observe_item(tcx, &mut diagnostic_items, id.owner_id.def_id);\n-    }\n-\n-    for id in crate_items.trait_items() {\n-        observe_item(tcx, &mut diagnostic_items, id.owner_id.def_id);\n-    }\n-\n-    for id in crate_items.impl_items() {\n-        observe_item(tcx, &mut diagnostic_items, id.owner_id.def_id);\n-    }\n-\n-    for id in crate_items.foreign_items() {\n-        observe_item(tcx, &mut diagnostic_items, id.owner_id.def_id);\n+    for id in crate_items.owners() {\n+        observe_item(tcx, &mut diagnostic_items, id);\n     }\n \n     diagnostic_items"}, {"sha": "b7e6a11998b1cff983aef83d1b41bc4692c02432", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::{ItemId, Node, CRATE_HIR_ID};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{DefIdTree, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{sigpipe, CrateType, EntryFnType};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;"}, {"sha": "9f1c0b5a0b7bdf960802be254be100bacdcd8e4e", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -809,23 +809,17 @@ impl IntoDiagnostic<'_> for InvalidAttrAtCrateLevel {\n     }\n }\n \n-#[derive(Diagnostic)]\n-#[diag(passes_duplicate_diagnostic_item)]\n-pub struct DuplicateDiagnosticItem {\n-    #[primary_span]\n-    pub span: Span,\n-    pub name: Symbol,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(passes_duplicate_diagnostic_item_in_crate)]\n pub struct DuplicateDiagnosticItemInCrate {\n+    #[primary_span]\n+    pub duplicate_span: Option<Span>,\n     #[note(passes_diagnostic_item_first_defined)]\n-    pub span: Option<Span>,\n-    pub orig_crate_name: Symbol,\n+    pub orig_span: Option<Span>,\n     #[note]\n-    pub have_orig_crate_name: Option<()>,\n+    pub different_crates: Option<()>,\n     pub crate_name: Symbol,\n+    pub orig_crate_name: Symbol,\n     pub name: Symbol,\n }\n "}, {"sha": "9418f3cd322a371b51ffd51bbe21b88879e99988", "filename": "compiler/rustc_passes/src/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::intravisit;\n use rustc_hir::{HirId, ItemLocalId};\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty::{DefIdTree, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n \n pub fn check_crate(tcx: TyCtxt<'_>) {\n     tcx.dep_graph.assert_ignored();"}, {"sha": "5e2d2d3e5a704aafc48bb2a2bef2f4e48fa90c2d", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -646,7 +646,7 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     // `UseTree` has one inline use (in `ast::ItemKind::Use`) and one\n-    // non-inline use (in `ast::UseTreeKind::Nested). The former case is more\n+    // non-inline use (in `ast::UseTreeKind::Nested`). The former case is more\n     // common, so we don't implement `visit_use_tree` and tolerate the missed\n     // coverage in the latter case.\n "}, {"sha": "db9d0dcc30053a7c04bc75e4fabbf00e5fb1d67a", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -95,7 +95,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Expr, HirId, HirIdMap, HirIdSet};\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, DefIdTree, RootVariableMinCaptureList, Ty, TyCtxt};\n+use rustc_middle::ty::{self, RootVariableMinCaptureList, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{BytePos, Span};"}, {"sha": "053bf5c234acfe96044a005ce41b8c791df05a2c", "filename": "compiler/rustc_passes/src/liveness/rwu_table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -9,7 +9,7 @@ pub(super) struct RWU {\n }\n \n /// Conceptually, this is like a `Vec<Vec<RWU>>`. But the number of\n-/// RWU`s can get very large, so it uses a more compact representation.\n+/// RWU's can get very large, so it uses a more compact representation.\n pub(super) struct RWUTable {\n     /// Total number of live nodes.\n     live_nodes: usize,"}, {"sha": "d6cb68a9c20d78c38b22346d303799ece39dc951", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::Node;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::middle::privacy::{self, Level};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::config::CrateType;\n use rustc_target::spec::abi::Abi;\n "}, {"sha": "99a44b0ca4dfd0de1a786931c8638dde2e13e5c4", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -29,7 +29,7 @@ use rustc_middle::middle::privacy::{EffectiveVisibilities, Level};\n use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::{self, Const, DefIdTree, GenericParamDefKind};\n+use rustc_middle::ty::{self, Const, GenericParamDefKind};\n use rustc_middle::ty::{TraitRef, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n use rustc_session::lint;\n use rustc_span::hygiene::Transparency;"}, {"sha": "46e34462cf2252035e60be227dd30226c363013b", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -333,7 +333,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n                 },\n             );\n \n-            // `Encode the file footer.\n+            // Encode the file footer.\n             let footer_pos = encoder.position() as u64;\n             encoder.encode_tagged(\n                 TAG_FILE_FOOTER,"}, {"sha": "5f003fa70e133b241911ac8b088cd33e4e6c7d3a", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -25,7 +25,6 @@ use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::mem;\n-use std::ptr;\n use thin_vec::ThinVec;\n \n use super::QueryConfig;\n@@ -250,13 +249,16 @@ where\n     where\n         C: QueryCache<Key = K>,\n     {\n-        // We can move out of `self` here because we `mem::forget` it below\n-        let key = unsafe { ptr::read(&self.key) };\n+        let key = self.key;\n         let state = self.state;\n \n         // Forget ourself so our destructor won't poison the query\n         mem::forget(self);\n \n+        // Mark as complete before we remove the job from the active state\n+        // so no other thread can re-execute this query.\n+        cache.complete(key, result, dep_node_index);\n+\n         let job = {\n             #[cfg(parallel_compiler)]\n             let mut lock = state.active.get_shard_by_value(&key).lock();\n@@ -267,7 +269,6 @@ where\n                 QueryResult::Poisoned => panic!(),\n             }\n         };\n-        cache.complete(key, result, dep_node_index);\n \n         job.signal_complete();\n     }"}, {"sha": "9526bca3df267db0ed18dd469264a85e1fddb2bd", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -25,9 +25,8 @@ use rustc_expand::expand::AstFragment;\n use rustc_hir::def::{self, *};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_metadata::creader::LoadedMacro;\n-use rustc_middle::bug;\n use rustc_middle::metadata::ModChild;\n-use rustc_middle::ty::{self, DefIdTree};\n+use rustc_middle::{bug, ty};\n use rustc_session::cstore::CrateStore;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind};\n use rustc_span::source_map::respan;\n@@ -99,7 +98,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         loop {\n             match self.get_module(def_id) {\n                 Some(module) => return module,\n-                None => def_id = self.parent(def_id),\n+                None => def_id = self.tcx.parent(def_id),\n             }\n         }\n     }\n@@ -775,7 +774,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                         let field_vis = self\n                             .try_resolve_visibility(&field.vis, false)\n                             .unwrap_or(ty::Visibility::Public);\n-                        if ctor_vis.is_at_least(field_vis, &*self.r) {\n+                        if ctor_vis.is_at_least(field_vis, self.r.tcx) {\n                             ctor_vis = field_vis;\n                         }\n                         ret_fields.push(field_vis.to_def_id());\n@@ -1414,10 +1413,7 @@ impl<'a, 'b, 'tcx> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n \n         if !(ctxt == AssocCtxt::Impl\n             && matches!(item.vis.kind, ast::VisibilityKind::Inherited)\n-            && self\n-                .r\n-                .trait_impl_items\n-                .contains(&ty::DefIdTree::local_parent(&*self.r, local_def_id)))\n+            && self.r.trait_impl_items.contains(&self.r.tcx.local_parent(local_def_id)))\n         {\n             // Trait impl item visibility is inherited from its trait when not specified\n             // explicitly. In that case we cannot determine it here in early resolve,"}, {"sha": "b2578e4c4b4467161cd38ec4b5a5f55b43c0ee72", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 121, "deletions": 14, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -29,11 +29,12 @@ use crate::Resolver;\n \n use rustc_ast as ast;\n use rustc_ast::visit::{self, Visitor};\n-use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n use rustc_data_structures::unord::UnordSet;\n use rustc_errors::{pluralize, MultiSpan};\n-use rustc_session::lint::builtin::{MACRO_USE_EXTERN_CRATE, UNUSED_IMPORTS};\n+use rustc_session::lint::builtin::{MACRO_USE_EXTERN_CRATE, UNUSED_EXTERN_CRATES, UNUSED_IMPORTS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n+use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n \n struct UnusedImport<'a> {\n@@ -53,11 +54,28 @@ struct UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     r: &'a mut Resolver<'b, 'tcx>,\n     /// All the (so far) unused imports, grouped path list\n     unused_imports: FxIndexMap<ast::NodeId, UnusedImport<'a>>,\n+    extern_crate_items: Vec<ExternCrateToLint>,\n     base_use_tree: Option<&'a ast::UseTree>,\n     base_id: ast::NodeId,\n     item_span: Span,\n }\n \n+struct ExternCrateToLint {\n+    id: ast::NodeId,\n+    /// Span from the item\n+    span: Span,\n+    /// Span to use to suggest complete removal.\n+    span_with_attributes: Span,\n+    /// Span of the visibility, if any.\n+    vis_span: Span,\n+    /// Whether the item has attrs.\n+    has_attrs: bool,\n+    /// Name used to refer to the crate.\n+    ident: Ident,\n+    /// Whether the statement renames the crate `extern crate orig_name as new_name;`.\n+    renames: bool,\n+}\n+\n impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     // We have information about whether `use` (import) items are actually\n     // used now. If an import is not used at all, we signal a lint error.\n@@ -96,18 +114,27 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n \n impl<'a, 'b, 'tcx> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n-        self.item_span = item.span_with_attributes();\n-\n-        // Ignore is_public import statements because there's no way to be sure\n-        // whether they're used or not. Also ignore imports with a dummy span\n-        // because this means that they were generated in some fashion by the\n-        // compiler and we don't need to consider them.\n-        if let ast::ItemKind::Use(..) = item.kind {\n-            if item.vis.kind.is_pub() || item.span.is_dummy() {\n-                return;\n+        match item.kind {\n+            // Ignore is_public import statements because there's no way to be sure\n+            // whether they're used or not. Also ignore imports with a dummy span\n+            // because this means that they were generated in some fashion by the\n+            // compiler and we don't need to consider them.\n+            ast::ItemKind::Use(..) if item.vis.kind.is_pub() || item.span.is_dummy() => return,\n+            ast::ItemKind::ExternCrate(orig_name) => {\n+                self.extern_crate_items.push(ExternCrateToLint {\n+                    id: item.id,\n+                    span: item.span,\n+                    vis_span: item.vis.span,\n+                    span_with_attributes: item.span_with_attributes(),\n+                    has_attrs: !item.attrs.is_empty(),\n+                    ident: item.ident,\n+                    renames: orig_name.is_some(),\n+                });\n             }\n+            _ => {}\n         }\n \n+        self.item_span = item.span_with_attributes();\n         visit::walk_item(self, item);\n     }\n \n@@ -224,6 +251,9 @@ fn calc_unused_spans(\n \n impl Resolver<'_, '_> {\n     pub(crate) fn check_unused(&mut self, krate: &ast::Crate) {\n+        let tcx = self.tcx;\n+        let mut maybe_unused_extern_crates = FxHashMap::default();\n+\n         for import in self.potentially_unused_imports.iter() {\n             match import.kind {\n                 _ if import.used.get()\n@@ -246,7 +276,14 @@ impl Resolver<'_, '_> {\n                 }\n                 ImportKind::ExternCrate { id, .. } => {\n                     let def_id = self.local_def_id(id);\n-                    self.maybe_unused_extern_crates.push((def_id, import.span));\n+                    if self.extern_crate_map.get(&def_id).map_or(true, |&cnum| {\n+                        !tcx.is_compiler_builtins(cnum)\n+                            && !tcx.is_panic_runtime(cnum)\n+                            && !tcx.has_global_allocator(cnum)\n+                            && !tcx.has_panic_handler(cnum)\n+                    }) {\n+                        maybe_unused_extern_crates.insert(id, import.span);\n+                    }\n                 }\n                 ImportKind::MacroUse => {\n                     let msg = \"unused `#[macro_use]` import\";\n@@ -259,6 +296,7 @@ impl Resolver<'_, '_> {\n         let mut visitor = UnusedImportCheckVisitor {\n             r: self,\n             unused_imports: Default::default(),\n+            extern_crate_items: Default::default(),\n             base_use_tree: None,\n             base_id: ast::DUMMY_NODE_ID,\n             item_span: DUMMY_SP,\n@@ -290,7 +328,7 @@ impl Resolver<'_, '_> {\n             let ms = MultiSpan::from_spans(spans.clone());\n             let mut span_snippets = spans\n                 .iter()\n-                .filter_map(|s| match visitor.r.tcx.sess.source_map().span_to_snippet(*s) {\n+                .filter_map(|s| match tcx.sess.source_map().span_to_snippet(*s) {\n                     Ok(s) => Some(format!(\"`{}`\", s)),\n                     _ => None,\n                 })\n@@ -317,7 +355,7 @@ impl Resolver<'_, '_> {\n             // If we are in the `--test` mode, suppress a help that adds the `#[cfg(test)]`\n             // attribute; however, if not, suggest adding the attribute. There is no way to\n             // retrieve attributes here because we do not have a `TyCtxt` yet.\n-            let test_module_span = if visitor.r.tcx.sess.opts.test {\n+            let test_module_span = if tcx.sess.opts.test {\n                 None\n             } else {\n                 let parent_module = visitor.r.get_nearest_non_block_module(\n@@ -346,5 +384,74 @@ impl Resolver<'_, '_> {\n                 BuiltinLintDiagnostics::UnusedImports(fix_msg.into(), fixes, test_module_span),\n             );\n         }\n+\n+        for extern_crate in visitor.extern_crate_items {\n+            let warn_if_unused = !extern_crate.ident.name.as_str().starts_with('_');\n+\n+            // If the crate is fully unused, we suggest removing it altogether.\n+            // We do this in any edition.\n+            if warn_if_unused {\n+                if let Some(&span) = maybe_unused_extern_crates.get(&extern_crate.id) {\n+                    visitor.r.lint_buffer.buffer_lint_with_diagnostic(\n+                        UNUSED_EXTERN_CRATES,\n+                        extern_crate.id,\n+                        span,\n+                        \"unused extern crate\",\n+                        BuiltinLintDiagnostics::UnusedExternCrate {\n+                            removal_span: extern_crate.span_with_attributes,\n+                        },\n+                    );\n+                    continue;\n+                }\n+            }\n+\n+            // If we are not in Rust 2018 edition, then we don't make any further\n+            // suggestions.\n+            if !tcx.sess.rust_2018() {\n+                continue;\n+            }\n+\n+            // If the extern crate has any attributes, they may have funky\n+            // semantics we can't faithfully represent using `use` (most\n+            // notably `#[macro_use]`). Ignore it.\n+            if extern_crate.has_attrs {\n+                continue;\n+            }\n+\n+            // If the extern crate is renamed, then we cannot suggest replacing it with a use as this\n+            // would not insert the new name into the prelude, where other imports in the crate may be\n+            // expecting it.\n+            if extern_crate.renames {\n+                continue;\n+            }\n+\n+            // If the extern crate isn't in the extern prelude,\n+            // there is no way it can be written as a `use`.\n+            if !visitor\n+                .r\n+                .extern_prelude\n+                .get(&extern_crate.ident)\n+                .map_or(false, |entry| !entry.introduced_by_item)\n+            {\n+                continue;\n+            }\n+\n+            let vis_span = extern_crate\n+                .vis_span\n+                .find_ancestor_inside(extern_crate.span)\n+                .unwrap_or(extern_crate.vis_span);\n+            let ident_span = extern_crate\n+                .ident\n+                .span\n+                .find_ancestor_inside(extern_crate.span)\n+                .unwrap_or(extern_crate.ident.span);\n+            visitor.r.lint_buffer.buffer_lint_with_diagnostic(\n+                UNUSED_EXTERN_CRATES,\n+                extern_crate.id,\n+                extern_crate.span,\n+                \"`extern crate` is not idiomatic in the new edition\",\n+                BuiltinLintDiagnostics::ExternCrateNotIdiomatic { vis_span, ident_span },\n+            );\n+        }\n     }\n }"}, {"sha": "adec7973671dd58a822fc73da93a89b2b53e2be5", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -15,7 +15,7 @@ use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_middle::bug;\n-use rustc_middle::ty::{DefIdTree, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE;\n use rustc_session::lint::builtin::MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -189,7 +189,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let container = match parent.kind {\n-            ModuleKind::Def(kind, _, _) => self.tcx.def_kind_descr(kind, parent.def_id()),\n+            // Avoid using TyCtxt::def_kind_descr in the resolver, because it\n+            // indirectly *calls* the resolver, and would cause a query cycle.\n+            ModuleKind::Def(kind, _, _) => kind.descr(parent.def_id()),\n             ModuleKind::Block => \"block\",\n         };\n \n@@ -1195,7 +1197,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         segms.push(ast::PathSegment::from_ident(ident));\n                         let path = Path { span: name_binding.span, segments: segms, tokens: None };\n                         let did = match res {\n-                            Res::Def(DefKind::Ctor(..), did) => this.opt_parent(did),\n+                            Res::Def(DefKind::Ctor(..), did) => this.tcx.opt_parent(did),\n                             _ => res.opt_def_id(),\n                         };\n \n@@ -1589,7 +1591,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ctor_def_id,\n         )) = binding.kind\n         {\n-            let def_id = self.parent(ctor_def_id);\n+            let def_id = self.tcx.parent(ctor_def_id);\n             let fields = self.field_names.get(&def_id)?;\n             return fields.iter().map(|name| name.span).reduce(Span::to); // None for `struct Foo()`\n         }\n@@ -1804,7 +1806,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         found(\"module\")\n                     } else {\n                         match binding.res() {\n-                            Res::Def(kind, id) => found(self.tcx.def_kind_descr(kind, id)),\n+                            // Avoid using TyCtxt::def_kind_descr in the resolver, because it\n+                            // indirectly *calls* the resolver, and would cause a query cycle.\n+                            Res::Def(kind, id) => found(kind.descr(id)),\n                             _ => found(ns_to_try.descr()),\n                         }\n                     }"}, {"sha": "4bb252bfb29ddc331352de762e2c3089ac9be2ba", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_middle::middle::privacy::Level;\n use rustc_middle::middle::privacy::{EffectiveVisibilities, EffectiveVisibility};\n-use rustc_middle::ty::{DefIdTree, Visibility};\n+use rustc_middle::ty::Visibility;\n use std::mem;\n \n type ImportId<'a> = Interned<'a, NameBinding<'a>>;\n@@ -60,7 +60,7 @@ impl Resolver<'_, '_> {\n         // For mod items `nearest_normal_mod` returns its argument, but we actually need its parent.\n         let normal_mod_id = self.nearest_normal_mod(def_id);\n         if normal_mod_id == def_id {\n-            self.opt_local_parent(def_id).map_or(Visibility::Public, Visibility::Restricted)\n+            self.tcx.opt_local_parent(def_id).map_or(Visibility::Public, Visibility::Restricted)\n         } else {\n             Visibility::Restricted(normal_mod_id)\n         }"}, {"sha": "52f0b65fad6724cab3806964bcc3783ba7152ef6", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -368,7 +368,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n     /// expansion and import resolution (perhaps they can be merged in the future).\n     /// The function is used for resolving initial segments of macro paths (e.g., `foo` in\n-    /// `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n+    /// `foo::bar!();` or `foo!();`) and also for import paths on 2018 edition.\n     #[instrument(level = \"debug\", skip(self, scope_set))]\n     pub(crate) fn early_resolve_ident_in_lexical_scope(\n         &mut self,"}, {"sha": "5d40c6e4e4862d38dacc98d2e7eaf2e4e7895142", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -245,7 +245,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         import: &'a Import<'a>,\n     ) -> &'a NameBinding<'a> {\n         let import_vis = import.expect_vis().to_def_id();\n-        let vis = if binding.vis.is_at_least(import_vis, self)\n+        let vis = if binding.vis.is_at_least(import_vis, self.tcx)\n             || pub_use_of_private_extern_crate_hack(import, binding)\n         {\n             import_vis\n@@ -255,7 +255,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         if let ImportKind::Glob { ref max_vis, .. } = import.kind {\n             if vis == import_vis\n-                || max_vis.get().map_or(true, |max_vis| vis.is_at_least(max_vis, self))\n+                || max_vis.get().map_or(true, |max_vis| vis.is_at_least(max_vis, self.tcx))\n             {\n                 max_vis.set(Some(vis.expect_local()))\n             }\n@@ -294,7 +294,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 old_binding,\n                                 binding,\n                             ));\n-                        } else if !old_binding.vis.is_at_least(binding.vis, &*this) {\n+                        } else if !old_binding.vis.is_at_least(binding.vis, this.tcx) {\n                             // We are glob-importing the same item but with greater visibility.\n                             resolution.binding = Some(binding);\n                         }\n@@ -786,7 +786,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                     if !is_prelude\n                     && let Some(max_vis) = max_vis.get()\n-                    && !max_vis.is_at_least(import.expect_vis(), &*self)\n+                    && !max_vis.is_at_least(import.expect_vis(), self.tcx)\n                 {\n                     let msg = \"glob import doesn't reexport anything because no candidate is public enough\";\n                     self.lint_buffer.buffer_lint(UNUSED_IMPORTS, id, import.span, msg);\n@@ -977,7 +977,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut crate_private_reexport = false;\n         self.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n-                if !binding.vis.is_at_least(import.expect_vis(), &*this) {\n+                if !binding.vis.is_at_least(import.expect_vis(), this.tcx) {\n                     reexport_error = Some((ns, binding));\n                     if let ty::Visibility::Restricted(binding_def_id) = binding.vis {\n                         if binding_def_id.is_top_level_module() {"}, {"sha": "cc3e142a5fd5faf63ff528f5d36d0d9933547a5d", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -22,7 +22,6 @@ use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::{BindingAnnotation, PrimTy, TraitCandidate};\n use rustc_middle::middle::resolve_bound_vars::Set1;\n-use rustc_middle::ty::DefIdTree;\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::{CrateType, ResolveDocLinks};\n use rustc_session::lint;\n@@ -1671,8 +1670,12 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             // Figure out if this is a type/trait segment,\n             // which may need lifetime elision performed.\n             let type_def_id = match partial_res.base_res() {\n-                Res::Def(DefKind::AssocTy, def_id) if i + 2 == proj_start => self.r.parent(def_id),\n-                Res::Def(DefKind::Variant, def_id) if i + 1 == proj_start => self.r.parent(def_id),\n+                Res::Def(DefKind::AssocTy, def_id) if i + 2 == proj_start => {\n+                    self.r.tcx.parent(def_id)\n+                }\n+                Res::Def(DefKind::Variant, def_id) if i + 1 == proj_start => {\n+                    self.r.tcx.parent(def_id)\n+                }\n                 Res::Def(DefKind::Struct, def_id)\n                 | Res::Def(DefKind::Union, def_id)\n                 | Res::Def(DefKind::Enum, def_id)"}, {"sha": "206c43f6902bedaaf9a1b5752d4d88bc5a0c26b6", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -21,7 +21,6 @@ use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n-use rustc_middle::ty::DefIdTree;\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n@@ -878,7 +877,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         );\n         let is_assoc_fn = self.self_type_is_available();\n         if let Some((fn_kind, span)) = &self.diagnostic_metadata.current_function {\n-            // The current function has a `self' parameter, but we were unable to resolve\n+            // The current function has a `self` parameter, but we were unable to resolve\n             // a reference to `self`. This can only happen if the `self` identifier we\n             // are resolving came from a different hygiene context.\n             if fn_kind.decl().inputs.get(0).map_or(false, |p| p.is_self()) {\n@@ -1508,7 +1507,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 }\n             }\n             (Res::Def(DefKind::Ctor(_, CtorKind::Fn), ctor_def_id), _) if ns == ValueNS => {\n-                let def_id = self.r.parent(ctor_def_id);\n+                let def_id = self.r.tcx.parent(ctor_def_id);\n                 if let Some(span) = self.def_span(def_id) {\n                     err.span_label(span, &format!(\"`{}` defined here\", path_str));\n                 }\n@@ -1999,7 +1998,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             }\n         } else {\n             let needs_placeholder = |ctor_def_id: DefId, kind: CtorKind| {\n-                let def_id = self.r.parent(ctor_def_id);\n+                let def_id = self.r.tcx.parent(ctor_def_id);\n                 let has_no_fields = self.r.field_names.get(&def_id).map_or(false, |f| f.is_empty());\n                 match kind {\n                     CtorKind::Const => false,"}, {"sha": "5eba208e3ed73e0e14af36c9c0ca61fa1ecd05ce", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -44,7 +44,7 @@ use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::span_bug;\n-use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools, TyCtxt};\n+use rustc_middle::ty::{self, MainDefinition, RegisteredTools, TyCtxt};\n use rustc_middle::ty::{ResolverGlobalCtxt, ResolverOutputs};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::cstore::CrateStore;\n@@ -946,7 +946,6 @@ pub struct Resolver<'a, 'tcx> {\n     has_pub_restricted: bool,\n     used_imports: FxHashSet<NodeId>,\n     maybe_unused_trait_imports: FxIndexSet<LocalDefId>,\n-    maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n \n     /// Privacy errors are delayed until the end in order to deduplicate them.\n     privacy_errors: Vec<PrivacyError<'a>>,\n@@ -1118,13 +1117,6 @@ impl<'a, 'tcx> AsMut<Resolver<'a, 'tcx>> for Resolver<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> DefIdTree for &'a Resolver<'b, 'tcx> {\n-    #[inline]\n-    fn opt_parent(self, id: DefId) -> Option<DefId> {\n-        self.tcx.opt_parent(id)\n-    }\n-}\n-\n impl<'tcx> Resolver<'_, 'tcx> {\n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n         self.node_id_to_def_id.get(&node).copied()\n@@ -1284,7 +1276,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             has_pub_restricted: false,\n             used_imports: FxHashSet::default(),\n             maybe_unused_trait_imports: Default::default(),\n-            maybe_unused_extern_crates: Vec::new(),\n \n             privacy_errors: Vec::new(),\n             ambiguity_errors: Vec::new(),\n@@ -1400,7 +1391,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let extern_crate_map = self.extern_crate_map;\n         let reexport_map = self.reexport_map;\n         let maybe_unused_trait_imports = self.maybe_unused_trait_imports;\n-        let maybe_unused_extern_crates = self.maybe_unused_extern_crates;\n         let glob_map = self.glob_map;\n         let main_def = self.main_def;\n         let confused_type_with_std_module = self.confused_type_with_std_module;\n@@ -1414,12 +1404,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             reexport_map,\n             glob_map,\n             maybe_unused_trait_imports,\n-            maybe_unused_extern_crates,\n-            extern_prelude: self\n-                .extern_prelude\n-                .iter()\n-                .map(|(ident, entry)| (ident.name, entry.introduced_by_item))\n-                .collect(),\n             main_def,\n             trait_impls: self.trait_impls,\n             proc_macros,\n@@ -1798,7 +1782,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         vis: ty::Visibility<impl Into<DefId>>,\n         module: Module<'a>,\n     ) -> bool {\n-        vis.is_accessible_from(module.nearest_parent_mod(), self)\n+        vis.is_accessible_from(module.nearest_parent_mod(), self.tcx)\n     }\n \n     fn set_binding_parent_module(&mut self, binding: &'a NameBinding<'a>, module: Module<'a>) {"}, {"sha": "b8853c1744c92871879f5583f70b7a688f33eef3", "filename": "compiler/rustc_resolve/src/rustdoc.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -265,9 +265,9 @@ fn strip_generics_from_path_segment(segment: Vec<char>) -> Result<String, Malfor\n     }\n }\n \n-pub fn strip_generics_from_path(path_str: &str) -> Result<String, MalformedGenerics> {\n+pub fn strip_generics_from_path(path_str: &str) -> Result<Box<str>, MalformedGenerics> {\n     if !path_str.contains(['<', '>']) {\n-        return Ok(path_str.to_string());\n+        return Ok(path_str.into());\n     }\n     let mut stripped_segments = vec![];\n     let mut path = path_str.chars().peekable();\n@@ -322,7 +322,11 @@ pub fn strip_generics_from_path(path_str: &str) -> Result<String, MalformedGener\n \n     let stripped_path = stripped_segments.join(\"::\");\n \n-    if !stripped_path.is_empty() { Ok(stripped_path) } else { Err(MalformedGenerics::MissingType) }\n+    if !stripped_path.is_empty() {\n+        Ok(stripped_path.into())\n+    } else {\n+        Err(MalformedGenerics::MissingType)\n+    }\n }\n \n /// Returns whether the first doc-comment is an inner attribute.\n@@ -336,7 +340,7 @@ pub fn inner_docs(attrs: &[ast::Attribute]) -> bool {\n /// Simplified version of the corresponding function in rustdoc.\n /// If the rustdoc version returns a successful result, this function must return the same result.\n /// Otherwise this function may return anything.\n-fn preprocess_link(link: &str) -> String {\n+fn preprocess_link(link: &str) -> Box<str> {\n     let link = link.replace('`', \"\");\n     let link = link.split('#').next().unwrap();\n     let link = link.trim();\n@@ -345,7 +349,7 @@ fn preprocess_link(link: &str) -> String {\n     let link = link.strip_suffix(\"{}\").unwrap_or(link);\n     let link = link.strip_suffix(\"[]\").unwrap_or(link);\n     let link = if link != \"!\" { link.strip_suffix('!').unwrap_or(link) } else { link };\n-    strip_generics_from_path(link).unwrap_or_else(|_| link.to_string())\n+    strip_generics_from_path(link).unwrap_or_else(|_| link.into())\n }\n \n /// Keep inline and reference links `[]`,\n@@ -365,7 +369,7 @@ pub fn may_be_doc_link(link_type: LinkType) -> bool {\n \n /// Simplified version of `preprocessed_markdown_links` from rustdoc.\n /// Must return at least the same links as it, but may add some more links on top of that.\n-pub(crate) fn attrs_to_preprocessed_links(attrs: &[ast::Attribute]) -> Vec<String> {\n+pub(crate) fn attrs_to_preprocessed_links(attrs: &[ast::Attribute]) -> Vec<Box<str>> {\n     let (doc_fragments, _) = attrs_to_doc_fragments(attrs.iter().map(|attr| (attr, None)), true);\n     let doc = prepare_to_doc_link_resolution(&doc_fragments).into_values().next().unwrap();\n "}, {"sha": "567fe06109b781f2275233b2b8ce3cd987f9d268", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -43,25 +43,13 @@ pub trait Encoder {\n     fn emit_str(&mut self, v: &str);\n     fn emit_raw_bytes(&mut self, s: &[u8]);\n \n-    // Convenience for the derive macro:\n     fn emit_enum_variant<F>(&mut self, v_id: usize, f: F)\n     where\n         F: FnOnce(&mut Self),\n     {\n         self.emit_usize(v_id);\n         f(self);\n     }\n-\n-    // We put the field index in a const generic to allow the emit_usize to be\n-    // compiled into a more efficient form. In practice, the variant index is\n-    // known at compile-time, and that knowledge allows much more efficient\n-    // codegen than we'd otherwise get. LLVM isn't always able to make the\n-    // optimization that would otherwise be necessary here, likely due to the\n-    // multiple levels of inlining and const-prop that are needed.\n-    #[inline]\n-    fn emit_fieldless_enum_variant<const ID: usize>(&mut self) {\n-        self.emit_usize(ID)\n-    }\n }\n \n // Note: all the methods in this trait are infallible, which may be surprising."}, {"sha": "ff53f22d43f9316c829295dcf962e1fee21a875c", "filename": "compiler/rustc_session/locales/en-US.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_session%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_session%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Flocales%2Fen-US.ftl?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -5,7 +5,7 @@ session_incorrect_cgu_reuse_type =\n     }`{$expected_reuse}`\n \n session_cgu_not_recorded =\n-    CGU-reuse for `{$cgu_user_name}` is (mangled: `{$cgu_name}`) was not recorded`\n+    CGU-reuse for `{$cgu_user_name}` is (mangled: `{$cgu_name}`) was not recorded\n \n session_feature_gate_error = {$explain}\n "}, {"sha": "d4e4ace889b039e3bc9ea7d12aa70be466807b50", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -2245,7 +2245,7 @@ pub fn parse_externs(\n                 early_error(\n                     error_format,\n                     \"the `-Z unstable-options` flag must also be passed to \\\n-                     enable `--extern options\",\n+                     enable `--extern` options\",\n                 );\n             }\n             for opt in opts.split(',') {\n@@ -2792,7 +2792,7 @@ pub enum PpMode {\n     HirTree,\n     /// `-Zunpretty=thir-tree`\n     ThirTree,\n-    /// `-Zunpretty=`thir-flat`\n+    /// `-Zunpretty=thir-flat`\n     ThirFlat,\n     /// `-Zunpretty=mir`\n     Mir,"}, {"sha": "f1fbf38217d64b82d09f36cb57c51e392e6170e4", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -182,7 +182,17 @@ pub fn get_or_default_sysroot() -> Result<PathBuf, String> {\n         if dir.ends_with(crate::config::host_triple()) {\n             dir.parent() // chop off `$target`\n                 .and_then(|p| p.parent()) // chop off `rustlib`\n-                .and_then(|p| p.parent()) // chop off `lib`\n+                .and_then(|p| {\n+                    // chop off `lib` (this could be also $arch dir if the host sysroot uses a\n+                    // multi-arch layout like Debian or Ubuntu)\n+                    match p.parent() {\n+                        Some(p) => match p.file_name() {\n+                            Some(f) if f == \"lib\" => p.parent(), // first chop went for $arch, so chop again for `lib`\n+                            _ => Some(p),\n+                        },\n+                        None => None,\n+                    }\n+                })\n                 .map(|s| s.to_owned())\n                 .ok_or(format!(\n                     \"Could not move 3 levels upper using `parent()` on {}\","}, {"sha": "b466a3fcdee915891e444fa6f81021e7b3a44b7c", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1503,6 +1503,9 @@ options! {\n         \"what location details should be tracked when using caller_location, either \\\n         `none`, or a comma separated list of location details, for which \\\n         valid options are `file`, `line`, and `column` (default: `file,line,column`)\"),\n+    lower_impl_trait_in_trait_to_assoc_ty: bool = (false, parse_bool, [TRACKED],\n+        \"modify the lowering strategy for `impl Trait` in traits so that they are lowered to \\\n+        generic associated types\"),\n     ls: bool = (false, parse_bool, [UNTRACKED],\n         \"list the symbols defined by a library crate (default: no)\"),\n     macro_backtrace: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "12634f67185fd94e200b3b2116279a4e5c905a33", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -882,10 +882,14 @@ impl Session {\n \n     /// We want to know if we're allowed to do an optimization for crate foo from -z fuel=foo=n.\n     /// This expends fuel if applicable, and records fuel if applicable.\n-    pub fn consider_optimizing<T: Fn() -> String>(&self, crate_name: &str, msg: T) -> bool {\n+    pub fn consider_optimizing(\n+        &self,\n+        get_crate_name: impl Fn() -> Symbol,\n+        msg: impl Fn() -> String,\n+    ) -> bool {\n         let mut ret = true;\n         if let Some((ref c, _)) = self.opts.unstable_opts.fuel {\n-            if c == crate_name {\n+            if c == get_crate_name().as_str() {\n                 assert_eq!(self.threads(), 1);\n                 let mut fuel = self.optimization_fuel.lock();\n                 ret = fuel.remaining != 0;\n@@ -903,7 +907,7 @@ impl Session {\n             }\n         }\n         if let Some(ref c) = self.opts.unstable_opts.print_fuel {\n-            if c == crate_name {\n+            if c == get_crate_name().as_str() {\n                 assert_eq!(self.threads(), 1);\n                 self.print_fuel.fetch_add(1, SeqCst);\n             }"}, {"sha": "162c15574b56ce8dd285f85228bf6795a2b2c949", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -235,7 +235,7 @@ impl<D: Decoder> Decodable<D> for DefIndex {\n pub struct DefId {\n     // cfg-ing the order of fields so that the `DefIndex` which is high entropy always ends up in\n     // the lower bits no matter the endianness. This allows the compiler to turn that `Hash` impl\n-    // into a direct call to 'u64::hash(_)`.\n+    // into a direct call to `u64::hash(_)`.\n     #[cfg(not(all(target_pointer_width = \"64\", target_endian = \"big\")))]\n     pub index: DefIndex,\n     pub krate: CrateNum,"}, {"sha": "9f22e9776d4f6b3b2633e64b37adee68a0993d2f", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1151,6 +1151,7 @@ pub enum DesugaringKind {\n     Await,\n     ForLoop,\n     WhileLoop,\n+    Replace,\n }\n \n impl DesugaringKind {\n@@ -1166,6 +1167,7 @@ impl DesugaringKind {\n             DesugaringKind::OpaqueTy => \"`impl Trait`\",\n             DesugaringKind::ForLoop => \"`for` loop\",\n             DesugaringKind::WhileLoop => \"`while` loop\",\n+            DesugaringKind::Replace => \"drop and replace\",\n         }\n     }\n }"}, {"sha": "6272bf7f25eb102d81af5e0b1a1c7b14019b002c", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1954,7 +1954,7 @@ impl Interner {\n         let name = Symbol::new(inner.strings.len() as u32);\n \n         // SAFETY: we convert from `&str` to `&[u8]`, clone it into the arena,\n-        // and immediately convert the clone back to `&[u8], all because there\n+        // and immediately convert the clone back to `&[u8]`, all because there\n         // is no `inner.arena.alloc_str()` method. This is clearly safe.\n         let string: &str =\n             unsafe { str::from_utf8_unchecked(inner.arena.alloc_slice(string.as_bytes())) };"}, {"sha": "c048d4a2aad7649d7f787ff9615dd69da1651891", "filename": "compiler/rustc_trait_selection/src/solve/canonical/canonicalize.rs", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -0,0 +1,390 @@\n+use std::cmp::Ordering;\n+\n+use crate::infer::InferCtxt;\n+use rustc_middle::infer::canonical::Canonical;\n+use rustc_middle::infer::canonical::CanonicalTyVarKind;\n+use rustc_middle::infer::canonical::CanonicalVarInfo;\n+use rustc_middle::infer::canonical::CanonicalVarInfos;\n+use rustc_middle::infer::canonical::CanonicalVarKind;\n+use rustc_middle::ty::BoundRegionKind::BrAnon;\n+use rustc_middle::ty::BoundTyKind;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::TypeVisitableExt;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n+\n+/// Whether we're canonicalizing a query input or the query reponse.\n+///\n+/// When canonicalizing an input we're in the context of the caller\n+/// while canonicalizing the response happens in the context of the\n+/// query.\n+#[derive(Debug, Clone, Copy)]\n+pub enum CanonicalizeMode {\n+    Input,\n+    /// FIXME: We currently return region constraints refering to\n+    /// placeholders and inference variables from a binder instantiated\n+    /// inside of the query.\n+    ///\n+    /// In the long term we should eagerly deal with these constraints\n+    /// inside of the query and only propagate constraints which are\n+    /// actually nameable by the caller.\n+    Response {\n+        /// The highest universe nameable by the caller.\n+        ///\n+        /// All variables in a universe nameable by the caller get mapped\n+        /// to the root universe in the response and then mapped back to\n+        /// their correct universe when applying the query response in the\n+        /// context of the caller.\n+        ///\n+        /// This doesn't work for universes created inside of the query so\n+        /// we do remember their universe in the response.\n+        max_input_universe: ty::UniverseIndex,\n+    },\n+}\n+\n+pub struct Canonicalizer<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'tcx>,\n+    canonicalize_mode: CanonicalizeMode,\n+\n+    variables: &'a mut Vec<ty::GenericArg<'tcx>>,\n+    primitive_var_infos: Vec<CanonicalVarInfo<'tcx>>,\n+    binder_index: ty::DebruijnIndex,\n+}\n+\n+impl<'a, 'tcx> Canonicalizer<'a, 'tcx> {\n+    #[instrument(level = \"debug\", skip(infcx), ret)]\n+    pub fn canonicalize<T: TypeFoldable<TyCtxt<'tcx>>>(\n+        infcx: &'a InferCtxt<'tcx>,\n+        canonicalize_mode: CanonicalizeMode,\n+        variables: &'a mut Vec<ty::GenericArg<'tcx>>,\n+        value: T,\n+    ) -> Canonical<'tcx, T> {\n+        let mut canonicalizer = Canonicalizer {\n+            infcx,\n+            canonicalize_mode,\n+\n+            variables,\n+            primitive_var_infos: Vec::new(),\n+            binder_index: ty::INNERMOST,\n+        };\n+\n+        let value = value.fold_with(&mut canonicalizer);\n+        assert!(!value.needs_infer());\n+        assert!(!value.has_placeholders());\n+\n+        let (max_universe, variables) = canonicalizer.finalize();\n+\n+        Canonical { max_universe, variables, value }\n+    }\n+\n+    fn finalize(self) -> (ty::UniverseIndex, CanonicalVarInfos<'tcx>) {\n+        let mut var_infos = self.primitive_var_infos;\n+        // See the rustc-dev-guide section about how we deal with universes\n+        // during canonicalization in the new solver.\n+        match self.canonicalize_mode {\n+            // We try to deduplicate as many query calls as possible and hide\n+            // all information which should not matter for the solver.\n+            //\n+            // For this we compress universes as much as possible.\n+            CanonicalizeMode::Input => {}\n+            // When canonicalizing a response we map a universes already entered\n+            // by the caller to the root universe and only return useful universe\n+            // information for placeholders and inference variables created inside\n+            // of the query.\n+            CanonicalizeMode::Response { max_input_universe } => {\n+                for var in var_infos.iter_mut() {\n+                    let uv = var.universe();\n+                    let new_uv = ty::UniverseIndex::from(\n+                        uv.index().saturating_sub(max_input_universe.index()),\n+                    );\n+                    *var = var.with_updated_universe(new_uv);\n+                }\n+                let max_universe = var_infos\n+                    .iter()\n+                    .map(|info| info.universe())\n+                    .max()\n+                    .unwrap_or(ty::UniverseIndex::ROOT);\n+\n+                let var_infos = self.infcx.tcx.mk_canonical_var_infos(&var_infos);\n+                return (max_universe, var_infos);\n+            }\n+        }\n+\n+        // Given a `var_infos` with existentials `En` and universals `Un` in\n+        // universes `n`, this algorithm compresses them in place so that:\n+        //\n+        // - the new universe indices are as small as possible\n+        // - we only create a new universe if we would otherwise put a placeholder in\n+        //   the same compressed universe as an existential which cannot name it\n+        //\n+        // Let's walk through an example:\n+        // - var_infos: [E0, U1, E5, U2, E2, E6, U6], curr_compressed_uv: 0, next_orig_uv: 0\n+        // - var_infos: [E0, U1, E5, U2, E2, E6, U6], curr_compressed_uv: 0, next_orig_uv: 1\n+        // - var_infos: [E0, U1, E5, U2, E2, E6, U6], curr_compressed_uv: 1, next_orig_uv: 2\n+        // - var_infos: [E0, U1, E5, U1, E1, E6, U6], curr_compressed_uv: 1, next_orig_uv: 5\n+        // - var_infos: [E0, U1, E1, U1, E1, E6, U6], curr_compressed_uv: 1, next_orig_uv: 6\n+        // - var_infos: [E0, U1, E1, U1, E1, E2, U2], curr_compressed_uv: 2, next_orig_uv: -\n+        //\n+        // This algorithm runs in `O(n\u00b2)` where `n` is the number of different universe\n+        // indices in the input. This should be fine as `n` is expected to be small.\n+        let mut curr_compressed_uv = ty::UniverseIndex::ROOT;\n+        let mut existential_in_new_uv = false;\n+        let mut next_orig_uv = Some(ty::UniverseIndex::ROOT);\n+        while let Some(orig_uv) = next_orig_uv.take() {\n+            let mut update_uv = |var: &mut CanonicalVarInfo<'tcx>, orig_uv, is_existential| {\n+                let uv = var.universe();\n+                match uv.cmp(&orig_uv) {\n+                    Ordering::Less => (), // Already updated\n+                    Ordering::Equal => {\n+                        if is_existential {\n+                            existential_in_new_uv = true;\n+                        } else if existential_in_new_uv {\n+                            //  `var` is a placeholder from a universe which is not nameable\n+                            // by an existential which we already put into the compressed\n+                            // universe `curr_compressed_uv`. We therefore have to create a\n+                            // new universe for `var`.\n+                            curr_compressed_uv = curr_compressed_uv.next_universe();\n+                            existential_in_new_uv = false;\n+                        }\n+\n+                        *var = var.with_updated_universe(curr_compressed_uv);\n+                    }\n+                    Ordering::Greater => {\n+                        // We can ignore this variable in this iteration. We only look at\n+                        // universes which actually occur in the input for performance.\n+                        //\n+                        // For this we set `next_orig_uv` to the next smallest, not yet compressed,\n+                        // universe of the input.\n+                        if next_orig_uv.map_or(true, |curr_next_uv| uv.cannot_name(curr_next_uv)) {\n+                            next_orig_uv = Some(uv);\n+                        }\n+                    }\n+                }\n+            };\n+\n+            // For each universe which occurs in the input, we first iterate over all\n+            // placeholders and then over all inference variables.\n+            //\n+            // Whenever we compress the universe of a placeholder, no existential with\n+            // an already compressed universe can name that placeholder.\n+            for is_existential in [false, true] {\n+                for var in var_infos.iter_mut() {\n+                    // We simply put all regions from the input into the highest\n+                    // compressed universe, so we only deal with them at the end.\n+                    if !var.is_region() {\n+                        if is_existential == var.is_existential() {\n+                            update_uv(var, orig_uv, is_existential)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for var in var_infos.iter_mut() {\n+            if var.is_region() {\n+                assert!(var.is_existential());\n+                *var = var.with_updated_universe(curr_compressed_uv);\n+            }\n+        }\n+\n+        let var_infos = self.infcx.tcx.mk_canonical_var_infos(&var_infos);\n+        (curr_compressed_uv, var_infos)\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n+    fn interner(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>\n+    where\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n+    {\n+        self.binder_index.shift_in(1);\n+        let t = t.super_fold_with(self);\n+        self.binder_index.shift_out(1);\n+        t\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        let r = self.infcx.shallow_resolve(r);\n+        let kind = match *r {\n+            ty::ReLateBound(..) => return r,\n+\n+            ty::ReStatic => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::Region(ty::UniverseIndex::ROOT),\n+                CanonicalizeMode::Response { .. } => return r,\n+            },\n+\n+            ty::ReErased | ty::ReFree(_) | ty::ReEarlyBound(_) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::Region(ty::UniverseIndex::ROOT),\n+                CanonicalizeMode::Response { .. } => bug!(\"unexpected region in response: {r:?}\"),\n+            },\n+\n+            ty::RePlaceholder(placeholder) => match self.canonicalize_mode {\n+                // We canonicalize placeholder regions as existentials in query inputs.\n+                CanonicalizeMode::Input => CanonicalVarKind::Region(ty::UniverseIndex::ROOT),\n+                CanonicalizeMode::Response { max_input_universe } => {\n+                    // If we have a placeholder region inside of a query, it must be from\n+                    // a new universe.\n+                    if max_input_universe.can_name(placeholder.universe) {\n+                        bug!(\"new placeholder in universe {max_input_universe:?}: {r:?}\");\n+                    }\n+                    CanonicalVarKind::PlaceholderRegion(placeholder)\n+                }\n+            },\n+\n+            ty::ReVar(_) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::Region(ty::UniverseIndex::ROOT),\n+                CanonicalizeMode::Response { .. } => {\n+                    CanonicalVarKind::Region(self.infcx.universe_of_region(r))\n+                }\n+            },\n+\n+            ty::ReError(_) => return r,\n+        };\n+\n+        let existing_bound_var = match self.canonicalize_mode {\n+            CanonicalizeMode::Input => None,\n+            CanonicalizeMode::Response { .. } => {\n+                self.variables.iter().position(|&v| v == r.into()).map(ty::BoundVar::from)\n+            }\n+        };\n+        let var = existing_bound_var.unwrap_or_else(|| {\n+            let var = ty::BoundVar::from(self.variables.len());\n+            self.variables.push(r.into());\n+            self.primitive_var_infos.push(CanonicalVarInfo { kind });\n+            var\n+        });\n+        let br = ty::BoundRegion { var, kind: BrAnon(var.as_u32(), None) };\n+        self.interner().mk_re_late_bound(self.binder_index, br)\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        let kind = match *t.kind() {\n+            ty::Infer(ty::TyVar(vid)) => match self.infcx.probe_ty_var(vid) {\n+                Ok(t) => return self.fold_ty(t),\n+                Err(ui) => CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n+            },\n+            ty::Infer(ty::IntVar(_)) => {\n+                let nt = self.infcx.shallow_resolve(t);\n+                if nt != t {\n+                    return self.fold_ty(nt);\n+                } else {\n+                    CanonicalVarKind::Ty(CanonicalTyVarKind::Int)\n+                }\n+            }\n+            ty::Infer(ty::FloatVar(_)) => {\n+                let nt = self.infcx.shallow_resolve(t);\n+                if nt != t {\n+                    return self.fold_ty(nt);\n+                } else {\n+                    CanonicalVarKind::Ty(CanonicalTyVarKind::Int)\n+                }\n+            }\n+            ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+                bug!(\"fresh var during canonicalization: {t:?}\")\n+            }\n+            ty::Placeholder(placeholder) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::PlaceholderTy(ty::Placeholder {\n+                    universe: placeholder.universe,\n+                    name: BoundTyKind::Anon(self.variables.len() as u32),\n+                }),\n+                CanonicalizeMode::Response { .. } => CanonicalVarKind::PlaceholderTy(placeholder),\n+            },\n+            ty::Param(_) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::PlaceholderTy(ty::Placeholder {\n+                    universe: ty::UniverseIndex::ROOT,\n+                    name: ty::BoundTyKind::Anon(self.variables.len() as u32),\n+                }),\n+                CanonicalizeMode::Response { .. } => bug!(\"param ty in response: {t:?}\"),\n+            },\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Adt(_, _)\n+            | ty::Foreign(_)\n+            | ty::Str\n+            | ty::Array(_, _)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(_, _, _)\n+            | ty::FnDef(_, _)\n+            | ty::FnPtr(_)\n+            | ty::Dynamic(_, _, _)\n+            | ty::Closure(_, _)\n+            | ty::Generator(_, _, _)\n+            | ty::GeneratorWitness(_)\n+            | ty::GeneratorWitnessMIR(..)\n+            | ty::Never\n+            | ty::Tuple(_)\n+            | ty::Alias(_, _)\n+            | ty::Bound(_, _)\n+            | ty::Error(_) => return t.super_fold_with(self),\n+        };\n+\n+        let var = ty::BoundVar::from(\n+            self.variables.iter().position(|&v| v == t.into()).unwrap_or_else(|| {\n+                let var = self.variables.len();\n+                self.variables.push(t.into());\n+                self.primitive_var_infos.push(CanonicalVarInfo { kind });\n+                var\n+            }),\n+        );\n+        let bt = ty::BoundTy { var, kind: BoundTyKind::Anon(var.index() as u32) };\n+        self.interner().mk_bound(self.binder_index, bt)\n+    }\n+\n+    fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        let kind = match c.kind() {\n+            ty::ConstKind::Infer(ty::InferConst::Var(vid)) => match self.infcx.probe_const_var(vid)\n+            {\n+                Ok(c) => return self.fold_const(c),\n+                Err(universe) => CanonicalVarKind::Const(universe, c.ty()),\n+            },\n+            ty::ConstKind::Infer(ty::InferConst::Fresh(_)) => {\n+                bug!(\"fresh var during canonicalization: {c:?}\")\n+            }\n+            ty::ConstKind::Placeholder(placeholder) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::PlaceholderConst(\n+                    ty::Placeholder {\n+                        universe: placeholder.universe,\n+                        name: ty::BoundVar::from(self.variables.len()),\n+                    },\n+                    c.ty(),\n+                ),\n+                CanonicalizeMode::Response { .. } => {\n+                    CanonicalVarKind::PlaceholderConst(placeholder, c.ty())\n+                }\n+            },\n+            ty::ConstKind::Param(_) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::PlaceholderConst(\n+                    ty::Placeholder {\n+                        universe: ty::UniverseIndex::ROOT,\n+                        name: ty::BoundVar::from(self.variables.len()),\n+                    },\n+                    c.ty(),\n+                ),\n+                CanonicalizeMode::Response { .. } => bug!(\"param ty in response: {c:?}\"),\n+            },\n+            ty::ConstKind::Bound(_, _)\n+            | ty::ConstKind::Unevaluated(_)\n+            | ty::ConstKind::Value(_)\n+            | ty::ConstKind::Error(_)\n+            | ty::ConstKind::Expr(_) => return c.super_fold_with(self),\n+        };\n+\n+        let var = ty::BoundVar::from(\n+            self.variables.iter().position(|&v| v == c.into()).unwrap_or_else(|| {\n+                let var = self.variables.len();\n+                self.variables.push(c.into());\n+                self.primitive_var_infos.push(CanonicalVarInfo { kind });\n+                var\n+            }),\n+        );\n+        self.interner().mk_const(ty::ConstKind::Bound(self.binder_index, var), c.ty())\n+    }\n+}"}, {"sha": "8c3be8da16b57841f5a7523f4b3e8754fe11a595", "filename": "compiler/rustc_trait_selection/src/solve/canonical/mod.rs", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -0,0 +1,240 @@\n+/// Canonicalization is used to separate some goal from its context,\n+/// throwing away unnecessary information in the process.\n+///\n+/// This is necessary to cache goals containing inference variables\n+/// and placeholders without restricting them to the current `InferCtxt`.\n+///\n+/// Canonicalization is fairly involved, for more details see the relevant\n+/// section of the [rustc-dev-guide][c].\n+///\n+/// [c]: https://rustc-dev-guide.rust-lang.org/solve/canonicalization.html\n+use self::canonicalize::{CanonicalizeMode, Canonicalizer};\n+use super::{CanonicalGoal, Certainty, EvalCtxt, Goal};\n+use super::{CanonicalResponse, ExternalConstraints, QueryResult, Response};\n+use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n+use rustc_infer::infer::canonical::CanonicalVarValues;\n+use rustc_infer::infer::canonical::{CanonicalExt, QueryRegionConstraints};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::solve::ExternalConstraintsData;\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::ty::{self, GenericArgKind};\n+use rustc_span::DUMMY_SP;\n+use std::iter;\n+use std::ops::Deref;\n+\n+mod canonicalize;\n+\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    /// Canonicalizes the goal remembering the original values\n+    /// for each bound variable.\n+    pub(super) fn canonicalize_goal(\n+        &self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> (Vec<ty::GenericArg<'tcx>>, CanonicalGoal<'tcx>) {\n+        let mut orig_values = Default::default();\n+        let canonical_goal = Canonicalizer::canonicalize(\n+            self.infcx,\n+            CanonicalizeMode::Input,\n+            &mut orig_values,\n+            goal,\n+        );\n+        (orig_values, canonical_goal)\n+    }\n+\n+    /// To return the constraints of a canonical query to the caller, we canonicalize:\n+    ///\n+    /// - `var_values`: a map from bound variables in the canonical goal to\n+    ///   the values inferred while solving the instantiated goal.\n+    /// - `external_constraints`: additional constraints which aren't expressable\n+    ///   using simple unification of inference variables.\n+    #[instrument(level = \"debug\", skip(self))]\n+    pub(super) fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n+        let external_constraints = self.compute_external_query_constraints()?;\n+\n+        let response = Response { var_values: self.var_values, external_constraints, certainty };\n+        let canonical = Canonicalizer::canonicalize(\n+            self.infcx,\n+            CanonicalizeMode::Response { max_input_universe: self.max_input_universe },\n+            &mut Default::default(),\n+            response,\n+        );\n+        Ok(canonical)\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn compute_external_query_constraints(&self) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n+        // Cannot use `take_registered_region_obligations` as we may compute the response\n+        // inside of a `probe` whenever we have multiple choices inside of the solver.\n+        let region_obligations = self.infcx.inner.borrow().region_obligations().to_owned();\n+        let region_constraints = self.infcx.with_region_constraints(|region_constraints| {\n+            make_query_region_constraints(\n+                self.tcx(),\n+                region_obligations\n+                    .iter()\n+                    .map(|r_o| (r_o.sup_type, r_o.sub_region, r_o.origin.to_constraint_category())),\n+                region_constraints,\n+            )\n+        });\n+        let opaque_types = self.infcx.clone_opaque_types_for_query_response();\n+        Ok(self\n+            .tcx()\n+            .mk_external_constraints(ExternalConstraintsData { region_constraints, opaque_types }))\n+    }\n+\n+    /// After calling a canonical query, we apply the constraints returned\n+    /// by the query using this function.\n+    ///\n+    /// This happens in three steps:\n+    /// - we instantiate the bound variables of the query response\n+    /// - we unify the `var_values` of the response with the `original_values`\n+    /// - we apply the `external_constraints` returned by the query\n+    pub(super) fn instantiate_and_apply_query_response(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: Vec<ty::GenericArg<'tcx>>,\n+        response: CanonicalResponse<'tcx>,\n+    ) -> Result<Certainty, NoSolution> {\n+        let substitution = self.compute_query_response_substitution(&original_values, &response);\n+\n+        let Response { var_values, external_constraints, certainty } =\n+            response.substitute(self.tcx(), &substitution);\n+\n+        self.unify_query_var_values(param_env, &original_values, var_values)?;\n+\n+        // FIXME: implement external constraints.\n+        let ExternalConstraintsData { region_constraints, opaque_types: _ } =\n+            external_constraints.deref();\n+        self.register_region_constraints(region_constraints);\n+\n+        Ok(certainty)\n+    }\n+\n+    /// This returns the substitutions to instantiate the bound variables of\n+    /// the canonical reponse. This depends on the `original_values` for the\n+    /// bound variables.\n+    fn compute_query_response_substitution(\n+        &self,\n+        original_values: &[ty::GenericArg<'tcx>],\n+        response: &CanonicalResponse<'tcx>,\n+    ) -> CanonicalVarValues<'tcx> {\n+        // FIXME: Longterm canonical queries should deal with all placeholders\n+        // created inside of the query directly instead of returning them to the\n+        // caller.\n+        let prev_universe = self.infcx.universe();\n+        let universes_created_in_query = response.max_universe.index() + 1;\n+        for _ in 0..universes_created_in_query {\n+            self.infcx.create_next_universe();\n+        }\n+\n+        let var_values = response.value.var_values;\n+        assert_eq!(original_values.len(), var_values.len());\n+\n+        // If the query did not make progress with constraining inference variables,\n+        // we would normally create a new inference variables for bound existential variables\n+        // only then unify this new inference variable with the inference variable from\n+        // the input.\n+        //\n+        // We therefore instantiate the existential variable in the canonical response with the\n+        // inference variable of the input right away, which is more performant.\n+        let mut opt_values = vec![None; response.variables.len()];\n+        for (original_value, result_value) in iter::zip(original_values, var_values.var_values) {\n+            match result_value.unpack() {\n+                GenericArgKind::Type(t) => {\n+                    if let &ty::Bound(debruijn, b) = t.kind() {\n+                        assert_eq!(debruijn, ty::INNERMOST);\n+                        opt_values[b.var.index()] = Some(*original_value);\n+                    }\n+                }\n+                GenericArgKind::Lifetime(r) => {\n+                    if let ty::ReLateBound(debruijn, br) = *r {\n+                        assert_eq!(debruijn, ty::INNERMOST);\n+                        opt_values[br.var.index()] = Some(*original_value);\n+                    }\n+                }\n+                GenericArgKind::Const(c) => {\n+                    if let ty::ConstKind::Bound(debrujin, b) = c.kind() {\n+                        assert_eq!(debrujin, ty::INNERMOST);\n+                        opt_values[b.index()] = Some(*original_value);\n+                    }\n+                }\n+            }\n+        }\n+\n+        let var_values = self.tcx().mk_substs_from_iter(response.variables.iter().enumerate().map(\n+            |(index, info)| {\n+                if info.universe() != ty::UniverseIndex::ROOT {\n+                    // A variable from inside a binder of the query. While ideally these shouldn't\n+                    // exist at all (see the FIXME at the start of this method), we have to deal with\n+                    // them for now.\n+                    self.infcx.instantiate_canonical_var(DUMMY_SP, info, |idx| {\n+                        ty::UniverseIndex::from(prev_universe.index() + idx.index())\n+                    })\n+                } else if info.is_existential() {\n+                    // As an optimization we sometimes avoid creating a new inference variable here.\n+                    //\n+                    // All new inference variables we create start out in the current universe of the caller.\n+                    // This is conceptionally wrong as these inference variables would be able to name\n+                    // more placeholders then they should be able to. However the inference variables have\n+                    // to \"come from somewhere\", so by equating them with the original values of the caller\n+                    // later on, we pull them down into their correct universe again.\n+                    if let Some(v) = opt_values[index] {\n+                        v\n+                    } else {\n+                        self.infcx.instantiate_canonical_var(DUMMY_SP, info, |_| prev_universe)\n+                    }\n+                } else {\n+                    // For placeholders which were already part of the input, we simply map this\n+                    // universal bound variable back the placeholder of the input.\n+                    original_values[info.expect_anon_placeholder() as usize]\n+                }\n+            },\n+        ));\n+\n+        CanonicalVarValues { var_values }\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    fn unify_query_var_values(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: &[ty::GenericArg<'tcx>],\n+        var_values: CanonicalVarValues<'tcx>,\n+    ) -> Result<(), NoSolution> {\n+        assert_eq!(original_values.len(), var_values.len());\n+        for (&orig, response) in iter::zip(original_values, var_values.var_values) {\n+            // This can fail due to the occurs check, see\n+            // `tests/ui/typeck/lazy-norm/equating-projection-cyclically.rs` for an example\n+            // where that can happen.\n+            //\n+            // FIXME: To deal with #105787 I also expect us to emit nested obligations here at\n+            // some point. We can figure out how to deal with this once we actually have\n+            // an ICE.\n+            let nested_goals = self.eq(param_env, orig, response)?;\n+            assert!(nested_goals.is_empty(), \"{nested_goals:?}\");\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn register_region_constraints(&mut self, region_constraints: &QueryRegionConstraints<'tcx>) {\n+        for &(ty::OutlivesPredicate(lhs, rhs), _) in &region_constraints.outlives {\n+            match lhs.unpack() {\n+                GenericArgKind::Lifetime(lhs) => self.infcx.region_outlives_predicate(\n+                    &ObligationCause::dummy(),\n+                    ty::Binder::dummy(ty::OutlivesPredicate(lhs, rhs)),\n+                ),\n+                GenericArgKind::Type(lhs) => self.infcx.register_region_obligation_with_cause(\n+                    lhs,\n+                    rhs,\n+                    &ObligationCause::dummy(),\n+                ),\n+                GenericArgKind::Const(_) => bug!(\"const outlives: {lhs:?}: {rhs:?}\"),\n+            }\n+        }\n+\n+        for member_constraint in &region_constraints.member_constraints {\n+            // FIXME: Deal with member constraints :<\n+            let _ = member_constraint;\n+        }\n+    }\n+}"}, {"sha": "95612674eb9d417a0fa173e1c6516ce9e4679cfa", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -19,8 +19,17 @@ use super::Goal;\n pub struct EvalCtxt<'a, 'tcx> {\n     // FIXME: should be private.\n     pub(super) infcx: &'a InferCtxt<'tcx>,\n-\n     pub(super) var_values: CanonicalVarValues<'tcx>,\n+    /// The highest universe index nameable by the caller.\n+    ///\n+    /// When we enter a new binder inside of the query we create new universes\n+    /// which the caller cannot name. We have to be careful with variables from\n+    /// these new universes when creating the query response.\n+    ///\n+    /// Both because these new universes can prevent us from reaching a fixpoint\n+    /// if we have a coinductive cycle and because that's the only way we can return\n+    /// new placeholders to the caller.\n+    pub(super) max_input_universe: ty::UniverseIndex,\n \n     pub(super) search_graph: &'a mut SearchGraph<'tcx>,\n "}, {"sha": "57b6a4527371835c0bee86d095e7a9f63a8d480a", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 27, "deletions": 70, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -19,11 +19,9 @@ use std::mem;\n \n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc_infer::infer::canonical::{OriginalQueryValues, QueryRegionConstraints, QueryResponse};\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::Obligation;\n-use rustc_middle::infer::canonical::Certainty as OldCertainty;\n use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n@@ -35,6 +33,7 @@ use crate::solve::search_graph::OverflowHandler;\n use crate::traits::ObligationCause;\n \n mod assembly;\n+mod canonical;\n mod eval_ctxt;\n mod fulfill;\n mod project_goals;\n@@ -89,11 +88,8 @@ trait CanonicalResponseExt {\n \n impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n     fn has_no_inference_or_external_constraints(&self) -> bool {\n-        // so that we get a compile error when regions are supported\n-        // so this code can be checked for being correct\n-        let _: () = self.value.external_constraints.regions;\n-\n-        self.value.var_values.is_identity()\n+        self.value.external_constraints.region_constraints.is_empty()\n+            && self.value.var_values.is_identity()\n             && self.value.external_constraints.opaque_types.is_empty()\n     }\n }\n@@ -169,6 +165,8 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n         let result = EvalCtxt {\n             search_graph: &mut search_graph,\n             infcx: self,\n+            // Only relevant when canonicalizing the response.\n+            max_input_universe: ty::UniverseIndex::ROOT,\n             var_values: CanonicalVarValues::dummy(),\n             in_projection_eq_hack: false,\n         }\n@@ -201,36 +199,33 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n             let (ref infcx, goal, var_values) =\n                 tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-            let mut ecx =\n-                EvalCtxt { infcx, var_values, search_graph, in_projection_eq_hack: false };\n+            let mut ecx = EvalCtxt {\n+                infcx,\n+                var_values,\n+                max_input_universe: canonical_goal.max_universe,\n+                search_graph,\n+                in_projection_eq_hack: false,\n+            };\n             ecx.compute_goal(goal)\n         })\n     }\n \n-    fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n-        let external_constraints = compute_external_query_constraints(self.infcx)?;\n-\n-        Ok(self.infcx.canonicalize_response(Response {\n-            var_values: self.var_values,\n-            external_constraints,\n-            certainty,\n-        }))\n-    }\n-\n     /// Recursively evaluates `goal`, returning whether any inference vars have\n     /// been constrained and the certainty of the result.\n     fn evaluate_goal(\n         &mut self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n     ) -> Result<(bool, Certainty), NoSolution> {\n-        let mut orig_values = OriginalQueryValues::default();\n-        let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+        let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n         let canonical_response =\n             EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n \n         let has_changed = !canonical_response.value.var_values.is_identity();\n-        let certainty =\n-            instantiate_canonical_query_response(self.infcx, &orig_values, canonical_response);\n+        let certainty = self.instantiate_and_apply_query_response(\n+            goal.param_env,\n+            orig_values,\n+            canonical_response,\n+        )?;\n \n         // Check that rerunning this query with its inference constraints applied\n         // doesn't result in new inference constraints and has the same result.\n@@ -244,8 +239,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             && !self.in_projection_eq_hack\n             && !self.search_graph.in_cycle()\n         {\n-            let mut orig_values = OriginalQueryValues::default();\n-            let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+            let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n             let canonical_response =\n                 EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n             if !canonical_response.value.var_values.is_identity() {\n@@ -316,15 +310,21 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n \n     fn compute_type_outlives_goal(\n         &mut self,\n-        _goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n+        goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n+        let ty::OutlivesPredicate(ty, lt) = goal.predicate;\n+        self.infcx.register_region_obligation_with_cause(ty, lt, &ObligationCause::dummy());\n         self.make_canonical_response(Certainty::Yes)\n     }\n \n     fn compute_region_outlives_goal(\n         &mut self,\n-        _goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n+        goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n+        self.infcx.region_outlives_predicate(\n+            &ObligationCause::dummy(),\n+            ty::Binder::dummy(goal.predicate),\n+        );\n         self.make_canonical_response(Certainty::Yes)\n     }\n \n@@ -561,49 +561,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     }\n }\n \n-#[instrument(level = \"debug\", skip(infcx), ret)]\n-fn compute_external_query_constraints<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n-    let region_obligations = infcx.take_registered_region_obligations();\n-    let opaque_types = infcx.take_opaque_types_for_query_response();\n-    Ok(infcx.tcx.mk_external_constraints(ExternalConstraintsData {\n-        // FIXME: Now that's definitely wrong :)\n-        //\n-        // Should also do the leak check here I think\n-        regions: drop(region_obligations),\n-        opaque_types,\n-    }))\n-}\n-\n-fn instantiate_canonical_query_response<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    original_values: &OriginalQueryValues<'tcx>,\n-    response: CanonicalResponse<'tcx>,\n-) -> Certainty {\n-    let Ok(InferOk { value, obligations }) = infcx\n-        .instantiate_query_response_and_region_obligations(\n-            &ObligationCause::dummy(),\n-            ty::ParamEnv::empty(),\n-            original_values,\n-            &response.unchecked_map(|resp| QueryResponse {\n-                var_values: resp.var_values,\n-                region_constraints: QueryRegionConstraints::default(),\n-                certainty: match resp.certainty {\n-                    Certainty::Yes => OldCertainty::Proven,\n-                    Certainty::Maybe(_) => OldCertainty::Ambiguous,\n-                },\n-                // FIXME: This to_owned makes me sad, but we should eventually impl\n-                // `instantiate_query_response_and_region_obligations` separately\n-                // instead of piggybacking off of the old implementation.\n-                opaque_types: resp.external_constraints.opaque_types.to_owned(),\n-                value: resp.certainty,\n-            }),\n-        ) else { bug!(); };\n-    assert!(obligations.is_empty());\n-    value\n-}\n-\n pub(super) fn response_no_constraints<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     goal: Canonical<'tcx, impl Sized>,"}, {"sha": "33c66d072e944dd5c8353d230df8855abaf7b796", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -77,10 +77,11 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let nested_goals = self\n             .eq(goal.param_env, goal.predicate.term, normalized_alias.into())\n             .expect(\"failed to unify with unconstrained term\");\n-        let rhs_certainty =\n+\n+        let unify_certainty =\n             self.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n \n-        self.make_canonical_response(normalization_certainty.unify_and(rhs_certainty))\n+        self.make_canonical_response(normalization_certainty.unify_and(unify_certainty))\n     }\n }\n "}, {"sha": "9ab753c5a482696ff1d3d0dc3ae12b5d61a8fedd", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::hir::map;\n use rustc_middle::ty::error::TypeError::{self, Sorts};\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{\n-    self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n+    self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind,\n     GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, InternalSubsts,\n     IsSuggestable, ToPredicate, Ty, TyCtxt, TypeAndMut, TypeFoldable, TypeFolder,\n     TypeSuperFoldable, TypeVisitableExt, TypeckResults,"}, {"sha": "944436ab82f91cc79522d1dc5c9acc02e0280f4b", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -212,36 +212,44 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n     /// Identifies whether a predicate obligation needs processing.\n     ///\n-    /// This is always inlined, despite its size, because it has a single\n-    /// callsite and it is called *very* frequently.\n+    /// This is always inlined because it has a single callsite and it is\n+    /// called *very* frequently. Be careful modifying this code! Several\n+    /// compile-time benchmarks are very sensitive to even small changes.\n     #[inline(always)]\n     fn needs_process_obligation(&self, pending_obligation: &Self::Obligation) -> bool {\n         // If we were stalled on some unresolved variables, first check whether\n         // any of them have been resolved; if not, don't bother doing more work\n         // yet.\n-        match pending_obligation.stalled_on.len() {\n-            // Match arms are in order of frequency, which matters because this\n-            // code is so hot. 1 and 0 dominate; 2+ is fairly rare.\n-            1 => {\n-                let infer_var = pending_obligation.stalled_on[0];\n-                self.selcx.infcx.ty_or_const_infer_var_changed(infer_var)\n-            }\n-            0 => {\n-                // In this case we haven't changed, but wish to make a change.\n-                true\n-            }\n-            _ => {\n-                // This `for` loop was once a call to `all()`, but this lower-level\n-                // form was a perf win. See #64545 for details.\n-                (|| {\n-                    for &infer_var in &pending_obligation.stalled_on {\n-                        if self.selcx.infcx.ty_or_const_infer_var_changed(infer_var) {\n-                            return true;\n-                        }\n+        let stalled_on = &pending_obligation.stalled_on;\n+        match stalled_on.len() {\n+            // This case is the hottest most of the time, being hit up to 99%\n+            // of the time. `keccak` and `cranelift-codegen-0.82.1` are\n+            // benchmarks that particularly stress this path.\n+            1 => self.selcx.infcx.ty_or_const_infer_var_changed(stalled_on[0]),\n+\n+            // In this case we haven't changed, but wish to make a change. Note\n+            // that this is a special case, and is not equivalent to the `_`\n+            // case below, which would return `false` for an empty `stalled_on`\n+            // vector.\n+            //\n+            // This case is usually hit only 1% of the time or less, though it\n+            // reaches 20% in `wasmparser-0.101.0`.\n+            0 => true,\n+\n+            // This case is usually hit only 1% of the time or less, though it\n+            // reaches 95% in `mime-0.3.16`, 64% in `wast-54.0.0`, and 12% in\n+            // `inflate-0.4.5`.\n+            //\n+            // The obvious way of writing this, with a call to `any()` and no\n+            // closure, is currently slower than this version.\n+            _ => (|| {\n+                for &infer_var in stalled_on {\n+                    if self.selcx.infcx.ty_or_const_infer_var_changed(infer_var) {\n+                        return true;\n                     }\n-                    false\n-                })()\n-            }\n+                }\n+                false\n+            })(),\n         }\n     }\n "}, {"sha": "0e047977caa7b1b76cf091529c26ffc213d9a5c1", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -28,7 +28,7 @@ use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_errors::ErrorGuaranteed;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::{TypeVisitable, TypeVisitableExt};\n-use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeSuperVisitable};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeSuperVisitable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_span::def_id::{DefId, CRATE_DEF_ID};\n use rustc_span::Span;"}, {"sha": "00acbf751f0e38771775964622419c99a17fe1a3", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -32,7 +32,6 @@ use rustc_infer::traits::ImplSourceBuiltinData;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::{MaxUniverse, TypeVisitable, TypeVisitableExt};\n-use rustc_middle::ty::DefIdTree;\n use rustc_middle::ty::{self, Term, ToPredicate, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n \n@@ -1175,7 +1174,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n /// paths you want to take. To make things worse, it was possible for\n /// cycles to arise, where you basically had a setup like `<MyType<$0>\n /// as Trait>::Foo == $0`. Here, normalizing `<MyType<$0> as\n-/// Trait>::Foo> to `[type error]` would lead to an obligation of\n+/// Trait>::Foo>` to `[type error]` would lead to an obligation of\n /// `<MyType<[type error]> as Trait>::Foo`. We are supposed to report\n /// an error for this obligation, but we legitimately should not,\n /// because it contains `[type error]`. Yuck! (See issue #29857 for\n@@ -1312,16 +1311,16 @@ fn assemble_candidate_for_impl_trait_in_trait<'cx, 'tcx>(\n                 }\n                 Ok(None) => {\n                     candidate_set.mark_ambiguous();\n-                    return Err(());\n+                    Err(())\n                 }\n                 Ok(Some(_)) => {\n                     // Don't know enough about the impl to provide a useful signature\n-                    return Err(());\n+                    Err(())\n                 }\n                 Err(e) => {\n                     debug!(error = ?e, \"selection error\");\n                     candidate_set.mark_error(e);\n-                    return Err(());\n+                    Err(())\n                 }\n             }\n         });\n@@ -2199,7 +2198,8 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n         Ok(assoc_ty) => assoc_ty,\n         Err(guar) => return Progress::error(tcx, guar),\n     };\n-    if !leaf_def.item.defaultness(tcx).has_value() {\n+    // We don't support specialization for RPITITs anyways... yet.\n+    if !leaf_def.is_final() {\n         return Progress { term: tcx.ty_error_misc().into(), obligations };\n     }\n "}, {"sha": "e91057356a2dc1a170f83a02b89d3eb931071dd9", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -339,7 +339,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // Essentially any user-written impl will match with an error type,\n         // so creating `ImplCandidates` isn't useful. However, we might\n-        // end up finding a candidate elsewhere (e.g. a `BuiltinCandidate` for `Sized)\n+        // end up finding a candidate elsewhere (e.g. a `BuiltinCandidate` for `Sized`)\n         // This helps us avoid overflow: see issue #72839\n         // Since compilation is already guaranteed to fail, this is just\n         // to try to show the 'nicest' possible errors to the user."}, {"sha": "4377de158290a6a73fde8c810343efdcee388aa1", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -151,7 +151,7 @@ struct TraitObligationStack<'prev, 'tcx> {\n     /// you don't want to cache that `B: AutoTrait` or `A: AutoTrait`\n     /// is `EvaluatedToOk`; this is because they were only considered\n     /// ok on the premise that if `A: AutoTrait` held, but we indeed\n-    /// encountered a problem (later on) with `A: AutoTrait. So we\n+    /// encountered a problem (later on) with `A: AutoTrait`. So we\n     /// currently set a flag on the stack node for `B: AutoTrait` (as\n     /// well as the second instance of `A: AutoTrait`) to suppress\n     /// caching.\n@@ -727,7 +727,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             // Otherwise, we can say that `T: NonAutoTrait` is\n                             // true.\n                             // Let's imagine we have a predicate stack like\n-                            //         `Foo: Bar -> WF(T) -> T: NonAutoTrait -> T: Auto\n+                            //         `Foo: Bar -> WF(T) -> T: NonAutoTrait -> T: Auto`\n                             // depth   ^1                    ^2                 ^3\n                             // and the current predicate is `WF(T)`. `wf_args`\n                             // would contain `(T, 1)`. We want to check all"}, {"sha": "0cae0377ee8c085feb2d68be8fc87ce8e187786f", "filename": "compiler/rustc_transmute/src/maybe_transmutable/query_context.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fquery_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fquery_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fquery_context.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -58,9 +58,7 @@ mod rustc {\n             use rustc_middle::ty;\n \n             let parent = if let ty::Adt(adt_def, ..) = scope.kind() {\n-                use rustc_middle::ty::DefIdTree;\n-                let parent = self.parent(adt_def.did());\n-                parent\n+                self.parent(adt_def.did())\n             } else {\n                 // Is this always how we want to handle a non-ADT scope?\n                 return false;"}, {"sha": "2fc55a2527dd20deeca9b6486b6201c7ac290f7e", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 155, "deletions": 11, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -4,7 +4,8 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n+use rustc_middle::ty::{self, ImplTraitInTraitData, InternalSubsts, TyCtxt};\n+use rustc_span::symbol::kw;\n \n pub fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n@@ -21,12 +22,68 @@ pub fn provide(providers: &mut ty::query::Providers) {\n fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n     let item = tcx.hir().expect_item(def_id.expect_local());\n     match item.kind {\n-        hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n-            trait_item_refs.iter().map(|trait_item_ref| trait_item_ref.id.owner_id.to_def_id()),\n-        ),\n-        hir::ItemKind::Impl(ref impl_) => tcx.arena.alloc_from_iter(\n-            impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.owner_id.to_def_id()),\n-        ),\n+        hir::ItemKind::Trait(.., ref trait_item_refs) => {\n+            if tcx.sess.opts.unstable_opts.lower_impl_trait_in_trait_to_assoc_ty {\n+                // We collect RPITITs for each trait method's return type and create a\n+                // corresponding associated item using associated_items_for_impl_trait_in_trait\n+                // query.\n+                tcx.arena.alloc_from_iter(\n+                    trait_item_refs\n+                        .iter()\n+                        .map(|trait_item_ref| trait_item_ref.id.owner_id.to_def_id())\n+                        .chain(\n+                            trait_item_refs\n+                                .iter()\n+                                .filter(|trait_item_ref| {\n+                                    matches!(trait_item_ref.kind, hir::AssocItemKind::Fn { .. })\n+                                })\n+                                .flat_map(|trait_item_ref| {\n+                                    let trait_fn_def_id =\n+                                        trait_item_ref.id.owner_id.def_id.to_def_id();\n+                                    tcx.associated_items_for_impl_trait_in_trait(trait_fn_def_id)\n+                                })\n+                                .map(|def_id| *def_id),\n+                        ),\n+                )\n+            } else {\n+                tcx.arena.alloc_from_iter(\n+                    trait_item_refs\n+                        .iter()\n+                        .map(|trait_item_ref| trait_item_ref.id.owner_id.to_def_id()),\n+                )\n+            }\n+        }\n+        hir::ItemKind::Impl(ref impl_) => {\n+            if tcx.sess.opts.unstable_opts.lower_impl_trait_in_trait_to_assoc_ty {\n+                // We collect RPITITs for each trait method's return type, on the impl side too and\n+                // create a corresponding associated item using\n+                // associated_items_for_impl_trait_in_trait query.\n+                tcx.arena.alloc_from_iter(\n+                    impl_\n+                        .items\n+                        .iter()\n+                        .map(|impl_item_ref| impl_item_ref.id.owner_id.to_def_id())\n+                        .chain(impl_.of_trait.iter().flat_map(|_| {\n+                            impl_\n+                                .items\n+                                .iter()\n+                                .filter(|impl_item_ref| {\n+                                    matches!(impl_item_ref.kind, hir::AssocItemKind::Fn { .. })\n+                                })\n+                                .flat_map(|impl_item_ref| {\n+                                    let impl_fn_def_id =\n+                                        impl_item_ref.id.owner_id.def_id.to_def_id();\n+                                    tcx.associated_items_for_impl_trait_in_trait(impl_fn_def_id)\n+                                })\n+                                .map(|def_id| *def_id)\n+                        })),\n+                )\n+            } else {\n+                tcx.arena.alloc_from_iter(\n+                    impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.owner_id.to_def_id()),\n+                )\n+            }\n+        }\n         _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n     }\n }\n@@ -193,10 +250,65 @@ fn associated_item_for_impl_trait_in_trait(\n     let span = tcx.def_span(opaque_ty_def_id);\n     let trait_assoc_ty =\n         tcx.at(span).create_def(trait_def_id.expect_local(), DefPathData::ImplTraitAssocTy);\n-    trait_assoc_ty.def_id()\n+\n+    let local_def_id = trait_assoc_ty.def_id();\n+    let def_id = local_def_id.to_def_id();\n+\n+    trait_assoc_ty.opt_def_kind(Some(DefKind::AssocTy));\n+\n+    // There's no HIR associated with this new synthesized `def_id`, so feed\n+    // `opt_local_def_id_to_hir_id` with `None`.\n+    trait_assoc_ty.opt_local_def_id_to_hir_id(None);\n+\n+    // Copy span of the opaque.\n+    trait_assoc_ty.def_ident_span(Some(span));\n+\n+    // Add the def_id of the function and opaque that generated this synthesized associated type.\n+    trait_assoc_ty.opt_rpitit_info(Some(ImplTraitInTraitData::Trait {\n+        fn_def_id,\n+        opaque_def_id: opaque_ty_def_id.to_def_id(),\n+    }));\n+\n+    trait_assoc_ty.associated_item(ty::AssocItem {\n+        name: kw::Empty,\n+        kind: ty::AssocKind::Type,\n+        def_id,\n+        trait_item_def_id: None,\n+        container: ty::TraitContainer,\n+        fn_has_self_parameter: false,\n+    });\n+\n+    // Copy visility of the containing function.\n+    trait_assoc_ty.visibility(tcx.visibility(fn_def_id));\n+\n+    // Copy impl_defaultness of the containing function.\n+    trait_assoc_ty.impl_defaultness(tcx.impl_defaultness(fn_def_id));\n+\n+    // Copy type_of of the opaque.\n+    trait_assoc_ty.type_of(ty::EarlyBinder(tcx.mk_opaque(\n+        opaque_ty_def_id.to_def_id(),\n+        InternalSubsts::identity_for_item(tcx, opaque_ty_def_id.to_def_id()),\n+    )));\n+\n+    // Copy generics_of of the opaque.\n+    trait_assoc_ty.generics_of(tcx.generics_of(opaque_ty_def_id).clone());\n+\n+    // There are no predicates for the synthesized associated type.\n+    trait_assoc_ty.explicit_predicates_of(ty::GenericPredicates {\n+        parent: Some(trait_def_id),\n+        predicates: &[],\n+    });\n+\n+    // There are no inferred outlives for the synthesized associated type.\n+    trait_assoc_ty.inferred_outlives_of(&[]);\n+\n+    // FIXME implement this.\n+    trait_assoc_ty.explicit_item_bounds(&[]);\n+\n+    local_def_id\n }\n \n-/// Given an `trait_assoc_def_id` that corresponds to a previously synthethized impl trait in trait\n+/// Given an `trait_assoc_def_id` that corresponds to a previously synthesized impl trait in trait\n /// into an associated type and an `impl_def_id` corresponding to an impl block, create and return\n /// the corresponding associated item inside the impl block.\n fn impl_associated_item_for_impl_trait_in_trait(\n@@ -206,8 +318,40 @@ fn impl_associated_item_for_impl_trait_in_trait(\n ) -> LocalDefId {\n     let impl_def_id = tcx.local_parent(impl_fn_def_id);\n \n-    let span = tcx.def_span(trait_assoc_def_id);\n+    // FIXME fix the span, we probably want the def_id of the return type of the function\n+    let span = tcx.def_span(impl_fn_def_id);\n     let impl_assoc_ty = tcx.at(span).create_def(impl_def_id, DefPathData::ImplTraitAssocTy);\n \n-    impl_assoc_ty.def_id()\n+    let local_def_id = impl_assoc_ty.def_id();\n+    let def_id = local_def_id.to_def_id();\n+\n+    impl_assoc_ty.opt_def_kind(Some(DefKind::AssocTy));\n+\n+    // There's no HIR associated with this new synthesized `def_id`, so feed\n+    // `opt_local_def_id_to_hir_id` with `None`.\n+    impl_assoc_ty.opt_local_def_id_to_hir_id(None);\n+\n+    // Add the def_id of the function that generated this synthesized associated type.\n+    impl_assoc_ty.opt_rpitit_info(Some(ImplTraitInTraitData::Impl {\n+        fn_def_id: impl_fn_def_id.to_def_id(),\n+    }));\n+\n+    impl_assoc_ty.associated_item(ty::AssocItem {\n+        name: kw::Empty,\n+        kind: ty::AssocKind::Type,\n+        def_id,\n+        trait_item_def_id: Some(trait_assoc_def_id.to_def_id()),\n+        container: ty::ImplContainer,\n+        fn_has_self_parameter: false,\n+    });\n+\n+    // Copy impl_defaultness of the containing function.\n+    impl_assoc_ty.impl_defaultness(tcx.impl_defaultness(impl_fn_def_id));\n+\n+    // Copy generics_of the trait's associated item.\n+    // FIXME: This is not correct, in particular the parent is going to be wrong. So we would need\n+    // to copy from trait_assoc_def_id and adjust things.\n+    impl_assoc_ty.generics_of(tcx.generics_of(trait_assoc_def_id).clone());\n+\n+    local_def_id\n }"}, {"sha": "56d6cc28bc83f070e1795b3561673c70398fb589", "filename": "compiler/rustc_ty_utils/src/implied_bounds.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,4 +1,3 @@\n-use crate::rustc_middle::ty::DefIdTree;\n use rustc_hir::{def::DefKind, def_id::DefId};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n "}, {"sha": "3aaeb09d4c005dd1a59336f4dbce81cc8e0c7759", "filename": "config.toml.example", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -164,6 +164,7 @@ changelog-seen = 2\n # General build configuration options\n # =============================================================================\n [build]\n+\n # The default stage to use for the `check` subcommand\n #check-stage = 0\n "}, {"sha": "44a37899007f8db12f2b67de4a6bc1bc63d74561", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -283,9 +283,7 @@ impl<T> Box<T> {\n     #[must_use]\n     #[inline(always)]\n     pub fn pin(x: T) -> Pin<Box<T>> {\n-        (#[rustc_box]\n-        Box::new(x))\n-        .into()\n+        Box::new(x).into()\n     }\n \n     /// Allocates memory on the heap then places `x` into it,\n@@ -1242,8 +1240,8 @@ unsafe impl<#[may_dangle] T: ?Sized, A: Allocator> Drop for Box<T, A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Box<T> {\n     /// Creates a `Box<T>`, with the `Default` value for T.\n+    #[inline]\n     fn default() -> Self {\n-        #[rustc_box]\n         Box::new(T::default())\n     }\n }\n@@ -1252,6 +1250,7 @@ impl<T: Default> Default for Box<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n impl<T> const Default for Box<[T]> {\n+    #[inline]\n     fn default() -> Self {\n         let ptr: Unique<[T]> = Unique::<[T; 0]>::dangling();\n         Box(ptr, Global)\n@@ -1262,6 +1261,7 @@ impl<T> const Default for Box<[T]> {\n #[stable(feature = \"default_box_extra\", since = \"1.17.0\")]\n #[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n impl const Default for Box<str> {\n+    #[inline]\n     fn default() -> Self {\n         // SAFETY: This is the same as `Unique::cast<U>` but with an unsized `U = str`.\n         let ptr: Unique<str> = unsafe {\n@@ -1616,7 +1616,6 @@ impl<T, const N: usize> From<[T; N]> for Box<[T]> {\n     /// println!(\"{boxed:?}\");\n     /// ```\n     fn from(array: [T; N]) -> Box<[T]> {\n-        #[rustc_box]\n         Box::new(array)\n     }\n }"}, {"sha": "8317ac431a5e1b5ba24091cd391a57302cebe55d", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1924,7 +1924,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n         if T::IS_ZST {\n-            self.len += other.len;\n+            self.len = self.len.checked_add(other.len).expect(\"capacity overflow\");\n             other.len = 0;\n             other.head = 0;\n             return;"}, {"sha": "4c6ae8f2579fae0f41e22a00ef14d8d27e8b715a", "filename": "library/alloc/src/macros.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fmacros.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -48,6 +48,8 @@ macro_rules! vec {\n     );\n     ($($x:expr),+ $(,)?) => (\n         $crate::__rust_force_expr!(<[_]>::into_vec(\n+            // This rustc_box is not required, but it produces a dramatic improvement in compile\n+            // time when constructing arrays with many elements.\n             #[rustc_box]\n             $crate::boxed::Box::new([$($x),+])\n         ))"}, {"sha": "932a537c598f2d4b6787e56126061e2b801368d5", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -2145,7 +2145,7 @@ impl<T, I: iter::TrustedLen<Item = T>> ToRcSlice<T> for I {\n                 Rc::from_iter_exact(self, low)\n             }\n         } else {\n-            // TrustedLen contract guarantees that `upper_bound == `None` implies an iterator\n+            // TrustedLen contract guarantees that `upper_bound == None` implies an iterator\n             // length exceeding `usize::MAX`.\n             // The default implementation would collect into a vec which would panic.\n             // Thus we panic here immediately without invoking `Vec` code."}, {"sha": "c7e7ed3e95e0282358297ecbeb10d5a371158024", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -2213,10 +2213,6 @@ impl PartialEq for String {\n     fn eq(&self, other: &String) -> bool {\n         PartialEq::eq(&self[..], &other[..])\n     }\n-    #[inline]\n-    fn ne(&self, other: &String) -> bool {\n-        PartialEq::ne(&self[..], &other[..])\n-    }\n }\n \n macro_rules! impl_eq {"}, {"sha": "fdd341a06ef46ab22c325357a35eea59e24cdefc", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -2895,7 +2895,7 @@ impl<T, I: iter::TrustedLen<Item = T>> ToArcSlice<T> for I {\n                 Arc::from_iter_exact(self, low)\n             }\n         } else {\n-            // TrustedLen contract guarantees that `upper_bound == `None` implies an iterator\n+            // TrustedLen contract guarantees that `upper_bound == None` implies an iterator\n             // length exceeding `usize::MAX`.\n             // The default implementation would collect into a vec which would panic.\n             // Thus we panic here immediately without invoking `Vec` code."}, {"sha": "f2aa30f18fcf65d27d81adb237b35f4cd4b0c5c5", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -3131,10 +3131,7 @@ impl<T, const N: usize> From<[T; N]> for Vec<T> {\n     /// ```\n     #[cfg(not(test))]\n     fn from(s: [T; N]) -> Vec<T> {\n-        <[T]>::into_vec(\n-            #[rustc_box]\n-            Box::new(s),\n-        )\n+        <[T]>::into_vec(Box::new(s))\n     }\n \n     #[cfg(test)]"}, {"sha": "5a0b852e8d5e2b94fe3cfd52002512a0969ddbfe", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1045,6 +1045,20 @@ fn test_append_double_drop() {\n     assert_eq!(count_b, 1);\n }\n \n+#[test]\n+#[should_panic]\n+fn test_append_zst_capacity_overflow() {\n+    let mut v = Vec::with_capacity(usize::MAX);\n+    // note: using resize instead of set_len here would\n+    //       be *extremely* slow in unoptimized builds.\n+    // SAFETY: `v` has capacity `usize::MAX`, and no initialization\n+    //         is needed for empty tuples.\n+    unsafe { v.set_len(usize::MAX) };\n+    let mut v = VecDeque::from(v);\n+    let mut w = vec![()].into();\n+    v.append(&mut w);\n+}\n+\n #[test]\n fn test_retain() {\n     let mut buf = VecDeque::new();"}, {"sha": "c27646b8f33dfb2eeeeb8b615cc8e080719fe867", "filename": "library/core/src/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fany.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -56,7 +56,7 @@\n //!     let value_any = value as &dyn Any;\n //!\n //!     // Try to convert our value to a `String`. If successful, we want to\n-//!     // output the String`'s length as well as its value. If not, it's a\n+//!     // output the `String`'s length as well as its value. If not, it's a\n //!     // different type: just print it out unadorned.\n //!     match value_any.downcast_ref::<String>() {\n //!         Some(as_string) => {"}, {"sha": "d749865f76f518fb26d87ccb901aacf69f5e7a6d", "filename": "library/core/src/array/equality.rs", "status": "modified", "additions": 6, "deletions": 67, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Farray%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Farray%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fequality.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,6 +1,5 @@\n+use crate::cmp::BytewiseEq;\n use crate::convert::TryInto;\n-use crate::num::{NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize};\n-use crate::num::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, const N: usize> PartialEq<[B; N]> for [A; N]\n@@ -144,74 +143,14 @@ impl<T: PartialEq<Other>, Other, const N: usize> SpecArrayEq<Other, N> for T {\n     }\n }\n \n-impl<T: IsRawEqComparable<U>, U, const N: usize> SpecArrayEq<U, N> for T {\n+impl<T: BytewiseEq<U>, U, const N: usize> SpecArrayEq<U, N> for T {\n     fn spec_eq(a: &[T; N], b: &[U; N]) -> bool {\n-        // SAFETY: This is why `IsRawEqComparable` is an `unsafe trait`.\n-        unsafe {\n-            let b = &*b.as_ptr().cast::<[T; N]>();\n-            crate::intrinsics::raw_eq(a, b)\n-        }\n+        // SAFETY: Arrays are compared element-wise, and don't add any padding\n+        // between elements, so when the elements are `BytewiseEq`, we can\n+        // compare the entire array at once.\n+        unsafe { crate::intrinsics::raw_eq(a, crate::mem::transmute(b)) }\n     }\n     fn spec_ne(a: &[T; N], b: &[U; N]) -> bool {\n         !Self::spec_eq(a, b)\n     }\n }\n-\n-/// `U` exists on here mostly because `min_specialization` didn't let me\n-/// repeat the `T` type parameter in the above specialization, so instead\n-/// the `T == U` constraint comes from the impls on this.\n-/// # Safety\n-/// - Neither `Self` nor `U` has any padding.\n-/// - `Self` and `U` have the same layout.\n-/// - `Self: PartialEq<U>` is byte-wise (this means no floats, among other things)\n-#[rustc_specialization_trait]\n-unsafe trait IsRawEqComparable<U>: PartialEq<U> {}\n-\n-macro_rules! is_raw_eq_comparable {\n-    ($($t:ty),+ $(,)?) => {$(\n-        unsafe impl IsRawEqComparable<$t> for $t {}\n-    )+};\n-}\n-\n-// SAFETY: All the ordinary integer types have no padding, and are not pointers.\n-is_raw_eq_comparable!(u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize);\n-\n-// SAFETY: bool and char have *niches*, but no *padding* (and these are not pointer types), so this\n-// is sound\n-is_raw_eq_comparable!(bool, char);\n-\n-// SAFETY: Similarly, the non-zero types have a niche, but no undef and no pointers,\n-// and they compare like their underlying numeric type.\n-is_raw_eq_comparable!(\n-    NonZeroU8,\n-    NonZeroU16,\n-    NonZeroU32,\n-    NonZeroU64,\n-    NonZeroU128,\n-    NonZeroUsize,\n-    NonZeroI8,\n-    NonZeroI16,\n-    NonZeroI32,\n-    NonZeroI64,\n-    NonZeroI128,\n-    NonZeroIsize,\n-);\n-\n-// SAFETY: The NonZero types have the \"null\" optimization guaranteed, and thus\n-// are also safe to equality-compare bitwise inside an `Option`.\n-// The way `PartialOrd` is defined for `Option` means that this wouldn't work\n-// for `<` or `>` on the signed types, but since we only do `==` it's fine.\n-is_raw_eq_comparable!(\n-    Option<NonZeroU8>,\n-    Option<NonZeroU16>,\n-    Option<NonZeroU32>,\n-    Option<NonZeroU64>,\n-    Option<NonZeroU128>,\n-    Option<NonZeroUsize>,\n-    Option<NonZeroI8>,\n-    Option<NonZeroI16>,\n-    Option<NonZeroI32>,\n-    Option<NonZeroI64>,\n-    Option<NonZeroI128>,\n-    Option<NonZeroIsize>,\n-);"}, {"sha": "897d03595d748dcaf5bac03607956dd044899d20", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -632,7 +632,7 @@ pub struct RefCell<T: ?Sized> {\n     // Stores the location of the earliest currently active borrow.\n     // This gets updated whenever we go from having zero borrows\n     // to having a single borrow. When a borrow occurs, this gets included\n-    // in the generated `BorrowError/`BorrowMutError`\n+    // in the generated `BorrowError`/`BorrowMutError`\n     #[cfg(feature = \"debug_refcell\")]\n     borrowed_at: Cell<Option<&'static crate::panic::Location<'static>>>,\n     value: UnsafeCell<T>,"}, {"sha": "5b5f55d0e65b0679007bded9e455b235fa4d184a", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -22,6 +22,9 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+mod bytewise;\n+pub(crate) use bytewise::BytewiseEq;\n+\n use crate::marker::Destruct;\n \n use self::Ordering::*;"}, {"sha": "2548d9e24c9dbd50a6664522a0d0d82e81f6a849", "filename": "library/core/src/cmp/bytewise.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fcmp%2Fbytewise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fcmp%2Fbytewise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp%2Fbytewise.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -0,0 +1,83 @@\n+use crate::num::{NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize};\n+use crate::num::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\n+\n+/// Types where `==` & `!=` are equivalent to comparing their underlying bytes.\n+///\n+/// Importantly, this means no floating-point types, as those have different\n+/// byte representations (like `-0` and `+0`) which compare as the same.\n+/// Since byte arrays are `Eq`, that implies that these types are probably also\n+/// `Eq`, but that's not technically required to use this trait.\n+///\n+/// `Rhs` is *de facto* always `Self`, but the separate parameter is important\n+/// to avoid the `specializing impl repeats parameter` error when consuming this.\n+///\n+/// # Safety\n+///\n+/// - `Self` and `Rhs` have no padding.\n+/// - `Self` and `Rhs` have the same layout (size and alignment).\n+/// - Neither `Self` nor `Rhs` have provenance, so integer comparisons are correct.\n+/// - `<Self as PartialEq<Rhs>>::{eq,ne}` are equivalent to comparing the bytes.\n+#[rustc_specialization_trait]\n+pub(crate) unsafe trait BytewiseEq<Rhs = Self>: PartialEq<Rhs> + Sized {}\n+\n+macro_rules! is_bytewise_comparable {\n+    ($($t:ty),+ $(,)?) => {$(\n+        unsafe impl BytewiseEq for $t {}\n+    )+};\n+}\n+\n+// SAFETY: All the ordinary integer types have no padding, and are not pointers.\n+is_bytewise_comparable!(u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize);\n+\n+// SAFETY: These have *niches*, but no *padding* and no *provenance*,\n+// so we can compare them directly.\n+is_bytewise_comparable!(bool, char, super::Ordering);\n+\n+// SAFETY: Similarly, the non-zero types have a niche, but no undef and no pointers,\n+// and they compare like their underlying numeric type.\n+is_bytewise_comparable!(\n+    NonZeroU8,\n+    NonZeroU16,\n+    NonZeroU32,\n+    NonZeroU64,\n+    NonZeroU128,\n+    NonZeroUsize,\n+    NonZeroI8,\n+    NonZeroI16,\n+    NonZeroI32,\n+    NonZeroI64,\n+    NonZeroI128,\n+    NonZeroIsize,\n+);\n+\n+// SAFETY: The NonZero types have the \"null\" optimization guaranteed, and thus\n+// are also safe to equality-compare bitwise inside an `Option`.\n+// The way `PartialOrd` is defined for `Option` means that this wouldn't work\n+// for `<` or `>` on the signed types, but since we only do `==` it's fine.\n+is_bytewise_comparable!(\n+    Option<NonZeroU8>,\n+    Option<NonZeroU16>,\n+    Option<NonZeroU32>,\n+    Option<NonZeroU64>,\n+    Option<NonZeroU128>,\n+    Option<NonZeroUsize>,\n+    Option<NonZeroI8>,\n+    Option<NonZeroI16>,\n+    Option<NonZeroI32>,\n+    Option<NonZeroI64>,\n+    Option<NonZeroI128>,\n+    Option<NonZeroIsize>,\n+);\n+\n+macro_rules! is_bytewise_comparable_array_length {\n+    ($($n:literal),+ $(,)?) => {$(\n+        // SAFETY: Arrays have no padding between elements, so if the elements are\n+        // `BytewiseEq`, then the whole array can be too.\n+        unsafe impl<T: BytewiseEq<U>, U> BytewiseEq<[U; $n]> for [T; $n] {}\n+    )+};\n+}\n+\n+// Frustratingly, this can't be made const-generic as it gets\n+//    error: specializing impl repeats parameter `N`\n+// so just do it for a couple of plausibly-common ones.\n+is_bytewise_comparable_array_length!(0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64);"}, {"sha": "27f6659049c50d14c5f595c5cb3ecbcf810e87cb", "filename": "library/core/src/ffi/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -144,6 +144,7 @@ mod c_char_definition {\n                 )\n             ),\n             all(target_os = \"fuchsia\", target_arch = \"aarch64\"),\n+            all(target_os = \"nto\", target_arch = \"aarch64\"),\n             target_os = \"horizon\"\n         ))] {\n             pub type c_char = u8;"}, {"sha": "18a90599c4db9994c404aefd68dcd61f1d36f4ec", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -2093,6 +2093,10 @@ extern \"rust-intrinsic\" {\n     /// Above some backend-decided threshold this will emit calls to `memcmp`,\n     /// like slice equality does, instead of causing massive code size.\n     ///\n+    /// Since this works by comparing the underlying bytes, the actual `T` is\n+    /// not particularly important.  It will be used for its size and alignment,\n+    /// but any validity restrictions will be ignored, not enforced.\n+    ///\n     /// # Safety\n     ///\n     /// It's UB to call this if any of the *bytes* in `*a` or `*b` are uninitialized or carry a"}, {"sha": "72db1d87ca3c0cf4e046f294ead1387678d4d533", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -42,7 +42,7 @@\n //! another function. The `dialect` and `phase` parameters indicate which [version of MIR][dialect\n //! docs] you are inserting here. Generally you'll want to use `#![custom_mir(dialect = \"built\")]`\n //! if you want your MIR to be modified by the full MIR pipeline, or `#![custom_mir(dialect =\n-//! \"runtime\", phase = \"optimized\")] if you don't.\n+//! \"runtime\", phase = \"optimized\")]` if you don't.\n //!\n //! [dialect docs]:\n //!     https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.MirPhase.html"}, {"sha": "24bad799fc85a8b58e7e345c2f66656d5feebc21", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -124,6 +124,8 @@\n #![feature(const_inherent_unchecked_arith)]\n #![feature(const_int_unchecked_arith)]\n #![feature(const_intrinsic_forget)]\n+#![feature(const_ipv4)]\n+#![feature(const_ipv6)]\n #![feature(const_likely)]\n #![feature(const_maybe_uninit_uninit_array)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n@@ -134,6 +136,7 @@\n #![feature(const_option)]\n #![feature(const_option_ext)]\n #![feature(const_pin)]\n+#![feature(const_pointer_byte_offsets)]\n #![feature(const_pointer_is_aligned)]\n #![feature(const_ptr_sub_ptr)]\n #![feature(const_replace)]\n@@ -179,6 +182,7 @@\n #![feature(const_slice_index)]\n #![feature(const_is_char_boundary)]\n #![feature(const_cstr_methods)]\n+#![feature(ip)]\n #![feature(is_ascii_octdigit)]\n //\n // Language features:\n@@ -242,7 +246,6 @@\n // Target features:\n #![feature(arm_target_feature)]\n #![feature(avx512_target_feature)]\n-#![feature(cmpxchg16b_target_feature)]\n #![feature(hexagon_target_feature)]\n #![feature(mips_target_feature)]\n #![feature(powerpc_target_feature)]\n@@ -251,6 +254,7 @@\n #![feature(sse4a_target_feature)]\n #![feature(tbm_target_feature)]\n #![feature(wasm_target_feature)]\n+#![cfg_attr(bootstrap, feature(cmpxchg16b_target_feature))]\n \n // allow using `core::` in intra-doc links\n #[allow(unused_extern_crates)]\n@@ -349,6 +353,7 @@ pub mod cell;\n pub mod char;\n pub mod ffi;\n pub mod iter;\n+pub mod net;\n pub mod option;\n pub mod panic;\n pub mod panicking;"}, {"sha": "7aadf06e92fc6a5b80c04ea34f4256ee07295cee", "filename": "library/core/src/net/display_buffer.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fnet%2Fdisplay_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fnet%2Fdisplay_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnet%2Fdisplay_buffer.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "previous_filename": "library/std/src/net/display_buffer.rs"}, {"sha": "954d88d548e82cbb2eee1faea25d33918825d447", "filename": "library/core/src/net/ip_addr.rs", "status": "added", "additions": 2070, "deletions": 0, "changes": 2070, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fnet%2Fip_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fnet%2Fip_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnet%2Fip_addr.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -0,0 +1,2070 @@\n+use crate::cmp::Ordering;\n+use crate::fmt::{self, Write};\n+use crate::mem::transmute;\n+\n+use super::display_buffer::DisplayBuffer;\n+\n+/// An IP address, either IPv4 or IPv6.\n+///\n+/// This enum can contain either an [`Ipv4Addr`] or an [`Ipv6Addr`], see their\n+/// respective documentation for more details.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+///\n+/// let localhost_v4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\n+/// let localhost_v6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+///\n+/// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost_v4));\n+/// assert_eq!(\"::1\".parse(), Ok(localhost_v6));\n+///\n+/// assert_eq!(localhost_v4.is_ipv6(), false);\n+/// assert_eq!(localhost_v4.is_ipv4(), true);\n+/// ```\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"IpAddr\")]\n+#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, PartialOrd, Ord)]\n+pub enum IpAddr {\n+    /// An IPv4 address.\n+    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+    V4(#[stable(feature = \"ip_addr\", since = \"1.7.0\")] Ipv4Addr),\n+    /// An IPv6 address.\n+    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+    V6(#[stable(feature = \"ip_addr\", since = \"1.7.0\")] Ipv6Addr),\n+}\n+\n+/// An IPv4 address.\n+///\n+/// IPv4 addresses are defined as 32-bit integers in [IETF RFC 791].\n+/// They are usually represented as four octets.\n+///\n+/// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n+///\n+/// [IETF RFC 791]: https://tools.ietf.org/html/rfc791\n+///\n+/// # Textual representation\n+///\n+/// `Ipv4Addr` provides a [`FromStr`] implementation. The four octets are in decimal\n+/// notation, divided by `.` (this is called \"dot-decimal notation\").\n+/// Notably, octal numbers (which are indicated with a leading `0`) and hexadecimal numbers (which\n+/// are indicated with a leading `0x`) are not allowed per [IETF RFC 6943].\n+///\n+/// [IETF RFC 6943]: https://tools.ietf.org/html/rfc6943#section-3.1.1\n+/// [`FromStr`]: crate::str::FromStr\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::Ipv4Addr;\n+///\n+/// let localhost = Ipv4Addr::new(127, 0, 0, 1);\n+/// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost));\n+/// assert_eq!(localhost.is_loopback(), true);\n+/// assert!(\"012.004.002.000\".parse::<Ipv4Addr>().is_err()); // all octets are in octal\n+/// assert!(\"0000000.0.0.0\".parse::<Ipv4Addr>().is_err()); // first octet is a zero in octal\n+/// assert!(\"0xcb.0x0.0x71.0x00\".parse::<Ipv4Addr>().is_err()); // all octets are in hex\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Ipv4Addr {\n+    octets: [u8; 4],\n+}\n+\n+/// An IPv6 address.\n+///\n+/// IPv6 addresses are defined as 128-bit integers in [IETF RFC 4291].\n+/// They are usually represented as eight 16-bit segments.\n+///\n+/// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n+///\n+/// # Embedding IPv4 Addresses\n+///\n+/// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n+///\n+/// To assist in the transition from IPv4 to IPv6 two types of IPv6 addresses that embed an IPv4 address were defined:\n+/// IPv4-compatible and IPv4-mapped addresses. Of these IPv4-compatible addresses have been officially deprecated.\n+///\n+/// Both types of addresses are not assigned any special meaning by this implementation,\n+/// other than what the relevant standards prescribe. This means that an address like `::ffff:127.0.0.1`,\n+/// while representing an IPv4 loopback address, is not itself an IPv6 loopback address; only `::1` is.\n+/// To handle these so called \"IPv4-in-IPv6\" addresses, they have to first be converted to their canonical IPv4 address.\n+///\n+/// ### IPv4-Compatible IPv6 Addresses\n+///\n+/// IPv4-compatible IPv6 addresses are defined in [IETF RFC 4291 Section 2.5.5.1], and have been officially deprecated.\n+/// The RFC describes the format of an \"IPv4-Compatible IPv6 address\" as follows:\n+///\n+/// ```text\n+/// |                80 bits               | 16 |      32 bits        |\n+/// +--------------------------------------+--------------------------+\n+/// |0000..............................0000|0000|    IPv4 address     |\n+/// +--------------------------------------+----+---------------------+\n+/// ```\n+/// So `::a.b.c.d` would be an IPv4-compatible IPv6 address representing the IPv4 address `a.b.c.d`.\n+///\n+/// To convert from an IPv4 address to an IPv4-compatible IPv6 address, use [`Ipv4Addr::to_ipv6_compatible`].\n+/// Use [`Ipv6Addr::to_ipv4`] to convert an IPv4-compatible IPv6 address to the canonical IPv4 address.\n+///\n+/// [IETF RFC 4291 Section 2.5.5.1]: https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.1\n+///\n+/// ### IPv4-Mapped IPv6 Addresses\n+///\n+/// IPv4-mapped IPv6 addresses are defined in [IETF RFC 4291 Section 2.5.5.2].\n+/// The RFC describes the format of an \"IPv4-Mapped IPv6 address\" as follows:\n+///\n+/// ```text\n+/// |                80 bits               | 16 |      32 bits        |\n+/// +--------------------------------------+--------------------------+\n+/// |0000..............................0000|FFFF|    IPv4 address     |\n+/// +--------------------------------------+----+---------------------+\n+/// ```\n+/// So `::ffff:a.b.c.d` would be an IPv4-mapped IPv6 address representing the IPv4 address `a.b.c.d`.\n+///\n+/// To convert from an IPv4 address to an IPv4-mapped IPv6 address, use [`Ipv4Addr::to_ipv6_mapped`].\n+/// Use [`Ipv6Addr::to_ipv4`] to convert an IPv4-mapped IPv6 address to the canonical IPv4 address.\n+/// Note that this will also convert the IPv6 loopback address `::1` to `0.0.0.1`. Use\n+/// [`Ipv6Addr::to_ipv4_mapped`] to avoid this.\n+///\n+/// [IETF RFC 4291 Section 2.5.5.2]: https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.2\n+///\n+/// # Textual representation\n+///\n+/// `Ipv6Addr` provides a [`FromStr`] implementation. There are many ways to represent\n+/// an IPv6 address in text, but in general, each segments is written in hexadecimal\n+/// notation, and segments are separated by `:`. For more information, see\n+/// [IETF RFC 5952].\n+///\n+/// [`FromStr`]: crate::str::FromStr\n+/// [IETF RFC 5952]: https://tools.ietf.org/html/rfc5952\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::Ipv6Addr;\n+///\n+/// let localhost = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n+/// assert_eq!(\"::1\".parse(), Ok(localhost));\n+/// assert_eq!(localhost.is_loopback(), true);\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Ipv6Addr {\n+    octets: [u8; 16],\n+}\n+\n+/// Scope of an [IPv6 multicast address] as defined in [IETF RFC 7346 section 2].\n+///\n+/// # Stability Guarantees\n+///\n+/// Not all possible values for a multicast scope have been assigned.\n+/// Future RFCs may introduce new scopes, which will be added as variants to this enum;\n+/// because of this the enum is marked as `#[non_exhaustive]`.\n+///\n+/// # Examples\n+/// ```\n+/// #![feature(ip)]\n+///\n+/// use std::net::Ipv6Addr;\n+/// use std::net::Ipv6MulticastScope::*;\n+///\n+/// // An IPv6 multicast address with global scope (`ff0e::`).\n+/// let address = Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0);\n+///\n+/// // Will print \"Global scope\".\n+/// match address.multicast_scope() {\n+///     Some(InterfaceLocal) => println!(\"Interface-Local scope\"),\n+///     Some(LinkLocal) => println!(\"Link-Local scope\"),\n+///     Some(RealmLocal) => println!(\"Realm-Local scope\"),\n+///     Some(AdminLocal) => println!(\"Admin-Local scope\"),\n+///     Some(SiteLocal) => println!(\"Site-Local scope\"),\n+///     Some(OrganizationLocal) => println!(\"Organization-Local scope\"),\n+///     Some(Global) => println!(\"Global scope\"),\n+///     Some(_) => println!(\"Unknown scope\"),\n+///     None => println!(\"Not a multicast address!\")\n+/// }\n+///\n+/// ```\n+///\n+/// [IPv6 multicast address]: Ipv6Addr\n+/// [IETF RFC 7346 section 2]: https://tools.ietf.org/html/rfc7346#section-2\n+#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n+#[unstable(feature = \"ip\", issue = \"27709\")]\n+#[non_exhaustive]\n+pub enum Ipv6MulticastScope {\n+    /// Interface-Local scope.\n+    InterfaceLocal,\n+    /// Link-Local scope.\n+    LinkLocal,\n+    /// Realm-Local scope.\n+    RealmLocal,\n+    /// Admin-Local scope.\n+    AdminLocal,\n+    /// Site-Local scope.\n+    SiteLocal,\n+    /// Organization-Local scope.\n+    OrganizationLocal,\n+    /// Global scope.\n+    Global,\n+}\n+\n+impl IpAddr {\n+    /// Returns [`true`] for the special 'unspecified' address.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_unspecified()`] and\n+    /// [`Ipv6Addr::is_unspecified()`] for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)).is_unspecified(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)).is_unspecified(), true);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_unspecified(&self) -> bool {\n+        match self {\n+            IpAddr::V4(ip) => ip.is_unspecified(),\n+            IpAddr::V6(ip) => ip.is_unspecified(),\n+        }\n+    }\n+\n+    /// Returns [`true`] if this is a loopback address.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_loopback()`] and\n+    /// [`Ipv6Addr::is_loopback()`] for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)).is_loopback(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1)).is_loopback(), true);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_loopback(&self) -> bool {\n+        match self {\n+            IpAddr::V4(ip) => ip.is_loopback(),\n+            IpAddr::V6(ip) => ip.is_loopback(),\n+        }\n+    }\n+\n+    /// Returns [`true`] if the address appears to be globally routable.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_global()`] and\n+    /// [`Ipv6Addr::is_global()`] for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(80, 9, 12, 3)).is_global(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1)).is_global(), true);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_global(&self) -> bool {\n+        match self {\n+            IpAddr::V4(ip) => ip.is_global(),\n+            IpAddr::V6(ip) => ip.is_global(),\n+        }\n+    }\n+\n+    /// Returns [`true`] if this is a multicast address.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_multicast()`] and\n+    /// [`Ipv6Addr::is_multicast()`] for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(224, 254, 0, 0)).is_multicast(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0)).is_multicast(), true);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_multicast(&self) -> bool {\n+        match self {\n+            IpAddr::V4(ip) => ip.is_multicast(),\n+            IpAddr::V6(ip) => ip.is_multicast(),\n+        }\n+    }\n+\n+    /// Returns [`true`] if this address is in a range designated for documentation.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_documentation()`] and\n+    /// [`Ipv6Addr::is_documentation()`] for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_documentation(), true);\n+    /// assert_eq!(\n+    ///     IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_documentation(),\n+    ///     true\n+    /// );\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_documentation(&self) -> bool {\n+        match self {\n+            IpAddr::V4(ip) => ip.is_documentation(),\n+            IpAddr::V6(ip) => ip.is_documentation(),\n+        }\n+    }\n+\n+    /// Returns [`true`] if this address is in a range designated for benchmarking.\n+    ///\n+    /// See the documentation for [`Ipv4Addr::is_benchmarking()`] and\n+    /// [`Ipv6Addr::is_benchmarking()`] for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(198, 19, 255, 255)).is_benchmarking(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0x2, 0, 0, 0, 0, 0, 0)).is_benchmarking(), true);\n+    /// ```\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_benchmarking(&self) -> bool {\n+        match self {\n+            IpAddr::V4(ip) => ip.is_benchmarking(),\n+            IpAddr::V6(ip) => ip.is_benchmarking(),\n+        }\n+    }\n+\n+    /// Returns [`true`] if this address is an [`IPv4` address], and [`false`]\n+    /// otherwise.\n+    ///\n+    /// [`IPv4` address]: IpAddr::V4\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv4(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv4(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_ipv4(&self) -> bool {\n+        matches!(self, IpAddr::V4(_))\n+    }\n+\n+    /// Returns [`true`] if this address is an [`IPv6` address], and [`false`]\n+    /// otherwise.\n+    ///\n+    /// [`IPv6` address]: IpAddr::V6\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv6(), false);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv6(), true);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_ipv6(&self) -> bool {\n+        matches!(self, IpAddr::V6(_))\n+    }\n+\n+    /// Converts this address to an `IpAddr::V4` if it is an IPv4-mapped IPv6 addresses, otherwise it\n+    /// return `self` as-is.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)).to_canonical().is_loopback(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1)).is_loopback(), false);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1)).to_canonical().is_loopback(), true);\n+    /// ```\n+    #[inline]\n+    #[must_use = \"this returns the result of the operation, \\\n+                  without modifying the original\"]\n+    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    pub const fn to_canonical(&self) -> IpAddr {\n+        match self {\n+            &v4 @ IpAddr::V4(_) => v4,\n+            IpAddr::V6(v6) => v6.to_canonical(),\n+        }\n+    }\n+}\n+\n+impl Ipv4Addr {\n+    /// Creates a new IPv4 address from four eight-bit octets.\n+    ///\n+    /// The result will represent the IP address `a`.`b`.`c`.`d`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n+        Ipv4Addr { octets: [a, b, c, d] }\n+    }\n+\n+    /// An IPv4 address with the address pointing to localhost: `127.0.0.1`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::LOCALHOST;\n+    /// assert_eq!(addr, Ipv4Addr::new(127, 0, 0, 1));\n+    /// ```\n+    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n+    pub const LOCALHOST: Self = Ipv4Addr::new(127, 0, 0, 1);\n+\n+    /// An IPv4 address representing an unspecified address: `0.0.0.0`\n+    ///\n+    /// This corresponds to the constant `INADDR_ANY` in other languages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::UNSPECIFIED;\n+    /// assert_eq!(addr, Ipv4Addr::new(0, 0, 0, 0));\n+    /// ```\n+    #[doc(alias = \"INADDR_ANY\")]\n+    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n+    pub const UNSPECIFIED: Self = Ipv4Addr::new(0, 0, 0, 0);\n+\n+    /// An IPv4 address representing the broadcast address: `255.255.255.255`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::BROADCAST;\n+    /// assert_eq!(addr, Ipv4Addr::new(255, 255, 255, 255));\n+    /// ```\n+    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n+    pub const BROADCAST: Self = Ipv4Addr::new(255, 255, 255, 255);\n+\n+    /// Returns the four eight-bit integers that make up this address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n+    /// assert_eq!(addr.octets(), [127, 0, 0, 1]);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn octets(&self) -> [u8; 4] {\n+        self.octets\n+    }\n+\n+    /// Returns [`true`] for the special 'unspecified' address (`0.0.0.0`).\n+    ///\n+    /// This property is defined in _UNIX Network Programming, Second Edition_,\n+    /// W. Richard Stevens, p. 891; see also [ip7].\n+    ///\n+    /// [ip7]: https://man7.org/linux/man-pages/man7/ip.7.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_unspecified(), true);\n+    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_unspecified(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n+    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_unspecified(&self) -> bool {\n+        u32::from_be_bytes(self.octets) == 0\n+    }\n+\n+    /// Returns [`true`] if this is a loopback address (`127.0.0.0/8`).\n+    ///\n+    /// This property is defined by [IETF RFC 1122].\n+    ///\n+    /// [IETF RFC 1122]: https://tools.ietf.org/html/rfc1122\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_loopback(), true);\n+    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_loopback(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_loopback(&self) -> bool {\n+        self.octets()[0] == 127\n+    }\n+\n+    /// Returns [`true`] if this is a private address.\n+    ///\n+    /// The private address ranges are defined in [IETF RFC 1918] and include:\n+    ///\n+    ///  - `10.0.0.0/8`\n+    ///  - `172.16.0.0/12`\n+    ///  - `192.168.0.0/16`\n+    ///\n+    /// [IETF RFC 1918]: https://tools.ietf.org/html/rfc1918\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(10, 0, 0, 1).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(10, 10, 10, 10).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 10).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 29, 45, 14).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 32, 0, 2).is_private(), false);\n+    /// assert_eq!(Ipv4Addr::new(192, 168, 0, 2).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(192, 169, 0, 2).is_private(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_private(&self) -> bool {\n+        match self.octets() {\n+            [10, ..] => true,\n+            [172, b, ..] if b >= 16 && b <= 31 => true,\n+            [192, 168, ..] => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns [`true`] if the address is link-local (`169.254.0.0/16`).\n+    ///\n+    /// This property is defined by [IETF RFC 3927].\n+    ///\n+    /// [IETF RFC 3927]: https://tools.ietf.org/html/rfc3927\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(169, 254, 0, 0).is_link_local(), true);\n+    /// assert_eq!(Ipv4Addr::new(169, 254, 10, 65).is_link_local(), true);\n+    /// assert_eq!(Ipv4Addr::new(16, 89, 10, 65).is_link_local(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_link_local(&self) -> bool {\n+        matches!(self.octets(), [169, 254, ..])\n+    }\n+\n+    /// Returns [`true`] if the address appears to be globally reachable\n+    /// as specified by the [IANA IPv4 Special-Purpose Address Registry].\n+    /// Whether or not an address is practically reachable will depend on your network configuration.\n+    ///\n+    /// Most IPv4 addresses are globally reachable;\n+    /// unless they are specifically defined as *not* globally reachable.\n+    ///\n+    /// Non-exhaustive list of notable addresses that are not globally reachable:\n+    ///\n+    /// - The [unspecified address] ([`is_unspecified`](Ipv4Addr::is_unspecified))\n+    /// - Addresses reserved for private use ([`is_private`](Ipv4Addr::is_private))\n+    /// - Addresses in the shared address space ([`is_shared`](Ipv4Addr::is_shared))\n+    /// - Loopback addresses ([`is_loopback`](Ipv4Addr::is_loopback))\n+    /// - Link-local addresses ([`is_link_local`](Ipv4Addr::is_link_local))\n+    /// - Addresses reserved for documentation ([`is_documentation`](Ipv4Addr::is_documentation))\n+    /// - Addresses reserved for benchmarking ([`is_benchmarking`](Ipv4Addr::is_benchmarking))\n+    /// - Reserved addresses ([`is_reserved`](Ipv4Addr::is_reserved))\n+    /// - The [broadcast address] ([`is_broadcast`](Ipv4Addr::is_broadcast))\n+    ///\n+    /// For the complete overview of which addresses are globally reachable, see the table at the [IANA IPv4 Special-Purpose Address Registry].\n+    ///\n+    /// [IANA IPv4 Special-Purpose Address Registry]: https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml\n+    /// [unspecified address]: Ipv4Addr::UNSPECIFIED\n+    /// [broadcast address]: Ipv4Addr::BROADCAST\n+\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// // Most IPv4 addresses are globally reachable:\n+    /// assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n+    ///\n+    /// // However some addresses have been assigned a special meaning\n+    /// // that makes them not globally reachable. Some examples are:\n+    ///\n+    /// // The unspecified address (`0.0.0.0`)\n+    /// assert_eq!(Ipv4Addr::UNSPECIFIED.is_global(), false);\n+    ///\n+    /// // Addresses reserved for private use (`10.0.0.0/8`, `172.16.0.0/12`, 192.168.0.0/16)\n+    /// assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n+    ///\n+    /// // Addresses in the shared address space (`100.64.0.0/10`)\n+    /// assert_eq!(Ipv4Addr::new(100, 100, 0, 0).is_global(), false);\n+    ///\n+    /// // The loopback addresses (`127.0.0.0/8`)\n+    /// assert_eq!(Ipv4Addr::LOCALHOST.is_global(), false);\n+    ///\n+    /// // Link-local addresses (`169.254.0.0/16`)\n+    /// assert_eq!(Ipv4Addr::new(169, 254, 45, 1).is_global(), false);\n+    ///\n+    /// // Addresses reserved for documentation (`192.0.2.0/24`, `198.51.100.0/24`, `203.0.113.0/24`)\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_global(), false);\n+    ///\n+    /// // Addresses reserved for benchmarking (`198.18.0.0/15`)\n+    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_global(), false);\n+    ///\n+    /// // Reserved addresses (`240.0.0.0/4`)\n+    /// assert_eq!(Ipv4Addr::new(250, 10, 20, 30).is_global(), false);\n+    ///\n+    /// // The broadcast address (`255.255.255.255`)\n+    /// assert_eq!(Ipv4Addr::BROADCAST.is_global(), false);\n+    ///\n+    /// // For a complete overview see the IANA IPv4 Special-Purpose Address Registry.\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_global(&self) -> bool {\n+        !(self.octets()[0] == 0 // \"This network\"\n+            || self.is_private()\n+            || self.is_shared()\n+            || self.is_loopback()\n+            || self.is_link_local()\n+            // addresses reserved for future protocols (`192.0.0.0/24`)\n+            ||(self.octets()[0] == 192 && self.octets()[1] == 0 && self.octets()[2] == 0)\n+            || self.is_documentation()\n+            || self.is_benchmarking()\n+            || self.is_reserved()\n+            || self.is_broadcast())\n+    }\n+\n+    /// Returns [`true`] if this address is part of the Shared Address Space defined in\n+    /// [IETF RFC 6598] (`100.64.0.0/10`).\n+    ///\n+    /// [IETF RFC 6598]: https://tools.ietf.org/html/rfc6598\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(100, 64, 0, 0).is_shared(), true);\n+    /// assert_eq!(Ipv4Addr::new(100, 127, 255, 255).is_shared(), true);\n+    /// assert_eq!(Ipv4Addr::new(100, 128, 0, 0).is_shared(), false);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_shared(&self) -> bool {\n+        self.octets()[0] == 100 && (self.octets()[1] & 0b1100_0000 == 0b0100_0000)\n+    }\n+\n+    /// Returns [`true`] if this address part of the `198.18.0.0/15` range, which is reserved for\n+    /// network devices benchmarking. This range is defined in [IETF RFC 2544] as `192.18.0.0`\n+    /// through `198.19.255.255` but [errata 423] corrects it to `198.18.0.0/15`.\n+    ///\n+    /// [IETF RFC 2544]: https://tools.ietf.org/html/rfc2544\n+    /// [errata 423]: https://www.rfc-editor.org/errata/eid423\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(198, 17, 255, 255).is_benchmarking(), false);\n+    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_benchmarking(), true);\n+    /// assert_eq!(Ipv4Addr::new(198, 19, 255, 255).is_benchmarking(), true);\n+    /// assert_eq!(Ipv4Addr::new(198, 20, 0, 0).is_benchmarking(), false);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_benchmarking(&self) -> bool {\n+        self.octets()[0] == 198 && (self.octets()[1] & 0xfe) == 18\n+    }\n+\n+    /// Returns [`true`] if this address is reserved by IANA for future use. [IETF RFC 1112]\n+    /// defines the block of reserved addresses as `240.0.0.0/4`. This range normally includes the\n+    /// broadcast address `255.255.255.255`, but this implementation explicitly excludes it, since\n+    /// it is obviously not reserved for future use.\n+    ///\n+    /// [IETF RFC 1112]: https://tools.ietf.org/html/rfc1112\n+    ///\n+    /// # Warning\n+    ///\n+    /// As IANA assigns new addresses, this method will be\n+    /// updated. This may result in non-reserved addresses being\n+    /// treated as reserved in code that relies on an outdated version\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(240, 0, 0, 0).is_reserved(), true);\n+    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 254).is_reserved(), true);\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(239, 255, 255, 255).is_reserved(), false);\n+    /// // The broadcast address is not considered as reserved for future use by this implementation\n+    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_reserved(), false);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_reserved(&self) -> bool {\n+        self.octets()[0] & 240 == 240 && !self.is_broadcast()\n+    }\n+\n+    /// Returns [`true`] if this is a multicast address (`224.0.0.0/4`).\n+    ///\n+    /// Multicast addresses have a most significant octet between `224` and `239`,\n+    /// and is defined by [IETF RFC 5771].\n+    ///\n+    /// [IETF RFC 5771]: https://tools.ietf.org/html/rfc5771\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(224, 254, 0, 0).is_multicast(), true);\n+    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_multicast(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_multicast(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_multicast(&self) -> bool {\n+        self.octets()[0] >= 224 && self.octets()[0] <= 239\n+    }\n+\n+    /// Returns [`true`] if this is a broadcast address (`255.255.255.255`).\n+    ///\n+    /// A broadcast address has all octets set to `255` as defined in [IETF RFC 919].\n+    ///\n+    /// [IETF RFC 919]: https://tools.ietf.org/html/rfc919\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_broadcast(), true);\n+    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_broadcast(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_broadcast(&self) -> bool {\n+        u32::from_be_bytes(self.octets()) == u32::from_be_bytes(Self::BROADCAST.octets())\n+    }\n+\n+    /// Returns [`true`] if this address is in a range designated for documentation.\n+    ///\n+    /// This is defined in [IETF RFC 5737]:\n+    ///\n+    /// - `192.0.2.0/24` (TEST-NET-1)\n+    /// - `198.51.100.0/24` (TEST-NET-2)\n+    /// - `203.0.113.0/24` (TEST-NET-3)\n+    ///\n+    /// [IETF RFC 5737]: https://tools.ietf.org/html/rfc5737\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_documentation(), true);\n+    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_documentation(), true);\n+    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_documentation(), true);\n+    /// assert_eq!(Ipv4Addr::new(193, 34, 17, 19).is_documentation(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_documentation(&self) -> bool {\n+        matches!(self.octets(), [192, 0, 2, _] | [198, 51, 100, _] | [203, 0, 113, _])\n+    }\n+\n+    /// Converts this address to an [IPv4-compatible] [`IPv6` address].\n+    ///\n+    /// `a.b.c.d` becomes `::a.b.c.d`\n+    ///\n+    /// Note that IPv4-compatible addresses have been officially deprecated.\n+    /// If you don't explicitly need an IPv4-compatible address for legacy reasons, consider using `to_ipv6_mapped` instead.\n+    ///\n+    /// [IPv4-compatible]: Ipv6Addr#ipv4-compatible-ipv6-addresses\n+    /// [`IPv6` address]: Ipv6Addr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(\n+    ///     Ipv4Addr::new(192, 0, 2, 255).to_ipv6_compatible(),\n+    ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x2ff)\n+    /// );\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use = \"this returns the result of the operation, \\\n+                  without modifying the original\"]\n+    #[inline]\n+    pub const fn to_ipv6_compatible(&self) -> Ipv6Addr {\n+        let [a, b, c, d] = self.octets();\n+        Ipv6Addr { octets: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, b, c, d] }\n+    }\n+\n+    /// Converts this address to an [IPv4-mapped] [`IPv6` address].\n+    ///\n+    /// `a.b.c.d` becomes `::ffff:a.b.c.d`\n+    ///\n+    /// [IPv4-mapped]: Ipv6Addr#ipv4-mapped-ipv6-addresses\n+    /// [`IPv6` address]: Ipv6Addr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_mapped(),\n+    ///            Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x2ff));\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use = \"this returns the result of the operation, \\\n+                  without modifying the original\"]\n+    #[inline]\n+    pub const fn to_ipv6_mapped(&self) -> Ipv6Addr {\n+        let [a, b, c, d] = self.octets();\n+        Ipv6Addr { octets: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, a, b, c, d] }\n+    }\n+}\n+\n+#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+impl fmt::Display for IpAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            IpAddr::V4(ip) => ip.fmt(fmt),\n+            IpAddr::V6(ip) => ip.fmt(fmt),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+impl fmt::Debug for IpAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n+impl From<Ipv4Addr> for IpAddr {\n+    /// Copies this address to a new `IpAddr::V4`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr};\n+    ///\n+    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n+    ///\n+    /// assert_eq!(\n+    ///     IpAddr::V4(addr),\n+    ///     IpAddr::from(addr)\n+    /// )\n+    /// ```\n+    #[inline]\n+    fn from(ipv4: Ipv4Addr) -> IpAddr {\n+        IpAddr::V4(ipv4)\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n+impl From<Ipv6Addr> for IpAddr {\n+    /// Copies this address to a new `IpAddr::V6`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv6Addr};\n+    ///\n+    /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n+    ///\n+    /// assert_eq!(\n+    ///     IpAddr::V6(addr),\n+    ///     IpAddr::from(addr)\n+    /// );\n+    /// ```\n+    #[inline]\n+    fn from(ipv6: Ipv6Addr) -> IpAddr {\n+        IpAddr::V6(ipv6)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for Ipv4Addr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let octets = self.octets();\n+\n+        // If there are no alignment requirements, write the IP address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n+        if fmt.precision().is_none() && fmt.width().is_none() {\n+            write!(fmt, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3])\n+        } else {\n+            const LONGEST_IPV4_ADDR: &str = \"255.255.255.255\";\n+\n+            let mut buf = DisplayBuffer::<{ LONGEST_IPV4_ADDR.len() }>::new();\n+            // Buffer is long enough for the longest possible IPv4 address, so this should never fail.\n+            write!(buf, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3]).unwrap();\n+\n+            fmt.pad(buf.as_str())\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for Ipv4Addr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialEq<Ipv4Addr> for IpAddr {\n+    #[inline]\n+    fn eq(&self, other: &Ipv4Addr) -> bool {\n+        match self {\n+            IpAddr::V4(v4) => v4 == other,\n+            IpAddr::V6(_) => false,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialEq<IpAddr> for Ipv4Addr {\n+    #[inline]\n+    fn eq(&self, other: &IpAddr) -> bool {\n+        match other {\n+            IpAddr::V4(v4) => self == v4,\n+            IpAddr::V6(_) => false,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl PartialOrd for Ipv4Addr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialOrd<Ipv4Addr> for IpAddr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n+        match self {\n+            IpAddr::V4(v4) => v4.partial_cmp(other),\n+            IpAddr::V6(_) => Some(Ordering::Greater),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialOrd<IpAddr> for Ipv4Addr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &IpAddr) -> Option<Ordering> {\n+        match other {\n+            IpAddr::V4(v4) => self.partial_cmp(v4),\n+            IpAddr::V6(_) => Some(Ordering::Less),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Ord for Ipv4Addr {\n+    #[inline]\n+    fn cmp(&self, other: &Ipv4Addr) -> Ordering {\n+        self.octets.cmp(&other.octets)\n+    }\n+}\n+\n+#[stable(feature = \"ip_u32\", since = \"1.1.0\")]\n+impl From<Ipv4Addr> for u32 {\n+    /// Converts an `Ipv4Addr` into a host byte order `u32`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::new(0x12, 0x34, 0x56, 0x78);\n+    /// assert_eq!(0x12345678, u32::from(addr));\n+    /// ```\n+    #[inline]\n+    fn from(ip: Ipv4Addr) -> u32 {\n+        u32::from_be_bytes(ip.octets)\n+    }\n+}\n+\n+#[stable(feature = \"ip_u32\", since = \"1.1.0\")]\n+impl From<u32> for Ipv4Addr {\n+    /// Converts a host byte order `u32` into an `Ipv4Addr`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::from(0x12345678);\n+    /// assert_eq!(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78), addr);\n+    /// ```\n+    #[inline]\n+    fn from(ip: u32) -> Ipv4Addr {\n+        Ipv4Addr { octets: ip.to_be_bytes() }\n+    }\n+}\n+\n+#[stable(feature = \"from_slice_v4\", since = \"1.9.0\")]\n+impl From<[u8; 4]> for Ipv4Addr {\n+    /// Creates an `Ipv4Addr` from a four element byte array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::from([13u8, 12u8, 11u8, 10u8]);\n+    /// assert_eq!(Ipv4Addr::new(13, 12, 11, 10), addr);\n+    /// ```\n+    #[inline]\n+    fn from(octets: [u8; 4]) -> Ipv4Addr {\n+        Ipv4Addr { octets }\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n+impl From<[u8; 4]> for IpAddr {\n+    /// Creates an `IpAddr::V4` from a four element byte array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr};\n+    ///\n+    /// let addr = IpAddr::from([13u8, 12u8, 11u8, 10u8]);\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(13, 12, 11, 10)), addr);\n+    /// ```\n+    #[inline]\n+    fn from(octets: [u8; 4]) -> IpAddr {\n+        IpAddr::V4(Ipv4Addr::from(octets))\n+    }\n+}\n+\n+impl Ipv6Addr {\n+    /// Creates a new IPv6 address from eight 16-bit segments.\n+    ///\n+    /// The result will represent the IP address `a:b:c:d:e:f:g:h`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {\n+        let addr16 = [\n+            a.to_be(),\n+            b.to_be(),\n+            c.to_be(),\n+            d.to_be(),\n+            e.to_be(),\n+            f.to_be(),\n+            g.to_be(),\n+            h.to_be(),\n+        ];\n+        Ipv6Addr {\n+            // All elements in `addr16` are big endian.\n+            // SAFETY: `[u16; 8]` is always safe to transmute to `[u8; 16]`.\n+            octets: unsafe { transmute::<_, [u8; 16]>(addr16) },\n+        }\n+    }\n+\n+    /// An IPv6 address representing localhost: `::1`.\n+    ///\n+    /// This corresponds to constant `IN6ADDR_LOOPBACK_INIT` or `in6addr_loopback` in other\n+    /// languages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::LOCALHOST;\n+    /// assert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+    /// ```\n+    #[doc(alias = \"IN6ADDR_LOOPBACK_INIT\")]\n+    #[doc(alias = \"in6addr_loopback\")]\n+    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n+    pub const LOCALHOST: Self = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n+\n+    /// An IPv6 address representing the unspecified address: `::`\n+    ///\n+    /// This corresponds to constant `IN6ADDR_ANY_INIT` or `in6addr_any` in other languages.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::UNSPECIFIED;\n+    /// assert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n+    /// ```\n+    #[doc(alias = \"IN6ADDR_ANY_INIT\")]\n+    #[doc(alias = \"in6addr_any\")]\n+    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n+    pub const UNSPECIFIED: Self = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0);\n+\n+    /// Returns the eight 16-bit segments that make up this address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).segments(),\n+    ///            [0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff]);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn segments(&self) -> [u16; 8] {\n+        // All elements in `self.octets` must be big endian.\n+        // SAFETY: `[u8; 16]` is always safe to transmute to `[u16; 8]`.\n+        let [a, b, c, d, e, f, g, h] = unsafe { transmute::<_, [u16; 8]>(self.octets) };\n+        // We want native endian u16\n+        [\n+            u16::from_be(a),\n+            u16::from_be(b),\n+            u16::from_be(c),\n+            u16::from_be(d),\n+            u16::from_be(e),\n+            u16::from_be(f),\n+            u16::from_be(g),\n+            u16::from_be(h),\n+        ]\n+    }\n+\n+    /// Returns [`true`] for the special 'unspecified' address (`::`).\n+    ///\n+    /// This property is defined in [IETF RFC 4291].\n+    ///\n+    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unspecified(), false);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).is_unspecified(), true);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_unspecified(&self) -> bool {\n+        u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::UNSPECIFIED.octets())\n+    }\n+\n+    /// Returns [`true`] if this is the [loopback address] (`::1`),\n+    /// as defined in [IETF RFC 4291 section 2.5.3].\n+    ///\n+    /// Contrary to IPv4, in IPv6 there is only one loopback address.\n+    ///\n+    /// [loopback address]: Ipv6Addr::LOCALHOST\n+    /// [IETF RFC 4291 section 2.5.3]: https://tools.ietf.org/html/rfc4291#section-2.5.3\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_loopback(), false);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_loopback(), true);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_loopback(&self) -> bool {\n+        u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::LOCALHOST.octets())\n+    }\n+\n+    /// Returns [`true`] if the address appears to be globally reachable\n+    /// as specified by the [IANA IPv6 Special-Purpose Address Registry].\n+    /// Whether or not an address is practically reachable will depend on your network configuration.\n+    ///\n+    /// Most IPv6 addresses are globally reachable;\n+    /// unless they are specifically defined as *not* globally reachable.\n+    ///\n+    /// Non-exhaustive list of notable addresses that are not globally reachable:\n+    /// - The [unspecified address] ([`is_unspecified`](Ipv6Addr::is_unspecified))\n+    /// - The [loopback address] ([`is_loopback`](Ipv6Addr::is_loopback))\n+    /// - IPv4-mapped addresses\n+    /// - Addresses reserved for benchmarking\n+    /// - Addresses reserved for documentation ([`is_documentation`](Ipv6Addr::is_documentation))\n+    /// - Unique local addresses ([`is_unique_local`](Ipv6Addr::is_unique_local))\n+    /// - Unicast addresses with link-local scope ([`is_unicast_link_local`](Ipv6Addr::is_unicast_link_local))\n+    ///\n+    /// For the complete overview of which addresses are globally reachable, see the table at the [IANA IPv6 Special-Purpose Address Registry].\n+    ///\n+    /// Note that an address having global scope is not the same as being globally reachable,\n+    /// and there is no direct relation between the two concepts: There exist addresses with global scope\n+    /// that are not globally reachable (for example unique local addresses),\n+    /// and addresses that are globally reachable without having global scope\n+    /// (multicast addresses with non-global scope).\n+    ///\n+    /// [IANA IPv6 Special-Purpose Address Registry]: https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml\n+    /// [unspecified address]: Ipv6Addr::UNSPECIFIED\n+    /// [loopback address]: Ipv6Addr::LOCALHOST\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// // Most IPv6 addresses are globally reachable:\n+    /// assert_eq!(Ipv6Addr::new(0x26, 0, 0x1c9, 0, 0, 0xafc8, 0x10, 0x1).is_global(), true);\n+    ///\n+    /// // However some addresses have been assigned a special meaning\n+    /// // that makes them not globally reachable. Some examples are:\n+    ///\n+    /// // The unspecified address (`::`)\n+    /// assert_eq!(Ipv6Addr::UNSPECIFIED.is_global(), false);\n+    ///\n+    /// // The loopback address (`::1`)\n+    /// assert_eq!(Ipv6Addr::LOCALHOST.is_global(), false);\n+    ///\n+    /// // IPv4-mapped addresses (`::ffff:0:0/96`)\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), false);\n+    ///\n+    /// // Addresses reserved for benchmarking (`2001:2::/48`)\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 2, 0, 0, 0, 0, 0, 1,).is_global(), false);\n+    ///\n+    /// // Addresses reserved for documentation (`2001:db8::/32`)\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1).is_global(), false);\n+    ///\n+    /// // Unique local addresses (`fc00::/7`)\n+    /// assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 1).is_global(), false);\n+    ///\n+    /// // Unicast addresses with link-local scope (`fe80::/10`)\n+    /// assert_eq!(Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 1).is_global(), false);\n+    ///\n+    /// // For a complete overview see the IANA IPv6 Special-Purpose Address Registry.\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_global(&self) -> bool {\n+        !(self.is_unspecified()\n+            || self.is_loopback()\n+            // IPv4-mapped Address (`::ffff:0:0/96`)\n+            || matches!(self.segments(), [0, 0, 0, 0, 0, 0xffff, _, _])\n+            // IPv4-IPv6 Translat. (`64:ff9b:1::/48`)\n+            || matches!(self.segments(), [0x64, 0xff9b, 1, _, _, _, _, _])\n+            // Discard-Only Address Block (`100::/64`)\n+            || matches!(self.segments(), [0x100, 0, 0, 0, _, _, _, _])\n+            // IETF Protocol Assignments (`2001::/23`)\n+            || (matches!(self.segments(), [0x2001, b, _, _, _, _, _, _] if b < 0x200)\n+                && !(\n+                    // Port Control Protocol Anycast (`2001:1::1`)\n+                    u128::from_be_bytes(self.octets()) == 0x2001_0001_0000_0000_0000_0000_0000_0001\n+                    // Traversal Using Relays around NAT Anycast (`2001:1::2`)\n+                    || u128::from_be_bytes(self.octets()) == 0x2001_0001_0000_0000_0000_0000_0000_0002\n+                    // AMT (`2001:3::/32`)\n+                    || matches!(self.segments(), [0x2001, 3, _, _, _, _, _, _])\n+                    // AS112-v6 (`2001:4:112::/48`)\n+                    || matches!(self.segments(), [0x2001, 4, 0x112, _, _, _, _, _])\n+                    // ORCHIDv2 (`2001:20::/28`)\n+                    || matches!(self.segments(), [0x2001, b, _, _, _, _, _, _] if b >= 0x20 && b <= 0x2F)\n+                ))\n+            || self.is_documentation()\n+            || self.is_unique_local()\n+            || self.is_unicast_link_local())\n+    }\n+\n+    /// Returns [`true`] if this is a unique local address (`fc00::/7`).\n+    ///\n+    /// This property is defined in [IETF RFC 4193].\n+    ///\n+    /// [IETF RFC 4193]: https://tools.ietf.org/html/rfc4193\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unique_local(), false);\n+    /// assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 0).is_unique_local(), true);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_unique_local(&self) -> bool {\n+        (self.segments()[0] & 0xfe00) == 0xfc00\n+    }\n+\n+    /// Returns [`true`] if this is a unicast address, as defined by [IETF RFC 4291].\n+    /// Any address that is not a [multicast address] (`ff00::/8`) is unicast.\n+    ///\n+    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    /// [multicast address]: Ipv6Addr::is_multicast\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// // The unspecified and loopback addresses are unicast.\n+    /// assert_eq!(Ipv6Addr::UNSPECIFIED.is_unicast(), true);\n+    /// assert_eq!(Ipv6Addr::LOCALHOST.is_unicast(), true);\n+    ///\n+    /// // Any address that is not a multicast address (`ff00::/8`) is unicast.\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast(), true);\n+    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_unicast(), false);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_unicast(&self) -> bool {\n+        !self.is_multicast()\n+    }\n+\n+    /// Returns `true` if the address is a unicast address with link-local scope,\n+    /// as defined in [RFC 4291].\n+    ///\n+    /// A unicast address has link-local scope if it has the prefix `fe80::/10`, as per [RFC 4291 section 2.4].\n+    /// Note that this encompasses more addresses than those defined in [RFC 4291 section 2.5.6],\n+    /// which describes \"Link-Local IPv6 Unicast Addresses\" as having the following stricter format:\n+    ///\n+    /// ```text\n+    /// | 10 bits  |         54 bits         |          64 bits           |\n+    /// +----------+-------------------------+----------------------------+\n+    /// |1111111010|           0             |       interface ID         |\n+    /// +----------+-------------------------+----------------------------+\n+    /// ```\n+    /// So while currently the only addresses with link-local scope an application will encounter are all in `fe80::/64`,\n+    /// this might change in the future with the publication of new standards. More addresses in `fe80::/10` could be allocated,\n+    /// and those addresses will have link-local scope.\n+    ///\n+    /// Also note that while [RFC 4291 section 2.5.3] mentions about the [loopback address] (`::1`) that \"it is treated as having Link-Local scope\",\n+    /// this does not mean that the loopback address actually has link-local scope and this method will return `false` on it.\n+    ///\n+    /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    /// [RFC 4291 section 2.4]: https://tools.ietf.org/html/rfc4291#section-2.4\n+    /// [RFC 4291 section 2.5.3]: https://tools.ietf.org/html/rfc4291#section-2.5.3\n+    /// [RFC 4291 section 2.5.6]: https://tools.ietf.org/html/rfc4291#section-2.5.6\n+    /// [loopback address]: Ipv6Addr::LOCALHOST\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// // The loopback address (`::1`) does not actually have link-local scope.\n+    /// assert_eq!(Ipv6Addr::LOCALHOST.is_unicast_link_local(), false);\n+    ///\n+    /// // Only addresses in `fe80::/10` have link-local scope.\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), false);\n+    /// assert_eq!(Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), true);\n+    ///\n+    /// // Addresses outside the stricter `fe80::/64` also have link-local scope.\n+    /// assert_eq!(Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0).is_unicast_link_local(), true);\n+    /// assert_eq!(Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), true);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_unicast_link_local(&self) -> bool {\n+        (self.segments()[0] & 0xffc0) == 0xfe80\n+    }\n+\n+    /// Returns [`true`] if this is an address reserved for documentation\n+    /// (`2001:db8::/32`).\n+    ///\n+    /// This property is defined in [IETF RFC 3849].\n+    ///\n+    /// [IETF RFC 3849]: https://tools.ietf.org/html/rfc3849\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_documentation(), false);\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_documentation(), true);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_documentation(&self) -> bool {\n+        (self.segments()[0] == 0x2001) && (self.segments()[1] == 0xdb8)\n+    }\n+\n+    /// Returns [`true`] if this is an address reserved for benchmarking (`2001:2::/48`).\n+    ///\n+    /// This property is defined in [IETF RFC 5180], where it is mistakenly specified as covering the range `2001:0200::/48`.\n+    /// This is corrected in [IETF RFC Errata 1752] to `2001:0002::/48`.\n+    ///\n+    /// [IETF RFC 5180]: https://tools.ietf.org/html/rfc5180\n+    /// [IETF RFC Errata 1752]: https://www.rfc-editor.org/errata_search.php?eid=1752\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc613, 0x0).is_benchmarking(), false);\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0x2, 0, 0, 0, 0, 0, 0).is_benchmarking(), true);\n+    /// ```\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_benchmarking(&self) -> bool {\n+        (self.segments()[0] == 0x2001) && (self.segments()[1] == 0x2) && (self.segments()[2] == 0)\n+    }\n+\n+    /// Returns [`true`] if the address is a globally routable unicast address.\n+    ///\n+    /// The following return false:\n+    ///\n+    /// - the loopback address\n+    /// - the link-local addresses\n+    /// - unique local addresses\n+    /// - the unspecified address\n+    /// - the address range reserved for documentation\n+    ///\n+    /// This method returns [`true`] for site-local addresses as per [RFC 4291 section 2.5.7]\n+    ///\n+    /// ```no_rust\n+    /// The special behavior of [the site-local unicast] prefix defined in [RFC3513] must no longer\n+    /// be supported in new implementations (i.e., new implementations must treat this prefix as\n+    /// Global Unicast).\n+    /// ```\n+    ///\n+    /// [RFC 4291 section 2.5.7]: https://tools.ietf.org/html/rfc4291#section-2.5.7\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_global(), false);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_global(), true);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_unicast_global(&self) -> bool {\n+        self.is_unicast()\n+            && !self.is_loopback()\n+            && !self.is_unicast_link_local()\n+            && !self.is_unique_local()\n+            && !self.is_unspecified()\n+            && !self.is_documentation()\n+            && !self.is_benchmarking()\n+    }\n+\n+    /// Returns the address's multicast scope if the address is multicast.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::{Ipv6Addr, Ipv6MulticastScope};\n+    ///\n+    /// assert_eq!(\n+    ///     Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0).multicast_scope(),\n+    ///     Some(Ipv6MulticastScope::Global)\n+    /// );\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).multicast_scope(), None);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn multicast_scope(&self) -> Option<Ipv6MulticastScope> {\n+        if self.is_multicast() {\n+            match self.segments()[0] & 0x000f {\n+                1 => Some(Ipv6MulticastScope::InterfaceLocal),\n+                2 => Some(Ipv6MulticastScope::LinkLocal),\n+                3 => Some(Ipv6MulticastScope::RealmLocal),\n+                4 => Some(Ipv6MulticastScope::AdminLocal),\n+                5 => Some(Ipv6MulticastScope::SiteLocal),\n+                8 => Some(Ipv6MulticastScope::OrganizationLocal),\n+                14 => Some(Ipv6MulticastScope::Global),\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns [`true`] if this is a multicast address (`ff00::/8`).\n+    ///\n+    /// This property is defined by [IETF RFC 4291].\n+    ///\n+    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_multicast(), true);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_multicast(), false);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn is_multicast(&self) -> bool {\n+        (self.segments()[0] & 0xff00) == 0xff00\n+    }\n+\n+    /// Converts this address to an [`IPv4` address] if it's an [IPv4-mapped] address,\n+    /// as defined in [IETF RFC 4291 section 2.5.5.2], otherwise returns [`None`].\n+    ///\n+    /// `::ffff:a.b.c.d` becomes `a.b.c.d`.\n+    /// All addresses *not* starting with `::ffff` will return `None`.\n+    ///\n+    /// [`IPv4` address]: Ipv4Addr\n+    /// [IPv4-mapped]: Ipv6Addr\n+    /// [IETF RFC 4291 section 2.5.5.2]: https://tools.ietf.org/html/rfc4291#section-2.5.5.2\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4_mapped(), None);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4_mapped(),\n+    ///            Some(Ipv4Addr::new(192, 10, 2, 255)));\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4_mapped(), None);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[stable(feature = \"ipv6_to_ipv4_mapped\", since = \"1.63.0\")]\n+    #[must_use = \"this returns the result of the operation, \\\n+                  without modifying the original\"]\n+    #[inline]\n+    pub const fn to_ipv4_mapped(&self) -> Option<Ipv4Addr> {\n+        match self.octets() {\n+            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, a, b, c, d] => {\n+                Some(Ipv4Addr::new(a, b, c, d))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// Converts this address to an [`IPv4` address] if it is either\n+    /// an [IPv4-compatible] address as defined in [IETF RFC 4291 section 2.5.5.1],\n+    /// or an [IPv4-mapped] address as defined in [IETF RFC 4291 section 2.5.5.2],\n+    /// otherwise returns [`None`].\n+    ///\n+    /// Note that this will return an [`IPv4` address] for the IPv6 loopback address `::1`. Use\n+    /// [`Ipv6Addr::to_ipv4_mapped`] to avoid this.\n+    ///\n+    /// `::a.b.c.d` and `::ffff:a.b.c.d` become `a.b.c.d`. `::1` becomes `0.0.0.1`.\n+    /// All addresses *not* starting with either all zeroes or `::ffff` will return `None`.\n+    ///\n+    /// [`IPv4` address]: Ipv4Addr\n+    /// [IPv4-compatible]: Ipv6Addr#ipv4-compatible-ipv6-addresses\n+    /// [IPv4-mapped]: Ipv6Addr#ipv4-mapped-ipv6-addresses\n+    /// [IETF RFC 4291 section 2.5.5.1]: https://tools.ietf.org/html/rfc4291#section-2.5.5.1\n+    /// [IETF RFC 4291 section 2.5.5.2]: https://tools.ietf.org/html/rfc4291#section-2.5.5.2\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4(), None);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4(),\n+    ///            Some(Ipv4Addr::new(192, 10, 2, 255)));\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4(),\n+    ///            Some(Ipv4Addr::new(0, 0, 0, 1)));\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use = \"this returns the result of the operation, \\\n+                  without modifying the original\"]\n+    #[inline]\n+    pub const fn to_ipv4(&self) -> Option<Ipv4Addr> {\n+        if let [0, 0, 0, 0, 0, 0 | 0xffff, ab, cd] = self.segments() {\n+            let [a, b] = ab.to_be_bytes();\n+            let [c, d] = cd.to_be_bytes();\n+            Some(Ipv4Addr::new(a, b, c, d))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Converts this address to an `IpAddr::V4` if it is an IPv4-mapped addresses, otherwise it\n+    /// returns self wrapped in an `IpAddr::V6`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1).is_loopback(), false);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1).to_canonical().is_loopback(), true);\n+    /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    #[unstable(feature = \"ip\", issue = \"27709\")]\n+    #[must_use = \"this returns the result of the operation, \\\n+                  without modifying the original\"]\n+    #[inline]\n+    pub const fn to_canonical(&self) -> IpAddr {\n+        if let Some(mapped) = self.to_ipv4_mapped() {\n+            return IpAddr::V4(mapped);\n+        }\n+        IpAddr::V6(*self)\n+    }\n+\n+    /// Returns the sixteen eight-bit integers the IPv6 address consists of.\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).octets(),\n+    ///            [255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n+    /// ```\n+    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n+    #[stable(feature = \"ipv6_to_octets\", since = \"1.12.0\")]\n+    #[must_use]\n+    #[inline]\n+    pub const fn octets(&self) -> [u8; 16] {\n+        self.octets\n+    }\n+}\n+\n+/// Write an Ipv6Addr, conforming to the canonical style described by\n+/// [RFC 5952](https://tools.ietf.org/html/rfc5952).\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for Ipv6Addr {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // If there are no alignment requirements, write the IP address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n+        if f.precision().is_none() && f.width().is_none() {\n+            let segments = self.segments();\n+\n+            // Special case for :: and ::1; otherwise they get written with the\n+            // IPv4 formatter\n+            if self.is_unspecified() {\n+                f.write_str(\"::\")\n+            } else if self.is_loopback() {\n+                f.write_str(\"::1\")\n+            } else if let Some(ipv4) = self.to_ipv4() {\n+                match segments[5] {\n+                    // IPv4 Compatible address\n+                    0 => write!(f, \"::{}\", ipv4),\n+                    // IPv4 Mapped address\n+                    0xffff => write!(f, \"::ffff:{}\", ipv4),\n+                    _ => unreachable!(),\n+                }\n+            } else {\n+                #[derive(Copy, Clone, Default)]\n+                struct Span {\n+                    start: usize,\n+                    len: usize,\n+                }\n+\n+                // Find the inner 0 span\n+                let zeroes = {\n+                    let mut longest = Span::default();\n+                    let mut current = Span::default();\n+\n+                    for (i, &segment) in segments.iter().enumerate() {\n+                        if segment == 0 {\n+                            if current.len == 0 {\n+                                current.start = i;\n+                            }\n+\n+                            current.len += 1;\n+\n+                            if current.len > longest.len {\n+                                longest = current;\n+                            }\n+                        } else {\n+                            current = Span::default();\n+                        }\n+                    }\n+\n+                    longest\n+                };\n+\n+                /// Write a colon-separated part of the address\n+                #[inline]\n+                fn fmt_subslice(f: &mut fmt::Formatter<'_>, chunk: &[u16]) -> fmt::Result {\n+                    if let Some((first, tail)) = chunk.split_first() {\n+                        write!(f, \"{:x}\", first)?;\n+                        for segment in tail {\n+                            f.write_char(':')?;\n+                            write!(f, \"{:x}\", segment)?;\n+                        }\n+                    }\n+                    Ok(())\n+                }\n+\n+                if zeroes.len > 1 {\n+                    fmt_subslice(f, &segments[..zeroes.start])?;\n+                    f.write_str(\"::\")?;\n+                    fmt_subslice(f, &segments[zeroes.start + zeroes.len..])\n+                } else {\n+                    fmt_subslice(f, &segments)\n+                }\n+            }\n+        } else {\n+            const LONGEST_IPV6_ADDR: &str = \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\";\n+\n+            let mut buf = DisplayBuffer::<{ LONGEST_IPV6_ADDR.len() }>::new();\n+            // Buffer is long enough for the longest possible IPv6 address, so this should never fail.\n+            write!(buf, \"{}\", self).unwrap();\n+\n+            f.pad(buf.as_str())\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for Ipv6Addr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialEq<IpAddr> for Ipv6Addr {\n+    #[inline]\n+    fn eq(&self, other: &IpAddr) -> bool {\n+        match other {\n+            IpAddr::V4(_) => false,\n+            IpAddr::V6(v6) => self == v6,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialEq<Ipv6Addr> for IpAddr {\n+    #[inline]\n+    fn eq(&self, other: &Ipv6Addr) -> bool {\n+        match self {\n+            IpAddr::V4(_) => false,\n+            IpAddr::V6(v6) => v6 == other,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl PartialOrd for Ipv6Addr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialOrd<Ipv6Addr> for IpAddr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n+        match self {\n+            IpAddr::V4(_) => Some(Ordering::Less),\n+            IpAddr::V6(v6) => v6.partial_cmp(other),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n+impl PartialOrd<IpAddr> for Ipv6Addr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &IpAddr) -> Option<Ordering> {\n+        match other {\n+            IpAddr::V4(_) => Some(Ordering::Greater),\n+            IpAddr::V6(v6) => self.partial_cmp(v6),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Ord for Ipv6Addr {\n+    #[inline]\n+    fn cmp(&self, other: &Ipv6Addr) -> Ordering {\n+        self.segments().cmp(&other.segments())\n+    }\n+}\n+\n+#[stable(feature = \"i128\", since = \"1.26.0\")]\n+impl From<Ipv6Addr> for u128 {\n+    /// Convert an `Ipv6Addr` into a host byte order `u128`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::new(\n+    ///     0x1020, 0x3040, 0x5060, 0x7080,\n+    ///     0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n+    /// );\n+    /// assert_eq!(0x102030405060708090A0B0C0D0E0F00D_u128, u128::from(addr));\n+    /// ```\n+    #[inline]\n+    fn from(ip: Ipv6Addr) -> u128 {\n+        u128::from_be_bytes(ip.octets)\n+    }\n+}\n+#[stable(feature = \"i128\", since = \"1.26.0\")]\n+impl From<u128> for Ipv6Addr {\n+    /// Convert a host byte order `u128` into an `Ipv6Addr`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::from(0x102030405060708090A0B0C0D0E0F00D_u128);\n+    /// assert_eq!(\n+    ///     Ipv6Addr::new(\n+    ///         0x1020, 0x3040, 0x5060, 0x7080,\n+    ///         0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n+    ///     ),\n+    ///     addr);\n+    /// ```\n+    #[inline]\n+    fn from(ip: u128) -> Ipv6Addr {\n+        Ipv6Addr::from(ip.to_be_bytes())\n+    }\n+}\n+\n+#[stable(feature = \"ipv6_from_octets\", since = \"1.9.0\")]\n+impl From<[u8; 16]> for Ipv6Addr {\n+    /// Creates an `Ipv6Addr` from a sixteen element byte array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::from([\n+    ///     25u8, 24u8, 23u8, 22u8, 21u8, 20u8, 19u8, 18u8,\n+    ///     17u8, 16u8, 15u8, 14u8, 13u8, 12u8, 11u8, 10u8,\n+    /// ]);\n+    /// assert_eq!(\n+    ///     Ipv6Addr::new(\n+    ///         0x1918, 0x1716,\n+    ///         0x1514, 0x1312,\n+    ///         0x1110, 0x0f0e,\n+    ///         0x0d0c, 0x0b0a\n+    ///     ),\n+    ///     addr\n+    /// );\n+    /// ```\n+    #[inline]\n+    fn from(octets: [u8; 16]) -> Ipv6Addr {\n+        Ipv6Addr { octets }\n+    }\n+}\n+\n+#[stable(feature = \"ipv6_from_segments\", since = \"1.16.0\")]\n+impl From<[u16; 8]> for Ipv6Addr {\n+    /// Creates an `Ipv6Addr` from an eight element 16-bit array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let addr = Ipv6Addr::from([\n+    ///     525u16, 524u16, 523u16, 522u16,\n+    ///     521u16, 520u16, 519u16, 518u16,\n+    /// ]);\n+    /// assert_eq!(\n+    ///     Ipv6Addr::new(\n+    ///         0x20d, 0x20c,\n+    ///         0x20b, 0x20a,\n+    ///         0x209, 0x208,\n+    ///         0x207, 0x206\n+    ///     ),\n+    ///     addr\n+    /// );\n+    /// ```\n+    #[inline]\n+    fn from(segments: [u16; 8]) -> Ipv6Addr {\n+        let [a, b, c, d, e, f, g, h] = segments;\n+        Ipv6Addr::new(a, b, c, d, e, f, g, h)\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n+impl From<[u8; 16]> for IpAddr {\n+    /// Creates an `IpAddr::V6` from a sixteen element byte array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv6Addr};\n+    ///\n+    /// let addr = IpAddr::from([\n+    ///     25u8, 24u8, 23u8, 22u8, 21u8, 20u8, 19u8, 18u8,\n+    ///     17u8, 16u8, 15u8, 14u8, 13u8, 12u8, 11u8, 10u8,\n+    /// ]);\n+    /// assert_eq!(\n+    ///     IpAddr::V6(Ipv6Addr::new(\n+    ///         0x1918, 0x1716,\n+    ///         0x1514, 0x1312,\n+    ///         0x1110, 0x0f0e,\n+    ///         0x0d0c, 0x0b0a\n+    ///     )),\n+    ///     addr\n+    /// );\n+    /// ```\n+    #[inline]\n+    fn from(octets: [u8; 16]) -> IpAddr {\n+        IpAddr::V6(Ipv6Addr::from(octets))\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n+impl From<[u16; 8]> for IpAddr {\n+    /// Creates an `IpAddr::V6` from an eight element 16-bit array.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv6Addr};\n+    ///\n+    /// let addr = IpAddr::from([\n+    ///     525u16, 524u16, 523u16, 522u16,\n+    ///     521u16, 520u16, 519u16, 518u16,\n+    /// ]);\n+    /// assert_eq!(\n+    ///     IpAddr::V6(Ipv6Addr::new(\n+    ///         0x20d, 0x20c,\n+    ///         0x20b, 0x20a,\n+    ///         0x209, 0x208,\n+    ///         0x207, 0x206\n+    ///     )),\n+    ///     addr\n+    /// );\n+    /// ```\n+    #[inline]\n+    fn from(segments: [u16; 8]) -> IpAddr {\n+        IpAddr::V6(Ipv6Addr::from(segments))\n+    }\n+}"}, {"sha": "31f5f5d3c223b14b04705b954048e97a6608b818", "filename": "library/core/src/net/mod.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnet%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -0,0 +1,24 @@\n+//! Networking primitives for IP communication.\n+//!\n+//! This module provides types for IP and socket addresses.\n+//!\n+//! # Organization\n+//!\n+//! * [`IpAddr`] represents IP addresses of either IPv4 or IPv6; [`Ipv4Addr`] and\n+//!   [`Ipv6Addr`] are respectively IPv4 and IPv6 addresses\n+//! * [`SocketAddr`] represents socket addresses of either IPv4 or IPv6; [`SocketAddrV4`]\n+//!   and [`SocketAddrV6`] are respectively IPv4 and IPv6 socket addresses\n+\n+#![unstable(feature = \"ip_in_core\", issue = \"108443\")]\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::ip_addr::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::parser::AddrParseError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::socket_addr::{SocketAddr, SocketAddrV4, SocketAddrV6};\n+\n+mod display_buffer;\n+mod ip_addr;\n+mod parser;\n+mod socket_addr;"}, {"sha": "a08d2792d0456ed6a2dcd8dddf6cddbf46ea9a19", "filename": "library/core/src/net/parser.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnet%2Fparser.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -3,9 +3,7 @@\n //! This module is \"publicly exported\" through the `FromStr` implementations\n //! below.\n \n-#[cfg(test)]\n-mod tests;\n-\n+use crate::convert::TryInto;\n use crate::error::Error;\n use crate::fmt;\n use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};", "previous_filename": "library/std/src/net/parser.rs"}, {"sha": "0d25ab1d5e1a4f34325665ce16765c7207d21716", "filename": "library/core/src/net/socket_addr.rs", "status": "added", "additions": 664, "deletions": 0, "changes": 664, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fnet%2Fsocket_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fnet%2Fsocket_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnet%2Fsocket_addr.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -0,0 +1,664 @@\n+use crate::cmp::Ordering;\n+use crate::fmt::{self, Write};\n+use crate::hash;\n+use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+\n+use super::display_buffer::DisplayBuffer;\n+\n+/// An internet socket address, either IPv4 or IPv6.\n+///\n+/// Internet socket addresses consist of an [IP address], a 16-bit port number, as well\n+/// as possibly some version-dependent additional information. See [`SocketAddrV4`]'s and\n+/// [`SocketAddrV6`]'s respective documentation for more details.\n+///\n+/// The size of a `SocketAddr` instance may vary depending on the target operating\n+/// system.\n+///\n+/// [IP address]: IpAddr\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+///\n+/// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+///\n+/// assert_eq!(\"127.0.0.1:8080\".parse(), Ok(socket));\n+/// assert_eq!(socket.port(), 8080);\n+/// assert_eq!(socket.is_ipv4(), true);\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum SocketAddr {\n+    /// An IPv4 socket address.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    V4(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV4),\n+    /// An IPv6 socket address.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    V6(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV6),\n+}\n+\n+/// An IPv4 socket address.\n+///\n+/// IPv4 socket addresses consist of an [`IPv4` address] and a 16-bit port number, as\n+/// stated in [IETF RFC 793].\n+///\n+/// See [`SocketAddr`] for a type encompassing both IPv4 and IPv6 socket addresses.\n+///\n+/// The size of a `SocketAddrV4` struct may vary depending on the target operating\n+/// system. Do not assume that this type has the same memory layout as the underlying\n+/// system representation.\n+///\n+/// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n+/// [`IPv4` address]: Ipv4Addr\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::{Ipv4Addr, SocketAddrV4};\n+///\n+/// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+///\n+/// assert_eq!(\"127.0.0.1:8080\".parse(), Ok(socket));\n+/// assert_eq!(socket.ip(), &Ipv4Addr::new(127, 0, 0, 1));\n+/// assert_eq!(socket.port(), 8080);\n+/// ```\n+#[derive(Copy, Clone, Eq, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct SocketAddrV4 {\n+    ip: Ipv4Addr,\n+    port: u16,\n+}\n+\n+/// An IPv6 socket address.\n+///\n+/// IPv6 socket addresses consist of an [`IPv6` address], a 16-bit port number, as well\n+/// as fields containing the traffic class, the flow label, and a scope identifier\n+/// (see [IETF RFC 2553, Section 3.3] for more details).\n+///\n+/// See [`SocketAddr`] for a type encompassing both IPv4 and IPv6 socket addresses.\n+///\n+/// The size of a `SocketAddrV6` struct may vary depending on the target operating\n+/// system. Do not assume that this type has the same memory layout as the underlying\n+/// system representation.\n+///\n+/// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n+/// [`IPv6` address]: Ipv6Addr\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::net::{Ipv6Addr, SocketAddrV6};\n+///\n+/// let socket = SocketAddrV6::new(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+///\n+/// assert_eq!(\"[2001:db8::1]:8080\".parse(), Ok(socket));\n+/// assert_eq!(socket.ip(), &Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1));\n+/// assert_eq!(socket.port(), 8080);\n+/// ```\n+#[derive(Copy, Clone, Eq, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct SocketAddrV6 {\n+    ip: Ipv6Addr,\n+    port: u16,\n+    flowinfo: u32,\n+    scope_id: u32,\n+}\n+\n+impl SocketAddr {\n+    /// Creates a new socket address from an [IP address] and a port number.\n+    ///\n+    /// [IP address]: IpAddr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n+    /// assert_eq!(socket.port(), 8080);\n+    /// ```\n+    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+    #[must_use]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn new(ip: IpAddr, port: u16) -> SocketAddr {\n+        match ip {\n+            IpAddr::V4(a) => SocketAddr::V4(SocketAddrV4::new(a, port)),\n+            IpAddr::V6(a) => SocketAddr::V6(SocketAddrV6::new(a, port, 0, 0)),\n+        }\n+    }\n+\n+    /// Returns the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn ip(&self) -> IpAddr {\n+        match *self {\n+            SocketAddr::V4(ref a) => IpAddr::V4(*a.ip()),\n+            SocketAddr::V6(ref a) => IpAddr::V6(*a.ip()),\n+        }\n+    }\n+\n+    /// Changes the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// socket.set_ip(IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n+    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_ip(&mut self, new_ip: IpAddr) {\n+        // `match (*self, new_ip)` would have us mutate a copy of self only to throw it away.\n+        match (self, new_ip) {\n+            (&mut SocketAddr::V4(ref mut a), IpAddr::V4(new_ip)) => a.set_ip(new_ip),\n+            (&mut SocketAddr::V6(ref mut a), IpAddr::V6(new_ip)) => a.set_ip(new_ip),\n+            (self_, new_ip) => *self_ = Self::new(new_ip, self_.port()),\n+        }\n+    }\n+\n+    /// Returns the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.port(), 8080);\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn port(&self) -> u16 {\n+        match *self {\n+            SocketAddr::V4(ref a) => a.port(),\n+            SocketAddr::V6(ref a) => a.port(),\n+        }\n+    }\n+\n+    /// Changes the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// socket.set_port(1025);\n+    /// assert_eq!(socket.port(), 1025);\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_port(&mut self, new_port: u16) {\n+        match *self {\n+            SocketAddr::V4(ref mut a) => a.set_port(new_port),\n+            SocketAddr::V6(ref mut a) => a.set_port(new_port),\n+        }\n+    }\n+\n+    /// Returns [`true`] if the [IP address] in this `SocketAddr` is an\n+    /// [`IPv4` address], and [`false`] otherwise.\n+    ///\n+    /// [IP address]: IpAddr\n+    /// [`IPv4` address]: IpAddr::V4\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.is_ipv4(), true);\n+    /// assert_eq!(socket.is_ipv6(), false);\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn is_ipv4(&self) -> bool {\n+        matches!(*self, SocketAddr::V4(_))\n+    }\n+\n+    /// Returns [`true`] if the [IP address] in this `SocketAddr` is an\n+    /// [`IPv6` address], and [`false`] otherwise.\n+    ///\n+    /// [IP address]: IpAddr\n+    /// [`IPv6` address]: IpAddr::V6\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv6Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 0, 1)), 8080);\n+    /// assert_eq!(socket.is_ipv4(), false);\n+    /// assert_eq!(socket.is_ipv6(), true);\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn is_ipv6(&self) -> bool {\n+        matches!(*self, SocketAddr::V6(_))\n+    }\n+}\n+\n+impl SocketAddrV4 {\n+    /// Creates a new socket address from an [`IPv4` address] and a port number.\n+    ///\n+    /// [`IPv4` address]: Ipv4Addr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV4, Ipv4Addr};\n+    ///\n+    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4 {\n+        SocketAddrV4 { ip, port }\n+    }\n+\n+    /// Returns the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV4, Ipv4Addr};\n+    ///\n+    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+    /// assert_eq!(socket.ip(), &Ipv4Addr::new(127, 0, 0, 1));\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn ip(&self) -> &Ipv4Addr {\n+        &self.ip\n+    }\n+\n+    /// Changes the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV4, Ipv4Addr};\n+    ///\n+    /// let mut socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+    /// socket.set_ip(Ipv4Addr::new(192, 168, 0, 1));\n+    /// assert_eq!(socket.ip(), &Ipv4Addr::new(192, 168, 0, 1));\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_ip(&mut self, new_ip: Ipv4Addr) {\n+        self.ip = new_ip;\n+    }\n+\n+    /// Returns the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV4, Ipv4Addr};\n+    ///\n+    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+    /// assert_eq!(socket.port(), 8080);\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn port(&self) -> u16 {\n+        self.port\n+    }\n+\n+    /// Changes the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV4, Ipv4Addr};\n+    ///\n+    /// let mut socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+    /// socket.set_port(4242);\n+    /// assert_eq!(socket.port(), 4242);\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_port(&mut self, new_port: u16) {\n+        self.port = new_port;\n+    }\n+}\n+\n+impl SocketAddrV6 {\n+    /// Creates a new socket address from an [`IPv6` address], a 16-bit port number,\n+    /// and the `flowinfo` and `scope_id` fields.\n+    ///\n+    /// For more information on the meaning and layout of the `flowinfo` and `scope_id`\n+    /// parameters, see [IETF RFC 2553, Section 3.3].\n+    ///\n+    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n+    /// [`IPv6` address]: Ipv6Addr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddrV6 {\n+        SocketAddrV6 { ip, port, flowinfo, scope_id }\n+    }\n+\n+    /// Returns the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+    /// assert_eq!(socket.ip(), &Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn ip(&self) -> &Ipv6Addr {\n+        &self.ip\n+    }\n+\n+    /// Changes the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+    /// socket.set_ip(Ipv6Addr::new(76, 45, 0, 0, 0, 0, 0, 0));\n+    /// assert_eq!(socket.ip(), &Ipv6Addr::new(76, 45, 0, 0, 0, 0, 0, 0));\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_ip(&mut self, new_ip: Ipv6Addr) {\n+        self.ip = new_ip;\n+    }\n+\n+    /// Returns the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+    /// assert_eq!(socket.port(), 8080);\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn port(&self) -> u16 {\n+        self.port\n+    }\n+\n+    /// Changes the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+    /// socket.set_port(4242);\n+    /// assert_eq!(socket.port(), 4242);\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_port(&mut self, new_port: u16) {\n+        self.port = new_port;\n+    }\n+\n+    /// Returns the flow information associated with this address.\n+    ///\n+    /// This information corresponds to the `sin6_flowinfo` field in C's `netinet/in.h`,\n+    /// as specified in [IETF RFC 2553, Section 3.3].\n+    /// It combines information about the flow label and the traffic class as specified\n+    /// in [IETF RFC 2460], respectively [Section 6] and [Section 7].\n+    ///\n+    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n+    /// [IETF RFC 2460]: https://tools.ietf.org/html/rfc2460\n+    /// [Section 6]: https://tools.ietf.org/html/rfc2460#section-6\n+    /// [Section 7]: https://tools.ietf.org/html/rfc2460#section-7\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 10, 0);\n+    /// assert_eq!(socket.flowinfo(), 10);\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn flowinfo(&self) -> u32 {\n+        self.flowinfo\n+    }\n+\n+    /// Changes the flow information associated with this socket address.\n+    ///\n+    /// See [`SocketAddrV6::flowinfo`]'s documentation for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 10, 0);\n+    /// socket.set_flowinfo(56);\n+    /// assert_eq!(socket.flowinfo(), 56);\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_flowinfo(&mut self, new_flowinfo: u32) {\n+        self.flowinfo = new_flowinfo;\n+    }\n+\n+    /// Returns the scope ID associated with this address.\n+    ///\n+    /// This information corresponds to the `sin6_scope_id` field in C's `netinet/in.h`,\n+    /// as specified in [IETF RFC 2553, Section 3.3].\n+    ///\n+    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 78);\n+    /// assert_eq!(socket.scope_id(), 78);\n+    /// ```\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n+    pub const fn scope_id(&self) -> u32 {\n+        self.scope_id\n+    }\n+\n+    /// Changes the scope ID associated with this socket address.\n+    ///\n+    /// See [`SocketAddrV6::scope_id`]'s documentation for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{SocketAddrV6, Ipv6Addr};\n+    ///\n+    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 78);\n+    /// socket.set_scope_id(42);\n+    /// assert_eq!(socket.scope_id(), 42);\n+    /// ```\n+    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n+    pub fn set_scope_id(&mut self, new_scope_id: u32) {\n+        self.scope_id = new_scope_id;\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n+impl From<SocketAddrV4> for SocketAddr {\n+    /// Converts a [`SocketAddrV4`] into a [`SocketAddr::V4`].\n+    fn from(sock4: SocketAddrV4) -> SocketAddr {\n+        SocketAddr::V4(sock4)\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n+impl From<SocketAddrV6> for SocketAddr {\n+    /// Converts a [`SocketAddrV6`] into a [`SocketAddr::V6`].\n+    fn from(sock6: SocketAddrV6) -> SocketAddr {\n+        SocketAddr::V6(sock6)\n+    }\n+}\n+\n+#[stable(feature = \"addr_from_into_ip\", since = \"1.17.0\")]\n+impl<I: Into<IpAddr>> From<(I, u16)> for SocketAddr {\n+    /// Converts a tuple struct (Into<[`IpAddr`]>, `u16`) into a [`SocketAddr`].\n+    ///\n+    /// This conversion creates a [`SocketAddr::V4`] for an [`IpAddr::V4`]\n+    /// and creates a [`SocketAddr::V6`] for an [`IpAddr::V6`].\n+    ///\n+    /// `u16` is treated as port of the newly created [`SocketAddr`].\n+    fn from(pieces: (I, u16)) -> SocketAddr {\n+        SocketAddr::new(pieces.0.into(), pieces.1)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for SocketAddr {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            SocketAddr::V4(ref a) => a.fmt(f),\n+            SocketAddr::V6(ref a) => a.fmt(f),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for SocketAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for SocketAddrV4 {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // If there are no alignment requirements, write the socket address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n+        if f.precision().is_none() && f.width().is_none() {\n+            write!(f, \"{}:{}\", self.ip(), self.port())\n+        } else {\n+            const LONGEST_IPV4_SOCKET_ADDR: &str = \"255.255.255.255:65536\";\n+\n+            let mut buf = DisplayBuffer::<{ LONGEST_IPV4_SOCKET_ADDR.len() }>::new();\n+            // Buffer is long enough for the longest possible IPv4 socket address, so this should never fail.\n+            write!(buf, \"{}:{}\", self.ip(), self.port()).unwrap();\n+\n+            f.pad(buf.as_str())\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for SocketAddrV4 {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for SocketAddrV6 {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // If there are no alignment requirements, write the socket address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n+        if f.precision().is_none() && f.width().is_none() {\n+            match self.scope_id() {\n+                0 => write!(f, \"[{}]:{}\", self.ip(), self.port()),\n+                scope_id => write!(f, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n+            }\n+        } else {\n+            const LONGEST_IPV6_SOCKET_ADDR: &str =\n+                \"[ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff%4294967296]:65536\";\n+\n+            let mut buf = DisplayBuffer::<{ LONGEST_IPV6_SOCKET_ADDR.len() }>::new();\n+            match self.scope_id() {\n+                0 => write!(buf, \"[{}]:{}\", self.ip(), self.port()),\n+                scope_id => write!(buf, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n+            }\n+            // Buffer is long enough for the longest possible IPv6 socket address, so this should never fail.\n+            .unwrap();\n+\n+            f.pad(buf.as_str())\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for SocketAddrV6 {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n+impl PartialOrd for SocketAddrV4 {\n+    fn partial_cmp(&self, other: &SocketAddrV4) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n+impl PartialOrd for SocketAddrV6 {\n+    fn partial_cmp(&self, other: &SocketAddrV6) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n+impl Ord for SocketAddrV4 {\n+    fn cmp(&self, other: &SocketAddrV4) -> Ordering {\n+        self.ip().cmp(other.ip()).then(self.port().cmp(&other.port()))\n+    }\n+}\n+\n+#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n+impl Ord for SocketAddrV6 {\n+    fn cmp(&self, other: &SocketAddrV6) -> Ordering {\n+        self.ip().cmp(other.ip()).then(self.port().cmp(&other.port()))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl hash::Hash for SocketAddrV4 {\n+    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n+        (self.port, self.ip).hash(s)\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl hash::Hash for SocketAddrV6 {\n+    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n+        (self.port, &self.ip, self.flowinfo, self.scope_id).hash(s)\n+    }\n+}"}, {"sha": "994c08d1fb50d19c1655b70481e742088511f3ca", "filename": "library/core/src/option.rs", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -553,6 +553,7 @@ use crate::pin::Pin;\n use crate::{\n     cmp, convert, hint, mem,\n     ops::{self, ControlFlow, Deref, DerefMut},\n+    slice,\n };\n \n /// The `Option` type. See [the module level documentation](self) for more.\n@@ -734,6 +735,124 @@ impl<T> Option<T> {\n         }\n     }\n \n+    const fn get_some_offset() -> isize {\n+        if mem::size_of::<Option<T>>() == mem::size_of::<T>() {\n+            // niche optimization means the `T` is always stored at the same position as the Option.\n+            0\n+        } else {\n+            assert!(mem::size_of::<Option<T>>() == mem::size_of::<Option<mem::MaybeUninit<T>>>());\n+            let some_uninit = Some(mem::MaybeUninit::<T>::uninit());\n+            // SAFETY: This gets the byte offset of the `Some(_)` value following the fact that\n+            // niche optimization is not active, and thus Option<T> and Option<MaybeUninit<t>> share\n+            // the same layout.\n+            unsafe {\n+                (some_uninit.as_ref().unwrap() as *const mem::MaybeUninit<T>)\n+                    .byte_offset_from(&some_uninit as *const Option<mem::MaybeUninit<T>>)\n+            }\n+        }\n+    }\n+\n+    /// Returns a slice of the contained value, if any. If this is `None`, an\n+    /// empty slice is returned. This can be useful to have a single type of\n+    /// iterator over an `Option` or slice.\n+    ///\n+    /// Note: Should you have an `Option<&T>` and wish to get a slice of `T`,\n+    /// you can unpack it via `opt.map_or(&[], std::slice::from_ref)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// assert_eq!(\n+    ///     [Some(1234).as_slice(), None.as_slice()],\n+    ///     [&[1234][..], &[][..]],\n+    /// );\n+    /// ```\n+    ///\n+    /// The inverse of this function is (discounting\n+    /// borrowing) [`[_]::first`](slice::first):\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// for i in [Some(1234_u16), None] {\n+    ///     assert_eq!(i.as_ref(), i.as_slice().first());\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[must_use]\n+    #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        // SAFETY: This is sound as long as `get_some_offset` returns the\n+        // correct offset. Though in the `None` case, the slice may be located\n+        // at a pointer pointing into padding, the fact that the slice is\n+        // empty, and the padding is at a properly aligned position for a\n+        // value of that type makes it sound.\n+        unsafe {\n+            slice::from_raw_parts(\n+                (self as *const Option<T>).wrapping_byte_offset(Self::get_some_offset())\n+                    as *const T,\n+                self.is_some() as usize,\n+            )\n+        }\n+    }\n+\n+    /// Returns a mutable slice of the contained value, if any. If this is\n+    /// `None`, an empty slice is returned. This can be useful to have a\n+    /// single type of iterator over an `Option` or slice.\n+    ///\n+    /// Note: Should you have an `Option<&mut T>` instead of a\n+    /// `&mut Option<T>`, which this method takes, you can obtain a mutable\n+    /// slice via `opt.map_or(&mut [], std::slice::from_mut)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// assert_eq!(\n+    ///     [Some(1234).as_mut_slice(), None.as_mut_slice()],\n+    ///     [&mut [1234][..], &mut [][..]],\n+    /// );\n+    /// ```\n+    ///\n+    /// The result is a mutable slice of zero or one items that points into\n+    /// our original `Option`:\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// let mut x = Some(1234);\n+    /// x.as_mut_slice()[0] += 1;\n+    /// assert_eq!(x, Some(1235));\n+    /// ```\n+    ///\n+    /// The inverse of this method (discounting borrowing)\n+    /// is [`[_]::first_mut`](slice::first_mut):\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// assert_eq!(Some(123).as_mut_slice().first_mut(), Some(&mut 123))\n+    /// ```\n+    #[inline]\n+    #[must_use]\n+    #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n+        // SAFETY: This is sound as long as `get_some_offset` returns the\n+        // correct offset. Though in the `None` case, the slice may be located\n+        // at a pointer pointing into padding, the fact that the slice is\n+        // empty, and the padding is at a properly aligned position for a\n+        // value of that type makes it sound.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                (self as *mut Option<T>).wrapping_byte_offset(Self::get_some_offset()) as *mut T,\n+                self.is_some() as usize,\n+            )\n+        }\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Getting to contained values\n     /////////////////////////////////////////////////////////////////////////"}, {"sha": "6f78811a186c7ec6b6d3bb537407a860a66d8211", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -587,8 +587,10 @@ mod prim_pointer {}\n /// There are two syntactic forms for creating an array:\n ///\n /// * A list with each element, i.e., `[x, y, z]`.\n-/// * A repeat expression `[x; N]`, which produces an array with `N` copies of `x`.\n-///   The type of `x` must be [`Copy`].\n+/// * A repeat expression `[expr; N]` where `N` is how many times to repeat `expr` in the array. `expr` must either be:\n+///\n+///   * A value of a type implementing the [`Copy`] trait\n+///   * A `const` value\n ///\n /// Note that `[expr; 0]` is allowed, and produces an empty array.\n /// This will still evaluate `expr`, however, and immediately drop the resulting value, so"}, {"sha": "efe6d4183e3ea808857cb83d1fe4f00a9db2fac5", "filename": "library/core/src/ptr/alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -41,7 +41,7 @@ impl Alignment {\n     /// Returns the alignment for a type.\n     ///\n     /// This provides the same numerical value as [`mem::align_of`],\n-    /// but in an `Alignment` instead of a `usize.\n+    /// but in an `Alignment` instead of a `usize`.\n     #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n     #[inline]\n     pub const fn of<T>() -> Self {"}, {"sha": "7601dd3c75608f9abcae2cb61252cdc609e552e3", "filename": "library/core/src/slice/cmp.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,6 +1,6 @@\n //! Comparison traits for `[T]`.\n \n-use crate::cmp::{self, Ordering};\n+use crate::cmp::{self, BytewiseEq, Ordering};\n use crate::ffi;\n use crate::mem;\n \n@@ -77,7 +77,7 @@ where\n // Use memcmp for bytewise equality when the types allow\n impl<A, B> SlicePartialEq<B> for [A]\n where\n-    A: BytewiseEquality<B>,\n+    A: BytewiseEq<B>,\n {\n     fn equal(&self, other: &[B]) -> bool {\n         if self.len() != other.len() {\n@@ -203,29 +203,6 @@ impl SliceOrd for u8 {\n     }\n }\n \n-// Hack to allow specializing on `Eq` even though `Eq` has a method.\n-#[rustc_unsafe_specialization_marker]\n-trait MarkerEq<T>: PartialEq<T> {}\n-\n-impl<T: Eq> MarkerEq<T> for T {}\n-\n-#[doc(hidden)]\n-/// Trait implemented for types that can be compared for equality using\n-/// their bytewise representation\n-#[rustc_specialization_trait]\n-trait BytewiseEquality<T>: MarkerEq<T> + Copy {}\n-\n-macro_rules! impl_marker_for {\n-    ($traitname:ident, $($ty:ty)*) => {\n-        $(\n-            impl $traitname<$ty> for $ty { }\n-        )*\n-    }\n-}\n-\n-impl_marker_for!(BytewiseEquality,\n-                 u8 i8 u16 i16 u32 i32 u64 i64 u128 i128 usize isize char bool);\n-\n pub(super) trait SliceContains: Sized {\n     fn slice_contains(&self, x: &[Self]) -> bool;\n }"}, {"sha": "1cd86b445b0a478552cb4bbefe9b1561f95a7e81", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -2955,7 +2955,7 @@ impl<T> [T] {\n         // This operation is still `O(n)`.\n         //\n         // Example: We start in this state, where `r` represents \"next\n-        // read\" and `w` represents \"next_write`.\n+        // read\" and `w` represents \"next_write\".\n         //\n         //           r\n         //     +---+---+---+---+---+---+"}, {"sha": "2333f60a8889b8051f47c12aebfbf32b94277201", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -317,7 +317,7 @@ where\n     // 1. `block` - Number of elements in the block.\n     // 2. `start` - Start pointer into the `offsets` array.\n     // 3. `end` - End pointer into the `offsets` array.\n-    // 4. `offsets - Indices of out-of-order elements within the block.\n+    // 4. `offsets` - Indices of out-of-order elements within the block.\n \n     // The current block on the left side (from `l` to `l.add(block_l)`).\n     let mut l = v.as_mut_ptr();\n@@ -327,7 +327,7 @@ where\n     let mut offsets_l = [MaybeUninit::<u8>::uninit(); BLOCK];\n \n     // The current block on the right side (from `r.sub(block_r)` to `r`).\n-    // SAFETY: The documentation for .add() specifically mention that `vec.as_ptr().add(vec.len())` is always safe`\n+    // SAFETY: The documentation for .add() specifically mention that `vec.as_ptr().add(vec.len())` is always safe\n     let mut r = unsafe { l.add(v.len()) };\n     let mut block_r = BLOCK;\n     let mut start_r = ptr::null_mut();"}, {"sha": "68f62ce8be5f682d88905672c4eea0229b129540", "filename": "library/core/src/str/traits.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -28,10 +28,6 @@ impl PartialEq for str {\n     fn eq(&self, other: &str) -> bool {\n         self.as_bytes() == other.as_bytes()\n     }\n-    #[inline]\n-    fn ne(&self, other: &str) -> bool {\n-        !(*self).eq(other)\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "040a59184a64639d675d63dfada5d6a20a42781e", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -305,6 +305,50 @@ impl AtomicBool {\n         AtomicBool { v: UnsafeCell::new(v as u8) }\n     }\n \n+    /// Creates a new `AtomicBool` from a pointer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(atomic_from_ptr, pointer_is_aligned)]\n+    /// use std::sync::atomic::{self, AtomicBool};\n+    /// use std::mem::align_of;\n+    ///\n+    /// // Get a pointer to an allocated value\n+    /// let ptr: *mut bool = Box::into_raw(Box::new(false));\n+    ///\n+    /// assert!(ptr.is_aligned_to(align_of::<AtomicBool>()));\n+    ///\n+    /// {\n+    ///     // Create an atomic view of the allocated value\n+    ///     let atomic = unsafe { AtomicBool::from_ptr(ptr) };\n+    ///\n+    ///     // Use `atomic` for atomic operations, possibly share it with other threads\n+    ///     atomic.store(true, atomic::Ordering::Relaxed);\n+    /// }\n+    ///\n+    /// // It's ok to non-atomically access the value behind `ptr`,\n+    /// // since the reference to the atomic ended its lifetime in the block above\n+    /// assert_eq!(unsafe { *ptr }, true);\n+    ///\n+    /// // Deallocate the value\n+    /// unsafe { drop(Box::from_raw(ptr)) }\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// * `ptr` must be aligned to `align_of::<AtomicBool>()` (note that on some platforms this can be bigger than `align_of::<bool>()`).\n+    /// * `ptr` must be [valid] for both reads and writes for the whole lifetime `'a`.\n+    /// * The value behind `ptr` must not be accessed through non-atomic operations for the whole lifetime `'a`.\n+    ///\n+    /// [valid]: crate::ptr#safety\n+    #[unstable(feature = \"atomic_from_ptr\", issue = \"108652\")]\n+    #[rustc_const_unstable(feature = \"atomic_from_ptr\", issue = \"108652\")]\n+    pub const unsafe fn from_ptr<'a>(ptr: *mut bool) -> &'a AtomicBool {\n+        // SAFETY: guaranteed by the caller\n+        unsafe { &*ptr.cast() }\n+    }\n+\n     /// Returns a mutable reference to the underlying [`bool`].\n     ///\n     /// This is safe because the mutable reference guarantees that no other threads are\n@@ -1017,6 +1061,50 @@ impl<T> AtomicPtr<T> {\n         AtomicPtr { p: UnsafeCell::new(p) }\n     }\n \n+    /// Creates a new `AtomicPtr` from a pointer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(atomic_from_ptr, pointer_is_aligned)]\n+    /// use std::sync::atomic::{self, AtomicPtr};\n+    /// use std::mem::align_of;\n+    ///\n+    /// // Get a pointer to an allocated value\n+    /// let ptr: *mut *mut u8 = Box::into_raw(Box::new(std::ptr::null_mut()));\n+    ///\n+    /// assert!(ptr.is_aligned_to(align_of::<AtomicPtr<u8>>()));\n+    ///\n+    /// {\n+    ///     // Create an atomic view of the allocated value\n+    ///     let atomic = unsafe { AtomicPtr::from_ptr(ptr) };\n+    ///\n+    ///     // Use `atomic` for atomic operations, possibly share it with other threads\n+    ///     atomic.store(std::ptr::NonNull::dangling().as_ptr(), atomic::Ordering::Relaxed);\n+    /// }\n+    ///\n+    /// // It's ok to non-atomically access the value behind `ptr`,\n+    /// // since the reference to the atomic ended its lifetime in the block above\n+    /// assert!(!unsafe { *ptr }.is_null());\n+    ///\n+    /// // Deallocate the value\n+    /// unsafe { drop(Box::from_raw(ptr)) }\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// * `ptr` must be aligned to `align_of::<AtomicPtr<T>>()` (note that on some platforms this can be bigger than `align_of::<*mut T>()`).\n+    /// * `ptr` must be [valid] for both reads and writes for the whole lifetime `'a`.\n+    /// * The value behind `ptr` must not be accessed through non-atomic operations for the whole lifetime `'a`.\n+    ///\n+    /// [valid]: crate::ptr#safety\n+    #[unstable(feature = \"atomic_from_ptr\", issue = \"108652\")]\n+    #[rustc_const_unstable(feature = \"atomic_from_ptr\", issue = \"108652\")]\n+    pub const unsafe fn from_ptr<'a>(ptr: *mut *mut T) -> &'a AtomicPtr<T> {\n+        // SAFETY: guaranteed by the caller\n+        unsafe { &*ptr.cast() }\n+    }\n+\n     /// Returns a mutable reference to the underlying pointer.\n     ///\n     /// This is safe because the mutable reference guarantees that no other threads are\n@@ -1958,6 +2046,53 @@ macro_rules! atomic_int {\n                 Self {v: UnsafeCell::new(v)}\n             }\n \n+            /// Creates a new reference to an atomic integer from a pointer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// #![feature(atomic_from_ptr, pointer_is_aligned)]\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{self, \", stringify!($atomic_type), \"};\")]\n+            /// use std::mem::align_of;\n+            ///\n+            /// // Get a pointer to an allocated value\n+            #[doc = concat!(\"let ptr: *mut \", stringify!($int_type), \" = Box::into_raw(Box::new(0));\")]\n+            ///\n+            #[doc = concat!(\"assert!(ptr.is_aligned_to(align_of::<\", stringify!($atomic_type), \">()));\")]\n+            ///\n+            /// {\n+            ///     // Create an atomic view of the allocated value\n+            // SAFETY: this is a doc comment, tidy, it can't hurt you (also guaranteed by the construction of `ptr` and the assert above)\n+            #[doc = concat!(\"    let atomic = unsafe {\", stringify!($atomic_type), \"::from_ptr(ptr) };\")]\n+            ///\n+            ///     // Use `atomic` for atomic operations, possibly share it with other threads\n+            ///     atomic.store(1, atomic::Ordering::Relaxed);\n+            /// }\n+            ///\n+            /// // It's ok to non-atomically access the value behind `ptr`,\n+            /// // since the reference to the atomic ended its lifetime in the block above\n+            /// assert_eq!(unsafe { *ptr }, 1);\n+            ///\n+            /// // Deallocate the value\n+            /// unsafe { drop(Box::from_raw(ptr)) }\n+            /// ```\n+            ///\n+            /// # Safety\n+            ///\n+            /// * `ptr` must be aligned to `align_of::<AtomicBool>()` (note that on some platforms this can be bigger than `align_of::<bool>()`).\n+            #[doc = concat!(\" * `ptr` must be aligned to `align_of::<\", stringify!($atomic_type), \">()` (note that on some platforms this can be bigger than `align_of::<\", stringify!($int_type), \">()`).\")]\n+            /// * `ptr` must be [valid] for both reads and writes for the whole lifetime `'a`.\n+            /// * The value behind `ptr` must not be accessed through non-atomic operations for the whole lifetime `'a`.\n+            ///\n+            /// [valid]: crate::ptr#safety\n+            #[unstable(feature = \"atomic_from_ptr\", issue = \"108652\")]\n+            #[rustc_const_unstable(feature = \"atomic_from_ptr\", issue = \"108652\")]\n+            pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {\n+                // SAFETY: guaranteed by the caller\n+                unsafe { &*ptr.cast() }\n+            }\n+\n+\n             /// Returns a mutable reference to the underlying integer.\n             ///\n             /// This is safe because the mutable reference guarantees that no other threads are"}, {"sha": "af5bf441bb25fb6e89561430f7119b18ccd64f65", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -45,6 +45,7 @@ impl<T> Poll<T> {\n     /// assert_eq!(poll_some_len, Poll::Ready(13));\n     /// ```\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+    #[inline]\n     pub fn map<U, F>(self, f: F) -> Poll<U>\n     where\n         F: FnOnce(T) -> U,\n@@ -144,6 +145,7 @@ impl<T, E> Poll<Result<T, E>> {\n     /// assert_eq!(squared, Poll::Ready(Ok(144)));\n     /// ```\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+    #[inline]\n     pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n     where\n         F: FnOnce(T) -> U,\n@@ -171,6 +173,7 @@ impl<T, E> Poll<Result<T, E>> {\n     /// assert_eq!(res, Poll::Ready(Err(0)));\n     /// ```\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+    #[inline]\n     pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n     where\n         F: FnOnce(E) -> U,\n@@ -199,6 +202,7 @@ impl<T, E> Poll<Option<Result<T, E>>> {\n     /// assert_eq!(squared, Poll::Ready(Some(Ok(144))));\n     /// ```\n     #[stable(feature = \"poll_map\", since = \"1.51.0\")]\n+    #[inline]\n     pub fn map_ok<U, F>(self, f: F) -> Poll<Option<Result<U, E>>>\n     where\n         F: FnOnce(T) -> U,\n@@ -228,6 +232,7 @@ impl<T, E> Poll<Option<Result<T, E>>> {\n     /// assert_eq!(res, Poll::Ready(Some(Err(0))));\n     /// ```\n     #[stable(feature = \"poll_map\", since = \"1.51.0\")]\n+    #[inline]\n     pub fn map_err<U, F>(self, f: F) -> Poll<Option<Result<T, U>>>\n     where\n         F: FnOnce(E) -> U,"}, {"sha": "ca3463aa7f782bcfa3b34b142885cc28fa4df6a2", "filename": "library/core/tests/iter/adapters/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -24,7 +24,7 @@ mod zip;\n \n use core::cell::Cell;\n \n-/// An iterator that panics whenever `next` or next_back` is called\n+/// An iterator that panics whenever `next` or `next_back` is called\n /// after `None` has already been returned. This does not violate\n /// `Iterator`'s contract. Used to test that iterator adapters don't\n /// poll their inner iterators after exhausting them."}, {"sha": "ccb7be68eb1b2407c63426fd3de7d32ec52f0b46", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -66,6 +66,8 @@\n #![feature(try_trait_v2)]\n #![feature(slice_internals)]\n #![feature(slice_partition_dedup)]\n+#![feature(ip)]\n+#![feature(ip_in_core)]\n #![feature(iter_advance_by)]\n #![feature(iter_array_chunks)]\n #![feature(iter_collect_into)]\n@@ -77,6 +79,9 @@\n #![feature(iter_repeat_n)]\n #![feature(iterator_try_collect)]\n #![feature(iterator_try_reduce)]\n+#![feature(const_ip)]\n+#![feature(const_ipv4)]\n+#![feature(const_ipv6)]\n #![feature(const_mut_refs)]\n #![feature(const_pin)]\n #![feature(const_waker)]\n@@ -135,6 +140,7 @@ mod lazy;\n mod macros;\n mod manually_drop;\n mod mem;\n+mod net;\n mod nonzero;\n mod num;\n mod ops;"}, {"sha": "5a6ac08c08815968d1d95c20024e28de46bf1575", "filename": "library/core/tests/net/ip_addr.rs", "status": "added", "additions": 1035, "deletions": 0, "changes": 1035, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Ftests%2Fnet%2Fip_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Ftests%2Fnet%2Fip_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnet%2Fip_addr.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -0,0 +1,1035 @@\n+use super::{sa4, sa6};\n+use core::net::{\n+    IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope, SocketAddr, SocketAddrV4, SocketAddrV6,\n+};\n+use core::str::FromStr;\n+\n+#[test]\n+fn test_from_str_ipv4() {\n+    assert_eq!(Ok(Ipv4Addr::new(127, 0, 0, 1)), \"127.0.0.1\".parse());\n+    assert_eq!(Ok(Ipv4Addr::new(255, 255, 255, 255)), \"255.255.255.255\".parse());\n+    assert_eq!(Ok(Ipv4Addr::new(0, 0, 0, 0)), \"0.0.0.0\".parse());\n+\n+    // out of range\n+    let none: Option<Ipv4Addr> = \"256.0.0.1\".parse().ok();\n+    assert_eq!(None, none);\n+    // too short\n+    let none: Option<Ipv4Addr> = \"255.0.0\".parse().ok();\n+    assert_eq!(None, none);\n+    // too long\n+    let none: Option<Ipv4Addr> = \"255.0.0.1.2\".parse().ok();\n+    assert_eq!(None, none);\n+    // no number between dots\n+    let none: Option<Ipv4Addr> = \"255.0..1\".parse().ok();\n+    assert_eq!(None, none);\n+    // octal\n+    let none: Option<Ipv4Addr> = \"255.0.0.01\".parse().ok();\n+    assert_eq!(None, none);\n+    // octal zero\n+    let none: Option<Ipv4Addr> = \"255.0.0.00\".parse().ok();\n+    assert_eq!(None, none);\n+    let none: Option<Ipv4Addr> = \"255.0.00.0\".parse().ok();\n+    assert_eq!(None, none);\n+}\n+\n+#[test]\n+fn test_from_str_ipv6() {\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n+\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n+\n+    assert_eq!(Ok(Ipv6Addr::new(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)), \"2a02:6b8::11:11\".parse());\n+\n+    // too long group\n+    let none: Option<Ipv6Addr> = \"::00000\".parse().ok();\n+    assert_eq!(None, none);\n+    // too short\n+    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7\".parse().ok();\n+    assert_eq!(None, none);\n+    // too long\n+    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n+    assert_eq!(None, none);\n+    // triple colon\n+    let none: Option<Ipv6Addr> = \"1:2:::6:7:8\".parse().ok();\n+    assert_eq!(None, none);\n+    // two double colons\n+    let none: Option<Ipv6Addr> = \"1:2::6::8\".parse().ok();\n+    assert_eq!(None, none);\n+    // `::` indicating zero groups of zeros\n+    let none: Option<Ipv6Addr> = \"1:2:3:4::5:6:7:8\".parse().ok();\n+    assert_eq!(None, none);\n+}\n+\n+#[test]\n+fn test_from_str_ipv4_in_ipv6() {\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 545)), \"::192.0.2.33\".parse());\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)), \"::FFFF:192.0.2.33\".parse());\n+    assert_eq!(\n+        Ok(Ipv6Addr::new(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n+        \"64:ff9b::192.0.2.33\".parse()\n+    );\n+    assert_eq!(\n+        Ok(Ipv6Addr::new(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n+        \"2001:db8:122:c000:2:2100:192.0.2.33\".parse()\n+    );\n+\n+    // colon after v4\n+    let none: Option<Ipv4Addr> = \"::127.0.0.1:\".parse().ok();\n+    assert_eq!(None, none);\n+    // not enough groups\n+    let none: Option<Ipv6Addr> = \"1:2:3:4:5:127.0.0.1\".parse().ok();\n+    assert_eq!(None, none);\n+    // too many groups\n+    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:127.0.0.1\".parse().ok();\n+    assert_eq!(None, none);\n+}\n+\n+#[test]\n+fn test_from_str_socket_addr() {\n+    assert_eq!(Ok(sa4(Ipv4Addr::new(77, 88, 21, 11), 80)), \"77.88.21.11:80\".parse());\n+    assert_eq!(Ok(SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80)), \"77.88.21.11:80\".parse());\n+    assert_eq!(\n+        Ok(sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n+        \"[2a02:6b8:0:1::1]:53\".parse()\n+    );\n+    assert_eq!(\n+        Ok(SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53, 0, 0)),\n+        \"[2a02:6b8:0:1::1]:53\".parse()\n+    );\n+    assert_eq!(Ok(sa6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)), \"[::127.0.0.1]:22\".parse());\n+    assert_eq!(\n+        Ok(SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22, 0, 0)),\n+        \"[::127.0.0.1]:22\".parse()\n+    );\n+\n+    // without port\n+    let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n+    assert_eq!(None, none);\n+    // without port\n+    let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n+    assert_eq!(None, none);\n+    // wrong brackets around v4\n+    let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n+    assert_eq!(None, none);\n+    // port out of range\n+    let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n+    assert_eq!(None, none);\n+}\n+\n+#[test]\n+fn ipv4_addr_to_string() {\n+    assert_eq!(Ipv4Addr::new(127, 0, 0, 1).to_string(), \"127.0.0.1\");\n+    // Short address\n+    assert_eq!(Ipv4Addr::new(1, 1, 1, 1).to_string(), \"1.1.1.1\");\n+    // Long address\n+    assert_eq!(Ipv4Addr::new(127, 127, 127, 127).to_string(), \"127.127.127.127\");\n+\n+    // Test padding\n+    assert_eq!(format!(\"{:16}\", Ipv4Addr::new(1, 1, 1, 1)), \"1.1.1.1         \");\n+    assert_eq!(format!(\"{:>16}\", Ipv4Addr::new(1, 1, 1, 1)), \"         1.1.1.1\");\n+}\n+\n+#[test]\n+fn ipv6_addr_to_string() {\n+    // ipv4-mapped address\n+    let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n+    assert_eq!(a1.to_string(), \"::ffff:192.0.2.128\");\n+\n+    // ipv4-compatible address\n+    let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280);\n+    assert_eq!(a1.to_string(), \"::192.0.2.128\");\n+\n+    // v6 address with no zero segments\n+    assert_eq!(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15).to_string(), \"8:9:a:b:c:d:e:f\");\n+\n+    // longest possible IPv6 length\n+    assert_eq!(\n+        Ipv6Addr::new(0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888).to_string(),\n+        \"1111:2222:3333:4444:5555:6666:7777:8888\"\n+    );\n+    // padding\n+    assert_eq!(format!(\"{:20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"1:2:3:4:5:6:7:8     \");\n+    assert_eq!(format!(\"{:>20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"     1:2:3:4:5:6:7:8\");\n+\n+    // reduce a single run of zeros\n+    assert_eq!(\n+        \"ae::ffff:102:304\",\n+        Ipv6Addr::new(0xae, 0, 0, 0, 0, 0xffff, 0x0102, 0x0304).to_string()\n+    );\n+\n+    // don't reduce just a single zero segment\n+    assert_eq!(\"1:2:3:4:5:6:0:8\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 0, 8).to_string());\n+\n+    // 'any' address\n+    assert_eq!(\"::\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).to_string());\n+\n+    // loopback address\n+    assert_eq!(\"::1\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_string());\n+\n+    // ends in zeros\n+    assert_eq!(\"1::\", Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0).to_string());\n+\n+    // two runs of zeros, second one is longer\n+    assert_eq!(\"1:0:0:4::8\", Ipv6Addr::new(1, 0, 0, 4, 0, 0, 0, 8).to_string());\n+\n+    // two runs of zeros, equal length\n+    assert_eq!(\"1::4:5:0:0:8\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8).to_string());\n+\n+    // don't prefix `0x` to each segment in `dbg!`.\n+    assert_eq!(\"1::4:5:0:0:8\", &format!(\"{:#?}\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8)));\n+}\n+\n+#[test]\n+fn ipv4_to_ipv6() {\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678),\n+        Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_mapped()\n+    );\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678),\n+        Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_compatible()\n+    );\n+}\n+\n+#[test]\n+fn ipv6_to_ipv4_mapped() {\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4_mapped(),\n+        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n+    );\n+    assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4_mapped(), None);\n+}\n+\n+#[test]\n+fn ipv6_to_ipv4() {\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4(),\n+        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n+    );\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n+        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n+    );\n+    assert_eq!(Ipv6Addr::new(0, 0, 1, 0, 0, 0, 0x1234, 0x5678).to_ipv4(), None);\n+}\n+\n+#[test]\n+fn ip_properties() {\n+    macro_rules! ip {\n+        ($s:expr) => {\n+            IpAddr::from_str($s).unwrap()\n+        };\n+    }\n+\n+    macro_rules! check {\n+        ($s:expr) => {\n+            check!($s, 0);\n+        };\n+\n+        ($s:expr, $mask:expr) => {{\n+            let unspec: u8 = 1 << 0;\n+            let loopback: u8 = 1 << 1;\n+            let global: u8 = 1 << 2;\n+            let multicast: u8 = 1 << 3;\n+            let doc: u8 = 1 << 4;\n+            let benchmarking: u8 = 1 << 5;\n+\n+            if ($mask & unspec) == unspec {\n+                assert!(ip!($s).is_unspecified());\n+            } else {\n+                assert!(!ip!($s).is_unspecified());\n+            }\n+\n+            if ($mask & loopback) == loopback {\n+                assert!(ip!($s).is_loopback());\n+            } else {\n+                assert!(!ip!($s).is_loopback());\n+            }\n+\n+            if ($mask & global) == global {\n+                assert!(ip!($s).is_global());\n+            } else {\n+                assert!(!ip!($s).is_global());\n+            }\n+\n+            if ($mask & multicast) == multicast {\n+                assert!(ip!($s).is_multicast());\n+            } else {\n+                assert!(!ip!($s).is_multicast());\n+            }\n+\n+            if ($mask & doc) == doc {\n+                assert!(ip!($s).is_documentation());\n+            } else {\n+                assert!(!ip!($s).is_documentation());\n+            }\n+\n+            if ($mask & benchmarking) == benchmarking {\n+                assert!(ip!($s).is_benchmarking());\n+            } else {\n+                assert!(!ip!($s).is_benchmarking());\n+            }\n+        }};\n+    }\n+\n+    let unspec: u8 = 1 << 0;\n+    let loopback: u8 = 1 << 1;\n+    let global: u8 = 1 << 2;\n+    let multicast: u8 = 1 << 3;\n+    let doc: u8 = 1 << 4;\n+    let benchmarking: u8 = 1 << 5;\n+\n+    check!(\"0.0.0.0\", unspec);\n+    check!(\"0.0.0.1\");\n+    check!(\"0.1.0.0\");\n+    check!(\"10.9.8.7\");\n+    check!(\"127.1.2.3\", loopback);\n+    check!(\"172.31.254.253\");\n+    check!(\"169.254.253.242\");\n+    check!(\"192.0.2.183\", doc);\n+    check!(\"192.1.2.183\", global);\n+    check!(\"192.168.254.253\");\n+    check!(\"198.51.100.0\", doc);\n+    check!(\"203.0.113.0\", doc);\n+    check!(\"203.2.113.0\", global);\n+    check!(\"224.0.0.0\", global | multicast);\n+    check!(\"239.255.255.255\", global | multicast);\n+    check!(\"255.255.255.255\");\n+    // make sure benchmarking addresses are not global\n+    check!(\"198.18.0.0\", benchmarking);\n+    check!(\"198.18.54.2\", benchmarking);\n+    check!(\"198.19.255.255\", benchmarking);\n+    // make sure addresses reserved for protocol assignment are not global\n+    check!(\"192.0.0.0\");\n+    check!(\"192.0.0.255\");\n+    check!(\"192.0.0.100\");\n+    // make sure reserved addresses are not global\n+    check!(\"240.0.0.0\");\n+    check!(\"251.54.1.76\");\n+    check!(\"254.255.255.255\");\n+    // make sure shared addresses are not global\n+    check!(\"100.64.0.0\");\n+    check!(\"100.127.255.255\");\n+    check!(\"100.100.100.0\");\n+\n+    check!(\"::\", unspec);\n+    check!(\"::1\", loopback);\n+    check!(\"::0.0.0.2\", global);\n+    check!(\"1::\", global);\n+    check!(\"fc00::\");\n+    check!(\"fdff:ffff::\");\n+    check!(\"fe80:ffff::\");\n+    check!(\"febf:ffff::\");\n+    check!(\"fec0::\", global);\n+    check!(\"ff01::\", global | multicast);\n+    check!(\"ff02::\", global | multicast);\n+    check!(\"ff03::\", global | multicast);\n+    check!(\"ff04::\", global | multicast);\n+    check!(\"ff05::\", global | multicast);\n+    check!(\"ff08::\", global | multicast);\n+    check!(\"ff0e::\", global | multicast);\n+    check!(\"2001:db8:85a3::8a2e:370:7334\", doc);\n+    check!(\"2001:2::ac32:23ff:21\", benchmarking);\n+    check!(\"102:304:506:708:90a:b0c:d0e:f10\", global);\n+}\n+\n+#[test]\n+fn ipv4_properties() {\n+    macro_rules! ip {\n+        ($s:expr) => {\n+            Ipv4Addr::from_str($s).unwrap()\n+        };\n+    }\n+\n+    macro_rules! check {\n+        ($s:expr) => {\n+            check!($s, 0);\n+        };\n+\n+        ($s:expr, $mask:expr) => {{\n+            let unspec: u16 = 1 << 0;\n+            let loopback: u16 = 1 << 1;\n+            let private: u16 = 1 << 2;\n+            let link_local: u16 = 1 << 3;\n+            let global: u16 = 1 << 4;\n+            let multicast: u16 = 1 << 5;\n+            let broadcast: u16 = 1 << 6;\n+            let documentation: u16 = 1 << 7;\n+            let benchmarking: u16 = 1 << 8;\n+            let reserved: u16 = 1 << 10;\n+            let shared: u16 = 1 << 11;\n+\n+            if ($mask & unspec) == unspec {\n+                assert!(ip!($s).is_unspecified());\n+            } else {\n+                assert!(!ip!($s).is_unspecified());\n+            }\n+\n+            if ($mask & loopback) == loopback {\n+                assert!(ip!($s).is_loopback());\n+            } else {\n+                assert!(!ip!($s).is_loopback());\n+            }\n+\n+            if ($mask & private) == private {\n+                assert!(ip!($s).is_private());\n+            } else {\n+                assert!(!ip!($s).is_private());\n+            }\n+\n+            if ($mask & link_local) == link_local {\n+                assert!(ip!($s).is_link_local());\n+            } else {\n+                assert!(!ip!($s).is_link_local());\n+            }\n+\n+            if ($mask & global) == global {\n+                assert!(ip!($s).is_global());\n+            } else {\n+                assert!(!ip!($s).is_global());\n+            }\n+\n+            if ($mask & multicast) == multicast {\n+                assert!(ip!($s).is_multicast());\n+            } else {\n+                assert!(!ip!($s).is_multicast());\n+            }\n+\n+            if ($mask & broadcast) == broadcast {\n+                assert!(ip!($s).is_broadcast());\n+            } else {\n+                assert!(!ip!($s).is_broadcast());\n+            }\n+\n+            if ($mask & documentation) == documentation {\n+                assert!(ip!($s).is_documentation());\n+            } else {\n+                assert!(!ip!($s).is_documentation());\n+            }\n+\n+            if ($mask & benchmarking) == benchmarking {\n+                assert!(ip!($s).is_benchmarking());\n+            } else {\n+                assert!(!ip!($s).is_benchmarking());\n+            }\n+\n+            if ($mask & reserved) == reserved {\n+                assert!(ip!($s).is_reserved());\n+            } else {\n+                assert!(!ip!($s).is_reserved());\n+            }\n+\n+            if ($mask & shared) == shared {\n+                assert!(ip!($s).is_shared());\n+            } else {\n+                assert!(!ip!($s).is_shared());\n+            }\n+        }};\n+    }\n+\n+    let unspec: u16 = 1 << 0;\n+    let loopback: u16 = 1 << 1;\n+    let private: u16 = 1 << 2;\n+    let link_local: u16 = 1 << 3;\n+    let global: u16 = 1 << 4;\n+    let multicast: u16 = 1 << 5;\n+    let broadcast: u16 = 1 << 6;\n+    let documentation: u16 = 1 << 7;\n+    let benchmarking: u16 = 1 << 8;\n+    let reserved: u16 = 1 << 10;\n+    let shared: u16 = 1 << 11;\n+\n+    check!(\"0.0.0.0\", unspec);\n+    check!(\"0.0.0.1\");\n+    check!(\"0.1.0.0\");\n+    check!(\"10.9.8.7\", private);\n+    check!(\"127.1.2.3\", loopback);\n+    check!(\"172.31.254.253\", private);\n+    check!(\"169.254.253.242\", link_local);\n+    check!(\"192.0.2.183\", documentation);\n+    check!(\"192.1.2.183\", global);\n+    check!(\"192.168.254.253\", private);\n+    check!(\"198.51.100.0\", documentation);\n+    check!(\"203.0.113.0\", documentation);\n+    check!(\"203.2.113.0\", global);\n+    check!(\"224.0.0.0\", global | multicast);\n+    check!(\"239.255.255.255\", global | multicast);\n+    check!(\"255.255.255.255\", broadcast);\n+    check!(\"198.18.0.0\", benchmarking);\n+    check!(\"198.18.54.2\", benchmarking);\n+    check!(\"198.19.255.255\", benchmarking);\n+    check!(\"192.0.0.0\");\n+    check!(\"192.0.0.255\");\n+    check!(\"192.0.0.100\");\n+    check!(\"240.0.0.0\", reserved);\n+    check!(\"251.54.1.76\", reserved);\n+    check!(\"254.255.255.255\", reserved);\n+    check!(\"100.64.0.0\", shared);\n+    check!(\"100.127.255.255\", shared);\n+    check!(\"100.100.100.0\", shared);\n+}\n+\n+#[test]\n+fn ipv6_properties() {\n+    macro_rules! ip {\n+        ($s:expr) => {\n+            Ipv6Addr::from_str($s).unwrap()\n+        };\n+    }\n+\n+    macro_rules! check {\n+        ($s:expr, &[$($octet:expr),*], $mask:expr) => {\n+            assert_eq!($s, ip!($s).to_string());\n+            let octets = &[$($octet),*];\n+            assert_eq!(&ip!($s).octets(), octets);\n+            assert_eq!(Ipv6Addr::from(*octets), ip!($s));\n+\n+            let unspecified: u32 = 1 << 0;\n+            let loopback: u32 = 1 << 1;\n+            let unique_local: u32 = 1 << 2;\n+            let global: u32 = 1 << 3;\n+            let unicast_link_local: u32 = 1 << 4;\n+            let unicast_global: u32 = 1 << 7;\n+            let documentation: u32 = 1 << 8;\n+            let benchmarking: u32 = 1 << 16;\n+            let multicast_interface_local: u32 = 1 << 9;\n+            let multicast_link_local: u32 = 1 << 10;\n+            let multicast_realm_local: u32 = 1 << 11;\n+            let multicast_admin_local: u32 = 1 << 12;\n+            let multicast_site_local: u32 = 1 << 13;\n+            let multicast_organization_local: u32 = 1 << 14;\n+            let multicast_global: u32 = 1 << 15;\n+            let multicast: u32 = multicast_interface_local\n+                | multicast_admin_local\n+                | multicast_global\n+                | multicast_link_local\n+                | multicast_realm_local\n+                | multicast_site_local\n+                | multicast_organization_local;\n+\n+            if ($mask & unspecified) == unspecified {\n+                assert!(ip!($s).is_unspecified());\n+            } else {\n+                assert!(!ip!($s).is_unspecified());\n+            }\n+            if ($mask & loopback) == loopback {\n+                assert!(ip!($s).is_loopback());\n+            } else {\n+                assert!(!ip!($s).is_loopback());\n+            }\n+            if ($mask & unique_local) == unique_local {\n+                assert!(ip!($s).is_unique_local());\n+            } else {\n+                assert!(!ip!($s).is_unique_local());\n+            }\n+            if ($mask & global) == global {\n+                assert!(ip!($s).is_global());\n+            } else {\n+                assert!(!ip!($s).is_global());\n+            }\n+            if ($mask & unicast_link_local) == unicast_link_local {\n+                assert!(ip!($s).is_unicast_link_local());\n+            } else {\n+                assert!(!ip!($s).is_unicast_link_local());\n+            }\n+            if ($mask & unicast_global) == unicast_global {\n+                assert!(ip!($s).is_unicast_global());\n+            } else {\n+                assert!(!ip!($s).is_unicast_global());\n+            }\n+            if ($mask & documentation) == documentation {\n+                assert!(ip!($s).is_documentation());\n+            } else {\n+                assert!(!ip!($s).is_documentation());\n+            }\n+            if ($mask & benchmarking) == benchmarking {\n+                assert!(ip!($s).is_benchmarking());\n+            } else {\n+                assert!(!ip!($s).is_benchmarking());\n+            }\n+            if ($mask & multicast) != 0 {\n+                assert!(ip!($s).multicast_scope().is_some());\n+                assert!(ip!($s).is_multicast());\n+            } else {\n+                assert!(ip!($s).multicast_scope().is_none());\n+                assert!(!ip!($s).is_multicast());\n+            }\n+            if ($mask & multicast_interface_local) == multicast_interface_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::InterfaceLocal);\n+            }\n+            if ($mask & multicast_link_local) == multicast_link_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::LinkLocal);\n+            }\n+            if ($mask & multicast_realm_local) == multicast_realm_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::RealmLocal);\n+            }\n+            if ($mask & multicast_admin_local) == multicast_admin_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::AdminLocal);\n+            }\n+            if ($mask & multicast_site_local) == multicast_site_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::SiteLocal);\n+            }\n+            if ($mask & multicast_organization_local) == multicast_organization_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::OrganizationLocal);\n+            }\n+            if ($mask & multicast_global) == multicast_global {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::Global);\n+            }\n+        }\n+    }\n+\n+    let unspecified: u32 = 1 << 0;\n+    let loopback: u32 = 1 << 1;\n+    let unique_local: u32 = 1 << 2;\n+    let global: u32 = 1 << 3;\n+    let unicast_link_local: u32 = 1 << 4;\n+    let unicast_global: u32 = 1 << 7;\n+    let documentation: u32 = 1 << 8;\n+    let benchmarking: u32 = 1 << 16;\n+    let multicast_interface_local: u32 = 1 << 9;\n+    let multicast_link_local: u32 = 1 << 10;\n+    let multicast_realm_local: u32 = 1 << 11;\n+    let multicast_admin_local: u32 = 1 << 12;\n+    let multicast_site_local: u32 = 1 << 13;\n+    let multicast_organization_local: u32 = 1 << 14;\n+    let multicast_global: u32 = 1 << 15;\n+\n+    check!(\"::\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unspecified);\n+\n+    check!(\"::1\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], loopback);\n+\n+    check!(\"::0.0.0.2\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], global | unicast_global);\n+\n+    check!(\"1::\", &[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], global | unicast_global);\n+\n+    check!(\n+        \"::ffff:127.0.0.1\",\n+        &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, 0x7f, 0, 0, 1],\n+        unicast_global\n+    );\n+\n+    check!(\n+        \"64:ff9b:1::\",\n+        &[0, 0x64, 0xff, 0x9b, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_global\n+    );\n+\n+    check!(\"100::\", &[0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n+\n+    check!(\"2001::\", &[0x20, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n+\n+    check!(\n+        \"2001:1::1\",\n+        &[0x20, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n+        global | unicast_global\n+    );\n+\n+    check!(\n+        \"2001:1::2\",\n+        &[0x20, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n+        global | unicast_global\n+    );\n+\n+    check!(\n+        \"2001:3::\",\n+        &[0x20, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        global | unicast_global\n+    );\n+\n+    check!(\n+        \"2001:4:112::\",\n+        &[0x20, 1, 0, 4, 1, 0x12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        global | unicast_global\n+    );\n+\n+    check!(\n+        \"2001:20::\",\n+        &[0x20, 1, 0, 0x20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        global | unicast_global\n+    );\n+\n+    check!(\"2001:30::\", &[0x20, 1, 0, 0x30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n+\n+    check!(\n+        \"2001:200::\",\n+        &[0x20, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        global | unicast_global\n+    );\n+\n+    check!(\"fc00::\", &[0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unique_local);\n+\n+    check!(\n+        \"fdff:ffff::\",\n+        &[0xfd, 0xff, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unique_local\n+    );\n+\n+    check!(\n+        \"fe80:ffff::\",\n+        &[0xfe, 0x80, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_link_local\n+    );\n+\n+    check!(\"fe80::\", &[0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_link_local);\n+\n+    check!(\n+        \"febf:ffff::\",\n+        &[0xfe, 0xbf, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_link_local\n+    );\n+\n+    check!(\"febf::\", &[0xfe, 0xbf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_link_local);\n+\n+    check!(\n+        \"febf:ffff:ffff:ffff:ffff:ffff:ffff:ffff\",\n+        &[\n+            0xfe, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff\n+        ],\n+        unicast_link_local\n+    );\n+\n+    check!(\n+        \"fe80::ffff:ffff:ffff:ffff\",\n+        &[\n+            0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff\n+        ],\n+        unicast_link_local\n+    );\n+\n+    check!(\n+        \"fe80:0:0:1::\",\n+        &[0xfe, 0x80, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_link_local\n+    );\n+\n+    check!(\n+        \"fec0::\",\n+        &[0xfe, 0xc0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_global | global\n+    );\n+\n+    check!(\n+        \"ff01::\",\n+        &[0xff, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_interface_local | global\n+    );\n+\n+    check!(\n+        \"ff02::\",\n+        &[0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_link_local | global\n+    );\n+\n+    check!(\n+        \"ff03::\",\n+        &[0xff, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_realm_local | global\n+    );\n+\n+    check!(\n+        \"ff04::\",\n+        &[0xff, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_admin_local | global\n+    );\n+\n+    check!(\n+        \"ff05::\",\n+        &[0xff, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_site_local | global\n+    );\n+\n+    check!(\n+        \"ff08::\",\n+        &[0xff, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_organization_local | global\n+    );\n+\n+    check!(\n+        \"ff0e::\",\n+        &[0xff, 0xe, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_global | global\n+    );\n+\n+    check!(\n+        \"2001:db8:85a3::8a2e:370:7334\",\n+        &[0x20, 1, 0xd, 0xb8, 0x85, 0xa3, 0, 0, 0, 0, 0x8a, 0x2e, 3, 0x70, 0x73, 0x34],\n+        documentation\n+    );\n+\n+    check!(\n+        \"2001:2::ac32:23ff:21\",\n+        &[0x20, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0xac, 0x32, 0x23, 0xff, 0, 0x21],\n+        benchmarking\n+    );\n+\n+    check!(\n+        \"102:304:506:708:90a:b0c:d0e:f10\",\n+        &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n+        global | unicast_global\n+    );\n+}\n+\n+#[test]\n+fn test_ipv4_to_int() {\n+    let a = Ipv4Addr::new(0x11, 0x22, 0x33, 0x44);\n+    assert_eq!(u32::from(a), 0x11223344);\n+}\n+\n+#[test]\n+fn test_int_to_ipv4() {\n+    let a = Ipv4Addr::new(0x11, 0x22, 0x33, 0x44);\n+    assert_eq!(Ipv4Addr::from(0x11223344), a);\n+}\n+\n+#[test]\n+fn test_ipv6_to_int() {\n+    let a = Ipv6Addr::new(0x1122, 0x3344, 0x5566, 0x7788, 0x99aa, 0xbbcc, 0xddee, 0xff11);\n+    assert_eq!(u128::from(a), 0x112233445566778899aabbccddeeff11u128);\n+}\n+\n+#[test]\n+fn test_int_to_ipv6() {\n+    let a = Ipv6Addr::new(0x1122, 0x3344, 0x5566, 0x7788, 0x99aa, 0xbbcc, 0xddee, 0xff11);\n+    assert_eq!(Ipv6Addr::from(0x112233445566778899aabbccddeeff11u128), a);\n+}\n+\n+#[test]\n+fn ipv4_from_constructors() {\n+    assert_eq!(Ipv4Addr::LOCALHOST, Ipv4Addr::new(127, 0, 0, 1));\n+    assert!(Ipv4Addr::LOCALHOST.is_loopback());\n+    assert_eq!(Ipv4Addr::UNSPECIFIED, Ipv4Addr::new(0, 0, 0, 0));\n+    assert!(Ipv4Addr::UNSPECIFIED.is_unspecified());\n+    assert_eq!(Ipv4Addr::BROADCAST, Ipv4Addr::new(255, 255, 255, 255));\n+    assert!(Ipv4Addr::BROADCAST.is_broadcast());\n+}\n+\n+#[test]\n+fn ipv6_from_constructors() {\n+    assert_eq!(Ipv6Addr::LOCALHOST, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+    assert!(Ipv6Addr::LOCALHOST.is_loopback());\n+    assert_eq!(Ipv6Addr::UNSPECIFIED, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n+    assert!(Ipv6Addr::UNSPECIFIED.is_unspecified());\n+}\n+\n+#[test]\n+fn ipv4_from_octets() {\n+    assert_eq!(Ipv4Addr::from([127, 0, 0, 1]), Ipv4Addr::new(127, 0, 0, 1))\n+}\n+\n+#[test]\n+fn ipv6_from_segments() {\n+    let from_u16s =\n+        Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff]);\n+    let new = Ipv6Addr::new(0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff);\n+    assert_eq!(new, from_u16s);\n+}\n+\n+#[test]\n+fn ipv6_from_octets() {\n+    let from_u16s =\n+        Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff]);\n+    let from_u8s = Ipv6Addr::from([\n+        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee,\n+        0xff,\n+    ]);\n+    assert_eq!(from_u16s, from_u8s);\n+}\n+\n+#[test]\n+fn cmp() {\n+    let v41 = Ipv4Addr::new(100, 64, 3, 3);\n+    let v42 = Ipv4Addr::new(192, 0, 2, 2);\n+    let v61 = \"2001:db8:f00::1002\".parse::<Ipv6Addr>().unwrap();\n+    let v62 = \"2001:db8:f00::2001\".parse::<Ipv6Addr>().unwrap();\n+    assert!(v41 < v42);\n+    assert!(v61 < v62);\n+\n+    assert_eq!(v41, IpAddr::V4(v41));\n+    assert_eq!(v61, IpAddr::V6(v61));\n+    assert!(v41 != IpAddr::V4(v42));\n+    assert!(v61 != IpAddr::V6(v62));\n+\n+    assert!(v41 < IpAddr::V4(v42));\n+    assert!(v61 < IpAddr::V6(v62));\n+    assert!(IpAddr::V4(v41) < v42);\n+    assert!(IpAddr::V6(v61) < v62);\n+\n+    assert!(v41 < IpAddr::V6(v61));\n+    assert!(IpAddr::V4(v41) < v61);\n+}\n+\n+#[test]\n+fn is_v4() {\n+    let ip = IpAddr::V4(Ipv4Addr::new(100, 64, 3, 3));\n+    assert!(ip.is_ipv4());\n+    assert!(!ip.is_ipv6());\n+}\n+\n+#[test]\n+fn is_v6() {\n+    let ip = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678));\n+    assert!(!ip.is_ipv4());\n+    assert!(ip.is_ipv6());\n+}\n+\n+#[test]\n+fn ipv4_const() {\n+    // test that the methods of `Ipv4Addr` are usable in a const context\n+\n+    const IP_ADDRESS: Ipv4Addr = Ipv4Addr::new(127, 0, 0, 1);\n+    assert_eq!(IP_ADDRESS, Ipv4Addr::LOCALHOST);\n+\n+    const OCTETS: [u8; 4] = IP_ADDRESS.octets();\n+    assert_eq!(OCTETS, [127, 0, 0, 1]);\n+\n+    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n+    assert!(!IS_UNSPECIFIED);\n+\n+    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n+    assert!(IS_LOOPBACK);\n+\n+    const IS_PRIVATE: bool = IP_ADDRESS.is_private();\n+    assert!(!IS_PRIVATE);\n+\n+    const IS_LINK_LOCAL: bool = IP_ADDRESS.is_link_local();\n+    assert!(!IS_LINK_LOCAL);\n+\n+    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n+    assert!(!IS_GLOBAL);\n+\n+    const IS_SHARED: bool = IP_ADDRESS.is_shared();\n+    assert!(!IS_SHARED);\n+\n+    const IS_BENCHMARKING: bool = IP_ADDRESS.is_benchmarking();\n+    assert!(!IS_BENCHMARKING);\n+\n+    const IS_RESERVED: bool = IP_ADDRESS.is_reserved();\n+    assert!(!IS_RESERVED);\n+\n+    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n+    assert!(!IS_MULTICAST);\n+\n+    const IS_BROADCAST: bool = IP_ADDRESS.is_broadcast();\n+    assert!(!IS_BROADCAST);\n+\n+    const IS_DOCUMENTATION: bool = IP_ADDRESS.is_documentation();\n+    assert!(!IS_DOCUMENTATION);\n+\n+    const IP_V6_COMPATIBLE: Ipv6Addr = IP_ADDRESS.to_ipv6_compatible();\n+    assert_eq!(\n+        IP_V6_COMPATIBLE,\n+        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 1])\n+    );\n+\n+    const IP_V6_MAPPED: Ipv6Addr = IP_ADDRESS.to_ipv6_mapped();\n+    assert_eq!(\n+        IP_V6_MAPPED,\n+        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 127, 0, 0, 1])\n+    );\n+}\n+\n+#[test]\n+fn ipv6_const() {\n+    // test that the methods of `Ipv6Addr` are usable in a const context\n+\n+    const IP_ADDRESS: Ipv6Addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n+    assert_eq!(IP_ADDRESS, Ipv6Addr::LOCALHOST);\n+\n+    const SEGMENTS: [u16; 8] = IP_ADDRESS.segments();\n+    assert_eq!(SEGMENTS, [0, 0, 0, 0, 0, 0, 0, 1]);\n+\n+    const OCTETS: [u8; 16] = IP_ADDRESS.octets();\n+    assert_eq!(OCTETS, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);\n+\n+    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n+    assert!(!IS_UNSPECIFIED);\n+\n+    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n+    assert!(IS_LOOPBACK);\n+\n+    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n+    assert!(!IS_GLOBAL);\n+\n+    const IS_UNIQUE_LOCAL: bool = IP_ADDRESS.is_unique_local();\n+    assert!(!IS_UNIQUE_LOCAL);\n+\n+    const IS_UNICAST_LINK_LOCAL: bool = IP_ADDRESS.is_unicast_link_local();\n+    assert!(!IS_UNICAST_LINK_LOCAL);\n+\n+    const IS_DOCUMENTATION: bool = IP_ADDRESS.is_documentation();\n+    assert!(!IS_DOCUMENTATION);\n+\n+    const IS_BENCHMARKING: bool = IP_ADDRESS.is_benchmarking();\n+    assert!(!IS_BENCHMARKING);\n+\n+    const IS_UNICAST_GLOBAL: bool = IP_ADDRESS.is_unicast_global();\n+    assert!(!IS_UNICAST_GLOBAL);\n+\n+    const MULTICAST_SCOPE: Option<Ipv6MulticastScope> = IP_ADDRESS.multicast_scope();\n+    assert_eq!(MULTICAST_SCOPE, None);\n+\n+    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n+    assert!(!IS_MULTICAST);\n+\n+    const IP_V4: Option<Ipv4Addr> = IP_ADDRESS.to_ipv4();\n+    assert_eq!(IP_V4.unwrap(), Ipv4Addr::new(0, 0, 0, 1));\n+}\n+\n+#[test]\n+fn ip_const() {\n+    // test that the methods of `IpAddr` are usable in a const context\n+\n+    const IP_ADDRESS: IpAddr = IpAddr::V4(Ipv4Addr::LOCALHOST);\n+\n+    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n+    assert!(!IS_UNSPECIFIED);\n+\n+    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n+    assert!(IS_LOOPBACK);\n+\n+    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n+    assert!(!IS_GLOBAL);\n+\n+    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n+    assert!(!IS_MULTICAST);\n+\n+    const IS_IP_V4: bool = IP_ADDRESS.is_ipv4();\n+    assert!(IS_IP_V4);\n+\n+    const IS_IP_V6: bool = IP_ADDRESS.is_ipv6();\n+    assert!(!IS_IP_V6);\n+}\n+\n+#[test]\n+fn structural_match() {\n+    // test that all IP types can be structurally matched upon\n+\n+    const IPV4: Ipv4Addr = Ipv4Addr::LOCALHOST;\n+    match IPV4 {\n+        Ipv4Addr::LOCALHOST => {}\n+        _ => unreachable!(),\n+    }\n+\n+    const IPV6: Ipv6Addr = Ipv6Addr::LOCALHOST;\n+    match IPV6 {\n+        Ipv6Addr::LOCALHOST => {}\n+        _ => unreachable!(),\n+    }\n+\n+    const IP: IpAddr = IpAddr::V4(Ipv4Addr::LOCALHOST);\n+    match IP {\n+        IpAddr::V4(Ipv4Addr::LOCALHOST) => {}\n+        _ => unreachable!(),\n+    }\n+}"}, {"sha": "8f17bbe5548ac86be7ae49f76b29afaaf2950ce0", "filename": "library/core/tests/net/mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Ftests%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Ftests%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnet%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -0,0 +1,13 @@\n+use core::net::{Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n+\n+mod ip_addr;\n+mod parser;\n+mod socket_addr;\n+\n+pub fn sa4(a: Ipv4Addr, p: u16) -> SocketAddr {\n+    SocketAddr::V4(SocketAddrV4::new(a, p))\n+}\n+\n+pub fn sa6(a: Ipv6Addr, p: u16) -> SocketAddr {\n+    SocketAddr::V6(SocketAddrV6::new(a, p, 0, 0))\n+}"}, {"sha": "36b87d7c1f5e00392761ee385cb2d137025d83e7", "filename": "library/core/tests/net/parser.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Ftests%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Ftests%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnet%2Fparser.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,6 +1,6 @@\n // FIXME: These tests are all excellent candidates for AFL fuzz testing\n-use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n-use crate::str::FromStr;\n+use core::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n+use core::str::FromStr;\n \n const PORT: u16 = 8080;\n const SCOPE_ID: u32 = 1337;", "previous_filename": "library/std/src/net/parser/tests.rs"}, {"sha": "68c7cd94d322faa2c03836df7e1cf2860ae87082", "filename": "library/core/tests/net/socket_addr.rs", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Ftests%2Fnet%2Fsocket_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fcore%2Ftests%2Fnet%2Fsocket_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnet%2Fsocket_addr.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -0,0 +1,233 @@\n+use core::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n+\n+#[test]\n+fn ipv4_socket_addr_to_string() {\n+    // Shortest possible IPv4 length.\n+    assert_eq!(SocketAddrV4::new(Ipv4Addr::new(0, 0, 0, 0), 0).to_string(), \"0.0.0.0:0\");\n+\n+    // Longest possible IPv4 length.\n+    assert_eq!(\n+        SocketAddrV4::new(Ipv4Addr::new(255, 255, 255, 255), u16::MAX).to_string(),\n+        \"255.255.255.255:65535\"\n+    );\n+\n+    // Test padding.\n+    assert_eq!(\n+        &format!(\"{:16}\", SocketAddrV4::new(Ipv4Addr::new(1, 1, 1, 1), 53)),\n+        \"1.1.1.1:53      \"\n+    );\n+    assert_eq!(\n+        &format!(\"{:>16}\", SocketAddrV4::new(Ipv4Addr::new(1, 1, 1, 1), 53)),\n+        \"      1.1.1.1:53\"\n+    );\n+}\n+\n+#[test]\n+fn ipv6_socket_addr_to_string() {\n+    // IPv4-mapped address.\n+    assert_eq!(\n+        SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280), 8080, 0, 0)\n+            .to_string(),\n+        \"[::ffff:192.0.2.128]:8080\"\n+    );\n+\n+    // IPv4-compatible address.\n+    assert_eq!(\n+        SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280), 8080, 0, 0).to_string(),\n+        \"[::192.0.2.128]:8080\"\n+    );\n+\n+    // IPv6 address with no zero segments.\n+    assert_eq!(\n+        SocketAddrV6::new(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15), 80, 0, 0).to_string(),\n+        \"[8:9:a:b:c:d:e:f]:80\"\n+    );\n+\n+    // Shortest possible IPv6 length.\n+    assert_eq!(SocketAddrV6::new(Ipv6Addr::UNSPECIFIED, 0, 0, 0).to_string(), \"[::]:0\");\n+\n+    // Longest possible IPv6 length.\n+    assert_eq!(\n+        SocketAddrV6::new(\n+            Ipv6Addr::new(0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888),\n+            u16::MAX,\n+            u32::MAX,\n+            u32::MAX,\n+        )\n+        .to_string(),\n+        \"[1111:2222:3333:4444:5555:6666:7777:8888%4294967295]:65535\"\n+    );\n+\n+    // Test padding.\n+    assert_eq!(\n+        &format!(\"{:22}\", SocketAddrV6::new(Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8), 9, 0, 0)),\n+        \"[1:2:3:4:5:6:7:8]:9   \"\n+    );\n+    assert_eq!(\n+        &format!(\"{:>22}\", SocketAddrV6::new(Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8), 9, 0, 0)),\n+        \"   [1:2:3:4:5:6:7:8]:9\"\n+    );\n+}\n+\n+#[test]\n+fn set_ip() {\n+    fn ip4(low: u8) -> Ipv4Addr {\n+        Ipv4Addr::new(77, 88, 21, low)\n+    }\n+    fn ip6(low: u16) -> Ipv6Addr {\n+        Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, low)\n+    }\n+\n+    let mut v4 = SocketAddrV4::new(ip4(11), 80);\n+    assert_eq!(v4.ip(), &ip4(11));\n+    v4.set_ip(ip4(12));\n+    assert_eq!(v4.ip(), &ip4(12));\n+\n+    let mut addr = SocketAddr::V4(v4);\n+    assert_eq!(addr.ip(), IpAddr::V4(ip4(12)));\n+    addr.set_ip(IpAddr::V4(ip4(13)));\n+    assert_eq!(addr.ip(), IpAddr::V4(ip4(13)));\n+    addr.set_ip(IpAddr::V6(ip6(14)));\n+    assert_eq!(addr.ip(), IpAddr::V6(ip6(14)));\n+\n+    let mut v6 = SocketAddrV6::new(ip6(1), 80, 0, 0);\n+    assert_eq!(v6.ip(), &ip6(1));\n+    v6.set_ip(ip6(2));\n+    assert_eq!(v6.ip(), &ip6(2));\n+\n+    let mut addr = SocketAddr::V6(v6);\n+    assert_eq!(addr.ip(), IpAddr::V6(ip6(2)));\n+    addr.set_ip(IpAddr::V6(ip6(3)));\n+    assert_eq!(addr.ip(), IpAddr::V6(ip6(3)));\n+    addr.set_ip(IpAddr::V4(ip4(4)));\n+    assert_eq!(addr.ip(), IpAddr::V4(ip4(4)));\n+}\n+\n+#[test]\n+fn set_port() {\n+    let mut v4 = SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80);\n+    assert_eq!(v4.port(), 80);\n+    v4.set_port(443);\n+    assert_eq!(v4.port(), 443);\n+\n+    let mut addr = SocketAddr::V4(v4);\n+    assert_eq!(addr.port(), 443);\n+    addr.set_port(8080);\n+    assert_eq!(addr.port(), 8080);\n+\n+    let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 0, 0);\n+    assert_eq!(v6.port(), 80);\n+    v6.set_port(443);\n+    assert_eq!(v6.port(), 443);\n+\n+    let mut addr = SocketAddr::V6(v6);\n+    assert_eq!(addr.port(), 443);\n+    addr.set_port(8080);\n+    assert_eq!(addr.port(), 8080);\n+}\n+\n+#[test]\n+fn set_flowinfo() {\n+    let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 10, 0);\n+    assert_eq!(v6.flowinfo(), 10);\n+    v6.set_flowinfo(20);\n+    assert_eq!(v6.flowinfo(), 20);\n+}\n+\n+#[test]\n+fn set_scope_id() {\n+    let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 0, 10);\n+    assert_eq!(v6.scope_id(), 10);\n+    v6.set_scope_id(20);\n+    assert_eq!(v6.scope_id(), 20);\n+}\n+\n+#[test]\n+fn is_v4() {\n+    let v4 = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80));\n+    assert!(v4.is_ipv4());\n+    assert!(!v4.is_ipv6());\n+}\n+\n+#[test]\n+fn is_v6() {\n+    let v6 = SocketAddr::V6(SocketAddrV6::new(\n+        Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1),\n+        80,\n+        10,\n+        0,\n+    ));\n+    assert!(!v6.is_ipv4());\n+    assert!(v6.is_ipv6());\n+}\n+\n+#[test]\n+fn socket_v4_to_str() {\n+    let socket = SocketAddrV4::new(Ipv4Addr::new(192, 168, 0, 1), 8080);\n+\n+    assert_eq!(format!(\"{socket}\"), \"192.168.0.1:8080\");\n+    assert_eq!(format!(\"{socket:<20}\"), \"192.168.0.1:8080    \");\n+    assert_eq!(format!(\"{socket:>20}\"), \"    192.168.0.1:8080\");\n+    assert_eq!(format!(\"{socket:^20}\"), \"  192.168.0.1:8080  \");\n+    assert_eq!(format!(\"{socket:.10}\"), \"192.168.0.\");\n+}\n+\n+#[test]\n+fn socket_v6_to_str() {\n+    let mut socket = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53, 0, 0);\n+\n+    assert_eq!(format!(\"{socket}\"), \"[2a02:6b8:0:1::1]:53\");\n+    assert_eq!(format!(\"{socket:<24}\"), \"[2a02:6b8:0:1::1]:53    \");\n+    assert_eq!(format!(\"{socket:>24}\"), \"    [2a02:6b8:0:1::1]:53\");\n+    assert_eq!(format!(\"{socket:^24}\"), \"  [2a02:6b8:0:1::1]:53  \");\n+    assert_eq!(format!(\"{socket:.15}\"), \"[2a02:6b8:0:1::\");\n+\n+    socket.set_scope_id(5);\n+\n+    assert_eq!(format!(\"{socket}\"), \"[2a02:6b8:0:1::1%5]:53\");\n+    assert_eq!(format!(\"{socket:<24}\"), \"[2a02:6b8:0:1::1%5]:53  \");\n+    assert_eq!(format!(\"{socket:>24}\"), \"  [2a02:6b8:0:1::1%5]:53\");\n+    assert_eq!(format!(\"{socket:^24}\"), \" [2a02:6b8:0:1::1%5]:53 \");\n+    assert_eq!(format!(\"{socket:.18}\"), \"[2a02:6b8:0:1::1%5\");\n+}\n+\n+#[test]\n+fn compare() {\n+    let v4_1 = \"224.120.45.1:23456\".parse::<SocketAddrV4>().unwrap();\n+    let v4_2 = \"224.210.103.5:12345\".parse::<SocketAddrV4>().unwrap();\n+    let v4_3 = \"224.210.103.5:23456\".parse::<SocketAddrV4>().unwrap();\n+    let v6_1 = \"[2001:db8:f00::1002]:23456\".parse::<SocketAddrV6>().unwrap();\n+    let v6_2 = \"[2001:db8:f00::2001]:12345\".parse::<SocketAddrV6>().unwrap();\n+    let v6_3 = \"[2001:db8:f00::2001]:23456\".parse::<SocketAddrV6>().unwrap();\n+\n+    // equality\n+    assert_eq!(v4_1, v4_1);\n+    assert_eq!(v6_1, v6_1);\n+    assert_eq!(SocketAddr::V4(v4_1), SocketAddr::V4(v4_1));\n+    assert_eq!(SocketAddr::V6(v6_1), SocketAddr::V6(v6_1));\n+    assert!(v4_1 != v4_2);\n+    assert!(v6_1 != v6_2);\n+\n+    // compare different addresses\n+    assert!(v4_1 < v4_2);\n+    assert!(v6_1 < v6_2);\n+    assert!(v4_2 > v4_1);\n+    assert!(v6_2 > v6_1);\n+\n+    // compare the same address with different ports\n+    assert!(v4_2 < v4_3);\n+    assert!(v6_2 < v6_3);\n+    assert!(v4_3 > v4_2);\n+    assert!(v6_3 > v6_2);\n+\n+    // compare different addresses with the same port\n+    assert!(v4_1 < v4_3);\n+    assert!(v6_1 < v6_3);\n+    assert!(v4_3 > v4_1);\n+    assert!(v6_3 > v6_1);\n+\n+    // compare with an inferred right-hand side\n+    assert_eq!(v4_1, \"224.120.45.1:23456\".parse().unwrap());\n+    assert_eq!(v6_1, \"[2001:db8:f00::1002]:23456\".parse().unwrap());\n+    assert_eq!(SocketAddr::V4(v4_1), \"224.120.45.1:23456\".parse().unwrap());\n+}"}, {"sha": "d52d1ac4d3a0efe78db6ef1f976549a2baffd5f1", "filename": "library/portable-simd/crates/core_simd/src/vector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -28,7 +28,7 @@ use crate::simd::{\n /// let zm_add = a0.zip(a1).map(|(lhs, rhs)| lhs + rhs);\n /// let zm_mul = a0.zip(a1).map(|(lhs, rhs)| lhs * rhs);\n ///\n-/// // `Simd<T, N>` implements `From<[T; N]>\n+/// // `Simd<T, N>` implements `From<[T; N]>`\n /// let (v0, v1) = (Simd::from(a0), Simd::from(a1));\n /// // Which means arrays implement `Into<Simd<T, N>>`.\n /// assert_eq!(v0 + v1, zm_add.into());"}, {"sha": "598a4bf928290d8445c9d3f1d9774971dd01f7ac", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -15,7 +15,7 @@ cfg-if = { version = \"1.0\", features = ['rustc-dep-of-std'] }\n panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n-libc = { version = \"0.2.138\", default-features = false, features = ['rustc-dep-of-std'] }\n+libc = { version = \"0.2.139\", default-features = false, features = ['rustc-dep-of-std'] }\n compiler_builtins = { version = \"0.1.87\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }"}, {"sha": "ea87966755805d5b64fbc9e504bafcd9b472dbce", "filename": "library/std/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fbuild.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -31,6 +31,7 @@ fn main() {\n         || target.contains(\"espidf\")\n         || target.contains(\"solid\")\n         || target.contains(\"nintendo-3ds\")\n+        || target.contains(\"nto\")\n     {\n         // These platforms don't have any special requirements.\n     } else {"}, {"sha": "b62f3ad29d3713f1c8190a20fdb3e6f47c1297c6", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -232,6 +232,7 @@\n     all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     feature(slice_index_methods, coerce_unsized, sgx_platform)\n )]\n+#![cfg_attr(windows, feature(round_char_boundary))]\n //\n // Language features:\n #![feature(alloc_error_handler)]\n@@ -287,6 +288,8 @@\n #![feature(float_next_up_down)]\n #![feature(hasher_prefixfree_extras)]\n #![feature(hashmap_internals)]\n+#![feature(ip)]\n+#![feature(ip_in_core)]\n #![feature(is_some_and)]\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_write_slice)]"}, {"sha": "e167fbd1b9cf89b2931120e8bacaed226ef854f7", "filename": "library/std/src/net/ip_addr.rs", "status": "modified", "additions": 7, "deletions": 2068, "changes": 2075, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -2,2101 +2,40 @@\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;\n \n-use crate::cmp::Ordering;\n-use crate::fmt::{self, Write};\n-use crate::mem::transmute;\n use crate::sys::net::netc as c;\n use crate::sys_common::{FromInner, IntoInner};\n \n-use super::display_buffer::DisplayBuffer;\n-\n-/// An IP address, either IPv4 or IPv6.\n-///\n-/// This enum can contain either an [`Ipv4Addr`] or an [`Ipv6Addr`], see their\n-/// respective documentation for more details.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-///\n-/// let localhost_v4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\n-/// let localhost_v6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n-///\n-/// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost_v4));\n-/// assert_eq!(\"::1\".parse(), Ok(localhost_v6));\n-///\n-/// assert_eq!(localhost_v4.is_ipv6(), false);\n-/// assert_eq!(localhost_v4.is_ipv4(), true);\n-/// ```\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"IpAddr\")]\n #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-#[derive(Copy, Clone, Eq, PartialEq, Hash, PartialOrd, Ord)]\n-pub enum IpAddr {\n-    /// An IPv4 address.\n-    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-    V4(#[stable(feature = \"ip_addr\", since = \"1.7.0\")] Ipv4Addr),\n-    /// An IPv6 address.\n-    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-    V6(#[stable(feature = \"ip_addr\", since = \"1.7.0\")] Ipv6Addr),\n-}\n+pub use core::net::IpAddr;\n \n-/// An IPv4 address.\n-///\n-/// IPv4 addresses are defined as 32-bit integers in [IETF RFC 791].\n-/// They are usually represented as four octets.\n-///\n-/// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n-///\n-/// [IETF RFC 791]: https://tools.ietf.org/html/rfc791\n-///\n-/// # Textual representation\n-///\n-/// `Ipv4Addr` provides a [`FromStr`] implementation. The four octets are in decimal\n-/// notation, divided by `.` (this is called \"dot-decimal notation\").\n-/// Notably, octal numbers (which are indicated with a leading `0`) and hexadecimal numbers (which\n-/// are indicated with a leading `0x`) are not allowed per [IETF RFC 6943].\n-///\n-/// [IETF RFC 6943]: https://tools.ietf.org/html/rfc6943#section-3.1.1\n-/// [`FromStr`]: crate::str::FromStr\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::net::Ipv4Addr;\n-///\n-/// let localhost = Ipv4Addr::new(127, 0, 0, 1);\n-/// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost));\n-/// assert_eq!(localhost.is_loopback(), true);\n-/// assert!(\"012.004.002.000\".parse::<Ipv4Addr>().is_err()); // all octets are in octal\n-/// assert!(\"0000000.0.0.0\".parse::<Ipv4Addr>().is_err()); // first octet is a zero in octal\n-/// assert!(\"0xcb.0x0.0x71.0x00\".parse::<Ipv4Addr>().is_err()); // all octets are in hex\n-/// ```\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Ipv4Addr {\n-    octets: [u8; 4],\n-}\n+pub use core::net::{Ipv4Addr, Ipv6Addr};\n \n-/// An IPv6 address.\n-///\n-/// IPv6 addresses are defined as 128-bit integers in [IETF RFC 4291].\n-/// They are usually represented as eight 16-bit segments.\n-///\n-/// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n-///\n-/// # Embedding IPv4 Addresses\n-///\n-/// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n-///\n-/// To assist in the transition from IPv4 to IPv6 two types of IPv6 addresses that embed an IPv4 address were defined:\n-/// IPv4-compatible and IPv4-mapped addresses. Of these IPv4-compatible addresses have been officially deprecated.\n-///\n-/// Both types of addresses are not assigned any special meaning by this implementation,\n-/// other than what the relevant standards prescribe. This means that an address like `::ffff:127.0.0.1`,\n-/// while representing an IPv4 loopback address, is not itself an IPv6 loopback address; only `::1` is.\n-/// To handle these so called \"IPv4-in-IPv6\" addresses, they have to first be converted to their canonical IPv4 address.\n-///\n-/// ### IPv4-Compatible IPv6 Addresses\n-///\n-/// IPv4-compatible IPv6 addresses are defined in [IETF RFC 4291 Section 2.5.5.1], and have been officially deprecated.\n-/// The RFC describes the format of an \"IPv4-Compatible IPv6 address\" as follows:\n-///\n-/// ```text\n-/// |                80 bits               | 16 |      32 bits        |\n-/// +--------------------------------------+--------------------------+\n-/// |0000..............................0000|0000|    IPv4 address     |\n-/// +--------------------------------------+----+---------------------+\n-/// ```\n-/// So `::a.b.c.d` would be an IPv4-compatible IPv6 address representing the IPv4 address `a.b.c.d`.\n-///\n-/// To convert from an IPv4 address to an IPv4-compatible IPv6 address, use [`Ipv4Addr::to_ipv6_compatible`].\n-/// Use [`Ipv6Addr::to_ipv4`] to convert an IPv4-compatible IPv6 address to the canonical IPv4 address.\n-///\n-/// [IETF RFC 4291 Section 2.5.5.1]: https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.1\n-///\n-/// ### IPv4-Mapped IPv6 Addresses\n-///\n-/// IPv4-mapped IPv6 addresses are defined in [IETF RFC 4291 Section 2.5.5.2].\n-/// The RFC describes the format of an \"IPv4-Mapped IPv6 address\" as follows:\n-///\n-/// ```text\n-/// |                80 bits               | 16 |      32 bits        |\n-/// +--------------------------------------+--------------------------+\n-/// |0000..............................0000|FFFF|    IPv4 address     |\n-/// +--------------------------------------+----+---------------------+\n-/// ```\n-/// So `::ffff:a.b.c.d` would be an IPv4-mapped IPv6 address representing the IPv4 address `a.b.c.d`.\n-///\n-/// To convert from an IPv4 address to an IPv4-mapped IPv6 address, use [`Ipv4Addr::to_ipv6_mapped`].\n-/// Use [`Ipv6Addr::to_ipv4`] to convert an IPv4-mapped IPv6 address to the canonical IPv4 address.\n-/// Note that this will also convert the IPv6 loopback address `::1` to `0.0.0.1`. Use\n-/// [`Ipv6Addr::to_ipv4_mapped`] to avoid this.\n-///\n-/// [IETF RFC 4291 Section 2.5.5.2]: https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.2\n-///\n-/// # Textual representation\n-///\n-/// `Ipv6Addr` provides a [`FromStr`] implementation. There are many ways to represent\n-/// an IPv6 address in text, but in general, each segments is written in hexadecimal\n-/// notation, and segments are separated by `:`. For more information, see\n-/// [IETF RFC 5952].\n-///\n-/// [`FromStr`]: crate::str::FromStr\n-/// [IETF RFC 5952]: https://tools.ietf.org/html/rfc5952\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::net::Ipv6Addr;\n-///\n-/// let localhost = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n-/// assert_eq!(\"::1\".parse(), Ok(localhost));\n-/// assert_eq!(localhost.is_loopback(), true);\n-/// ```\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Ipv6Addr {\n-    octets: [u8; 16],\n-}\n-\n-/// Scope of an [IPv6 multicast address] as defined in [IETF RFC 7346 section 2].\n-///\n-/// # Stability Guarantees\n-///\n-/// Not all possible values for a multicast scope have been assigned.\n-/// Future RFCs may introduce new scopes, which will be added as variants to this enum;\n-/// because of this the enum is marked as `#[non_exhaustive]`.\n-///\n-/// # Examples\n-/// ```\n-/// #![feature(ip)]\n-///\n-/// use std::net::Ipv6Addr;\n-/// use std::net::Ipv6MulticastScope::*;\n-///\n-/// // An IPv6 multicast address with global scope (`ff0e::`).\n-/// let address = Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0);\n-///\n-/// // Will print \"Global scope\".\n-/// match address.multicast_scope() {\n-///     Some(InterfaceLocal) => println!(\"Interface-Local scope\"),\n-///     Some(LinkLocal) => println!(\"Link-Local scope\"),\n-///     Some(RealmLocal) => println!(\"Realm-Local scope\"),\n-///     Some(AdminLocal) => println!(\"Admin-Local scope\"),\n-///     Some(SiteLocal) => println!(\"Site-Local scope\"),\n-///     Some(OrganizationLocal) => println!(\"Organization-Local scope\"),\n-///     Some(Global) => println!(\"Global scope\"),\n-///     Some(_) => println!(\"Unknown scope\"),\n-///     None => println!(\"Not a multicast address!\")\n-/// }\n-///\n-/// ```\n-///\n-/// [IPv6 multicast address]: Ipv6Addr\n-/// [IETF RFC 7346 section 2]: https://tools.ietf.org/html/rfc7346#section-2\n-#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n #[unstable(feature = \"ip\", issue = \"27709\")]\n-#[non_exhaustive]\n-pub enum Ipv6MulticastScope {\n-    /// Interface-Local scope.\n-    InterfaceLocal,\n-    /// Link-Local scope.\n-    LinkLocal,\n-    /// Realm-Local scope.\n-    RealmLocal,\n-    /// Admin-Local scope.\n-    AdminLocal,\n-    /// Site-Local scope.\n-    SiteLocal,\n-    /// Organization-Local scope.\n-    OrganizationLocal,\n-    /// Global scope.\n-    Global,\n-}\n-\n-impl IpAddr {\n-    /// Returns [`true`] for the special 'unspecified' address.\n-    ///\n-    /// See the documentation for [`Ipv4Addr::is_unspecified()`] and\n-    /// [`Ipv6Addr::is_unspecified()`] for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)).is_unspecified(), true);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)).is_unspecified(), true);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_unspecified(&self) -> bool {\n-        match self {\n-            IpAddr::V4(ip) => ip.is_unspecified(),\n-            IpAddr::V6(ip) => ip.is_unspecified(),\n-        }\n-    }\n-\n-    /// Returns [`true`] if this is a loopback address.\n-    ///\n-    /// See the documentation for [`Ipv4Addr::is_loopback()`] and\n-    /// [`Ipv6Addr::is_loopback()`] for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)).is_loopback(), true);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1)).is_loopback(), true);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_loopback(&self) -> bool {\n-        match self {\n-            IpAddr::V4(ip) => ip.is_loopback(),\n-            IpAddr::V6(ip) => ip.is_loopback(),\n-        }\n-    }\n-\n-    /// Returns [`true`] if the address appears to be globally routable.\n-    ///\n-    /// See the documentation for [`Ipv4Addr::is_global()`] and\n-    /// [`Ipv6Addr::is_global()`] for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(80, 9, 12, 3)).is_global(), true);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1)).is_global(), true);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_global(&self) -> bool {\n-        match self {\n-            IpAddr::V4(ip) => ip.is_global(),\n-            IpAddr::V6(ip) => ip.is_global(),\n-        }\n-    }\n-\n-    /// Returns [`true`] if this is a multicast address.\n-    ///\n-    /// See the documentation for [`Ipv4Addr::is_multicast()`] and\n-    /// [`Ipv6Addr::is_multicast()`] for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(224, 254, 0, 0)).is_multicast(), true);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0)).is_multicast(), true);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_multicast(&self) -> bool {\n-        match self {\n-            IpAddr::V4(ip) => ip.is_multicast(),\n-            IpAddr::V6(ip) => ip.is_multicast(),\n-        }\n-    }\n-\n-    /// Returns [`true`] if this address is in a range designated for documentation.\n-    ///\n-    /// See the documentation for [`Ipv4Addr::is_documentation()`] and\n-    /// [`Ipv6Addr::is_documentation()`] for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_documentation(), true);\n-    /// assert_eq!(\n-    ///     IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_documentation(),\n-    ///     true\n-    /// );\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_documentation(&self) -> bool {\n-        match self {\n-            IpAddr::V4(ip) => ip.is_documentation(),\n-            IpAddr::V6(ip) => ip.is_documentation(),\n-        }\n-    }\n-\n-    /// Returns [`true`] if this address is in a range designated for benchmarking.\n-    ///\n-    /// See the documentation for [`Ipv4Addr::is_benchmarking()`] and\n-    /// [`Ipv6Addr::is_benchmarking()`] for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(198, 19, 255, 255)).is_benchmarking(), true);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0x2, 0, 0, 0, 0, 0, 0)).is_benchmarking(), true);\n-    /// ```\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_benchmarking(&self) -> bool {\n-        match self {\n-            IpAddr::V4(ip) => ip.is_benchmarking(),\n-            IpAddr::V6(ip) => ip.is_benchmarking(),\n-        }\n-    }\n-\n-    /// Returns [`true`] if this address is an [`IPv4` address], and [`false`]\n-    /// otherwise.\n-    ///\n-    /// [`IPv4` address]: IpAddr::V4\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv4(), true);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv4(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_ipv4(&self) -> bool {\n-        matches!(self, IpAddr::V4(_))\n-    }\n-\n-    /// Returns [`true`] if this address is an [`IPv6` address], and [`false`]\n-    /// otherwise.\n-    ///\n-    /// [`IPv6` address]: IpAddr::V6\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv6(), false);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv6(), true);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_ipv6(&self) -> bool {\n-        matches!(self, IpAddr::V6(_))\n-    }\n-\n-    /// Converts this address to an `IpAddr::V4` if it is an IPv4-mapped IPv6 addresses, otherwise it\n-    /// return `self` as-is.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)).to_canonical().is_loopback(), true);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1)).is_loopback(), false);\n-    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1)).to_canonical().is_loopback(), true);\n-    /// ```\n-    #[inline]\n-    #[must_use = \"this returns the result of the operation, \\\n-                  without modifying the original\"]\n-    #[rustc_const_unstable(feature = \"const_ip\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    pub const fn to_canonical(&self) -> IpAddr {\n-        match self {\n-            &v4 @ IpAddr::V4(_) => v4,\n-            IpAddr::V6(v6) => v6.to_canonical(),\n-        }\n-    }\n-}\n-\n-impl Ipv4Addr {\n-    /// Creates a new IPv4 address from four eight-bit octets.\n-    ///\n-    /// The result will represent the IP address `a`.`b`.`c`.`d`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n-        Ipv4Addr { octets: [a, b, c, d] }\n-    }\n-\n-    /// An IPv4 address with the address pointing to localhost: `127.0.0.1`\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::LOCALHOST;\n-    /// assert_eq!(addr, Ipv4Addr::new(127, 0, 0, 1));\n-    /// ```\n-    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n-    pub const LOCALHOST: Self = Ipv4Addr::new(127, 0, 0, 1);\n-\n-    /// An IPv4 address representing an unspecified address: `0.0.0.0`\n-    ///\n-    /// This corresponds to the constant `INADDR_ANY` in other languages.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::UNSPECIFIED;\n-    /// assert_eq!(addr, Ipv4Addr::new(0, 0, 0, 0));\n-    /// ```\n-    #[doc(alias = \"INADDR_ANY\")]\n-    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n-    pub const UNSPECIFIED: Self = Ipv4Addr::new(0, 0, 0, 0);\n-\n-    /// An IPv4 address representing the broadcast address: `255.255.255.255`\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::BROADCAST;\n-    /// assert_eq!(addr, Ipv4Addr::new(255, 255, 255, 255));\n-    /// ```\n-    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n-    pub const BROADCAST: Self = Ipv4Addr::new(255, 255, 255, 255);\n-\n-    /// Returns the four eight-bit integers that make up this address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n-    /// assert_eq!(addr.octets(), [127, 0, 0, 1]);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn octets(&self) -> [u8; 4] {\n-        self.octets\n-    }\n-\n-    /// Returns [`true`] for the special 'unspecified' address (`0.0.0.0`).\n-    ///\n-    /// This property is defined in _UNIX Network Programming, Second Edition_,\n-    /// W. Richard Stevens, p. 891; see also [ip7].\n-    ///\n-    /// [ip7]: https://man7.org/linux/man-pages/man7/ip.7.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_unspecified(), true);\n-    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_unspecified(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n-    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_unspecified(&self) -> bool {\n-        u32::from_be_bytes(self.octets) == 0\n-    }\n-\n-    /// Returns [`true`] if this is a loopback address (`127.0.0.0/8`).\n-    ///\n-    /// This property is defined by [IETF RFC 1122].\n-    ///\n-    /// [IETF RFC 1122]: https://tools.ietf.org/html/rfc1122\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_loopback(), true);\n-    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_loopback(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_loopback(&self) -> bool {\n-        self.octets()[0] == 127\n-    }\n-\n-    /// Returns [`true`] if this is a private address.\n-    ///\n-    /// The private address ranges are defined in [IETF RFC 1918] and include:\n-    ///\n-    ///  - `10.0.0.0/8`\n-    ///  - `172.16.0.0/12`\n-    ///  - `192.168.0.0/16`\n-    ///\n-    /// [IETF RFC 1918]: https://tools.ietf.org/html/rfc1918\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(10, 0, 0, 1).is_private(), true);\n-    /// assert_eq!(Ipv4Addr::new(10, 10, 10, 10).is_private(), true);\n-    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 10).is_private(), true);\n-    /// assert_eq!(Ipv4Addr::new(172, 29, 45, 14).is_private(), true);\n-    /// assert_eq!(Ipv4Addr::new(172, 32, 0, 2).is_private(), false);\n-    /// assert_eq!(Ipv4Addr::new(192, 168, 0, 2).is_private(), true);\n-    /// assert_eq!(Ipv4Addr::new(192, 169, 0, 2).is_private(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_private(&self) -> bool {\n-        match self.octets() {\n-            [10, ..] => true,\n-            [172, b, ..] if b >= 16 && b <= 31 => true,\n-            [192, 168, ..] => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Returns [`true`] if the address is link-local (`169.254.0.0/16`).\n-    ///\n-    /// This property is defined by [IETF RFC 3927].\n-    ///\n-    /// [IETF RFC 3927]: https://tools.ietf.org/html/rfc3927\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(169, 254, 0, 0).is_link_local(), true);\n-    /// assert_eq!(Ipv4Addr::new(169, 254, 10, 65).is_link_local(), true);\n-    /// assert_eq!(Ipv4Addr::new(16, 89, 10, 65).is_link_local(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_link_local(&self) -> bool {\n-        matches!(self.octets(), [169, 254, ..])\n-    }\n-\n-    /// Returns [`true`] if the address appears to be globally reachable\n-    /// as specified by the [IANA IPv4 Special-Purpose Address Registry].\n-    /// Whether or not an address is practically reachable will depend on your network configuration.\n-    ///\n-    /// Most IPv4 addresses are globally reachable;\n-    /// unless they are specifically defined as *not* globally reachable.\n-    ///\n-    /// Non-exhaustive list of notable addresses that are not globally reachable:\n-    ///\n-    /// - The [unspecified address] ([`is_unspecified`](Ipv4Addr::is_unspecified))\n-    /// - Addresses reserved for private use ([`is_private`](Ipv4Addr::is_private))\n-    /// - Addresses in the shared address space ([`is_shared`](Ipv4Addr::is_shared))\n-    /// - Loopback addresses ([`is_loopback`](Ipv4Addr::is_loopback))\n-    /// - Link-local addresses ([`is_link_local`](Ipv4Addr::is_link_local))\n-    /// - Addresses reserved for documentation ([`is_documentation`](Ipv4Addr::is_documentation))\n-    /// - Addresses reserved for benchmarking ([`is_benchmarking`](Ipv4Addr::is_benchmarking))\n-    /// - Reserved addresses ([`is_reserved`](Ipv4Addr::is_reserved))\n-    /// - The [broadcast address] ([`is_broadcast`](Ipv4Addr::is_broadcast))\n-    ///\n-    /// For the complete overview of which addresses are globally reachable, see the table at the [IANA IPv4 Special-Purpose Address Registry].\n-    ///\n-    /// [IANA IPv4 Special-Purpose Address Registry]: https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml\n-    /// [unspecified address]: Ipv4Addr::UNSPECIFIED\n-    /// [broadcast address]: Ipv4Addr::BROADCAST\n-\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// // Most IPv4 addresses are globally reachable:\n-    /// assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n-    ///\n-    /// // However some addresses have been assigned a special meaning\n-    /// // that makes them not globally reachable. Some examples are:\n-    ///\n-    /// // The unspecified address (`0.0.0.0`)\n-    /// assert_eq!(Ipv4Addr::UNSPECIFIED.is_global(), false);\n-    ///\n-    /// // Addresses reserved for private use (`10.0.0.0/8`, `172.16.0.0/12`, 192.168.0.0/16)\n-    /// assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n-    /// assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n-    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n-    ///\n-    /// // Addresses in the shared address space (`100.64.0.0/10`)\n-    /// assert_eq!(Ipv4Addr::new(100, 100, 0, 0).is_global(), false);\n-    ///\n-    /// // The loopback addresses (`127.0.0.0/8`)\n-    /// assert_eq!(Ipv4Addr::LOCALHOST.is_global(), false);\n-    ///\n-    /// // Link-local addresses (`169.254.0.0/16`)\n-    /// assert_eq!(Ipv4Addr::new(169, 254, 45, 1).is_global(), false);\n-    ///\n-    /// // Addresses reserved for documentation (`192.0.2.0/24`, `198.51.100.0/24`, `203.0.113.0/24`)\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_global(), false);\n-    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_global(), false);\n-    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_global(), false);\n-    ///\n-    /// // Addresses reserved for benchmarking (`198.18.0.0/15`)\n-    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_global(), false);\n-    ///\n-    /// // Reserved addresses (`240.0.0.0/4`)\n-    /// assert_eq!(Ipv4Addr::new(250, 10, 20, 30).is_global(), false);\n-    ///\n-    /// // The broadcast address (`255.255.255.255`)\n-    /// assert_eq!(Ipv4Addr::BROADCAST.is_global(), false);\n-    ///\n-    /// // For a complete overview see the IANA IPv4 Special-Purpose Address Registry.\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_global(&self) -> bool {\n-        !(self.octets()[0] == 0 // \"This network\"\n-            || self.is_private()\n-            || self.is_shared()\n-            || self.is_loopback()\n-            || self.is_link_local()\n-            // addresses reserved for future protocols (`192.0.0.0/24`)\n-            ||(self.octets()[0] == 192 && self.octets()[1] == 0 && self.octets()[2] == 0)\n-            || self.is_documentation()\n-            || self.is_benchmarking()\n-            || self.is_reserved()\n-            || self.is_broadcast())\n-    }\n-\n-    /// Returns [`true`] if this address is part of the Shared Address Space defined in\n-    /// [IETF RFC 6598] (`100.64.0.0/10`).\n-    ///\n-    /// [IETF RFC 6598]: https://tools.ietf.org/html/rfc6598\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(100, 64, 0, 0).is_shared(), true);\n-    /// assert_eq!(Ipv4Addr::new(100, 127, 255, 255).is_shared(), true);\n-    /// assert_eq!(Ipv4Addr::new(100, 128, 0, 0).is_shared(), false);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_shared(&self) -> bool {\n-        self.octets()[0] == 100 && (self.octets()[1] & 0b1100_0000 == 0b0100_0000)\n-    }\n-\n-    /// Returns [`true`] if this address part of the `198.18.0.0/15` range, which is reserved for\n-    /// network devices benchmarking. This range is defined in [IETF RFC 2544] as `192.18.0.0`\n-    /// through `198.19.255.255` but [errata 423] corrects it to `198.18.0.0/15`.\n-    ///\n-    /// [IETF RFC 2544]: https://tools.ietf.org/html/rfc2544\n-    /// [errata 423]: https://www.rfc-editor.org/errata/eid423\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(198, 17, 255, 255).is_benchmarking(), false);\n-    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_benchmarking(), true);\n-    /// assert_eq!(Ipv4Addr::new(198, 19, 255, 255).is_benchmarking(), true);\n-    /// assert_eq!(Ipv4Addr::new(198, 20, 0, 0).is_benchmarking(), false);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_benchmarking(&self) -> bool {\n-        self.octets()[0] == 198 && (self.octets()[1] & 0xfe) == 18\n-    }\n-\n-    /// Returns [`true`] if this address is reserved by IANA for future use. [IETF RFC 1112]\n-    /// defines the block of reserved addresses as `240.0.0.0/4`. This range normally includes the\n-    /// broadcast address `255.255.255.255`, but this implementation explicitly excludes it, since\n-    /// it is obviously not reserved for future use.\n-    ///\n-    /// [IETF RFC 1112]: https://tools.ietf.org/html/rfc1112\n-    ///\n-    /// # Warning\n-    ///\n-    /// As IANA assigns new addresses, this method will be\n-    /// updated. This may result in non-reserved addresses being\n-    /// treated as reserved in code that relies on an outdated version\n-    /// of this method.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(240, 0, 0, 0).is_reserved(), true);\n-    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 254).is_reserved(), true);\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(239, 255, 255, 255).is_reserved(), false);\n-    /// // The broadcast address is not considered as reserved for future use by this implementation\n-    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_reserved(), false);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_reserved(&self) -> bool {\n-        self.octets()[0] & 240 == 240 && !self.is_broadcast()\n-    }\n-\n-    /// Returns [`true`] if this is a multicast address (`224.0.0.0/4`).\n-    ///\n-    /// Multicast addresses have a most significant octet between `224` and `239`,\n-    /// and is defined by [IETF RFC 5771].\n-    ///\n-    /// [IETF RFC 5771]: https://tools.ietf.org/html/rfc5771\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(224, 254, 0, 0).is_multicast(), true);\n-    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_multicast(), true);\n-    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_multicast(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_multicast(&self) -> bool {\n-        self.octets()[0] >= 224 && self.octets()[0] <= 239\n-    }\n-\n-    /// Returns [`true`] if this is a broadcast address (`255.255.255.255`).\n-    ///\n-    /// A broadcast address has all octets set to `255` as defined in [IETF RFC 919].\n-    ///\n-    /// [IETF RFC 919]: https://tools.ietf.org/html/rfc919\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_broadcast(), true);\n-    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_broadcast(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_broadcast(&self) -> bool {\n-        u32::from_be_bytes(self.octets()) == u32::from_be_bytes(Self::BROADCAST.octets())\n-    }\n-\n-    /// Returns [`true`] if this address is in a range designated for documentation.\n-    ///\n-    /// This is defined in [IETF RFC 5737]:\n-    ///\n-    /// - `192.0.2.0/24` (TEST-NET-1)\n-    /// - `198.51.100.0/24` (TEST-NET-2)\n-    /// - `203.0.113.0/24` (TEST-NET-3)\n-    ///\n-    /// [IETF RFC 5737]: https://tools.ietf.org/html/rfc5737\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_documentation(), true);\n-    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_documentation(), true);\n-    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_documentation(), true);\n-    /// assert_eq!(Ipv4Addr::new(193, 34, 17, 19).is_documentation(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_documentation(&self) -> bool {\n-        matches!(self.octets(), [192, 0, 2, _] | [198, 51, 100, _] | [203, 0, 113, _])\n-    }\n-\n-    /// Converts this address to an [IPv4-compatible] [`IPv6` address].\n-    ///\n-    /// `a.b.c.d` becomes `::a.b.c.d`\n-    ///\n-    /// Note that IPv4-compatible addresses have been officially deprecated.\n-    /// If you don't explicitly need an IPv4-compatible address for legacy reasons, consider using `to_ipv6_mapped` instead.\n-    ///\n-    /// [IPv4-compatible]: Ipv6Addr#ipv4-compatible-ipv6-addresses\n-    /// [`IPv6` address]: Ipv6Addr\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(\n-    ///     Ipv4Addr::new(192, 0, 2, 255).to_ipv6_compatible(),\n-    ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x2ff)\n-    /// );\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use = \"this returns the result of the operation, \\\n-                  without modifying the original\"]\n-    #[inline]\n-    pub const fn to_ipv6_compatible(&self) -> Ipv6Addr {\n-        let [a, b, c, d] = self.octets();\n-        Ipv6Addr { octets: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, b, c, d] }\n-    }\n-\n-    /// Converts this address to an [IPv4-mapped] [`IPv6` address].\n-    ///\n-    /// `a.b.c.d` becomes `::ffff:a.b.c.d`\n-    ///\n-    /// [IPv4-mapped]: Ipv6Addr#ipv4-mapped-ipv6-addresses\n-    /// [`IPv6` address]: Ipv6Addr\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_mapped(),\n-    ///            Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x2ff));\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use = \"this returns the result of the operation, \\\n-                  without modifying the original\"]\n-    #[inline]\n-    pub const fn to_ipv6_mapped(&self) -> Ipv6Addr {\n-        let [a, b, c, d] = self.octets();\n-        Ipv6Addr { octets: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, a, b, c, d] }\n-    }\n-}\n-\n-#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-impl fmt::Display for IpAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            IpAddr::V4(ip) => ip.fmt(fmt),\n-            IpAddr::V6(ip) => ip.fmt(fmt),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-impl fmt::Debug for IpAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n-impl From<Ipv4Addr> for IpAddr {\n-    /// Copies this address to a new `IpAddr::V4`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr};\n-    ///\n-    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n-    ///\n-    /// assert_eq!(\n-    ///     IpAddr::V4(addr),\n-    ///     IpAddr::from(addr)\n-    /// )\n-    /// ```\n-    #[inline]\n-    fn from(ipv4: Ipv4Addr) -> IpAddr {\n-        IpAddr::V4(ipv4)\n-    }\n-}\n-\n-#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n-impl From<Ipv6Addr> for IpAddr {\n-    /// Copies this address to a new `IpAddr::V6`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv6Addr};\n-    ///\n-    /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n-    ///\n-    /// assert_eq!(\n-    ///     IpAddr::V6(addr),\n-    ///     IpAddr::from(addr)\n-    /// );\n-    /// ```\n-    #[inline]\n-    fn from(ipv6: Ipv6Addr) -> IpAddr {\n-        IpAddr::V6(ipv6)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for Ipv4Addr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let octets = self.octets();\n-\n-        // If there are no alignment requirements, write the IP address directly to `f`.\n-        // Otherwise, write it to a local buffer and then use `f.pad`.\n-        if fmt.precision().is_none() && fmt.width().is_none() {\n-            write!(fmt, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3])\n-        } else {\n-            const LONGEST_IPV4_ADDR: &str = \"255.255.255.255\";\n-\n-            let mut buf = DisplayBuffer::<{ LONGEST_IPV4_ADDR.len() }>::new();\n-            // Buffer is long enough for the longest possible IPv4 address, so this should never fail.\n-            write!(buf, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3]).unwrap();\n-\n-            fmt.pad(buf.as_str())\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for Ipv4Addr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialEq<Ipv4Addr> for IpAddr {\n-    #[inline]\n-    fn eq(&self, other: &Ipv4Addr) -> bool {\n-        match self {\n-            IpAddr::V4(v4) => v4 == other,\n-            IpAddr::V6(_) => false,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialEq<IpAddr> for Ipv4Addr {\n-    #[inline]\n-    fn eq(&self, other: &IpAddr) -> bool {\n-        match other {\n-            IpAddr::V4(v4) => self == v4,\n-            IpAddr::V6(_) => false,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialOrd for Ipv4Addr {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialOrd<Ipv4Addr> for IpAddr {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n-        match self {\n-            IpAddr::V4(v4) => v4.partial_cmp(other),\n-            IpAddr::V6(_) => Some(Ordering::Greater),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialOrd<IpAddr> for Ipv4Addr {\n-    #[inline]\n-    fn partial_cmp(&self, other: &IpAddr) -> Option<Ordering> {\n-        match other {\n-            IpAddr::V4(v4) => self.partial_cmp(v4),\n-            IpAddr::V6(_) => Some(Ordering::Less),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Ord for Ipv4Addr {\n-    #[inline]\n-    fn cmp(&self, other: &Ipv4Addr) -> Ordering {\n-        self.octets.cmp(&other.octets)\n-    }\n-}\n+pub use core::net::Ipv6MulticastScope;\n \n impl IntoInner<c::in_addr> for Ipv4Addr {\n     #[inline]\n     fn into_inner(self) -> c::in_addr {\n         // `s_addr` is stored as BE on all machines and the array is in BE order.\n         // So the native endian conversion method is used so that it's never swapped.\n-        c::in_addr { s_addr: u32::from_ne_bytes(self.octets) }\n+        c::in_addr { s_addr: u32::from_ne_bytes(self.octets()) }\n     }\n }\n impl FromInner<c::in_addr> for Ipv4Addr {\n     fn from_inner(addr: c::in_addr) -> Ipv4Addr {\n-        Ipv4Addr { octets: addr.s_addr.to_ne_bytes() }\n-    }\n-}\n-\n-#[stable(feature = \"ip_u32\", since = \"1.1.0\")]\n-impl From<Ipv4Addr> for u32 {\n-    /// Converts an `Ipv4Addr` into a host byte order `u32`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::new(0x12, 0x34, 0x56, 0x78);\n-    /// assert_eq!(0x12345678, u32::from(addr));\n-    /// ```\n-    #[inline]\n-    fn from(ip: Ipv4Addr) -> u32 {\n-        u32::from_be_bytes(ip.octets)\n-    }\n-}\n-\n-#[stable(feature = \"ip_u32\", since = \"1.1.0\")]\n-impl From<u32> for Ipv4Addr {\n-    /// Converts a host byte order `u32` into an `Ipv4Addr`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::from(0x12345678);\n-    /// assert_eq!(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78), addr);\n-    /// ```\n-    #[inline]\n-    fn from(ip: u32) -> Ipv4Addr {\n-        Ipv4Addr { octets: ip.to_be_bytes() }\n-    }\n-}\n-\n-#[stable(feature = \"from_slice_v4\", since = \"1.9.0\")]\n-impl From<[u8; 4]> for Ipv4Addr {\n-    /// Creates an `Ipv4Addr` from a four element byte array.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv4Addr;\n-    ///\n-    /// let addr = Ipv4Addr::from([13u8, 12u8, 11u8, 10u8]);\n-    /// assert_eq!(Ipv4Addr::new(13, 12, 11, 10), addr);\n-    /// ```\n-    #[inline]\n-    fn from(octets: [u8; 4]) -> Ipv4Addr {\n-        Ipv4Addr { octets }\n-    }\n-}\n-\n-#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n-impl From<[u8; 4]> for IpAddr {\n-    /// Creates an `IpAddr::V4` from a four element byte array.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr};\n-    ///\n-    /// let addr = IpAddr::from([13u8, 12u8, 11u8, 10u8]);\n-    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(13, 12, 11, 10)), addr);\n-    /// ```\n-    #[inline]\n-    fn from(octets: [u8; 4]) -> IpAddr {\n-        IpAddr::V4(Ipv4Addr::from(octets))\n-    }\n-}\n-\n-impl Ipv6Addr {\n-    /// Creates a new IPv6 address from eight 16-bit segments.\n-    ///\n-    /// The result will represent the IP address `a:b:c:d:e:f:g:h`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {\n-        let addr16 = [\n-            a.to_be(),\n-            b.to_be(),\n-            c.to_be(),\n-            d.to_be(),\n-            e.to_be(),\n-            f.to_be(),\n-            g.to_be(),\n-            h.to_be(),\n-        ];\n-        Ipv6Addr {\n-            // All elements in `addr16` are big endian.\n-            // SAFETY: `[u16; 8]` is always safe to transmute to `[u8; 16]`.\n-            octets: unsafe { transmute::<_, [u8; 16]>(addr16) },\n-        }\n-    }\n-\n-    /// An IPv6 address representing localhost: `::1`.\n-    ///\n-    /// This corresponds to constant `IN6ADDR_LOOPBACK_INIT` or `in6addr_loopback` in other\n-    /// languages.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// let addr = Ipv6Addr::LOCALHOST;\n-    /// assert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n-    /// ```\n-    #[doc(alias = \"IN6ADDR_LOOPBACK_INIT\")]\n-    #[doc(alias = \"in6addr_loopback\")]\n-    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n-    pub const LOCALHOST: Self = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n-\n-    /// An IPv6 address representing the unspecified address: `::`\n-    ///\n-    /// This corresponds to constant `IN6ADDR_ANY_INIT` or `in6addr_any` in other languages.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// let addr = Ipv6Addr::UNSPECIFIED;\n-    /// assert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n-    /// ```\n-    #[doc(alias = \"IN6ADDR_ANY_INIT\")]\n-    #[doc(alias = \"in6addr_any\")]\n-    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n-    pub const UNSPECIFIED: Self = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0);\n-\n-    /// Returns the eight 16-bit segments that make up this address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).segments(),\n-    ///            [0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff]);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn segments(&self) -> [u16; 8] {\n-        // All elements in `self.octets` must be big endian.\n-        // SAFETY: `[u8; 16]` is always safe to transmute to `[u16; 8]`.\n-        let [a, b, c, d, e, f, g, h] = unsafe { transmute::<_, [u16; 8]>(self.octets) };\n-        // We want native endian u16\n-        [\n-            u16::from_be(a),\n-            u16::from_be(b),\n-            u16::from_be(c),\n-            u16::from_be(d),\n-            u16::from_be(e),\n-            u16::from_be(f),\n-            u16::from_be(g),\n-            u16::from_be(h),\n-        ]\n-    }\n-\n-    /// Returns [`true`] for the special 'unspecified' address (`::`).\n-    ///\n-    /// This property is defined in [IETF RFC 4291].\n-    ///\n-    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unspecified(), false);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).is_unspecified(), true);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_unspecified(&self) -> bool {\n-        u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::UNSPECIFIED.octets())\n-    }\n-\n-    /// Returns [`true`] if this is the [loopback address] (`::1`),\n-    /// as defined in [IETF RFC 4291 section 2.5.3].\n-    ///\n-    /// Contrary to IPv4, in IPv6 there is only one loopback address.\n-    ///\n-    /// [loopback address]: Ipv6Addr::LOCALHOST\n-    /// [IETF RFC 4291 section 2.5.3]: https://tools.ietf.org/html/rfc4291#section-2.5.3\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_loopback(), false);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_loopback(), true);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_loopback(&self) -> bool {\n-        u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::LOCALHOST.octets())\n-    }\n-\n-    /// Returns [`true`] if the address appears to be globally reachable\n-    /// as specified by the [IANA IPv6 Special-Purpose Address Registry].\n-    /// Whether or not an address is practically reachable will depend on your network configuration.\n-    ///\n-    /// Most IPv6 addresses are globally reachable;\n-    /// unless they are specifically defined as *not* globally reachable.\n-    ///\n-    /// Non-exhaustive list of notable addresses that are not globally reachable:\n-    /// - The [unspecified address] ([`is_unspecified`](Ipv6Addr::is_unspecified))\n-    /// - The [loopback address] ([`is_loopback`](Ipv6Addr::is_loopback))\n-    /// - IPv4-mapped addresses\n-    /// - Addresses reserved for benchmarking\n-    /// - Addresses reserved for documentation ([`is_documentation`](Ipv6Addr::is_documentation))\n-    /// - Unique local addresses ([`is_unique_local`](Ipv6Addr::is_unique_local))\n-    /// - Unicast addresses with link-local scope ([`is_unicast_link_local`](Ipv6Addr::is_unicast_link_local))\n-    ///\n-    /// For the complete overview of which addresses are globally reachable, see the table at the [IANA IPv6 Special-Purpose Address Registry].\n-    ///\n-    /// Note that an address having global scope is not the same as being globally reachable,\n-    /// and there is no direct relation between the two concepts: There exist addresses with global scope\n-    /// that are not globally reachable (for example unique local addresses),\n-    /// and addresses that are globally reachable without having global scope\n-    /// (multicast addresses with non-global scope).\n-    ///\n-    /// [IANA IPv6 Special-Purpose Address Registry]: https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml\n-    /// [unspecified address]: Ipv6Addr::UNSPECIFIED\n-    /// [loopback address]: Ipv6Addr::LOCALHOST\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// // Most IPv6 addresses are globally reachable:\n-    /// assert_eq!(Ipv6Addr::new(0x26, 0, 0x1c9, 0, 0, 0xafc8, 0x10, 0x1).is_global(), true);\n-    ///\n-    /// // However some addresses have been assigned a special meaning\n-    /// // that makes them not globally reachable. Some examples are:\n-    ///\n-    /// // The unspecified address (`::`)\n-    /// assert_eq!(Ipv6Addr::UNSPECIFIED.is_global(), false);\n-    ///\n-    /// // The loopback address (`::1`)\n-    /// assert_eq!(Ipv6Addr::LOCALHOST.is_global(), false);\n-    ///\n-    /// // IPv4-mapped addresses (`::ffff:0:0/96`)\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), false);\n-    ///\n-    /// // Addresses reserved for benchmarking (`2001:2::/48`)\n-    /// assert_eq!(Ipv6Addr::new(0x2001, 2, 0, 0, 0, 0, 0, 1,).is_global(), false);\n-    ///\n-    /// // Addresses reserved for documentation (`2001:db8::/32`)\n-    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1).is_global(), false);\n-    ///\n-    /// // Unique local addresses (`fc00::/7`)\n-    /// assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 1).is_global(), false);\n-    ///\n-    /// // Unicast addresses with link-local scope (`fe80::/10`)\n-    /// assert_eq!(Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 1).is_global(), false);\n-    ///\n-    /// // For a complete overview see the IANA IPv6 Special-Purpose Address Registry.\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_global(&self) -> bool {\n-        !(self.is_unspecified()\n-            || self.is_loopback()\n-            // IPv4-mapped Address (`::ffff:0:0/96`)\n-            || matches!(self.segments(), [0, 0, 0, 0, 0, 0xffff, _, _])\n-            // IPv4-IPv6 Translat. (`64:ff9b:1::/48`)\n-            || matches!(self.segments(), [0x64, 0xff9b, 1, _, _, _, _, _])\n-            // Discard-Only Address Block (`100::/64`)\n-            || matches!(self.segments(), [0x100, 0, 0, 0, _, _, _, _])\n-            // IETF Protocol Assignments (`2001::/23`)\n-            || (matches!(self.segments(), [0x2001, b, _, _, _, _, _, _] if b < 0x200)\n-                && !(\n-                    // Port Control Protocol Anycast (`2001:1::1`)\n-                    u128::from_be_bytes(self.octets()) == 0x2001_0001_0000_0000_0000_0000_0000_0001\n-                    // Traversal Using Relays around NAT Anycast (`2001:1::2`)\n-                    || u128::from_be_bytes(self.octets()) == 0x2001_0001_0000_0000_0000_0000_0000_0002\n-                    // AMT (`2001:3::/32`)\n-                    || matches!(self.segments(), [0x2001, 3, _, _, _, _, _, _])\n-                    // AS112-v6 (`2001:4:112::/48`)\n-                    || matches!(self.segments(), [0x2001, 4, 0x112, _, _, _, _, _])\n-                    // ORCHIDv2 (`2001:20::/28`)\n-                    || matches!(self.segments(), [0x2001, b, _, _, _, _, _, _] if b >= 0x20 && b <= 0x2F)\n-                ))\n-            || self.is_documentation()\n-            || self.is_unique_local()\n-            || self.is_unicast_link_local())\n-    }\n-\n-    /// Returns [`true`] if this is a unique local address (`fc00::/7`).\n-    ///\n-    /// This property is defined in [IETF RFC 4193].\n-    ///\n-    /// [IETF RFC 4193]: https://tools.ietf.org/html/rfc4193\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unique_local(), false);\n-    /// assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 0).is_unique_local(), true);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_unique_local(&self) -> bool {\n-        (self.segments()[0] & 0xfe00) == 0xfc00\n-    }\n-\n-    /// Returns [`true`] if this is a unicast address, as defined by [IETF RFC 4291].\n-    /// Any address that is not a [multicast address] (`ff00::/8`) is unicast.\n-    ///\n-    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n-    /// [multicast address]: Ipv6Addr::is_multicast\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// // The unspecified and loopback addresses are unicast.\n-    /// assert_eq!(Ipv6Addr::UNSPECIFIED.is_unicast(), true);\n-    /// assert_eq!(Ipv6Addr::LOCALHOST.is_unicast(), true);\n-    ///\n-    /// // Any address that is not a multicast address (`ff00::/8`) is unicast.\n-    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast(), true);\n-    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_unicast(), false);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_unicast(&self) -> bool {\n-        !self.is_multicast()\n-    }\n-\n-    /// Returns `true` if the address is a unicast address with link-local scope,\n-    /// as defined in [RFC 4291].\n-    ///\n-    /// A unicast address has link-local scope if it has the prefix `fe80::/10`, as per [RFC 4291 section 2.4].\n-    /// Note that this encompasses more addresses than those defined in [RFC 4291 section 2.5.6],\n-    /// which describes \"Link-Local IPv6 Unicast Addresses\" as having the following stricter format:\n-    ///\n-    /// ```text\n-    /// | 10 bits  |         54 bits         |          64 bits           |\n-    /// +----------+-------------------------+----------------------------+\n-    /// |1111111010|           0             |       interface ID         |\n-    /// +----------+-------------------------+----------------------------+\n-    /// ```\n-    /// So while currently the only addresses with link-local scope an application will encounter are all in `fe80::/64`,\n-    /// this might change in the future with the publication of new standards. More addresses in `fe80::/10` could be allocated,\n-    /// and those addresses will have link-local scope.\n-    ///\n-    /// Also note that while [RFC 4291 section 2.5.3] mentions about the [loopback address] (`::1`) that \"it is treated as having Link-Local scope\",\n-    /// this does not mean that the loopback address actually has link-local scope and this method will return `false` on it.\n-    ///\n-    /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n-    /// [RFC 4291 section 2.4]: https://tools.ietf.org/html/rfc4291#section-2.4\n-    /// [RFC 4291 section 2.5.3]: https://tools.ietf.org/html/rfc4291#section-2.5.3\n-    /// [RFC 4291 section 2.5.6]: https://tools.ietf.org/html/rfc4291#section-2.5.6\n-    /// [loopback address]: Ipv6Addr::LOCALHOST\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// // The loopback address (`::1`) does not actually have link-local scope.\n-    /// assert_eq!(Ipv6Addr::LOCALHOST.is_unicast_link_local(), false);\n-    ///\n-    /// // Only addresses in `fe80::/10` have link-local scope.\n-    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), false);\n-    /// assert_eq!(Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), true);\n-    ///\n-    /// // Addresses outside the stricter `fe80::/64` also have link-local scope.\n-    /// assert_eq!(Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0).is_unicast_link_local(), true);\n-    /// assert_eq!(Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0).is_unicast_link_local(), true);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_unicast_link_local(&self) -> bool {\n-        (self.segments()[0] & 0xffc0) == 0xfe80\n-    }\n-\n-    /// Returns [`true`] if this is an address reserved for documentation\n-    /// (`2001:db8::/32`).\n-    ///\n-    /// This property is defined in [IETF RFC 3849].\n-    ///\n-    /// [IETF RFC 3849]: https://tools.ietf.org/html/rfc3849\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_documentation(), false);\n-    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_documentation(), true);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_documentation(&self) -> bool {\n-        (self.segments()[0] == 0x2001) && (self.segments()[1] == 0xdb8)\n-    }\n-\n-    /// Returns [`true`] if this is an address reserved for benchmarking (`2001:2::/48`).\n-    ///\n-    /// This property is defined in [IETF RFC 5180], where it is mistakenly specified as covering the range `2001:0200::/48`.\n-    /// This is corrected in [IETF RFC Errata 1752] to `2001:0002::/48`.\n-    ///\n-    /// [IETF RFC 5180]: https://tools.ietf.org/html/rfc5180\n-    /// [IETF RFC Errata 1752]: https://www.rfc-editor.org/errata_search.php?eid=1752\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc613, 0x0).is_benchmarking(), false);\n-    /// assert_eq!(Ipv6Addr::new(0x2001, 0x2, 0, 0, 0, 0, 0, 0).is_benchmarking(), true);\n-    /// ```\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_benchmarking(&self) -> bool {\n-        (self.segments()[0] == 0x2001) && (self.segments()[1] == 0x2) && (self.segments()[2] == 0)\n-    }\n-\n-    /// Returns [`true`] if the address is a globally routable unicast address.\n-    ///\n-    /// The following return false:\n-    ///\n-    /// - the loopback address\n-    /// - the link-local addresses\n-    /// - unique local addresses\n-    /// - the unspecified address\n-    /// - the address range reserved for documentation\n-    ///\n-    /// This method returns [`true`] for site-local addresses as per [RFC 4291 section 2.5.7]\n-    ///\n-    /// ```no_rust\n-    /// The special behavior of [the site-local unicast] prefix defined in [RFC3513] must no longer\n-    /// be supported in new implementations (i.e., new implementations must treat this prefix as\n-    /// Global Unicast).\n-    /// ```\n-    ///\n-    /// [RFC 4291 section 2.5.7]: https://tools.ietf.org/html/rfc4291#section-2.5.7\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_global(), false);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_global(), true);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_unicast_global(&self) -> bool {\n-        self.is_unicast()\n-            && !self.is_loopback()\n-            && !self.is_unicast_link_local()\n-            && !self.is_unique_local()\n-            && !self.is_unspecified()\n-            && !self.is_documentation()\n-            && !self.is_benchmarking()\n-    }\n-\n-    /// Returns the address's multicast scope if the address is multicast.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    ///\n-    /// use std::net::{Ipv6Addr, Ipv6MulticastScope};\n-    ///\n-    /// assert_eq!(\n-    ///     Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0).multicast_scope(),\n-    ///     Some(Ipv6MulticastScope::Global)\n-    /// );\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).multicast_scope(), None);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn multicast_scope(&self) -> Option<Ipv6MulticastScope> {\n-        if self.is_multicast() {\n-            match self.segments()[0] & 0x000f {\n-                1 => Some(Ipv6MulticastScope::InterfaceLocal),\n-                2 => Some(Ipv6MulticastScope::LinkLocal),\n-                3 => Some(Ipv6MulticastScope::RealmLocal),\n-                4 => Some(Ipv6MulticastScope::AdminLocal),\n-                5 => Some(Ipv6MulticastScope::SiteLocal),\n-                8 => Some(Ipv6MulticastScope::OrganizationLocal),\n-                14 => Some(Ipv6MulticastScope::Global),\n-                _ => None,\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Returns [`true`] if this is a multicast address (`ff00::/8`).\n-    ///\n-    /// This property is defined by [IETF RFC 4291].\n-    ///\n-    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_multicast(), true);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_multicast(), false);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn is_multicast(&self) -> bool {\n-        (self.segments()[0] & 0xff00) == 0xff00\n-    }\n-\n-    /// Converts this address to an [`IPv4` address] if it's an [IPv4-mapped] address,\n-    /// as defined in [IETF RFC 4291 section 2.5.5.2], otherwise returns [`None`].\n-    ///\n-    /// `::ffff:a.b.c.d` becomes `a.b.c.d`.\n-    /// All addresses *not* starting with `::ffff` will return `None`.\n-    ///\n-    /// [`IPv4` address]: Ipv4Addr\n-    /// [IPv4-mapped]: Ipv6Addr\n-    /// [IETF RFC 4291 section 2.5.5.2]: https://tools.ietf.org/html/rfc4291#section-2.5.5.2\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4_mapped(), None);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4_mapped(),\n-    ///            Some(Ipv4Addr::new(192, 10, 2, 255)));\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4_mapped(), None);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[stable(feature = \"ipv6_to_ipv4_mapped\", since = \"1.63.0\")]\n-    #[must_use = \"this returns the result of the operation, \\\n-                  without modifying the original\"]\n-    #[inline]\n-    pub const fn to_ipv4_mapped(&self) -> Option<Ipv4Addr> {\n-        match self.octets() {\n-            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, a, b, c, d] => {\n-                Some(Ipv4Addr::new(a, b, c, d))\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    /// Converts this address to an [`IPv4` address] if it is either\n-    /// an [IPv4-compatible] address as defined in [IETF RFC 4291 section 2.5.5.1],\n-    /// or an [IPv4-mapped] address as defined in [IETF RFC 4291 section 2.5.5.2],\n-    /// otherwise returns [`None`].\n-    ///\n-    /// Note that this will return an [`IPv4` address] for the IPv6 loopback address `::1`. Use\n-    /// [`Ipv6Addr::to_ipv4_mapped`] to avoid this.\n-    ///\n-    /// `::a.b.c.d` and `::ffff:a.b.c.d` become `a.b.c.d`. `::1` becomes `0.0.0.1`.\n-    /// All addresses *not* starting with either all zeroes or `::ffff` will return `None`.\n-    ///\n-    /// [`IPv4` address]: Ipv4Addr\n-    /// [IPv4-compatible]: Ipv6Addr#ipv4-compatible-ipv6-addresses\n-    /// [IPv4-mapped]: Ipv6Addr#ipv4-mapped-ipv6-addresses\n-    /// [IETF RFC 4291 section 2.5.5.1]: https://tools.ietf.org/html/rfc4291#section-2.5.5.1\n-    /// [IETF RFC 4291 section 2.5.5.2]: https://tools.ietf.org/html/rfc4291#section-2.5.5.2\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{Ipv4Addr, Ipv6Addr};\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4(), None);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4(),\n-    ///            Some(Ipv4Addr::new(192, 10, 2, 255)));\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4(),\n-    ///            Some(Ipv4Addr::new(0, 0, 0, 1)));\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_50\", since = \"1.50.0\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use = \"this returns the result of the operation, \\\n-                  without modifying the original\"]\n-    #[inline]\n-    pub const fn to_ipv4(&self) -> Option<Ipv4Addr> {\n-        if let [0, 0, 0, 0, 0, 0 | 0xffff, ab, cd] = self.segments() {\n-            let [a, b] = ab.to_be_bytes();\n-            let [c, d] = cd.to_be_bytes();\n-            Some(Ipv4Addr::new(a, b, c, d))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Converts this address to an `IpAddr::V4` if it is an IPv4-mapped addresses, otherwise it\n-    /// returns self wrapped in an `IpAddr::V6`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ip)]\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1).is_loopback(), false);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x7f00, 0x1).to_canonical().is_loopback(), true);\n-    /// ```\n-    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n-    #[unstable(feature = \"ip\", issue = \"27709\")]\n-    #[must_use = \"this returns the result of the operation, \\\n-                  without modifying the original\"]\n-    #[inline]\n-    pub const fn to_canonical(&self) -> IpAddr {\n-        if let Some(mapped) = self.to_ipv4_mapped() {\n-            return IpAddr::V4(mapped);\n-        }\n-        IpAddr::V6(*self)\n-    }\n-\n-    /// Returns the sixteen eight-bit integers the IPv6 address consists of.\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).octets(),\n-    ///            [255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n-    /// ```\n-    #[rustc_const_stable(feature = \"const_ip_32\", since = \"1.32.0\")]\n-    #[stable(feature = \"ipv6_to_octets\", since = \"1.12.0\")]\n-    #[must_use]\n-    #[inline]\n-    pub const fn octets(&self) -> [u8; 16] {\n-        self.octets\n-    }\n-}\n-\n-/// Write an Ipv6Addr, conforming to the canonical style described by\n-/// [RFC 5952](https://tools.ietf.org/html/rfc5952).\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for Ipv6Addr {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // If there are no alignment requirements, write the IP address directly to `f`.\n-        // Otherwise, write it to a local buffer and then use `f.pad`.\n-        if f.precision().is_none() && f.width().is_none() {\n-            let segments = self.segments();\n-\n-            // Special case for :: and ::1; otherwise they get written with the\n-            // IPv4 formatter\n-            if self.is_unspecified() {\n-                f.write_str(\"::\")\n-            } else if self.is_loopback() {\n-                f.write_str(\"::1\")\n-            } else if let Some(ipv4) = self.to_ipv4() {\n-                match segments[5] {\n-                    // IPv4 Compatible address\n-                    0 => write!(f, \"::{}\", ipv4),\n-                    // IPv4 Mapped address\n-                    0xffff => write!(f, \"::ffff:{}\", ipv4),\n-                    _ => unreachable!(),\n-                }\n-            } else {\n-                #[derive(Copy, Clone, Default)]\n-                struct Span {\n-                    start: usize,\n-                    len: usize,\n-                }\n-\n-                // Find the inner 0 span\n-                let zeroes = {\n-                    let mut longest = Span::default();\n-                    let mut current = Span::default();\n-\n-                    for (i, &segment) in segments.iter().enumerate() {\n-                        if segment == 0 {\n-                            if current.len == 0 {\n-                                current.start = i;\n-                            }\n-\n-                            current.len += 1;\n-\n-                            if current.len > longest.len {\n-                                longest = current;\n-                            }\n-                        } else {\n-                            current = Span::default();\n-                        }\n-                    }\n-\n-                    longest\n-                };\n-\n-                /// Write a colon-separated part of the address\n-                #[inline]\n-                fn fmt_subslice(f: &mut fmt::Formatter<'_>, chunk: &[u16]) -> fmt::Result {\n-                    if let Some((first, tail)) = chunk.split_first() {\n-                        write!(f, \"{:x}\", first)?;\n-                        for segment in tail {\n-                            f.write_char(':')?;\n-                            write!(f, \"{:x}\", segment)?;\n-                        }\n-                    }\n-                    Ok(())\n-                }\n-\n-                if zeroes.len > 1 {\n-                    fmt_subslice(f, &segments[..zeroes.start])?;\n-                    f.write_str(\"::\")?;\n-                    fmt_subslice(f, &segments[zeroes.start + zeroes.len..])\n-                } else {\n-                    fmt_subslice(f, &segments)\n-                }\n-            }\n-        } else {\n-            const LONGEST_IPV6_ADDR: &str = \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\";\n-\n-            let mut buf = DisplayBuffer::<{ LONGEST_IPV6_ADDR.len() }>::new();\n-            // Buffer is long enough for the longest possible IPv6 address, so this should never fail.\n-            write!(buf, \"{}\", self).unwrap();\n-\n-            f.pad(buf.as_str())\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for Ipv6Addr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialEq<IpAddr> for Ipv6Addr {\n-    #[inline]\n-    fn eq(&self, other: &IpAddr) -> bool {\n-        match other {\n-            IpAddr::V4(_) => false,\n-            IpAddr::V6(v6) => self == v6,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialEq<Ipv6Addr> for IpAddr {\n-    #[inline]\n-    fn eq(&self, other: &Ipv6Addr) -> bool {\n-        match self {\n-            IpAddr::V4(_) => false,\n-            IpAddr::V6(v6) => v6 == other,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialOrd for Ipv6Addr {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialOrd<Ipv6Addr> for IpAddr {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n-        match self {\n-            IpAddr::V4(_) => Some(Ordering::Less),\n-            IpAddr::V6(v6) => v6.partial_cmp(other),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\n-impl PartialOrd<IpAddr> for Ipv6Addr {\n-    #[inline]\n-    fn partial_cmp(&self, other: &IpAddr) -> Option<Ordering> {\n-        match other {\n-            IpAddr::V4(_) => Some(Ordering::Greater),\n-            IpAddr::V6(v6) => self.partial_cmp(v6),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Ord for Ipv6Addr {\n-    #[inline]\n-    fn cmp(&self, other: &Ipv6Addr) -> Ordering {\n-        self.segments().cmp(&other.segments())\n+        Ipv4Addr::from(addr.s_addr.to_ne_bytes())\n     }\n }\n \n impl IntoInner<c::in6_addr> for Ipv6Addr {\n     fn into_inner(self) -> c::in6_addr {\n-        c::in6_addr { s6_addr: self.octets }\n+        c::in6_addr { s6_addr: self.octets() }\n     }\n }\n impl FromInner<c::in6_addr> for Ipv6Addr {\n     #[inline]\n     fn from_inner(addr: c::in6_addr) -> Ipv6Addr {\n-        Ipv6Addr { octets: addr.s6_addr }\n-    }\n-}\n-\n-#[stable(feature = \"i128\", since = \"1.26.0\")]\n-impl From<Ipv6Addr> for u128 {\n-    /// Convert an `Ipv6Addr` into a host byte order `u128`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// let addr = Ipv6Addr::new(\n-    ///     0x1020, 0x3040, 0x5060, 0x7080,\n-    ///     0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n-    /// );\n-    /// assert_eq!(0x102030405060708090A0B0C0D0E0F00D_u128, u128::from(addr));\n-    /// ```\n-    #[inline]\n-    fn from(ip: Ipv6Addr) -> u128 {\n-        u128::from_be_bytes(ip.octets)\n-    }\n-}\n-#[stable(feature = \"i128\", since = \"1.26.0\")]\n-impl From<u128> for Ipv6Addr {\n-    /// Convert a host byte order `u128` into an `Ipv6Addr`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// let addr = Ipv6Addr::from(0x102030405060708090A0B0C0D0E0F00D_u128);\n-    /// assert_eq!(\n-    ///     Ipv6Addr::new(\n-    ///         0x1020, 0x3040, 0x5060, 0x7080,\n-    ///         0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n-    ///     ),\n-    ///     addr);\n-    /// ```\n-    #[inline]\n-    fn from(ip: u128) -> Ipv6Addr {\n-        Ipv6Addr::from(ip.to_be_bytes())\n-    }\n-}\n-\n-#[stable(feature = \"ipv6_from_octets\", since = \"1.9.0\")]\n-impl From<[u8; 16]> for Ipv6Addr {\n-    /// Creates an `Ipv6Addr` from a sixteen element byte array.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// let addr = Ipv6Addr::from([\n-    ///     25u8, 24u8, 23u8, 22u8, 21u8, 20u8, 19u8, 18u8,\n-    ///     17u8, 16u8, 15u8, 14u8, 13u8, 12u8, 11u8, 10u8,\n-    /// ]);\n-    /// assert_eq!(\n-    ///     Ipv6Addr::new(\n-    ///         0x1918, 0x1716,\n-    ///         0x1514, 0x1312,\n-    ///         0x1110, 0x0f0e,\n-    ///         0x0d0c, 0x0b0a\n-    ///     ),\n-    ///     addr\n-    /// );\n-    /// ```\n-    #[inline]\n-    fn from(octets: [u8; 16]) -> Ipv6Addr {\n-        Ipv6Addr { octets }\n-    }\n-}\n-\n-#[stable(feature = \"ipv6_from_segments\", since = \"1.16.0\")]\n-impl From<[u16; 8]> for Ipv6Addr {\n-    /// Creates an `Ipv6Addr` from an eight element 16-bit array.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::Ipv6Addr;\n-    ///\n-    /// let addr = Ipv6Addr::from([\n-    ///     525u16, 524u16, 523u16, 522u16,\n-    ///     521u16, 520u16, 519u16, 518u16,\n-    /// ]);\n-    /// assert_eq!(\n-    ///     Ipv6Addr::new(\n-    ///         0x20d, 0x20c,\n-    ///         0x20b, 0x20a,\n-    ///         0x209, 0x208,\n-    ///         0x207, 0x206\n-    ///     ),\n-    ///     addr\n-    /// );\n-    /// ```\n-    #[inline]\n-    fn from(segments: [u16; 8]) -> Ipv6Addr {\n-        let [a, b, c, d, e, f, g, h] = segments;\n-        Ipv6Addr::new(a, b, c, d, e, f, g, h)\n-    }\n-}\n-\n-#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n-impl From<[u8; 16]> for IpAddr {\n-    /// Creates an `IpAddr::V6` from a sixteen element byte array.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv6Addr};\n-    ///\n-    /// let addr = IpAddr::from([\n-    ///     25u8, 24u8, 23u8, 22u8, 21u8, 20u8, 19u8, 18u8,\n-    ///     17u8, 16u8, 15u8, 14u8, 13u8, 12u8, 11u8, 10u8,\n-    /// ]);\n-    /// assert_eq!(\n-    ///     IpAddr::V6(Ipv6Addr::new(\n-    ///         0x1918, 0x1716,\n-    ///         0x1514, 0x1312,\n-    ///         0x1110, 0x0f0e,\n-    ///         0x0d0c, 0x0b0a\n-    ///     )),\n-    ///     addr\n-    /// );\n-    /// ```\n-    #[inline]\n-    fn from(octets: [u8; 16]) -> IpAddr {\n-        IpAddr::V6(Ipv6Addr::from(octets))\n-    }\n-}\n-\n-#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\n-impl From<[u16; 8]> for IpAddr {\n-    /// Creates an `IpAddr::V6` from an eight element 16-bit array.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv6Addr};\n-    ///\n-    /// let addr = IpAddr::from([\n-    ///     525u16, 524u16, 523u16, 522u16,\n-    ///     521u16, 520u16, 519u16, 518u16,\n-    /// ]);\n-    /// assert_eq!(\n-    ///     IpAddr::V6(Ipv6Addr::new(\n-    ///         0x20d, 0x20c,\n-    ///         0x20b, 0x20a,\n-    ///         0x209, 0x208,\n-    ///         0x207, 0x206\n-    ///     )),\n-    ///     addr\n-    /// );\n-    /// ```\n-    #[inline]\n-    fn from(segments: [u16; 8]) -> IpAddr {\n-        IpAddr::V6(Ipv6Addr::from(segments))\n+        Ipv6Addr::from(addr.s6_addr)\n     }\n }"}, {"sha": "ab99c0c2fcc160cf57817ee3c93c023ff94e4d55", "filename": "library/std/src/net/ip_addr/tests.rs", "status": "modified", "additions": 2, "deletions": 1033, "changes": 1035, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fnet%2Fip_addr%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fnet%2Fip_addr%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip_addr%2Ftests.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,1039 +1,8 @@\n-use crate::net::test::{sa4, sa6, tsa};\n-use crate::net::*;\n-use crate::str::FromStr;\n-\n-#[test]\n-fn test_from_str_ipv4() {\n-    assert_eq!(Ok(Ipv4Addr::new(127, 0, 0, 1)), \"127.0.0.1\".parse());\n-    assert_eq!(Ok(Ipv4Addr::new(255, 255, 255, 255)), \"255.255.255.255\".parse());\n-    assert_eq!(Ok(Ipv4Addr::new(0, 0, 0, 0)), \"0.0.0.0\".parse());\n-\n-    // out of range\n-    let none: Option<Ipv4Addr> = \"256.0.0.1\".parse().ok();\n-    assert_eq!(None, none);\n-    // too short\n-    let none: Option<Ipv4Addr> = \"255.0.0\".parse().ok();\n-    assert_eq!(None, none);\n-    // too long\n-    let none: Option<Ipv4Addr> = \"255.0.0.1.2\".parse().ok();\n-    assert_eq!(None, none);\n-    // no number between dots\n-    let none: Option<Ipv4Addr> = \"255.0..1\".parse().ok();\n-    assert_eq!(None, none);\n-    // octal\n-    let none: Option<Ipv4Addr> = \"255.0.0.01\".parse().ok();\n-    assert_eq!(None, none);\n-    // octal zero\n-    let none: Option<Ipv4Addr> = \"255.0.0.00\".parse().ok();\n-    assert_eq!(None, none);\n-    let none: Option<Ipv4Addr> = \"255.0.00.0\".parse().ok();\n-    assert_eq!(None, none);\n-}\n-\n-#[test]\n-fn test_from_str_ipv6() {\n-    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n-    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n-\n-    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n-    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n-\n-    assert_eq!(Ok(Ipv6Addr::new(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)), \"2a02:6b8::11:11\".parse());\n-\n-    // too long group\n-    let none: Option<Ipv6Addr> = \"::00000\".parse().ok();\n-    assert_eq!(None, none);\n-    // too short\n-    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7\".parse().ok();\n-    assert_eq!(None, none);\n-    // too long\n-    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n-    assert_eq!(None, none);\n-    // triple colon\n-    let none: Option<Ipv6Addr> = \"1:2:::6:7:8\".parse().ok();\n-    assert_eq!(None, none);\n-    // two double colons\n-    let none: Option<Ipv6Addr> = \"1:2::6::8\".parse().ok();\n-    assert_eq!(None, none);\n-    // `::` indicating zero groups of zeros\n-    let none: Option<Ipv6Addr> = \"1:2:3:4::5:6:7:8\".parse().ok();\n-    assert_eq!(None, none);\n-}\n-\n-#[test]\n-fn test_from_str_ipv4_in_ipv6() {\n-    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 545)), \"::192.0.2.33\".parse());\n-    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)), \"::FFFF:192.0.2.33\".parse());\n-    assert_eq!(\n-        Ok(Ipv6Addr::new(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n-        \"64:ff9b::192.0.2.33\".parse()\n-    );\n-    assert_eq!(\n-        Ok(Ipv6Addr::new(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n-        \"2001:db8:122:c000:2:2100:192.0.2.33\".parse()\n-    );\n-\n-    // colon after v4\n-    let none: Option<Ipv4Addr> = \"::127.0.0.1:\".parse().ok();\n-    assert_eq!(None, none);\n-    // not enough groups\n-    let none: Option<Ipv6Addr> = \"1:2:3:4:5:127.0.0.1\".parse().ok();\n-    assert_eq!(None, none);\n-    // too many groups\n-    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:127.0.0.1\".parse().ok();\n-    assert_eq!(None, none);\n-}\n-\n-#[test]\n-fn test_from_str_socket_addr() {\n-    assert_eq!(Ok(sa4(Ipv4Addr::new(77, 88, 21, 11), 80)), \"77.88.21.11:80\".parse());\n-    assert_eq!(Ok(SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80)), \"77.88.21.11:80\".parse());\n-    assert_eq!(\n-        Ok(sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n-        \"[2a02:6b8:0:1::1]:53\".parse()\n-    );\n-    assert_eq!(\n-        Ok(SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53, 0, 0)),\n-        \"[2a02:6b8:0:1::1]:53\".parse()\n-    );\n-    assert_eq!(Ok(sa6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)), \"[::127.0.0.1]:22\".parse());\n-    assert_eq!(\n-        Ok(SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22, 0, 0)),\n-        \"[::127.0.0.1]:22\".parse()\n-    );\n-\n-    // without port\n-    let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n-    assert_eq!(None, none);\n-    // without port\n-    let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n-    assert_eq!(None, none);\n-    // wrong brackets around v4\n-    let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n-    assert_eq!(None, none);\n-    // port out of range\n-    let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n-    assert_eq!(None, none);\n-}\n-\n-#[test]\n-fn ipv4_addr_to_string() {\n-    assert_eq!(Ipv4Addr::new(127, 0, 0, 1).to_string(), \"127.0.0.1\");\n-    // Short address\n-    assert_eq!(Ipv4Addr::new(1, 1, 1, 1).to_string(), \"1.1.1.1\");\n-    // Long address\n-    assert_eq!(Ipv4Addr::new(127, 127, 127, 127).to_string(), \"127.127.127.127\");\n-\n-    // Test padding\n-    assert_eq!(format!(\"{:16}\", Ipv4Addr::new(1, 1, 1, 1)), \"1.1.1.1         \");\n-    assert_eq!(format!(\"{:>16}\", Ipv4Addr::new(1, 1, 1, 1)), \"         1.1.1.1\");\n-}\n-\n-#[test]\n-fn ipv6_addr_to_string() {\n-    // ipv4-mapped address\n-    let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n-    assert_eq!(a1.to_string(), \"::ffff:192.0.2.128\");\n-\n-    // ipv4-compatible address\n-    let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280);\n-    assert_eq!(a1.to_string(), \"::192.0.2.128\");\n-\n-    // v6 address with no zero segments\n-    assert_eq!(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15).to_string(), \"8:9:a:b:c:d:e:f\");\n-\n-    // longest possible IPv6 length\n-    assert_eq!(\n-        Ipv6Addr::new(0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888).to_string(),\n-        \"1111:2222:3333:4444:5555:6666:7777:8888\"\n-    );\n-    // padding\n-    assert_eq!(format!(\"{:20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"1:2:3:4:5:6:7:8     \");\n-    assert_eq!(format!(\"{:>20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"     1:2:3:4:5:6:7:8\");\n-\n-    // reduce a single run of zeros\n-    assert_eq!(\n-        \"ae::ffff:102:304\",\n-        Ipv6Addr::new(0xae, 0, 0, 0, 0, 0xffff, 0x0102, 0x0304).to_string()\n-    );\n-\n-    // don't reduce just a single zero segment\n-    assert_eq!(\"1:2:3:4:5:6:0:8\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 0, 8).to_string());\n-\n-    // 'any' address\n-    assert_eq!(\"::\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).to_string());\n-\n-    // loopback address\n-    assert_eq!(\"::1\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_string());\n-\n-    // ends in zeros\n-    assert_eq!(\"1::\", Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0).to_string());\n-\n-    // two runs of zeros, second one is longer\n-    assert_eq!(\"1:0:0:4::8\", Ipv6Addr::new(1, 0, 0, 4, 0, 0, 0, 8).to_string());\n-\n-    // two runs of zeros, equal length\n-    assert_eq!(\"1::4:5:0:0:8\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8).to_string());\n-\n-    // don't prefix `0x` to each segment in `dbg!`.\n-    assert_eq!(\"1::4:5:0:0:8\", &format!(\"{:#?}\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8)));\n-}\n-\n-#[test]\n-fn ipv4_to_ipv6() {\n-    assert_eq!(\n-        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678),\n-        Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_mapped()\n-    );\n-    assert_eq!(\n-        Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678),\n-        Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_compatible()\n-    );\n-}\n-\n-#[test]\n-fn ipv6_to_ipv4_mapped() {\n-    assert_eq!(\n-        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4_mapped(),\n-        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n-    );\n-    assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4_mapped(), None);\n-}\n-\n-#[test]\n-fn ipv6_to_ipv4() {\n-    assert_eq!(\n-        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4(),\n-        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n-    );\n-    assert_eq!(\n-        Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n-        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n-    );\n-    assert_eq!(Ipv6Addr::new(0, 0, 1, 0, 0, 0, 0x1234, 0x5678).to_ipv4(), None);\n-}\n-\n-#[test]\n-fn ip_properties() {\n-    macro_rules! ip {\n-        ($s:expr) => {\n-            IpAddr::from_str($s).unwrap()\n-        };\n-    }\n-\n-    macro_rules! check {\n-        ($s:expr) => {\n-            check!($s, 0);\n-        };\n-\n-        ($s:expr, $mask:expr) => {{\n-            let unspec: u8 = 1 << 0;\n-            let loopback: u8 = 1 << 1;\n-            let global: u8 = 1 << 2;\n-            let multicast: u8 = 1 << 3;\n-            let doc: u8 = 1 << 4;\n-            let benchmarking: u8 = 1 << 5;\n-\n-            if ($mask & unspec) == unspec {\n-                assert!(ip!($s).is_unspecified());\n-            } else {\n-                assert!(!ip!($s).is_unspecified());\n-            }\n-\n-            if ($mask & loopback) == loopback {\n-                assert!(ip!($s).is_loopback());\n-            } else {\n-                assert!(!ip!($s).is_loopback());\n-            }\n-\n-            if ($mask & global) == global {\n-                assert!(ip!($s).is_global());\n-            } else {\n-                assert!(!ip!($s).is_global());\n-            }\n-\n-            if ($mask & multicast) == multicast {\n-                assert!(ip!($s).is_multicast());\n-            } else {\n-                assert!(!ip!($s).is_multicast());\n-            }\n-\n-            if ($mask & doc) == doc {\n-                assert!(ip!($s).is_documentation());\n-            } else {\n-                assert!(!ip!($s).is_documentation());\n-            }\n-\n-            if ($mask & benchmarking) == benchmarking {\n-                assert!(ip!($s).is_benchmarking());\n-            } else {\n-                assert!(!ip!($s).is_benchmarking());\n-            }\n-        }};\n-    }\n-\n-    let unspec: u8 = 1 << 0;\n-    let loopback: u8 = 1 << 1;\n-    let global: u8 = 1 << 2;\n-    let multicast: u8 = 1 << 3;\n-    let doc: u8 = 1 << 4;\n-    let benchmarking: u8 = 1 << 5;\n-\n-    check!(\"0.0.0.0\", unspec);\n-    check!(\"0.0.0.1\");\n-    check!(\"0.1.0.0\");\n-    check!(\"10.9.8.7\");\n-    check!(\"127.1.2.3\", loopback);\n-    check!(\"172.31.254.253\");\n-    check!(\"169.254.253.242\");\n-    check!(\"192.0.2.183\", doc);\n-    check!(\"192.1.2.183\", global);\n-    check!(\"192.168.254.253\");\n-    check!(\"198.51.100.0\", doc);\n-    check!(\"203.0.113.0\", doc);\n-    check!(\"203.2.113.0\", global);\n-    check!(\"224.0.0.0\", global | multicast);\n-    check!(\"239.255.255.255\", global | multicast);\n-    check!(\"255.255.255.255\");\n-    // make sure benchmarking addresses are not global\n-    check!(\"198.18.0.0\", benchmarking);\n-    check!(\"198.18.54.2\", benchmarking);\n-    check!(\"198.19.255.255\", benchmarking);\n-    // make sure addresses reserved for protocol assignment are not global\n-    check!(\"192.0.0.0\");\n-    check!(\"192.0.0.255\");\n-    check!(\"192.0.0.100\");\n-    // make sure reserved addresses are not global\n-    check!(\"240.0.0.0\");\n-    check!(\"251.54.1.76\");\n-    check!(\"254.255.255.255\");\n-    // make sure shared addresses are not global\n-    check!(\"100.64.0.0\");\n-    check!(\"100.127.255.255\");\n-    check!(\"100.100.100.0\");\n-\n-    check!(\"::\", unspec);\n-    check!(\"::1\", loopback);\n-    check!(\"::0.0.0.2\", global);\n-    check!(\"1::\", global);\n-    check!(\"fc00::\");\n-    check!(\"fdff:ffff::\");\n-    check!(\"fe80:ffff::\");\n-    check!(\"febf:ffff::\");\n-    check!(\"fec0::\", global);\n-    check!(\"ff01::\", global | multicast);\n-    check!(\"ff02::\", global | multicast);\n-    check!(\"ff03::\", global | multicast);\n-    check!(\"ff04::\", global | multicast);\n-    check!(\"ff05::\", global | multicast);\n-    check!(\"ff08::\", global | multicast);\n-    check!(\"ff0e::\", global | multicast);\n-    check!(\"2001:db8:85a3::8a2e:370:7334\", doc);\n-    check!(\"2001:2::ac32:23ff:21\", benchmarking);\n-    check!(\"102:304:506:708:90a:b0c:d0e:f10\", global);\n-}\n-\n-#[test]\n-fn ipv4_properties() {\n-    macro_rules! ip {\n-        ($s:expr) => {\n-            Ipv4Addr::from_str($s).unwrap()\n-        };\n-    }\n-\n-    macro_rules! check {\n-        ($s:expr) => {\n-            check!($s, 0);\n-        };\n-\n-        ($s:expr, $mask:expr) => {{\n-            let unspec: u16 = 1 << 0;\n-            let loopback: u16 = 1 << 1;\n-            let private: u16 = 1 << 2;\n-            let link_local: u16 = 1 << 3;\n-            let global: u16 = 1 << 4;\n-            let multicast: u16 = 1 << 5;\n-            let broadcast: u16 = 1 << 6;\n-            let documentation: u16 = 1 << 7;\n-            let benchmarking: u16 = 1 << 8;\n-            let reserved: u16 = 1 << 10;\n-            let shared: u16 = 1 << 11;\n-\n-            if ($mask & unspec) == unspec {\n-                assert!(ip!($s).is_unspecified());\n-            } else {\n-                assert!(!ip!($s).is_unspecified());\n-            }\n-\n-            if ($mask & loopback) == loopback {\n-                assert!(ip!($s).is_loopback());\n-            } else {\n-                assert!(!ip!($s).is_loopback());\n-            }\n-\n-            if ($mask & private) == private {\n-                assert!(ip!($s).is_private());\n-            } else {\n-                assert!(!ip!($s).is_private());\n-            }\n-\n-            if ($mask & link_local) == link_local {\n-                assert!(ip!($s).is_link_local());\n-            } else {\n-                assert!(!ip!($s).is_link_local());\n-            }\n-\n-            if ($mask & global) == global {\n-                assert!(ip!($s).is_global());\n-            } else {\n-                assert!(!ip!($s).is_global());\n-            }\n-\n-            if ($mask & multicast) == multicast {\n-                assert!(ip!($s).is_multicast());\n-            } else {\n-                assert!(!ip!($s).is_multicast());\n-            }\n-\n-            if ($mask & broadcast) == broadcast {\n-                assert!(ip!($s).is_broadcast());\n-            } else {\n-                assert!(!ip!($s).is_broadcast());\n-            }\n-\n-            if ($mask & documentation) == documentation {\n-                assert!(ip!($s).is_documentation());\n-            } else {\n-                assert!(!ip!($s).is_documentation());\n-            }\n-\n-            if ($mask & benchmarking) == benchmarking {\n-                assert!(ip!($s).is_benchmarking());\n-            } else {\n-                assert!(!ip!($s).is_benchmarking());\n-            }\n-\n-            if ($mask & reserved) == reserved {\n-                assert!(ip!($s).is_reserved());\n-            } else {\n-                assert!(!ip!($s).is_reserved());\n-            }\n-\n-            if ($mask & shared) == shared {\n-                assert!(ip!($s).is_shared());\n-            } else {\n-                assert!(!ip!($s).is_shared());\n-            }\n-        }};\n-    }\n-\n-    let unspec: u16 = 1 << 0;\n-    let loopback: u16 = 1 << 1;\n-    let private: u16 = 1 << 2;\n-    let link_local: u16 = 1 << 3;\n-    let global: u16 = 1 << 4;\n-    let multicast: u16 = 1 << 5;\n-    let broadcast: u16 = 1 << 6;\n-    let documentation: u16 = 1 << 7;\n-    let benchmarking: u16 = 1 << 8;\n-    let reserved: u16 = 1 << 10;\n-    let shared: u16 = 1 << 11;\n-\n-    check!(\"0.0.0.0\", unspec);\n-    check!(\"0.0.0.1\");\n-    check!(\"0.1.0.0\");\n-    check!(\"10.9.8.7\", private);\n-    check!(\"127.1.2.3\", loopback);\n-    check!(\"172.31.254.253\", private);\n-    check!(\"169.254.253.242\", link_local);\n-    check!(\"192.0.2.183\", documentation);\n-    check!(\"192.1.2.183\", global);\n-    check!(\"192.168.254.253\", private);\n-    check!(\"198.51.100.0\", documentation);\n-    check!(\"203.0.113.0\", documentation);\n-    check!(\"203.2.113.0\", global);\n-    check!(\"224.0.0.0\", global | multicast);\n-    check!(\"239.255.255.255\", global | multicast);\n-    check!(\"255.255.255.255\", broadcast);\n-    check!(\"198.18.0.0\", benchmarking);\n-    check!(\"198.18.54.2\", benchmarking);\n-    check!(\"198.19.255.255\", benchmarking);\n-    check!(\"192.0.0.0\");\n-    check!(\"192.0.0.255\");\n-    check!(\"192.0.0.100\");\n-    check!(\"240.0.0.0\", reserved);\n-    check!(\"251.54.1.76\", reserved);\n-    check!(\"254.255.255.255\", reserved);\n-    check!(\"100.64.0.0\", shared);\n-    check!(\"100.127.255.255\", shared);\n-    check!(\"100.100.100.0\", shared);\n-}\n-\n-#[test]\n-fn ipv6_properties() {\n-    macro_rules! ip {\n-        ($s:expr) => {\n-            Ipv6Addr::from_str($s).unwrap()\n-        };\n-    }\n-\n-    macro_rules! check {\n-        ($s:expr, &[$($octet:expr),*], $mask:expr) => {\n-            assert_eq!($s, ip!($s).to_string());\n-            let octets = &[$($octet),*];\n-            assert_eq!(&ip!($s).octets(), octets);\n-            assert_eq!(Ipv6Addr::from(*octets), ip!($s));\n-\n-            let unspecified: u32 = 1 << 0;\n-            let loopback: u32 = 1 << 1;\n-            let unique_local: u32 = 1 << 2;\n-            let global: u32 = 1 << 3;\n-            let unicast_link_local: u32 = 1 << 4;\n-            let unicast_global: u32 = 1 << 7;\n-            let documentation: u32 = 1 << 8;\n-            let benchmarking: u32 = 1 << 16;\n-            let multicast_interface_local: u32 = 1 << 9;\n-            let multicast_link_local: u32 = 1 << 10;\n-            let multicast_realm_local: u32 = 1 << 11;\n-            let multicast_admin_local: u32 = 1 << 12;\n-            let multicast_site_local: u32 = 1 << 13;\n-            let multicast_organization_local: u32 = 1 << 14;\n-            let multicast_global: u32 = 1 << 15;\n-            let multicast: u32 = multicast_interface_local\n-                | multicast_admin_local\n-                | multicast_global\n-                | multicast_link_local\n-                | multicast_realm_local\n-                | multicast_site_local\n-                | multicast_organization_local;\n-\n-            if ($mask & unspecified) == unspecified {\n-                assert!(ip!($s).is_unspecified());\n-            } else {\n-                assert!(!ip!($s).is_unspecified());\n-            }\n-            if ($mask & loopback) == loopback {\n-                assert!(ip!($s).is_loopback());\n-            } else {\n-                assert!(!ip!($s).is_loopback());\n-            }\n-            if ($mask & unique_local) == unique_local {\n-                assert!(ip!($s).is_unique_local());\n-            } else {\n-                assert!(!ip!($s).is_unique_local());\n-            }\n-            if ($mask & global) == global {\n-                assert!(ip!($s).is_global());\n-            } else {\n-                assert!(!ip!($s).is_global());\n-            }\n-            if ($mask & unicast_link_local) == unicast_link_local {\n-                assert!(ip!($s).is_unicast_link_local());\n-            } else {\n-                assert!(!ip!($s).is_unicast_link_local());\n-            }\n-            if ($mask & unicast_global) == unicast_global {\n-                assert!(ip!($s).is_unicast_global());\n-            } else {\n-                assert!(!ip!($s).is_unicast_global());\n-            }\n-            if ($mask & documentation) == documentation {\n-                assert!(ip!($s).is_documentation());\n-            } else {\n-                assert!(!ip!($s).is_documentation());\n-            }\n-            if ($mask & benchmarking) == benchmarking {\n-                assert!(ip!($s).is_benchmarking());\n-            } else {\n-                assert!(!ip!($s).is_benchmarking());\n-            }\n-            if ($mask & multicast) != 0 {\n-                assert!(ip!($s).multicast_scope().is_some());\n-                assert!(ip!($s).is_multicast());\n-            } else {\n-                assert!(ip!($s).multicast_scope().is_none());\n-                assert!(!ip!($s).is_multicast());\n-            }\n-            if ($mask & multicast_interface_local) == multicast_interface_local {\n-                assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                           Ipv6MulticastScope::InterfaceLocal);\n-            }\n-            if ($mask & multicast_link_local) == multicast_link_local {\n-                assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                           Ipv6MulticastScope::LinkLocal);\n-            }\n-            if ($mask & multicast_realm_local) == multicast_realm_local {\n-                assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                           Ipv6MulticastScope::RealmLocal);\n-            }\n-            if ($mask & multicast_admin_local) == multicast_admin_local {\n-                assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                           Ipv6MulticastScope::AdminLocal);\n-            }\n-            if ($mask & multicast_site_local) == multicast_site_local {\n-                assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                           Ipv6MulticastScope::SiteLocal);\n-            }\n-            if ($mask & multicast_organization_local) == multicast_organization_local {\n-                assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                           Ipv6MulticastScope::OrganizationLocal);\n-            }\n-            if ($mask & multicast_global) == multicast_global {\n-                assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                           Ipv6MulticastScope::Global);\n-            }\n-        }\n-    }\n-\n-    let unspecified: u32 = 1 << 0;\n-    let loopback: u32 = 1 << 1;\n-    let unique_local: u32 = 1 << 2;\n-    let global: u32 = 1 << 3;\n-    let unicast_link_local: u32 = 1 << 4;\n-    let unicast_global: u32 = 1 << 7;\n-    let documentation: u32 = 1 << 8;\n-    let benchmarking: u32 = 1 << 16;\n-    let multicast_interface_local: u32 = 1 << 9;\n-    let multicast_link_local: u32 = 1 << 10;\n-    let multicast_realm_local: u32 = 1 << 11;\n-    let multicast_admin_local: u32 = 1 << 12;\n-    let multicast_site_local: u32 = 1 << 13;\n-    let multicast_organization_local: u32 = 1 << 14;\n-    let multicast_global: u32 = 1 << 15;\n-\n-    check!(\"::\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unspecified);\n-\n-    check!(\"::1\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], loopback);\n-\n-    check!(\"::0.0.0.2\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], global | unicast_global);\n-\n-    check!(\"1::\", &[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], global | unicast_global);\n-\n-    check!(\n-        \"::ffff:127.0.0.1\",\n-        &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, 0x7f, 0, 0, 1],\n-        unicast_global\n-    );\n-\n-    check!(\n-        \"64:ff9b:1::\",\n-        &[0, 0x64, 0xff, 0x9b, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        unicast_global\n-    );\n-\n-    check!(\"100::\", &[0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n-\n-    check!(\"2001::\", &[0x20, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n-\n-    check!(\n-        \"2001:1::1\",\n-        &[0x20, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n-        global | unicast_global\n-    );\n-\n-    check!(\n-        \"2001:1::2\",\n-        &[0x20, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n-        global | unicast_global\n-    );\n-\n-    check!(\n-        \"2001:3::\",\n-        &[0x20, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        global | unicast_global\n-    );\n-\n-    check!(\n-        \"2001:4:112::\",\n-        &[0x20, 1, 0, 4, 1, 0x12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        global | unicast_global\n-    );\n-\n-    check!(\n-        \"2001:20::\",\n-        &[0x20, 1, 0, 0x20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        global | unicast_global\n-    );\n-\n-    check!(\"2001:30::\", &[0x20, 1, 0, 0x30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n-\n-    check!(\n-        \"2001:200::\",\n-        &[0x20, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        global | unicast_global\n-    );\n-\n-    check!(\"fc00::\", &[0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unique_local);\n-\n-    check!(\n-        \"fdff:ffff::\",\n-        &[0xfd, 0xff, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        unique_local\n-    );\n-\n-    check!(\n-        \"fe80:ffff::\",\n-        &[0xfe, 0x80, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        unicast_link_local\n-    );\n-\n-    check!(\"fe80::\", &[0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_link_local);\n-\n-    check!(\n-        \"febf:ffff::\",\n-        &[0xfe, 0xbf, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        unicast_link_local\n-    );\n-\n-    check!(\"febf::\", &[0xfe, 0xbf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_link_local);\n-\n-    check!(\n-        \"febf:ffff:ffff:ffff:ffff:ffff:ffff:ffff\",\n-        &[\n-            0xfe, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n-            0xff, 0xff\n-        ],\n-        unicast_link_local\n-    );\n-\n-    check!(\n-        \"fe80::ffff:ffff:ffff:ffff\",\n-        &[\n-            0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n-            0xff, 0xff\n-        ],\n-        unicast_link_local\n-    );\n-\n-    check!(\n-        \"fe80:0:0:1::\",\n-        &[0xfe, 0x80, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n-        unicast_link_local\n-    );\n-\n-    check!(\n-        \"fec0::\",\n-        &[0xfe, 0xc0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        unicast_global | global\n-    );\n-\n-    check!(\n-        \"ff01::\",\n-        &[0xff, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_interface_local | global\n-    );\n-\n-    check!(\n-        \"ff02::\",\n-        &[0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_link_local | global\n-    );\n-\n-    check!(\n-        \"ff03::\",\n-        &[0xff, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_realm_local | global\n-    );\n-\n-    check!(\n-        \"ff04::\",\n-        &[0xff, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_admin_local | global\n-    );\n-\n-    check!(\n-        \"ff05::\",\n-        &[0xff, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_site_local | global\n-    );\n-\n-    check!(\n-        \"ff08::\",\n-        &[0xff, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_organization_local | global\n-    );\n-\n-    check!(\n-        \"ff0e::\",\n-        &[0xff, 0xe, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_global | global\n-    );\n-\n-    check!(\n-        \"2001:db8:85a3::8a2e:370:7334\",\n-        &[0x20, 1, 0xd, 0xb8, 0x85, 0xa3, 0, 0, 0, 0, 0x8a, 0x2e, 3, 0x70, 0x73, 0x34],\n-        documentation\n-    );\n-\n-    check!(\n-        \"2001:2::ac32:23ff:21\",\n-        &[0x20, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0xac, 0x32, 0x23, 0xff, 0, 0x21],\n-        benchmarking\n-    );\n-\n-    check!(\n-        \"102:304:506:708:90a:b0c:d0e:f10\",\n-        &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n-        global | unicast_global\n-    );\n-}\n+use crate::net::test::{sa4, tsa};\n+use crate::net::Ipv4Addr;\n \n #[test]\n fn to_socket_addr_socketaddr() {\n     let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 12345);\n     assert_eq!(Ok(vec![a]), tsa(a));\n }\n-\n-#[test]\n-fn test_ipv4_to_int() {\n-    let a = Ipv4Addr::new(0x11, 0x22, 0x33, 0x44);\n-    assert_eq!(u32::from(a), 0x11223344);\n-}\n-\n-#[test]\n-fn test_int_to_ipv4() {\n-    let a = Ipv4Addr::new(0x11, 0x22, 0x33, 0x44);\n-    assert_eq!(Ipv4Addr::from(0x11223344), a);\n-}\n-\n-#[test]\n-fn test_ipv6_to_int() {\n-    let a = Ipv6Addr::new(0x1122, 0x3344, 0x5566, 0x7788, 0x99aa, 0xbbcc, 0xddee, 0xff11);\n-    assert_eq!(u128::from(a), 0x112233445566778899aabbccddeeff11u128);\n-}\n-\n-#[test]\n-fn test_int_to_ipv6() {\n-    let a = Ipv6Addr::new(0x1122, 0x3344, 0x5566, 0x7788, 0x99aa, 0xbbcc, 0xddee, 0xff11);\n-    assert_eq!(Ipv6Addr::from(0x112233445566778899aabbccddeeff11u128), a);\n-}\n-\n-#[test]\n-fn ipv4_from_constructors() {\n-    assert_eq!(Ipv4Addr::LOCALHOST, Ipv4Addr::new(127, 0, 0, 1));\n-    assert!(Ipv4Addr::LOCALHOST.is_loopback());\n-    assert_eq!(Ipv4Addr::UNSPECIFIED, Ipv4Addr::new(0, 0, 0, 0));\n-    assert!(Ipv4Addr::UNSPECIFIED.is_unspecified());\n-    assert_eq!(Ipv4Addr::BROADCAST, Ipv4Addr::new(255, 255, 255, 255));\n-    assert!(Ipv4Addr::BROADCAST.is_broadcast());\n-}\n-\n-#[test]\n-fn ipv6_from_constructors() {\n-    assert_eq!(Ipv6Addr::LOCALHOST, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n-    assert!(Ipv6Addr::LOCALHOST.is_loopback());\n-    assert_eq!(Ipv6Addr::UNSPECIFIED, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n-    assert!(Ipv6Addr::UNSPECIFIED.is_unspecified());\n-}\n-\n-#[test]\n-fn ipv4_from_octets() {\n-    assert_eq!(Ipv4Addr::from([127, 0, 0, 1]), Ipv4Addr::new(127, 0, 0, 1))\n-}\n-\n-#[test]\n-fn ipv6_from_segments() {\n-    let from_u16s =\n-        Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff]);\n-    let new = Ipv6Addr::new(0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff);\n-    assert_eq!(new, from_u16s);\n-}\n-\n-#[test]\n-fn ipv6_from_octets() {\n-    let from_u16s =\n-        Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff]);\n-    let from_u8s = Ipv6Addr::from([\n-        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee,\n-        0xff,\n-    ]);\n-    assert_eq!(from_u16s, from_u8s);\n-}\n-\n-#[test]\n-fn cmp() {\n-    let v41 = Ipv4Addr::new(100, 64, 3, 3);\n-    let v42 = Ipv4Addr::new(192, 0, 2, 2);\n-    let v61 = \"2001:db8:f00::1002\".parse::<Ipv6Addr>().unwrap();\n-    let v62 = \"2001:db8:f00::2001\".parse::<Ipv6Addr>().unwrap();\n-    assert!(v41 < v42);\n-    assert!(v61 < v62);\n-\n-    assert_eq!(v41, IpAddr::V4(v41));\n-    assert_eq!(v61, IpAddr::V6(v61));\n-    assert!(v41 != IpAddr::V4(v42));\n-    assert!(v61 != IpAddr::V6(v62));\n-\n-    assert!(v41 < IpAddr::V4(v42));\n-    assert!(v61 < IpAddr::V6(v62));\n-    assert!(IpAddr::V4(v41) < v42);\n-    assert!(IpAddr::V6(v61) < v62);\n-\n-    assert!(v41 < IpAddr::V6(v61));\n-    assert!(IpAddr::V4(v41) < v61);\n-}\n-\n-#[test]\n-fn is_v4() {\n-    let ip = IpAddr::V4(Ipv4Addr::new(100, 64, 3, 3));\n-    assert!(ip.is_ipv4());\n-    assert!(!ip.is_ipv6());\n-}\n-\n-#[test]\n-fn is_v6() {\n-    let ip = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678));\n-    assert!(!ip.is_ipv4());\n-    assert!(ip.is_ipv6());\n-}\n-\n-#[test]\n-fn ipv4_const() {\n-    // test that the methods of `Ipv4Addr` are usable in a const context\n-\n-    const IP_ADDRESS: Ipv4Addr = Ipv4Addr::new(127, 0, 0, 1);\n-    assert_eq!(IP_ADDRESS, Ipv4Addr::LOCALHOST);\n-\n-    const OCTETS: [u8; 4] = IP_ADDRESS.octets();\n-    assert_eq!(OCTETS, [127, 0, 0, 1]);\n-\n-    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n-    assert!(!IS_UNSPECIFIED);\n-\n-    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n-    assert!(IS_LOOPBACK);\n-\n-    const IS_PRIVATE: bool = IP_ADDRESS.is_private();\n-    assert!(!IS_PRIVATE);\n-\n-    const IS_LINK_LOCAL: bool = IP_ADDRESS.is_link_local();\n-    assert!(!IS_LINK_LOCAL);\n-\n-    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n-    assert!(!IS_GLOBAL);\n-\n-    const IS_SHARED: bool = IP_ADDRESS.is_shared();\n-    assert!(!IS_SHARED);\n-\n-    const IS_BENCHMARKING: bool = IP_ADDRESS.is_benchmarking();\n-    assert!(!IS_BENCHMARKING);\n-\n-    const IS_RESERVED: bool = IP_ADDRESS.is_reserved();\n-    assert!(!IS_RESERVED);\n-\n-    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n-    assert!(!IS_MULTICAST);\n-\n-    const IS_BROADCAST: bool = IP_ADDRESS.is_broadcast();\n-    assert!(!IS_BROADCAST);\n-\n-    const IS_DOCUMENTATION: bool = IP_ADDRESS.is_documentation();\n-    assert!(!IS_DOCUMENTATION);\n-\n-    const IP_V6_COMPATIBLE: Ipv6Addr = IP_ADDRESS.to_ipv6_compatible();\n-    assert_eq!(\n-        IP_V6_COMPATIBLE,\n-        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 1])\n-    );\n-\n-    const IP_V6_MAPPED: Ipv6Addr = IP_ADDRESS.to_ipv6_mapped();\n-    assert_eq!(\n-        IP_V6_MAPPED,\n-        Ipv6Addr::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 127, 0, 0, 1])\n-    );\n-}\n-\n-#[test]\n-fn ipv6_const() {\n-    // test that the methods of `Ipv6Addr` are usable in a const context\n-\n-    const IP_ADDRESS: Ipv6Addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n-    assert_eq!(IP_ADDRESS, Ipv6Addr::LOCALHOST);\n-\n-    const SEGMENTS: [u16; 8] = IP_ADDRESS.segments();\n-    assert_eq!(SEGMENTS, [0, 0, 0, 0, 0, 0, 0, 1]);\n-\n-    const OCTETS: [u8; 16] = IP_ADDRESS.octets();\n-    assert_eq!(OCTETS, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);\n-\n-    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n-    assert!(!IS_UNSPECIFIED);\n-\n-    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n-    assert!(IS_LOOPBACK);\n-\n-    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n-    assert!(!IS_GLOBAL);\n-\n-    const IS_UNIQUE_LOCAL: bool = IP_ADDRESS.is_unique_local();\n-    assert!(!IS_UNIQUE_LOCAL);\n-\n-    const IS_UNICAST_LINK_LOCAL: bool = IP_ADDRESS.is_unicast_link_local();\n-    assert!(!IS_UNICAST_LINK_LOCAL);\n-\n-    const IS_DOCUMENTATION: bool = IP_ADDRESS.is_documentation();\n-    assert!(!IS_DOCUMENTATION);\n-\n-    const IS_BENCHMARKING: bool = IP_ADDRESS.is_benchmarking();\n-    assert!(!IS_BENCHMARKING);\n-\n-    const IS_UNICAST_GLOBAL: bool = IP_ADDRESS.is_unicast_global();\n-    assert!(!IS_UNICAST_GLOBAL);\n-\n-    const MULTICAST_SCOPE: Option<Ipv6MulticastScope> = IP_ADDRESS.multicast_scope();\n-    assert_eq!(MULTICAST_SCOPE, None);\n-\n-    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n-    assert!(!IS_MULTICAST);\n-\n-    const IP_V4: Option<Ipv4Addr> = IP_ADDRESS.to_ipv4();\n-    assert_eq!(IP_V4.unwrap(), Ipv4Addr::new(0, 0, 0, 1));\n-}\n-\n-#[test]\n-fn ip_const() {\n-    // test that the methods of `IpAddr` are usable in a const context\n-\n-    const IP_ADDRESS: IpAddr = IpAddr::V4(Ipv4Addr::LOCALHOST);\n-\n-    const IS_UNSPECIFIED: bool = IP_ADDRESS.is_unspecified();\n-    assert!(!IS_UNSPECIFIED);\n-\n-    const IS_LOOPBACK: bool = IP_ADDRESS.is_loopback();\n-    assert!(IS_LOOPBACK);\n-\n-    const IS_GLOBAL: bool = IP_ADDRESS.is_global();\n-    assert!(!IS_GLOBAL);\n-\n-    const IS_MULTICAST: bool = IP_ADDRESS.is_multicast();\n-    assert!(!IS_MULTICAST);\n-\n-    const IS_IP_V4: bool = IP_ADDRESS.is_ipv4();\n-    assert!(IS_IP_V4);\n-\n-    const IS_IP_V6: bool = IP_ADDRESS.is_ipv6();\n-    assert!(!IS_IP_V6);\n-}\n-\n-#[test]\n-fn structural_match() {\n-    // test that all IP types can be structurally matched upon\n-\n-    const IPV4: Ipv4Addr = Ipv4Addr::LOCALHOST;\n-    match IPV4 {\n-        Ipv4Addr::LOCALHOST => {}\n-        _ => unreachable!(),\n-    }\n-\n-    const IPV6: Ipv6Addr = Ipv6Addr::LOCALHOST;\n-    match IPV6 {\n-        Ipv6Addr::LOCALHOST => {}\n-        _ => unreachable!(),\n-    }\n-\n-    const IP: IpAddr = IpAddr::V4(Ipv4Addr::LOCALHOST);\n-    match IP {\n-        IpAddr::V4(Ipv4Addr::LOCALHOST) => {}\n-        _ => unreachable!(),\n-    }\n-}"}, {"sha": "bcab15db35b5ca291c6205b9cff3f0c151c2a2c2", "filename": "library/std/src/net/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -26,19 +26,17 @@ use crate::io::{self, ErrorKind};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::ip_addr::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::parser::AddrParseError;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::socket_addr::{SocketAddr, SocketAddrV4, SocketAddrV6, ToSocketAddrs};\n #[unstable(feature = \"tcplistener_into_incoming\", issue = \"88339\")]\n pub use self::tcp::IntoIncoming;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::tcp::{Incoming, TcpListener, TcpStream};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::udp::UdpSocket;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::net::AddrParseError;\n \n-mod display_buffer;\n mod ip_addr;\n-mod parser;\n mod socket_addr;\n mod tcp;\n #[cfg(test)]"}, {"sha": "421fed9077c5bbdb21bb1c6d20c2d6340b76c949", "filename": "library/std/src/net/socket_addr.rs", "status": "modified", "additions": 15, "deletions": 674, "changes": 689, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1,9 +1,7 @@\n+// Tests for this module\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;\n \n-use crate::cmp::Ordering;\n-use crate::fmt::{self, Write};\n-use crate::hash;\n use crate::io;\n use crate::iter;\n use crate::mem;\n@@ -15,542 +13,32 @@ use crate::sys_common::net::LookupHost;\n use crate::sys_common::{FromInner, IntoInner};\n use crate::vec;\n \n-use super::display_buffer::DisplayBuffer;\n-\n-/// An internet socket address, either IPv4 or IPv6.\n-///\n-/// Internet socket addresses consist of an [IP address], a 16-bit port number, as well\n-/// as possibly some version-dependent additional information. See [`SocketAddrV4`]'s and\n-/// [`SocketAddrV6`]'s respective documentation for more details.\n-///\n-/// The size of a `SocketAddr` instance may vary depending on the target operating\n-/// system.\n-///\n-/// [IP address]: IpAddr\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n-///\n-/// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-///\n-/// assert_eq!(\"127.0.0.1:8080\".parse(), Ok(socket));\n-/// assert_eq!(socket.port(), 8080);\n-/// assert_eq!(socket.is_ipv4(), true);\n-/// ```\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub enum SocketAddr {\n-    /// An IPv4 socket address.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    V4(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV4),\n-    /// An IPv6 socket address.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    V6(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV6),\n-}\n-\n-/// An IPv4 socket address.\n-///\n-/// IPv4 socket addresses consist of an [`IPv4` address] and a 16-bit port number, as\n-/// stated in [IETF RFC 793].\n-///\n-/// See [`SocketAddr`] for a type encompassing both IPv4 and IPv6 socket addresses.\n-///\n-/// The size of a `SocketAddrV4` struct may vary depending on the target operating\n-/// system. Do not assume that this type has the same memory layout as the underlying\n-/// system representation.\n-///\n-/// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n-/// [`IPv4` address]: Ipv4Addr\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::net::{Ipv4Addr, SocketAddrV4};\n-///\n-/// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n-///\n-/// assert_eq!(\"127.0.0.1:8080\".parse(), Ok(socket));\n-/// assert_eq!(socket.ip(), &Ipv4Addr::new(127, 0, 0, 1));\n-/// assert_eq!(socket.port(), 8080);\n-/// ```\n-#[derive(Copy, Clone, Eq, PartialEq)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SocketAddrV4 {\n-    ip: Ipv4Addr,\n-    port: u16,\n-}\n-\n-/// An IPv6 socket address.\n-///\n-/// IPv6 socket addresses consist of an [`IPv6` address], a 16-bit port number, as well\n-/// as fields containing the traffic class, the flow label, and a scope identifier\n-/// (see [IETF RFC 2553, Section 3.3] for more details).\n-///\n-/// See [`SocketAddr`] for a type encompassing both IPv4 and IPv6 socket addresses.\n-///\n-/// The size of a `SocketAddrV6` struct may vary depending on the target operating\n-/// system. Do not assume that this type has the same memory layout as the underlying\n-/// system representation.\n-///\n-/// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n-/// [`IPv6` address]: Ipv6Addr\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::net::{Ipv6Addr, SocketAddrV6};\n-///\n-/// let socket = SocketAddrV6::new(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n-///\n-/// assert_eq!(\"[2001:db8::1]:8080\".parse(), Ok(socket));\n-/// assert_eq!(socket.ip(), &Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1));\n-/// assert_eq!(socket.port(), 8080);\n-/// ```\n-#[derive(Copy, Clone, Eq, PartialEq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SocketAddrV6 {\n-    ip: Ipv6Addr,\n-    port: u16,\n-    flowinfo: u32,\n-    scope_id: u32,\n-}\n-\n-impl SocketAddr {\n-    /// Creates a new socket address from an [IP address] and a port number.\n-    ///\n-    /// [IP address]: IpAddr\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n-    ///\n-    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n-    /// assert_eq!(socket.port(), 8080);\n-    /// ```\n-    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-    #[must_use]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn new(ip: IpAddr, port: u16) -> SocketAddr {\n-        match ip {\n-            IpAddr::V4(a) => SocketAddr::V4(SocketAddrV4::new(a, port)),\n-            IpAddr::V6(a) => SocketAddr::V6(SocketAddrV6::new(a, port, 0, 0)),\n-        }\n-    }\n-\n-    /// Returns the IP address associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n-    ///\n-    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn ip(&self) -> IpAddr {\n-        match *self {\n-            SocketAddr::V4(ref a) => IpAddr::V4(*a.ip()),\n-            SocketAddr::V6(ref a) => IpAddr::V6(*a.ip()),\n-        }\n-    }\n-\n-    /// Changes the IP address associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n-    ///\n-    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-    /// socket.set_ip(IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n-    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_ip(&mut self, new_ip: IpAddr) {\n-        // `match (*self, new_ip)` would have us mutate a copy of self only to throw it away.\n-        match (self, new_ip) {\n-            (&mut SocketAddr::V4(ref mut a), IpAddr::V4(new_ip)) => a.set_ip(new_ip),\n-            (&mut SocketAddr::V6(ref mut a), IpAddr::V6(new_ip)) => a.set_ip(new_ip),\n-            (self_, new_ip) => *self_ = Self::new(new_ip, self_.port()),\n-        }\n-    }\n-\n-    /// Returns the port number associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n-    ///\n-    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-    /// assert_eq!(socket.port(), 8080);\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn port(&self) -> u16 {\n-        match *self {\n-            SocketAddr::V4(ref a) => a.port(),\n-            SocketAddr::V6(ref a) => a.port(),\n-        }\n-    }\n-\n-    /// Changes the port number associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n-    ///\n-    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-    /// socket.set_port(1025);\n-    /// assert_eq!(socket.port(), 1025);\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_port(&mut self, new_port: u16) {\n-        match *self {\n-            SocketAddr::V4(ref mut a) => a.set_port(new_port),\n-            SocketAddr::V6(ref mut a) => a.set_port(new_port),\n-        }\n-    }\n-\n-    /// Returns [`true`] if the [IP address] in this `SocketAddr` is an\n-    /// [`IPv4` address], and [`false`] otherwise.\n-    ///\n-    /// [IP address]: IpAddr\n-    /// [`IPv4` address]: IpAddr::V4\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n-    ///\n-    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-    /// assert_eq!(socket.is_ipv4(), true);\n-    /// assert_eq!(socket.is_ipv6(), false);\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn is_ipv4(&self) -> bool {\n-        matches!(*self, SocketAddr::V4(_))\n-    }\n-\n-    /// Returns [`true`] if the [IP address] in this `SocketAddr` is an\n-    /// [`IPv6` address], and [`false`] otherwise.\n-    ///\n-    /// [IP address]: IpAddr\n-    /// [`IPv6` address]: IpAddr::V6\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{IpAddr, Ipv6Addr, SocketAddr};\n-    ///\n-    /// let socket = SocketAddr::new(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 0, 1)), 8080);\n-    /// assert_eq!(socket.is_ipv4(), false);\n-    /// assert_eq!(socket.is_ipv6(), true);\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn is_ipv6(&self) -> bool {\n-        matches!(*self, SocketAddr::V6(_))\n-    }\n-}\n-\n-impl SocketAddrV4 {\n-    /// Creates a new socket address from an [`IPv4` address] and a port number.\n-    ///\n-    /// [`IPv4` address]: Ipv4Addr\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV4, Ipv4Addr};\n-    ///\n-    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4 {\n-        SocketAddrV4 { ip, port }\n-    }\n-\n-    /// Returns the IP address associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV4, Ipv4Addr};\n-    ///\n-    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n-    /// assert_eq!(socket.ip(), &Ipv4Addr::new(127, 0, 0, 1));\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn ip(&self) -> &Ipv4Addr {\n-        &self.ip\n-    }\n-\n-    /// Changes the IP address associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV4, Ipv4Addr};\n-    ///\n-    /// let mut socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n-    /// socket.set_ip(Ipv4Addr::new(192, 168, 0, 1));\n-    /// assert_eq!(socket.ip(), &Ipv4Addr::new(192, 168, 0, 1));\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_ip(&mut self, new_ip: Ipv4Addr) {\n-        self.ip = new_ip;\n-    }\n-\n-    /// Returns the port number associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV4, Ipv4Addr};\n-    ///\n-    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n-    /// assert_eq!(socket.port(), 8080);\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn port(&self) -> u16 {\n-        self.port\n-    }\n-\n-    /// Changes the port number associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV4, Ipv4Addr};\n-    ///\n-    /// let mut socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n-    /// socket.set_port(4242);\n-    /// assert_eq!(socket.port(), 4242);\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_port(&mut self, new_port: u16) {\n-        self.port = new_port;\n-    }\n-}\n-\n-impl SocketAddrV6 {\n-    /// Creates a new socket address from an [`IPv6` address], a 16-bit port number,\n-    /// and the `flowinfo` and `scope_id` fields.\n-    ///\n-    /// For more information on the meaning and layout of the `flowinfo` and `scope_id`\n-    /// parameters, see [IETF RFC 2553, Section 3.3].\n-    ///\n-    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n-    /// [`IPv6` address]: Ipv6Addr\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[must_use]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddrV6 {\n-        SocketAddrV6 { ip, port, flowinfo, scope_id }\n-    }\n-\n-    /// Returns the IP address associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n-    /// assert_eq!(socket.ip(), &Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn ip(&self) -> &Ipv6Addr {\n-        &self.ip\n-    }\n-\n-    /// Changes the IP address associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n-    /// socket.set_ip(Ipv6Addr::new(76, 45, 0, 0, 0, 0, 0, 0));\n-    /// assert_eq!(socket.ip(), &Ipv6Addr::new(76, 45, 0, 0, 0, 0, 0, 0));\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_ip(&mut self, new_ip: Ipv6Addr) {\n-        self.ip = new_ip;\n-    }\n-\n-    /// Returns the port number associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n-    /// assert_eq!(socket.port(), 8080);\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn port(&self) -> u16 {\n-        self.port\n-    }\n-\n-    /// Changes the port number associated with this socket address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n-    /// socket.set_port(4242);\n-    /// assert_eq!(socket.port(), 4242);\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_port(&mut self, new_port: u16) {\n-        self.port = new_port;\n-    }\n-\n-    /// Returns the flow information associated with this address.\n-    ///\n-    /// This information corresponds to the `sin6_flowinfo` field in C's `netinet/in.h`,\n-    /// as specified in [IETF RFC 2553, Section 3.3].\n-    /// It combines information about the flow label and the traffic class as specified\n-    /// in [IETF RFC 2460], respectively [Section 6] and [Section 7].\n-    ///\n-    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n-    /// [IETF RFC 2460]: https://tools.ietf.org/html/rfc2460\n-    /// [Section 6]: https://tools.ietf.org/html/rfc2460#section-6\n-    /// [Section 7]: https://tools.ietf.org/html/rfc2460#section-7\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 10, 0);\n-    /// assert_eq!(socket.flowinfo(), 10);\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn flowinfo(&self) -> u32 {\n-        self.flowinfo\n-    }\n-\n-    /// Changes the flow information associated with this socket address.\n-    ///\n-    /// See [`SocketAddrV6::flowinfo`]'s documentation for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 10, 0);\n-    /// socket.set_flowinfo(56);\n-    /// assert_eq!(socket.flowinfo(), 56);\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_flowinfo(&mut self, new_flowinfo: u32) {\n-        self.flowinfo = new_flowinfo;\n-    }\n-\n-    /// Returns the scope ID associated with this address.\n-    ///\n-    /// This information corresponds to the `sin6_scope_id` field in C's `netinet/in.h`,\n-    /// as specified in [IETF RFC 2553, Section 3.3].\n-    ///\n-    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 78);\n-    /// assert_eq!(socket.scope_id(), 78);\n-    /// ```\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_socketaddr\", since = \"CURRENT_RUSTC_VERSION\")]\n-    pub const fn scope_id(&self) -> u32 {\n-        self.scope_id\n-    }\n-\n-    /// Changes the scope ID associated with this socket address.\n-    ///\n-    /// See [`SocketAddrV6::scope_id`]'s documentation for more details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::net::{SocketAddrV6, Ipv6Addr};\n-    ///\n-    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 78);\n-    /// socket.set_scope_id(42);\n-    /// assert_eq!(socket.scope_id(), 42);\n-    /// ```\n-    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n-    pub fn set_scope_id(&mut self, new_scope_id: u32) {\n-        self.scope_id = new_scope_id;\n-    }\n-}\n+pub use core::net::{SocketAddr, SocketAddrV4, SocketAddrV6};\n \n impl FromInner<c::sockaddr_in> for SocketAddrV4 {\n     fn from_inner(addr: c::sockaddr_in) -> SocketAddrV4 {\n-        SocketAddrV4 { ip: Ipv4Addr::from_inner(addr.sin_addr), port: u16::from_be(addr.sin_port) }\n+        SocketAddrV4::new(Ipv4Addr::from_inner(addr.sin_addr), u16::from_be(addr.sin_port))\n     }\n }\n \n impl FromInner<c::sockaddr_in6> for SocketAddrV6 {\n     fn from_inner(addr: c::sockaddr_in6) -> SocketAddrV6 {\n-        SocketAddrV6 {\n-            ip: Ipv6Addr::from_inner(addr.sin6_addr),\n-            port: u16::from_be(addr.sin6_port),\n-            flowinfo: addr.sin6_flowinfo,\n-            scope_id: addr.sin6_scope_id,\n-        }\n+        SocketAddrV6::new(\n+            Ipv6Addr::from_inner(addr.sin6_addr),\n+            u16::from_be(addr.sin6_port),\n+            addr.sin6_flowinfo,\n+            addr.sin6_scope_id,\n+        )\n     }\n }\n \n impl IntoInner<c::sockaddr_in> for SocketAddrV4 {\n     fn into_inner(self) -> c::sockaddr_in {\n         c::sockaddr_in {\n             sin_family: c::AF_INET as c::sa_family_t,\n-            sin_port: self.port.to_be(),\n-            sin_addr: self.ip.into_inner(),\n+            sin_port: self.port().to_be(),\n+            sin_addr: self.ip().into_inner(),\n             ..unsafe { mem::zeroed() }\n         }\n     }\n@@ -560,162 +48,15 @@ impl IntoInner<c::sockaddr_in6> for SocketAddrV6 {\n     fn into_inner(self) -> c::sockaddr_in6 {\n         c::sockaddr_in6 {\n             sin6_family: c::AF_INET6 as c::sa_family_t,\n-            sin6_port: self.port.to_be(),\n-            sin6_addr: self.ip.into_inner(),\n-            sin6_flowinfo: self.flowinfo,\n-            sin6_scope_id: self.scope_id,\n+            sin6_port: self.port().to_be(),\n+            sin6_addr: self.ip().into_inner(),\n+            sin6_flowinfo: self.flowinfo(),\n+            sin6_scope_id: self.scope_id(),\n             ..unsafe { mem::zeroed() }\n         }\n     }\n }\n \n-#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n-impl From<SocketAddrV4> for SocketAddr {\n-    /// Converts a [`SocketAddrV4`] into a [`SocketAddr::V4`].\n-    fn from(sock4: SocketAddrV4) -> SocketAddr {\n-        SocketAddr::V4(sock4)\n-    }\n-}\n-\n-#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n-impl From<SocketAddrV6> for SocketAddr {\n-    /// Converts a [`SocketAddrV6`] into a [`SocketAddr::V6`].\n-    fn from(sock6: SocketAddrV6) -> SocketAddr {\n-        SocketAddr::V6(sock6)\n-    }\n-}\n-\n-#[stable(feature = \"addr_from_into_ip\", since = \"1.17.0\")]\n-impl<I: Into<IpAddr>> From<(I, u16)> for SocketAddr {\n-    /// Converts a tuple struct (Into<[`IpAddr`]>, `u16`) into a [`SocketAddr`].\n-    ///\n-    /// This conversion creates a [`SocketAddr::V4`] for an [`IpAddr::V4`]\n-    /// and creates a [`SocketAddr::V6`] for an [`IpAddr::V6`].\n-    ///\n-    /// `u16` is treated as port of the newly created [`SocketAddr`].\n-    fn from(pieces: (I, u16)) -> SocketAddr {\n-        SocketAddr::new(pieces.0.into(), pieces.1)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for SocketAddr {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            SocketAddr::V4(ref a) => a.fmt(f),\n-            SocketAddr::V6(ref a) => a.fmt(f),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for SocketAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for SocketAddrV4 {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // If there are no alignment requirements, write the socket address directly to `f`.\n-        // Otherwise, write it to a local buffer and then use `f.pad`.\n-        if f.precision().is_none() && f.width().is_none() {\n-            write!(f, \"{}:{}\", self.ip(), self.port())\n-        } else {\n-            const LONGEST_IPV4_SOCKET_ADDR: &str = \"255.255.255.255:65536\";\n-\n-            let mut buf = DisplayBuffer::<{ LONGEST_IPV4_SOCKET_ADDR.len() }>::new();\n-            // Buffer is long enough for the longest possible IPv4 socket address, so this should never fail.\n-            write!(buf, \"{}:{}\", self.ip(), self.port()).unwrap();\n-\n-            f.pad(buf.as_str())\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for SocketAddrV4 {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for SocketAddrV6 {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // If there are no alignment requirements, write the socket address directly to `f`.\n-        // Otherwise, write it to a local buffer and then use `f.pad`.\n-        if f.precision().is_none() && f.width().is_none() {\n-            match self.scope_id() {\n-                0 => write!(f, \"[{}]:{}\", self.ip(), self.port()),\n-                scope_id => write!(f, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n-            }\n-        } else {\n-            const LONGEST_IPV6_SOCKET_ADDR: &str =\n-                \"[ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff%4294967296]:65536\";\n-\n-            let mut buf = DisplayBuffer::<{ LONGEST_IPV6_SOCKET_ADDR.len() }>::new();\n-            match self.scope_id() {\n-                0 => write!(buf, \"[{}]:{}\", self.ip(), self.port()),\n-                scope_id => write!(buf, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n-            }\n-            // Buffer is long enough for the longest possible IPv6 socket address, so this should never fail.\n-            .unwrap();\n-\n-            f.pad(buf.as_str())\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for SocketAddrV6 {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, fmt)\n-    }\n-}\n-\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl PartialOrd for SocketAddrV4 {\n-    fn partial_cmp(&self, other: &SocketAddrV4) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl PartialOrd for SocketAddrV6 {\n-    fn partial_cmp(&self, other: &SocketAddrV6) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl Ord for SocketAddrV4 {\n-    fn cmp(&self, other: &SocketAddrV4) -> Ordering {\n-        self.ip().cmp(other.ip()).then(self.port().cmp(&other.port()))\n-    }\n-}\n-\n-#[stable(feature = \"socketaddr_ordering\", since = \"1.45.0\")]\n-impl Ord for SocketAddrV6 {\n-    fn cmp(&self, other: &SocketAddrV6) -> Ordering {\n-        self.ip().cmp(other.ip()).then(self.port().cmp(&other.port()))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl hash::Hash for SocketAddrV4 {\n-    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n-        (self.port, self.ip).hash(s)\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl hash::Hash for SocketAddrV6 {\n-    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n-        (self.port, &self.ip, self.flowinfo, self.scope_id).hash(s)\n-    }\n-}\n-\n /// A trait for objects which can be converted or resolved to one or more\n /// [`SocketAddr`] values.\n ///"}, {"sha": "e019bc0b67a15260bac309f498703d6b69dc2be5", "filename": "library/std/src/net/tcp/tests.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -670,7 +670,10 @@ fn debug() {\n // FIXME: re-enabled openbsd tests once their socket timeout code\n //        no longer has rounding errors.\n // VxWorks ignores SO_SNDTIMEO.\n-#[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"vxworks\"), ignore)]\n+#[cfg_attr(\n+    any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"vxworks\", target_os = \"nto\"),\n+    ignore\n+)]\n #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n #[test]\n fn timeouts() {"}, {"sha": "892fe2ba8baf8deb50b073af048c3274e4d83cb7", "filename": "library/std/src/net/udp/tests.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -180,7 +180,10 @@ fn debug() {\n // FIXME: re-enabled openbsd/netbsd tests once their socket timeout code\n //        no longer has rounding errors.\n // VxWorks ignores SO_SNDTIMEO.\n-#[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"vxworks\"), ignore)]\n+#[cfg_attr(\n+    any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"vxworks\", target_os = \"nto\"),\n+    ignore\n+)]\n #[test]\n fn timeouts() {\n     let addr = next_test_ip4();"}, {"sha": "b148d8a0091807c56f78ecf7c90f3159930a257a", "filename": "library/std/src/os/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -127,6 +127,8 @@ pub mod l4re;\n pub mod macos;\n #[cfg(target_os = \"netbsd\")]\n pub mod netbsd;\n+#[cfg(target_os = \"nto\")]\n+pub mod nto;\n #[cfg(target_os = \"openbsd\")]\n pub mod openbsd;\n #[cfg(target_os = \"redox\")]"}, {"sha": "8f915b08c9e2e9c49fdf9adb406989e76448cd4e", "filename": "library/std/src/os/nto/fs.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Fnto%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Fnto%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnto%2Ffs.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -0,0 +1,92 @@\n+#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+\n+use crate::fs::Metadata;\n+use crate::sys_common::AsInner;\n+\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+pub trait MetadataExt {\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_dev(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ino(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mode(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_nlink(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_uid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_gid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_rdev(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_size(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blksize(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blocks(&self) -> u64;\n+}\n+\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+impl MetadataExt for Metadata {\n+    fn st_dev(&self) -> u64 {\n+        self.as_inner().as_inner().st_dev as u64\n+    }\n+    fn st_ino(&self) -> u64 {\n+        self.as_inner().as_inner().st_ino as u64\n+    }\n+    fn st_mode(&self) -> u32 {\n+        self.as_inner().as_inner().st_mode as u32\n+    }\n+    fn st_nlink(&self) -> u64 {\n+        self.as_inner().as_inner().st_nlink as u64\n+    }\n+    fn st_uid(&self) -> u32 {\n+        self.as_inner().as_inner().st_uid as u32\n+    }\n+    fn st_gid(&self) -> u32 {\n+        self.as_inner().as_inner().st_gid as u32\n+    }\n+    fn st_rdev(&self) -> u64 {\n+        self.as_inner().as_inner().st_rdev as u64\n+    }\n+    fn st_size(&self) -> u64 {\n+        self.as_inner().as_inner().st_size as u64\n+    }\n+    fn st_atime(&self) -> i64 {\n+        self.as_inner().as_inner().st_atim.tv_sec as i64\n+    }\n+    fn st_atime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_atim.tv_nsec as i64\n+    }\n+    fn st_mtime(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtim.tv_sec as i64\n+    }\n+    fn st_mtime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtim.tv_nsec as i64\n+    }\n+    fn st_ctime(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctim.tv_sec as i64\n+    }\n+    fn st_ctime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctim.tv_nsec as i64\n+    }\n+    fn st_blksize(&self) -> u64 {\n+        self.as_inner().as_inner().st_blksize as u64\n+    }\n+    fn st_blocks(&self) -> u64 {\n+        self.as_inner().as_inner().st_blocks as u64\n+    }\n+}"}, {"sha": "3e591dace9274acc7e2d4cff1a761629afd1c7e3", "filename": "library/std/src/os/nto/mod.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Fnto%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Fnto%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnto%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -0,0 +1,4 @@\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+\n+pub mod fs;\n+pub(super) mod raw;"}, {"sha": "90e9ad546432a723b3a7e517fdb615ee93eee493", "filename": "library/std/src/os/nto/raw.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Fnto%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Fnto%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnto%2Fraw.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -0,0 +1,40 @@\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+#![deprecated(\n+    since = \"1.8.0\",\n+    note = \"these type aliases are no longer supported by \\\n+            the standard library, the `libc` crate on \\\n+            crates.io should be used instead for the correct \\\n+            definitions\"\n+)]\n+#![allow(deprecated)]\n+\n+use crate::os::raw::c_int;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = u32;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = u32;\n+\n+#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n+pub type pthread_t = c_int;\n+\n+#[doc(inline)]\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub use self::arch::{blkcnt_t, blksize_t, ino_t, nlink_t, off_t, time_t};\n+\n+mod arch {\n+    use crate::os::raw::c_long;\n+\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blkcnt_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type blksize_t = i32;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type ino_t = u64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type nlink_t = u32;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type off_t = i64;\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub type time_t = c_long;\n+}"}, {"sha": "a0e664acd130aae44f9df6c13803b9893ee1445c", "filename": "library/std/src/os/unix/fs.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -17,6 +17,10 @@ use crate::sealed::Sealed;\n #[allow(unused_imports)]\n use io::{Read, Write};\n \n+// Tests for this module\n+#[cfg(test)]\n+mod tests;\n+\n /// Unix-specific extensions to [`fs::File`].\n #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n pub trait FileExt {\n@@ -54,6 +58,16 @@ pub trait FileExt {\n     #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;\n \n+    /// Like `read_at`, except that it reads into a slice of buffers.\n+    ///\n+    /// Data is copied to fill each buffer in order, with the final buffer\n+    /// written to possibly being only partially filled. This method must behave\n+    /// equivalently to a single call to read with concatenated buffers.\n+    #[unstable(feature = \"unix_file_vectored_at\", issue = \"89517\")]\n+    fn read_vectored_at(&self, bufs: &mut [io::IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        io::default_read_vectored(|b| self.read_at(b, offset), bufs)\n+    }\n+\n     /// Reads the exact number of byte required to fill `buf` from the given offset.\n     ///\n     /// The offset is relative to the start of the file and thus independent\n@@ -155,6 +169,16 @@ pub trait FileExt {\n     #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize>;\n \n+    /// Like `write_at`, except that it writes from a slice of buffers.\n+    ///\n+    /// Data is copied from each buffer in order, with the final buffer read\n+    /// from possibly being only partially consumed. This method must behave as\n+    /// a call to `write_at` with the buffers concatenated would.\n+    #[unstable(feature = \"unix_file_vectored_at\", issue = \"89517\")]\n+    fn write_vectored_at(&self, bufs: &[io::IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        io::default_write_vectored(|b| self.write_at(b, offset), bufs)\n+    }\n+\n     /// Attempts to write an entire buffer starting from a given offset.\n     ///\n     /// The offset is relative to the start of the file and thus independent\n@@ -218,9 +242,15 @@ impl FileExt for fs::File {\n     fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n         self.as_inner().read_at(buf, offset)\n     }\n+    fn read_vectored_at(&self, bufs: &mut [io::IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        self.as_inner().read_vectored_at(bufs, offset)\n+    }\n     fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n         self.as_inner().write_at(buf, offset)\n     }\n+    fn write_vectored_at(&self, bufs: &[io::IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        self.as_inner().write_vectored_at(bufs, offset)\n+    }\n }\n \n /// Unix-specific extensions to [`fs::Permissions`]."}, {"sha": "67f607bd4683735e3508f3eed425d7c9216922ac", "filename": "library/std/src/os/unix/fs/tests.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs%2Ftests.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -0,0 +1,57 @@\n+use super::*;\n+\n+#[test]\n+fn read_vectored_at() {\n+    let msg = b\"preadv is working!\";\n+    let dir = crate::sys_common::io::test::tmpdir();\n+\n+    let filename = dir.join(\"preadv.txt\");\n+    {\n+        let mut file = fs::File::create(&filename).unwrap();\n+        file.write_all(msg).unwrap();\n+    }\n+    {\n+        let file = fs::File::open(&filename).unwrap();\n+        let mut buf0 = [0; 4];\n+        let mut buf1 = [0; 3];\n+\n+        let mut iovec = [io::IoSliceMut::new(&mut buf0), io::IoSliceMut::new(&mut buf1)];\n+\n+        let n = file.read_vectored_at(&mut iovec, 4).unwrap();\n+\n+        assert!(n == 4 || n == 7);\n+        assert_eq!(&buf0, b\"dv i\");\n+\n+        if n == 7 {\n+            assert_eq!(&buf1, b\"s w\");\n+        }\n+    }\n+}\n+\n+#[test]\n+fn write_vectored_at() {\n+    let msg = b\"pwritev is not working!\";\n+    let dir = crate::sys_common::io::test::tmpdir();\n+\n+    let filename = dir.join(\"preadv.txt\");\n+    {\n+        let mut file = fs::File::create(&filename).unwrap();\n+        file.write_all(msg).unwrap();\n+    }\n+    let expected = {\n+        let file = fs::File::options().write(true).open(&filename).unwrap();\n+        let buf0 = b\"    \";\n+        let buf1 = b\"great  \";\n+\n+        let iovec = [io::IoSlice::new(buf0), io::IoSlice::new(buf1)];\n+\n+        let n = file.write_vectored_at(&iovec, 11).unwrap();\n+\n+        assert!(n == 4 || n == 11);\n+\n+        if n == 4 { b\"pwritev is     working!\" } else { b\"pwritev is     great  !\" }\n+    };\n+\n+    let content = fs::read(&filename).unwrap();\n+    assert_eq!(&content, expected);\n+}"}, {"sha": "eb2d7ce117477932f24df9e08335910ec82a5a03", "filename": "library/std/src/os/unix/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -65,6 +65,8 @@ mod platform {\n     pub use crate::os::macos::*;\n     #[cfg(target_os = \"netbsd\")]\n     pub use crate::os::netbsd::*;\n+    #[cfg(target_os = \"nto\")]\n+    pub use crate::os::nto::*;\n     #[cfg(target_os = \"openbsd\")]\n     pub use crate::os::openbsd::*;\n     #[cfg(target_os = \"redox\")]\n@@ -95,7 +97,8 @@ pub mod thread;\n     target_os = \"watchos\",\n     target_os = \"macos\",\n     target_os = \"netbsd\",\n-    target_os = \"openbsd\"\n+    target_os = \"openbsd\",\n+    target_os = \"nto\",\n ))]\n pub mod ucred;\n "}, {"sha": "272b4f5dcd5adc088c6b94452785dedccb6cb116", "filename": "library/std/src/os/unix/net/datagram.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -19,7 +19,8 @@ use crate::{fmt, io};\n     target_os = \"freebsd\",\n     target_os = \"openbsd\",\n     target_os = \"netbsd\",\n-    target_os = \"haiku\"\n+    target_os = \"haiku\",\n+    target_os = \"nto\",\n ))]\n use libc::MSG_NOSIGNAL;\n #[cfg(not(any(\n@@ -29,7 +30,8 @@ use libc::MSG_NOSIGNAL;\n     target_os = \"freebsd\",\n     target_os = \"openbsd\",\n     target_os = \"netbsd\",\n-    target_os = \"haiku\"\n+    target_os = \"haiku\",\n+    target_os = \"nto\",\n )))]\n const MSG_NOSIGNAL: libc::c_int = 0x0;\n "}, {"sha": "f8c29a6d3a16a5ab190fdd5892feeca9352b6e8c", "filename": "library/std/src/os/unix/net/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -167,6 +167,7 @@ fn long_path() {\n }\n \n #[test]\n+#[cfg(not(target_os = \"nto\"))]\n fn timeouts() {\n     let dir = tmpdir();\n     let socket_path = dir.path().join(\"sock\");"}, {"sha": "729c63d184f2c417826c56649187a3469ab7692f", "filename": "library/std/src/os/unix/process.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -12,15 +12,23 @@ use crate::sealed::Sealed;\n use crate::sys;\n use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n \n-#[cfg(not(any(target_os = \"vxworks\", target_os = \"espidf\", target_os = \"horizon\")))]\n-type UserId = u32;\n-#[cfg(not(any(target_os = \"vxworks\", target_os = \"espidf\", target_os = \"horizon\")))]\n-type GroupId = u32;\n-\n-#[cfg(any(target_os = \"vxworks\", target_os = \"espidf\", target_os = \"horizon\"))]\n-type UserId = u16;\n-#[cfg(any(target_os = \"vxworks\", target_os = \"espidf\", target_os = \"horizon\"))]\n-type GroupId = u16;\n+use cfg_if::cfg_if;\n+\n+cfg_if! {\n+    if #[cfg(any(target_os = \"vxworks\", target_os = \"espidf\", target_os = \"horizon\"))] {\n+        type UserId = u16;\n+        type GroupId = u16;\n+    } else if #[cfg(target_os = \"nto\")] {\n+        // Both IDs are signed, see `sys/target_nto.h` of the QNX Neutrino SDP.\n+        // Only positive values should be used, see e.g.\n+        // https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/topic/s/setuid.html\n+        type UserId = i32;\n+        type GroupId = i32;\n+    } else {\n+        type UserId = u32;\n+        type GroupId = u32;\n+    }\n+}\n \n /// Unix-specific extensions to the [`process::Command`] builder.\n ///"}, {"sha": "95967eac29520740f3d10142cfee9f99fdda0493", "filename": "library/std/src/os/unix/ucred.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Funix%2Fucred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fos%2Funix%2Fucred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fucred.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -79,7 +79,8 @@ pub mod impl_linux {\n     target_os = \"dragonfly\",\n     target_os = \"freebsd\",\n     target_os = \"openbsd\",\n-    target_os = \"netbsd\"\n+    target_os = \"netbsd\",\n+    target_os = \"nto\",\n ))]\n pub mod impl_bsd {\n     use super::UCred;"}, {"sha": "6f78811a186c7ec6b6d3bb537407a860a66d8211", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -587,8 +587,10 @@ mod prim_pointer {}\n /// There are two syntactic forms for creating an array:\n ///\n /// * A list with each element, i.e., `[x, y, z]`.\n-/// * A repeat expression `[x; N]`, which produces an array with `N` copies of `x`.\n-///   The type of `x` must be [`Copy`].\n+/// * A repeat expression `[expr; N]` where `N` is how many times to repeat `expr` in the array. `expr` must either be:\n+///\n+///   * A value of a type implementing the [`Copy`] trait\n+///   * A `const` value\n ///\n /// Note that `[expr; 0]` is allowed, and produces an empty array.\n /// This will still evaluate `expr`, however, and immediately drop the resulting value, so"}, {"sha": "1952e19e60720f3fbc42f61374fa6a0ef45910c9", "filename": "library/std/src/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -1416,7 +1416,7 @@ impl From<fs::File> for Stdio {\n     /// use std::fs::File;\n     /// use std::process::Command;\n     ///\n-    /// // With the `foo.txt` file containing `Hello, world!\"\n+    /// // With the `foo.txt` file containing \"Hello, world!\"\n     /// let file = File::open(\"foo.txt\").unwrap();\n     ///\n     /// let reverse = Command::new(\"rev\")"}, {"sha": "ae0f718535b2694e83a2c03ebf911da00bf65478", "filename": "library/std/src/sys/itron/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -247,7 +247,7 @@ impl Thread {\n                 // [FINISHED \u2192 JOINED]\n                 // To synchronize with the child task's memory accesses to\n                 // `inner` up to the point of the assignment of `FINISHED`,\n-                // `Ordering::Acquire` must be used for the above `swap` call`.\n+                // `Ordering::Acquire` must be used for the above `swap` call.\n             }\n             _ => unsafe { hint::unreachable_unchecked() },\n         }"}, {"sha": "3d79058b320c5fbadadb5574df8d6a923b5f6d26", "filename": "library/std/src/sys/unix/args.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -69,7 +69,8 @@ impl DoubleEndedIterator for Args {\n     target_os = \"fuchsia\",\n     target_os = \"redox\",\n     target_os = \"vxworks\",\n-    target_os = \"horizon\"\n+    target_os = \"horizon\",\n+    target_os = \"nto\",\n ))]\n mod imp {\n     use super::Args;"}, {"sha": "1a9276f1110096416e008d0621ff8b0cdee66185", "filename": "library/std/src/sys/unix/env.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -185,6 +185,17 @@ pub mod os {\n     pub const EXE_EXTENSION: &str = \"\";\n }\n \n+#[cfg(target_os = \"nto\")]\n+pub mod os {\n+    pub const FAMILY: &str = \"unix\";\n+    pub const OS: &str = \"nto\";\n+    pub const DLL_PREFIX: &str = \"lib\";\n+    pub const DLL_SUFFIX: &str = \".so\";\n+    pub const DLL_EXTENSION: &str = \"so\";\n+    pub const EXE_SUFFIX: &str = \"\";\n+    pub const EXE_EXTENSION: &str = \"\";\n+}\n+\n #[cfg(target_os = \"redox\")]\n pub mod os {\n     pub const FAMILY: &str = \"unix\";"}, {"sha": "9874af4d3e2419614ac5df00b83fc6947dad1fe6", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 192, "deletions": 6, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -53,7 +53,12 @@ const fn max_iov() -> usize {\n     libc::IOV_MAX as usize\n }\n \n-#[cfg(any(target_os = \"android\", target_os = \"emscripten\", target_os = \"linux\"))]\n+#[cfg(any(\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"linux\",\n+    target_os = \"nto\",\n+))]\n const fn max_iov() -> usize {\n     libc::UIO_MAXIOV as usize\n }\n@@ -67,6 +72,7 @@ const fn max_iov() -> usize {\n     target_os = \"linux\",\n     target_os = \"macos\",\n     target_os = \"netbsd\",\n+    target_os = \"nto\",\n     target_os = \"openbsd\",\n     target_os = \"horizon\",\n     target_os = \"watchos\",\n@@ -92,7 +98,7 @@ impl FileDesc {\n         let ret = cvt(unsafe {\n             libc::readv(\n                 self.as_raw_fd(),\n-                bufs.as_ptr() as *const libc::iovec,\n+                bufs.as_mut_ptr() as *mut libc::iovec as *const libc::iovec,\n                 cmp::min(bufs.len(), max_iov()) as libc::c_int,\n             )\n         })?;\n@@ -101,7 +107,7 @@ impl FileDesc {\n \n     #[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))]\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        return crate::io::default_read_vectored(|b| self.read(b), bufs);\n+        io::default_read_vectored(|b| self.read(b), bufs)\n     }\n \n     #[inline]\n@@ -147,6 +153,95 @@ impl FileDesc {\n         Ok(())\n     }\n \n+    #[cfg(any(\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"fuchsia\",\n+        target_os = \"illumos\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+    ))]\n+    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::preadv(\n+                self.as_raw_fd(),\n+                bufs.as_mut_ptr() as *mut libc::iovec as *const libc::iovec,\n+                cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                offset as _,\n+            )\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    #[cfg(not(any(\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"fuchsia\",\n+        target_os = \"illumos\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"macos\",\n+        target_os = \"netbsd\",\n+    )))]\n+    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        io::default_read_vectored(|b| self.read_at(b, offset), bufs)\n+    }\n+\n+    // We support some old Android versions that do not have `preadv` in libc,\n+    // so we use weak linkage and fallback to a direct syscall if not available.\n+    //\n+    // On 32-bit targets, we don't want to deal with weird ABI issues around\n+    // passing 64-bits parameters to syscalls, so we fallback to the default\n+    // implementation if `preadv` is not available.\n+    #[cfg(all(target_os = \"android\", target_pointer_width = \"64\"))]\n+    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        super::weak::syscall! {\n+            fn preadv(\n+                fd: libc::c_int,\n+                iovec: *const libc::iovec,\n+                n_iovec: libc::c_int,\n+                offset: off64_t\n+            ) -> isize\n+        }\n+\n+        let ret = cvt(unsafe {\n+            preadv(\n+                self.as_raw_fd(),\n+                bufs.as_mut_ptr() as *mut libc::iovec as *const libc::iovec,\n+                cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                offset as _,\n+            )\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    // We support old MacOS and iOS versions that do not have `preadv`. There is\n+    // no `syscall` possible in these platform.\n+    #[cfg(any(\n+        all(target_os = \"android\", target_pointer_width = \"32\"),\n+        target_os = \"ios\",\n+        target_os = \"macos\",\n+    ))]\n+    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        super::weak::weak!(fn preadv64(libc::c_int, *const libc::iovec, libc::c_int, off64_t) -> isize);\n+\n+        match preadv64.get() {\n+            Some(preadv) => {\n+                let ret = cvt(unsafe {\n+                    preadv(\n+                        self.as_raw_fd(),\n+                        bufs.as_mut_ptr() as *mut libc::iovec as *const libc::iovec,\n+                        cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                        offset as _,\n+                    )\n+                })?;\n+                Ok(ret as usize)\n+            }\n+            None => io::default_read_vectored(|b| self.read_at(b, offset), bufs),\n+        }\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n             libc::write(\n@@ -172,7 +267,7 @@ impl FileDesc {\n \n     #[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))]\n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        return crate::io::default_write_vectored(|b| self.write(b), bufs);\n+        io::default_write_vectored(|b| self.write(b), bufs)\n     }\n \n     #[inline]\n@@ -197,6 +292,95 @@ impl FileDesc {\n         }\n     }\n \n+    #[cfg(any(\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"fuchsia\",\n+        target_os = \"illumos\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+    ))]\n+    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::pwritev(\n+                self.as_raw_fd(),\n+                bufs.as_ptr() as *const libc::iovec,\n+                cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                offset as _,\n+            )\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    #[cfg(not(any(\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"fuchsia\",\n+        target_os = \"illumos\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"macos\",\n+        target_os = \"netbsd\",\n+    )))]\n+    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        io::default_write_vectored(|b| self.write_at(b, offset), bufs)\n+    }\n+\n+    // We support some old Android versions that do not have `pwritev` in libc,\n+    // so we use weak linkage and fallback to a direct syscall if not available.\n+    //\n+    // On 32-bit targets, we don't want to deal with weird ABI issues around\n+    // passing 64-bits parameters to syscalls, so we fallback to the default\n+    // implementation if `pwritev` is not available.\n+    #[cfg(all(target_os = \"android\", target_pointer_width = \"64\"))]\n+    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        super::weak::syscall! {\n+            fn pwritev(\n+                fd: libc::c_int,\n+                iovec: *const libc::iovec,\n+                n_iovec: libc::c_int,\n+                offset: off64_t\n+            ) -> isize\n+        }\n+\n+        let ret = cvt(unsafe {\n+            pwritev(\n+                self.as_raw_fd(),\n+                bufs.as_ptr() as *const libc::iovec,\n+                cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                offset as _,\n+            )\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    // We support old MacOS and iOS versions that do not have `pwritev`. There is\n+    // no `syscall` possible in these platform.\n+    #[cfg(any(\n+        all(target_os = \"android\", target_pointer_width = \"32\"),\n+        target_os = \"ios\",\n+        target_os = \"macos\",\n+    ))]\n+    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        super::weak::weak!(fn pwritev64(libc::c_int, *const libc::iovec, libc::c_int, off64_t) -> isize);\n+\n+        match pwritev64.get() {\n+            Some(pwritev) => {\n+                let ret = cvt(unsafe {\n+                    pwritev(\n+                        self.as_raw_fd(),\n+                        bufs.as_ptr() as *const libc::iovec,\n+                        cmp::min(bufs.len(), max_iov()) as libc::c_int,\n+                        offset as _,\n+                    )\n+                })?;\n+                Ok(ret as usize)\n+            }\n+            None => io::default_write_vectored(|b| self.write_at(b, offset), bufs),\n+        }\n+    }\n+\n     #[cfg(not(any(\n         target_env = \"newlib\",\n         target_os = \"solaris\",\n@@ -207,7 +391,8 @@ impl FileDesc {\n         target_os = \"linux\",\n         target_os = \"haiku\",\n         target_os = \"redox\",\n-        target_os = \"vxworks\"\n+        target_os = \"vxworks\",\n+        target_os = \"nto\",\n     )))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n@@ -225,7 +410,8 @@ impl FileDesc {\n         target_os = \"linux\",\n         target_os = \"haiku\",\n         target_os = \"redox\",\n-        target_os = \"vxworks\"\n+        target_os = \"vxworks\",\n+        target_os = \"nto\",\n     ))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {"}, {"sha": "7566fafda24a9fbdfbea2d6bee72ad3dd65b2773", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 73, "deletions": 19, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -13,7 +13,8 @@ use crate::mem;\n     target_os = \"solaris\",\n     target_os = \"fuchsia\",\n     target_os = \"redox\",\n-    target_os = \"illumos\"\n+    target_os = \"illumos\",\n+    target_os = \"nto\",\n ))]\n use crate::mem::MaybeUninit;\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd};\n@@ -54,7 +55,8 @@ use libc::fstatat64;\n     target_os = \"solaris\",\n     target_os = \"fuchsia\",\n     target_os = \"redox\",\n-    target_os = \"illumos\"\n+    target_os = \"illumos\",\n+    target_os = \"nto\",\n ))]\n use libc::readdir as readdir64;\n #[cfg(target_os = \"linux\")]\n@@ -69,7 +71,8 @@ use libc::readdir64_r;\n     target_os = \"illumos\",\n     target_os = \"l4re\",\n     target_os = \"fuchsia\",\n-    target_os = \"redox\"\n+    target_os = \"redox\",\n+    target_os = \"nto\",\n )))]\n use libc::readdir_r as readdir64_r;\n #[cfg(target_os = \"android\")]\n@@ -277,7 +280,8 @@ unsafe impl Sync for Dir {}\n     target_os = \"solaris\",\n     target_os = \"illumos\",\n     target_os = \"fuchsia\",\n-    target_os = \"redox\"\n+    target_os = \"redox\",\n+    target_os = \"nto\",\n ))]\n pub struct DirEntry {\n     dir: Arc<InnerReadDir>,\n@@ -297,11 +301,12 @@ pub struct DirEntry {\n     target_os = \"solaris\",\n     target_os = \"illumos\",\n     target_os = \"fuchsia\",\n-    target_os = \"redox\"\n+    target_os = \"redox\",\n+    target_os = \"nto\",\n ))]\n struct dirent64_min {\n     d_ino: u64,\n-    #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\")))]\n+    #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\", target_os = \"nto\")))]\n     d_type: u8,\n }\n \n@@ -311,7 +316,8 @@ struct dirent64_min {\n     target_os = \"solaris\",\n     target_os = \"illumos\",\n     target_os = \"fuchsia\",\n-    target_os = \"redox\"\n+    target_os = \"redox\",\n+    target_os = \"nto\",\n )))]\n pub struct DirEntry {\n     dir: Arc<InnerReadDir>,\n@@ -438,7 +444,7 @@ impl FileAttr {\n     }\n }\n \n-#[cfg(not(target_os = \"netbsd\"))]\n+#[cfg(not(any(target_os = \"netbsd\", target_os = \"nto\")))]\n impl FileAttr {\n     #[cfg(not(any(target_os = \"vxworks\", target_os = \"espidf\", target_os = \"horizon\")))]\n     pub fn modified(&self) -> io::Result<SystemTime> {\n@@ -524,6 +530,21 @@ impl FileAttr {\n     }\n }\n \n+#[cfg(target_os = \"nto\")]\n+impl FileAttr {\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::new(self.stat.st_mtim.tv_sec, self.stat.st_mtim.tv_nsec))\n+    }\n+\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::new(self.stat.st_atim.tv_sec, self.stat.st_atim.tv_nsec))\n+    }\n+\n+    pub fn created(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::new(self.stat.st_ctim.tv_sec, self.stat.st_ctim.tv_nsec))\n+    }\n+}\n+\n impl AsInner<stat64> for FileAttr {\n     fn as_inner(&self) -> &stat64 {\n         &self.stat\n@@ -603,7 +624,8 @@ impl Iterator for ReadDir {\n         target_os = \"solaris\",\n         target_os = \"fuchsia\",\n         target_os = \"redox\",\n-        target_os = \"illumos\"\n+        target_os = \"illumos\",\n+        target_os = \"nto\",\n     ))]\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n         if self.end_of_stream {\n@@ -686,7 +708,11 @@ impl Iterator for ReadDir {\n \n                 let entry = dirent64_min {\n                     d_ino: *offset_ptr!(entry_ptr, d_ino) as u64,\n-                    #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\")))]\n+                    #[cfg(not(any(\n+                        target_os = \"solaris\",\n+                        target_os = \"illumos\",\n+                        target_os = \"nto\",\n+                    )))]\n                     d_type: *offset_ptr!(entry_ptr, d_type) as u8,\n                 };\n \n@@ -705,7 +731,8 @@ impl Iterator for ReadDir {\n         target_os = \"solaris\",\n         target_os = \"fuchsia\",\n         target_os = \"redox\",\n-        target_os = \"illumos\"\n+        target_os = \"illumos\",\n+        target_os = \"nto\",\n     )))]\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n         if self.end_of_stream {\n@@ -794,7 +821,8 @@ impl DirEntry {\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n         target_os = \"haiku\",\n-        target_os = \"vxworks\"\n+        target_os = \"vxworks\",\n+        target_os = \"nto\",\n     ))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         self.metadata().map(|m| m.file_type())\n@@ -804,7 +832,8 @@ impl DirEntry {\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n         target_os = \"haiku\",\n-        target_os = \"vxworks\"\n+        target_os = \"vxworks\",\n+        target_os = \"nto\",\n     )))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         match self.entry.d_type {\n@@ -834,7 +863,8 @@ impl DirEntry {\n         target_os = \"redox\",\n         target_os = \"vxworks\",\n         target_os = \"espidf\",\n-        target_os = \"horizon\"\n+        target_os = \"horizon\",\n+        target_os = \"nto\",\n     ))]\n     pub fn ino(&self) -> u64 {\n         self.entry.d_ino as u64\n@@ -887,7 +917,8 @@ impl DirEntry {\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n         target_os = \"fuchsia\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"nto\",\n     )))]\n     fn name_cstr(&self) -> &CStr {\n         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }\n@@ -898,7 +929,8 @@ impl DirEntry {\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n         target_os = \"fuchsia\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"nto\",\n     ))]\n     fn name_cstr(&self) -> &CStr {\n         &self.name\n@@ -1051,7 +1083,8 @@ impl File {\n             target_os = \"linux\",\n             target_os = \"android\",\n             target_os = \"netbsd\",\n-            target_os = \"openbsd\"\n+            target_os = \"openbsd\",\n+            target_os = \"nto\",\n         ))]\n         unsafe fn os_datasync(fd: c_int) -> c_int {\n             libc::fdatasync(fd)\n@@ -1065,6 +1098,7 @@ impl File {\n             target_os = \"netbsd\",\n             target_os = \"openbsd\",\n             target_os = \"watchos\",\n+            target_os = \"nto\",\n         )))]\n         unsafe fn os_datasync(fd: c_int) -> c_int {\n             libc::fsync(fd)\n@@ -1098,6 +1132,10 @@ impl File {\n         self.0.read_buf(cursor)\n     }\n \n+    pub fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n+        self.0.read_vectored_at(bufs, offset)\n+    }\n+\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n     }\n@@ -1115,6 +1153,10 @@ impl File {\n         self.0.write_at(buf, offset)\n     }\n \n+    pub fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n+        self.0.write_vectored_at(bufs, offset)\n+    }\n+\n     pub fn flush(&self) -> io::Result<()> {\n         Ok(())\n     }\n@@ -1750,13 +1792,25 @@ pub fn chroot(dir: &Path) -> io::Result<()> {\n pub use remove_dir_impl::remove_dir_all;\n \n // Fallback for REDOX, ESP-ID, Horizon, and Miri\n-#[cfg(any(target_os = \"redox\", target_os = \"espidf\", target_os = \"horizon\", miri))]\n+#[cfg(any(\n+    target_os = \"redox\",\n+    target_os = \"espidf\",\n+    target_os = \"horizon\",\n+    target_os = \"nto\",\n+    miri\n+))]\n mod remove_dir_impl {\n     pub use crate::sys_common::fs::remove_dir_all;\n }\n \n // Modern implementation using openat(), unlinkat() and fdopendir()\n-#[cfg(not(any(target_os = \"redox\", target_os = \"espidf\", target_os = \"horizon\", miri)))]\n+#[cfg(not(any(\n+    target_os = \"redox\",\n+    target_os = \"espidf\",\n+    target_os = \"horizon\",\n+    target_os = \"nto\",\n+    miri\n+)))]\n mod remove_dir_impl {\n     use super::{lstat, Dir, DirEntry, InnerReadDir, ReadDir};\n     use crate::ffi::CStr;"}, {"sha": "192fa216dfaf5e7c40f6102be89cfda7dbcd918b", "filename": "library/std/src/sys/unix/locks/pthread_condvar.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -2,7 +2,10 @@ use crate::cell::UnsafeCell;\n use crate::ptr;\n use crate::sync::atomic::{AtomicPtr, Ordering::Relaxed};\n use crate::sys::locks::{pthread_mutex, Mutex};\n+#[cfg(not(target_os = \"nto\"))]\n use crate::sys::time::TIMESPEC_MAX;\n+#[cfg(target_os = \"nto\")]\n+use crate::sys::time::TIMESPEC_MAX_CAPPED;\n use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n use crate::time::Duration;\n \n@@ -132,10 +135,18 @@ impl Condvar {\n         let mutex = pthread_mutex::raw(mutex);\n         self.verify(mutex);\n \n+        #[cfg(not(target_os = \"nto\"))]\n         let timeout = Timespec::now(libc::CLOCK_MONOTONIC)\n             .checked_add_duration(&dur)\n             .and_then(|t| t.to_timespec())\n             .unwrap_or(TIMESPEC_MAX);\n+\n+        #[cfg(target_os = \"nto\")]\n+        let timeout = Timespec::now(libc::CLOCK_MONOTONIC)\n+            .checked_add_duration(&dur)\n+            .and_then(|t| t.to_timespec_capped())\n+            .unwrap_or(TIMESPEC_MAX_CAPPED);\n+\n         let r = libc::pthread_cond_timedwait(raw(self), mutex, &timeout);\n         assert!(r == libc::ETIMEDOUT || r == 0);\n         r == 0"}, {"sha": "68c9520cc9eb4fd40a989063c12a550a1fa38140", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -329,7 +329,7 @@ pub fn cvt_nz(error: libc::c_int) -> crate::io::Result<()> {\n // do so.  In 1003.1-2004 this was fixed.\n //\n // glibc's implementation did the flush, unsafely, before glibc commit\n-// 91e7cf982d01 `abort: Do not flush stdio streams [BZ #15436]' by Florian\n+// 91e7cf982d01 `abort: Do not flush stdio streams [BZ #15436]` by Florian\n // Weimer.  According to glibc's NEWS:\n //\n //    The abort function terminates the process immediately, without flushing"}, {"sha": "8e05b618daa02a0bd9455c08087534e77eb5a327", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -78,6 +78,7 @@ impl Socket {\n                     target_os = \"linux\",\n                     target_os = \"netbsd\",\n                     target_os = \"openbsd\",\n+                    target_os = \"nto\",\n                 ))] {\n                     // On platforms that support it we pass the SOCK_CLOEXEC\n                     // flag to atomically create the socket and set it as\n@@ -115,6 +116,7 @@ impl Socket {\n                     target_os = \"linux\",\n                     target_os = \"netbsd\",\n                     target_os = \"openbsd\",\n+                    target_os = \"nto\",\n                 ))] {\n                     // Like above, set cloexec atomically\n                     cvt(libc::socketpair(fam, ty | libc::SOCK_CLOEXEC, 0, fds.as_mut_ptr()))?;"}, {"sha": "21b035fb37379f3df9719109dde40cf5d04cb47f", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=9f3c3ffaf83f9226f81c200c7bf8a04e4e3d5715", "patch": "@@ -62,6 +62,7 @@ extern \"C\" {\n         link_name = \"__errno\"\n     )]\n     #[cfg_attr(any(target_os = \"solaris\", target_os = \"illumos\"), link_name = \"___errno\")]\n+    #[cfg_attr(target_os = \"nto\", link_name = \"__get_errno_ptr\")]\n     #[cfg_attr(\n         any(target_os = \"macos\", target_os = \"ios\", target_os = \"freebsd\", target_os = \"watchos\"),\n         link_name = \"__error\"\n@@ -361,6 +362,17 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     }\n }\n \n+#[cfg(target_os = \"nto\")]\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    let mut e = crate::fs::read(\"/proc/self/exefile\")?;\n+    // Current versions of QNX Neutrino provide a null-terminated path.\n+    // Ensure the trailing null byte is not returned here.\n+    if let Some(0) = e.last() {\n+        e.pop();\n+    }\n+    Ok(PathBuf::from(OsString::from_vec(e)))\n+}\n+\n #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n     unsafe {"}]}