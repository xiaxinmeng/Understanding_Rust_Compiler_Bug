{"sha": "61ddf5e85cdc46cff8617088594d7916d597e87e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZGRmNWU4NWNkYzQ2Y2ZmODYxNzA4ODU5NGQ3OTE2ZDU5N2U4N2U=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-27T20:46:23Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-07-04T19:23:21Z"}, "message": "Create async version of the dynamic-drop test", "tree": {"sha": "a0701f46c1ba2726b9b97c42ded55a2c29559e26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0701f46c1ba2726b9b97c42ded55a2c29559e26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61ddf5e85cdc46cff8617088594d7916d597e87e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61ddf5e85cdc46cff8617088594d7916d597e87e", "html_url": "https://github.com/rust-lang/rust/commit/61ddf5e85cdc46cff8617088594d7916d597e87e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61ddf5e85cdc46cff8617088594d7916d597e87e/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "088b987307b91612ab164026e1dcdd0129fdb62b", "url": "https://api.github.com/repos/rust-lang/rust/commits/088b987307b91612ab164026e1dcdd0129fdb62b", "html_url": "https://github.com/rust-lang/rust/commit/088b987307b91612ab164026e1dcdd0129fdb62b"}], "stats": {"total": 328, "additions": 328, "deletions": 0}, "files": [{"sha": "9226145d9354de3ee119bb8d159655b7aa63d725", "filename": "src/test/run-pass/drop/dynamic-drop-async.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/61ddf5e85cdc46cff8617088594d7916d597e87e/src%2Ftest%2Frun-pass%2Fdrop%2Fdynamic-drop-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ddf5e85cdc46cff8617088594d7916d597e87e/src%2Ftest%2Frun-pass%2Fdrop%2Fdynamic-drop-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop%2Fdynamic-drop-async.rs?ref=61ddf5e85cdc46cff8617088594d7916d597e87e", "patch": "@@ -0,0 +1,328 @@\n+// Test that values are not leaked in async functions, even in the cases where:\n+// * Dropping one of the values panics while running the future.\n+// * The future is dropped at one of its suspend points.\n+// * Dropping one of the values panics while dropping the future.\n+\n+// run-pass\n+// edition:2018\n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n+#![allow(unused_assignments)]\n+#![allow(unused_variables)]\n+#![feature(slice_patterns)]\n+#![feature(async_await)]\n+\n+use std::{\n+    cell::{Cell, RefCell},\n+    future::Future,\n+    marker::Unpin,\n+    panic,\n+    pin::Pin,\n+    ptr,\n+    rc::Rc,\n+    task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+    usize,\n+};\n+\n+struct InjectedFailure;\n+\n+struct Defer<T> {\n+    ready: bool,\n+    value: Option<T>,\n+}\n+\n+impl<T: Unpin> Future for Defer<T> {\n+    type Output = T;\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n+        if self.ready {\n+            Poll::Ready(self.value.take().unwrap())\n+        } else {\n+            self.ready = true;\n+            Poll::Pending\n+        }\n+    }\n+}\n+\n+/// Allocator tracks the creation and destruction of `Ptr`s.\n+/// The `failing_op`-th operation will panic.\n+struct Allocator {\n+    data: RefCell<Vec<bool>>,\n+    failing_op: usize,\n+    cur_ops: Cell<usize>,\n+}\n+\n+impl panic::UnwindSafe for Allocator {}\n+impl panic::RefUnwindSafe for Allocator {}\n+\n+impl Drop for Allocator {\n+    fn drop(&mut self) {\n+        let data = self.data.borrow();\n+        if data.iter().any(|d| *d) {\n+            panic!(\"missing free: {:?}\", data);\n+        }\n+    }\n+}\n+\n+impl Allocator {\n+    fn new(failing_op: usize) -> Self {\n+        Allocator { failing_op, cur_ops: Cell::new(0), data: RefCell::new(vec![]) }\n+    }\n+    fn alloc(&self) -> impl Future<Output = Ptr<'_>> + '_ {\n+        self.fallible_operation();\n+\n+        let mut data = self.data.borrow_mut();\n+\n+        let addr = data.len();\n+        data.push(true);\n+        Defer { ready: false, value: Some(Ptr(addr, self)) }\n+    }\n+    fn fallible_operation(&self) {\n+        self.cur_ops.set(self.cur_ops.get() + 1);\n+\n+        if self.cur_ops.get() == self.failing_op {\n+            panic!(InjectedFailure);\n+        }\n+    }\n+}\n+\n+// Type that tracks whether it was dropped and can panic when it's created or\n+// destroyed.\n+struct Ptr<'a>(usize, &'a Allocator);\n+impl<'a> Drop for Ptr<'a> {\n+    fn drop(&mut self) {\n+        match self.1.data.borrow_mut()[self.0] {\n+            false => panic!(\"double free at index {:?}\", self.0),\n+            ref mut d => *d = false,\n+        }\n+\n+        self.1.fallible_operation();\n+    }\n+}\n+\n+async fn dynamic_init(a: Rc<Allocator>, c: bool) {\n+    let _x;\n+    if c {\n+        _x = Some(a.alloc().await);\n+    }\n+}\n+\n+async fn dynamic_drop(a: Rc<Allocator>, c: bool) {\n+    let x = a.alloc().await;\n+    if c {\n+        Some(x)\n+    } else {\n+        None\n+    };\n+}\n+\n+struct TwoPtrs<'a>(Ptr<'a>, Ptr<'a>);\n+async fn struct_dynamic_drop(a: Rc<Allocator>, c0: bool, c1: bool, c: bool) {\n+    for i in 0..2 {\n+        let x;\n+        let y;\n+        if (c0 && i == 0) || (c1 && i == 1) {\n+            x = (a.alloc().await, a.alloc().await, a.alloc().await);\n+            y = TwoPtrs(a.alloc().await, a.alloc().await);\n+            if c {\n+                drop(x.1);\n+                a.alloc().await;\n+                drop(y.0);\n+                a.alloc().await;\n+            }\n+        }\n+    }\n+}\n+\n+async fn field_assignment(a: Rc<Allocator>, c0: bool) {\n+    let mut x = (TwoPtrs(a.alloc().await, a.alloc().await), a.alloc().await);\n+\n+    x.1 = a.alloc().await;\n+    x.1 = a.alloc().await;\n+\n+    let f = (x.0).0;\n+    a.alloc().await;\n+    if c0 {\n+        (x.0).0 = f;\n+    }\n+    a.alloc().await;\n+}\n+\n+async fn assignment(a: Rc<Allocator>, c0: bool, c1: bool) {\n+    let mut _v = a.alloc().await;\n+    let mut _w = a.alloc().await;\n+    if c0 {\n+        drop(_v);\n+    }\n+    _v = _w;\n+    if c1 {\n+        _w = a.alloc().await;\n+    }\n+}\n+\n+async fn array_simple(a: Rc<Allocator>) {\n+    let _x = [a.alloc().await, a.alloc().await, a.alloc().await, a.alloc().await];\n+}\n+\n+async fn vec_simple(a: Rc<Allocator>) {\n+    let _x = vec![a.alloc().await, a.alloc().await, a.alloc().await, a.alloc().await];\n+}\n+\n+async fn mixed_drop_and_nondrop(a: Rc<Allocator>) {\n+    // check that destructor panics handle drop\n+    // and non-drop blocks in the same scope correctly.\n+    //\n+    // Surprisingly enough, this used to not work.\n+    let (x, y, z);\n+    x = a.alloc().await;\n+    y = 5;\n+    z = a.alloc().await;\n+}\n+\n+#[allow(unreachable_code)]\n+async fn vec_unreachable(a: Rc<Allocator>) {\n+    let _x = vec![a.alloc().await, a.alloc().await, a.alloc().await, return];\n+}\n+\n+async fn slice_pattern_one_of(a: Rc<Allocator>, i: usize) {\n+    let array = [a.alloc().await, a.alloc().await, a.alloc().await, a.alloc().await];\n+    let _x = match i {\n+        0 => {\n+            let [a, ..] = array;\n+            a\n+        }\n+        1 => {\n+            let [_, a, ..] = array;\n+            a\n+        }\n+        2 => {\n+            let [_, _, a, _] = array;\n+            a\n+        }\n+        3 => {\n+            let [_, _, _, a] = array;\n+            a\n+        }\n+        _ => panic!(\"unmatched\"),\n+    };\n+    a.alloc().await;\n+}\n+\n+async fn subslice_pattern_from_end_with_drop(a: Rc<Allocator>, arg: bool, arg2: bool) {\n+    let arr = [a.alloc().await, a.alloc().await, a.alloc().await, a.alloc().await, a.alloc().await];\n+    if arg2 {\n+        drop(arr);\n+        return;\n+    }\n+\n+    if arg {\n+        let [.., _x, _] = arr;\n+    } else {\n+        let [_, _y..] = arr;\n+    }\n+    a.alloc().await;\n+}\n+\n+async fn subslice_pattern_reassign(a: Rc<Allocator>) {\n+    let mut ar = [a.alloc().await, a.alloc().await, a.alloc().await];\n+    let [_, _, _x] = ar;\n+    ar = [a.alloc().await, a.alloc().await, a.alloc().await];\n+    let [_, _y..] = ar;\n+    a.alloc().await;\n+}\n+\n+fn run_test<F, G>(cx: &mut Context<'_>, ref f: F)\n+where\n+    F: Fn(Rc<Allocator>) -> G,\n+    G: Future<Output = ()>,\n+{\n+    for polls in 0.. {\n+        // Run without any panics to find which operations happen after the\n+        // penultimate `poll`.\n+        let first_alloc = Rc::new(Allocator::new(usize::MAX));\n+        let mut fut = Box::pin(f(first_alloc.clone()));\n+        let mut ops_before_last_poll = 0;\n+        let mut completed = false;\n+        for _ in 0..polls {\n+            ops_before_last_poll = first_alloc.cur_ops.get();\n+            if let Poll::Ready(()) = fut.as_mut().poll(cx) {\n+                completed = true;\n+            }\n+        }\n+        drop(fut);\n+\n+        // Start at `ops_before_last_poll` so that we will always be able to\n+        // `poll` the expected number of times.\n+        for failing_op in ops_before_last_poll..first_alloc.cur_ops.get() {\n+            let alloc = Rc::new(Allocator::new(failing_op + 1));\n+            let f = &f;\n+            let cx = &mut *cx;\n+            let result = panic::catch_unwind(panic::AssertUnwindSafe(move || {\n+                let mut fut = Box::pin(f(alloc));\n+                for _ in 0..polls {\n+                    let _ = fut.as_mut().poll(cx);\n+                }\n+                drop(fut);\n+            }));\n+            match result {\n+                Ok(..) => panic!(\"test executed more ops on first call\"),\n+                Err(e) => {\n+                    if e.downcast_ref::<InjectedFailure>().is_none() {\n+                        panic::resume_unwind(e);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if completed {\n+            break;\n+        }\n+    }\n+}\n+\n+fn clone_waker(data: *const ()) -> RawWaker {\n+    RawWaker::new(data, &RawWakerVTable::new(clone_waker, drop, drop, drop))\n+}\n+\n+fn main() {\n+    let waker = unsafe { Waker::from_raw(clone_waker(ptr::null())) };\n+    let context = &mut Context::from_waker(&waker);\n+\n+    run_test(context, |a| dynamic_init(a, false));\n+    run_test(context, |a| dynamic_init(a, true));\n+    run_test(context, |a| dynamic_drop(a, false));\n+    run_test(context, |a| dynamic_drop(a, true));\n+\n+    run_test(context, |a| assignment(a, false, false));\n+    run_test(context, |a| assignment(a, false, true));\n+    run_test(context, |a| assignment(a, true, false));\n+    run_test(context, |a| assignment(a, true, true));\n+\n+    run_test(context, |a| array_simple(a));\n+    run_test(context, |a| vec_simple(a));\n+    run_test(context, |a| vec_unreachable(a));\n+\n+    run_test(context, |a| struct_dynamic_drop(a, false, false, false));\n+    run_test(context, |a| struct_dynamic_drop(a, false, false, true));\n+    run_test(context, |a| struct_dynamic_drop(a, false, true, false));\n+    run_test(context, |a| struct_dynamic_drop(a, false, true, true));\n+    run_test(context, |a| struct_dynamic_drop(a, true, false, false));\n+    run_test(context, |a| struct_dynamic_drop(a, true, false, true));\n+    run_test(context, |a| struct_dynamic_drop(a, true, true, false));\n+    run_test(context, |a| struct_dynamic_drop(a, true, true, true));\n+\n+    run_test(context, |a| field_assignment(a, false));\n+    run_test(context, |a| field_assignment(a, true));\n+\n+    run_test(context, |a| mixed_drop_and_nondrop(a));\n+\n+    run_test(context, |a| slice_pattern_one_of(a, 0));\n+    run_test(context, |a| slice_pattern_one_of(a, 1));\n+    run_test(context, |a| slice_pattern_one_of(a, 2));\n+    run_test(context, |a| slice_pattern_one_of(a, 3));\n+\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, true, true));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, true, false));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, false, true));\n+    run_test(context, |a| subslice_pattern_from_end_with_drop(a, false, false));\n+    run_test(context, |a| subslice_pattern_reassign(a));\n+}"}]}