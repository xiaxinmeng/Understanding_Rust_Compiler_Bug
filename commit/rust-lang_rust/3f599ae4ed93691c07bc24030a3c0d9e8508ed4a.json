{"sha": "3f599ae4ed93691c07bc24030a3c0d9e8508ed4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNTk5YWU0ZWQ5MzY5MWMwN2JjMjQwMzBhM2MwZDllODUwOGVkNGE=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-04-07T14:37:47Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-04-07T14:38:04Z"}, "message": "Rewrite, reparse modified file", "tree": {"sha": "525e6d80c425f3b747042a359fecef92e2c2f859", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/525e6d80c425f3b747042a359fecef92e2c2f859"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f599ae4ed93691c07bc24030a3c0d9e8508ed4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f599ae4ed93691c07bc24030a3c0d9e8508ed4a", "html_url": "https://github.com/rust-lang/rust/commit/3f599ae4ed93691c07bc24030a3c0d9e8508ed4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f599ae4ed93691c07bc24030a3c0d9e8508ed4a/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17a1011a12d270dfaf83a404dd7c40c5d9967064", "url": "https://api.github.com/repos/rust-lang/rust/commits/17a1011a12d270dfaf83a404dd7c40c5d9967064", "html_url": "https://github.com/rust-lang/rust/commit/17a1011a12d270dfaf83a404dd7c40c5d9967064"}], "stats": {"total": 163, "additions": 114, "deletions": 49}, "files": [{"sha": "9050853ce695e1f4c4974b1cad0727486c7424d5", "filename": "crates/ide/src/typing.rs", "status": "modified", "additions": 114, "deletions": 49, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/3f599ae4ed93691c07bc24030a3c0d9e8508ed4a/crates%2Fide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f599ae4ed93691c07bc24030a3c0d9e8508ed4a/crates%2Fide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ftyping.rs?ref=3f599ae4ed93691c07bc24030a3c0d9e8508ed4a", "patch": "@@ -22,12 +22,12 @@ use ide_db::{\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, edit::IndentLevel, AstToken},\n-    AstNode, SourceFile,\n+    AstNode, Parse, SourceFile,\n     SyntaxKind::{FIELD_EXPR, METHOD_CALL_EXPR},\n     TextRange, TextSize,\n };\n \n-use text_edit::TextEdit;\n+use text_edit::{Indel, TextEdit};\n \n use crate::SourceChange;\n \n@@ -59,42 +59,61 @@ pub(crate) fn on_char_typed(\n     char_typed: char,\n ) -> Option<SourceChange> {\n     assert!(TRIGGER_CHARS.contains(char_typed));\n-    let file = &db.parse(position.file_id).tree();\n-    assert_eq!(file.syntax().text().char_at(position.offset), Some(char_typed));\n+    let file = &db.parse(position.file_id);\n+    assert_eq!(file.tree().syntax().text().char_at(position.offset), Some(char_typed));\n     let edit = on_char_typed_inner(file, position.offset, char_typed)?;\n     Some(SourceChange::from_text_edit(position.file_id, edit))\n }\n \n-fn on_char_typed_inner(file: &SourceFile, offset: TextSize, char_typed: char) -> Option<TextEdit> {\n+fn on_char_typed_inner(\n+    file: &Parse<SourceFile>,\n+    offset: TextSize,\n+    char_typed: char,\n+) -> Option<TextEdit> {\n     assert!(TRIGGER_CHARS.contains(char_typed));\n     match char_typed {\n-        '.' => on_dot_typed(file, offset),\n-        '=' => on_eq_typed(file, offset),\n-        '>' => on_arrow_typed(file, offset),\n+        '.' => on_dot_typed(&file.tree(), offset),\n+        '=' => on_eq_typed(&file.tree(), offset),\n+        '>' => on_arrow_typed(&file.tree(), offset),\n         '{' => on_opening_brace_typed(file, offset),\n         _ => unreachable!(),\n     }\n }\n \n /// Inserts a closing `}` when the user types an opening `{`, wrapping an existing expression in a\n /// block.\n-fn on_opening_brace_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {\n-    stdx::always!(file.syntax().text().char_at(offset) == Some('{'));\n-    let brace_token = file.syntax().token_at_offset(offset).right_biased()?;\n-    let block = ast::BlockExpr::cast(brace_token.parent()?)?;\n-\n-    // We expect a block expression enclosing exactly 1 preexisting expression. It can be parsed as\n-    // either the trailing expr or an ExprStmt.\n-    let offset = match block.statements().next() {\n-        Some(ast::Stmt::ExprStmt(it)) => {\n-            // Use the expression span to place `}` before the `;`\n-            it.expr()?.syntax().text_range().end()\n+fn on_opening_brace_typed(file: &Parse<SourceFile>, offset: TextSize) -> Option<TextEdit> {\n+    stdx::always!(file.tree().syntax().text().char_at(offset) == Some('{'));\n+\n+    let brace_token = file.tree().syntax().token_at_offset(offset).right_biased()?;\n+\n+    // Remove the `{` to get a better parse tree, and reparse\n+    let file = file.reparse(&Indel::delete(brace_token.text_range()));\n+\n+    let mut expr: ast::Expr = find_node_at_offset(file.tree().syntax(), offset)?;\n+    if expr.syntax().text_range().start() != offset {\n+        return None;\n+    }\n+\n+    // Enclose the outermost expression starting at `offset`\n+    while let Some(parent) = expr.syntax().parent() {\n+        if parent.text_range().start() != expr.syntax().text_range().start() {\n+            break;\n         }\n-        None => block.tail_expr()?.syntax().text_range().end(),\n-        _ => return None,\n-    };\n \n-    Some(TextEdit::insert(offset, \"}\".to_string()))\n+        match ast::Expr::cast(parent) {\n+            Some(parent) => expr = parent,\n+            None => break,\n+        }\n+    }\n+\n+    // If it's a statement in a block, we don't know how many statements should be included\n+    if ast::ExprStmt::can_cast(expr.syntax().parent()?.kind()) {\n+        return None;\n+    }\n+\n+    // Insert `}` right after the expression.\n+    Some(TextEdit::insert(expr.syntax().text_range().end() + TextSize::of(\"{\"), \"}\".to_string()))\n }\n \n /// Returns an edit which should be applied after `=` was typed. Primarily,\n@@ -175,7 +194,7 @@ mod tests {\n         let edit = TextEdit::insert(offset, char_typed.to_string());\n         edit.apply(&mut before);\n         let parse = SourceFile::parse(&before);\n-        on_char_typed_inner(&parse.tree(), offset, char_typed).map(|it| {\n+        on_char_typed_inner(&parse, offset, char_typed).map(|it| {\n             it.apply(&mut before);\n             before.to_string()\n         })\n@@ -399,36 +418,82 @@ fn main() {\n \n     #[test]\n     fn adds_closing_brace() {\n-        type_char('{', r\"fn f() { match () { _ => $0() } }\", r\"fn f() { match () { _ => {()} } }\");\n-        type_char('{', r\"fn f() { $0(); }\", r\"fn f() { {()}; }\");\n-        type_char('{', r\"fn f() { let x = $0(); }\", r\"fn f() { let x = {()}; }\");\n         type_char(\n             '{',\n-            r\"\n-            const S: () = $0();\n-            fn f() {}\n-            \",\n-            r\"\n-            const S: () = {()};\n-            fn f() {}\n-            \",\n+            r#\"\n+fn f() { match () { _ => $0() } }\n+            \"#,\n+            r#\"\n+fn f() { match () { _ => {()} } }\n+            \"#,\n         );\n         type_char(\n             '{',\n-            r\"\n-            fn f() {\n-                match x {\n-                    0 => $0(),\n-                    1 => (),\n-                }\n-            }\",\n-            r\"\n-            fn f() {\n-                match x {\n-                    0 => {()},\n-                    1 => (),\n-                }\n-            }\",\n+            r#\"\n+fn f() { $0() }\n+            \"#,\n+            r#\"\n+fn f() { {()} }\n+            \"#,\n+        );\n+        type_char(\n+            '{',\n+            r#\"\n+fn f() { let x = $0(); }\n+            \"#,\n+            r#\"\n+fn f() { let x = {()}; }\n+            \"#,\n+        );\n+        type_char(\n+            '{',\n+            r#\"\n+fn f() { let x = $0a.b(); }\n+            \"#,\n+            r#\"\n+fn f() { let x = {a.b()}; }\n+            \"#,\n+        );\n+        type_char(\n+            '{',\n+            r#\"\n+const S: () = $0();\n+fn f() {}\n+            \"#,\n+            r#\"\n+const S: () = {()};\n+fn f() {}\n+            \"#,\n+        );\n+        type_char(\n+            '{',\n+            r#\"\n+const S: () = $0a.b();\n+fn f() {}\n+            \"#,\n+            r#\"\n+const S: () = {a.b()};\n+fn f() {}\n+            \"#,\n+        );\n+        type_char(\n+            '{',\n+            r#\"\n+fn f() {\n+    match x {\n+        0 => $0(),\n+        1 => (),\n+    }\n+}\n+            \"#,\n+            r#\"\n+fn f() {\n+    match x {\n+        0 => {()},\n+        1 => (),\n+    }\n+}\n+            \"#,\n         );\n     }\n }"}]}