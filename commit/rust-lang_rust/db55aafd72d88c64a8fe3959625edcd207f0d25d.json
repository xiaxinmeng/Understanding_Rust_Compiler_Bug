{"sha": "db55aafd72d88c64a8fe3959625edcd207f0d25d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNTVhYWZkNzJkODhjNjRhOGZlMzk1OTYyNWVkY2QyMDdmMGQyNWQ=", "commit": {"author": {"name": "chansuke", "email": "chansuke@georepublic.de", "date": "2019-06-05T19:20:49Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-16T11:17:01Z"}, "message": "Separate libserialize module", "tree": {"sha": "0f02e9b0c3517dfd2090ff0933a4ab74bf50e805", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f02e9b0c3517dfd2090ff0933a4ab74bf50e805"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db55aafd72d88c64a8fe3959625edcd207f0d25d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db55aafd72d88c64a8fe3959625edcd207f0d25d", "html_url": "https://github.com/rust-lang/rust/commit/db55aafd72d88c64a8fe3959625edcd207f0d25d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db55aafd72d88c64a8fe3959625edcd207f0d25d/comments", "author": null, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46e622beb96929b0904a7e6031e29e1b03dcb728", "url": "https://api.github.com/repos/rust-lang/rust/commits/46e622beb96929b0904a7e6031e29e1b03dcb728", "html_url": "https://github.com/rust-lang/rust/commit/46e622beb96929b0904a7e6031e29e1b03dcb728"}], "stats": {"total": 422, "additions": 210, "deletions": 212}, "files": [{"sha": "95d92f311ed3cdb48db3fc6ca6c61920439b9a05", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 1, "deletions": 76, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/db55aafd72d88c64a8fe3959625edcd207f0d25d/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db55aafd72d88c64a8fe3959625edcd207f0d25d/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=db55aafd72d88c64a8fe3959625edcd207f0d25d", "patch": "@@ -143,79 +143,4 @@ impl FromHex for str {\n }\n \n #[cfg(test)]\n-mod tests {\n-    extern crate test;\n-    use test::Bencher;\n-    use crate::hex::{FromHex, ToHex};\n-\n-    #[test]\n-    pub fn test_to_hex() {\n-        assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\");\n-    }\n-\n-    #[test]\n-    pub fn test_from_hex_okay() {\n-        assert_eq!(\"666f6f626172\".from_hex().unwrap(),\n-                   b\"foobar\");\n-        assert_eq!(\"666F6F626172\".from_hex().unwrap(),\n-                   b\"foobar\");\n-    }\n-\n-    #[test]\n-    pub fn test_from_hex_odd_len() {\n-        assert!(\"666\".from_hex().is_err());\n-        assert!(\"66 6\".from_hex().is_err());\n-    }\n-\n-    #[test]\n-    pub fn test_from_hex_invalid_char() {\n-        assert!(\"66y6\".from_hex().is_err());\n-    }\n-\n-    #[test]\n-    pub fn test_from_hex_ignores_whitespace() {\n-        assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap(),\n-                   b\"foobar\");\n-    }\n-\n-    #[test]\n-    pub fn test_to_hex_all_bytes() {\n-        for i in 0..256 {\n-            assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as usize));\n-        }\n-    }\n-\n-    #[test]\n-    pub fn test_from_hex_all_bytes() {\n-        for i in 0..256 {\n-            let ii: &[u8] = &[i as u8];\n-            assert_eq!(format!(\"{:02x}\", i as usize).from_hex()\n-                                                   .unwrap(),\n-                       ii);\n-            assert_eq!(format!(\"{:02X}\", i as usize).from_hex()\n-                                                   .unwrap(),\n-                       ii);\n-        }\n-    }\n-\n-    #[bench]\n-    pub fn bench_to_hex(b: &mut Bencher) {\n-        let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n-                 \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-        b.iter(|| {\n-            s.as_bytes().to_hex();\n-        });\n-        b.bytes = s.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn bench_from_hex(b: &mut Bencher) {\n-        let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n-                 \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-        let sb = s.as_bytes().to_hex();\n-        b.iter(|| {\n-            sb.from_hex().unwrap();\n-        });\n-        b.bytes = sb.len() as u64;\n-    }\n-}\n+mod tests;"}, {"sha": "471912c11d06fd69de0f204bc1acbd8bcf5f3438", "filename": "src/libserialize/hex/tests.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/db55aafd72d88c64a8fe3959625edcd207f0d25d/src%2Flibserialize%2Fhex%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db55aafd72d88c64a8fe3959625edcd207f0d25d/src%2Flibserialize%2Fhex%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex%2Ftests.rs?ref=db55aafd72d88c64a8fe3959625edcd207f0d25d", "patch": "@@ -0,0 +1,74 @@\n+extern crate test;\n+use test::Bencher;\n+use crate::hex::{FromHex, ToHex};\n+\n+#[test]\n+pub fn test_to_hex() {\n+    assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\");\n+}\n+\n+#[test]\n+pub fn test_from_hex_okay() {\n+    assert_eq!(\"666f6f626172\".from_hex().unwrap(),\n+               b\"foobar\");\n+    assert_eq!(\"666F6F626172\".from_hex().unwrap(),\n+               b\"foobar\");\n+}\n+\n+#[test]\n+pub fn test_from_hex_odd_len() {\n+    assert!(\"666\".from_hex().is_err());\n+    assert!(\"66 6\".from_hex().is_err());\n+}\n+\n+#[test]\n+pub fn test_from_hex_invalid_char() {\n+    assert!(\"66y6\".from_hex().is_err());\n+}\n+\n+#[test]\n+pub fn test_from_hex_ignores_whitespace() {\n+    assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap(),\n+               b\"foobar\");\n+}\n+\n+#[test]\n+pub fn test_to_hex_all_bytes() {\n+    for i in 0..256 {\n+        assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as usize));\n+    }\n+}\n+\n+#[test]\n+pub fn test_from_hex_all_bytes() {\n+    for i in 0..256 {\n+        let ii: &[u8] = &[i as u8];\n+        assert_eq!(format!(\"{:02x}\", i as usize).from_hex()\n+                                               .unwrap(),\n+                   ii);\n+        assert_eq!(format!(\"{:02X}\", i as usize).from_hex()\n+                                               .unwrap(),\n+                   ii);\n+    }\n+}\n+\n+#[bench]\n+pub fn bench_to_hex(b: &mut Bencher) {\n+    let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n+             \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n+    b.iter(|| {\n+        s.as_bytes().to_hex();\n+    });\n+    b.bytes = s.len() as u64;\n+}\n+\n+#[bench]\n+pub fn bench_from_hex(b: &mut Bencher) {\n+    let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n+             \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n+    let sb = s.as_bytes().to_hex();\n+    b.iter(|| {\n+        sb.from_hex().unwrap();\n+    });\n+    b.bytes = sb.len() as u64;\n+}"}, {"sha": "8f926e6dd2909458e3f15a8f5cd43232c0957beb", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 136, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/db55aafd72d88c64a8fe3959625edcd207f0d25d/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db55aafd72d88c64a8fe3959625edcd207f0d25d/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=db55aafd72d88c64a8fe3959625edcd207f0d25d", "patch": "@@ -2582,139 +2582,4 @@ impl FromStr for Json {\n }\n \n #[cfg(test)]\n-mod tests {\n-    // Benchmarks and tests that require private items\n-\n-    extern crate test;\n-    use test::Bencher;\n-    use super::{from_str, Parser, StackElement, Stack};\n-    use std::string;\n-\n-    #[test]\n-    fn test_stack() {\n-        let mut stack = Stack::new();\n-\n-        assert!(stack.is_empty());\n-        assert!(stack.is_empty());\n-        assert!(!stack.last_is_index());\n-\n-        stack.push_index(0);\n-        stack.bump_index();\n-\n-        assert!(stack.len() == 1);\n-        assert!(stack.is_equal_to(&[StackElement::Index(1)]));\n-        assert!(stack.starts_with(&[StackElement::Index(1)]));\n-        assert!(stack.ends_with(&[StackElement::Index(1)]));\n-        assert!(stack.last_is_index());\n-        assert!(stack.get(0) == StackElement::Index(1));\n-\n-        stack.push_key(\"foo\".to_string());\n-\n-        assert!(stack.len() == 2);\n-        assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.starts_with(&[StackElement::Index(1)]));\n-        assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.ends_with(&[StackElement::Key(\"foo\")]));\n-        assert!(!stack.last_is_index());\n-        assert!(stack.get(0) == StackElement::Index(1));\n-        assert!(stack.get(1) == StackElement::Key(\"foo\"));\n-\n-        stack.push_key(\"bar\".to_string());\n-\n-        assert!(stack.len() == 3);\n-        assert!(stack.is_equal_to(&[StackElement::Index(1),\n-                                    StackElement::Key(\"foo\"),\n-                                    StackElement::Key(\"bar\")]));\n-        assert!(stack.starts_with(&[StackElement::Index(1)]));\n-        assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.starts_with(&[StackElement::Index(1),\n-                                    StackElement::Key(\"foo\"),\n-                                    StackElement::Key(\"bar\")]));\n-        assert!(stack.ends_with(&[StackElement::Key(\"bar\")]));\n-        assert!(stack.ends_with(&[StackElement::Key(\"foo\"), StackElement::Key(\"bar\")]));\n-        assert!(stack.ends_with(&[StackElement::Index(1),\n-                                  StackElement::Key(\"foo\"),\n-                                  StackElement::Key(\"bar\")]));\n-        assert!(!stack.last_is_index());\n-        assert!(stack.get(0) == StackElement::Index(1));\n-        assert!(stack.get(1) == StackElement::Key(\"foo\"));\n-        assert!(stack.get(2) == StackElement::Key(\"bar\"));\n-\n-        stack.pop();\n-\n-        assert!(stack.len() == 2);\n-        assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.starts_with(&[StackElement::Index(1)]));\n-        assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.ends_with(&[StackElement::Key(\"foo\")]));\n-        assert!(!stack.last_is_index());\n-        assert!(stack.get(0) == StackElement::Index(1));\n-        assert!(stack.get(1) == StackElement::Key(\"foo\"));\n-    }\n-\n-    #[bench]\n-    fn bench_streaming_small(b: &mut Bencher) {\n-        b.iter( || {\n-            let mut parser = Parser::new(\n-                r#\"{\n-                    \"a\": 1.0,\n-                    \"b\": [\n-                        true,\n-                        \"foo\\nbar\",\n-                        { \"c\": {\"d\": null} }\n-                    ]\n-                }\"#.chars()\n-            );\n-            loop {\n-                match parser.next() {\n-                    None => return,\n-                    _ => {}\n-                }\n-            }\n-        });\n-    }\n-    #[bench]\n-    fn bench_small(b: &mut Bencher) {\n-        b.iter( || {\n-            let _ = from_str(r#\"{\n-                \"a\": 1.0,\n-                \"b\": [\n-                    true,\n-                    \"foo\\nbar\",\n-                    { \"c\": {\"d\": null} }\n-                ]\n-            }\"#);\n-        });\n-    }\n-\n-    fn big_json() -> string::String {\n-        let mut src = \"[\\n\".to_string();\n-        for _ in 0..500 {\n-            src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n-                            [1,2,3]},\"#);\n-        }\n-        src.push_str(\"{}]\");\n-        return src;\n-    }\n-\n-    #[bench]\n-    fn bench_streaming_large(b: &mut Bencher) {\n-        let src = big_json();\n-        b.iter( || {\n-            let mut parser = Parser::new(src.chars());\n-            loop {\n-                match parser.next() {\n-                    None => return,\n-                    _ => {}\n-                }\n-            }\n-        });\n-    }\n-    #[bench]\n-    fn bench_large(b: &mut Bencher) {\n-        let src = big_json();\n-        b.iter( || { let _ = from_str(&src); });\n-    }\n-}\n+mod tests;"}, {"sha": "a16b8bdd787043efaec62d2245f04f0944d4ad97", "filename": "src/libserialize/json/tests.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/db55aafd72d88c64a8fe3959625edcd207f0d25d/src%2Flibserialize%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db55aafd72d88c64a8fe3959625edcd207f0d25d/src%2Flibserialize%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson%2Ftests.rs?ref=db55aafd72d88c64a8fe3959625edcd207f0d25d", "patch": "@@ -0,0 +1,134 @@\n+// Benchmarks and tests that require private items\n+\n+extern crate test;\n+use test::Bencher;\n+use super::{from_str, Parser, StackElement, Stack};\n+use std::string;\n+\n+#[test]\n+fn test_stack() {\n+    let mut stack = Stack::new();\n+\n+    assert!(stack.is_empty());\n+    assert!(stack.is_empty());\n+    assert!(!stack.last_is_index());\n+\n+    stack.push_index(0);\n+    stack.bump_index();\n+\n+    assert!(stack.len() == 1);\n+    assert!(stack.is_equal_to(&[StackElement::Index(1)]));\n+    assert!(stack.starts_with(&[StackElement::Index(1)]));\n+    assert!(stack.ends_with(&[StackElement::Index(1)]));\n+    assert!(stack.last_is_index());\n+    assert!(stack.get(0) == StackElement::Index(1));\n+\n+    stack.push_key(\"foo\".to_string());\n+\n+    assert!(stack.len() == 2);\n+    assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+    assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+    assert!(stack.starts_with(&[StackElement::Index(1)]));\n+    assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+    assert!(stack.ends_with(&[StackElement::Key(\"foo\")]));\n+    assert!(!stack.last_is_index());\n+    assert!(stack.get(0) == StackElement::Index(1));\n+    assert!(stack.get(1) == StackElement::Key(\"foo\"));\n+\n+    stack.push_key(\"bar\".to_string());\n+\n+    assert!(stack.len() == 3);\n+    assert!(stack.is_equal_to(&[StackElement::Index(1),\n+                                StackElement::Key(\"foo\"),\n+                                StackElement::Key(\"bar\")]));\n+    assert!(stack.starts_with(&[StackElement::Index(1)]));\n+    assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+    assert!(stack.starts_with(&[StackElement::Index(1),\n+                                StackElement::Key(\"foo\"),\n+                                StackElement::Key(\"bar\")]));\n+    assert!(stack.ends_with(&[StackElement::Key(\"bar\")]));\n+    assert!(stack.ends_with(&[StackElement::Key(\"foo\"), StackElement::Key(\"bar\")]));\n+    assert!(stack.ends_with(&[StackElement::Index(1),\n+                              StackElement::Key(\"foo\"),\n+                              StackElement::Key(\"bar\")]));\n+    assert!(!stack.last_is_index());\n+    assert!(stack.get(0) == StackElement::Index(1));\n+    assert!(stack.get(1) == StackElement::Key(\"foo\"));\n+    assert!(stack.get(2) == StackElement::Key(\"bar\"));\n+\n+    stack.pop();\n+\n+    assert!(stack.len() == 2);\n+    assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+    assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+    assert!(stack.starts_with(&[StackElement::Index(1)]));\n+    assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+    assert!(stack.ends_with(&[StackElement::Key(\"foo\")]));\n+    assert!(!stack.last_is_index());\n+    assert!(stack.get(0) == StackElement::Index(1));\n+    assert!(stack.get(1) == StackElement::Key(\"foo\"));\n+}\n+\n+#[bench]\n+fn bench_streaming_small(b: &mut Bencher) {\n+    b.iter( || {\n+        let mut parser = Parser::new(\n+            r#\"{\n+                \"a\": 1.0,\n+                \"b\": [\n+                    true,\n+                    \"foo\\nbar\",\n+                    { \"c\": {\"d\": null} }\n+                ]\n+            }\"#.chars()\n+        );\n+        loop {\n+            match parser.next() {\n+                None => return,\n+                _ => {}\n+            }\n+        }\n+    });\n+}\n+#[bench]\n+fn bench_small(b: &mut Bencher) {\n+    b.iter( || {\n+        let _ = from_str(r#\"{\n+            \"a\": 1.0,\n+            \"b\": [\n+                true,\n+                \"foo\\nbar\",\n+                { \"c\": {\"d\": null} }\n+            ]\n+        }\"#);\n+    });\n+}\n+\n+fn big_json() -> string::String {\n+    let mut src = \"[\\n\".to_string();\n+    for _ in 0..500 {\n+        src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n+                        [1,2,3]},\"#);\n+    }\n+    src.push_str(\"{}]\");\n+    return src;\n+}\n+\n+#[bench]\n+fn bench_streaming_large(b: &mut Bencher) {\n+    let src = big_json();\n+    b.iter( || {\n+        let mut parser = Parser::new(src.chars());\n+        loop {\n+            match parser.next() {\n+                None => return,\n+                _ => {}\n+            }\n+        }\n+    });\n+}\n+#[bench]\n+fn bench_large(b: &mut Bencher) {\n+    let src = big_json();\n+    b.iter( || { let _ = from_str(&src); });\n+}"}]}