{"sha": "3e98860425447e30e967e83a738f7c54b7fe8273", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlOTg4NjA0MjU0NDdlMzBlOTY3ZTgzYTczOGY3YzU0YjdmZTgyNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-26T01:40:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-26T01:40:26Z"}, "message": "Auto merge of #75811 - ecstatic-morse:better-dlerror, r=nagisa\n\nRefactor dynamic library error checking on *nix\n\nThe old code was checking `dlerror` more often than necessary, since (unlike `dlsym`) checking the return value of [`dlopen`](https://www.man7.org/linux/man-pages/man3/dlopen.3.html) is enough to indicate whether an error occurred. In the first commit, I've refactored the code to minimize the number of system calls needed. It should be strictly better than the old version.\n\nThe second commit is an optional addendum which fixes the issue observed on illumos in #74469, a PR I reviewed that was ultimately closed due to inactivity. I'm not sure how hard we try to work around platform-specific bugs like this, and I believe that, due to the way that `dlerror` is specified in the POSIX standard, libc implementations that want to run on conforming systems cannot call `dlsym` in multi-threaded programs.", "tree": {"sha": "7e6064b59e631310dafa67a4caccaf95d376420c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e6064b59e631310dafa67a4caccaf95d376420c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e98860425447e30e967e83a738f7c54b7fe8273", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e98860425447e30e967e83a738f7c54b7fe8273", "html_url": "https://github.com/rust-lang/rust/commit/3e98860425447e30e967e83a738f7c54b7fe8273", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e98860425447e30e967e83a738f7c54b7fe8273/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf4342114e357f2934d59e12e31e94532ddb2adf", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf4342114e357f2934d59e12e31e94532ddb2adf", "html_url": "https://github.com/rust-lang/rust/commit/bf4342114e357f2934d59e12e31e94532ddb2adf"}, {"sha": "aae6c0fbfe3051e5539f47d0e9d84ddee53f72bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/aae6c0fbfe3051e5539f47d0e9d84ddee53f72bd", "html_url": "https://github.com/rust-lang/rust/commit/aae6c0fbfe3051e5539f47d0e9d84ddee53f72bd"}], "stats": {"total": 108, "additions": 74, "deletions": 34}, "files": [{"sha": "bdb53e3f75a40866d347e3f3c279935eb90f7ae5", "filename": "src/librustc_metadata/dynamic_lib.rs", "status": "modified", "additions": 73, "deletions": 34, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/3e98860425447e30e967e83a738f7c54b7fe8273/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e98860425447e30e967e83a738f7c54b7fe8273/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib.rs?ref=3e98860425447e30e967e83a738f7c54b7fe8273", "patch": "@@ -51,51 +51,90 @@ mod tests;\n \n #[cfg(unix)]\n mod dl {\n-    use std::ffi::{CStr, CString, OsStr};\n+    use std::ffi::{CString, OsStr};\n     use std::os::unix::prelude::*;\n-    use std::ptr;\n-    use std::str;\n \n-    pub(super) fn open(filename: &OsStr) -> Result<*mut u8, String> {\n-        check_for_errors_in(|| unsafe {\n-            let s = CString::new(filename.as_bytes()).unwrap();\n-            libc::dlopen(s.as_ptr(), libc::RTLD_LAZY) as *mut u8\n-        })\n-    }\n+    // As of the 2017 revision of the POSIX standard (IEEE 1003.1-2017), it is\n+    // implementation-defined whether `dlerror` is thread-safe (in which case it returns the most\n+    // recent error in the calling thread) or not thread-safe (in which case it returns the most\n+    // recent error in *any* thread).\n+    //\n+    // There's no easy way to tell what strategy is used by a given POSIX implementation, so we\n+    // lock around all calls that can modify `dlerror` in this module lest we accidentally read an\n+    // error from a different thread. This is bulletproof when we are the *only* code using the\n+    // dynamic library APIs at a given point in time. However, it's still possible for us to race\n+    // with other code (see #74469) on platforms where `dlerror` is not thread-safe.\n+    mod error {\n+        use std::ffi::CStr;\n+        use std::lazy::SyncLazy;\n+        use std::sync::{Mutex, MutexGuard};\n+\n+        pub fn lock() -> MutexGuard<'static, Guard> {\n+            static LOCK: SyncLazy<Mutex<Guard>> = SyncLazy::new(|| Mutex::new(Guard { _priv: () }));\n+            LOCK.lock().unwrap()\n+        }\n \n-    fn check_for_errors_in<T, F>(f: F) -> Result<T, String>\n-    where\n-        F: FnOnce() -> T,\n-    {\n-        use std::sync::{Mutex, Once};\n-        static INIT: Once = Once::new();\n-        static mut LOCK: *mut Mutex<()> = ptr::null_mut();\n-        unsafe {\n-            INIT.call_once(|| {\n-                LOCK = Box::into_raw(Box::new(Mutex::new(())));\n-            });\n-            // dlerror isn't thread safe, so we need to lock around this entire\n-            // sequence\n-            let _guard = (*LOCK).lock();\n-            let _old_error = libc::dlerror();\n-\n-            let result = f();\n-\n-            let last_error = libc::dlerror() as *const _;\n-            if ptr::null() == last_error {\n-                Ok(result)\n-            } else {\n-                let s = CStr::from_ptr(last_error).to_bytes();\n-                Err(str::from_utf8(s).unwrap().to_owned())\n+        pub struct Guard {\n+            _priv: (),\n+        }\n+\n+        impl Guard {\n+            pub fn get(&mut self) -> Result<(), String> {\n+                let msg = unsafe { libc::dlerror() };\n+                if msg.is_null() {\n+                    Ok(())\n+                } else {\n+                    let msg = unsafe { CStr::from_ptr(msg as *const _) };\n+                    Err(msg.to_string_lossy().into_owned())\n+                }\n+            }\n+\n+            pub fn clear(&mut self) {\n+                let _ = unsafe { libc::dlerror() };\n             }\n         }\n     }\n \n+    pub(super) fn open(filename: &OsStr) -> Result<*mut u8, String> {\n+        let s = CString::new(filename.as_bytes()).unwrap();\n+\n+        let mut dlerror = error::lock();\n+        let ret = unsafe { libc::dlopen(s.as_ptr(), libc::RTLD_LAZY | libc::RTLD_LOCAL) };\n+\n+        if !ret.is_null() {\n+            return Ok(ret.cast());\n+        }\n+\n+        // A NULL return from `dlopen` indicates that an error has definitely occurred, so if\n+        // nothing is in `dlerror`, we are racing with another thread that has stolen our error\n+        // message. See the explanation on the `dl::error` module for more information.\n+        dlerror.get().and_then(|()| Err(\"Unknown error\".to_string()))\n+    }\n+\n     pub(super) unsafe fn symbol(\n         handle: *mut u8,\n         symbol: *const libc::c_char,\n     ) -> Result<*mut u8, String> {\n-        check_for_errors_in(|| libc::dlsym(handle as *mut libc::c_void, symbol) as *mut u8)\n+        let mut dlerror = error::lock();\n+\n+        // Unlike `dlopen`, it's possible for `dlsym` to return NULL without overwriting `dlerror`.\n+        // Because of this, we clear `dlerror` before calling `dlsym` to avoid picking up a stale\n+        // error message by accident.\n+        dlerror.clear();\n+\n+        let ret = libc::dlsym(handle as *mut libc::c_void, symbol);\n+\n+        if !ret.is_null() {\n+            return Ok(ret.cast());\n+        }\n+\n+        // If `dlsym` returns NULL but there is nothing in `dlerror` it means one of two things:\n+        // - We tried to load a symbol mapped to address 0. This is not technically an error but is\n+        //   unlikely to occur in practice and equally unlikely to be handled correctly by calling\n+        //   code. Therefore we treat it as an error anyway.\n+        // - An error has occurred, but we are racing with another thread that has stolen our error\n+        //   message. See the explanation on the `dl::error` module for more information.\n+        dlerror.get().and_then(|()| Err(\"Tried to load symbol mapped to address 0\".to_string()))\n     }\n \n     pub(super) unsafe fn close(handle: *mut u8) {"}, {"sha": "85490f5f6e91ab1e1b956e4753440c7cb343a740", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e98860425447e30e967e83a738f7c54b7fe8273/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e98860425447e30e967e83a738f7c54b7fe8273/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=3e98860425447e30e967e83a738f7c54b7fe8273", "patch": "@@ -5,6 +5,7 @@\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n+#![feature(once_cell)]\n #![feature(or_patterns)]\n #![feature(proc_macro_internals)]\n #![feature(min_specialization)]"}]}