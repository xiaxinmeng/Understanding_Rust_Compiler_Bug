{"sha": "375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NWNiZDIwY2ZjYzlkYmYxNTY4MmJjZmMwMDgxY2U1Y2U5NTU2N2I=", "commit": {"author": {"name": "Austin Bonander", "email": "austin.bonander@gmail.com", "date": "2017-01-09T09:31:14Z"}, "committer": {"name": "Austin Bonander", "email": "austin.bonander@gmail.com", "date": "2017-01-17T06:41:22Z"}, "message": "Implement `#[proc_macro_attribute]`\n\n* Add support for `#[proc_macro]`\n\n* Reactivate `proc_macro` feature and gate `#[proc_macro_attribute]` under it\n\n* Have `#![feature(proc_macro)]` imply `#![feature(use_extern_macros)]`,\nerror on legacy import of proc macros via `#[macro_use]`", "tree": {"sha": "6eee726bbefda54496b97963b696404cc50287aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6eee726bbefda54496b97963b696404cc50287aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "html_url": "https://github.com/rust-lang/rust/commit/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/comments", "author": {"login": "abonander", "id": 3198595, "node_id": "MDQ6VXNlcjMxOTg1OTU=", "avatar_url": "https://avatars.githubusercontent.com/u/3198595?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abonander", "html_url": "https://github.com/abonander", "followers_url": "https://api.github.com/users/abonander/followers", "following_url": "https://api.github.com/users/abonander/following{/other_user}", "gists_url": "https://api.github.com/users/abonander/gists{/gist_id}", "starred_url": "https://api.github.com/users/abonander/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abonander/subscriptions", "organizations_url": "https://api.github.com/users/abonander/orgs", "repos_url": "https://api.github.com/users/abonander/repos", "events_url": "https://api.github.com/users/abonander/events{/privacy}", "received_events_url": "https://api.github.com/users/abonander/received_events", "type": "User", "site_admin": false}, "committer": {"login": "abonander", "id": 3198595, "node_id": "MDQ6VXNlcjMxOTg1OTU=", "avatar_url": "https://avatars.githubusercontent.com/u/3198595?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abonander", "html_url": "https://github.com/abonander", "followers_url": "https://api.github.com/users/abonander/followers", "following_url": "https://api.github.com/users/abonander/following{/other_user}", "gists_url": "https://api.github.com/users/abonander/gists{/gist_id}", "starred_url": "https://api.github.com/users/abonander/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abonander/subscriptions", "organizations_url": "https://api.github.com/users/abonander/orgs", "repos_url": "https://api.github.com/users/abonander/repos", "events_url": "https://api.github.com/users/abonander/events{/privacy}", "received_events_url": "https://api.github.com/users/abonander/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6c0c4837c303e327a8b37649dd72f115b48f309", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6c0c4837c303e327a8b37649dd72f115b48f309", "html_url": "https://github.com/rust-lang/rust/commit/f6c0c4837c303e327a8b37649dd72f115b48f309"}], "stats": {"total": 605, "additions": 526, "deletions": 79}, "files": [{"sha": "f34d1203a3d20edc6a92e0a857745f53a8c9a734", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -677,6 +677,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n             should_test: sess.opts.test,\n             ..syntax::ext::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n+\n         let mut ecx = ExtCtxt::new(&sess.parse_sess, cfg, &mut resolver);\n         let err_count = ecx.parse_sess.span_diagnostic.err_count();\n "}, {"sha": "161331b1728bcd0deb0973b3a52ff1d45e6faec1", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -578,6 +578,7 @@ impl<'a> CrateLoader<'a> {\n         use proc_macro::__internal::Registry;\n         use rustc_back::dynamic_lib::DynamicLibrary;\n         use syntax_ext::deriving::custom::CustomDerive;\n+        use syntax_ext::proc_macro_impl::AttrProcMacro;\n \n         let path = match dylib {\n             Some(dylib) => dylib,\n@@ -613,6 +614,15 @@ impl<'a> CrateLoader<'a> {\n                 );\n                 self.0.push((Symbol::intern(trait_name), Rc::new(derive)));\n             }\n+\n+            fn register_attr_proc_macro(&mut self,\n+                                        name: &str,\n+                                        expand: fn(TokenStream, TokenStream) -> TokenStream) {\n+                let expand = SyntaxExtension::AttrProcMacro(\n+                    Box::new(AttrProcMacro { inner: expand })\n+                );\n+                self.0.push((Symbol::intern(name), Rc::new(expand)));\n+            }\n         }\n \n         let mut my_registrar = MyRegistrar(Vec::new());"}, {"sha": "2c5e338563816712921759ce8af44a56fc5b71dc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -61,7 +61,7 @@ use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n-use syntax::feature_gate::{emit_feature_err, GateIssue};\n+use syntax::feature_gate::{feature_err, emit_feature_err, GateIssue};\n \n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use errors::DiagnosticBuilder;\n@@ -1123,6 +1123,12 @@ pub struct Resolver<'a> {\n \n     // Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Name, Span>,\n+\n+    // If `#![feature(proc_macro)]` is set\n+    proc_macro_enabled: bool,\n+\n+    // A set of procedural macros imported by `#[macro_use]` that have already been warned about\n+    warned_proc_macros: FxHashSet<Name>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1227,6 +1233,8 @@ impl<'a> Resolver<'a> {\n         invocations.insert(Mark::root(),\n                            arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n \n+        let features = session.features.borrow();\n+\n         Resolver {\n             session: session,\n \n@@ -1284,7 +1292,9 @@ impl<'a> Resolver<'a> {\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             }),\n-            use_extern_macros: session.features.borrow().use_extern_macros,\n+\n+            // `#![feature(proc_macro)]` implies `#[feature(extern_macros)]`\n+            use_extern_macros: features.use_extern_macros || features.proc_macro,\n \n             exported_macros: Vec::new(),\n             crate_loader: crate_loader,\n@@ -1296,6 +1306,8 @@ impl<'a> Resolver<'a> {\n             invocations: invocations,\n             name_already_seen: FxHashMap(),\n             whitelisted_legacy_custom_derives: Vec::new(),\n+            proc_macro_enabled: features.proc_macro,\n+            warned_proc_macros: FxHashSet(),\n         }\n     }\n \n@@ -1525,6 +1537,8 @@ impl<'a> Resolver<'a> {\n \n         debug!(\"(resolving item) resolving {}\", name);\n \n+        self.check_proc_macro_attrs(&item.attrs);\n+\n         match item.node {\n             ItemKind::Enum(_, ref generics) |\n             ItemKind::Ty(_, ref generics) |\n@@ -1554,6 +1568,8 @@ impl<'a> Resolver<'a> {\n                         walk_list!(this, visit_ty_param_bound, bounds);\n \n                         for trait_item in trait_items {\n+                            this.check_proc_macro_attrs(&trait_item.attrs);\n+\n                             match trait_item.node {\n                                 TraitItemKind::Const(_, ref default) => {\n                                     // Only impose the restrictions of\n@@ -1738,6 +1754,7 @@ impl<'a> Resolver<'a> {\n                 this.with_self_rib(Def::SelfTy(trait_id, Some(item_def_id)), |this| {\n                     this.with_current_self_type(self_type, |this| {\n                         for impl_item in impl_items {\n+                            this.check_proc_macro_attrs(&impl_item.attrs);\n                             this.resolve_visibility(&impl_item.vis);\n                             match impl_item.node {\n                                 ImplItemKind::Const(..) => {\n@@ -3184,6 +3201,31 @@ impl<'a> Resolver<'a> {\n         let msg = \"`self` no longer imports values\".to_string();\n         self.session.add_lint(lint::builtin::LEGACY_IMPORTS, id, span, msg);\n     }\n+\n+    fn check_proc_macro_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        if self.proc_macro_enabled { return; }\n+\n+        for attr in attrs {\n+            let maybe_binding = self.builtin_macros.get(&attr.name()).cloned().or_else(|| {\n+                let ident = Ident::with_empty_ctxt(attr.name());\n+                self.resolve_lexical_macro_path_segment(ident, MacroNS, None).ok()\n+            });\n+\n+            if let Some(binding) = maybe_binding {\n+                if let SyntaxExtension::AttrProcMacro(..) = *binding.get_macro(self) {\n+                    attr::mark_known(attr);\n+\n+                    let msg = \"attribute procedural macros are experimental\";\n+                    let feature = \"proc_macro\";\n+\n+                    feature_err(&self.session.parse_sess, feature,\n+                                attr.span, GateIssue::Language, msg)\n+                        .span_note(binding.span, \"procedural macro imported here\")\n+                        .emit();\n+                }\n+            }\n+        }\n+    }\n }\n \n fn is_struct_like(def: Def) -> bool {"}, {"sha": "9b7d6f33a7f3b45e90eb0ea16e33ecd0bb0d6f32", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -27,7 +27,7 @@ use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n use syntax::ext::expand::{Expansion, mark_tts};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n-use syntax::feature_gate::{emit_feature_err, GateIssue};\n+use syntax::feature_gate::{emit_feature_err, GateIssue, is_builtin_attr};\n use syntax::fold::{self, Folder};\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n@@ -183,6 +183,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 },\n                 None => {}\n             }\n+\n+            if self.proc_macro_enabled && !is_builtin_attr(&attrs[i]) {\n+                return Some(attrs.remove(i));\n+            }\n         }\n         None\n     }\n@@ -373,6 +377,10 @@ impl<'a> Resolver<'a> {\n             let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, Some(span));\n             let (legacy_resolution, resolution) = match (legacy_resolution, resolution) {\n                 (Some(legacy_resolution), Ok(resolution)) => (legacy_resolution, resolution),\n+                (Some(MacroBinding::Modern(binding)), Err(_)) => {\n+                    self.err_if_macro_use_proc_macro(ident.name, span, binding);\n+                    continue\n+                },\n                 _ => continue,\n             };\n             let (legacy_span, participle) = match legacy_resolution {\n@@ -469,4 +477,37 @@ impl<'a> Resolver<'a> {\n             self.exported_macros.push(def);\n         }\n     }\n+\n+    /// Error if `ext` is a Macros 1.1 procedural macro being imported by `#[macro_use]`\n+    fn err_if_macro_use_proc_macro(&mut self, name: Name, use_span: Span,\n+                                   binding: &NameBinding<'a>) {\n+        use self::SyntaxExtension::*;\n+\n+        let krate = binding.def().def_id().krate;\n+\n+        // Plugin-based syntax extensions are exempt from this check\n+        if krate == BUILTIN_MACROS_CRATE { return; }\n+\n+        let ext = binding.get_macro(self);\n+\n+        match *ext {\n+            // If `ext` is a procedural macro, check if we've already warned about it\n+            AttrProcMacro(_) | ProcMacro(_) => if !self.warned_proc_macros.insert(name) { return; },\n+            _ => return,\n+        }\n+\n+        let warn_msg = match *ext {\n+            AttrProcMacro(_) => \"attribute procedural macros cannot be \\\n+                                 imported with `#[macro_use]`\",\n+            ProcMacro(_) => \"procedural macros cannot be imported with `#[macro_use]`\",\n+            _ => return,\n+        };\n+\n+        let crate_name = self.session.cstore.crate_name(krate);\n+\n+        self.session.struct_span_err(use_span, warn_msg)\n+            .help(&format!(\"instead, import the procedural macro like any other item: \\\n+                             `use {}::{};`\", crate_name, name))\n+            .emit();\n+    }\n }"}, {"sha": "1f7874274f78983922b4ac04b346d4d1700d8cd7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -364,7 +364,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 kind.expect_from_annotatables(items)\n             }\n             SyntaxExtension::AttrProcMacro(ref mac) => {\n-                let attr_toks = TokenStream::from_tts(tts_for_attr(&attr, &self.cx.parse_sess));\n+                let attr_toks = TokenStream::from_tts(tts_for_attr_args(&attr,\n+                                                                        &self.cx.parse_sess));\n+\n                 let item_toks = TokenStream::from_tts(tts_for_item(&item, &self.cx.parse_sess));\n \n                 let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n@@ -640,8 +642,30 @@ fn tts_for_item(item: &Annotatable, parse_sess: &ParseSess) -> Vec<TokenTree> {\n     string_to_tts(text, parse_sess)\n }\n \n-fn tts_for_attr(attr: &ast::Attribute, parse_sess: &ParseSess) -> Vec<TokenTree> {\n-    string_to_tts(pprust::attr_to_string(attr), parse_sess)\n+fn tts_for_attr_args(attr: &ast::Attribute, parse_sess: &ParseSess) -> Vec<TokenTree> {\n+    use ast::MetaItemKind::*;\n+    use print::pp::Breaks;\n+    use print::pprust::PrintState;\n+\n+    let token_string = match attr.value.node {\n+        // For `#[foo]`, an empty token\n+        Word => return vec![],\n+        // For `#[foo(bar, baz)]`, returns `(bar, baz)`\n+        List(ref items) => pprust::to_string(|s| {\n+            s.popen()?;\n+            s.commasep(Breaks::Consistent,\n+                       &items[..],\n+                       |s, i| s.print_meta_list_item(&i))?;\n+            s.pclose()\n+        }),\n+        // For `#[foo = \"bar\"]`, returns `= \"bar\"`\n+        NameValue(ref lit) => pprust::to_string(|s| {\n+            s.word_space(\"=\")?;\n+            s.print_literal(lit)\n+        }),\n+    };\n+\n+    string_to_tts(token_string, parse_sess)\n }\n \n fn string_to_tts(text: String, parse_sess: &ParseSess) -> Vec<TokenTree> {"}, {"sha": "2478ed169cd5e8d43cb2a5e413d0c5eac0cc3040", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -30,7 +30,7 @@ use ast::{self, NodeId, PatKind};\n use attr;\n use codemap::{CodeMap, Spanned};\n use syntax_pos::Span;\n-use errors::{DiagnosticBuilder, Handler};\n+use errors::{DiagnosticBuilder, Handler, FatalError};\n use visit::{self, FnKind, Visitor};\n use parse::ParseSess;\n use symbol::Symbol;\n@@ -325,6 +325,9 @@ declare_features! (\n     // The `unadjusted` ABI. Perma unstable.\n     (active, abi_unadjusted, \"1.16.0\", None),\n \n+    // Macros 1.1\n+    (active, proc_macro, \"1.16.0\", Some(35900)),\n+\n     // Allows attributes on struct literal fields.\n     (active, struct_field_attributes, \"1.16.0\", Some(38814)),\n );\n@@ -377,8 +380,6 @@ declare_features! (\n     // Allows `..` in tuple (struct) patterns\n     (accepted, dotdot_in_tuple_patterns, \"1.14.0\", Some(33627)),\n     (accepted, item_like_imports, \"1.14.0\", Some(35120)),\n-    // Macros 1.1\n-    (accepted, proc_macro, \"1.15.0\", Some(35900)),\n );\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -446,6 +447,10 @@ pub fn deprecated_attributes() -> Vec<&'static (&'static str, AttributeType, Att\n     BUILTIN_ATTRIBUTES.iter().filter(|a| a.2.is_deprecated()).collect()\n }\n \n+pub fn is_builtin_attr(attr: &ast::Attribute) -> bool {\n+    BUILTIN_ATTRIBUTES.iter().any(|&(builtin_name, _, _)| attr.check_name(builtin_name))\n+}\n+\n // Attributes that have a special meaning to rustc or rustdoc\n pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGate)] = &[\n     // Normal attributes\n@@ -739,6 +744,16 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                               is currently unstable\",\n                                              cfg_fn!(windows_subsystem))),\n \n+    (\"proc_macro_attribute\", Normal, Gated(Stability::Unstable,\n+                                           \"proc_macro\",\n+                                           \"attribute proc macros are currently unstable\",\n+                                           cfg_fn!(proc_macro))),\n+\n+    (\"rustc_derive_registrar\", Normal, Gated(Stability::Unstable,\n+                                             \"rustc_derive_registrar\",\n+                                             \"used internally by rustc\",\n+                                             cfg_fn!(rustc_attrs))),\n+\n     // Crate level attributes\n     (\"crate_name\", CrateLevel, Ungated),\n     (\"crate_type\", CrateLevel, Ungated),\n@@ -1380,6 +1395,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> Features {\n     let mut features = Features::new();\n \n+    let mut feature_checker = MutexFeatureChecker::default();\n+\n     for attr in krate_attrs {\n         if !attr.check_name(\"feature\") {\n             continue\n@@ -1403,6 +1420,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n                     if let Some(&(_, _, _, setter)) = ACTIVE_FEATURES.iter()\n                         .find(|& &(n, _, _, _)| name == n) {\n                         *(setter(&mut features)) = true;\n+                        feature_checker.collect(&features, mi.span);\n                     }\n                     else if let Some(&(_, _, _)) = REMOVED_FEATURES.iter()\n                         .find(|& &(n, _, _)| name == n) {\n@@ -1419,9 +1437,45 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n         }\n     }\n \n+    feature_checker.check(span_handler);\n+\n     features\n }\n \n+// A collector for mutually-exclusive features and their flag spans\n+#[derive(Default)]\n+struct MutexFeatureChecker {\n+    proc_macro: Option<Span>,\n+    custom_attribute: Option<Span>,\n+}\n+\n+impl MutexFeatureChecker {\n+    // If this method turns out to be a hotspot due to branching,\n+    // the branching can be eliminated by modifying `setter!()` to set these spans\n+    // only for the features that need to be checked for mutual exclusion.\n+    fn collect(&mut self, features: &Features, span: Span) {\n+        if features.proc_macro {\n+            // If self.proc_macro is None, set to Some(span)\n+            self.proc_macro = self.proc_macro.or(Some(span));\n+        }\n+\n+        if features.custom_attribute {\n+            self.custom_attribute = self.custom_attribute.or(Some(span));\n+        }\n+    }\n+\n+    fn check(self, handler: &Handler) {\n+        if let (Some(pm_span), Some(ca_span)) = (self.proc_macro, self.custom_attribute) {\n+            handler.struct_span_err(pm_span, \"Cannot use `#![feature(proc_macro)]` and \\\n+                                              `#![feature(custom_attribute)] at the same time\")\n+                .span_note(ca_span, \"`#![feature(custom_attribute)]` declared here\")\n+                .emit();\n+\n+            panic!(FatalError);\n+        }\n+    }\n+}\n+\n pub fn check_crate(krate: &ast::Crate,\n                    sess: &ParseSess,\n                    features: &Features,"}, {"sha": "ebec23d0901a0409ea705cf3db7cbe7fa1275204", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -47,6 +47,8 @@ pub mod proc_macro_registrar;\n // for custom_derive\n pub mod deriving;\n \n+pub mod proc_macro_impl;\n+\n use std::rc::Rc;\n use syntax::ast;\n use syntax::ext::base::{MacroExpanderFn, NormalTT, MultiModifier, NamedSyntaxExtension};"}, {"sha": "b454628acb1c09bf95b0dabcd04ed18411daf1f8", "filename": "src/libsyntax_ext/proc_macro_impl.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_impl.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::panic;\n+\n+use errors::FatalError;\n+\n+use syntax::codemap::Span;\n+use syntax::ext::base::*;\n+use syntax::tokenstream::TokenStream;\n+use syntax::ext::base;\n+\n+use proc_macro::TokenStream as TsShim;\n+use proc_macro::__internal;\n+\n+pub struct AttrProcMacro {\n+    pub inner: fn(TsShim, TsShim) -> TsShim,\n+}\n+\n+impl base::AttrProcMacro for AttrProcMacro {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt,\n+                   span: Span,\n+                   annotation: TokenStream,\n+                   annotated: TokenStream)\n+                   -> TokenStream {\n+        let annotation = __internal::token_stream_wrap(annotation);\n+        let annotated = __internal::token_stream_wrap(annotated);\n+\n+        let res = __internal::set_parse_sess(&ecx.parse_sess, || {\n+            panic::catch_unwind(panic::AssertUnwindSafe(|| (self.inner)(annotation, annotated)))\n+        });\n+\n+        match res {\n+            Ok(stream) => __internal::token_stream_inner(stream),\n+            Err(e) => {\n+                let msg = \"custom attribute panicked\";\n+                let mut err = ecx.struct_span_fatal(span, msg);\n+                if let Some(s) = e.downcast_ref::<String>() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+                if let Some(s) = e.downcast_ref::<&'static str>() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+\n+                err.emit();\n+                panic!(FatalError);\n+            }\n+        }\n+    }\n+}"}, {"sha": "c8af16e9242f05c8277578b04576d11c13d08b04", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 135, "deletions": 69, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -11,18 +11,20 @@\n use std::mem;\n \n use errors;\n+\n use syntax::ast::{self, Ident, NodeId};\n use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n-use syntax::parse::ParseSess;\n use syntax::fold::Folder;\n+use syntax::parse::ParseSess;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n-use syntax_pos::{Span, DUMMY_SP};\n use syntax::visit::{self, Visitor};\n \n+use syntax_pos::{Span, DUMMY_SP};\n+\n use deriving;\n \n struct CustomDerive {\n@@ -32,8 +34,14 @@ struct CustomDerive {\n     attrs: Vec<ast::Name>,\n }\n \n-struct CollectCustomDerives<'a> {\n+struct AttrProcMacro {\n+    function_name: Ident,\n+    span: Span,\n+}\n+\n+struct CollectProcMacros<'a> {\n     derives: Vec<CustomDerive>,\n+    attr_macros: Vec<AttrProcMacro>,\n     in_root: bool,\n     handler: &'a errors::Handler,\n     is_proc_macro_crate: bool,\n@@ -50,16 +58,17 @@ pub fn modify(sess: &ParseSess,\n     let ecfg = ExpansionConfig::default(\"proc_macro\".to_string());\n     let mut cx = ExtCtxt::new(sess, ecfg, resolver);\n \n-    let derives = {\n-        let mut collect = CollectCustomDerives {\n+    let (derives, attr_macros) = {\n+        let mut collect = CollectProcMacros {\n             derives: Vec::new(),\n+            attr_macros: Vec::new(),\n             in_root: true,\n             handler: handler,\n             is_proc_macro_crate: is_proc_macro_crate,\n             is_test_crate: is_test_crate,\n         };\n         visit::walk_crate(&mut collect, &krate);\n-        collect.derives\n+        (collect.derives, collect.attr_macros)\n     };\n \n     if !is_proc_macro_crate {\n@@ -74,7 +83,7 @@ pub fn modify(sess: &ParseSess,\n         return krate;\n     }\n \n-    krate.module.items.push(mk_registrar(&mut cx, &derives));\n+    krate.module.items.push(mk_registrar(&mut cx, &derives, &attr_macros));\n \n     if krate.exported_macros.len() > 0 {\n         handler.err(\"cannot export macro_rules! macros from a `proc-macro` \\\n@@ -84,69 +93,19 @@ pub fn modify(sess: &ParseSess,\n     return krate\n }\n \n-impl<'a> CollectCustomDerives<'a> {\n+impl<'a> CollectProcMacros<'a> {\n     fn check_not_pub_in_root(&self, vis: &ast::Visibility, sp: Span) {\n         if self.is_proc_macro_crate &&\n            self.in_root &&\n            *vis == ast::Visibility::Public {\n             self.handler.span_err(sp,\n                                   \"`proc-macro` crate types cannot \\\n                                    export any items other than functions \\\n-                                   tagged with `#[proc_macro_derive]` \\\n-                                   currently\");\n+                                   tagged with `#[proc_macro_derive]` currently\");\n         }\n     }\n-}\n-\n-impl<'a> Visitor<'a> for CollectCustomDerives<'a> {\n-    fn visit_item(&mut self, item: &'a ast::Item) {\n-        let mut attrs = item.attrs.iter().filter(|a| a.check_name(\"proc_macro_derive\"));\n-\n-        // First up, make sure we're checking a bare function. If we're not then\n-        // we're just not interested in this item.\n-        //\n-        // If we find one, try to locate a `#[proc_macro_derive]` attribute on\n-        // it.\n-        match item.node {\n-            ast::ItemKind::Fn(..) => {}\n-            _ => {\n-                // Check for invalid use of proc_macro_derive\n-                if let Some(attr) = attrs.next() {\n-                    self.handler.span_err(attr.span(),\n-                                          \"the `#[proc_macro_derive]` \\\n-                                          attribute may only be used \\\n-                                          on bare functions\");\n-                    return;\n-                }\n-                self.check_not_pub_in_root(&item.vis, item.span);\n-                return visit::walk_item(self, item)\n-            }\n-        }\n-\n-        let attr = match attrs.next() {\n-            Some(attr) => attr,\n-            None => {\n-                self.check_not_pub_in_root(&item.vis, item.span);\n-                return visit::walk_item(self, item)\n-            }\n-        };\n-\n-        if let Some(a) = attrs.next() {\n-            self.handler.span_err(a.span(), \"multiple `#[proc_macro_derive]` \\\n-                                             attributes found\");\n-        }\n-\n-        if self.is_test_crate {\n-            return;\n-        }\n-\n-        if !self.is_proc_macro_crate {\n-            self.handler.span_err(attr.span(),\n-                                  \"the `#[proc_macro_derive]` attribute is \\\n-                                   only usable with crates of the `proc-macro` \\\n-                                   crate type\");\n-        }\n \n+    fn collect_custom_derive(&mut self, item: &'a ast::Item, attr: &'a ast::Attribute) {\n         // Once we've located the `#[proc_macro_derive]` attribute, verify\n         // that it's of the form `#[proc_macro_derive(Foo)]` or\n         // `#[proc_macro_derive(Foo, attributes(A, ..))]`\n@@ -232,6 +191,101 @@ impl<'a> Visitor<'a> for CollectCustomDerives<'a> {\n             };\n             self.handler.span_err(item.span, msg);\n         }\n+    }\n+\n+    fn collect_attr_proc_macro(&mut self, item: &'a ast::Item, attr: &'a ast::Attribute) {\n+        if let Some(_) = attr.meta_item_list() {\n+            self.handler.span_err(attr.span, \"`#[proc_macro_attribute]` attribute\n+                cannot contain any meta items\");\n+            return;\n+        }\n+\n+        if self.in_root && item.vis == ast::Visibility::Public {\n+            self.attr_macros.push(AttrProcMacro {\n+                span: item.span,\n+                function_name: item.ident,\n+            });\n+        } else {\n+            let msg = if !self.in_root {\n+                \"functions tagged with `#[proc_macro_attribute]` must \\\n+                 currently reside in the root of the crate\"\n+            } else {\n+                \"functions tagged with `#[proc_macro_attribute]` must be `pub`\"\n+            };\n+            self.handler.span_err(item.span, msg);\n+        }\n+    }\n+}\n+\n+impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n+    fn visit_item(&mut self, item: &'a ast::Item) {\n+        // First up, make sure we're checking a bare function. If we're not then\n+        // we're just not interested in this item.\n+        //\n+        // If we find one, try to locate a `#[proc_macro_derive]` attribute on\n+        // it.\n+        let is_fn = match item.node {\n+            ast::ItemKind::Fn(..) => true,\n+            _ => false,\n+        };\n+\n+        let mut found_attr: Option<&'a ast::Attribute> = None;\n+\n+        for attr in &item.attrs {\n+            if attr.check_name(\"proc_macro_derive\") || attr.check_name(\"proc_macro_attribute\") {\n+                if let Some(prev_attr) = found_attr {\n+                    let msg = if attr.name() == prev_attr.name() {\n+                        format!(\"Only one `#[{}]` attribute is allowed on any given function\",\n+                                attr.name())\n+                    } else {\n+                        format!(\"`#[{}]` and `#[{}]` attributes cannot both be applied \\\n+                                to the same function\", attr.name(), prev_attr.name())\n+                    };\n+\n+                    self.handler.struct_span_err(attr.span(), &msg)\n+                        .span_note(prev_attr.span(), \"Previous attribute here\")\n+                        .emit();\n+\n+                    return;\n+                }\n+\n+                found_attr = Some(attr);\n+            }\n+        }\n+\n+        let attr = match found_attr {\n+            None => {\n+                self.check_not_pub_in_root(&item.vis, item.span);\n+                return visit::walk_item(self, item);\n+            },\n+            Some(attr) => attr,\n+        };\n+\n+        if !is_fn {\n+            let msg = format!(\"the `#[{}]` attribute may only be used on bare functions\",\n+                              attr.name());\n+\n+            self.handler.span_err(attr.span(), &msg);\n+            return;\n+        }\n+\n+        if self.is_test_crate {\n+            return;\n+        }\n+\n+        if !self.is_proc_macro_crate {\n+            let msg = format!(\"the `#[{}]` attribute is only usable with crates of the \\\n+                              `proc-macro` crate type\", attr.name());\n+\n+            self.handler.span_err(attr.span(), &msg);\n+            return;\n+        }\n+\n+        if attr.check_name(\"proc_macro_derive\") {\n+            self.collect_custom_derive(item, attr);\n+        } else if attr.check_name(\"proc_macro_attribute\") {\n+            self.collect_attr_proc_macro(item, attr);\n+        };\n \n         visit::walk_item(self, item);\n     }\n@@ -265,7 +319,8 @@ impl<'a> Visitor<'a> for CollectCustomDerives<'a> {\n //          }\n //      }\n fn mk_registrar(cx: &mut ExtCtxt,\n-                custom_derives: &[CustomDerive]) -> P<ast::Item> {\n+                custom_derives: &[CustomDerive],\n+                custom_attrs: &[AttrProcMacro]) -> P<ast::Item> {\n     let eid = cx.codemap().record_expansion(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n@@ -286,25 +341,36 @@ fn mk_registrar(cx: &mut ExtCtxt,\n     let registry = Ident::from_str(\"Registry\");\n     let registrar = Ident::from_str(\"registrar\");\n     let register_custom_derive = Ident::from_str(\"register_custom_derive\");\n-    let stmts = custom_derives.iter().map(|cd| {\n+    let register_attr_proc_macro = Ident::from_str(\"register_attr_proc_macro\");\n+\n+    let mut stmts = custom_derives.iter().map(|cd| {\n         let path = cx.path_global(cd.span, vec![cd.function_name]);\n         let trait_name = cx.expr_str(cd.span, cd.trait_name);\n         let attrs = cx.expr_vec_slice(\n             span,\n             cd.attrs.iter().map(|&s| cx.expr_str(cd.span, s)).collect::<Vec<_>>()\n         );\n-        (path, trait_name, attrs)\n-    }).map(|(path, trait_name, attrs)| {\n         let registrar = cx.expr_ident(span, registrar);\n         let ufcs_path = cx.path(span, vec![proc_macro, __internal, registry,\n                                            register_custom_derive]);\n-        cx.expr_call(span,\n-                     cx.expr_path(ufcs_path),\n-                     vec![registrar, trait_name, cx.expr_path(path), attrs])\n-    }).map(|expr| {\n-        cx.stmt_expr(expr)\n+\n+        cx.stmt_expr(cx.expr_call(span, cx.expr_path(ufcs_path),\n+                                  vec![registrar, trait_name, cx.expr_path(path), attrs]))\n+\n     }).collect::<Vec<_>>();\n \n+    stmts.extend(custom_attrs.iter().map(|ca| {\n+        let name = cx.expr_str(ca.span, ca.function_name.name);\n+        let path = cx.path_global(ca.span, vec![ca.function_name]);\n+        let registrar = cx.expr_ident(ca.span, registrar);\n+\n+        let ufcs_path = cx.path(span,\n+                                vec![proc_macro, __internal, registry, register_attr_proc_macro]);\n+\n+        cx.stmt_expr(cx.expr_call(span, cx.expr_path(ufcs_path),\n+                                  vec![registrar, name, cx.expr_path(path)]))\n+    }));\n+\n     let path = cx.path(span, vec![proc_macro, __internal, registry]);\n     let registrar_path = cx.ty_path(path);\n     let arg_ty = cx.ty_rptr(span, registrar_path, None, ast::Mutability::Mutable);"}, {"sha": "db0c19e96f8211a2996bb6df3e21b8e21b52e0db", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/attr_proc_macro.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr_proc_macro.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_attribute]\n+pub fn attr_proc_macro(_: TokenStream, input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "7e32800e0f9b8a915e597c5936e905f4dd0882f5", "filename": "src/test/compile-fail-fulldeps/proc-macro/feature-gate-proc_macro.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ffeature-gate-proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ffeature-gate-proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ffeature-gate-proc_macro.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:attr_proc_macro.rs\n+// gate-test-proc_macro\n+#![feature(use_extern_macros)]\n+\n+extern crate attr_proc_macro;\n+use attr_proc_macro::attr_proc_macro;\n+\n+#[attr_proc_macro]\n+//~^ ERROR: attribute procedural macros are experimental\n+struct Foo;\n+\n+fn main() {\n+    let _ = Foo;\n+}\n\\ No newline at end of file"}, {"sha": "76253487b51fc294f5abd7468e9a4d2a4a9f1a10", "filename": "src/test/compile-fail-fulldeps/proc-macro/macro-use-attr.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-attr.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:attr_proc_macro.rs\n+#![feature(proc_macro)]\n+\n+#[macro_use] extern crate attr_proc_macro;\n+\n+#[attr_proc_macro]\n+//~^ ERROR: attribute procedural macros cannot be imported with `#[macro_use]`\n+struct Foo;\n+\n+fn main() {\n+    let _ = Foo;\n+}"}, {"sha": "288cab71ff49c24faf9fefeeaaca5aa150ba5e68", "filename": "src/test/compile-fail-fulldeps/proc-macro/proc-macro-custom-attr-mutex.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-custom-attr-mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-custom-attr-mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-custom-attr-mutex.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:attr_proc_macro.rs\n+\n+#![feature(proc_macro, custom_attribute)]\n+//~^ ERROR Cannot use `#![feature(proc_macro)]` and `#![feature(custom_attribute)] at the same time\n+\n+extern crate attr_proc_macro;\n+use attr_proc_macro::attr_proc_macro;\n+\n+#[attr_proc_macro]\n+fn foo() {}\n+\n+fn main() {\n+    foo();\n+}"}, {"sha": "d28d75d81a2fb7ca5f35d42d60afdc0d49e0a792", "filename": "src/test/run-pass-fulldeps/proc-macro/attr-args.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-args.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:attr-args.rs\n+\n+#![allow(warnings)]\n+#![feature(proc_macro)]\n+\n+extern crate attr_args;\n+use attr_args::attr_with_args;\n+\n+#[attr_with_args(text = \"Hello, world!\")]\n+fn foo() {}\n+\n+fn main() {\n+    assert_eq!(foo(), \"Hello, world!\");\n+}"}, {"sha": "6e1eb395a0a1923f6a215cbaf6400060a8462dd6", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/attr-args.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-args.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_attribute]\n+pub fn attr_with_args(args: TokenStream, input: TokenStream) -> TokenStream {\n+    let args = args.to_string();\n+\n+    assert_eq!(args, r#\"( text = \"Hello, world!\" )\"#);\n+\n+    let input = input.to_string();\n+\n+    assert_eq!(input, \"fn foo (  ) {  }\");\n+\n+    r#\"\n+        fn foo() -> &'static str { \"Hello, world!\" }\n+    \"#.parse().unwrap()\n+}"}, {"sha": "9df3e254943423685bf24021df92805c79939607", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/375cbd20cfcc9dbf15682bcfc0081ce5ce95567b/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=375cbd20cfcc9dbf15682bcfc0081ce5ce95567b", "patch": "@@ -172,7 +172,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n         \"use_extern_macros\", \"staged_api\", \"const_indexing\",\n         \"unboxed_closures\", \"stmt_expr_attributes\",\n         \"cfg_target_thread_local\", \"unwind_attributes\",\n-        \"inclusive_range_syntax\"\n+        \"inclusive_range_syntax\", \"proc_macro\"\n     ];\n \n     // Only check the number of lang features."}]}