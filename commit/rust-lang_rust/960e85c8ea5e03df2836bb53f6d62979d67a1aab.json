{"sha": "960e85c8ea5e03df2836bb53f6d62979d67a1aab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MGU4NWM4ZWE1ZTAzZGYyODM2YmI1M2Y2ZDYyOTc5ZDY3YTFhYWI=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2015-09-24T09:29:15Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2015-09-24T09:29:15Z"}, "message": "change fasta benchmark to Veedrac's implementation", "tree": {"sha": "7cf5ba9a135f1bf8468d83207c6e97af171e23c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cf5ba9a135f1bf8468d83207c6e97af171e23c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/960e85c8ea5e03df2836bb53f6d62979d67a1aab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/960e85c8ea5e03df2836bb53f6d62979d67a1aab", "html_url": "https://github.com/rust-lang/rust/commit/960e85c8ea5e03df2836bb53f6d62979d67a1aab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/960e85c8ea5e03df2836bb53f6d62979d67a1aab/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fe79bdfdacb2f5914971bd1a0b63b9577afbf6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fe79bdfdacb2f5914971bd1a0b63b9577afbf6a", "html_url": "https://github.com/rust-lang/rust/commit/8fe79bdfdacb2f5914971bd1a0b63b9577afbf6a"}], "stats": {"total": 392, "additions": 305, "deletions": 87}, "files": [{"sha": "a5731f150c6d024c6ef78cc3daccd02521e1c9b3", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 305, "deletions": 87, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/960e85c8ea5e03df2836bb53f6d62979d67a1aab/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/960e85c8ea5e03df2836bb53f6d62979d67a1aab/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=960e85c8ea5e03df2836bb53f6d62979d67a1aab", "patch": "@@ -39,114 +39,332 @@\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n use std::cmp::min;\n-use std::env;\n-use std::fs::File;\n-use std::io::{self, BufWriter};\n-use std::io::prelude::*;\n+use std::io::{self, Write};\n+use std::sync::{Arc, Mutex};\n+use std::thread;\n \n-const LINE_LENGTH: usize = 60;\n-const IM: u32 = 139968;\n \n-struct MyRandom {\n+const LINE_LEN: usize = 60;\n+\n+const BLOCK_LINES: usize = 512;\n+const BLOCK_THOROUGHPUT: usize = LINE_LEN * BLOCK_LINES;\n+const BLOCK_LEN: usize = BLOCK_THOROUGHPUT + BLOCK_LINES;\n+\n+const STDIN_BUF: usize = (LINE_LEN + 1) * 1024;\n+\n+\n+const ALU: &'static [u8] =\n+    b\"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\\\n+      GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\\\n+      CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\\\n+      ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\\\n+      GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\\\n+      AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\\\n+      AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n+\n+const IUB: &'static [(u8, f32)] =\n+    &[(b'a', 0.27), (b'c', 0.12), (b'g', 0.12),\n+      (b't', 0.27), (b'B', 0.02), (b'D', 0.02),\n+      (b'H', 0.02), (b'K', 0.02), (b'M', 0.02),\n+      (b'N', 0.02), (b'R', 0.02), (b'S', 0.02),\n+      (b'V', 0.02), (b'W', 0.02), (b'Y', 0.02)];\n+\n+const HOMOSAPIENS: &'static [(u8, f32)] =\n+    &[(b'a', 0.3029549426680),\n+      (b'c', 0.1979883004921),\n+      (b'g', 0.1975473066391),\n+      (b't', 0.3015094502008)];\n+\n+\n+// We need a specific Rng,\n+// so implement this manually\n+const MODULUS: u32 = 139968;\n+const MULTIPLIER: u32 = 3877;\n+const ADDITIVE: u32 = 29573;\n+\n+// Why doesn't rust already have this?\n+// Algorithm directly taken from Wikipedia\n+fn powmod(mut base: u64, mut exponent: u32, modulus: u64) -> u64 {\n+    let mut ret = 1;\n+    base %= modulus;\n+\n+    while exponent > 0 {\n+        if exponent & 1 == 1 {\n+           ret *= base;\n+           ret %= modulus;\n+        }\n+        exponent >>= 1;\n+        base *= base;\n+        base %= modulus;\n+    }\n+\n+    ret\n+}\n+\n+// Just a typical LCRNG\n+pub struct Rng {\n     last: u32\n }\n-impl MyRandom {\n-    fn new() -> MyRandom { MyRandom { last: 42 } }\n-    fn normalize(p: f32) -> u32 {(p * IM as f32).floor() as u32}\n-    fn gen(&mut self) -> u32 {\n-        self.last = (self.last * 3877 + 29573) % IM;\n+\n+impl Rng {\n+    pub fn new() -> Rng {\n+        Rng { last: 42 }\n+    }\n+\n+    pub fn max_value() -> u32 {\n+        MODULUS - 1\n+    }\n+\n+    pub fn normalize(p: f32) -> u32 {\n+        (p * MODULUS as f32).floor() as u32\n+    }\n+\n+    pub fn gen(&mut self) -> u32 {\n+        self.last = (self.last * MULTIPLIER + ADDITIVE) % MODULUS;\n         self.last\n     }\n+\n+    // This allows us to fast-forward the RNG,\n+    // allowing us to run it in parallel.\n+    pub fn future(&self, n: u32) -> Rng {\n+        let a = MULTIPLIER as u64;\n+        let b = ADDITIVE as u64;\n+        let m = MODULUS as u64;\n+\n+        //                          (a^n - 1) mod (a-1) m\n+        // x_k = ((a^n x_0 mod m) + --------------------- b) mod m\n+        //                                   a - 1\n+        //\n+        // Since (a - 1) divides (a^n - 1) mod (a-1) m,\n+        // the subtraction does not overflow and thus can be non-modular.\n+        //\n+        let new_seed =\n+            (powmod(a, n, m) * self.last as u64) % m +\n+            (powmod(a, n, (a-1) * m) - 1) / (a-1) * b;\n+\n+        Rng { last: (new_seed % m) as u32 }\n+    }\n }\n \n-struct AAGen<'a> {\n-    rng: &'a mut MyRandom,\n-    data: Vec<(u32, u8)>\n+\n+// This will end up keeping track of threads, like\n+// in the other multithreaded Rust version, in\n+// order to keep writes in order.\n+//\n+// This is stolen from another multithreaded Rust\n+// implementation, although that implementation\n+// was not able to parallelize the RNG itself.\n+struct BlockSubmitter<W: io::Write> {\n+    writer: W,\n+    pub waiting_on: usize,\n }\n-impl<'a> AAGen<'a> {\n-    fn new<'b>(rng: &'b mut MyRandom, aa: &[(char, f32)]) -> AAGen<'b> {\n-        let mut cum = 0.;\n-        let data = aa.iter()\n-            .map(|&(ch, p)| { cum += p; (MyRandom::normalize(cum), ch as u8) })\n-            .collect();\n-        AAGen { rng: rng, data: data }\n+\n+impl<W: io::Write> BlockSubmitter<W> {\n+    fn submit(&mut self, data: &[u8], block_num: usize) -> Option<io::Result<()>> {\n+        if block_num == self.waiting_on {\n+            self.waiting_on += 1;\n+            Some(self.submit_async(data))\n+        }\n+        else {\n+            None\n+        }\n     }\n-}\n-impl<'a> Iterator for AAGen<'a> {\n-    type Item = u8;\n-\n-    fn next(&mut self) -> Option<u8> {\n-        let r = self.rng.gen();\n-        self.data.iter()\n-            .skip_while(|pc| pc.0 < r)\n-            .map(|&(_, c)| c)\n-            .next()\n+\n+    fn submit_async(&mut self, data: &[u8]) -> io::Result<()> {\n+        self.writer.write_all(data)\n     }\n }\n \n-fn make_fasta<W: Write, I: Iterator<Item=u8>>(\n-    wr: &mut W, header: &str, mut it: I, mut n: usize)\n-    -> io::Result<()>\n+\n+// For repeating strings as output\n+fn fasta_static<W: io::Write>(\n+    writer: &mut W,\n+    header: &[u8],\n+    data: &[u8],\n+    mut n: usize\n+) -> io::Result<()>\n {\n-    try!(wr.write(header.as_bytes()));\n-    let mut line = [0; LINE_LENGTH + 1];\n+    // The aim here is to print a short(ish) string cyclically\n+    // with line breaks as appropriate.\n+    //\n+    // The secret technique is to repeat the string such that\n+    // any wanted line is a single offset in the string.\n+    //\n+    // This technique is stolen from the Haskell version.\n+\n+    try!(writer.write_all(header));\n+\n+    // Maximum offset is data.len(),\n+    // Maximum read len is LINE_LEN\n+    let stream = data.iter().cloned().cycle();\n+    let mut extended: Vec<u8> = stream.take(data.len() + LINE_LEN + 1).collect();\n+\n+    let mut offset = 0;\n     while n > 0 {\n-        let nb = min(LINE_LENGTH, n);\n-        for i in 0..nb {\n-            line[i] = it.next().unwrap();\n+        let write_len = min(LINE_LEN, n);\n+        let end = offset + write_len;\n+        n -= write_len;\n+\n+        let tmp = extended[end];\n+        extended[end] = b'\\n';\n+        try!(writer.write_all(&extended[offset..end + 1]));\n+        extended[end] = tmp;\n+\n+        offset = end;\n+        offset %= data.len();\n+    }\n+\n+    Ok(())\n+}\n+\n+\n+// For RNG streams as output\n+fn fasta<W: io::Write + Send + 'static>(\n+    submitter: &Arc<Mutex<BlockSubmitter<W>>>,\n+    header: &[u8],\n+    table: &[(u8, f32)],\n+    rng: &mut Rng,\n+    n: usize\n+) -> io::Result<()>\n+{\n+    // There's another secret technique in use here:\n+    // we generate a lookup table to cache search of the\n+    // aa buffer.\n+    //\n+    // The secret technique used is stolen from Haskell's\n+    // implementation, and is the main secret to the Haskell\n+    // implementation's  speed.\n+    fn gen_lookup_table(aa: &[(u8, f32)]) -> Vec<u8> {\n+        let mut table = Vec::with_capacity(Rng::max_value() as usize + 1);\n+\n+        let mut cumulative_prob = 0.0;\n+        let mut cumulative_norm = 0;\n+\n+        for &(byte, prob) in aa {\n+            let last_norm = cumulative_norm;\n+            cumulative_prob += prob;\n+            cumulative_norm = min(Rng::max_value(), Rng::normalize(cumulative_prob)) + 1;\n+\n+            table.extend((0..cumulative_norm - last_norm).map(|_| byte));\n         }\n-        n -= nb;\n-        line[nb] = '\\n' as u8;\n-        try!(wr.write(&line[..nb+1]));\n+\n+        table\n+    }\n+\n+    {\n+        try!(submitter.lock().unwrap().submit_async(header));\n     }\n+\n+    let lookup_table = Arc::new(gen_lookup_table(table));\n+\n+    let thread_count = 4; // avoid external dependency\n+    let mut threads = Vec::new();\n+    for block_num in (0..thread_count) {\n+        let offset = BLOCK_THOROUGHPUT * block_num;\n+\n+        let local_submitter = submitter.clone();\n+        let local_lookup_table = lookup_table.clone();\n+        let local_rng = rng.future(offset as u32);\n+\n+        threads.push(thread::spawn(move || {\n+            gen_block(\n+                local_submitter,\n+                local_lookup_table,\n+                local_rng,\n+                n.saturating_sub(offset),\n+                block_num,\n+                thread_count\n+            )\n+        }));\n+    }\n+\n+    for thread in threads {\n+        try!(thread.join().unwrap());\n+    }\n+\n+    *rng = rng.future(n as u32);\n+\n     Ok(())\n }\n \n-fn run<W: Write>(writer: &mut W) -> io::Result<()> {\n-    let mut args = env::args();\n-    let n = if env::var_os(\"RUST_BENCH\").is_some() {\n-        25000000\n-    } else if args.len() <= 1 {\n-        1000\n-    } else {\n-        args.nth(1).unwrap().parse().unwrap()\n-    };\n-\n-    let rng = &mut MyRandom::new();\n-    let alu =\n-        \"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\\\n-        GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\\\n-        CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\\\n-        ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\\\n-        GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\\\n-        AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\\\n-        AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n-    let iub = &[('a', 0.27), ('c', 0.12), ('g', 0.12),\n-                ('t', 0.27), ('B', 0.02), ('D', 0.02),\n-                ('H', 0.02), ('K', 0.02), ('M', 0.02),\n-                ('N', 0.02), ('R', 0.02), ('S', 0.02),\n-                ('V', 0.02), ('W', 0.02), ('Y', 0.02)];\n-    let homosapiens = &[('a', 0.3029549426680),\n-                        ('c', 0.1979883004921),\n-                        ('g', 0.1975473066391),\n-                        ('t', 0.3015094502008)];\n-\n-    try!(make_fasta(writer, \">ONE Homo sapiens alu\\n\",\n-                    alu.as_bytes().iter().cycle().cloned(), n * 2));\n-    try!(make_fasta(writer, \">TWO IUB ambiguity codes\\n\",\n-                    AAGen::new(rng, iub), n * 3));\n-    try!(make_fasta(writer, \">THREE Homo sapiens frequency\\n\",\n-                    AAGen::new(rng, homosapiens), n * 5));\n-\n-    writer.flush()\n+// A very optimized writer.\n+// I have a feeling a simpler version wouldn't slow\n+// things down too much, though, since the RNG\n+// is the really heavy hitter.\n+fn gen_block<W: io::Write>(\n+    submitter: Arc<Mutex<BlockSubmitter<W>>>,\n+    lookup_table: Arc<Vec<u8>>,\n+    mut rng: Rng,\n+    mut length: usize,\n+    mut block_num: usize,\n+    block_stride: usize,\n+) -> io::Result<()>\n+{\n+    // Include newlines in block\n+    length += length / LINE_LEN;\n+    let block: &mut [u8] = &mut [b'\\n'; BLOCK_LEN];\n+\n+    while length > 0 {\n+        {\n+            let gen_into = &mut block[..min(length, BLOCK_LEN)];\n+\n+            // Write random numbers, skipping newlines\n+            for (i, byte) in gen_into.iter_mut().enumerate() {\n+                if (i + 1) % (LINE_LEN + 1) != 0 {\n+                    *byte = lookup_table[rng.gen() as usize];\n+                }\n+            }\n+        }\n+\n+        let write_out = {\n+            if length >= BLOCK_LEN               { &mut *block }\n+            else if length % (LINE_LEN + 1) == 0 { &mut block[..length] }\n+            else                                 { &mut block[..length + 1] }\n+        };\n+\n+        *write_out.last_mut().unwrap() = b'\\n';\n+        loop {\n+            match submitter.lock().unwrap().submit(write_out, block_num) {\n+                Some(result) => { try!(result); break; }\n+                None => std::thread::yield_now()\n+            }\n+        }\n+        block_num += block_stride;\n+        rng = rng.future((BLOCK_THOROUGHPUT * (block_stride - 1)) as u32);\n+        length = length.saturating_sub(BLOCK_LEN * (block_stride - 1));\n+\n+        length = length.saturating_sub(BLOCK_LEN);\n+    }\n+\n+    Ok(())\n }\n \n+\n+fn run<W: io::Write + Send + 'static>(writer: W) -> io::Result<()> {\n+    let n = std::env::args_os().nth(1)\n+        .and_then(|s| s.into_string().ok())\n+        .and_then(|n| n.parse().ok())\n+        .unwrap_or(1000);\n+\n+    let rng = &mut Rng::new();\n+\n+    // Use automatic buffering for the static version...\n+    let mut writer = io::BufWriter::with_capacity(STDIN_BUF, writer);\n+    try!(fasta_static(&mut writer, b\">ONE Homo sapiens alu\\n\", ALU, n * 2));\n+\n+    // ...but the dynamic version does its own buffering already\n+    let writer = try!(writer.into_inner());\n+    let submitter = Arc::new(Mutex::new(BlockSubmitter { writer: writer, waiting_on: 0 }));\n+\n+    { submitter.lock().unwrap().waiting_on = 0; }\n+    try!(fasta(&submitter, b\">TWO IUB ambiguity codes\\n\", &IUB, rng, n * 3));\n+    { submitter.lock().unwrap().waiting_on = 0; }\n+    try!(fasta(&submitter, b\">THREE Homo sapiens frequency\\n\", &HOMOSAPIENS, rng, n * 5));\n+\n+    Ok(())\n+}\n+\n+\n fn main() {\n-    let res = if env::var_os(\"RUST_BENCH\").is_some() {\n-        let mut file = BufWriter::new(File::create(\"./shootout-fasta.data\").unwrap());\n-        run(&mut file)\n-    } else {\n-        run(&mut io::stdout())\n-    };\n-    res.unwrap()\n+    run(io::stdout()).unwrap()\n }"}]}