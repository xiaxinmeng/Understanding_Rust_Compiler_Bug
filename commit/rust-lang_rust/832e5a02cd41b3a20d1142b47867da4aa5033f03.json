{"sha": "832e5a02cd41b3a20d1142b47867da4aa5033f03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzMmU1YTAyY2Q0MWIzYTIwZDExNDJiNDc4NjdkYTRhYTUwMzNmMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-01T08:36:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-01T08:36:59Z"}, "message": "Auto merge of #27453 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #26982, #27305, #27419, #27423, #27426\n- Failed merges:", "tree": {"sha": "46e2aae3d859a544acbdc5b44d7bc1eb52f8ad2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46e2aae3d859a544acbdc5b44d7bc1eb52f8ad2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/832e5a02cd41b3a20d1142b47867da4aa5033f03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/832e5a02cd41b3a20d1142b47867da4aa5033f03", "html_url": "https://github.com/rust-lang/rust/commit/832e5a02cd41b3a20d1142b47867da4aa5033f03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/832e5a02cd41b3a20d1142b47867da4aa5033f03/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f50518e05ab1fd7632b83c0c6675ec072d1685ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/f50518e05ab1fd7632b83c0c6675ec072d1685ea", "html_url": "https://github.com/rust-lang/rust/commit/f50518e05ab1fd7632b83c0c6675ec072d1685ea"}, {"sha": "ead9a6dacf88f252b700a3d342cf332ae522eef7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ead9a6dacf88f252b700a3d342cf332ae522eef7", "html_url": "https://github.com/rust-lang/rust/commit/ead9a6dacf88f252b700a3d342cf332ae522eef7"}], "stats": {"total": 142, "additions": 114, "deletions": 28}, "files": [{"sha": "cc5bc8a602daad24397b431823ba29c0d048f3ca", "filename": "src/doc/tarpl/borrow-splitting.md", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/832e5a02cd41b3a20d1142b47867da4aa5033f03/src%2Fdoc%2Ftarpl%2Fborrow-splitting.md", "raw_url": "https://github.com/rust-lang/rust/raw/832e5a02cd41b3a20d1142b47867da4aa5033f03/src%2Fdoc%2Ftarpl%2Fborrow-splitting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fborrow-splitting.md?ref=832e5a02cd41b3a20d1142b47867da4aa5033f03", "patch": "@@ -27,19 +27,27 @@ However borrowck doesn't understand arrays or slices in any way, so this doesn't\n work:\n \n ```rust,ignore\n-let x = [1, 2, 3];\n+let mut x = [1, 2, 3];\n let a = &mut x[0];\n let b = &mut x[1];\n println!(\"{} {}\", a, b);\n ```\n \n ```text\n-<anon>:3:18: 3:22 error: cannot borrow immutable indexed content `x[..]` as mutable\n-<anon>:3     let a = &mut x[0];\n-                          ^~~~\n-<anon>:4:18: 4:22 error: cannot borrow immutable indexed content `x[..]` as mutable\n-<anon>:4     let b = &mut x[1];\n-                          ^~~~\n+<anon>:4:14: 4:18 error: cannot borrow `x[..]` as mutable more than once at a time\n+<anon>:4 let b = &mut x[1];\n+                      ^~~~\n+<anon>:3:14: 3:18 note: previous borrow of `x[..]` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x[..]` until the borrow ends\n+<anon>:3 let a = &mut x[0];\n+                      ^~~~\n+<anon>:6:2: 6:2 note: previous borrow ends here\n+<anon>:1 fn main() {\n+<anon>:2 let mut x = [1, 2, 3];\n+<anon>:3 let a = &mut x[0];\n+<anon>:4 let b = &mut x[1];\n+<anon>:5 println!(\"{} {}\", a, b);\n+<anon>:6 }\n+         ^\n error: aborting due to 2 previous errors\n ```\n "}, {"sha": "334d5c9dd55e3045b1884a1ff66c126a23176a34", "filename": "src/doc/tarpl/send-and-sync.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/832e5a02cd41b3a20d1142b47867da4aa5033f03/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md", "raw_url": "https://github.com/rust-lang/rust/raw/832e5a02cd41b3a20d1142b47867da4aa5033f03/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md?ref=832e5a02cd41b3a20d1142b47867da4aa5033f03", "patch": "@@ -5,8 +5,8 @@ multiply alias a location in memory while mutating it. Unless these types use\n synchronization to manage this access, they are absolutely not thread safe. Rust\n captures this with through the `Send` and `Sync` traits.\n \n-* A type is Send if it is safe to send it to another thread. A type is Sync if\n-* it is safe to share between threads (`&T` is Send).\n+* A type is Send if it is safe to send it to another thread.\n+* A type is Sync if it is safe to share between threads (`&T` is Send).\n \n Send and Sync are fundamental to Rust's concurrency story. As such, a\n substantial amount of special tooling exists to make them work right. First and\n@@ -24,9 +24,9 @@ pretty much all types you'll ever interact with are Send and Sync.\n \n Major exceptions include:\n \n-* raw pointers are neither Send nor Sync (because they have no safety guards)\n-* `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't) `Rc` isn't\n-* Send or Sync (because the refcount is shared and unsynchronized)\n+* raw pointers are neither Send nor Sync (because they have no safety guards).\n+* `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't).\n+* `Rc` isn't Send or Sync (because the refcount is shared and unsynchronized).\n \n `Rc` and `UnsafeCell` are very fundamentally not thread-safe: they enable\n unsynchronized shared mutable state. However raw pointers are, strictly\n@@ -70,7 +70,7 @@ possible cause trouble by being incorrectly Send or Sync.\n Most uses of raw pointers should be encapsulated behind a sufficient abstraction\n that Send and Sync can be derived. For instance all of Rust's standard\n collections are Send and Sync (when they contain Send and Sync types) in spite\n-of their pervasive use raw pointers to manage allocations and complex ownership.\n+of their pervasive use of raw pointers to manage allocations and complex ownership.\n Similarly, most iterators into these collections are Send and Sync because they\n largely behave like an `&` or `&mut` into the collection.\n "}, {"sha": "77256d5b34ef96f3d25ec44558329502667a2513", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 92, "deletions": 14, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/832e5a02cd41b3a20d1142b47867da4aa5033f03/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/832e5a02cd41b3a20d1142b47867da4aa5033f03/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=832e5a02cd41b3a20d1142b47867da4aa5033f03", "patch": "@@ -1227,16 +1227,22 @@ impl Bytes { ... } // error, same as above\n \"##,\n \n E0117: r##\"\n-You got this error because because you tried to implement a foreign\n-trait for a foreign type (with maybe a foreign type parameter). Erroneous\n-code example:\n+This error indicates a violation of one of Rust's orphan rules for trait\n+implementations. The rule prohibits any implementation of a foreign trait (a\n+trait defined in another crate) where\n+\n+ - the type that is implementing the trait is foreign\n+ - all of the parameters being passed to the trait (if there are any) are also\n+   foreign.\n+\n+Here's one example of this error:\n \n ```\n impl Drop for u32 {}\n ```\n \n-The type, trait or the type parameter (or all of them) has to be defined\n-in your crate. Example:\n+To avoid this kind of error, ensure that at least one local type is referenced\n+by the `impl`:\n \n ```\n pub struct Foo; // you define your type in your crate\n@@ -1245,21 +1251,29 @@ impl Drop for Foo { // and you can implement the trait on it!\n     // code of trait implementation here\n }\n \n-trait Bar { // or define your trait in your crate\n-    fn get(&self) -> usize;\n-}\n-\n-impl Bar for u32 { // and then you implement it on a foreign type\n-    fn get(&self) -> usize { 0 }\n-}\n-\n impl From<Foo> for i32 { // or you use a type from your crate as\n                          // a type parameter\n     fn from(i: Foo) -> i32 {\n         0\n     }\n }\n ```\n+\n+Alternatively, define a trait locally and implement that instead:\n+\n+```\n+trait Bar {\n+    fn get(&self) -> usize;\n+}\n+\n+impl Bar for u32 {\n+    fn get(&self) -> usize { 0 }\n+}\n+```\n+\n+For information on the design of the orphan rules, see [RFC 1023].\n+\n+[RFC 1023]: https://github.com/rust-lang/rfcs/pull/1023\n \"##,\n \n E0119: r##\"\n@@ -1889,6 +1903,71 @@ impl MyTrait for Foo {\n ```\n \"##,\n \n+E0210: r##\"\n+This error indicates a violation of one of Rust's orphan rules for trait\n+implementations. The rule concerns the use of type parameters in an\n+implementation of a foreign trait (a trait defined in another crate), and\n+states that type parameters must be \"covered\" by a local type. To understand\n+what this means, it is perhaps easiest to consider a few examples.\n+\n+If `ForeignTrait` is a trait defined in some external crate `foo`, then the\n+following trait `impl` is an error:\n+\n+```\n+extern crate foo;\n+use foo::ForeignTrait;\n+\n+impl<T> ForeignTrait for T { ... } // error\n+```\n+\n+To work around this, it can be covered with a local type, `MyType`:\n+\n+```\n+struct MyType<T>(T);\n+impl<T> ForeignTrait for MyType<T> { ... } // Ok\n+```\n+\n+For another example of an error, suppose there's another trait defined in `foo`\n+named `ForeignTrait2` that takes two type parameters. Then this `impl` results\n+in the same rule violation:\n+\n+```\n+struct MyType2;\n+impl<T> ForeignTrait2<T, MyType<T>> for MyType2 { ... } // error\n+```\n+\n+The reason for this is that there are two appearances of type parameter `T` in\n+the `impl` header, both as parameters for `ForeignTrait2`. The first appearance\n+is uncovered, and so runs afoul of the orphan rule.\n+\n+Consider one more example:\n+\n+```\n+impl<T> ForeignTrait2<MyType<T>, T> for MyType2 { ... } // Ok\n+```\n+\n+This only differs from the previous `impl` in that the parameters `T` and\n+`MyType<T>` for `ForeignTrait2` have been swapped. This example does *not*\n+violate the orphan rule; it is permitted.\n+\n+To see why that last example was allowed, you need to understand the general\n+rule. Unfortunately this rule is a bit tricky to state. Consider an `impl`:\n+\n+```\n+impl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n+```\n+\n+where `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`\n+are types. One of the types `T0, ..., Tn` must be a local type (this is another\n+orphan rule, see the explanation for E0117). Let `i` be the smallest integer\n+such that `Ti` is a local type. Then no type parameter can appear in any of the\n+`Tj` for `j < i`.\n+\n+For information on the design of the orphan rules, see [RFC 1023].\n+\n+[RFC 1023]: https://github.com/rust-lang/rfcs/pull/1023\n+\"##,\n+\n E0211: r##\"\n You used an intrinsic function which doesn't correspond to its\n definition. Erroneous code example:\n@@ -2335,7 +2414,6 @@ register_diagnostics! {\n            // and only one is supported\n     E0208,\n     E0209, // builtin traits can only be implemented on structs or enums\n-    E0210, // type parameter is not constrained by any local type\n     E0212, // cannot extract an associated type from a higher-ranked trait bound\n     E0213, // associated types are not accepted in this context\n     E0214, // parenthesized parameters may only be used with a trait"}, {"sha": "010e2cc7bb2d48e3954d1833d0f7cda0b10b0295", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/832e5a02cd41b3a20d1142b47867da4aa5033f03/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/832e5a02cd41b3a20d1142b47867da4aa5033f03/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=832e5a02cd41b3a20d1142b47867da4aa5033f03", "patch": "@@ -15,7 +15,7 @@\n //! for the [broader Rust ecosystem](https://crates.io). It offers\n //! core types (e.g. [`Vec`](vec/index.html)\n //! and [`Option`](option/index.html)), library-defined [operations on\n-//! language primitives](#primitive) (e.g. [`u32`](u32/index.html) and\n+//! language primitives](#primitives) (e.g. [`u32`](u32/index.html) and\n //! [`str`](str/index.html)), [standard macros](#macros),\n //! [I/O](io/index.html) and [multithreading](thread/index.html), among\n //! [many other lovely"}]}