{"sha": "89c4e3792ddc5b45706ea0e919806a248f7a87c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YzRlMzc5MmRkYzViNDU3MDZlYTBlOTE5ODA2YTI0OGY3YTg3YzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-17T10:58:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-17T10:58:43Z"}, "message": "auto merge of #21233 : huonw/rust/simd-size, r=Aatch\n\nThis stops the compiler ICEing on the use of SIMD types in FFI signatures. It emits correct code for LLVM intrinsics, but I am quite unsure about the ABI handling in general so I've added a new feature gate `simd_ffi` to try to ensure people don't use it without realising there's a non-trivial risk of codegen brokenness.\r\n\r\nCloses #20043.", "tree": {"sha": "31af99a5d3e3fe2cbc72ea7a7a168a796327c322", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31af99a5d3e3fe2cbc72ea7a7a168a796327c322"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89c4e3792ddc5b45706ea0e919806a248f7a87c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89c4e3792ddc5b45706ea0e919806a248f7a87c3", "html_url": "https://github.com/rust-lang/rust/commit/89c4e3792ddc5b45706ea0e919806a248f7a87c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89c4e3792ddc5b45706ea0e919806a248f7a87c3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e6eaeb69ff729096253670aba752c03225113bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e6eaeb69ff729096253670aba752c03225113bc", "html_url": "https://github.com/rust-lang/rust/commit/3e6eaeb69ff729096253670aba752c03225113bc"}, {"sha": "c8e0e9549d4327c54d9eb5fd0de5e23312c34fe9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e0e9549d4327c54d9eb5fd0de5e23312c34fe9", "html_url": "https://github.com/rust-lang/rust/commit/c8e0e9549d4327c54d9eb5fd0de5e23312c34fe9"}], "stats": {"total": 473, "additions": 359, "deletions": 114}, "files": [{"sha": "0d1836e01443520e31a70a36051508e55fead566", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=89c4e3792ddc5b45706ea0e919806a248f7a87c3", "patch": "@@ -304,7 +304,7 @@ pub enum RealPredicate {\n \n // The LLVM TypeKind type - must stay in sync with the def of\n // LLVMTypeKind in llvm/include/llvm-c/Core.h\n-#[derive(Copy, PartialEq)]\n+#[derive(Copy, PartialEq, Show)]\n #[repr(C)]\n pub enum TypeKind {\n     Void      = 0,"}, {"sha": "037f20ee4c5ff7e3a93f1a3bbd3d49815926bd02", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=89c4e3792ddc5b45706ea0e919806a248f7a87c3", "patch": "@@ -835,26 +835,24 @@ pub fn cast_shift_rhs<F, G>(op: ast::BinOp,\n     G: FnOnce(ValueRef, Type) -> ValueRef,\n {\n     // Shifts may have any size int on the rhs\n-    unsafe {\n-        if ast_util::is_shift_binop(op) {\n-            let mut rhs_llty = val_ty(rhs);\n-            let mut lhs_llty = val_ty(lhs);\n-            if rhs_llty.kind() == Vector { rhs_llty = rhs_llty.element_type() }\n-            if lhs_llty.kind() == Vector { lhs_llty = lhs_llty.element_type() }\n-            let rhs_sz = llvm::LLVMGetIntTypeWidth(rhs_llty.to_ref());\n-            let lhs_sz = llvm::LLVMGetIntTypeWidth(lhs_llty.to_ref());\n-            if lhs_sz < rhs_sz {\n-                trunc(rhs, lhs_llty)\n-            } else if lhs_sz > rhs_sz {\n-                // FIXME (#1877: If shifting by negative\n-                // values becomes not undefined then this is wrong.\n-                zext(rhs, lhs_llty)\n-            } else {\n-                rhs\n-            }\n+    if ast_util::is_shift_binop(op) {\n+        let mut rhs_llty = val_ty(rhs);\n+        let mut lhs_llty = val_ty(lhs);\n+        if rhs_llty.kind() == Vector { rhs_llty = rhs_llty.element_type() }\n+        if lhs_llty.kind() == Vector { lhs_llty = lhs_llty.element_type() }\n+        let rhs_sz = rhs_llty.int_width();\n+        let lhs_sz = lhs_llty.int_width();\n+        if lhs_sz < rhs_sz {\n+            trunc(rhs, lhs_llty)\n+        } else if lhs_sz > rhs_sz {\n+            // FIXME (#1877: If shifting by negative\n+            // values becomes not undefined then this is wrong.\n+            zext(rhs, lhs_llty)\n         } else {\n             rhs\n         }\n+    } else {\n+        rhs\n     }\n }\n "}, {"sha": "0d8ef9e2fc92e6c6829568ba4ec5fc9a59afad29", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=89c4e3792ddc5b45706ea0e919806a248f7a87c3", "patch": "@@ -10,8 +10,7 @@\n \n #![allow(non_upper_case_globals)]\n \n-use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n use llvm::{StructRetAttribute, ZExtAttribute};\n use trans::cabi::{FnType, ArgType};\n use trans::context::CrateContext;\n@@ -30,11 +29,7 @@ fn align(off: uint, ty: Type) -> uint {\n \n fn ty_align(ty: Type) -> uint {\n     match ty.kind() {\n-        Integer => {\n-            unsafe {\n-                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n-            }\n-        }\n+        Integer => ((ty.int_width() as uint) + 7) / 8,\n         Pointer => 8,\n         Float => 4,\n         Double => 8,\n@@ -50,17 +45,18 @@ fn ty_align(ty: Type) -> uint {\n             let elt = ty.element_type();\n             ty_align(elt)\n         }\n+        Vector => {\n+            let len = ty.vector_length();\n+            let elt = ty.element_type();\n+            ty_align(elt) * len\n+        }\n         _ => panic!(\"ty_align: unhandled type\")\n     }\n }\n \n fn ty_size(ty: Type) -> uint {\n     match ty.kind() {\n-        Integer => {\n-            unsafe {\n-                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n-            }\n-        }\n+        Integer => ((ty.int_width() as uint) + 7) / 8,\n         Pointer => 8,\n         Float => 4,\n         Double => 8,\n@@ -80,6 +76,12 @@ fn ty_size(ty: Type) -> uint {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n+        Vector => {\n+            let len = ty.vector_length();\n+            let elt = ty.element_type();\n+            let eltsz = ty_size(elt);\n+            len * eltsz\n+        }\n         _ => panic!(\"ty_size: unhandled type\")\n     }\n }\n@@ -137,7 +139,8 @@ fn is_reg_ty(ty: Type) -> bool {\n         Integer\n         | Pointer\n         | Float\n-        | Double => true,\n+        | Double\n+        | Vector => true,\n         _ => false\n     }\n }"}, {"sha": "7d1a8ab1452eca5b4316330a453261d554ef615f", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=89c4e3792ddc5b45706ea0e919806a248f7a87c3", "patch": "@@ -10,8 +10,7 @@\n \n #![allow(non_upper_case_globals)]\n \n-use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n use llvm::{StructRetAttribute, ZExtAttribute};\n use trans::cabi::{FnType, ArgType};\n use trans::context::CrateContext;\n@@ -37,11 +36,7 @@ fn align(off: uint, ty: Type, align_fn: TyAlignFn) -> uint {\n \n fn general_ty_align(ty: Type) -> uint {\n     match ty.kind() {\n-        Integer => {\n-            unsafe {\n-                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n-            }\n-        }\n+        Integer => ((ty.int_width() as uint) + 7) / 8,\n         Pointer => 4,\n         Float => 4,\n         Double => 8,\n@@ -57,6 +52,11 @@ fn general_ty_align(ty: Type) -> uint {\n             let elt = ty.element_type();\n             general_ty_align(elt)\n         }\n+        Vector => {\n+            let len = ty.vector_length();\n+            let elt = ty.element_type();\n+            general_ty_align(elt) * len\n+        }\n         _ => panic!(\"ty_align: unhandled type\")\n     }\n }\n@@ -70,11 +70,7 @@ fn general_ty_align(ty: Type) -> uint {\n //    /iPhoneOSABIReference/Articles/ARMv6FunctionCallingConventions.html\n fn ios_ty_align(ty: Type) -> uint {\n     match ty.kind() {\n-        Integer => {\n-            unsafe {\n-                cmp::min(4, ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8)\n-            }\n-        }\n+        Integer => cmp::min(4, ((ty.int_width() as uint) + 7) / 8),\n         Pointer => 4,\n         Float => 4,\n         Double => 4,\n@@ -90,17 +86,18 @@ fn ios_ty_align(ty: Type) -> uint {\n             let elt = ty.element_type();\n             ios_ty_align(elt)\n         }\n+        Vector => {\n+            let len = ty.vector_length();\n+            let elt = ty.element_type();\n+            ios_ty_align(elt) * len\n+        }\n         _ => panic!(\"ty_align: unhandled type\")\n     }\n }\n \n fn ty_size(ty: Type, align_fn: TyAlignFn) -> uint {\n     match ty.kind() {\n-        Integer => {\n-            unsafe {\n-                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n-            }\n-        }\n+        Integer => ((ty.int_width() as uint) + 7) / 8,\n         Pointer => 4,\n         Float => 4,\n         Double => 8,\n@@ -123,6 +120,12 @@ fn ty_size(ty: Type, align_fn: TyAlignFn) -> uint {\n             let eltsz = ty_size(elt, align_fn);\n             len * eltsz\n         }\n+        Vector => {\n+            let len = ty.vector_length();\n+            let elt = ty.element_type();\n+            let eltsz = ty_size(elt, align_fn);\n+            len * eltsz\n+        }\n         _ => panic!(\"ty_size: unhandled type\")\n     }\n }\n@@ -166,7 +169,8 @@ fn is_reg_ty(ty: Type) -> bool {\n         Integer\n         | Pointer\n         | Float\n-        | Double => true,\n+        | Double\n+        | Vector => true,\n         _ => false\n     }\n }"}, {"sha": "776be8855cbf7a6269eedc6e36caed53420664dd", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=89c4e3792ddc5b45706ea0e919806a248f7a87c3", "patch": "@@ -13,7 +13,7 @@\n use libc::c_uint;\n use std::cmp;\n use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n use llvm::{StructRetAttribute, ZExtAttribute};\n use trans::cabi::{ArgType, FnType};\n use trans::context::CrateContext;\n@@ -30,11 +30,7 @@ fn align(off: uint, ty: Type) -> uint {\n \n fn ty_align(ty: Type) -> uint {\n     match ty.kind() {\n-        Integer => {\n-            unsafe {\n-                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n-            }\n-        }\n+        Integer => ((ty.int_width() as uint) + 7) / 8,\n         Pointer => 4,\n         Float => 4,\n         Double => 8,\n@@ -50,17 +46,18 @@ fn ty_align(ty: Type) -> uint {\n             let elt = ty.element_type();\n             ty_align(elt)\n         }\n-        _ => panic!(\"ty_size: unhandled type\")\n+        Vector => {\n+            let len = ty.vector_length();\n+            let elt = ty.element_type();\n+            ty_align(elt) * len\n+        }\n+        _ => panic!(\"ty_align: unhandled type\")\n     }\n }\n \n fn ty_size(ty: Type) -> uint {\n     match ty.kind() {\n-        Integer => {\n-            unsafe {\n-                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n-            }\n-        }\n+        Integer => ((ty.int_width() as uint) + 7) / 8,\n         Pointer => 4,\n         Float => 4,\n         Double => 8,\n@@ -80,6 +77,12 @@ fn ty_size(ty: Type) -> uint {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n+        Vector => {\n+            let len = ty.vector_length();\n+            let elt = ty.element_type();\n+            let eltsz = ty_size(elt);\n+            len * eltsz\n+        }\n         _ => panic!(\"ty_size: unhandled type\")\n     }\n }\n@@ -120,7 +123,8 @@ fn is_reg_ty(ty: Type) -> bool {\n         Integer\n         | Pointer\n         | Float\n-        | Double => true,\n+        | Double\n+        | Vector => true,\n         _ => false\n     };\n }"}, {"sha": "980a70256e9369fb1514f7fffa5ad48d9bac88d3", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 87, "deletions": 39, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=89c4e3792ddc5b45706ea0e919806a248f7a87c3", "patch": "@@ -14,9 +14,8 @@\n #![allow(non_upper_case_globals)]\n use self::RegClass::*;\n \n-use llvm;\n use llvm::{Integer, Pointer, Float, Double};\n-use llvm::{Struct, Array, Attribute};\n+use llvm::{Struct, Array, Attribute, Vector};\n use llvm::{StructRetAttribute, ByValAttribute, ZExtAttribute};\n use trans::cabi::{ArgType, FnType};\n use trans::context::CrateContext;\n@@ -33,7 +32,8 @@ enum RegClass {\n     SSEFv,\n     SSEDs,\n     SSEDv,\n-    SSEInt,\n+    SSEInt(/* bitwidth */ u64),\n+    /// Data that can appear in the upper half of an SSE register.\n     SSEUp,\n     X87,\n     X87Up,\n@@ -57,7 +57,7 @@ impl TypeMethods for Type {\n impl RegClass {\n     fn is_sse(&self) -> bool {\n         match *self {\n-            SSEFs | SSEFv | SSEDs | SSEDv => true,\n+            SSEFs | SSEFv | SSEDs | SSEDv | SSEInt(_) => true,\n             _ => false\n         }\n     }\n@@ -93,11 +93,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n \n     fn ty_align(ty: Type) -> uint {\n         match ty.kind() {\n-            Integer => {\n-                unsafe {\n-                    ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n-                }\n-            }\n+            Integer => ((ty.int_width() as uint) + 7) / 8,\n             Pointer => 8,\n             Float => 4,\n             Double => 8,\n@@ -113,17 +109,18 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                 let elt = ty.element_type();\n                 ty_align(elt)\n             }\n-            _ => panic!(\"ty_size: unhandled type\")\n+            Vector => {\n+                let len = ty.vector_length();\n+                let elt = ty.element_type();\n+                ty_align(elt) * len\n+            }\n+            _ => panic!(\"ty_align: unhandled type\")\n         }\n     }\n \n     fn ty_size(ty: Type) -> uint {\n         match ty.kind() {\n-            Integer => {\n-                unsafe {\n-                    ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n-                }\n-            }\n+            Integer => (ty.int_width() as uint + 7) / 8,\n             Pointer => 8,\n             Float => 4,\n             Double => 8,\n@@ -142,6 +139,13 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                 let eltsz = ty_size(elt);\n                 len * eltsz\n             }\n+            Vector => {\n+                let len = ty.vector_length();\n+                let elt = ty.element_type();\n+                let eltsz = ty_size(elt);\n+                len * eltsz\n+            }\n+\n             _ => panic!(\"ty_size: unhandled type\")\n         }\n     }\n@@ -155,26 +159,34 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     fn unify(cls: &mut [RegClass],\n              i: uint,\n              newv: RegClass) {\n-        if cls[i] == newv {\n-            return;\n-        } else if cls[i] == NoClass {\n-            cls[i] = newv;\n-        } else if newv == NoClass {\n-            return;\n-        } else if cls[i] == Memory || newv == Memory {\n-            cls[i] = Memory;\n-        } else if cls[i] == Int || newv == Int {\n-            cls[i] = Int;\n-        } else if cls[i] == X87 ||\n-                  cls[i] == X87Up ||\n-                  cls[i] == ComplexX87 ||\n-                  newv == X87 ||\n-                  newv == X87Up ||\n-                  newv == ComplexX87 {\n-            cls[i] = Memory;\n-        } else {\n-            cls[i] = newv;\n-        }\n+        if cls[i] == newv { return }\n+\n+        let to_write = match (cls[i], newv) {\n+            (NoClass,     _) => newv,\n+            (_,           NoClass) => return,\n+\n+            (Memory,      _) |\n+            (_,           Memory) => Memory,\n+\n+            (Int,         _) |\n+            (_,           Int) => Int,\n+\n+            (X87,         _) |\n+            (X87Up,       _) |\n+            (ComplexX87,  _) |\n+            (_,           X87) |\n+            (_,           X87Up) |\n+            (_,           ComplexX87) => Memory,\n+\n+            (SSEFv,       SSEUp) |\n+            (SSEFs,       SSEUp) |\n+            (SSEDv,       SSEUp) |\n+            (SSEDs,       SSEUp) |\n+            (SSEInt(_),   SSEUp) => return,\n+\n+            (_,           _) => newv\n+        };\n+        cls[i] = to_write;\n     }\n \n     fn classify_struct(tys: &[Type],\n@@ -237,6 +249,27 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                     i += 1u;\n                 }\n             }\n+            Vector => {\n+                let len = ty.vector_length();\n+                let elt = ty.element_type();\n+                let eltsz = ty_size(elt);\n+                let mut reg = match elt.kind() {\n+                    Integer => SSEInt(elt.int_width()),\n+                    Float => SSEFv,\n+                    Double => SSEDv,\n+                    _ => panic!(\"classify: unhandled vector element type\")\n+                };\n+\n+                let mut i = 0u;\n+                while i < len {\n+                    unify(cls, ix + (off + i * eltsz) / 8, reg);\n+\n+                    // everything after the first one is the upper\n+                    // half of a register.\n+                    reg = SSEUp;\n+                    i += 1u;\n+                }\n+            }\n             _ => panic!(\"classify: unhandled type\")\n         }\n     }\n@@ -245,7 +278,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n         let mut i = 0u;\n         let ty_kind = ty.kind();\n         let e = cls.len();\n-        if cls.len() > 2u && (ty_kind == Struct || ty_kind == Array) {\n+        if cls.len() > 2u && (ty_kind == Struct || ty_kind == Array || ty_kind == Vector) {\n             if cls[i].is_sse() {\n                 i += 1u;\n                 while i < e {\n@@ -317,9 +350,19 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n             Int => {\n                 tys.push(Type::i64(ccx));\n             }\n-            SSEFv => {\n+            SSEFv | SSEDv | SSEInt(_) => {\n+                let (elts_per_word, elt_ty) = match cls[i] {\n+                    SSEFv => (2, Type::f32(ccx)),\n+                    SSEDv => (1, Type::f64(ccx)),\n+                    SSEInt(bits) => {\n+                        assert!(bits == 8 || bits == 16 || bits == 32 || bits == 64,\n+                                \"llreg_ty: unsupported SSEInt width {}\", bits);\n+                        (64 / bits, Type::ix(ccx, bits))\n+                    }\n+                    _ => unreachable!(),\n+                };\n                 let vec_len = llvec_len(&cls[(i + 1u)..]);\n-                let vec_ty = Type::vector(&Type::f32(ccx), (vec_len * 2u) as u64);\n+                let vec_ty = Type::vector(&elt_ty, vec_len as u64 * elts_per_word);\n                 tys.push(vec_ty);\n                 i += vec_len;\n                 continue;\n@@ -334,7 +377,12 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n         }\n         i += 1u;\n     }\n-    return Type::struct_(ccx, tys.as_slice(), false);\n+    if tys.len() == 1 && tys[0].kind() == Vector {\n+        // if the type contains only a vector, pass it as that vector.\n+        tys[0]\n+    } else {\n+        Type::struct_(ccx, tys.as_slice(), false)\n+    }\n }\n \n pub fn compute_abi_info(ccx: &CrateContext,"}, {"sha": "11d1c7e67968115382c32099a21e2ec514c756a5", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=89c4e3792ddc5b45706ea0e919806a248f7a87c3", "patch": "@@ -1905,18 +1905,16 @@ fn int_cast(bcx: Block,\n             signed: bool)\n             -> ValueRef {\n     let _icx = push_ctxt(\"int_cast\");\n-    unsafe {\n-        let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype.to_ref());\n-        let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype.to_ref());\n-        return if dstsz == srcsz {\n-            BitCast(bcx, llsrc, lldsttype)\n-        } else if srcsz > dstsz {\n-            TruncOrBitCast(bcx, llsrc, lldsttype)\n-        } else if signed {\n-            SExtOrBitCast(bcx, llsrc, lldsttype)\n-        } else {\n-            ZExtOrBitCast(bcx, llsrc, lldsttype)\n-        };\n+    let srcsz = llsrctype.int_width();\n+    let dstsz = lldsttype.int_width();\n+    return if dstsz == srcsz {\n+        BitCast(bcx, llsrc, lldsttype)\n+    } else if srcsz > dstsz {\n+        TruncOrBitCast(bcx, llsrc, lldsttype)\n+    } else if signed {\n+        SExtOrBitCast(bcx, llsrc, lldsttype)\n+    } else {\n+        ZExtOrBitCast(bcx, llsrc, lldsttype)\n     }\n }\n "}, {"sha": "abb961d87de96a23078c165a0e2efb406f08c940", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=89c4e3792ddc5b45706ea0e919806a248f7a87c3", "patch": "@@ -36,6 +36,7 @@ use syntax::parse::token::{InternedString, special_idents};\n use syntax::parse::token;\n use syntax::{ast};\n use syntax::{attr, ast_map};\n+use syntax::print::pprust;\n use util::ppaux::Repr;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -426,16 +427,47 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     return bcx;\n }\n \n+// feature gate SIMD types in FFI, since I (huonw) am not sure the\n+// ABIs are handled at all correctly.\n+fn gate_simd_ffi(tcx: &ty::ctxt, decl: &ast::FnDecl, ty: &ty::BareFnTy) {\n+    if !tcx.sess.features.borrow().simd_ffi {\n+        let check = |&: ast_ty: &ast::Ty, ty: ty::Ty| {\n+            if ty::type_is_simd(tcx, ty) {\n+                tcx.sess.span_err(ast_ty.span,\n+                              &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n+                                        may result in invalid code\",\n+                                       pprust::ty_to_string(ast_ty))[]);\n+                tcx.sess.span_help(ast_ty.span,\n+                                   \"add #![feature(simd_ffi)] to the crate attributes to enable\");\n+            }\n+        };\n+        let sig = &ty.sig.0;\n+        for (input, ty) in decl.inputs.iter().zip(sig.inputs.iter()) {\n+            check(&*input.ty, *ty)\n+        }\n+        match decl.output {\n+            ast::NoReturn(_) => {}\n+            ast::Return(ref ty) => check(&**ty, sig.output.unwrap())\n+        }\n+    }\n+}\n+\n pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n     let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n     for foreign_item in foreign_mod.items.iter() {\n         let lname = link_name(&**foreign_item);\n \n-        if let ast::ForeignItemFn(..) = foreign_item.node {\n+        if let ast::ForeignItemFn(ref decl, _) = foreign_item.node {\n             match foreign_mod.abi {\n                 Rust | RustIntrinsic => {}\n                 abi => {\n                     let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n+                    match ty.sty {\n+                        ty::ty_bare_fn(_, bft) => gate_simd_ffi(ccx.tcx(), &**decl, bft),\n+                        _ => ccx.tcx().sess.span_bug(foreign_item.span,\n+                                                     \"foreign fn's sty isn't a bare_fn_ty?\")\n+                    }\n+\n                     register_foreign_item_fn(ccx, abi, ty,\n                                              &lname.get()[]);\n                     // Unlike for other items, we shouldn't call"}, {"sha": "0124ab72f6b08ed4ba30ac96f4765b61712ab049", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=89c4e3792ddc5b45706ea0e919806a248f7a87c3", "patch": "@@ -284,6 +284,13 @@ impl Type {\n         }\n     }\n \n+    /// Return the number of elements in `self` if it is a LLVM vector type.\n+    pub fn vector_length(&self) -> uint {\n+        unsafe {\n+            llvm::LLVMGetVectorSize(self.to_ref()) as uint\n+        }\n+    }\n+\n     pub fn array_length(&self) -> uint {\n         unsafe {\n             llvm::LLVMGetArrayLength(self.to_ref()) as uint\n@@ -326,6 +333,13 @@ impl Type {\n             _ => panic!(\"llvm_float_width called on a non-float type\")\n         }\n     }\n+\n+    /// Retrieve the bit width of the integer type `self`.\n+    pub fn int_width(&self) -> u64 {\n+        unsafe {\n+            llvm::LLVMGetIntTypeWidth(self.to_ref()) as u64\n+        }\n+    }\n }\n \n "}, {"sha": "9231d4ad659430c058b961e810dbd5e3fee0ef6a", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=89c4e3792ddc5b45706ea0e919806a248f7a87c3", "patch": "@@ -72,6 +72,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"slicing_syntax\", Active),\n     (\"box_syntax\", Active),\n     (\"on_unimplemented\", Active),\n+    (\"simd_ffi\", Active),\n \n     (\"if_let\", Accepted),\n     (\"while_let\", Accepted),\n@@ -128,6 +129,7 @@ pub struct Features {\n     pub visible_private_types: bool,\n     pub quote: bool,\n     pub old_orphan_check: bool,\n+    pub simd_ffi: bool,\n }\n \n impl Features {\n@@ -139,6 +141,7 @@ impl Features {\n             visible_private_types: false,\n             quote: false,\n             old_orphan_check: false,\n+            simd_ffi: false,\n         }\n     }\n }\n@@ -524,6 +527,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n         visible_private_types: cx.has_feature(\"visible_private_types\"),\n         quote: cx.has_feature(\"quote\"),\n         old_orphan_check: cx.has_feature(\"old_orphan_check\"),\n+        simd_ffi: cx.has_feature(\"simd_ffi\"),\n     },\n     unknown_features)\n }"}, {"sha": "409c85b71980413e5e03c6cc5ab16c7f56abaab4", "filename": "src/test/compile-fail/feature-gate-simd-ffi.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs?ref=89c4e3792ddc5b45706ea0e919806a248f7a87c3", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(simd)]\n+#![allow(dead_code)]\n+\n+use std::simd::f32x4;\n+\n+#[simd] #[derive(Copy)] #[repr(C)] struct LocalSimd(u8, u8);\n+\n+extern {\n+    fn foo() -> f32x4; //~ ERROR use of SIMD type\n+    fn bar(x: f32x4); //~ ERROR use of SIMD type\n+\n+    fn baz() -> LocalSimd; //~ ERROR use of SIMD type\n+    fn qux(x: LocalSimd); //~ ERROR use of SIMD type\n+}\n+\n+fn main() {}"}, {"sha": "68a6a5fbfe86425d49b1e9892427bce94c43b174", "filename": "src/test/run-make/simd-ffi/Makefile", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Ftest%2Frun-make%2Fsimd-ffi%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Ftest%2Frun-make%2Fsimd-ffi%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-ffi%2FMakefile?ref=89c4e3792ddc5b45706ea0e919806a248f7a87c3", "patch": "@@ -0,0 +1,33 @@\n+-include ../tools.mk\n+\n+# construct a fairly exhaustive list of platforms that we\n+# support. These ones don't follow a pattern\n+TARGETS=arm-linux-androideabi arm-unknown-linux-gnueabihf arm-unknown-linux-gnueabi\n+\n+# these ones do, each OS lists the architectures it supports\n+LINUX=aarch64 i686 x86_64 mips mipsel\n+WINDOWS=i686 x86_64\n+# fails with: failed to get iphonesimulator SDK path: no such file or directory\n+#IOS=i386 aarch64 armv7\n+DARWIN=i686 x86_64\n+\n+$(foreach arch,$(LINUX),$(eval TARGETS += $(arch)-unknown-linux-gnu))\n+$(foreach arch,$(WINDOWS),$(eval TARGETS += $(arch)-pc-windows-gnu))\n+#$(foreach arch,$(IOS),$(eval TARGETS += $(arch)-apple-ios))\n+$(foreach arch,$(DARWIN),$(eval TARGETS += $(arch)-apple-darwin))\n+\n+all: $(TARGETS)\n+\n+define MK_TARGETS\n+# compile the rust file to the given target, but only to asm and IR\n+# form, to avoid having to have an appropriate linker.\n+#\n+# we need some features because the integer SIMD instructions are not\n+# enabled by-default for i686 and ARM; these features will be invalid\n+# on some platforms, but LLVM just prints a warning so that's fine for\n+# now.\n+$(1): simd.rs\n+\t$$(RUSTC) --target=$(1) --emit=llvm-ir,asm simd.rs -C target-feature='+neon,+sse2'\n+endef\n+\n+$(foreach targetxxx,$(TARGETS),$(eval $(call MK_TARGETS,$(targetxxx))))"}, {"sha": "76079ddb8bd910bca3cc111905ce02db0b9e86d4", "filename": "src/test/run-make/simd-ffi/simd.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c4e3792ddc5b45706ea0e919806a248f7a87c3/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs?ref=89c4e3792ddc5b45706ea0e919806a248f7a87c3", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ensures that public symbols are not removed completely\n+#![crate_type = \"lib\"]\n+// we can compile to a variety of platforms, because we don't need\n+// cross-compiled standard libraries.\n+#![no_std]\n+\n+#![feature(simd, simd_ffi, link_llvm_intrinsics, lang_items)]\n+\n+\n+#[repr(C)]\n+#[derive(Copy)]\n+#[simd]\n+pub struct f32x4(f32, f32, f32, f32);\n+\n+\n+extern {\n+    #[link_name = \"llvm.sqrt.v4f32\"]\n+    fn vsqrt(x: f32x4) -> f32x4;\n+}\n+\n+pub fn foo(x: f32x4) -> f32x4 {\n+    unsafe {vsqrt(x)}\n+}\n+\n+#[repr(C)]\n+#[derive(Copy)]\n+#[simd]\n+pub struct i32x4(i32, i32, i32, i32);\n+\n+\n+extern {\n+    // _mm_sll_epi32\n+    #[cfg(any(target_arch = \"x86\",\n+              target_arch = \"x86-64\"))]\n+    #[link_name = \"llvm.x86.sse2.psll.d\"]\n+    fn integer(a: i32x4, b: i32x4) -> i32x4;\n+\n+    // vmaxq_s32\n+    #[cfg(any(target_arch = \"arm\"))]\n+    #[link_name = \"llvm.arm.neon.vmaxs.v4i32\"]\n+    fn integer(a: i32x4, b: i32x4) -> i32x4;\n+    // vmaxq_s32\n+    #[cfg(any(target_arch = \"aarch64\"))]\n+    #[link_name = \"llvm.aarch64.neon.maxs.v4i32\"]\n+    fn integer(a: i32x4, b: i32x4) -> i32x4;\n+\n+    // just some substitute foreign symbol, not an LLVM intrinsic; so\n+    // we still get type checking, but not as detailed as (ab)using\n+    // LLVM.\n+    #[cfg(not(any(target_arch = \"x86\",\n+                  target_arch = \"x86-64\",\n+                  target_arch = \"arm\",\n+                  target_arch = \"aarch64\")))]\n+    fn integer(a: i32x4, b: i32x4) -> i32x4;\n+}\n+\n+pub fn bar(a: i32x4, b: i32x4) -> i32x4 {\n+    unsafe {integer(a, b)}\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+mod std {\n+    pub mod marker {\n+        pub use Copy;\n+    }\n+}"}]}