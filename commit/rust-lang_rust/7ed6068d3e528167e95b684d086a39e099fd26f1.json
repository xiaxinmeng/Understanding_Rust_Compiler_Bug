{"sha": "7ed6068d3e528167e95b684d086a39e099fd26f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZDYwNjhkM2U1MjgxNjdlOTViNjg0ZDA4NmEzOWUwOTlmZDI2ZjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-17T07:06:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-17T07:06:29Z"}, "message": "Auto merge of #34789 - jonathandturner:simplify_liberror, r=alexcrichton\n\nSimplify librustc_errors\n\nThis is part 2 of the error crate refactor, starting with #34403.\n\nIn this refactor, I focused on slimming down the error crate to fewer moving parts.  As such, I've removed quite a few parts and replaced the with simpler, straight-line code.  Specifically, this PR:\n\n* Removes BasicEmitter\n* Remove emit from emitter, leaving emit_struct\n* Renames emit_struct to emit\n* Removes CoreEmitter and focuses on a single Emitter\n* Implements the latest changes to error format RFC (#1644)\n* Removes (now-unused) code in emitter.rs and snippet.rs\n* Moves more tests to the UI tester, removing some duplicate tests in the process\n\nThere is probably more that could be done with some additional refactoring, but this felt like it was getting to a good state.\n\nr? @alexcrichton   cc: @Manishearth (as there may be breaking changes in stuff I removed/changed)", "tree": {"sha": "dc1690ceec127d3d085f2bfa7dcee80b50b4b6cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc1690ceec127d3d085f2bfa7dcee80b50b4b6cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ed6068d3e528167e95b684d086a39e099fd26f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ed6068d3e528167e95b684d086a39e099fd26f1", "html_url": "https://github.com/rust-lang/rust/commit/7ed6068d3e528167e95b684d086a39e099fd26f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ed6068d3e528167e95b684d086a39e099fd26f1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34d7f7e607aec07b6db2ccd5cab42f996220e148", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d7f7e607aec07b6db2ccd5cab42f996220e148", "html_url": "https://github.com/rust-lang/rust/commit/34d7f7e607aec07b6db2ccd5cab42f996220e148"}, {"sha": "c7158a143ae639081084755038c5ce1f8c398e93", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7158a143ae639081084755038c5ce1f8c398e93", "html_url": "https://github.com/rust-lang/rust/commit/c7158a143ae639081084755038c5ce1f8c398e93"}], "stats": {"total": 3668, "additions": 1550, "deletions": 2118}, "files": [{"sha": "96ecad629f543f24d7a7e586a351e7163375b4c1", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -94,7 +94,7 @@ use syntax::ast;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::{self, Pos, Span};\n-use errors::{DiagnosticBuilder, check_old_skool};\n+use errors::{DiagnosticBuilder, check_old_school};\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n@@ -485,7 +485,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                        \"{}\",\n                                        trace.origin);\n \n-        if !is_simple_error || check_old_skool() {\n+        if !is_simple_error || check_old_school() {\n             err.note_expected_found(&\"type\", &expected, &found);\n         }\n "}, {"sha": "fa9bc7c83680c45009f1bf09f72685b38d7e1f09", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -22,7 +22,8 @@ use mir::transform as mir_pass;\n \n use syntax::ast::{NodeId, Name};\n use errors::{self, DiagnosticBuilder};\n-use errors::emitter::{Emitter, BasicEmitter, EmitterWriter};\n+use errors::emitter::{Emitter, EmitterWriter};\n+use errors::snippet::FormatMode;\n use syntax::json::JsonEmitter;\n use syntax::feature_gate;\n use syntax::parse;\n@@ -439,7 +440,7 @@ pub fn build_session_with_codemap(sopts: config::Options,\n         config::ErrorOutputType::HumanReadable(color_config) => {\n             Box::new(EmitterWriter::stderr(color_config,\n                                            Some(registry),\n-                                           codemap.clone(),\n+                                           Some(codemap.clone()),\n                                            errors::snippet::FormatMode::EnvironmentSelected))\n         }\n         config::ErrorOutputType::Json => {\n@@ -575,24 +576,32 @@ unsafe fn configure_llvm(sess: &Session) {\n }\n \n pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n-    let mut emitter: Box<Emitter> = match output {\n+    let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(BasicEmitter::stderr(color_config))\n+            Box::new(EmitterWriter::stderr(color_config,\n+                                           None,\n+                                           None,\n+                                           FormatMode::EnvironmentSelected))\n         }\n         config::ErrorOutputType::Json => Box::new(JsonEmitter::basic()),\n     };\n-    emitter.emit(&MultiSpan::new(), msg, None, errors::Level::Fatal);\n+    let handler = errors::Handler::with_emitter(true, false, emitter);\n+    handler.emit(&MultiSpan::new(), msg, errors::Level::Fatal);\n     panic!(errors::FatalError);\n }\n \n pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n-    let mut emitter: Box<Emitter> = match output {\n+    let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(BasicEmitter::stderr(color_config))\n+            Box::new(EmitterWriter::stderr(color_config,\n+                                           None,\n+                                           None,\n+                                           FormatMode::EnvironmentSelected))\n         }\n         config::ErrorOutputType::Json => Box::new(JsonEmitter::basic()),\n     };\n-    emitter.emit(&MultiSpan::new(), msg, None, errors::Level::Warning);\n+    let handler = errors::Handler::with_emitter(true, false, emitter);\n+    handler.emit(&MultiSpan::new(), msg, errors::Level::Warning);\n }\n \n // Err(0) means compilation was stopped, but no errors were found."}, {"sha": "0a8df923b846b90f2b4783a822fa7471f2497ef4", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -100,6 +100,7 @@ use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n use syntax_pos::MultiSpan;\n use errors::emitter::Emitter;\n+use errors::snippet::FormatMode;\n \n #[cfg(test)]\n pub mod test;\n@@ -138,10 +139,15 @@ pub fn run(args: Vec<String>) -> isize {\n                 match session {\n                     Some(sess) => sess.fatal(&abort_msg(err_count)),\n                     None => {\n-                        let mut emitter =\n-                            errors::emitter::BasicEmitter::stderr(errors::ColorConfig::Auto);\n-                        emitter.emit(&MultiSpan::new(), &abort_msg(err_count), None,\n-                            errors::Level::Fatal);\n+                        let emitter =\n+                            errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n+                                                                   None,\n+                                                                   None,\n+                                                                   FormatMode::EnvironmentSelected);\n+                        let handler = errors::Handler::with_emitter(true, false, Box::new(emitter));\n+                        handler.emit(&MultiSpan::new(),\n+                                     &abort_msg(err_count),\n+                                     errors::Level::Fatal);\n                         exit_on_err();\n                     }\n                 }\n@@ -373,23 +379,26 @@ fn handle_explain(code: &str,\n \n fn check_cfg(sopts: &config::Options,\n              output: ErrorOutputType) {\n-    let mut emitter: Box<Emitter> = match output {\n+    let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(errors::emitter::BasicEmitter::stderr(color_config))\n+            Box::new(errors::emitter::EmitterWriter::stderr(color_config,\n+                                                            None,\n+                                                            None,\n+                                                            FormatMode::EnvironmentSelected))\n         }\n         config::ErrorOutputType::Json => Box::new(json::JsonEmitter::basic()),\n     };\n+    let handler = errors::Handler::with_emitter(true, false, emitter);\n \n     let mut saw_invalid_predicate = false;\n     for item in sopts.cfg.iter() {\n         match item.node {\n             ast::MetaItemKind::List(ref pred, _) => {\n                 saw_invalid_predicate = true;\n-                emitter.emit(&MultiSpan::new(),\n+                handler.emit(&MultiSpan::new(),\n                              &format!(\"invalid predicate in --cfg command line argument: `{}`\",\n                                       pred),\n-                             None,\n-                             errors::Level::Fatal);\n+                                errors::Level::Fatal);\n             }\n             _ => {},\n         }\n@@ -1046,26 +1055,34 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n      if let Err(value) = thread.unwrap().join() {\n         // Thread panicked without emitting a fatal diagnostic\n         if !value.is::<errors::FatalError>() {\n-            let mut emitter = errors::emitter::BasicEmitter::stderr(errors::ColorConfig::Auto);\n+            let emitter =\n+                Box::new(errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n+                                                       None,\n+                                                       None,\n+                                                       FormatMode::EnvironmentSelected));\n+            let handler = errors::Handler::with_emitter(true, false, emitter);\n \n             // a .span_bug or .bug call has already printed what\n             // it wants to print.\n             if !value.is::<errors::ExplicitBug>() {\n-                emitter.emit(&MultiSpan::new(), \"unexpected panic\", None, errors::Level::Bug);\n+                handler.emit(&MultiSpan::new(),\n+                             \"unexpected panic\",\n+                             errors::Level::Bug);\n             }\n \n             let xs = [\"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n                       format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL)];\n             for note in &xs {\n-                emitter.emit(&MultiSpan::new(), &note[..], None, errors::Level::Note)\n+                handler.emit(&MultiSpan::new(),\n+                             &note[..],\n+                             errors::Level::Note);\n             }\n             if match env::var_os(\"RUST_BACKTRACE\") {\n                 Some(val) => &val != \"0\",\n                 None => false,\n             } {\n-                emitter.emit(&MultiSpan::new(),\n+                handler.emit(&MultiSpan::new(),\n                              \"run with `RUST_BACKTRACE=1` for a backtrace\",\n-                             None,\n                              errors::Level::Note);\n             }\n "}, {"sha": "39763bfa0eb61c6d279054166cf57eaeab03de87", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -33,8 +33,8 @@ use syntax::ast;\n use syntax::abi::Abi;\n use syntax::codemap::CodeMap;\n use errors;\n-use errors::emitter::{CoreEmitter, Emitter};\n-use errors::{Level, RenderSpan};\n+use errors::emitter::Emitter;\n+use errors::{Level, DiagnosticBuilder};\n use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n use syntax_pos::DUMMY_SP;\n@@ -76,15 +76,12 @@ fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n     }\n }\n \n-impl CoreEmitter for ExpectErrorEmitter {\n-    fn emit_message(&mut self,\n-                    _sp: &RenderSpan,\n-                    msg: &str,\n-                    _: Option<&str>,\n-                    lvl: Level,\n-                    _is_header: bool,\n-                    _show_snippet: bool) {\n-        remove_message(self, msg, lvl);\n+impl Emitter for ExpectErrorEmitter {\n+    fn emit(&mut self, db: &DiagnosticBuilder) {\n+        remove_message(self, &db.message, db.level);\n+        for child in &db.children {\n+            remove_message(self, &child.message, child.level);\n+        }\n     }\n }\n "}, {"sha": "893f8a6e4ddb01b4a09963ec5afe445964d81cc1", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 819, "deletions": 377, "changes": 1196, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -10,89 +10,40 @@\n \n use self::Destination::*;\n \n-use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, Span, MultiSpan, LineInfo};\n+use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, LineInfo, CharPos};\n use registry;\n \n-use check_old_skool;\n-use {Level, RenderSpan, CodeSuggestion, DiagnosticBuilder, CodeMapper};\n+use check_old_school;\n+use {Level, CodeSuggestion, DiagnosticBuilder, CodeMapper};\n use RenderSpan::*;\n-use Level::*;\n-use snippet::{RenderedLineKind, SnippetData, Style, FormatMode};\n+use snippet::{StyledString, Style, FormatMode, Annotation, Line};\n+use styled_buffer::StyledBuffer;\n \n-use std::{cmp, fmt};\n+use std::cmp;\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use term;\n \n-/// Emitter trait for emitting errors. Do not implement this directly:\n-/// implement `CoreEmitter` instead.\n+/// Emitter trait for emitting errors.\n pub trait Emitter {\n-    /// Emit a standalone diagnostic message.\n-    fn emit(&mut self, span: &MultiSpan, msg: &str, code: Option<&str>, lvl: Level);\n-\n     /// Emit a structured diagnostic.\n-    fn emit_struct(&mut self, db: &DiagnosticBuilder);\n-}\n-\n-pub trait CoreEmitter {\n-    fn emit_message(&mut self,\n-                    rsp: &RenderSpan,\n-                    msg: &str,\n-                    code: Option<&str>,\n-                    lvl: Level,\n-                    is_header: bool,\n-                    show_snippet: bool);\n+    fn emit(&mut self, db: &DiagnosticBuilder);\n }\n \n-impl<T: CoreEmitter> Emitter for T {\n-    fn emit(&mut self,\n-            msp: &MultiSpan,\n-            msg: &str,\n-            code: Option<&str>,\n-            lvl: Level) {\n-        self.emit_message(&FullSpan(msp.clone()),\n-                          msg,\n-                          code,\n-                          lvl,\n-                          true,\n-                          true);\n-    }\n+impl Emitter for EmitterWriter {\n+    fn emit(&mut self, db: &DiagnosticBuilder) {\n+        // Pick old school mode either from env or let the test dictate the format\n+        let old_school = match self.format_mode {\n+            FormatMode::NewErrorFormat => false,\n+            FormatMode::OriginalErrorFormat => true,\n+            FormatMode::EnvironmentSelected => check_old_school()\n+        };\n \n-    fn emit_struct(&mut self, db: &DiagnosticBuilder) {\n-        let old_school = check_old_skool();\n-        let db_span = FullSpan(db.span.clone());\n-        self.emit_message(&FullSpan(db.span.clone()),\n-                          &db.message,\n-                          db.code.as_ref().map(|s| &**s),\n-                          db.level,\n-                          true,\n-                          true);\n-        for child in &db.children {\n-            let render_span = child.render_span\n-                                   .clone()\n-                                   .unwrap_or_else(\n-                                       || FullSpan(child.span.clone()));\n-\n-            if !old_school {\n-                self.emit_message(&render_span,\n-                                    &child.message,\n-                                    None,\n-                                    child.level,\n-                                    false,\n-                                    true);\n-            } else {\n-                let (render_span, show_snippet) = match render_span.span().primary_span() {\n-                    None => (db_span.clone(), false),\n-                    _ => (render_span, true)\n-                };\n-                self.emit_message(&render_span,\n-                                    &child.message,\n-                                    None,\n-                                    child.level,\n-                                    false,\n-                                    show_snippet);\n-            }\n+        if old_school {\n+            self.emit_messages_old_school(db);\n+        } else {\n+            self.emit_messages_default(db);\n         }\n     }\n }\n@@ -117,66 +68,21 @@ impl ColorConfig {\n     }\n }\n \n-/// A basic emitter for when we don't have access to a codemap or registry. Used\n-/// for reporting very early errors, etc.\n-pub struct BasicEmitter {\n-    dst: Destination,\n-}\n-\n-impl CoreEmitter for BasicEmitter {\n-    fn emit_message(&mut self,\n-                    _rsp: &RenderSpan,\n-                    msg: &str,\n-                    code: Option<&str>,\n-                    lvl: Level,\n-                    _is_header: bool,\n-                    _show_snippet: bool) {\n-        // we ignore the span as we have no access to a codemap at this point\n-        if let Err(e) = print_diagnostic(&mut self.dst, \"\", lvl, msg, code) {\n-            panic!(\"failed to print diagnostics: {:?}\", e);\n-        }\n-    }\n-}\n-\n-impl BasicEmitter {\n-    pub fn stderr(color_config: ColorConfig) -> BasicEmitter {\n-        if color_config.use_color() {\n-            let dst = Destination::from_stderr();\n-            BasicEmitter { dst: dst }\n-        } else {\n-            BasicEmitter { dst: Raw(Box::new(io::stderr())) }\n-        }\n-    }\n-}\n-\n pub struct EmitterWriter {\n     dst: Destination,\n     registry: Option<registry::Registry>,\n-    cm: Rc<CodeMapper>,\n-\n-    /// Is this the first error emitted thus far? If not, we emit a\n-    /// `\\n` before the top-level errors.\n-    first: bool,\n+    cm: Option<Rc<CodeMapper>>,\n \n     // For now, allow an old-school mode while we transition\n     format_mode: FormatMode\n }\n \n-impl CoreEmitter for EmitterWriter {\n-    fn emit_message(&mut self,\n-                    rsp: &RenderSpan,\n-                    msg: &str,\n-                    code: Option<&str>,\n-                    lvl: Level,\n-                    is_header: bool,\n-                    show_snippet: bool) {\n-        match self.emit_message_(rsp, msg, code, lvl, is_header, show_snippet) {\n-            Ok(()) => { }\n-            Err(e) => panic!(\"failed to emit error: {}\", e)\n-        }\n-    }\n+struct FileWithAnnotatedLines {\n+    file: Rc<FileMap>,\n+    lines: Vec<Line>,\n }\n \n+\n /// Do not use this for messages that end in `\\n` \u2013 use `println_maybe_styled` instead. See\n /// `EmitterWriter::print_maybe_styled` for details.\n macro_rules! print_maybe_styled {\n@@ -194,256 +100,862 @@ macro_rules! println_maybe_styled {\n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig,\n                   registry: Option<registry::Registry>,\n-                  code_map: Rc<CodeMapper>,\n+                  code_map: Option<Rc<CodeMapper>>,\n                   format_mode: FormatMode)\n                   -> EmitterWriter {\n         if color_config.use_color() {\n             let dst = Destination::from_stderr();\n             EmitterWriter { dst: dst,\n                             registry: registry,\n                             cm: code_map,\n-                            first: true,\n                             format_mode: format_mode.clone() }\n         } else {\n             EmitterWriter { dst: Raw(Box::new(io::stderr())),\n                             registry: registry,\n                             cm: code_map,\n-                            first: true,\n                             format_mode: format_mode.clone() }\n         }\n     }\n \n     pub fn new(dst: Box<Write + Send>,\n                registry: Option<registry::Registry>,\n-               code_map: Rc<CodeMapper>,\n+               code_map: Option<Rc<CodeMapper>>,\n                format_mode: FormatMode)\n                -> EmitterWriter {\n         EmitterWriter { dst: Raw(dst),\n                         registry: registry,\n                         cm: code_map,\n-                        first: true,\n                         format_mode: format_mode.clone() }\n     }\n \n-    fn emit_message_(&mut self,\n-                     rsp: &RenderSpan,\n-                     msg: &str,\n-                     code: Option<&str>,\n-                     lvl: Level,\n-                     is_header: bool,\n-                     show_snippet: bool)\n-                     -> io::Result<()> {\n-        let old_school = match self.format_mode {\n-            FormatMode::NewErrorFormat => false,\n-            FormatMode::OriginalErrorFormat => true,\n-            FormatMode::EnvironmentSelected => check_old_skool()\n-        };\n+    fn preprocess_annotations(&self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n+        fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n+                                    file: Rc<FileMap>,\n+                                    line_index: usize,\n+                                    ann: Annotation) {\n+\n+            for slot in file_vec.iter_mut() {\n+                // Look through each of our files for the one we're adding to\n+                if slot.file.name == file.name {\n+                    // See if we already have a line for it\n+                    for line_slot in &mut slot.lines {\n+                        if line_slot.line_index == line_index {\n+                            line_slot.annotations.push(ann);\n+                            return;\n+                        }\n+                    }\n+                    // We don't have a line yet, create one\n+                    slot.lines.push(Line {\n+                        line_index: line_index,\n+                        annotations: vec![ann],\n+                    });\n+                    slot.lines.sort();\n+                    return;\n+                }\n+            }\n+            // This is the first time we're seeing the file\n+            file_vec.push(FileWithAnnotatedLines {\n+                file: file,\n+                lines: vec![Line {\n+                                line_index: line_index,\n+                                annotations: vec![ann],\n+                            }],\n+            });\n+        }\n+\n+        let mut output = vec![];\n+\n+        if let Some(ref cm) = self.cm {\n+            for span_label in msp.span_labels() {\n+                if span_label.span == DUMMY_SP || span_label.span == COMMAND_LINE_SP {\n+                    continue;\n+                }\n+                let lo = cm.lookup_char_pos(span_label.span.lo);\n+                let mut hi = cm.lookup_char_pos(span_label.span.hi);\n+                let mut is_minimized = false;\n+\n+                // If the span is multi-line, simplify down to the span of one character\n+                if lo.line != hi.line {\n+                    hi.line = lo.line;\n+                    hi.col = CharPos(lo.col.0 + 1);\n+                    is_minimized = true;\n+                }\n \n-        if is_header {\n-            if self.first {\n-                self.first = false;\n+                // Watch out for \"empty spans\". If we get a span like 6..6, we\n+                // want to just display a `^` at 6, so convert that to\n+                // 6..7. This is degenerate input, but it's best to degrade\n+                // gracefully -- and the parser likes to supply a span like\n+                // that for EOF, in particular.\n+                if lo.col == hi.col {\n+                    hi.col = CharPos(lo.col.0 + 1);\n+                }\n+\n+                add_annotation_to_file(&mut output,\n+                                        lo.file,\n+                                        lo.line,\n+                                        Annotation {\n+                                            start_col: lo.col.0,\n+                                            end_col: hi.col.0,\n+                                            is_primary: span_label.is_primary,\n+                                            is_minimized: is_minimized,\n+                                            label: span_label.label.clone(),\n+                                        });\n+            }\n+        }\n+        output\n+    }\n+\n+    fn render_source_line(&self,\n+                          buffer: &mut StyledBuffer,\n+                          file: Rc<FileMap>,\n+                          line: &Line,\n+                          width_offset: usize) {\n+        let source_string = file.get_line(line.line_index - 1)\n+            .unwrap_or(\"\");\n+\n+        let line_offset = buffer.num_lines();\n+\n+        // First create the source line we will highlight.\n+        buffer.puts(line_offset, width_offset, &source_string, Style::Quotation);\n+        buffer.puts(line_offset,\n+                    0,\n+                    &(line.line_index.to_string()),\n+                    Style::LineNumber);\n+\n+        draw_col_separator(buffer, line_offset, width_offset - 2);\n+\n+        if line.annotations.is_empty() {\n+            return;\n+        }\n+\n+        // We want to display like this:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      ---      ^^^               _ previous borrow ends here\n+        //      |        |\n+        //      |        error occurs here\n+        //      previous borrow of `vec` occurs here\n+        //\n+        // But there are some weird edge cases to be aware of:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      --------                    - previous borrow ends here\n+        //      ||\n+        //      |this makes no sense\n+        //      previous borrow of `vec` occurs here\n+        //\n+        // For this reason, we group the lines into \"highlight lines\"\n+        // and \"annotations lines\", where the highlight lines have the `~`.\n+\n+        // Sort the annotations by (start, end col)\n+        let mut annotations = line.annotations.clone();\n+        annotations.sort();\n+\n+        // Next, create the highlight line.\n+        for annotation in &annotations {\n+            for p in annotation.start_col..annotation.end_col {\n+                if annotation.is_primary {\n+                    buffer.putc(line_offset + 1,\n+                                width_offset + p,\n+                                '^',\n+                                Style::UnderlinePrimary);\n+                    if !annotation.is_minimized {\n+                        buffer.set_style(line_offset,\n+                                            width_offset + p,\n+                                            Style::UnderlinePrimary);\n+                    }\n+                } else {\n+                    buffer.putc(line_offset + 1,\n+                                width_offset + p,\n+                                '-',\n+                                Style::UnderlineSecondary);\n+                    if !annotation.is_minimized {\n+                        buffer.set_style(line_offset,\n+                                            width_offset + p,\n+                                            Style::UnderlineSecondary);\n+                    }\n+                }\n+            }\n+        }\n+        draw_col_separator(buffer, line_offset + 1, width_offset - 2);\n+\n+        // Now we are going to write labels in. To start, we'll exclude\n+        // the annotations with no labels.\n+        let (labeled_annotations, unlabeled_annotations): (Vec<_>, _) = annotations.into_iter()\n+            .partition(|a| a.label.is_some());\n+\n+        // If there are no annotations that need text, we're done.\n+        if labeled_annotations.is_empty() {\n+            return;\n+        }\n+        // Now add the text labels. We try, when possible, to stick the rightmost\n+        // annotation at the end of the highlight line:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      ---      ---               - previous borrow ends here\n+        //\n+        // But sometimes that's not possible because one of the other\n+        // annotations overlaps it. For example, from the test\n+        // `span_overlap_label`, we have the following annotations\n+        // (written on distinct lines for clarity):\n+        //\n+        //      fn foo(x: u32) {\n+        //      --------------\n+        //             -\n+        //\n+        // In this case, we can't stick the rightmost-most label on\n+        // the highlight line, or we would get:\n+        //\n+        //      fn foo(x: u32) {\n+        //      -------- x_span\n+        //      |\n+        //      fn_span\n+        //\n+        // which is totally weird. Instead we want:\n+        //\n+        //      fn foo(x: u32) {\n+        //      --------------\n+        //      |      |\n+        //      |      x_span\n+        //      fn_span\n+        //\n+        // which is...less weird, at least. In fact, in general, if\n+        // the rightmost span overlaps with any other span, we should\n+        // use the \"hang below\" version, so we can at least make it\n+        // clear where the span *starts*.\n+        let mut labeled_annotations = &labeled_annotations[..];\n+        match labeled_annotations.split_last().unwrap() {\n+            (last, previous) => {\n+                if previous.iter()\n+                    .chain(&unlabeled_annotations)\n+                    .all(|a| !overlaps(a, last)) {\n+                    // append the label afterwards; we keep it in a separate\n+                    // string\n+                    let highlight_label: String = format!(\" {}\", last.label.as_ref().unwrap());\n+                    if last.is_primary {\n+                        buffer.append(line_offset + 1, &highlight_label, Style::LabelPrimary);\n+                    } else {\n+                        buffer.append(line_offset + 1, &highlight_label, Style::LabelSecondary);\n+                    }\n+                    labeled_annotations = previous;\n+                }\n+            }\n+        }\n+\n+        // If that's the last annotation, we're done\n+        if labeled_annotations.is_empty() {\n+            return;\n+        }\n+\n+        for (index, annotation) in labeled_annotations.iter().enumerate() {\n+            // Leave:\n+            // - 1 extra line\n+            // - One line for each thing that comes after\n+            let comes_after = labeled_annotations.len() - index - 1;\n+            let blank_lines = 3 + comes_after;\n+\n+            // For each blank line, draw a `|` at our column. The\n+            // text ought to be long enough for this.\n+            for index in 2..blank_lines {\n+                if annotation.is_primary {\n+                    buffer.putc(line_offset + index,\n+                                width_offset + annotation.start_col,\n+                                '|',\n+                                Style::UnderlinePrimary);\n+                } else {\n+                    buffer.putc(line_offset + index,\n+                                width_offset + annotation.start_col,\n+                                '|',\n+                                Style::UnderlineSecondary);\n+                }\n+                draw_col_separator(buffer, line_offset + index, width_offset - 2);\n+            }\n+\n+            if annotation.is_primary {\n+                buffer.puts(line_offset + blank_lines,\n+                            width_offset + annotation.start_col,\n+                            annotation.label.as_ref().unwrap(),\n+                            Style::LabelPrimary);\n             } else {\n-                if !old_school {\n-                    write!(self.dst, \"\\n\")?;\n+                buffer.puts(line_offset + blank_lines,\n+                            width_offset + annotation.start_col,\n+                            annotation.label.as_ref().unwrap(),\n+                            Style::LabelSecondary);\n+            }\n+            draw_col_separator(buffer, line_offset + blank_lines, width_offset - 2);\n+        }\n+    }\n+\n+    fn get_multispan_max_line_num(&mut self, msp: &MultiSpan) -> usize {\n+        let mut max = 0;\n+        if let Some(ref cm) = self.cm {\n+            for primary_span in msp.primary_spans() {\n+                if primary_span != &DUMMY_SP && primary_span != &COMMAND_LINE_SP {\n+                    let hi = cm.lookup_char_pos(primary_span.hi);\n+                    if hi.line > max {\n+                        max = hi.line;\n+                    }\n+                }\n+            }\n+            for span_label in msp.span_labels() {\n+                if span_label.span != DUMMY_SP && span_label.span != COMMAND_LINE_SP {\n+                    let hi = cm.lookup_char_pos(span_label.span.hi);\n+                    if hi.line > max {\n+                        max = hi.line;\n+                    }\n+                }\n+            }\n+        }\n+        max\n+    }\n+\n+    fn get_max_line_num(&mut self, db: &DiagnosticBuilder) -> usize {\n+        let mut max = 0;\n+\n+        let primary = self.get_multispan_max_line_num(&db.span);\n+        max = if primary > max { primary } else { max };\n+\n+        for sub in &db.children {\n+            let sub_result = self.get_multispan_max_line_num(&sub.span);\n+            max = if sub_result > max { primary } else { max };\n+        }\n+        max\n+    }\n+\n+    fn emit_message_default(&mut self,\n+                            msp: &MultiSpan,\n+                            msg: &str,\n+                            code: &Option<String>,\n+                            level: &Level,\n+                            max_line_num_len: usize,\n+                            is_secondary: bool)\n+                            -> io::Result<()> {\n+        let mut buffer = StyledBuffer::new();\n+\n+        if msp.primary_spans().is_empty() && msp.span_labels().is_empty() && is_secondary {\n+            // This is a secondary message with no span info\n+            for _ in 0..max_line_num_len {\n+                buffer.prepend(0, \" \", Style::NoStyle);\n+            }\n+            draw_note_separator(&mut buffer, 0, max_line_num_len + 1);\n+            buffer.append(0, &level.to_string(), Style::HeaderMsg);\n+            buffer.append(0, \": \", Style::NoStyle);\n+            buffer.append(0, msg, Style::NoStyle);\n+        }\n+        else {\n+            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+            match code {\n+                &Some(ref code) => {\n+                    buffer.append(0, \"[\", Style::Level(level.clone()));\n+                    buffer.append(0, &code, Style::Level(level.clone()));\n+                    buffer.append(0, \"]\", Style::Level(level.clone()));\n                 }\n+                _ => {}\n             }\n+            buffer.append(0, \": \", Style::HeaderMsg);\n+            buffer.append(0, msg, Style::HeaderMsg);\n         }\n \n-        match code {\n-            Some(code) if self.registry.as_ref()\n-                                       .and_then(|registry| registry.find_description(code))\n-                                       .is_some() => {\n-                let code_with_explain = String::from(\"--explain \") + code;\n-                if old_school {\n-                    let loc = match rsp.span().primary_span() {\n-                        Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n-                        Some(ps) => self.cm.span_to_string(ps),\n-                        None => \"\".to_string()\n-                    };\n-                    print_diagnostic(&mut self.dst, &loc, lvl, msg, Some(code))?\n+        // Preprocess all the annotations so that they are grouped by file and by line number\n+        // This helps us quickly iterate over the whole message (including secondary file spans)\n+        let mut annotated_files = self.preprocess_annotations(msp);\n+\n+        // Make sure our primary file comes first\n+        let primary_lo =\n+            if let (Some(ref cm), Some(ref primary_span)) = (self.cm.as_ref(),\n+                                                             msp.primary_span().as_ref()) {\n+                if primary_span != &&DUMMY_SP && primary_span != &&COMMAND_LINE_SP {\n+                    cm.lookup_char_pos(primary_span.lo)\n                 }\n                 else {\n-                    print_diagnostic(&mut self.dst, \"\", lvl, msg, Some(&code_with_explain))?\n+                    emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+                    return Ok(());\n+                }\n+            } else {\n+                // If we don't have span information, emit and exit\n+                emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+                return Ok(());\n+            };\n+        if let Ok(pos) =\n+                annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name)) {\n+            annotated_files.swap(0, pos);\n+        }\n+\n+        // Print out the annotate source lines that correspond with the error\n+        for annotated_file in annotated_files {\n+            // print out the span location and spacer before we print the annotated source\n+            // to do this, we need to know if this span will be primary\n+            let is_primary = primary_lo.file.name == annotated_file.file.name;\n+            if is_primary {\n+                // remember where we are in the output buffer for easy reference\n+                let buffer_msg_line_offset = buffer.num_lines();\n+\n+                buffer.prepend(buffer_msg_line_offset, \"--> \", Style::LineNumber);\n+                let loc = primary_lo.clone();\n+                buffer.append(buffer_msg_line_offset,\n+                                &format!(\"{}:{}:{}\", loc.file.name, loc.line, loc.col.0 + 1),\n+                                Style::LineAndColumn);\n+                for _ in 0..max_line_num_len {\n+                    buffer.prepend(buffer_msg_line_offset, \" \", Style::NoStyle);\n+                }\n+            } else {\n+                // remember where we are in the output buffer for easy reference\n+                let buffer_msg_line_offset = buffer.num_lines();\n+\n+                // Add spacing line\n+                draw_col_separator(&mut buffer, buffer_msg_line_offset, max_line_num_len + 1);\n+\n+                // Then, the secondary file indicator\n+                buffer.prepend(buffer_msg_line_offset + 1, \"::: \", Style::LineNumber);\n+                buffer.append(buffer_msg_line_offset + 1,\n+                                &annotated_file.file.name,\n+                                Style::LineAndColumn);\n+                for _ in 0..max_line_num_len {\n+                    buffer.prepend(buffer_msg_line_offset + 1, \" \", Style::NoStyle);\n                 }\n             }\n-            _ => {\n-                if old_school {\n-                    let loc = match rsp.span().primary_span() {\n-                        Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n-                        Some(ps) => self.cm.span_to_string(ps),\n-                        None => \"\".to_string()\n-                    };\n-                    print_diagnostic(&mut self.dst, &loc, lvl, msg, code)?\n+\n+            // Put in the spacer between the location and annotated source\n+            let buffer_msg_line_offset = buffer.num_lines();\n+            draw_col_separator_no_space(&mut buffer, buffer_msg_line_offset, max_line_num_len + 1);\n+\n+            // Next, output the annotate source for this file\n+            for line_idx in 0..annotated_file.lines.len() {\n+                self.render_source_line(&mut buffer,\n+                                        annotated_file.file.clone(),\n+                                        &annotated_file.lines[line_idx],\n+                                        3 + max_line_num_len);\n+\n+                // check to see if we need to print out or elide lines that come between\n+                // this annotated line and the next one\n+                if line_idx < (annotated_file.lines.len() - 1) {\n+                    let line_idx_delta = annotated_file.lines[line_idx + 1].line_index -\n+                                            annotated_file.lines[line_idx].line_index;\n+                    if line_idx_delta > 2 {\n+                        let last_buffer_line_num = buffer.num_lines();\n+                        buffer.puts(last_buffer_line_num, 0, \"...\", Style::LineNumber);\n+                    } else if line_idx_delta == 2 {\n+                        let unannotated_line = annotated_file.file\n+                            .get_line(annotated_file.lines[line_idx].line_index)\n+                            .unwrap_or(\"\");\n+\n+                        let last_buffer_line_num = buffer.num_lines();\n+\n+                        buffer.puts(last_buffer_line_num,\n+                                    0,\n+                                    &(annotated_file.lines[line_idx + 1].line_index - 1)\n+                                        .to_string(),\n+                                    Style::LineNumber);\n+                        draw_col_separator(&mut buffer, last_buffer_line_num, 1 + max_line_num_len);\n+                        buffer.puts(last_buffer_line_num,\n+                                    3 + max_line_num_len,\n+                                    &unannotated_line,\n+                                    Style::Quotation);\n+                    }\n                 }\n-                else {\n-                    print_diagnostic(&mut self.dst, \"\", lvl, msg, code)?\n+            }\n+        }\n+\n+        if let Some(ref primary_span) = msp.primary_span().as_ref() {\n+            self.render_macro_backtrace_old_school(primary_span, &mut buffer)?;\n+        }\n+\n+        // final step: take our styled buffer, render it, then output it\n+        emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+\n+        Ok(())\n+    }\n+    fn emit_suggestion_default(&mut self,\n+                               suggestion: &CodeSuggestion,\n+                               level: &Level,\n+                               msg: &str,\n+                               max_line_num_len: usize)\n+                               -> io::Result<()> {\n+        use std::borrow::Borrow;\n+\n+        let primary_span = suggestion.msp.primary_span().unwrap();\n+        if let Some(ref cm) = self.cm {\n+            let mut buffer = StyledBuffer::new();\n+\n+            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+            buffer.append(0, \": \", Style::HeaderMsg);\n+            buffer.append(0, msg, Style::HeaderMsg);\n+\n+            let lines = cm.span_to_lines(primary_span).unwrap();\n+\n+            assert!(!lines.lines.is_empty());\n+\n+            let complete = suggestion.splice_lines(cm.borrow());\n+\n+            // print the suggestion without any line numbers, but leave\n+            // space for them. This helps with lining up with previous\n+            // snippets from the actual error being reported.\n+            let mut lines = complete.lines();\n+            let mut row_num = 1;\n+            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n+                draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n+                buffer.append(row_num, line, Style::NoStyle);\n+                row_num += 1;\n+            }\n+\n+            // if we elided some lines, add an ellipsis\n+            if let Some(_) = lines.next() {\n+                buffer.append(row_num, \"...\", Style::NoStyle);\n+            }\n+            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+        }\n+        Ok(())\n+    }\n+    fn emit_messages_default(&mut self, db: &DiagnosticBuilder) {\n+        let max_line_num = self.get_max_line_num(db);\n+        let max_line_num_len = max_line_num.to_string().len();\n+\n+        match self.emit_message_default(&db.span,\n+                                        &db.message,\n+                                        &db.code,\n+                                        &db.level,\n+                                        max_line_num_len,\n+                                        false) {\n+            Ok(()) => {\n+                if !db.children.is_empty() {\n+                    let mut buffer = StyledBuffer::new();\n+                    draw_col_separator_no_space(&mut buffer, 0, max_line_num_len + 1);\n+                    match emit_to_destination(&buffer.render(), &db.level, &mut self.dst) {\n+                        Ok(()) => (),\n+                        Err(e) => panic!(\"failed to emit error: {}\", e)\n+                    }\n+                }\n+                for child in &db.children {\n+                    match child.render_span {\n+                        Some(FullSpan(ref msp)) => {\n+                            match self.emit_message_default(msp,\n+                                                            &child.message,\n+                                                            &None,\n+                                                            &child.level,\n+                                                            max_line_num_len,\n+                                                            true) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        },\n+                        Some(Suggestion(ref cs)) => {\n+                            match self.emit_suggestion_default(cs,\n+                                                               &child.level,\n+                                                               &child.message,\n+                                                               max_line_num_len) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        },\n+                        None => {\n+                            match self.emit_message_default(&child.span,\n+                                                            &child.message,\n+                                                            &None,\n+                                                            &child.level,\n+                                                            max_line_num_len,\n+                                                            true) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        }\n+                    }\n                 }\n             }\n+            Err(e) => panic!(\"failed to emit error: {}\", e)\n+        }\n+        match write!(&mut self.dst, \"\\n\") {\n+            Err(e) => panic!(\"failed to emit error: {}\", e),\n+            _ => ()\n+        }\n+    }\n+    fn emit_message_old_school(&mut self,\n+                               msp: &MultiSpan,\n+                               msg: &str,\n+                               code: &Option<String>,\n+                               level: &Level,\n+                               show_snippet: bool)\n+                               -> io::Result<()> {\n+        let mut buffer = StyledBuffer::new();\n+\n+        let loc = match msp.primary_span() {\n+            Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n+            Some(ps) => if let Some(ref cm) = self.cm {\n+                cm.span_to_string(ps)\n+            } else {\n+                \"\".to_string()\n+            },\n+            None => {\n+                \"\".to_string()\n+            }\n+        };\n+        if loc != \"\" {\n+            buffer.append(0, &loc, Style::NoStyle);\n+            buffer.append(0, \" \", Style::NoStyle);\n+        }\n+        buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+        buffer.append(0, \": \", Style::HeaderMsg);\n+        buffer.append(0, msg, Style::HeaderMsg);\n+        buffer.append(0, \" \", Style::NoStyle);\n+        match code {\n+            &Some(ref code) => {\n+                buffer.append(0, \"[\", Style::ErrorCode);\n+                buffer.append(0, &code, Style::ErrorCode);\n+                buffer.append(0, \"]\", Style::ErrorCode);\n+            }\n+            _ => {}\n         }\n \n         if !show_snippet {\n+            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n             return Ok(());\n         }\n \n         // Watch out for various nasty special spans; don't try to\n         // print any filename or anything for those.\n-        match rsp.span().primary_span() {\n+        match msp.primary_span() {\n             Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => {\n+                emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n                 return Ok(());\n             }\n             _ => { }\n         }\n \n-        // Otherwise, print out the snippet etc as needed.\n-        match *rsp {\n-            FullSpan(ref msp) => {\n-                self.highlight_lines(msp, lvl)?;\n-                if let Some(primary_span) = msp.primary_span() {\n-                    self.print_macro_backtrace(primary_span)?;\n-                }\n-            }\n-            Suggestion(ref suggestion) => {\n-                self.highlight_suggestion(suggestion)?;\n-                if let Some(primary_span) = rsp.span().primary_span() {\n-                    self.print_macro_backtrace(primary_span)?;\n+        let annotated_files = self.preprocess_annotations(msp);\n+\n+        if let (Some(ref cm), Some(ann_file), Some(ref primary_span)) =\n+            (self.cm.as_ref(), annotated_files.first(), msp.primary_span().as_ref()) {\n+\n+            // Next, print the source line and its squiggle\n+            // for old school mode, we will render them to the buffer, then insert the file loc\n+            // (or space the same amount) in front of the line and the squiggle\n+            let source_string = ann_file.file.get_line(ann_file.lines[0].line_index - 1)\n+                .unwrap_or(\"\");\n+\n+            let line_offset = buffer.num_lines();\n+\n+            let lo = cm.lookup_char_pos(primary_span.lo);\n+            //Before each secondary line in old skool-mode, print the label\n+            //as an old-style note\n+            let file_pos = format!(\"{}:{} \", lo.file.name.clone(), lo.line);\n+            let file_pos_len = file_pos.len();\n+\n+            // First create the source line we will highlight.\n+            buffer.puts(line_offset, 0, &file_pos, Style::FileNameStyle);\n+            buffer.puts(line_offset, file_pos_len, &source_string, Style::Quotation);\n+            // Sort the annotations by (start, end col)\n+            let annotations = ann_file.lines[0].annotations.clone();\n+\n+            // Next, create the highlight line.\n+            for annotation in &annotations {\n+                for p in annotation.start_col..annotation.end_col {\n+                    if p == annotation.start_col {\n+                        buffer.putc(line_offset + 1,\n+                                    file_pos_len + p,\n+                                    '^',\n+                                    if annotation.is_primary {\n+                                        Style::UnderlinePrimary\n+                                    } else {\n+                                        Style::OldSchoolNote\n+                                    });\n+                    } else {\n+                        buffer.putc(line_offset + 1,\n+                                    file_pos_len + p,\n+                                    '~',\n+                                    if annotation.is_primary {\n+                                        Style::UnderlinePrimary\n+                                    } else {\n+                                        Style::OldSchoolNote\n+                                    });\n+                    }\n                 }\n             }\n         }\n-        if old_school {\n-            match code {\n-                Some(code) if self.registry.as_ref()\n-                                        .and_then(|registry| registry.find_description(code))\n-                                        .is_some() => {\n-                    let loc = match rsp.span().primary_span() {\n-                        Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n-                        Some(ps) => self.cm.span_to_string(ps),\n-                        None => \"\".to_string()\n-                    };\n-                    let msg = \"run `rustc --explain \".to_string() + &code.to_string() +\n-                        \"` to see a detailed explanation\";\n-                    print_diagnostic(&mut self.dst, &loc, Level::Help, &msg,\n-                        None)?\n-                }\n-                _ => ()\n+        if let Some(ref primary_span) = msp.primary_span().as_ref() {\n+            self.render_macro_backtrace_old_school(primary_span, &mut buffer)?;\n+        }\n+\n+        match code {\n+            &Some(ref code) if self.registry.as_ref()\n+                                           .and_then(|registry| registry.find_description(code))\n+                                           .is_some() => {\n+                let msg = \"run `rustc --explain \".to_string() + &code.to_string() +\n+                    \"` to see a detailed explanation\";\n+\n+                let line_offset = buffer.num_lines();\n+                buffer.append(line_offset, &loc, Style::NoStyle);\n+                buffer.append(line_offset, \" \", Style::NoStyle);\n+                buffer.append(line_offset, &Level::Help.to_string(), Style::Level(Level::Help));\n+                buffer.append(line_offset, \": \", Style::HeaderMsg);\n+                buffer.append(line_offset, &msg, Style::HeaderMsg);\n             }\n+            _ => ()\n         }\n+\n+        // final step: take our styled buffer, render it, then output it\n+        emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n         Ok(())\n     }\n-\n-    fn highlight_suggestion(&mut self, suggestion: &CodeSuggestion) -> io::Result<()>\n-    {\n+    fn emit_suggestion_old_school(&mut self,\n+                                  suggestion: &CodeSuggestion,\n+                                  level: &Level,\n+                                  msg: &str)\n+                                  -> io::Result<()> {\n         use std::borrow::Borrow;\n \n         let primary_span = suggestion.msp.primary_span().unwrap();\n-        let lines = self.cm.span_to_lines(primary_span).unwrap();\n-        assert!(!lines.lines.is_empty());\n+        if let Some(ref cm) = self.cm {\n+            let mut buffer = StyledBuffer::new();\n \n-        let complete = suggestion.splice_lines(self.cm.borrow());\n-        let line_count = cmp::min(lines.lines.len(), MAX_HIGHLIGHT_LINES);\n-        let display_lines = &lines.lines[..line_count];\n+            let loc = cm.span_to_string(primary_span);\n \n-        let fm = &*lines.file;\n-        // Calculate the widest number to format evenly\n-        let max_digits = line_num_max_digits(display_lines.last().unwrap());\n+            if loc != \"\" {\n+                buffer.append(0, &loc, Style::NoStyle);\n+                buffer.append(0, \" \", Style::NoStyle);\n+            }\n \n-        // print the suggestion without any line numbers, but leave\n-        // space for them. This helps with lining up with previous\n-        // snippets from the actual error being reported.\n-        let mut lines = complete.lines();\n-        for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n-            write!(&mut self.dst, \"{0}:{1:2$} {3}\\n\",\n-                   fm.name, \"\", max_digits, line)?;\n-        }\n+            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+            buffer.append(0, \": \", Style::HeaderMsg);\n+            buffer.append(0, msg, Style::HeaderMsg);\n \n-        // if we elided some lines, add an ellipsis\n-        if let Some(_) = lines.next() {\n-            write!(&mut self.dst, \"{0:1$} {0:2$} ...\\n\",\n-                   \"\", fm.name.len(), max_digits)?;\n-        }\n+            let lines = cm.span_to_lines(primary_span).unwrap();\n \n-        Ok(())\n-    }\n+            assert!(!lines.lines.is_empty());\n \n-    pub fn highlight_lines(&mut self,\n-                       msp: &MultiSpan,\n-                       lvl: Level)\n-                       -> io::Result<()>\n-    {\n-        let old_school = match self.format_mode {\n-            FormatMode::NewErrorFormat => false,\n-            FormatMode::OriginalErrorFormat => true,\n-            FormatMode::EnvironmentSelected => check_old_skool()\n-        };\n+            let complete = suggestion.splice_lines(cm.borrow());\n+            let line_count = cmp::min(lines.lines.len(), MAX_HIGHLIGHT_LINES);\n+            let display_lines = &lines.lines[..line_count];\n \n-        let mut snippet_data = SnippetData::new(self.cm.clone(),\n-                                                msp.primary_span(),\n-                                                self.format_mode.clone());\n-        if old_school {\n-            let mut output_vec = vec![];\n+            let fm = &*lines.file;\n+            // Calculate the widest number to format evenly\n+            let max_digits = line_num_max_digits(display_lines.last().unwrap());\n \n-            for span_label in msp.span_labels() {\n-                let mut snippet_data = SnippetData::new(self.cm.clone(),\n-                                                        Some(span_label.span),\n-                                                        self.format_mode.clone());\n-\n-                snippet_data.push(span_label.span,\n-                                  span_label.is_primary,\n-                                  span_label.label);\n-                if span_label.is_primary {\n-                    output_vec.insert(0, snippet_data);\n-                }\n-                else {\n-                    output_vec.push(snippet_data);\n+            // print the suggestion without any line numbers, but leave\n+            // space for them. This helps with lining up with previous\n+            // snippets from the actual error being reported.\n+            let mut lines = complete.lines();\n+            let mut row_num = 1;\n+            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n+                buffer.append(row_num, &fm.name, Style::FileNameStyle);\n+                for _ in 0..max_digits+2 {\n+                    buffer.append(row_num, &\" \", Style::NoStyle);\n                 }\n+                buffer.append(row_num, line, Style::NoStyle);\n+                row_num += 1;\n+            }\n+\n+            // if we elided some lines, add an ellipsis\n+            if let Some(_) = lines.next() {\n+                buffer.append(row_num, \"...\", Style::NoStyle);\n             }\n+            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+        }\n+        Ok(())\n+    }\n \n-            for snippet_data in output_vec.iter() {\n-                let rendered_lines = snippet_data.render_lines();\n-                for rendered_line in &rendered_lines {\n-                    for styled_string in &rendered_line.text {\n-                        self.dst.apply_style(lvl, &rendered_line.kind, styled_string.style)?;\n-                        write!(&mut self.dst, \"{}\", styled_string.text)?;\n-                        self.dst.reset_attrs()?;\n+    fn emit_messages_old_school(&mut self, db: &DiagnosticBuilder) {\n+        match self.emit_message_old_school(&db.span,\n+                                           &db.message,\n+                                           &db.code,\n+                                           &db.level,\n+                                           true) {\n+            Ok(()) => {\n+                for child in &db.children {\n+                    let (span, show_snippet) = if child.span.primary_spans().is_empty() {\n+                        (db.span.clone(), false)\n+                    } else {\n+                        (child.span.clone(), true)\n+                    };\n+\n+                    match child.render_span {\n+                        Some(FullSpan(_)) => {\n+                            match self.emit_message_old_school(&span,\n+                                                               &child.message,\n+                                                               &None,\n+                                                               &child.level,\n+                                                               show_snippet) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        },\n+                        Some(Suggestion(ref cs)) => {\n+                            match self.emit_suggestion_old_school(cs,\n+                                                                  &child.level,\n+                                                                  &child.message) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        },\n+                        None => {\n+                            match self.emit_message_old_school(&span,\n+                                                               &child.message,\n+                                                               &None,\n+                                                               &child.level,\n+                                                               show_snippet) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        }\n                     }\n-                    write!(&mut self.dst, \"\\n\")?;\n                 }\n             }\n+            Err(e) => panic!(\"failed to emit error: {}\", e)\n         }\n-        else {\n-            for span_label in msp.span_labels() {\n-                snippet_data.push(span_label.span,\n-                                  span_label.is_primary,\n-                                  span_label.label);\n-            }\n-            let rendered_lines = snippet_data.render_lines();\n-            for rendered_line in &rendered_lines {\n-                for styled_string in &rendered_line.text {\n-                    self.dst.apply_style(lvl, &rendered_line.kind, styled_string.style)?;\n-                    write!(&mut self.dst, \"{}\", styled_string.text)?;\n-                    self.dst.reset_attrs()?;\n+    }\n+\n+    fn render_macro_backtrace_old_school(&mut self,\n+                                         sp: &Span,\n+                                         buffer: &mut StyledBuffer) -> io::Result<()> {\n+        if let Some(ref cm) = self.cm {\n+            for trace in cm.macro_backtrace(sp.clone()) {\n+                let line_offset = buffer.num_lines();\n+\n+                let mut diag_string =\n+                    format!(\"in this expansion of {}\", trace.macro_decl_name);\n+                if let Some(def_site_span) = trace.def_site_span {\n+                    diag_string.push_str(\n+                        &format!(\" (defined in {})\",\n+                            cm.span_to_filename(def_site_span)));\n                 }\n-                write!(&mut self.dst, \"\\n\")?;\n+                let snippet = cm.span_to_string(trace.call_site);\n+                buffer.append(line_offset, &format!(\"{} \", snippet), Style::NoStyle);\n+                buffer.append(line_offset, \"note\", Style::Level(Level::Note));\n+                buffer.append(line_offset, \": \", Style::NoStyle);\n+                buffer.append(line_offset, &diag_string, Style::OldSchoolNoteText);\n             }\n         }\n         Ok(())\n     }\n+}\n \n-    fn print_macro_backtrace(&mut self,\n-                             sp: Span)\n-                             -> io::Result<()> {\n-        for trace in self.cm.macro_backtrace(sp) {\n-            let mut diag_string =\n-                format!(\"in this expansion of {}\", trace.macro_decl_name);\n-            if let Some(def_site_span) = trace.def_site_span {\n-                diag_string.push_str(\n-                    &format!(\" (defined in {})\",\n-                        self.cm.span_to_filename(def_site_span)));\n-            }\n-            let snippet = self.cm.span_to_string(trace.call_site);\n-            print_diagnostic(&mut self.dst, &snippet, Note, &diag_string, None)?;\n+fn draw_col_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n+    buffer.puts(line, col, \"| \", Style::LineNumber);\n+}\n+\n+fn draw_col_separator_no_space(buffer: &mut StyledBuffer, line: usize, col: usize) {\n+    buffer.puts(line, col, \"|\", Style::LineNumber);\n+}\n+\n+fn draw_note_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n+    buffer.puts(line, col, \"= \", Style::LineNumber);\n+}\n+\n+fn overlaps(a1: &Annotation, a2: &Annotation) -> bool {\n+    (a2.start_col..a2.end_col).contains(a1.start_col) ||\n+    (a1.start_col..a1.end_col).contains(a2.start_col)\n+}\n+\n+fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n+        lvl: &Level,\n+        dst: &mut Destination) -> io::Result<()> {\n+    for line in rendered_buffer {\n+        for part in line {\n+            dst.apply_style(lvl.clone(), part.style)?;\n+            write!(dst, \"{}\", part.text)?;\n+            dst.reset_attrs()?;\n         }\n-        Ok(())\n+        write!(dst, \"\\n\")?;\n     }\n+    Ok(())\n }\n \n fn line_num_max_digits(line: &LineInfo) -> usize {\n@@ -456,40 +968,6 @@ fn line_num_max_digits(line: &LineInfo) -> usize {\n     digits\n }\n \n-fn print_diagnostic(dst: &mut Destination,\n-                    topic: &str,\n-                    lvl: Level,\n-                    msg: &str,\n-                    code: Option<&str>)\n-                    -> io::Result<()> {\n-    if !topic.is_empty() {\n-        let old_school = check_old_skool();\n-        if !old_school {\n-            write!(dst, \"{}: \", topic)?;\n-        }\n-        else {\n-            write!(dst, \"{} \", topic)?;\n-        }\n-        dst.reset_attrs()?;\n-    }\n-    dst.start_attr(term::Attr::Bold)?;\n-    dst.start_attr(term::Attr::ForegroundColor(lvl.color()))?;\n-    write!(dst, \"{}\", lvl.to_string())?;\n-    dst.reset_attrs()?;\n-    write!(dst, \": \")?;\n-    dst.start_attr(term::Attr::Bold)?;\n-    write!(dst, \"{}\", msg)?;\n-\n-    if let Some(code) = code {\n-        let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n-        print_maybe_styled!(dst, style, \" [{}]\", code.clone())?;\n-    }\n-\n-    dst.reset_attrs()?;\n-    write!(dst, \"\\n\")?;\n-    Ok(())\n-}\n-\n #[cfg(unix)]\n fn stderr_isatty() -> bool {\n     use libc;\n@@ -513,7 +991,7 @@ fn stderr_isatty() -> bool {\n     }\n }\n \n-enum Destination {\n+pub enum Destination {\n     Terminal(Box<term::StderrTerminal>),\n     Raw(Box<Write + Send>),\n }\n@@ -528,35 +1006,39 @@ impl Destination {\n \n     fn apply_style(&mut self,\n                    lvl: Level,\n-                   _kind: &RenderedLineKind,\n                    style: Style)\n                    -> io::Result<()> {\n         match style {\n-            Style::FileNameStyle |\n-            Style::LineAndColumn => {\n-            }\n+            Style::FileNameStyle | Style::LineAndColumn => {}\n             Style::LineNumber => {\n-                self.start_attr(term::Attr::Bold)?;\n-                self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE))?;\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE)));\n             }\n-            Style::Quotation => {\n+            Style::ErrorCode => {\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA)));\n             }\n-            Style::OldSkoolNote => {\n-                self.start_attr(term::Attr::Bold)?;\n-                self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_GREEN))?;\n+            Style::Quotation => {}\n+            Style::OldSchoolNote => {\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_GREEN)));\n             }\n-            Style::OldSkoolNoteText => {\n-                self.start_attr(term::Attr::Bold)?;\n+            Style::OldSchoolNoteText | Style::HeaderMsg => {\n+                try!(self.start_attr(term::Attr::Bold));\n             }\n             Style::UnderlinePrimary | Style::LabelPrimary => {\n-                self.start_attr(term::Attr::Bold)?;\n-                self.start_attr(term::Attr::ForegroundColor(lvl.color()))?;\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(lvl.color())));\n             }\n-            Style::UnderlineSecondary | Style::LabelSecondary => {\n-                self.start_attr(term::Attr::Bold)?;\n-                self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE))?;\n+            Style::UnderlineSecondary |\n+            Style::LabelSecondary => {\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE)));\n             }\n-            Style::NoStyle => {\n+            Style::NoStyle => {}\n+            Style::Level(l) => {\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(l.color())));\n             }\n         }\n         Ok(())\n@@ -577,46 +1059,6 @@ impl Destination {\n         }\n         Ok(())\n     }\n-\n-    fn print_maybe_styled(&mut self,\n-                          args: fmt::Arguments,\n-                          color: term::Attr,\n-                          print_newline_at_end: bool)\n-                          -> io::Result<()> {\n-        match *self {\n-            Terminal(ref mut t) => {\n-                t.attr(color)?;\n-                // If `msg` ends in a newline, we need to reset the color before\n-                // the newline. We're making the assumption that we end up writing\n-                // to a `LineBufferedWriter`, which means that emitting the reset\n-                // after the newline ends up buffering the reset until we print\n-                // another line or exit. Buffering the reset is a problem if we're\n-                // sharing the terminal with any other programs (e.g. other rustc\n-                // instances via `make -jN`).\n-                //\n-                // Note that if `msg` contains any internal newlines, this will\n-                // result in the `LineBufferedWriter` flushing twice instead of\n-                // once, which still leaves the opportunity for interleaved output\n-                // to be miscolored. We assume this is rare enough that we don't\n-                // have to worry about it.\n-                t.write_fmt(args)?;\n-                t.reset()?;\n-                if print_newline_at_end {\n-                    t.write_all(b\"\\n\")\n-                } else {\n-                    Ok(())\n-                }\n-            }\n-            Raw(ref mut w) => {\n-                w.write_fmt(args)?;\n-                if print_newline_at_end {\n-                    w.write_all(b\"\\n\")\n-                } else {\n-                    Ok(())\n-                }\n-            }\n-        }\n-    }\n }\n \n impl Write for Destination {\n@@ -632,4 +1074,4 @@ impl Write for Destination {\n             Raw(ref mut w) => w.flush(),\n         }\n     }\n-}\n+}\n\\ No newline at end of file"}, {"sha": "6a48f65714cc50d95e6463d337ec64af32233dd1", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -49,6 +49,7 @@ use std::thread::panicking;\n pub mod emitter;\n pub mod snippet;\n pub mod registry;\n+pub mod styled_buffer;\n \n use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION };\n use syntax_pos::{MacroBacktrace};\n@@ -81,16 +82,6 @@ pub trait CodeMapper {\n     fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace>;\n }\n \n-impl RenderSpan {\n-    fn span(&self) -> &MultiSpan {\n-        match *self {\n-            FullSpan(ref msp) |\n-            Suggestion(CodeSuggestion { ref msp, .. }) =>\n-                msp\n-        }\n-    }\n-}\n-\n impl CodeSuggestion {\n     /// Returns the assembled code suggestion.\n     pub fn splice_lines(&self, cm: &CodeMapper) -> String {\n@@ -238,7 +229,7 @@ impl<'a> DiagnosticBuilder<'a> {\n             return;\n         }\n \n-        self.handler.emit.borrow_mut().emit_struct(&self);\n+        self.handler.emitter.borrow_mut().emit(&self);\n         self.cancel();\n         self.handler.panic_if_treat_err_as_bug();\n \n@@ -359,11 +350,20 @@ impl<'a> DiagnosticBuilder<'a> {\n     fn new(handler: &'a Handler,\n            level: Level,\n            message: &str) -> DiagnosticBuilder<'a> {\n+        DiagnosticBuilder::new_with_code(handler, level, None, message)\n+    }\n+\n+    /// Convenience function for internal use, clients should use one of the\n+    /// struct_* methods on Handler.\n+    fn new_with_code(handler: &'a Handler,\n+           level: Level,\n+           code: Option<String>,\n+           message: &str) -> DiagnosticBuilder<'a> {\n         DiagnosticBuilder {\n             handler: handler,\n             level: level,\n             message: message.to_owned(),\n-            code: None,\n+            code: code,\n             span: MultiSpan::new(),\n             children: vec![],\n         }\n@@ -397,10 +397,10 @@ impl<'a> fmt::Debug for DiagnosticBuilder<'a> {\n impl<'a> Drop for DiagnosticBuilder<'a> {\n     fn drop(&mut self) {\n         if !panicking() && !self.cancelled() {\n-            self.handler.emit.borrow_mut().emit(&MultiSpan::new(),\n-                                                \"Error constructed but not emitted\",\n-                                                None,\n-                                                Bug);\n+            let mut db = DiagnosticBuilder::new(self.handler,\n+                                                Bug,\n+                                                \"Error constructed but not emitted\");\n+            db.emit();\n             panic!();\n         }\n     }\n@@ -411,7 +411,7 @@ impl<'a> Drop for DiagnosticBuilder<'a> {\n /// others log errors for later reporting.\n pub struct Handler {\n     err_count: Cell<usize>,\n-    emit: RefCell<Box<Emitter>>,\n+    emitter: RefCell<Box<Emitter>>,\n     pub can_emit_warnings: bool,\n     treat_err_as_bug: bool,\n     continue_after_error: Cell<bool>,\n@@ -423,7 +423,7 @@ impl Handler {\n                             registry: Option<registry::Registry>,\n                             can_emit_warnings: bool,\n                             treat_err_as_bug: bool,\n-                            cm: Rc<CodeMapper>)\n+                            cm: Option<Rc<CodeMapper>>)\n                             -> Handler {\n         let emitter = Box::new(EmitterWriter::stderr(color_config, registry, cm,\n                                snippet::FormatMode::EnvironmentSelected));\n@@ -435,7 +435,7 @@ impl Handler {\n                         e: Box<Emitter>) -> Handler {\n         Handler {\n             err_count: Cell::new(0),\n-            emit: RefCell::new(e),\n+            emitter: RefCell::new(e),\n             can_emit_warnings: can_emit_warnings,\n             treat_err_as_bug: treat_err_as_bug,\n             continue_after_error: Cell::new(true),\n@@ -588,7 +588,7 @@ impl Handler {\n         self.bump_err_count();\n     }\n     pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit.borrow_mut().emit(&sp.into(), msg, None, Note);\n+        self.emit(&sp.into(), msg, Note);\n     }\n     pub fn span_unimpl<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n         self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n@@ -597,25 +597,40 @@ impl Handler {\n         if self.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Fatal);\n+        let mut db = DiagnosticBuilder::new(self,\n+                                            Fatal,\n+                                            msg);\n+        db.emit();\n         self.bump_err_count();\n         FatalError\n     }\n     pub fn err(&self, msg: &str) {\n         if self.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Error);\n+        let mut db = DiagnosticBuilder::new(self,\n+                                            Error,\n+                                            msg);\n+        db.emit();\n         self.bump_err_count();\n     }\n     pub fn warn(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Warning);\n+        let mut db = DiagnosticBuilder::new(self,\n+                                            Warning,\n+                                            msg);\n+        db.emit();\n     }\n     pub fn note_without_error(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Note);\n+        let mut db = DiagnosticBuilder::new(self,\n+                                            Note,\n+                                            msg);\n+        db.emit();\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Bug);\n+        let mut db = DiagnosticBuilder::new(self,\n+                                            Bug,\n+                                            msg);\n+        db.emit();\n         panic!(ExplicitBug);\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n@@ -661,7 +676,9 @@ impl Handler {\n                 msg: &str,\n                 lvl: Level) {\n         if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(&msp, msg, None, lvl);\n+        let mut db = DiagnosticBuilder::new(self, lvl, msg);\n+        db.set_span(msp.clone());\n+        db.emit();\n         if !self.continue_after_error.get() { self.abort_if_errors(); }\n     }\n     pub fn emit_with_code(&self,\n@@ -670,7 +687,12 @@ impl Handler {\n                           code: &str,\n                           lvl: Level) {\n         if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(&msp, msg, Some(code), lvl);\n+        let mut db = DiagnosticBuilder::new_with_code(self,\n+                                                      lvl,\n+                                                      Some(code.to_owned()),\n+                                                      msg);\n+        db.set_span(msp.clone());\n+        db.emit();\n         if !self.continue_after_error.get() { self.abort_if_errors(); }\n     }\n }\n@@ -734,13 +756,13 @@ pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T where\n ///\n /// FIXME(#33240)\n #[cfg(not(test))]\n-pub fn check_old_skool() -> bool {\n+pub fn check_old_school() -> bool {\n     use std::env;\n     env::var(\"RUST_NEW_ERROR_FORMAT\").is_err()\n }\n \n /// For unit tests, use the new format.\n #[cfg(test)]\n-pub fn check_old_skool() -> bool {\n+pub fn check_old_school() -> bool {\n     false\n }"}, {"sha": "2f94a7f6832fe34401b3a52b6d54cb7d610023ef", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 18, "deletions": 835, "changes": 853, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -10,12 +10,10 @@\n \n // Code for annotating snippets.\n \n-use syntax_pos::{Span, FileMap, CharPos, LineInfo};\n-use check_old_skool;\n+use syntax_pos::{Span, FileMap};\n use CodeMapper;\n-use std::cmp;\n use std::rc::Rc;\n-use std::mem;\n+use {Level};\n \n #[derive(Clone)]\n pub enum FormatMode {\n@@ -49,37 +47,31 @@ pub struct FileInfo {\n     format_mode: FormatMode,\n }\n \n-#[derive(Clone, Debug)]\n-struct Line {\n-    line_index: usize,\n-    annotations: Vec<Annotation>,\n+#[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+pub struct Line {\n+    pub line_index: usize,\n+    pub annotations: Vec<Annotation>,\n }\n \n #[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n-struct Annotation {\n+pub struct Annotation {\n     /// Start column, 0-based indexing -- counting *characters*, not\n     /// utf-8 bytes. Note that it is important that this field goes\n     /// first, so that when we sort, we sort orderings by start\n     /// column.\n-    start_col: usize,\n+    pub start_col: usize,\n \n     /// End column within the line (exclusive)\n-    end_col: usize,\n+    pub end_col: usize,\n \n     /// Is this annotation derived from primary span\n-    is_primary: bool,\n+    pub is_primary: bool,\n \n     /// Is this a large span minimized down to a smaller span\n-    is_minimized: bool,\n+    pub is_minimized: bool,\n \n     /// Optional label to display adjacent to the annotation.\n-    label: Option<String>,\n-}\n-\n-#[derive(Debug)]\n-pub struct RenderedLine {\n-    pub text: Vec<StyledString>,\n-    pub kind: RenderedLineKind,\n+    pub label: Option<String>,\n }\n \n #[derive(Debug)]\n@@ -88,14 +80,9 @@ pub struct StyledString {\n     pub style: Style,\n }\n \n-#[derive(Debug)]\n-pub struct StyledBuffer {\n-    text: Vec<Vec<char>>,\n-    styles: Vec<Vec<Style>>\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Style {\n+    HeaderMsg,\n     FileNameStyle,\n     LineAndColumn,\n     LineNumber,\n@@ -104,813 +91,9 @@ pub enum Style {\n     UnderlineSecondary,\n     LabelPrimary,\n     LabelSecondary,\n-    OldSkoolNoteText,\n-    OldSkoolNote,\n+    OldSchoolNoteText,\n+    OldSchoolNote,\n     NoStyle,\n-}\n-\n-#[derive(Debug, Clone)]\n-pub enum RenderedLineKind {\n-    PrimaryFileName,\n-    OtherFileName,\n-    SourceText {\n-        file: Rc<FileMap>,\n-        line_index: usize,\n-    },\n-    Annotations,\n-    Elision,\n-}\n-\n-impl SnippetData {\n-    pub fn new(codemap: Rc<CodeMapper>,\n-               primary_span: Option<Span>,\n-               format_mode: FormatMode) // (*)\n-               -> Self {\n-        // (*) The primary span indicates the file that must appear\n-        // first, and which will have a line number etc in its\n-        // name. Outside of tests, this is always `Some`, but for many\n-        // tests it's not relevant to test this portion of the logic,\n-        // and it's tedious to pick a primary span (read: tedious to\n-        // port older tests that predate the existence of a primary\n-        // span).\n-\n-        debug!(\"SnippetData::new(primary_span={:?})\", primary_span);\n-\n-        let mut data = SnippetData {\n-            codemap: codemap.clone(),\n-            files: vec![],\n-            format_mode: format_mode.clone()\n-        };\n-        if let Some(primary_span) = primary_span {\n-            let lo = codemap.lookup_char_pos(primary_span.lo);\n-            data.files.push(\n-                FileInfo {\n-                    file: lo.file,\n-                    primary_span: Some(primary_span),\n-                    lines: vec![],\n-                    format_mode: format_mode.clone(),\n-                });\n-        }\n-        data\n-    }\n-\n-    pub fn push(&mut self, span: Span, is_primary: bool, label: Option<String>) {\n-        debug!(\"SnippetData::push(span={:?}, is_primary={}, label={:?})\",\n-               span, is_primary, label);\n-\n-        let file_lines = match self.codemap.span_to_lines(span) {\n-            Ok(file_lines) => file_lines,\n-            Err(_) => {\n-                // ignore unprintable spans completely.\n-                return;\n-            }\n-        };\n-\n-        self.file(&file_lines.file)\n-            .push_lines(&file_lines.lines, is_primary, label);\n-    }\n-\n-    fn file(&mut self, file_map: &Rc<FileMap>) -> &mut FileInfo {\n-        let index = self.files.iter().position(|f| f.file.name == file_map.name);\n-        if let Some(index) = index {\n-            return &mut self.files[index];\n-        }\n-\n-        self.files.push(\n-            FileInfo {\n-                file: file_map.clone(),\n-                lines: vec![],\n-                primary_span: None,\n-                format_mode: self.format_mode.clone()\n-            });\n-        self.files.last_mut().unwrap()\n-    }\n-\n-    pub fn render_lines(&self) -> Vec<RenderedLine> {\n-        debug!(\"SnippetData::render_lines()\");\n-\n-        let mut rendered_lines: Vec<_> =\n-            self.files.iter()\n-                      .flat_map(|f| f.render_file_lines(&self.codemap))\n-                      .collect();\n-        prepend_prefixes(&mut rendered_lines, &self.format_mode);\n-        trim_lines(&mut rendered_lines);\n-        rendered_lines\n-    }\n-}\n-\n-pub trait StringSource {\n-    fn make_string(self) -> String;\n-}\n-\n-impl StringSource for String {\n-    fn make_string(self) -> String {\n-        self\n-    }\n-}\n-\n-impl StringSource for Vec<char> {\n-    fn make_string(self) -> String {\n-        self.into_iter().collect()\n-    }\n-}\n-\n-impl<S> From<(S, Style, RenderedLineKind)> for RenderedLine\n-    where S: StringSource\n-{\n-    fn from((text, style, kind): (S, Style, RenderedLineKind)) -> Self {\n-        RenderedLine {\n-            text: vec![StyledString {\n-                text: text.make_string(),\n-                style: style,\n-            }],\n-            kind: kind,\n-        }\n-    }\n-}\n-\n-impl<S1,S2> From<(S1, Style, S2, Style, RenderedLineKind)> for RenderedLine\n-    where S1: StringSource, S2: StringSource\n-{\n-    fn from(tuple: (S1, Style, S2, Style, RenderedLineKind)) -> Self {\n-        let (text1, style1, text2, style2, kind) = tuple;\n-        RenderedLine {\n-            text: vec![\n-                StyledString {\n-                    text: text1.make_string(),\n-                    style: style1,\n-                },\n-                StyledString {\n-                    text: text2.make_string(),\n-                    style: style2,\n-                }\n-            ],\n-            kind: kind,\n-        }\n-    }\n-}\n-\n-impl RenderedLine {\n-    fn trim_last(&mut self) {\n-        if let Some(last_text) = self.text.last_mut() {\n-            let len = last_text.text.trim_right().len();\n-            last_text.text.truncate(len);\n-        }\n-    }\n-}\n-\n-impl RenderedLineKind {\n-    fn prefix(&self) -> StyledString {\n-        match *self {\n-            RenderedLineKind::SourceText { file: _, line_index } =>\n-                StyledString {\n-                    text: format!(\"{}\", line_index + 1),\n-                    style: Style::LineNumber,\n-                },\n-            RenderedLineKind::Elision =>\n-                StyledString {\n-                    text: String::from(\"...\"),\n-                    style: Style::LineNumber,\n-                },\n-            RenderedLineKind::PrimaryFileName |\n-            RenderedLineKind::OtherFileName |\n-            RenderedLineKind::Annotations =>\n-                StyledString {\n-                    text: String::from(\"\"),\n-                    style: Style::LineNumber,\n-                },\n-        }\n-    }\n-}\n-\n-impl StyledBuffer {\n-    fn new() -> StyledBuffer {\n-        StyledBuffer { text: vec![], styles: vec![] }\n-    }\n-\n-    fn render(&self, source_kind: RenderedLineKind) -> Vec<RenderedLine> {\n-        let mut output: Vec<RenderedLine> = vec![];\n-        let mut styled_vec: Vec<StyledString> = vec![];\n-\n-        for (row, row_style) in self.text.iter().zip(&self.styles) {\n-            let mut current_style = Style::NoStyle;\n-            let mut current_text = String::new();\n-\n-            for (&c, &s) in row.iter().zip(row_style) {\n-                if s != current_style {\n-                    if !current_text.is_empty() {\n-                        styled_vec.push(StyledString { text: current_text, style: current_style });\n-                    }\n-                    current_style = s;\n-                    current_text = String::new();\n-                }\n-                current_text.push(c);\n-            }\n-            if !current_text.is_empty() {\n-                styled_vec.push(StyledString { text: current_text, style: current_style });\n-            }\n-\n-            if output.is_empty() {\n-                //We know our first output line is source and the rest are highlights and labels\n-                output.push(RenderedLine { text: styled_vec, kind: source_kind.clone() });\n-            } else {\n-                output.push(RenderedLine { text: styled_vec, kind: RenderedLineKind::Annotations });\n-            }\n-            styled_vec = vec![];\n-        }\n-\n-        output\n-    }\n-\n-    fn putc(&mut self, line: usize, col: usize, chr: char, style: Style) {\n-        while line >= self.text.len() {\n-            self.text.push(vec![]);\n-            self.styles.push(vec![]);\n-        }\n-\n-        if col < self.text[line].len() {\n-            self.text[line][col] = chr;\n-            self.styles[line][col] = style;\n-        } else {\n-            let mut i = self.text[line].len();\n-            while i < col {\n-                let s = match self.text[0].get(i) {\n-                    Some(&'\\t') => '\\t',\n-                    _ => ' '\n-                };\n-                self.text[line].push(s);\n-                self.styles[line].push(Style::NoStyle);\n-                i += 1;\n-            }\n-            self.text[line].push(chr);\n-            self.styles[line].push(style);\n-        }\n-    }\n-\n-    fn puts(&mut self, line: usize, col: usize, string: &str, style: Style) {\n-        let mut n = col;\n-        for c in string.chars() {\n-            self.putc(line, n, c, style);\n-            n += 1;\n-        }\n-    }\n-\n-    fn set_style(&mut self, line: usize, col: usize, style: Style) {\n-        if self.styles.len() > line && self.styles[line].len() > col {\n-            self.styles[line][col] = style;\n-        }\n-    }\n-\n-    fn append(&mut self, line: usize, string: &str, style: Style) {\n-        if line >= self.text.len() {\n-            self.puts(line, 0, string, style);\n-        } else {\n-            let col = self.text[line].len();\n-            self.puts(line, col, string, style);\n-        }\n-    }\n-}\n-\n-impl FileInfo {\n-    fn push_lines(&mut self,\n-                  lines: &[LineInfo],\n-                  is_primary: bool,\n-                  label: Option<String>) {\n-        assert!(lines.len() > 0);\n-\n-        // If a span covers multiple lines, we reduce it to a single\n-        // point at the start of the span. This means that instead\n-        // of producing output like this:\n-        //\n-        // ```\n-        // --> foo.rs:2:1\n-        // 2   |> fn conflicting_items<'grammar>(state: &LR0State<'grammar>)\n-        //     |> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-        // 3   |>                               -> Set<LR0Item<'grammar>>\n-        //     |> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-        // (and so on)\n-        // ```\n-        //\n-        // we produce:\n-        //\n-        // ```\n-        // --> foo.rs:2:1\n-        // 2   |> fn conflicting_items<'grammar>(state: &LR0State<'grammar>)\n-        //        ^\n-        // ```\n-        //\n-        // Basically, although this loses information, multi-line spans just\n-        // never look good.\n-\n-        let (line, start_col, mut end_col, is_minimized) = if lines.len() == 1 {\n-            (lines[0].line_index, lines[0].start_col, lines[0].end_col, false)\n-        } else {\n-            (lines[0].line_index, lines[0].start_col, CharPos(lines[0].start_col.0 + 1), true)\n-        };\n-\n-        // Watch out for \"empty spans\". If we get a span like 6..6, we\n-        // want to just display a `^` at 6, so convert that to\n-        // 6..7. This is degenerate input, but it's best to degrade\n-        // gracefully -- and the parser likes to suply a span like\n-        // that for EOF, in particular.\n-        if start_col == end_col {\n-            end_col.0 += 1;\n-        }\n-\n-        let index = self.ensure_source_line(line);\n-        self.lines[index].push_annotation(start_col,\n-                                          end_col,\n-                                          is_primary,\n-                                          is_minimized,\n-                                          label);\n-    }\n-\n-    /// Ensure that we have a `Line` struct corresponding to\n-    /// `line_index` in the file. If we already have some other lines,\n-    /// then this will add the intervening lines to ensure that we\n-    /// have a complete snippet. (Note that when we finally display,\n-    /// some of those lines may be elided.)\n-    fn ensure_source_line(&mut self, line_index: usize) -> usize {\n-        if self.lines.is_empty() {\n-            self.lines.push(Line::new(line_index));\n-            return 0;\n-        }\n-\n-        // Find the range of lines we have thus far.\n-        let first_line_index = self.lines.first().unwrap().line_index;\n-        let last_line_index = self.lines.last().unwrap().line_index;\n-        assert!(first_line_index <= last_line_index);\n-\n-        // If the new line is lower than all the lines we have thus\n-        // far, then insert the new line and any intervening lines at\n-        // the front. In a silly attempt at micro-optimization, we\n-        // don't just call `insert` repeatedly, but instead make a new\n-        // (empty) vector, pushing the new lines onto it, and then\n-        // appending the old vector.\n-        if line_index < first_line_index {\n-            let lines = mem::replace(&mut self.lines, vec![]);\n-            self.lines.extend(\n-                (line_index .. first_line_index)\n-                    .map(|line| Line::new(line))\n-                    .chain(lines));\n-            return 0;\n-        }\n-\n-        // If the new line comes after the ones we have so far, insert\n-        // lines for it.\n-        if line_index > last_line_index {\n-            self.lines.extend(\n-                (last_line_index+1 .. line_index+1)\n-                    .map(|line| Line::new(line)));\n-            return self.lines.len() - 1;\n-        }\n-\n-        // Otherwise it should already exist.\n-        return line_index - first_line_index;\n-    }\n-\n-    fn render_file_lines(&self, codemap: &Rc<CodeMapper>) -> Vec<RenderedLine> {\n-        let old_school = match self.format_mode {\n-            FormatMode::OriginalErrorFormat => true,\n-            FormatMode::NewErrorFormat => false,\n-            FormatMode::EnvironmentSelected => check_old_skool()\n-        };\n-\n-        // As a first step, we elide any instance of more than one\n-        // continuous unannotated line.\n-\n-        let mut lines_iter = self.lines.iter();\n-        let mut output = vec![];\n-\n-        // First insert the name of the file.\n-        if !old_school {\n-            match self.primary_span {\n-                Some(span) => {\n-                    let lo = codemap.lookup_char_pos(span.lo);\n-                    output.push(RenderedLine {\n-                        text: vec![StyledString {\n-                            text: lo.file.name.clone(),\n-                            style: Style::FileNameStyle,\n-                        }, StyledString {\n-                            text: format!(\":{}:{}\", lo.line, lo.col.0 + 1),\n-                            style: Style::LineAndColumn,\n-                        }],\n-                        kind: RenderedLineKind::PrimaryFileName,\n-                    });\n-                    output.push(RenderedLine {\n-                        text: vec![StyledString {\n-                            text: \"\".to_string(),\n-                            style: Style::FileNameStyle,\n-                        }],\n-                        kind: RenderedLineKind::Annotations,\n-                    });\n-                }\n-                None => {\n-                    output.push(RenderedLine {\n-                        text: vec![StyledString {\n-                            text: self.file.name.clone(),\n-                            style: Style::FileNameStyle,\n-                        }],\n-                        kind: RenderedLineKind::OtherFileName,\n-                    });\n-                    output.push(RenderedLine {\n-                        text: vec![StyledString {\n-                            text: \"\".to_string(),\n-                            style: Style::FileNameStyle,\n-                        }],\n-                        kind: RenderedLineKind::Annotations,\n-                    });\n-                }\n-            }\n-        }\n-\n-        let mut next_line = lines_iter.next();\n-        while next_line.is_some() {\n-            // Consume lines with annotations.\n-            while let Some(line) = next_line {\n-                if line.annotations.is_empty() { break; }\n-\n-                let mut rendered_lines = self.render_line(line);\n-                assert!(!rendered_lines.is_empty());\n-                if old_school {\n-                    match self.primary_span {\n-                        Some(span) => {\n-                            let lo = codemap.lookup_char_pos(span.lo);\n-                            let hi = codemap.lookup_char_pos(span.hi);\n-                            //Before each secondary line in old skool-mode, print the label\n-                            //as an old-style note\n-                            if !line.annotations[0].is_primary {\n-                                if let Some(ann) = line.annotations[0].label.clone() {\n-                                    output.push(RenderedLine {\n-                                        text: vec![StyledString {\n-                                            text: lo.file.name.clone(),\n-                                            style: Style::FileNameStyle,\n-                                        }, StyledString {\n-                                            text: format!(\":{}:{}: {}:{} \", lo.line, lo.col.0 + 1,\n-                                                hi.line, hi.col.0+1),\n-                                            style: Style::LineAndColumn,\n-                                        }, StyledString {\n-                                            text: format!(\"note: \"),\n-                                            style: Style::OldSkoolNote,\n-                                        }, StyledString {\n-                                            text: format!(\"{}\", ann),\n-                                            style: Style::OldSkoolNoteText,\n-                                        }],\n-                                        kind: RenderedLineKind::Annotations,\n-                                    });\n-                                }\n-                            }\n-                            rendered_lines[0].text.insert(0, StyledString {\n-                                text: format!(\":{} \", lo.line),\n-                                style: Style::LineAndColumn,\n-                            });\n-                            rendered_lines[0].text.insert(0, StyledString {\n-                                text: lo.file.name.clone(),\n-                                style: Style::FileNameStyle,\n-                            });\n-                            let gap_amount =\n-                                rendered_lines[0].text[0].text.len() +\n-                                rendered_lines[0].text[1].text.len();\n-                            assert!(rendered_lines.len() >= 2,\n-                                    \"no annotations resulted from: {:?}\",\n-                                    line);\n-                            for i in 1..rendered_lines.len() {\n-                                rendered_lines[i].text.insert(0, StyledString {\n-                                    text: vec![\" \"; gap_amount].join(\"\"),\n-                                    style: Style::NoStyle\n-                                });\n-                            }\n-                        }\n-                        _ =>()\n-                    }\n-                }\n-                output.append(&mut rendered_lines);\n-                next_line = lines_iter.next();\n-            }\n-\n-            // Emit lines without annotations, but only if they are\n-            // followed by a line with an annotation.\n-            let unannotated_line = next_line;\n-            let mut unannotated_lines = 0;\n-            while let Some(line) = next_line {\n-                if !line.annotations.is_empty() { break; }\n-                unannotated_lines += 1;\n-                next_line = lines_iter.next();\n-            }\n-            if unannotated_lines > 1 {\n-                output.push(RenderedLine::from((String::new(),\n-                                                Style::NoStyle,\n-                                                RenderedLineKind::Elision)));\n-            } else if let Some(line) = unannotated_line {\n-                output.append(&mut self.render_line(line));\n-            }\n-        }\n-\n-        output\n-    }\n-\n-    fn render_line(&self, line: &Line) -> Vec<RenderedLine> {\n-        let old_school = match self.format_mode {\n-            FormatMode::OriginalErrorFormat => true,\n-            FormatMode::NewErrorFormat => false,\n-            FormatMode::EnvironmentSelected => check_old_skool()\n-        };\n-\n-        let source_string = self.file.get_line(line.line_index)\n-                                     .unwrap_or(\"\");\n-        let source_kind = RenderedLineKind::SourceText {\n-            file: self.file.clone(),\n-            line_index: line.line_index,\n-        };\n-\n-        let mut styled_buffer = StyledBuffer::new();\n-\n-        // First create the source line we will highlight.\n-        styled_buffer.append(0, &source_string, Style::Quotation);\n-\n-        if line.annotations.is_empty() {\n-            return styled_buffer.render(source_kind);\n-        }\n-\n-        // We want to display like this:\n-        //\n-        //      vec.push(vec.pop().unwrap());\n-        //      ---      ^^^               _ previous borrow ends here\n-        //      |        |\n-        //      |        error occurs here\n-        //      previous borrow of `vec` occurs here\n-        //\n-        // But there are some weird edge cases to be aware of:\n-        //\n-        //      vec.push(vec.pop().unwrap());\n-        //      --------                    - previous borrow ends here\n-        //      ||\n-        //      |this makes no sense\n-        //      previous borrow of `vec` occurs here\n-        //\n-        // For this reason, we group the lines into \"highlight lines\"\n-        // and \"annotations lines\", where the highlight lines have the `~`.\n-\n-        //let mut highlight_line = Self::whitespace(&source_string);\n-\n-        // Sort the annotations by (start, end col)\n-        let mut annotations = line.annotations.clone();\n-        annotations.sort();\n-\n-        // Next, create the highlight line.\n-        for annotation in &annotations {\n-            if old_school {\n-                for p in annotation.start_col .. annotation.end_col {\n-                    if p == annotation.start_col {\n-                        styled_buffer.putc(1, p, '^',\n-                            if annotation.is_primary {\n-                                Style::UnderlinePrimary\n-                            } else {\n-                                Style::OldSkoolNote\n-                            });\n-                    }\n-                    else {\n-                        styled_buffer.putc(1, p, '~',\n-                            if annotation.is_primary {\n-                                Style::UnderlinePrimary\n-                            } else {\n-                                Style::OldSkoolNote\n-                            });\n-                    }\n-                }\n-            }\n-            else {\n-                for p in annotation.start_col .. annotation.end_col {\n-                    if annotation.is_primary {\n-                        styled_buffer.putc(1, p, '^', Style::UnderlinePrimary);\n-                        if !annotation.is_minimized {\n-                            styled_buffer.set_style(0, p, Style::UnderlinePrimary);\n-                        }\n-                    } else {\n-                        styled_buffer.putc(1, p, '-', Style::UnderlineSecondary);\n-                        if !annotation.is_minimized {\n-                            styled_buffer.set_style(0, p, Style::UnderlineSecondary);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Now we are going to write labels in. To start, we'll exclude\n-        // the annotations with no labels.\n-        let (labeled_annotations, unlabeled_annotations): (Vec<_>, _) =\n-            annotations.into_iter()\n-                       .partition(|a| a.label.is_some());\n-\n-        // If there are no annotations that need text, we're done.\n-        if labeled_annotations.is_empty() {\n-            return styled_buffer.render(source_kind);\n-        }\n-        if old_school {\n-            return styled_buffer.render(source_kind);\n-        }\n-\n-        // Now add the text labels. We try, when possible, to stick the rightmost\n-        // annotation at the end of the highlight line:\n-        //\n-        //      vec.push(vec.pop().unwrap());\n-        //      ---      ---               - previous borrow ends here\n-        //\n-        // But sometimes that's not possible because one of the other\n-        // annotations overlaps it. For example, from the test\n-        // `span_overlap_label`, we have the following annotations\n-        // (written on distinct lines for clarity):\n-        //\n-        //      fn foo(x: u32) {\n-        //      --------------\n-        //             -\n-        //\n-        // In this case, we can't stick the rightmost-most label on\n-        // the highlight line, or we would get:\n-        //\n-        //      fn foo(x: u32) {\n-        //      -------- x_span\n-        //      |\n-        //      fn_span\n-        //\n-        // which is totally weird. Instead we want:\n-        //\n-        //      fn foo(x: u32) {\n-        //      --------------\n-        //      |      |\n-        //      |      x_span\n-        //      fn_span\n-        //\n-        // which is...less weird, at least. In fact, in general, if\n-        // the rightmost span overlaps with any other span, we should\n-        // use the \"hang below\" version, so we can at least make it\n-        // clear where the span *starts*.\n-        let mut labeled_annotations = &labeled_annotations[..];\n-        match labeled_annotations.split_last().unwrap() {\n-            (last, previous) => {\n-                if previous.iter()\n-                           .chain(&unlabeled_annotations)\n-                           .all(|a| !overlaps(a, last))\n-                {\n-                    // append the label afterwards; we keep it in a separate\n-                    // string\n-                    let highlight_label: String = format!(\" {}\", last.label.as_ref().unwrap());\n-                    if last.is_primary {\n-                        styled_buffer.append(1, &highlight_label, Style::LabelPrimary);\n-                    } else {\n-                        styled_buffer.append(1, &highlight_label, Style::LabelSecondary);\n-                    }\n-                    labeled_annotations = previous;\n-                }\n-            }\n-        }\n-\n-        // If that's the last annotation, we're done\n-        if labeled_annotations.is_empty() {\n-            return styled_buffer.render(source_kind);\n-        }\n-\n-        for (index, annotation) in labeled_annotations.iter().enumerate() {\n-            // Leave:\n-            // - 1 extra line\n-            // - One line for each thing that comes after\n-            let comes_after = labeled_annotations.len() - index - 1;\n-            let blank_lines = 3 + comes_after;\n-\n-            // For each blank line, draw a `|` at our column. The\n-            // text ought to be long enough for this.\n-            for index in 2..blank_lines {\n-                if annotation.is_primary {\n-                    styled_buffer.putc(index, annotation.start_col, '|', Style::UnderlinePrimary);\n-                } else {\n-                    styled_buffer.putc(index, annotation.start_col, '|', Style::UnderlineSecondary);\n-                }\n-            }\n-\n-            if annotation.is_primary {\n-                styled_buffer.puts(blank_lines, annotation.start_col,\n-                    annotation.label.as_ref().unwrap(), Style::LabelPrimary);\n-            } else {\n-                styled_buffer.puts(blank_lines, annotation.start_col,\n-                    annotation.label.as_ref().unwrap(), Style::LabelSecondary);\n-            }\n-        }\n-\n-        styled_buffer.render(source_kind)\n-    }\n-}\n-\n-fn prepend_prefixes(rendered_lines: &mut [RenderedLine], format_mode: &FormatMode) {\n-    let old_school = match *format_mode {\n-        FormatMode::OriginalErrorFormat => true,\n-        FormatMode::NewErrorFormat => false,\n-        FormatMode::EnvironmentSelected => check_old_skool()\n-    };\n-    if old_school {\n-        return;\n-    }\n-\n-    let prefixes: Vec<_> =\n-        rendered_lines.iter()\n-                      .map(|rl| rl.kind.prefix())\n-                      .collect();\n-\n-    // find the max amount of spacing we need; add 1 to\n-    // p.text.len() to leave space between the prefix and the\n-    // source text\n-    let padding_len =\n-        prefixes.iter()\n-                .map(|p| if p.text.len() == 0 { 0 } else { p.text.len() + 1 })\n-                .max()\n-                .unwrap_or(0);\n-\n-    // Ensure we insert at least one character of padding, so that the\n-    // `-->` arrows can fit etc.\n-    let padding_len = cmp::max(padding_len, 1);\n-\n-    for (mut prefix, line) in prefixes.into_iter().zip(rendered_lines) {\n-        let extra_spaces = (prefix.text.len() .. padding_len).map(|_| ' ');\n-        prefix.text.extend(extra_spaces);\n-        match line.kind {\n-            RenderedLineKind::Elision => {\n-                line.text.insert(0, prefix);\n-            }\n-            RenderedLineKind::PrimaryFileName => {\n-                //   --> filename\n-                // 22 |>\n-                //   ^\n-                //   padding_len\n-                let dashes = (0..padding_len - 1).map(|_| ' ')\n-                                                 .chain(Some('-'))\n-                                                 .chain(Some('-'))\n-                                                 .chain(Some('>'))\n-                                                 .chain(Some(' '));\n-                line.text.insert(0, StyledString {text: dashes.collect(),\n-                                                  style: Style::LineNumber})\n-            }\n-            RenderedLineKind::OtherFileName => {\n-                //   ::: filename\n-                // 22 |>\n-                //   ^\n-                //   padding_len\n-                let dashes = (0..padding_len - 1).map(|_| ' ')\n-                                                 .chain(Some(':'))\n-                                                 .chain(Some(':'))\n-                                                 .chain(Some(':'))\n-                                                 .chain(Some(' '));\n-                line.text.insert(0, StyledString {text: dashes.collect(),\n-                                                  style: Style::LineNumber})\n-            }\n-            _ => {\n-                line.text.insert(0, prefix);\n-                line.text.insert(1, StyledString {text: String::from(\"|> \"),\n-                                                  style: Style::LineNumber})\n-            }\n-        }\n-    }\n-}\n-\n-fn trim_lines(rendered_lines: &mut [RenderedLine]) {\n-    for line in rendered_lines {\n-        while !line.text.is_empty() {\n-            line.trim_last();\n-            if line.text.last().unwrap().text.is_empty() {\n-                line.text.pop();\n-            } else {\n-                break;\n-            }\n-        }\n-    }\n-}\n-\n-impl Line {\n-    fn new(line_index: usize) -> Line {\n-        Line {\n-            line_index: line_index,\n-            annotations: vec![]\n-        }\n-    }\n-\n-    fn push_annotation(&mut self,\n-                       start: CharPos,\n-                       end: CharPos,\n-                       is_primary: bool,\n-                       is_minimized: bool,\n-                       label: Option<String>) {\n-        self.annotations.push(Annotation {\n-            start_col: start.0,\n-            end_col: end.0,\n-            is_primary: is_primary,\n-            is_minimized: is_minimized,\n-            label: label,\n-        });\n-    }\n-}\n-\n-fn overlaps(a1: &Annotation,\n-            a2: &Annotation)\n-            -> bool\n-{\n-    (a2.start_col .. a2.end_col).contains(a1.start_col) ||\n-        (a1.start_col .. a1.end_col).contains(a2.start_col)\n-}\n+    ErrorCode,\n+    Level(Level),\n+}\n\\ No newline at end of file"}, {"sha": "9768b68619e7945ec38648300874f9507d4cf12f", "filename": "src/librustc_errors/styled_buffer.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc_errors%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc_errors%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fstyled_buffer.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,146 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Code for creating styled buffers\n+\n+use snippet::{Style, StyledString};\n+\n+#[derive(Debug)]\n+pub struct StyledBuffer {\n+    text: Vec<Vec<char>>,\n+    styles: Vec<Vec<Style>>,\n+}\n+\n+impl StyledBuffer {\n+    pub fn new() -> StyledBuffer {\n+        StyledBuffer {\n+            text: vec![],\n+            styles: vec![],\n+        }\n+    }\n+\n+    pub fn copy_tabs(&mut self, row: usize) {\n+        if row < self.text.len() {\n+            for i in row+1..self.text.len() {\n+                for j in 0..self.text[i].len() {\n+                    if self.text[row].len() > j &&\n+                       self.text[row][j] == '\\t' &&\n+                       self.text[i][j] == ' ' {\n+                        self.text[i][j] = '\\t';\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn render(&mut self) -> Vec<Vec<StyledString>> {\n+        let mut output: Vec<Vec<StyledString>> = vec![];\n+        let mut styled_vec: Vec<StyledString> = vec![];\n+\n+        //before we render, do a little patch-up work to support tabs\n+        self.copy_tabs(3);\n+\n+        for (row, row_style) in self.text.iter().zip(&self.styles) {\n+            let mut current_style = Style::NoStyle;\n+            let mut current_text = String::new();\n+\n+            for (&c, &s) in row.iter().zip(row_style) {\n+                if s != current_style {\n+                    if !current_text.is_empty() {\n+                        styled_vec.push(StyledString {\n+                            text: current_text,\n+                            style: current_style,\n+                        });\n+                    }\n+                    current_style = s;\n+                    current_text = String::new();\n+                }\n+                current_text.push(c);\n+            }\n+            if !current_text.is_empty() {\n+                styled_vec.push(StyledString {\n+                    text: current_text,\n+                    style: current_style,\n+                });\n+            }\n+\n+            // We're done with the row, push and keep going\n+            output.push(styled_vec);\n+\n+            styled_vec = vec![];\n+        }\n+\n+        output\n+    }\n+\n+    fn ensure_lines(&mut self, line: usize) {\n+        while line >= self.text.len() {\n+            self.text.push(vec![]);\n+            self.styles.push(vec![]);\n+        }\n+    }\n+\n+    pub fn putc(&mut self, line: usize, col: usize, chr: char, style: Style) {\n+        self.ensure_lines(line);\n+        if col < self.text[line].len() {\n+            self.text[line][col] = chr;\n+            self.styles[line][col] = style;\n+        } else {\n+            let mut i = self.text[line].len();\n+            while i < col {\n+                self.text[line].push(' ');\n+                self.styles[line].push(Style::NoStyle);\n+                i += 1;\n+            }\n+            self.text[line].push(chr);\n+            self.styles[line].push(style);\n+        }\n+    }\n+\n+    pub fn puts(&mut self, line: usize, col: usize, string: &str, style: Style) {\n+        let mut n = col;\n+        for c in string.chars() {\n+            self.putc(line, n, c, style);\n+            n += 1;\n+        }\n+    }\n+\n+    pub fn set_style(&mut self, line: usize, col: usize, style: Style) {\n+        if self.styles.len() > line && self.styles[line].len() > col {\n+            self.styles[line][col] = style;\n+        }\n+    }\n+\n+    pub fn prepend(&mut self, line: usize, string: &str, style: Style) {\n+        self.ensure_lines(line);\n+        let string_len = string.len();\n+\n+        // Push the old content over to make room for new content\n+        for _ in 0..string_len {\n+            self.styles[line].insert(0, Style::NoStyle);\n+            self.text[line].insert(0, ' ');\n+        }\n+\n+        self.puts(line, 0, string, style);\n+    }\n+\n+    pub fn append(&mut self, line: usize, string: &str, style: Style) {\n+        if line >= self.text.len() {\n+            self.puts(line, 0, string, style);\n+        } else {\n+            let col = self.text[line].len();\n+            self.puts(line, col, string, style);\n+        }\n+    }\n+\n+    pub fn num_lines(&self) -> usize {\n+        self.text.len()\n+    }\n+}"}, {"sha": "33cffa8a480137a17a36dffef93a12422ae64065", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -19,8 +19,8 @@ use llvm::SMDiagnosticRef;\n use {CrateTranslation, ModuleTranslation};\n use util::common::time;\n use util::common::path2cstr;\n-use errors::{self, Handler, Level, RenderSpan};\n-use errors::emitter::CoreEmitter;\n+use errors::{self, Handler, Level, DiagnosticBuilder};\n+use errors::emitter::Emitter;\n use syntax_pos::MultiSpan;\n \n use std::collections::HashMap;\n@@ -100,23 +100,23 @@ impl SharedEmitter {\n     }\n }\n \n-impl CoreEmitter for SharedEmitter {\n-    fn emit_message(&mut self,\n-                    _rsp: &RenderSpan,\n-                    msg: &str,\n-                    code: Option<&str>,\n-                    lvl: Level,\n-                    _is_header: bool,\n-                    _show_snippet: bool) {\n+impl Emitter for SharedEmitter {\n+    fn emit(&mut self, db: &DiagnosticBuilder) {\n         self.buffer.lock().unwrap().push(Diagnostic {\n-            msg: msg.to_string(),\n-            code: code.map(|s| s.to_string()),\n-            lvl: lvl,\n+            msg: db.message.to_string(),\n+            code: db.code.clone(),\n+            lvl: db.level,\n         });\n+        for child in &db.children {\n+            self.buffer.lock().unwrap().push(Diagnostic {\n+                msg: child.message.to_string(),\n+                code: None,\n+                lvl: child.level,\n+            });\n+        }\n     }\n }\n \n-\n // On android, we by default compile for armv7 processors. This enables\n // things like double word CAS instructions (rather than emulating them)\n // which are *far* more efficient. This is obviously undesirable in some"}, {"sha": "fc9ae73f5ce7e2ec96a4c584c4e8f652c9b38746", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -131,7 +131,7 @@ pub fn run_core(search_paths: SearchPaths,\n                                                                None,\n                                                                true,\n                                                                false,\n-                                                               codemap.clone());\n+                                                               Some(codemap.clone()));\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();"}, {"sha": "f9d0df9981a1d73bc9e796746aaca850cda0736d", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -77,7 +77,7 @@ pub fn run(input: &str,\n                                                                None,\n                                                                true,\n                                                                false,\n-                                                               codemap.clone());\n+                                                               Some(codemap.clone()));\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n@@ -229,7 +229,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     let codemap = Rc::new(CodeMap::new());\n     let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n                                                 None,\n-                                                codemap.clone(),\n+                                                Some(codemap.clone()),\n                                                 errors::snippet::FormatMode::EnvironmentSelected);\n     let old = io::set_panic(box Sink(data.clone()));\n     let _bomb = Bomb(data.clone(), old.unwrap_or(box io::stdout()));"}, {"sha": "a8aca90e6238daf18f6503aa6f7b7664dd35366e", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 781, "changes": 781, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -827,12 +827,6 @@ impl CodeMapper for CodeMap {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use errors::{Level, CodeSuggestion};\n-    use errors::emitter::EmitterWriter;\n-    use errors::snippet::{SnippetData, RenderedLine, FormatMode};\n-    use std::sync::{Arc, Mutex};\n-    use std::io::{self, Write};\n-    use std::str::from_utf8;\n     use std::rc::Rc;\n \n     #[test]\n@@ -1122,24 +1116,6 @@ mod tests {\n         }\n     }\n \n-    fn splice(start: Span, end: Span) -> Span {\n-        Span {\n-            lo: start.lo,\n-            hi: end.hi,\n-            expn_id: NO_EXPANSION,\n-        }\n-    }\n-\n-    fn make_string(lines: &[RenderedLine]) -> String {\n-        lines.iter()\n-            .flat_map(|rl| {\n-                rl.text.iter()\n-                        .map(|s| &s.text[..])\n-                        .chain(Some(\"\\n\"))\n-            })\n-            .collect()\n-    }\n-\n     fn init_expansion_chain(cm: &CodeMap) -> Span {\n         // Creates an expansion chain containing two recursive calls\n         // root -> expA -> expA -> expB -> expB -> end\n@@ -1219,761 +1195,4 @@ r\"blork2.rs:2:1: 2:12\n \";\n         assert_eq!(sstr, res_str);\n     }\n-\n-    struct Sink(Arc<Mutex<Vec<u8>>>);\n-    impl Write for Sink {\n-        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-            Write::write(&mut *self.0.lock().unwrap(), data)\n-        }\n-        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-    }\n-\n-    // Diagnostic doesn't align properly in span where line number increases by one digit\n-    #[test]\n-    fn test_hilight_suggestion_issue_11715() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())),\n-                                        None,\n-                                        cm.clone(),\n-                                        FormatMode::NewErrorFormat);\n-        let content = \"abcdefg\n-        koksi\n-        line3\n-        line4\n-        cinq\n-        line6\n-        line7\n-        line8\n-        line9\n-        line10\n-        e-l\u00e4-v\u00e4n\n-        tolv\n-        dreizehn\n-        \";\n-        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, content);\n-        let start = file.lines.borrow()[10];\n-        let end = file.lines.borrow()[11];\n-        let sp = mk_sp(start, end);\n-        let lvl = Level::Error;\n-        println!(\"highlight_lines\");\n-        ew.highlight_lines(&sp.into(), lvl).unwrap();\n-        println!(\"done\");\n-        let vec = data.lock().unwrap().clone();\n-        let vec: &[u8] = &vec;\n-        let str = from_utf8(vec).unwrap();\n-        println!(\"r#\\\"\\n{}\\\"#\", str);\n-        assert_eq!(str, &r#\"\n-  --> dummy.txt:11:1\n-   |>\n-11 |>         e-l\u00e4-v\u00e4n\n-   |> ^\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn test_single_span_splice() {\n-        // Test that a `MultiSpan` containing a single span splices a substition correctly\n-        let cm = CodeMap::new();\n-        let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n-        let sp = span_from_selection(inputtext, selection);\n-        let msp: MultiSpan = sp.into();\n-\n-        // check that we are extracting the text we thought we were extracting\n-        assert_eq!(&cm.span_to_snippet(sp).unwrap(), \"BB\\nCCC\\nDDDDD\");\n-\n-        let substitute = \"ZZZZZZ\".to_owned();\n-        let expected = \"bbbbZZZZZZddddd\";\n-        let suggest = CodeSuggestion {\n-            msp: msp,\n-            substitutes: vec![substitute],\n-        };\n-        assert_eq!(suggest.splice_lines(&cm), expected);\n-    }\n-\n-    #[test]\n-    fn test_multi_span_splice() {\n-        // Test that a `MultiSpan` containing multiple spans splices a substition correctly\n-        let cm = CodeMap::new();\n-        let inputtext  = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection1 = \"     \\n      \\n   \\n          \\n ~ \\n\"; // intentionally out of order\n-        let selection2 = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n-        let sp1 = span_from_selection(inputtext, selection1);\n-        let sp2 = span_from_selection(inputtext, selection2);\n-        let msp: MultiSpan = MultiSpan::from_spans(vec![sp1, sp2]);\n-\n-        let expected = \"bbbbZZZZZZddddd\\neXYZe\";\n-        let suggest = CodeSuggestion {\n-            msp: msp,\n-            substitutes: vec![\"ZZZZZZ\".to_owned(),\n-                              \"XYZ\".to_owned()]\n-        };\n-\n-        assert_eq!(suggest.splice_lines(&cm), expected);\n-    }\n-\n-    #[test]\n-    fn test_multispan_highlight() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())),\n-                                          None,\n-                                          cm.clone(),\n-                                          FormatMode::NewErrorFormat);\n-\n-        let inp =       \"_____aaaaaa____bbbbbb__cccccdd_\";\n-        let sp1 =       \"     ~~~~~~                    \";\n-        let sp2 =       \"               ~~~~~~          \";\n-        let sp3 =       \"                       ~~~~~   \";\n-        let sp4 =       \"                          ~~~~ \";\n-        let sp34 =      \"                       ~~~~~~~ \";\n-\n-        let expect_start = &r#\"\n- --> dummy.txt:1:6\n-  |>\n-1 |> _____aaaaaa____bbbbbb__cccccdd_\n-  |>      ^^^^^^    ^^^^^^  ^^^^^^^\n-\"#[1..];\n-\n-        let span = |sp, expected| {\n-            let sp = span_from_selection(inp, sp);\n-            assert_eq!(&cm.span_to_snippet(sp).unwrap(), expected);\n-            sp\n-        };\n-        cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n-        let sp1 = span(sp1, \"aaaaaa\");\n-        let sp2 = span(sp2, \"bbbbbb\");\n-        let sp3 = span(sp3, \"ccccc\");\n-        let sp4 = span(sp4, \"ccdd\");\n-        let sp34 = span(sp34, \"cccccdd\");\n-\n-        let spans = vec![sp1, sp2, sp3, sp4];\n-\n-        let test = |expected, highlight: &mut FnMut()| {\n-            data.lock().unwrap().clear();\n-            highlight();\n-            let vec = data.lock().unwrap().clone();\n-            let actual = from_utf8(&vec[..]).unwrap();\n-            println!(\"actual=\\n{}\", actual);\n-            assert_eq!(actual, expected);\n-        };\n-\n-        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp34]);\n-        test(expect_start, &mut || {\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-        test(expect_start, &mut || {\n-            let msp = MultiSpan::from_spans(spans.clone());\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-    }\n-\n-    #[test]\n-    fn test_huge_multispan_highlight() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())),\n-                                          None,\n-                                          cm.clone(),\n-                                          FormatMode::NewErrorFormat);\n-\n-        let inp = \"aaaaa\\n\\\n-                   aaaaa\\n\\\n-                   aaaaa\\n\\\n-                   bbbbb\\n\\\n-                   ccccc\\n\\\n-                   xxxxx\\n\\\n-                   yyyyy\\n\\\n-                   _____\\n\\\n-                   ddd__eee_\\n\\\n-                   elided\\n\\\n-                   __f_gg\";\n-        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n-\n-        let span = |lo, hi, (off_lo, off_hi)| {\n-            let lines = file.lines.borrow();\n-            let (mut lo, mut hi): (BytePos, BytePos) = (lines[lo], lines[hi]);\n-            lo.0 += off_lo;\n-            hi.0 += off_hi;\n-            mk_sp(lo, hi)\n-        };\n-        let sp0 = span(4, 6, (0, 5));\n-        let sp1 = span(0, 6, (0, 5));\n-        let sp2 = span(8, 8, (0, 3));\n-        let sp3 = span(8, 8, (5, 8));\n-        let sp4 = span(10, 10, (2, 3));\n-        let sp5 = span(10, 10, (4, 6));\n-\n-        let expect0 = &r#\"\n-   --> dummy.txt:5:1\n-    |>\n-5   |> ccccc\n-    |> ^\n-...\n-9   |> ddd__eee_\n-    |> ^^^  ^^^\n-10  |> elided\n-11  |> __f_gg\n-    |>   ^ ^^\n-\"#[1..];\n-\n-        let expect = &r#\"\n-   --> dummy.txt:1:1\n-    |>\n-1   |> aaaaa\n-    |> ^\n-...\n-9   |> ddd__eee_\n-    |> ^^^  ^^^\n-10  |> elided\n-11  |> __f_gg\n-    |>   ^ ^^\n-\"#[1..];\n-\n-        macro_rules! test {\n-            ($expected: expr, $highlight: expr) => ({\n-                data.lock().unwrap().clear();\n-                $highlight();\n-                let vec = data.lock().unwrap().clone();\n-                let actual = from_utf8(&vec[..]).unwrap();\n-                println!(\"actual:\");\n-                println!(\"{}\", actual);\n-                println!(\"expected:\");\n-                println!(\"{}\", $expected);\n-                assert_eq!(&actual[..], &$expected[..]);\n-            });\n-        }\n-\n-        let msp0 = MultiSpan::from_spans(vec![sp0, sp2, sp3, sp4, sp5]);\n-        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp3, sp4, sp5]);\n-\n-        test!(expect0, || {\n-            diag.highlight_lines(&msp0, Level::Error).unwrap();\n-        });\n-        test!(expect, || {\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-    }\n-\n-    #[test]\n-    fn tab() {\n-        let file_text = \"\n-fn foo() {\n-\\tbar;\n-}\n-\";\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_bar = cm.span_substr(&foo, file_text, \"bar\", 0);\n-\n-        let mut snippet = SnippetData::new(cm, Some(span_bar), FormatMode::NewErrorFormat);\n-        snippet.push(span_bar, true, None);\n-\n-        let lines = snippet.render_lines();\n-        let text = make_string(&lines);\n-        assert_eq!(&text[..], &\"\n- --> foo.rs:3:2\n-  |>\n-3 |> \\tbar;\n-  |> \\t^^^\n-\"[1..]);\n-    }\n-\n-    #[test]\n-    fn one_line() {\n-        let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n-        let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n-\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n-        snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n-        snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=\\n{}\", text);\n-        assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     ---      ---                - previous borrow ends here\n-  |>     |        |\n-  |>     |        error occurs here\n-  |>     previous borrow of `vec` occurs here\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn two_files() {\n-        let file_text_foo = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let file_text_bar = r#\"\n-fn bar() {\n-    // these blank links here\n-    // serve to ensure that the line numbers\n-    // from bar.rs\n-    // require more digits\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-    vec.push();\n-\n-    // this line will get elided\n-\n-    vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo_map = cm.new_filemap_and_lines(\"foo.rs\", None, file_text_foo);\n-        let span_foo_vec0 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 0);\n-        let span_foo_vec1 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 1);\n-        let span_foo_semi = cm.span_substr(&foo_map, file_text_foo, \";\", 0);\n-\n-        let bar_map = cm.new_filemap_and_lines(\"bar.rs\", None, file_text_bar);\n-        let span_bar_vec0 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 0);\n-        let span_bar_vec1 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 1);\n-        let span_bar_semi = cm.span_substr(&bar_map, file_text_bar, \";\", 0);\n-\n-        let mut snippet = SnippetData::new(cm, Some(span_foo_vec1), FormatMode::NewErrorFormat);\n-        snippet.push(span_foo_vec0, false, Some(format!(\"a\")));\n-        snippet.push(span_foo_vec1, true, Some(format!(\"b\")));\n-        snippet.push(span_foo_semi, false, Some(format!(\"c\")));\n-        snippet.push(span_bar_vec0, false, Some(format!(\"d\")));\n-        snippet.push(span_bar_vec1, false, Some(format!(\"e\")));\n-        snippet.push(span_bar_semi, false, Some(format!(\"f\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=\\n{}\", text);\n-\n-        // Note that the `|>` remain aligned across both files:\n-        assert_eq!(&text[..], &r#\"\n-   --> foo.rs:3:14\n-    |>\n-3   |>     vec.push(vec.pop().unwrap());\n-    |>     ---      ^^^                - c\n-    |>     |        |\n-    |>     |        b\n-    |>     a\n-   ::: bar.rs\n-    |>\n-17  |>     vec.push();\n-    |>     ---       - f\n-    |>     |\n-    |>     d\n-...\n-21  |>     vec.pop().unwrap());\n-    |>     --- e\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn multi_line() {\n-        let file_text = r#\"\n-fn foo() {\n-    let name = find_id(&data, 22).unwrap();\n-\n-    // Add one more item we forgot to the vector. Silly us.\n-    data.push(Data { name: format!(\"Hera\"), id: 66 });\n-\n-    // Print everything out.\n-    println!(\"Name: {:?}\", name);\n-    println!(\"Data: {:?}\", data);\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_data0 = cm.span_substr(&foo, file_text, \"data\", 0);\n-        let span_data1 = cm.span_substr(&foo, file_text, \"data\", 1);\n-        let span_rbrace = cm.span_substr(&foo, file_text, \"}\", 3);\n-\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span_data0, false, Some(format!(\"immutable borrow begins here\")));\n-        snippet.push(span_data1, false, Some(format!(\"mutable borrow occurs here\")));\n-        snippet.push(span_rbrace, false, Some(format!(\"immutable borrow ends here\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=\\n{}\", text);\n-        assert_eq!(&text[..], &r#\"\n-   ::: foo.rs\n-    |>\n-3   |>     let name = find_id(&data, 22).unwrap();\n-    |>                         ---- immutable borrow begins here\n-...\n-6   |>     data.push(Data { name: format!(\"Hera\"), id: 66 });\n-    |>     ---- mutable borrow occurs here\n-...\n-11  |> }\n-    |> - immutable borrow ends here\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn overlapping() {\n-        let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span0 = cm.span_substr(&foo, file_text, \"vec.push\", 0);\n-        let span1 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-        let span2 = cm.span_substr(&foo, file_text, \"ec.push\", 0);\n-        let span3 = cm.span_substr(&foo, file_text, \"unwrap\", 0);\n-\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span0, false, Some(format!(\"A\")));\n-        snippet.push(span1, false, Some(format!(\"B\")));\n-        snippet.push(span2, false, Some(format!(\"C\")));\n-        snippet.push(span3, false, Some(format!(\"D\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-        assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     --------           ------ D\n-  |>     ||\n-  |>     |C\n-  |>     A\n-  |>     B\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn one_line_out_of_order() {\n-        let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n-        let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n-\n-        // intentionally don't push the snippets left to right\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n-        snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n-        snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-        assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     ---      ---                - previous borrow ends here\n-  |>     |        |\n-  |>     |        error occurs here\n-  |>     previous borrow of `vec` occurs here\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn elide_unnecessary_lines() {\n-        let file_text = r#\"\n-fn foo() {\n-    let mut vec = vec![0, 1, 2];\n-    let mut vec2 = vec;\n-    vec2.push(3);\n-    vec2.push(4);\n-    vec2.push(5);\n-    vec2.push(6);\n-    vec.push(7);\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 3);\n-        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 8);\n-\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span_vec0, false, Some(format!(\"`vec` moved here because it \\\n-            has type `collections::vec::Vec<i32>`\")));\n-        snippet.push(span_vec1, false, Some(format!(\"use of moved value: `vec`\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-        let text: String = make_string(&lines);\n-        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-        assert_eq!(&text[..], &r#\"\n-   ::: foo.rs\n-    |>\n-4   |>     let mut vec2 = vec;\n-    |>                    --- `vec` moved here because it has type `collections::vec::Vec<i32>`\n-...\n-9   |>     vec.push(7);\n-    |>     --- use of moved value: `vec`\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn spans_without_labels() {\n-        let file_text = r#\"\n-fn foo() {\n-    let mut vec = vec![0, 1, 2];\n-    let mut vec2 = vec;\n-    vec2.push(3);\n-    vec2.push(4);\n-    vec2.push(5);\n-    vec2.push(6);\n-    vec.push(7);\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-        for i in 0..4 {\n-            let span_veci = cm.span_substr(&foo, file_text, \"vec\", i);\n-            snippet.push(span_veci, false, None);\n-        }\n-\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"text=&r#\\\"\\n{}\\n\\\"#[1..]\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     let mut vec = vec![0, 1, 2];\n-  |>             ---   ---\n-4 |>     let mut vec2 = vec;\n-  |>             ---    ---\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_long_selection() {\n-        let file_text = r#\"\n-impl SomeTrait for () {\n-    fn foo(x: u32) {\n-        // impl 1\n-        // impl 2\n-        // impl 3\n-    }\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-        let fn_span = cm.span_substr(&foo, file_text, \"fn\", 0);\n-        let rbrace_span = cm.span_substr(&foo, file_text, \"}\", 0);\n-        snippet.push(splice(fn_span, rbrace_span), false, None);\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     fn foo(x: u32) {\n-  |>     -\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_overlap_label() {\n-        // Test that we don't put `x_span` to the right of its highlight,\n-        // since there is another highlight that overlaps it.\n-\n-        let file_text = r#\"\n-    fn foo(x: u32) {\n-    }\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-        let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x: u32)\", 0);\n-        let x_span = cm.span_substr(&foo, file_text, \"x\", 0);\n-        snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n-        snippet.push(x_span, false, Some(format!(\"x_span\")));\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-2 |>     fn foo(x: u32) {\n-  |>     --------------\n-  |>     |      |\n-  |>     |      x_span\n-  |>     fn_span\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_overlap_label2() {\n-        // Test that we don't put `x_span` to the right of its highlight,\n-        // since there is another highlight that overlaps it. In this\n-        // case, the overlap is only at the beginning, but it's still\n-        // better to show the beginning more clearly.\n-\n-        let file_text = r#\"\n-    fn foo(x: u32) {\n-    }\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-        let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x\", 0);\n-        let x_span = cm.span_substr(&foo, file_text, \"x: u32)\", 0);\n-        snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n-        snippet.push(x_span, false, Some(format!(\"x_span\")));\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-2 |>     fn foo(x: u32) {\n-  |>     --------------\n-  |>     |      |\n-  |>     |      x_span\n-  |>     fn_span\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_overlap_label3() {\n-        // Test that we don't put `x_span` to the right of its highlight,\n-        // since there is another highlight that overlaps it. In this\n-        // case, the overlap is only at the beginning, but it's still\n-        // better to show the beginning more clearly.\n-\n-        let file_text = r#\"\n-    fn foo() {\n-       let closure = || {\n-           inner\n-       };\n-    }\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-\n-        let closure_span = {\n-            let closure_start_span = cm.span_substr(&foo, file_text, \"||\", 0);\n-            let closure_end_span = cm.span_substr(&foo, file_text, \"}\", 0);\n-            splice(closure_start_span, closure_end_span)\n-        };\n-\n-        let inner_span = cm.span_substr(&foo, file_text, \"inner\", 0);\n-\n-        snippet.push(closure_span, false, Some(format!(\"foo\")));\n-        snippet.push(inner_span, false, Some(format!(\"bar\")));\n-\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>        let closure = || {\n-  |>                      - foo\n-4 |>            inner\n-  |>            ----- bar\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_empty() {\n-        // In one of the unit tests, we found that the parser sometimes\n-        // gives empty spans, and in particular it supplied an EOF span\n-        // like this one, which points at the very end. We want to\n-        // fallback gracefully in this case.\n-\n-        let file_text = r#\"\n-fn main() {\n-    struct Foo;\n-\n-    impl !Sync for Foo {}\n-\n-    unsafe impl Send for &'static Foo {\n-    // error: cross-crate traits with a default impl, like `core::marker::Send`,\n-    //        can only be implemented for a struct/enum type, not\n-    //        `&'static Foo`\n-}\"#;\n-\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut rbrace_span = cm.span_substr(&foo, file_text, \"}\", 1);\n-        rbrace_span.lo = rbrace_span.hi;\n-\n-        let mut snippet = SnippetData::new(cm.clone(),\n-                                           Some(rbrace_span),\n-                                           FormatMode::NewErrorFormat);\n-        snippet.push(rbrace_span, false, None);\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n-  --> foo.rs:11:2\n-   |>\n-11 |> }\n-   |>  -\n-\"#[1..]);\n-    }\n }"}, {"sha": "a40c30b3e3397fe61d6175a21e5ab9f56bd8bbad", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -22,7 +22,7 @@\n use codemap::CodeMap;\n use syntax_pos::{self, MacroBacktrace, Span, SpanLabel, MultiSpan};\n use errors::registry::Registry;\n-use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion, CodeMapper};\n+use errors::{DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion, CodeMapper};\n use errors::emitter::Emitter;\n \n use std::rc::Rc;\n@@ -53,14 +53,7 @@ impl JsonEmitter {\n }\n \n impl Emitter for JsonEmitter {\n-    fn emit(&mut self, span: &MultiSpan, msg: &str, code: Option<&str>, level: Level) {\n-        let data = Diagnostic::new(span, msg, code, level, self);\n-        if let Err(e) = writeln!(&mut self.dst, \"{}\", as_json(&data)) {\n-            panic!(\"failed to print diagnostics: {:?}\", e);\n-        }\n-    }\n-\n-    fn emit_struct(&mut self, db: &DiagnosticBuilder) {\n+    fn emit(&mut self, db: &DiagnosticBuilder) {\n         let data = Diagnostic::from_diagnostic_builder(db, self);\n         if let Err(e) = writeln!(&mut self.dst, \"{}\", as_json(&data)) {\n             panic!(\"failed to print diagnostics: {:?}\", e);\n@@ -146,22 +139,6 @@ struct DiagnosticCode {\n }\n \n impl<'a> Diagnostic<'a> {\n-    fn new(msp: &MultiSpan,\n-           msg: &'a str,\n-           code: Option<&str>,\n-           level: Level,\n-           je: &JsonEmitter)\n-           -> Diagnostic<'a> {\n-        Diagnostic {\n-            message: msg,\n-            code: DiagnosticCode::map_opt_string(code.map(|c| c.to_owned()), je),\n-            level: level.to_str(),\n-            spans: DiagnosticSpan::from_multispan(msp, je),\n-            children: vec![],\n-            rendered: None,\n-        }\n-    }\n-\n     fn from_diagnostic_builder<'c>(db: &'c DiagnosticBuilder,\n                                    je: &JsonEmitter)\n                                    -> Diagnostic<'c> {"}, {"sha": "5ea1d6be9fec9903b3155b7faf60cafe2efe240d", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -1686,7 +1686,7 @@ mod tests {\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n                                                 None,\n-                                                cm,\n+                                                Some(cm),\n                                                 errors::snippet::FormatMode::EnvironmentSelected);\n         errors::Handler::with_emitter(true, false, Box::new(emitter))\n     }"}, {"sha": "6af4d95e888ac71006f7a72bf050da0ef5816c53", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -50,7 +50,11 @@ pub struct ParseSess {\n impl ParseSess {\n     pub fn new() -> ParseSess {\n         let cm = Rc::new(CodeMap::new());\n-        let handler = Handler::with_tty_emitter(ColorConfig::Auto, None, true, false, cm.clone());\n+        let handler = Handler::with_tty_emitter(ColorConfig::Auto,\n+                                                None,\n+                                                true,\n+                                                false,\n+                                                Some(cm.clone()));\n         ParseSess::with_span_handler(handler, cm)\n     }\n "}, {"sha": "faf6a17a150459fb62cd380b952340d5b90b12d5", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -26,7 +26,7 @@ use std::rc::Rc;\n \n use codemap::{self, CodeMap, ExpnInfo, NameAndSpan, MacroAttribute};\n use errors;\n-use errors::snippet::{RenderedLine, SnippetData};\n+use errors::snippet::{SnippetData};\n use config;\n use entry::{self, EntryPointType};\n use ext::base::{ExtCtxt, DummyMacroLoader};"}, {"sha": "7dfe19452a2a933a64cdd849e2a21ce535880f50", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -568,7 +568,7 @@ impl Sub for CharPos {\n //\n \n /// A source code location used for error reporting\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct Loc {\n     /// Information about the original source\n     pub file: Rc<FileMap>,"}, {"sha": "c78a586763429ebc12e5e5417edc859015036ef5", "filename": "src/test/ui/codemap_tests/empty_span.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+#![feature(optin_builtin_traits)]\n+fn main() {\n+    struct Foo;\n+\n+    impl !Sync for Foo {}\n+\n+    unsafe impl Send for &'static Foo { }\n+}"}, {"sha": "f3e04ef02409b86af8f99f942db21804f974d864", "filename": "src/test/ui/codemap_tests/empty_span.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.stderr?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,8 @@\n+error[E0321]: cross-crate traits with a default impl, like `std::marker::Send`, can only be implemented for a struct/enum type, not `&'static main::Foo`\n+  --> $DIR/empty_span.rs:18:5\n+   |\n+18 |     unsafe impl Send for &'static Foo { }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "b06832c7628ed9f4df3c92aa4d5256020683c394", "filename": "src/test/ui/codemap_tests/huge_multispan_highlight.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+\n+fn main() {\n+    let x = \"foo\";\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    let y = &mut x;\n+}\n+\n+\n+"}, {"sha": "6a898a434778e2af416723401227d83f02bc805e", "filename": "src/test/ui/codemap_tests/huge_multispan_highlight.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,11 @@\n+error: cannot borrow immutable local variable `x` as mutable\n+   --> $DIR/huge_multispan_highlight.rs:100:18\n+    |\n+14  |     let x = \"foo\";\n+    |         - use `mut x` here to make mutable\n+...\n+100 |     let y = &mut x;\n+    |                  ^ cannot borrow mutably\n+\n+error: aborting due to previous error\n+"}, {"sha": "7ea497a25c8321f81aac9ecf610a8e036d306ae7", "filename": "src/test/ui/codemap_tests/issue-11715.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+fn main() {\n+    let mut x = \"foo\";\n+    let y = &mut x;\n+    let z = &mut x;\n+}\n+\n+\n+"}, {"sha": "4947cbedd200e45ec424e508881480505c313b57", "filename": "src/test/ui/codemap_tests/issue-11715.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.stderr?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,12 @@\n+error[E0499]: cannot borrow `x` as mutable more than once at a time\n+   --> $DIR/issue-11715.rs:100:18\n+    |\n+99  |     let y = &mut x;\n+    |                  - first mutable borrow occurs here\n+100 |     let z = &mut x;\n+    |                  ^ second mutable borrow occurs here\n+101 | }\n+    | - first borrow ends here\n+\n+error: aborting due to previous error\n+"}, {"sha": "2a5ee6f8711ef92846a867bce0cb20fbabbcb94a", "filename": "src/test/ui/codemap_tests/one_line.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+\n+fn main() {\n+    let mut v = vec![Some(\"foo\"), Some(\"bar\")];\n+    v.push(v.pop().unwrap());\n+}"}, {"sha": "8f80489ea1aeb02539dc589d40bc4c4dc1b1a630", "filename": "src/test/ui/codemap_tests/one_line.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,11 @@\n+error[E0499]: cannot borrow `v` as mutable more than once at a time\n+  --> $DIR/one_line.rs:15:12\n+   |\n+15 |     v.push(v.pop().unwrap());\n+   |     -      ^               - first borrow ends here\n+   |     |      |\n+   |     |      second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "5a90852392c081263c56f81c48c3b368e9e6bc24", "filename": "src/test/ui/codemap_tests/overlapping_spans.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+#[derive(Debug)]\n+struct Foo { }\n+\n+struct S {f:String}\n+impl Drop for S {\n+    fn drop(&mut self) { println!(\"{}\", self.f); }\n+}\n+\n+fn main() {\n+    match (S {f:\"foo\".to_string()}) {\n+        S {f:_s} => {}\n+    }\n+}"}, {"sha": "cbcf154eaba50d79473f4a103ab3feb145e52614", "filename": "src/test/ui/codemap_tests/overlapping_spans.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.stderr?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,11 @@\n+error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n+  --> $DIR/overlapping_spans.rs:22:9\n+   |\n+22 |         S {f:_s} => {}\n+   |         ^^^^^--^\n+   |         |    |\n+   |         |    hint: to prevent move, use `ref _s` or `ref mut _s`\n+   |         cannot move out of here\n+\n+error: aborting due to previous error\n+"}, {"sha": "aaaee8c5577fe02700876f1d659f324215c55e19", "filename": "src/test/ui/codemap_tests/tab.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+// ignore-tidy-tab\n+fn main() {\n+\tbar;\n+}\n+"}, {"sha": "543c02fb701f35507034ad505ca50eac76cd3fa0", "filename": "src/test/ui/codemap_tests/tab.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,8 @@\n+error[E0425]: unresolved name `bar`\n+  --> $DIR/tab.rs:14:2\n+   |\n+14 | \\tbar;\n+   | \\t^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "53e240e8c4738ca494e26fffa9d31891955e3f5e", "filename": "src/test/ui/codemap_tests/two_files.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+include!(\"two_files_data.rs\");\n+\n+struct Baz { }\n+\n+impl Bar for Baz { }\n+\n+fn main() { }"}, {"sha": "6c388cd69395b272b7dc7d224e8a1b9ac708d09d", "filename": "src/test/ui/codemap_tests/two_files.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,13 @@\n+error[E0404]: `Bar` is not a trait\n+  --> $DIR/two_files.rs:16:6\n+   |\n+16 | impl Bar for Baz { }\n+   |      ^^^ `Bar` is not a trait\n+   | \n+  ::: $DIR/two_files_data.rs\n+   |\n+15 | type Bar = Foo;\n+   | --------------- type aliases cannot be used for traits\n+\n+error: cannot continue compilation due to previous error\n+"}, {"sha": "412c40f8e811b9e52d54a41f35c4af45371cc213", "filename": "src/test/ui/codemap_tests/two_files_data.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files_data.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+// ignore-test\n+trait Foo { }\n+\n+type Bar = Foo;\n+"}, {"sha": "19660133d62228b861c0ba3a6acc0c01bf26f00e", "filename": "src/test/ui/codemap_tests/unicode.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.rs?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}\n+\n+fn main() { }"}, {"sha": "178bee7b7f3ab62b388532eecadba7ae57bd0bb9", "filename": "src/test/ui/codemap_tests/unicode.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -0,0 +1,8 @@\n+error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n+  --> $DIR/unicode.rs:12:8\n+   |\n+12 | extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}\n+   |        ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "ff6920d28ccf90a3647df517a6d4dae074feecdd", "filename": "src/test/ui/mismatched_types/issue-26480.stderr", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -1,15 +1,16 @@\n-error: mismatched types [--explain E0308]\n+error[E0308]: mismatched types\n   --> $DIR/issue-26480.rs:27:19\n-   |>\n-27 |>                   $arr.len() * size_of($arr[0]));\n-   |>                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected u64, found usize\n-$DIR/issue-26480.rs:38:5: 38:19: note: in this expansion of write! (defined in $DIR/issue-26480.rs)\n+   |\n+27 |                   $arr.len() * size_of($arr[0]));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected u64, found usize\n+$DIR/issue-26480.rs:38:5: 38:19 note: in this expansion of write! (defined in $DIR/issue-26480.rs)\n \n error: non-scalar cast: `_` as `()`\n   --> $DIR/issue-26480.rs:33:19\n-   |>\n-33 |>     ($x:expr) => ($x as ())\n-   |>                   ^^^^^^^^\n-$DIR/issue-26480.rs:39:5: 39:14: note: in this expansion of cast! (defined in $DIR/issue-26480.rs)\n+   |\n+33 |     ($x:expr) => ($x as ())\n+   |                   ^^^^^^^^\n+$DIR/issue-26480.rs:39:5: 39:14 note: in this expansion of cast! (defined in $DIR/issue-26480.rs)\n \n error: aborting due to 2 previous errors\n+"}, {"sha": "2903aa08c0a91e744d5ff55bb56028104121df10", "filename": "src/test/ui/mismatched_types/main.stderr", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ed6068d3e528167e95b684d086a39e099fd26f1/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr?ref=7ed6068d3e528167e95b684d086a39e099fd26f1", "patch": "@@ -1,9 +1,11 @@\n-error: mismatched types [--explain E0308]\n+error[E0308]: mismatched types\n   --> $DIR/main.rs:14:18\n-   |>\n-14 |>     let x: u32 = (\n-   |>                  ^ expected u32, found ()\n-note: expected type `u32`\n-note:    found type `()`\n+   |\n+14 |     let x: u32 = (\n+   |                  ^ expected u32, found ()\n+   |\n+   = note: expected type `u32`\n+   = note:    found type `()`\n \n error: aborting due to previous error\n+"}]}