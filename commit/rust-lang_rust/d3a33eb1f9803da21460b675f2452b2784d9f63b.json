{"sha": "d3a33eb1f9803da21460b675f2452b2784d9f63b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYTMzZWIxZjk4MDNkYTIxNDYwYjY3NWYyNDUyYjI3ODRkOWY2M2I=", "commit": {"author": {"name": "Daniel Henry-Mantilla", "email": "daniel.henry.mantilla@gmail.com", "date": "2020-10-14T19:12:03Z"}, "committer": {"name": "Daniel Henry-Mantilla", "email": "daniel.henry.mantilla@gmail.com", "date": "2021-01-06T14:13:38Z"}, "message": "Fix type/value namespace clashes + test for that", "tree": {"sha": "747ea96975d539aae6c64351768595e17c4e725c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/747ea96975d539aae6c64351768595e17c4e725c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3a33eb1f9803da21460b675f2452b2784d9f63b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3a33eb1f9803da21460b675f2452b2784d9f63b", "html_url": "https://github.com/rust-lang/rust/commit/d3a33eb1f9803da21460b675f2452b2784d9f63b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3a33eb1f9803da21460b675f2452b2784d9f63b/comments", "author": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "committer": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d03870882aa05fc4c600afa3585251f54d299c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d03870882aa05fc4c600afa3585251f54d299c4", "html_url": "https://github.com/rust-lang/rust/commit/7d03870882aa05fc4c600afa3585251f54d299c4"}], "stats": {"total": 129, "additions": 85, "deletions": 44}, "files": [{"sha": "ebad35f4e550ec4981518fa9f438e8bd4227a48d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 38, "deletions": 42, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d3a33eb1f9803da21460b675f2452b2784d9f63b/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3a33eb1f9803da21460b675f2452b2784d9f63b/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=d3a33eb1f9803da21460b675f2452b2784d9f63b", "patch": "@@ -74,50 +74,46 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // well (_e.g._, `Copy`), these are wrongly bundled in there too, so we need to fix that by\n         // moving them back to their correct locations.\n         krate.exported_macros.iter().for_each(|def| {\n-            /// A return value of `None` signifies a fallback to the default behavior (locating\n-            /// the macro at the root of the crate).\n-            fn containing_mod_of_macro<'module, 'hir>(\n-                def: &'_ rustc_hir::MacroDef<'_>,\n-                tcx: TyCtxt<'_>,\n-                top_level_module: &'module mut Module<'hir>,\n-            ) -> Option<&'module mut Module<'hir>> {\n-                // The `def` of a macro in `exported_macros` should correspond to either:\n-                //  - a `#[macro-export] macro_rules!` macro,\n-                //  - a built-in `derive` (or attribute) macro such as the ones in `::core`,\n-                //  - a `pub macro`.\n-                // Only the last two need to be fixed, thus:\n-                if def.ast.macro_rules {\n-                    return None;\n-                }\n-                /* Because of #77828 we cannot do the simpler:\n-                let macro_parent_module = tcx.def_path(tcx.parent_module(def.hir_id).to_def_id());\n-                // and instead have to do: */\n-                let macro_parent_module = tcx.def_path({\n-                    use rustc_middle::ty::DefIdTree;\n-                    tcx.parent(tcx.hir().local_def_id(def.hir_id).to_def_id())?\n-                });\n-                // HACK: rustdoc has no way to lookup `doctree::Module`s by their HirId. Instead,\n-                // lookup the module by its name, by looking at each path segment one at a time.\n-                // WARNING: this will probably break in the presence of re-exports or shadowing.\n-                let mut cur_mod = top_level_module;\n-                for path_segment in macro_parent_module.data {\n-                    let path_segment = path_segment.to_string();\n-                    cur_mod = cur_mod.mods.iter_mut().find(|module| {\n-                        matches!(\n-                            module.name, Some(symbol)\n-                            if symbol.with(|mod_name| mod_name == path_segment)\n-                        )\n-                    })?;\n-                }\n-                Some(cur_mod)\n+            let visit_macro = || self.visit_local_macro(def, None);\n+            // The `def` of a macro in `exported_macros` should correspond to either:\n+            //  - a `#[macro-export] macro_rules!` macro,\n+            //  - a built-in `derive` (or attribute) macro such as the ones in `::core`,\n+            //  - a `pub macro`.\n+            // Only the last two need to be fixed, thus:\n+            if def.ast.macro_rules {\n+                top_level_module.macros.push(visit_macro());\n+                return;\n             }\n-\n-            if let Some(module) = containing_mod_of_macro(def, self.cx.tcx, &mut top_level_module) {\n-                &mut module.macros\n-            } else {\n-                &mut top_level_module.macros\n+            let tcx = self.cx.tcx;\n+            /* Because of #77828 we cannot do the simpler:\n+            let macro_parent_module = tcx.def_path(tcx.parent_module(def.hir_id).to_def_id());\n+            // and instead have to do: */\n+            let macro_parent_module = tcx.def_path({\n+                use rustc_middle::ty::DefIdTree;\n+                tcx.parent(tcx.hir().local_def_id(def.hir_id).to_def_id()).unwrap()\n+            });\n+            // HACK: rustdoc has no way to lookup `doctree::Module`s by their HirId. Instead,\n+            // lookup the module by its name, by looking at each path segment one at a time.\n+            let mut cur_mod = &mut top_level_module;\n+            for path_segment in macro_parent_module.data {\n+                let path_segment_ty_ns = match path_segment.data {\n+                    rustc_hir::definitions::DefPathData::TypeNs(symbol) => symbol,\n+                    _ => {\n+                        // If the path segment is not from the type namespace\n+                        // (_e.g._, it can be from a value namespace in the case of `f::` in:\n+                        // `fn f() { pub macro m() {} }`\n+                        // then the item is not accessible, and should thus act as if it didn't\n+                        // exist (unless \"associated macros\" (inside an `impl`) were a thing\u2026).\n+                        return;\n+                    }\n+                };\n+                cur_mod = cur_mod\n+                    .mods\n+                    .iter_mut()\n+                    .find(|module| module.name == Some(path_segment_ty_ns))\n+                    .unwrap();\n             }\n-            .push(self.visit_local_macro(def, None));\n+            cur_mod.macros.push(visit_macro());\n         });\n \n         self.cx.renderinfo.get_mut().exact_paths = self.exact_paths;"}, {"sha": "fa987689ec650b3936e199dad1fae151e83fa761", "filename": "src/test/rustdoc/auxiliary/macro_pub_in_module.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d3a33eb1f9803da21460b675f2452b2784d9f63b/src%2Ftest%2Frustdoc%2Fauxiliary%2Fmacro_pub_in_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3a33eb1f9803da21460b675f2452b2784d9f63b/src%2Ftest%2Frustdoc%2Fauxiliary%2Fmacro_pub_in_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fmacro_pub_in_module.rs?ref=d3a33eb1f9803da21460b675f2452b2784d9f63b", "patch": "@@ -0,0 +1,13 @@\n+// edition:2018\n+\n+#![feature(decl_macro)]\n+#![crate_name = \"external_crate\"]\n+\n+pub mod some_module {\n+    /* == Make sure the logic is not affected by a re-export == */\n+    mod private {\n+        pub macro external_macro() {}\n+    }\n+    // @has external_crate/some_module/macro.external_macro.html\n+    pub use private::external_macro;\n+}"}, {"sha": "7d92246279fb6aed1abf2042d0a10fb05dca72f8", "filename": "src/test/rustdoc/macro_pub_in_module.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d3a33eb1f9803da21460b675f2452b2784d9f63b/src%2Ftest%2Frustdoc%2Fmacro_pub_in_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3a33eb1f9803da21460b675f2452b2784d9f63b/src%2Ftest%2Frustdoc%2Fmacro_pub_in_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro_pub_in_module.rs?ref=d3a33eb1f9803da21460b675f2452b2784d9f63b", "patch": "@@ -1,11 +1,18 @@\n+// aux-build:macro_pub_in_module.rs\n+// edition:2018\n+// build-aux-docs\n+// @has external_crate/some_module/macro.external_macro.html\n+\n //! See issue #74355\n #![feature(decl_macro, no_core, rustc_attrs)]\n #![crate_name = \"krate\"]\n #![no_core]\n \n+extern crate external_crate;\n+\n pub mod inner {\n-    // @has krate/inner/macro.my_macro.html\n-    pub macro my_macro() {}\n+    // @has krate/inner/macro.raw_const.html\n+    pub macro raw_const() {}\n \n     // @has krate/inner/macro.test.html\n     #[rustc_builtin_macro]\n@@ -14,4 +21,29 @@ pub mod inner {\n     // @has krate/inner/macro.Clone.html\n     #[rustc_builtin_macro]\n     pub macro Clone($item:item) {}\n+\n+    // Make sure the logic is not affected by a re-export.\n+    mod private {\n+        pub macro m() {}\n+    }\n+    // @has krate/inner/macro.renamed.html\n+    pub use private::m as renamed;\n+\n+    // @has krate/inner/macro.external_macro.html\n+    pub use ::external_crate::some_module::external_macro;\n+}\n+\n+// Namespaces: Make sure the logic does not mix up a function name with a module name\u2026\n+fn both_fn_and_mod() {\n+    pub macro m() {}\n+}\n+pub mod both_fn_and_mod {\n+    // @!has krate/both_fn_and_mod/macro.m.html\n+}\n+\n+const __: () = {\n+    pub macro m() {}\n+};\n+pub mod __ {\n+    // @!has krate/__/macro.m.html\n }"}]}