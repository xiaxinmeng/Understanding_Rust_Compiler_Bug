{"sha": "450263de4a93e7dd4eb863c8f4b98fc780b9c385", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MDI2M2RlNGE5M2U3ZGQ0ZWI4NjNjOGY0Yjk4ZmM3ODBiOWMzODU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-10-17T13:13:12Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-10-21T16:32:36Z"}, "message": "Tests for method resolution in the face of various ambiguities or non-ambiguities. These\nare mostly new tests though I also revamped (and renamed) some of the existing tests.", "tree": {"sha": "d745e5466c3a1cf890a8213ff5160e14abcc591f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d745e5466c3a1cf890a8213ff5160e14abcc591f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/450263de4a93e7dd4eb863c8f4b98fc780b9c385", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/450263de4a93e7dd4eb863c8f4b98fc780b9c385", "html_url": "https://github.com/rust-lang/rust/commit/450263de4a93e7dd4eb863c8f4b98fc780b9c385", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/450263de4a93e7dd4eb863c8f4b98fc780b9c385/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e09fc0370188eff0bd3e6f27f72ba4de0d1a6c24", "url": "https://api.github.com/repos/rust-lang/rust/commits/e09fc0370188eff0bd3e6f27f72ba4de0d1a6c24", "html_url": "https://github.com/rust-lang/rust/commit/e09fc0370188eff0bd3e6f27f72ba4de0d1a6c24"}], "stats": {"total": 217, "additions": 204, "deletions": 13}, "files": [{"sha": "e5c3da10df8e94b6966d59505e3aef831b20afcb", "filename": "src/test/compile-fail/method-ambig-one-trait-coerce.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-coerce.rs?ref=450263de4a93e7dd4eb863c8f4b98fc780b9c385", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that when we pick a trait based on coercion, versus subtyping,\n+// we consider all possible coercions equivalent and don't try to pick\n+// a best one.\n+\n+trait Object { }\n+\n+trait foo {\n+    fn foo(self) -> int;\n+}\n+\n+impl foo for Box<Object+'static> {\n+    fn foo(self) -> int {1}\n+}\n+\n+impl foo for Box<Object+Send> {\n+    fn foo(self) -> int {2}\n+}\n+\n+fn test1(x: Box<Object+Send+Sync>) {\n+    // Ambiguous because we could coerce to either impl:\n+    x.foo(); //~ ERROR E0034\n+}\n+\n+fn test2(x: Box<Object+Send>) {\n+    // Not ambiguous because it is a precise match:\n+    x.foo();\n+}\n+\n+fn test3(x: Box<Object+'static>) {\n+    // Not ambiguous because it is a precise match:\n+    x.foo();\n+}\n+\n+fn main() { }"}, {"sha": "e211db2dcd2967de9ed64ead385b5f2e46e1496a", "filename": "src/test/compile-fail/method-ambig-one-trait-unknown-int-type.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-unknown-int-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-unknown-int-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-unknown-int-type.rs?ref=450263de4a93e7dd4eb863c8f4b98fc780b9c385", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we invoking `foo()` successfully resolves to the trait `foo`\n+// (prompting the mismatched types error) but does not influence the choice\n+// of what kind of `Vec` we have, eventually leading to a type error.\n+\n+trait foo {\n+    fn foo(&self) -> int;\n+}\n+\n+impl foo for Vec<uint> {\n+    fn foo(&self) -> int {1}\n+}\n+\n+impl foo for Vec<int> {\n+    fn foo(&self) -> int {2}\n+}\n+\n+// This is very hokey: we have heuristics to suppress messages about\n+// type annotations required. But placing these two bits of code into\n+// distinct functions, in this order, causes us to print out both\n+// errors I'd like to see.\n+\n+fn m1() {\n+    // we couldn't infer the type of the vector just based on calling foo()...\n+    let mut x = Vec::new(); //~ ERROR type annotations required\n+    x.foo();\n+}\n+\n+fn m2() {\n+    let mut x = Vec::new();\n+\n+    // ...but we still resolved `foo()` to the trait and hence know the return type.\n+    let y: uint = x.foo(); //~ ERROR mismatched types\n+}\n+\n+fn main() { }"}, {"sha": "30e635149c442683895d3ae8be7c0d0746203800", "filename": "src/test/compile-fail/method-ambig-two-traits-cross-crate.rs", "status": "renamed", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-cross-crate.rs?ref=450263de4a93e7dd4eb863c8f4b98fc780b9c385", "patch": "@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test an ambiguity scenario where one copy of the method is available\n+// from a trait imported from another crate.\n+\n // aux-build:ambig_impl_2_lib.rs\n extern crate ambig_impl_2_lib;\n use ambig_impl_2_lib::me;\n trait me2 {\n     fn me(&self) -> uint;\n }\n-impl me2 for uint { fn me(&self) -> uint { *self } } //~ NOTE is `uint.me2::me`\n-fn main() { 1u.me(); } //~ ERROR multiple applicable methods in scope\n-//~^ NOTE is `ambig_impl_2_lib::uint.me::me`\n+impl me2 for uint { fn me(&self) -> uint { *self } }\n+fn main() { 1u.me(); } //~ ERROR E0034\n+", "previous_filename": "src/test/compile-fail/ambig_impl_2_exe.rs"}, {"sha": "184927c01357a7efb4f5c5c5c502cfa087c0e62d", "filename": "src/test/compile-fail/method-ambig-two-traits-from-bounds.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-from-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-from-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-from-bounds.rs?ref=450263de4a93e7dd4eb863c8f4b98fc780b9c385", "patch": "@@ -12,9 +12,7 @@ trait A { fn foo(&self); }\n trait B { fn foo(&self); }\n \n fn foo<T:A + B>(t: T) {\n-    t.foo(); //~ ERROR multiple applicable methods in scope\n-    //~^ NOTE candidate #1 derives from the bound `A`\n-    //~^^ NOTE candidate #2 derives from the bound `B`\n+    t.foo(); //~ ERROR E0034\n }\n \n fn main() {}", "previous_filename": "src/test/compile-fail/ambig_impl_bounds.rs"}, {"sha": "87efaed4e3ddadd6093678288e53960ac25154b0", "filename": "src/test/compile-fail/method-ambig-two-traits-with-default-method.rs", "status": "renamed", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-with-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-with-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-with-default-method.rs?ref=450263de4a93e7dd4eb863c8f4b98fc780b9c385", "patch": "@@ -8,12 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo { fn method(&self) {} } //~ NOTE `Foo::method`\n-trait Bar { fn method(&self) {} } //~ NOTE `Bar::method`\n+// Test that we correctly report an ambiguity where two applicable traits\n+// are in scope and the method being invoked is a default method not\n+// defined directly in the impl.\n+\n+trait Foo { fn method(&self) {} }\n+trait Bar { fn method(&self) {} }\n \n impl Foo for uint {}\n impl Bar for uint {}\n \n fn main() {\n-    1u.method(); //~ ERROR multiple applicable methods in scope\n+    1u.method(); //~ ERROR E0034\n }", "previous_filename": "src/test/compile-fail/ambig-default-method.rs"}, {"sha": "6e4b5e088c9fcc00590440474ac13483ee0cfa80", "filename": "src/test/compile-fail/method-commit-to-trait.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Fcompile-fail%2Fmethod-commit-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Fcompile-fail%2Fmethod-commit-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-commit-to-trait.rs?ref=450263de4a93e7dd4eb863c8f4b98fc780b9c385", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we pick `Foo`, and also pick the `impl`, even though in\n+// this case the vector type `T` is not copyable. This is because\n+// there is no other reasonable choice. The error you see is thus\n+// about `T` being non-copyable, not about `Foo` being\n+// unimplemented. This is better for user too, since it suggests minimal\n+// diff requird to fix program.\n+\n+trait Object { }\n+\n+trait Foo {\n+    fn foo(self) -> int;\n+}\n+\n+impl<T:Copy> Foo for Vec<T> {\n+    fn foo(self) -> int {1}\n+}\n+\n+fn test1<T>(x: Vec<T>) {\n+    x.foo();\n+    //~^ ERROR `core::kinds::Copy` is not implemented for the type `T`\n+}\n+\n+fn main() { }"}, {"sha": "e4ae33c1c5055148a732678bdf022290b11fdbb2", "filename": "src/test/run-pass/method-two-trait-defer-resolution-1.rs", "status": "renamed", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-1.rs?ref=450263de4a93e7dd4eb863c8f4b98fc780b9c385", "patch": "@@ -8,20 +8,36 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that we pick which version of `foo` to run based on the\n+// type that is (ultimately) inferred for `x`.\n \n trait foo {\n     fn foo(&self) -> int;\n }\n \n impl foo for Vec<uint> {\n-    fn foo(&self) -> int {1} //~ NOTE candidate #1 is `Vec<uint>.foo::foo`\n+    fn foo(&self) -> int {1}\n }\n \n impl foo for Vec<int> {\n-    fn foo(&self) -> int {2} //~ NOTE candidate #2 is `Vec<int>.foo::foo`\n+    fn foo(&self) -> int {2}\n+}\n+\n+fn call_foo_uint() -> int {\n+    let mut x = Vec::new();\n+    let y = x.foo();\n+    x.push(0u);\n+    y\n+}\n+\n+fn call_foo_int() -> int {\n+    let mut x = Vec::new();\n+    let y = x.foo();\n+    x.push(0i);\n+    y\n }\n \n fn main() {\n-    let x = Vec::new();\n-    x.foo(); //~ ERROR multiple applicable methods in scope\n+    assert_eq!(call_foo_uint(), 1);\n+    assert_eq!(call_foo_int(), 2);\n }", "previous_filename": "src/test/compile-fail/ambig_impl_unify.rs"}, {"sha": "cae783e7ea84a2a337c26f3bd9a7738c6b649094", "filename": "src/test/run-pass/method-two-trait-defer-resolution-2.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/450263de4a93e7dd4eb863c8f4b98fc780b9c385/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs?ref=450263de4a93e7dd4eb863c8f4b98fc780b9c385", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we pick which version of `Foo` to run based on whether\n+// the type we (ultimately) inferred for `x` is copyable or not.\n+//\n+// In this case, the two versions are both impls of same trait, and\n+// hence we we can resolve method even without knowing yet which\n+// version will run (note that the `push` occurs after the call to\n+// `foo()`).\n+\n+trait Foo {\n+    fn foo(&self) -> int;\n+}\n+\n+impl<T:Copy> Foo for Vec<T> {\n+    fn foo(&self) -> int {1}\n+}\n+\n+impl<T> Foo for Vec<Box<T>> {\n+    fn foo(&self) -> int {2}\n+}\n+\n+fn call_foo_copy() -> int {\n+    let mut x = Vec::new();\n+    let y = x.foo();\n+    x.push(0u);\n+    y\n+}\n+\n+fn call_foo_other() -> int {\n+    let mut x = Vec::new();\n+    let y = x.foo();\n+    x.push(box 0i);\n+    y\n+}\n+\n+fn main() {\n+    assert_eq!(call_foo_copy(), 1);\n+    assert_eq!(call_foo_other(), 2);\n+}"}]}