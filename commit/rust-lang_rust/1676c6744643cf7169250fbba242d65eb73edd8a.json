{"sha": "1676c6744643cf7169250fbba242d65eb73edd8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NzZjNjc0NDY0M2NmNzE2OTI1MGZiYmEyNDJkNjVlYjczZWRkOGE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-31T00:34:59Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-31T18:00:47Z"}, "message": "Tighten up comment rules a little more.", "tree": {"sha": "68438132c2355bf2ebd8fe84257e0176e7a438f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68438132c2355bf2ebd8fe84257e0176e7a438f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1676c6744643cf7169250fbba242d65eb73edd8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1676c6744643cf7169250fbba242d65eb73edd8a", "html_url": "https://github.com/rust-lang/rust/commit/1676c6744643cf7169250fbba242d65eb73edd8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1676c6744643cf7169250fbba242d65eb73edd8a/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf57553679b59bc90caa3632762b8beda1896f9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf57553679b59bc90caa3632762b8beda1896f9d", "html_url": "https://github.com/rust-lang/rust/commit/cf57553679b59bc90caa3632762b8beda1896f9d"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "7f0004b1874e4e78439cc16f0b36109841f1b558", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1676c6744643cf7169250fbba242d65eb73edd8a/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1676c6744643cf7169250fbba242d65eb73edd8a/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=1676c6744643cf7169250fbba242d65eb73edd8a", "patch": "@@ -547,7 +547,7 @@ fn eof(printer p) { p.pretty_print(EOF); }\n fn word(printer p, str wrd) {\n     p.pretty_print(STRING(wrd, str::char_len(wrd) as int));\n }\n-fn word_and_eol(printer p, str wrd) {\n+fn huge_word(printer p, str wrd) {\n     p.pretty_print(STRING(wrd, 0xffff));\n }\n fn spaces(printer p, uint n) { break_offset(p, n, 0); }"}, {"sha": "5d06c28c3d426acfcbabfc30a8bbf5a5e4e5a956", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1676c6744643cf7169250fbba242d65eb73edd8a/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1676c6744643cf7169250fbba242d65eb73edd8a/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=1676c6744643cf7169250fbba242d65eb73edd8a", "patch": "@@ -17,7 +17,7 @@ import pp::box;\n import pp::cbox;\n import pp::ibox;\n import pp::word;\n-import pp::word_and_eol;\n+import pp::huge_word;\n import pp::space;\n import pp::zerobreak;\n import pp::hardbreak;\n@@ -152,7 +152,8 @@ fn commasep_cmnt[IN](ps s, breaks b, vec[IN] elts, fn(ps, &IN) op,\n         i += 1u;\n         if (i < len) {\n             word(s.s, \",\");\n-            if (!maybe_print_line_comment(s, get_span(elt))) {space(s.s);}\n+            maybe_print_trailing_comment(s, get_span(elt));\n+            space(s.s);\n         }\n     }\n     end(s.s);\n@@ -350,7 +351,7 @@ fn print_item(ps s, @ast::item item) {\n                     pclose(s);\n                 }\n                 word(s.s, \";\");\n-                maybe_print_line_comment(s, v.span);\n+                maybe_print_trailing_comment(s, v.span);\n             }\n             bclose(s, item.span);\n         }\n@@ -409,13 +410,13 @@ fn print_block(ps s, ast::block blk) {\n           }\n         }\n         if (front::parser::stmt_ends_with_semi(st)) {word(s.s, \";\");}\n-        maybe_print_line_comment(s, st.span);\n+        maybe_print_trailing_comment(s, st.span);\n     }\n     alt (blk.node.expr) {\n         case (option::some[@ast::expr](?expr)) {\n             space(s.s);\n             print_expr(s, expr);\n-            maybe_print_line_comment(s, expr.span);\n+            maybe_print_trailing_comment(s, expr.span);\n         }\n         case (_) {}\n     }\n@@ -1105,32 +1106,28 @@ fn maybe_print_comment(ps s, uint pos) {\n     }\n }\n \n-fn maybe_print_line_comment(ps s, common::span span) -> bool {\n+fn maybe_print_trailing_comment(ps s, common::span span) {\n     auto cm;\n     alt (s.cm) {\n         case (option::some[codemap](?ccm)) {\n             cm = ccm;\n         }\n-        case (_) {\n-            ret false;\n-        }\n+        case (_) { ret; }\n     }\n     alt (next_comment(s)) {\n         case (option::some[lexer::cmnt](?cmnt)) {\n-            if (cmnt.style != lexer::trailing) { ret false; }\n+            if (cmnt.style != lexer::trailing) { ret; }\n \n             auto span_line = codemap::lookup_pos(cm, span.hi);\n             auto comment_line = codemap::lookup_pos(cm, cmnt.pos);\n             if (span_line.line == comment_line.line) {\n                 word(s.s, \" \");\n                 print_comment(s, cmnt);\n                 s.cur_cmnt += 1u;\n-                ret true;\n             }\n         }\n         case (_) {}\n     }\n-    ret false;\n }\n \n fn print_remaining_comments(ps s) {\n@@ -1148,21 +1145,24 @@ fn print_remaining_comments(ps s) {\n fn print_comment(ps s, lexer::cmnt cmnt) {\n     alt (cmnt.style) {\n         case (lexer::isolated) {\n-            zerobreak(s.s);\n+            hardbreak(s.s);\n             for (str line in cmnt.lines) {\n-                word_and_eol(s.s, line);\n+                huge_word(s.s, line);\n                 zerobreak(s.s);\n             }\n-            zerobreak(s.s);\n         }\n         case (lexer::trailing) {\n-            cbox(s.s, 0u);\n-            for (str line in cmnt.lines) {\n-                word_and_eol(s.s, line);\n-                zerobreak(s.s);\n+            if (vec::len(cmnt.lines) == 1u) {\n+                word(s.s, cmnt.lines.(0));\n+                hardbreak(s.s);\n+            } else {\n+                cbox(s.s, 0u);\n+                for (str line in cmnt.lines) {\n+                    huge_word(s.s, line);\n+                    zerobreak(s.s);\n+                }\n+                end(s.s);\n             }\n-            end(s.s);\n-            zerobreak(s.s);\n         }\n         case (lexer::mixed) {\n             assert vec::len(cmnt.lines) == 1u;"}]}