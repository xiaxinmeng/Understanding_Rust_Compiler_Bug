{"sha": "433fbe8fcf13724445cc57c85cc454352c969429", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzM2ZiZThmY2YxMzcyNDQ0NWNjNTdjODVjYzQ1NDM1MmM5Njk0Mjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-13T23:53:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-13T23:53:14Z"}, "message": "auto merge of #8329 : michaelwoerister/rust/lexical_scopes_alt, r=graydon\n\nThis pull request re-implements handling of visibility scopes and source code positions in debug info. It should now be very stable and properly handle\r\n\r\n+ variable shadowing\r\n+ expanded code (macros and the new for-loop de-sugaring, for example)\r\n+ variables in the middle of nested scopes\r\n+ bindings declared in the head of match statement arms. \r\n\r\nall of which did not work at all or did not work reliably before. Those interested in a more detailed description of the problems at hand, I kindly refer to http://michaelwoerister.github.io/2013/08/03/visibility-scopes.html\r\n\r\nWhy doesn't the `populate_scope_map()` function use `syntax::visit`?\r\nBecause it would not improve this particular AST walker (see: https://github.com/michaelwoerister/rust/commit/69dc7908490b8b492e9730cb1c34fa83c2ef30eb#commitcomment-3781426)\r\n\r\nCheers,\r\nMichael", "tree": {"sha": "aca4edd4be02a72d29094b699f00fc71dc96552d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aca4edd4be02a72d29094b699f00fc71dc96552d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/433fbe8fcf13724445cc57c85cc454352c969429", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/433fbe8fcf13724445cc57c85cc454352c969429", "html_url": "https://github.com/rust-lang/rust/commit/433fbe8fcf13724445cc57c85cc454352c969429", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/433fbe8fcf13724445cc57c85cc454352c969429/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f379329db48e613f910167a8840fd2c13581dd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f379329db48e613f910167a8840fd2c13581dd9", "html_url": "https://github.com/rust-lang/rust/commit/9f379329db48e613f910167a8840fd2c13581dd9"}, {"sha": "983cc777c5090df18188dd417cdfda8acfc2cb1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/983cc777c5090df18188dd417cdfda8acfc2cb1b", "html_url": "https://github.com/rust-lang/rust/commit/983cc777c5090df18188dd417cdfda8acfc2cb1b"}], "stats": {"total": 2351, "additions": 2195, "deletions": 156}, "files": [{"sha": "bb1e3fa1718dc3d83854420507bb31eab6c414e9", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -214,6 +214,7 @@ use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::tvec;\n use middle::trans::type_of;\n+use middle::trans::debuginfo;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, vec_map_to_str};\n@@ -385,6 +386,7 @@ struct BindingInfo {\n     llmatch: ValueRef,\n     trmode: TransBindingMode,\n     id: ast::NodeId,\n+    span: span,\n     ty: ty::t,\n }\n \n@@ -1305,7 +1307,7 @@ fn insert_lllocals(bcx: @mut Block,\n         BindArgument => bcx.fcx.llargs\n     };\n \n-    for (_, &binding_info) in bindings_map.iter() {\n+    for (&ident, &binding_info) in bindings_map.iter() {\n         let llval = match binding_info.trmode {\n             // By value bindings: use the stack slot that we\n             // copied/moved the value into\n@@ -1325,6 +1327,14 @@ fn insert_lllocals(bcx: @mut Block,\n \n         debug!(\"binding %? to %s\", binding_info.id, bcx.val_to_str(llval));\n         llmap.insert(binding_info.id, llval);\n+\n+        if bcx.sess().opts.extra_debuginfo {\n+            debuginfo::create_match_binding_metadata(bcx,\n+                                                     ident,\n+                                                     binding_info.id,\n+                                                     binding_info.ty,\n+                                                     binding_info.span);\n+        }\n     }\n     return bcx;\n }\n@@ -1771,7 +1781,7 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::pat) -> BindingsMap {\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n     let mut bindings_map = HashMap::new();\n-    do pat_bindings(tcx.def_map, pat) |bm, p_id, _s, path| {\n+    do pat_bindings(tcx.def_map, pat) |bm, p_id, span, path| {\n         let ident = path_to_ident(path);\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n@@ -1793,8 +1803,11 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::pat) -> BindingsMap {\n             }\n         };\n         bindings_map.insert(ident, BindingInfo {\n-            llmatch: llmatch, trmode: trmode,\n-            id: p_id, ty: variable_ty\n+            llmatch: llmatch,\n+            trmode: trmode,\n+            id: p_id,\n+            span: span,\n+            ty: variable_ty\n         });\n     }\n     return bindings_map;"}, {"sha": "eedc97440f079172421146ac499ee2f3ed9cd051", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -1103,7 +1103,6 @@ pub fn trans_stmt(cx: @mut Block, s: &ast::stmt) -> @mut Block {\n     }\n \n     let mut bcx = cx;\n-    debuginfo::update_source_pos(cx, s.span);\n \n     match s.node {\n         ast::stmt_expr(e, _) | ast::stmt_semi(e, _) => {\n@@ -1634,7 +1633,8 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n           param_substs: param_substs,\n           span: sp,\n           path: path,\n-          ccx: ccx\n+          ccx: ccx,\n+          debug_context: None,\n     };\n     fcx.llenv = unsafe {\n           llvm::LLVMGetParam(llfndecl, fcx.env_arg_pos() as c_uint)\n@@ -1933,7 +1933,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                   attrs,\n                   output_type,\n                   |fcx| {\n-                      if ccx.sess.opts.extra_debuginfo\n+                      if ccx.sess.opts.debuginfo\n                           && fcx_has_nonzero_span(fcx) {\n                           debuginfo::create_function_metadata(fcx);\n                       }"}, {"sha": "9aa18bc05f8fa884ff22abb255dcebb2cc8e24fe", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -23,6 +23,7 @@ use middle::trans::build;\n use middle::trans::datum;\n use middle::trans::glue;\n use middle::trans::write_guard;\n+use middle::trans::debuginfo;\n use middle::ty::substs;\n use middle::ty;\n use middle::typeck;\n@@ -226,7 +227,10 @@ pub struct FunctionContext {\n     path: path,\n \n     // This function's enclosing crate context.\n-    ccx: @mut CrateContext\n+    ccx: @mut CrateContext,\n+\n+    // Used and maintained by the debuginfo module.\n+    debug_context: Option<~debuginfo::FunctionDebugContext>\n }\n \n impl FunctionContext {"}, {"sha": "2a3003812fe07383533862c4d40ac36d8c9ddff4", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -19,7 +19,6 @@ use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee;\n use middle::trans::common::*;\n-use middle::trans::debuginfo;\n use middle::trans::expr;\n use middle::trans::type_of::*;\n use middle::ty;\n@@ -38,12 +37,10 @@ pub fn trans_block(bcx: @mut Block, b: &ast::Block, dest: expr::Dest) -> @mut Bl\n     let _icx = push_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n     for s in b.stmts.iter() {\n-        debuginfo::update_source_pos(bcx, b.span);\n         bcx = trans_stmt(bcx, *s);\n     }\n     match b.expr {\n         Some(e) => {\n-            debuginfo::update_source_pos(bcx, e.span);\n             bcx = expr::trans_into(bcx, e, dest);\n         }\n         None => {"}, {"sha": "66ff2495c296de6dfcd05328a9732c5df722d73c", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 595, "deletions": 133, "changes": 728, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -99,9 +99,7 @@ pub struct DebugContext {\n     priv created_files: HashMap<~str, DIFile>,\n     priv created_functions: HashMap<ast::NodeId, DISubprogram>,\n     priv created_blocks: HashMap<ast::NodeId, DILexicalBlock>,\n-    priv created_types: HashMap<uint, DIType>,\n-    priv last_function_context_id: ast::NodeId,\n-    priv argument_counter: uint,\n+    priv created_types: HashMap<uint, DIType>\n }\n \n impl DebugContext {\n@@ -118,8 +116,21 @@ impl DebugContext {\n             created_files: HashMap::new(),\n             created_functions: HashMap::new(),\n             created_blocks: HashMap::new(),\n-            created_types: HashMap::new(),\n-            last_function_context_id: -1, // magic value :(\n+            created_types: HashMap::new()\n+        };\n+    }\n+}\n+\n+\n+pub struct FunctionDebugContext {\n+    priv scope_map: HashMap<ast::NodeId, DIScope>,\n+    priv argument_counter: uint,\n+}\n+\n+impl FunctionDebugContext {\n+    fn new() -> FunctionDebugContext {\n+        return FunctionDebugContext {\n+            scope_map: HashMap::new(),\n             argument_counter: 1,\n         };\n     }\n@@ -141,61 +152,24 @@ pub fn finalize(cx: @mut CrateContext) {\n pub fn create_local_var_metadata(bcx: @mut Block, local: &ast::Local) {\n     let cx = bcx.ccx();\n     let def_map = cx.tcx.def_map;\n-    let pattern = local.pat;\n-\n-    let scope = match bcx.parent {\n-        None => create_function_metadata(bcx.fcx),\n-        Some(_) => lexical_block_metadata(bcx)\n-    };\n-\n-    let filename = span_start(cx, local.span).file.name;\n-    let file_metadata = file_metadata(cx, filename);\n-\n-    do pat_util::pat_bindings(def_map, pattern) |_, node_id, span, path_ref| {\n-\n-        let ident = ast_util::path_to_ident(path_ref);\n-        let name: &str = cx.sess.str_of(ident);\n-        debug!(\"create_local_var_metadata: %s\", name);\n-        let loc = span_start(cx, span);\n-        let ty = node_id_type(bcx, node_id);\n-        let type_metadata = type_metadata(cx, ty, span);\n-\n-        let var_metadata = do name.to_c_str().with_ref |name| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateLocalVariable(\n-                    DIB(cx),\n-                    DW_TAG_auto_variable,\n-                    scope,\n-                    name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    type_metadata,\n-                    false,\n-                    0,\n-                    0)\n-            }\n-        };\n \n-        let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n-            Some(v) => v,\n-            None => {\n-                bcx.tcx().sess.span_bug(span, fmt!(\"No entry in lllocals table for %?\", node_id));\n-            }\n-        };\n+    do pat_util::pat_bindings(def_map, local.pat) |_, node_id, span, path_ref| {\n \n-        set_debug_location(cx, lexical_block_metadata(bcx), loc.line, loc.col.to_uint());\n-        unsafe {\n-            let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-                DIB(cx),\n-                llptr,\n-                var_metadata,\n-                bcx.llbb);\n+        let var_ident = ast_util::path_to_ident(path_ref);\n+        let var_type = node_id_type(bcx, node_id);\n \n-            llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n-        }\n+        declare_local(bcx, var_ident, node_id, var_type, span);\n     }\n }\n \n+pub fn create_match_binding_metadata(bcx: @mut Block,\n+                                     variable_ident: ast::ident,\n+                                     node_id: ast::NodeId,\n+                                     variable_type: ty::t,\n+                                     span: span) {\n+    declare_local(bcx, variable_ident, node_id, variable_type, span);\n+}\n+\n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n@@ -213,20 +187,6 @@ pub fn create_argument_metadata(bcx: @mut Block,\n         return;\n     }\n \n-    // Limited the scope within which `debug_context` is live,\n-    // otherwise => borrowing errors\n-    {\n-        let debug_context = dbg_cx(cx);\n-\n-        // If this is a new function, reset the counter. llvm::DIBuilder\n-        // wants arguments to be indexed starting from 1.\n-        if fcx.id != debug_context.last_function_context_id {\n-                    debug_context.argument_counter = 1;\n-        }\n-        // Keep track of the function we are in\n-        debug_context.last_function_context_id = fcx.id;\n-    }\n-\n     let def_map = cx.tcx.def_map;\n     let file_metadata = file_metadata(cx, filename);\n     let scope = create_function_metadata(fcx);\n@@ -241,9 +201,9 @@ pub fn create_argument_metadata(bcx: @mut Block,\n         debug!(\"create_argument_metadata: %s\", name);\n \n         let argument_index = {\n-            let debug_context = dbg_cx(cx);\n-            let argument_index = debug_context.argument_counter;\n-            debug_context.argument_counter += 1;\n+            let counter = &mut fcx.debug_context.get_mut_ref().argument_counter;\n+            let argument_index = *counter;\n+            *counter += 1;\n             argument_index as c_uint\n         };\n \n@@ -270,7 +230,7 @@ pub fn create_argument_metadata(bcx: @mut Block,\n             }\n         };\n \n-        set_debug_location(cx, lexical_block_metadata(bcx), loc.line, loc.col.to_uint());\n+        set_debug_location(cx, scope, loc.line, loc.col.to_uint());\n         unsafe {\n             let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n                 DIB(cx),\n@@ -286,49 +246,57 @@ pub fn create_argument_metadata(bcx: @mut Block,\n /// Sets the current debug location at the beginning of the span\n ///\n /// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...)\n-pub fn update_source_pos(bcx: @mut Block, span: span) {\n-    if !bcx.sess().opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n+pub fn update_source_pos(fcx: &FunctionContext,\n+                         node_id: ast::NodeId,\n+                         span: span) {\n+    let cx: &mut CrateContext = fcx.ccx;\n+\n+    if !cx.sess.opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n         return;\n     }\n-    debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(span));\n-    let loc = span_start(bcx.ccx(), span);\n-    set_debug_location(bcx.ccx(), lexical_block_metadata(bcx), loc.line, loc.col.to_uint())\n+\n+    debug!(\"update_source_pos: %s\", cx.sess.codemap.span_to_str(span));\n+\n+    let loc = span_start(cx, span);\n+    let scope = scope_metadata(fcx, node_id, span);\n+\n+    set_debug_location(cx, scope, loc.line, loc.col.to_uint());\n }\n \n /// Creates debug information for the given function.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n /// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_function_metadata(fcx: &FunctionContext) -> DISubprogram {\n+pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n     let cx = fcx.ccx;\n \n     let fnitem = cx.tcx.items.get_copy(&fcx.id);\n-    let (ident, ret_ty, id) = match fnitem {\n+    let (ident, fn_decl, id) = match fnitem {\n         ast_map::node_item(ref item, _) => {\n             match item.node {\n-                ast::item_fn(ast::fn_decl { output: ref ty, _}, _, _, _, _) => {\n-                    (item.ident, ty, item.id)\n+                ast::item_fn(ref fn_decl, _, _, _, _) => {\n+                    (item.ident, fn_decl, item.id)\n                 }\n                 _ => fcx.ccx.sess.span_bug(item.span,\n                                            \"create_function_metadata: item bound to non-function\")\n             }\n         }\n         ast_map::node_method(\n             @ast::method {\n-                decl: ast::fn_decl { output: ref ty, _ },\n+                decl: ref fn_decl,\n                 id: id,\n                 ident: ident,\n                 _\n             },\n             _,\n             _) => {\n-            (ident, ty, id)\n+            (ident, fn_decl, id)\n         }\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n-                ast::expr_fn_block(ref decl, _) => {\n+                ast::expr_fn_block(ref fn_decl, _) => {\n                     let name = gensym_name(\"fn\");\n-                    (name, &decl.output, expr.id)\n+                    (name, fn_decl, expr.id)\n                 }\n                 _ => fcx.ccx.sess.span_bug(expr.span,\n                         \"create_function_metadata: expected an expr_fn_block here\")\n@@ -337,20 +305,20 @@ pub fn create_function_metadata(fcx: &FunctionContext) -> DISubprogram {\n         ast_map::node_trait_method(\n             @ast::provided(\n                 @ast::method {\n-                    decl: ast::fn_decl { output: ref ty, _ },\n+                    decl: ref fn_decl,\n                     id: id,\n                     ident: ident,\n                     _\n                 }),\n             _,\n             _) => {\n-            (ident, ty, id)\n+            (ident, fn_decl, id)\n         }\n         _ => fcx.ccx.sess.bug(fmt!(\"create_function_metadata: unexpected sort of node: %?\", fnitem))\n     };\n \n-    match dbg_cx(cx).created_functions.find(&id) {\n-        Some(fn_metadata) => return *fn_metadata,\n+    match dbg_cx(cx).created_functions.find_copy(&id) {\n+        Some(fn_metadata) => return fn_metadata,\n         None => ()\n     }\n \n@@ -367,9 +335,9 @@ pub fn create_function_metadata(fcx: &FunctionContext) -> DISubprogram {\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n     let return_type_metadata = if cx.sess.opts.extra_debuginfo {\n-        match ret_ty.node {\n+        match fn_decl.output.node {\n           ast::ty_nil => ptr::null(),\n-          _ => type_metadata(cx, ty::node_id_to_type(cx.tcx, id), ret_ty.span)\n+          _ => type_metadata(cx, ty::node_id_to_type(cx.tcx, id), fn_decl.output.span)\n         }\n     } else {\n         ptr::null()\n@@ -405,6 +373,27 @@ pub fn create_function_metadata(fcx: &FunctionContext) -> DISubprogram {\n             }\n         }};\n \n+    assert!(fcx.debug_context.is_none());\n+\n+    let mut fn_debug_context = ~FunctionDebugContext::new();\n+    let entry_block_id = fcx.entry_bcx.get_ref().node_info.get_ref().id;\n+    let entry_block = cx.tcx.items.get(&entry_block_id);\n+\n+    match *entry_block {\n+        ast_map::node_block(ref block) => {\n+            let scope_map = &mut fn_debug_context.scope_map;\n+            let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n+\n+            populate_scope_map(cx, arg_pats, block, fn_metadata, scope_map);\n+        }\n+        _ => cx.sess.span_bug(span,\n+                fmt!(\"debuginfo::create_function_metadata() - \\\n+                     FunctionContext::entry_bcx::node_info points to wrong type of ast_map entry. \\\n+                     Expected: ast_map::node_block, actual: %?\", *entry_block))\n+    }\n+\n+    fcx.debug_context = Some(fn_debug_context);\n+\n     dbg_cx(cx).created_functions.insert(id, fn_metadata);\n     return fn_metadata;\n }\n@@ -445,6 +434,56 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n     }}}}};\n }\n \n+fn declare_local(bcx: @mut Block,\n+                 variable_ident: ast::ident,\n+                 node_id: ast::NodeId,\n+                 variable_type: ty::t,\n+                 span: span) {\n+    let cx: &mut CrateContext = bcx.ccx();\n+\n+    let filename = span_start(cx, span).file.name;\n+    let file_metadata = file_metadata(cx, filename);\n+\n+    let name: &str = cx.sess.str_of(variable_ident);\n+    let loc = span_start(cx, span);\n+    let type_metadata = type_metadata(cx, variable_type, span);\n+    let scope = scope_metadata(bcx.fcx, node_id, span);\n+\n+    let var_metadata = do name.to_c_str().with_ref |name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateLocalVariable(\n+                DIB(cx),\n+                DW_TAG_auto_variable,\n+                scope,\n+                name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                type_metadata,\n+                false,\n+                0,\n+                0)\n+        }\n+    };\n+\n+    let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n+        Some(v) => v,\n+        None => {\n+            bcx.tcx().sess.span_bug(span, fmt!(\"No entry in lllocals table for %?\", node_id));\n+        }\n+    };\n+\n+    set_debug_location(cx, scope, loc.line, loc.col.to_uint());\n+    unsafe {\n+        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+            DIB(cx),\n+            llptr,\n+            var_metadata,\n+            bcx.llbb);\n+\n+        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n+    }\n+}\n+\n fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n     match dbg_cx(cx).created_files.find_equiv(&full_path) {\n         Some(file_metadata) => return *file_metadata,\n@@ -473,50 +512,26 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n     return file_metadata;\n }\n \n-/// Get or create the lexical block metadata node for the given LLVM basic block.\n-fn lexical_block_metadata(bcx: @mut Block) -> DILexicalBlock {\n-    let cx = bcx.ccx();\n-    let mut bcx = bcx;\n-\n-    // Search up the tree of basic blocks until we find one that knows the containing lexical block.\n-    while bcx.node_info.is_none() {\n-        match bcx.parent {\n-            Some(b) => bcx = b,\n-            None => cx.sess.bug(\"debuginfo: Could not find lexical block for LLVM basic block.\")\n-        }\n-    }\n-\n-    let span = bcx.node_info.unwrap().span;\n-    let id = bcx.node_info.unwrap().id;\n-\n-    // Check whether we already have a cache entry for this node id\n-    match dbg_cx(cx).created_blocks.find(&id) {\n-        Some(block) => return *block,\n-        None => ()\n+/// Finds the scope metadata node for the given AST node.\n+fn scope_metadata(fcx: &FunctionContext,\n+                  node_id: ast::NodeId,\n+                  span: span) -> DIScope {\n+    if fcx.debug_context.is_none() {\n+        fcx.ccx.sess.span_bug(span, \"debuginfo: FunctionDebugContext should be initialized \\\n+                                     but is not!\");\n     }\n \n-    debug!(\"lexical_block_metadata: %s\", bcx.sess().codemap.span_to_str(span));\n+    let scope_map = &fcx.debug_context.get_ref().scope_map;\n \n-    let parent = match bcx.parent {\n-        None => create_function_metadata(bcx.fcx),\n-        Some(b) => lexical_block_metadata(b)\n-    };\n+    match scope_map.find_copy(&node_id) {\n+        Some(scope_metadata) => scope_metadata,\n+        None => {\n+            let node = fcx.ccx.tcx.items.get_copy(&node_id);\n \n-    let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n-\n-    let lexical_block_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateLexicalBlock(\n-            DIB(cx),\n-            parent,\n-            file_metadata,\n-            loc.line as c_uint,\n-            loc.col.to_uint() as c_uint)\n-    };\n-\n-    dbg_cx(cx).created_blocks.insert(id, lexical_block_metadata);\n-\n-    return lexical_block_metadata;\n+            fcx.ccx.sess.span_bug(span,\n+                fmt!(\"debuginfo: Could not find scope info for node %?\", node));\n+        }\n+    }\n }\n \n fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n@@ -1206,7 +1221,7 @@ fn type_metadata(cx: &mut CrateContext,\n     return type_metadata;\n }\n \n-fn set_debug_location(cx: @mut CrateContext, scope: DIScope, line: uint, col: uint) {\n+fn set_debug_location(cx: &mut CrateContext, scope: DIScope, line: uint, col: uint) {\n     if dbg_cx(cx).curr_loc == (line, col) {\n         return;\n     }\n@@ -1224,7 +1239,6 @@ fn set_debug_location(cx: @mut CrateContext, scope: DIScope, line: uint, col: ui\n     }\n }\n \n-\n //=-------------------------------------------------------------------------------------------------\n //  Utility Functions\n //=-------------------------------------------------------------------------------------------------\n@@ -1256,3 +1270,451 @@ fn dbg_cx<'a>(cx: &'a mut CrateContext) -> &'a mut DebugContext {\n fn DIB(cx: &CrateContext) -> DIBuilderRef {\n     cx.dbg_cx.get_ref().builder\n }\n+\n+\n+// This procedure builds the *scope map* for a given function, which maps any given ast::NodeId in\n+// the function's AST to the correct DIScope metadata instance.\n+//\n+// This builder procedure walks the AST in execution order and keeps track of what belongs to which\n+// scope, creating DIScope DIEs along the way, and introducing *artificial* lexical scope\n+// descriptors where necessary. These artificial scopes allow GDB to correctly handle name\n+// shadowing.\n+fn populate_scope_map(cx: &mut CrateContext,\n+                      arg_pats: &[@ast::pat],\n+                      fn_entry_block: &ast::Block,\n+                      fn_metadata: DISubprogram,\n+                      scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n+    let def_map = cx.tcx.def_map;\n+\n+    struct ScopeStackEntry {\n+        scope_metadata: DIScope,\n+        ident: Option<ast::ident>\n+    }\n+\n+    let mut scope_stack = ~[ScopeStackEntry { scope_metadata: fn_metadata, ident: None }];\n+\n+    // Push argument identifiers onto the stack so arguments integrate nicely with variable\n+    // shadowing.\n+    for &arg_pat in arg_pats.iter() {\n+        do pat_util::pat_bindings(def_map, arg_pat) |_, _, _, path_ref| {\n+            let ident = ast_util::path_to_ident(path_ref);\n+            scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata, ident: Some(ident) });\n+        }\n+    }\n+\n+    walk_block(cx, fn_entry_block, &mut scope_stack, scope_map);\n+\n+    // local helper functions for walking the AST.\n+\n+    fn with_new_scope(cx: &mut CrateContext,\n+                      scope_span: span,\n+                      scope_stack: &mut ~[ScopeStackEntry],\n+                      scope_map: &mut HashMap<ast::NodeId, DIScope>,\n+                      inner_walk: &fn(&mut CrateContext,\n+                                      &mut ~[ScopeStackEntry],\n+                                      &mut HashMap<ast::NodeId, DIScope>)) {\n+        // Create a new lexical scope and push it onto the stack\n+        let loc = cx.sess.codemap.lookup_char_pos(scope_span.lo);\n+        let file_metadata = file_metadata(cx, loc.file.name);\n+        let parent_scope = scope_stack.last().scope_metadata;\n+\n+        let scope_metadata = unsafe {\n+            llvm::LLVMDIBuilderCreateLexicalBlock(\n+                DIB(cx),\n+                parent_scope,\n+                file_metadata,\n+                loc.line as c_uint,\n+                loc.col.to_uint() as c_uint)\n+        };\n+\n+        scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata, ident: None });\n+\n+        inner_walk(cx, scope_stack, scope_map);\n+\n+        // pop artificial scopes\n+        while scope_stack.last().ident.is_some() {\n+            scope_stack.pop();\n+        }\n+\n+        if scope_stack.last().scope_metadata != scope_metadata {\n+            cx.sess.span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n+        }\n+\n+        scope_stack.pop();\n+    }\n+\n+    fn walk_block(cx: &mut CrateContext,\n+                  block: &ast::Block,\n+                  scope_stack: &mut ~[ScopeStackEntry],\n+                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n+        scope_map.insert(block.id, scope_stack.last().scope_metadata);\n+\n+        // The interesting things here are statements and the concluding expression.\n+        for &@ ref statement in block.stmts.iter() {\n+            scope_map.insert(ast_util::stmt_id(statement), scope_stack.last().scope_metadata);\n+\n+            match statement.node {\n+                ast::stmt_decl(@ref decl, _) => walk_decl(cx, decl, scope_stack, scope_map),\n+                ast::stmt_expr(@ref exp, _) |\n+                ast::stmt_semi(@ref exp, _) => walk_expr(cx, exp, scope_stack, scope_map),\n+                ast::stmt_mac(*) => () // ignore macros (which should be expanded anyway)\n+            }\n+        }\n+\n+        for &@ref exp in block.expr.iter() {\n+            walk_expr(cx, exp, scope_stack, scope_map);\n+        }\n+    }\n+\n+    fn walk_decl(cx: &mut CrateContext,\n+                 decl: &ast::decl,\n+                 scope_stack: &mut ~[ScopeStackEntry],\n+                 scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n+        match *decl {\n+            codemap::spanned { node: ast::decl_local(@ref local), _ } => {\n+                scope_map.insert(local.id, scope_stack.last().scope_metadata);\n+\n+                walk_pattern(cx, local.pat, scope_stack, scope_map);\n+\n+                for &@ref exp in local.init.iter() {\n+                    walk_expr(cx, exp, scope_stack, scope_map);\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+\n+    fn walk_pattern(cx: &mut CrateContext,\n+                    pat: @ast::pat,\n+                    scope_stack: &mut ~[ScopeStackEntry],\n+                    scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n+\n+        let def_map = cx.tcx.def_map;\n+\n+        // Unfortunately, we cannot just use pat_util::pat_bindings() or ast_util::walk_pat() here\n+        // because we have to visit *all* nodes in order to put them into the scope map. The above\n+        // functions don't do that.\n+        match pat.node {\n+            ast::pat_ident(_, ref path_ref, ref sub_pat_opt) => {\n+\n+                // Check if this is a binding. If so we need to put it on the scope stack and maybe\n+                // introduce an articial scope\n+                if pat_util::pat_is_binding(def_map, pat) {\n+\n+                    let ident = ast_util::path_to_ident(path_ref);\n+\n+                    // LLVM does not properly generate 'DW_AT_start_scope' fields for variable DIEs.\n+                    // For this reason we have to introduce an artificial scope at bindings whenever\n+                    // a variable with the same name is declared in *any* parent scope.\n+                    //\n+                    // Otherwise the following error occurs:\n+                    //\n+                    // let x = 10;\n+                    //\n+                    // do_something(); // 'gdb print x' correctly prints 10\n+                    //\n+                    // {\n+                    //     do_something(); // 'gdb print x' prints 0, because it already reads the\n+                    //                     // uninitialized 'x' from the next line...\n+                    //     let x = 100;\n+                    //     do_something(); // 'gdb print x' correctly prints 100\n+                    // }\n+\n+                    // Is there already a binding with that name?\n+                    let need_new_scope = scope_stack\n+                        .iter()\n+                        .any(|entry| entry.ident.iter().any(|i| *i == ident));\n+\n+                    if need_new_scope {\n+                        // Create a new lexical scope and push it onto the stack\n+                        let loc = cx.sess.codemap.lookup_char_pos(pat.span.lo);\n+                        let file_metadata = file_metadata(cx, loc.file.name);\n+                        let parent_scope = scope_stack.last().scope_metadata;\n+\n+                        let scope_metadata = unsafe {\n+                            llvm::LLVMDIBuilderCreateLexicalBlock(\n+                                DIB(cx),\n+                                parent_scope,\n+                                file_metadata,\n+                                loc.line as c_uint,\n+                                loc.col.to_uint() as c_uint)\n+                        };\n+\n+                        scope_stack.push(ScopeStackEntry {\n+                            scope_metadata: scope_metadata,\n+                            ident: Some(ident)\n+                        });\n+\n+                    } else {\n+                        // Push a new entry anyway so the name can be found\n+                        let prev_metadata = scope_stack.last().scope_metadata;\n+                        scope_stack.push(ScopeStackEntry {\n+                            scope_metadata: prev_metadata,\n+                            ident: Some(ident)\n+                        });\n+                    }\n+                }\n+\n+                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+\n+                for &sub_pat in sub_pat_opt.iter() {\n+                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::pat_wild => {\n+                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+            }\n+\n+            ast::pat_enum(_, ref sub_pats_opt) => {\n+                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+\n+                for ref sub_pats in sub_pats_opt.iter() {\n+                    for &p in sub_pats.iter() {\n+                        walk_pattern(cx, p, scope_stack, scope_map);\n+                    }\n+                }\n+            }\n+\n+            ast::pat_struct(_, ref field_pats, _) => {\n+                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+\n+                for &ast::field_pat { pat: sub_pat, _ } in field_pats.iter() {\n+                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::pat_tup(ref sub_pats) => {\n+                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+\n+                for &sub_pat in sub_pats.iter() {\n+                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::pat_box(sub_pat)    |\n+            ast::pat_uniq(sub_pat)   |\n+            ast::pat_region(sub_pat) => {\n+                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+            }\n+\n+            ast::pat_lit(@ref exp) => {\n+                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                walk_expr(cx, exp, scope_stack, scope_map);\n+            }\n+\n+            ast::pat_range(@ref exp1, @ref exp2) => {\n+                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+                walk_expr(cx, exp1, scope_stack, scope_map);\n+                walk_expr(cx, exp2, scope_stack, scope_map);\n+            }\n+\n+            ast::pat_vec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n+                scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n+\n+                for &sub_pat in front_sub_pats.iter() {\n+                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                }\n+\n+                for &sub_pat in middle_sub_pats.iter() {\n+                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                }\n+\n+                for &sub_pat in back_sub_pats.iter() {\n+                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn walk_expr(cx: &mut CrateContext,\n+                 exp: &ast::expr,\n+                 scope_stack: &mut ~[ScopeStackEntry],\n+                 scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n+\n+        scope_map.insert(exp.id, scope_stack.last().scope_metadata);\n+\n+        match exp.node {\n+            ast::expr_self     |\n+            ast::expr_lit(_)   |\n+            ast::expr_break(_) |\n+            ast::expr_again(_) |\n+            ast::expr_path(_)  => (),\n+\n+            ast::expr_vstore(@ref sub_exp, _)   |\n+            ast::expr_cast(@ref sub_exp, _)     |\n+            ast::expr_addr_of(_, @ref sub_exp)  |\n+            ast::expr_field(@ref sub_exp, _, _) |\n+            ast::expr_paren(@ref sub_exp)       => walk_expr(cx, sub_exp, scope_stack, scope_map),\n+\n+            ast::expr_ret(exp_opt) => match exp_opt {\n+                Some(@ref sub_exp) => walk_expr(cx, sub_exp, scope_stack, scope_map),\n+                None => ()\n+            },\n+\n+            ast::expr_unary(node_id, _, @ref sub_exp) => {\n+                scope_map.insert(node_id, scope_stack.last().scope_metadata);\n+                walk_expr(cx, sub_exp, scope_stack, scope_map);\n+            }\n+\n+            ast::expr_assign_op(node_id, _, @ref lhs, @ref rhs) |\n+            ast::expr_index(node_id, @ref lhs, @ref rhs)        |\n+            ast::expr_binary(node_id, _, @ref lhs, @ref rhs)    => {\n+                scope_map.insert(node_id, scope_stack.last().scope_metadata);\n+                walk_expr(cx, lhs, scope_stack, scope_map);\n+                walk_expr(cx, rhs, scope_stack, scope_map);\n+            }\n+\n+            ast::expr_vec(ref init_expressions, _) |\n+            ast::expr_tup(ref init_expressions)    => {\n+                for &@ref ie in init_expressions.iter() {\n+                    walk_expr(cx, ie, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::expr_assign(@ref sub_exp1, @ref sub_exp2)    |\n+            ast::expr_log(@ref sub_exp1, @ref sub_exp2)       |\n+            ast::expr_repeat(@ref sub_exp1, @ref sub_exp2, _) => {\n+                walk_expr(cx, sub_exp1, scope_stack, scope_map);\n+                walk_expr(cx, sub_exp2, scope_stack, scope_map);\n+            }\n+\n+            ast::expr_if(@ref cond_exp, ref then_block, ref opt_else_exp) => {\n+                walk_expr(cx, cond_exp, scope_stack, scope_map);\n+\n+                do with_new_scope(cx, then_block.span, scope_stack, scope_map) |cx,\n+                                                                                scope_stack,\n+                                                                                scope_map| {\n+                    walk_block(cx, then_block, scope_stack, scope_map);\n+                }\n+\n+                match *opt_else_exp {\n+                    Some(@ref else_exp) => walk_expr(cx, else_exp, scope_stack, scope_map),\n+                    _ => ()\n+                }\n+            }\n+\n+            ast::expr_while(@ref cond_exp, ref loop_body) => {\n+                walk_expr(cx, cond_exp, scope_stack, scope_map);\n+\n+                do with_new_scope(cx, loop_body.span, scope_stack, scope_map) |cx,\n+                                                                               scope_stack,\n+                                                                               scope_map| {\n+                    walk_block(cx, loop_body, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::expr_for_loop(_, _, _) => {\n+                cx.sess.span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                                            Found unexpanded for-loop.\");\n+            }\n+\n+            ast::expr_mac(_) => {\n+                cx.sess.span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                                            Found unexpanded macro.\");\n+            }\n+\n+            ast::expr_loop(ref block, _) |\n+            ast::expr_block(ref block)   => {\n+                do with_new_scope(cx, block.span, scope_stack, scope_map) |cx,\n+                                                                           scope_stack,\n+                                                                           scope_map| {\n+                    walk_block(cx, block, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::expr_fn_block(ast::fn_decl { inputs: ref inputs, _ }, ref block) => {\n+                do with_new_scope(cx, block.span, scope_stack, scope_map) |cx,\n+                                                                           scope_stack,\n+                                                                           scope_map| {\n+                    for &ast::arg { pat: pattern, _ } in inputs.iter() {\n+                        walk_pattern(cx, pattern, scope_stack, scope_map);\n+                    }\n+\n+                    walk_block(cx, block, scope_stack, scope_map);\n+                }\n+            }\n+\n+            // ast::expr_loop_body(@ref inner_exp) |\n+            ast::expr_do_body(@ref inner_exp)   => {\n+                let inner_expr_is_expr_fn_block = match *inner_exp {\n+                    ast::expr { node: ast::expr_fn_block(*), _ } => true,\n+                    _ => false\n+                };\n+\n+                if !inner_expr_is_expr_fn_block {\n+                    cx.sess.span_bug(inner_exp.span, \"debuginfo: Inner expression was expected \\\n+                                                      to be an ast::expr_fn_block.\");\n+                }\n+\n+                walk_expr(cx, inner_exp, scope_stack, scope_map);\n+            }\n+\n+            ast::expr_call(@ref fn_exp, ref args, _) => {\n+                walk_expr(cx, fn_exp, scope_stack, scope_map);\n+\n+                for &@ref arg_exp in args.iter() {\n+                    walk_expr(cx, arg_exp, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::expr_method_call(node_id, @ref receiver_exp, _, _, ref args, _) => {\n+                scope_map.insert(node_id, scope_stack.last().scope_metadata);\n+                walk_expr(cx, receiver_exp, scope_stack, scope_map);\n+\n+                for &@ref arg_exp in args.iter() {\n+                    walk_expr(cx, arg_exp, scope_stack, scope_map);\n+                }\n+            }\n+\n+            ast::expr_match(@ref discriminant_exp, ref arms) => {\n+                walk_expr(cx, discriminant_exp, scope_stack, scope_map);\n+\n+                // for each arm we have to first walk the pattern as these might introduce new\n+                // artificial scopes. It should be sufficient to walk only one pattern per arm, as\n+                // they all must contain the same binding names\n+\n+                for arm_ref in arms.iter() {\n+                    let arm_span = arm_ref.pats[0].span;\n+\n+                    do with_new_scope(cx, arm_span, scope_stack, scope_map) |cx,\n+                                                                             scope_stack,\n+                                                                             scope_map| {\n+                        walk_pattern(cx, arm_ref.pats[0], scope_stack, scope_map);\n+\n+                        for &@ref guard_exp in arm_ref.guard.iter() {\n+                            walk_expr(cx, guard_exp, scope_stack, scope_map)\n+                        }\n+\n+                        walk_block(cx, &arm_ref.body, scope_stack, scope_map);\n+                    }\n+                }\n+            }\n+\n+            ast::expr_struct(_, ref fields, ref base_exp) => {\n+                for &ast::Field { expr: @ref exp, _ } in fields.iter() {\n+                    walk_expr(cx, exp, scope_stack, scope_map);\n+                }\n+\n+                match *base_exp {\n+                    Some(@ref exp) => walk_expr(cx, exp, scope_stack, scope_map),\n+                    None => ()\n+                }\n+            }\n+\n+            ast::expr_inline_asm(ast::inline_asm { inputs: ref inputs,\n+                                                   outputs: ref outputs,\n+                                                   _ }) => {\n+                // inputs, outputs: ~[(@str, @expr)]\n+                for &(_, @ref exp) in inputs.iter() {\n+                    walk_expr(cx, exp, scope_stack, scope_map);\n+                }\n+\n+                for &(_, @ref exp) in outputs.iter() {\n+                    walk_expr(cx, exp, scope_stack, scope_map);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "d56fcb1081f6f96d03daee7c67e13ccb85bb8837", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -413,7 +413,7 @@ pub fn trans_into(bcx: @mut Block, expr: @ast::expr, dest: Dest) -> @mut Block {\n            dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n \n-    debuginfo::update_source_pos(bcx, expr.span);\n+    debuginfo::update_source_pos(bcx.fcx, expr.id, expr.span);\n \n     let dest = {\n         if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n@@ -485,7 +485,7 @@ fn trans_to_datum_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     debug!(\"trans_to_datum_unadjusted(expr=%s)\", bcx.expr_to_str(expr));\n     let _indenter = indenter();\n \n-    debuginfo::update_source_pos(bcx, expr.span);\n+    debuginfo::update_source_pos(bcx.fcx, expr.id, expr.span);\n \n     match ty::expr_kind(bcx.tcx(), bcx.ccx().maps.method_map, expr) {\n         ty::LvalueExpr => {"}, {"sha": "9aae26b50be78925c02c520a644eb61d78bbdb22", "filename": "src/test/debug-info/lexical-scope-in-for-loop.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-for-loop.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// FIRST ITERATION\n+// debugger:finish\n+// debugger:print x\n+// check:$1 = 1\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$2 = -1\n+// debugger:continue\n+\n+// SECOND ITERATION\n+// debugger:finish\n+// debugger:print x\n+// check:$3 = 2\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$4 = -2\n+// debugger:continue\n+\n+// THIRD ITERATION\n+// debugger:finish\n+// debugger:print x\n+// check:$5 = 3\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$6 = -3\n+// debugger:continue\n+\n+// AFTER LOOP\n+// debugger:finish\n+// debugger:print x\n+// check:$7 = 1000000\n+// debugger:continue\n+\n+fn main() {\n+\n+    let range = [1, 2, 3];\n+\n+    let x = 1000000; // wan meeeljen doollaars!\n+\n+    for &x in range.iter() {\n+        zzz();\n+        sentinel();\n+\n+        let x = -1 * x;\n+\n+        zzz();\n+        sentinel();\n+    }\n+\n+    zzz();\n+    sentinel();\n+}\n+\n+fn zzz() {()}\n+fn sentinel() {()}"}, {"sha": "296ad7ca861e6cfecfbfd9cb5898edd6d08a4d42", "filename": "src/test/debug-info/lexical-scope-in-if.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-if.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// BEFORE if\n+// debugger:finish\n+// debugger:print x\n+// check:$1 = 999\n+// debugger:print y\n+// check:$2 = -1\n+// debugger:continue\n+\n+// AT BEGINNING of 'then' block\n+// debugger:finish\n+// debugger:print x\n+// check:$3 = 999\n+// debugger:print y\n+// check:$4 = -1\n+// debugger:continue\n+\n+// AFTER 1st redeclaration of 'x'\n+// debugger:finish\n+// debugger:print x\n+// check:$5 = 1001\n+// debugger:print y\n+// check:$6 = -1\n+// debugger:continue\n+\n+// AFTER 2st redeclaration of 'x'\n+// debugger:finish\n+// debugger:print x\n+// check:$7 = 1002\n+// debugger:print y\n+// check:$8 = 1003\n+// debugger:continue\n+\n+// AFTER 1st if expression\n+// debugger:finish\n+// debugger:print x\n+// check:$9 = 999\n+// debugger:print y\n+// check:$10 = -1\n+// debugger:continue\n+\n+// BEGINNING of else branch\n+// debugger:finish\n+// debugger:print x\n+// check:$11 = 999\n+// debugger:print y\n+// check:$12 = -1\n+// debugger:continue\n+\n+// BEGINNING of else branch\n+// debugger:finish\n+// debugger:print x\n+// check:$13 = 1004\n+// debugger:print y\n+// check:$14 = 1005\n+// debugger:continue\n+\n+// BEGINNING of else branch\n+// debugger:finish\n+// debugger:print x\n+// check:$15 = 999\n+// debugger:print y\n+// check:$16 = -1\n+// debugger:continue\n+\n+use std::util;\n+\n+fn main() {\n+\n+    let x = 999;\n+    let y = -1;\n+\n+    zzz();\n+    sentinel();\n+\n+    if x < 1000 {\n+        zzz();\n+        sentinel();\n+\n+        let x = 1001;\n+\n+        zzz();\n+        sentinel();\n+\n+        let x = 1002;\n+        let y = 1003;\n+        zzz();\n+        sentinel();\n+    } else {\n+        util::unreachable();\n+    }\n+\n+    zzz();\n+    sentinel();\n+\n+    if x > 1000 {\n+        util::unreachable();\n+    } else {\n+        zzz();\n+        sentinel();\n+\n+        let x = 1004;\n+        let y = 1005;\n+        zzz();\n+        sentinel();\n+    }\n+\n+    zzz();\n+    sentinel();\n+}\n+\n+fn zzz() {()}\n+fn sentinel() {()}"}, {"sha": "d04818b56cdab785062fc6d04c97d7db15be323c", "filename": "src/test/debug-info/lexical-scope-in-managed-closure.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-managed-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-managed-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-managed-closure.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$1 = false\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$2 = false\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$3 = 1000\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$4 = 2.5\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$5 = true\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$6 = false\n+// debugger:continue\n+\n+fn main() {\n+\n+    let x = false;\n+\n+    zzz();\n+    sentinel();\n+\n+    let managed_closure: @fn(int) = |x| {\n+        zzz();\n+        sentinel();\n+\n+        let x = 2.5;\n+\n+        zzz();\n+        sentinel();\n+\n+        let x = true;\n+\n+        zzz();\n+        sentinel();\n+    };\n+\n+    zzz();\n+    sentinel();\n+\n+    managed_closure(1000);\n+\n+    zzz();\n+    sentinel();\n+}\n+\n+fn zzz() {()}\n+fn sentinel() {()}"}, {"sha": "ccdb20d8202048092cd28ef68e9f690975a56320", "filename": "src/test/debug-info/lexical-scope-in-match.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-match.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -0,0 +1,148 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print shadowed\n+// check:$1 = 231\n+// debugger:print not_shadowed\n+// check:$2 = 232\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print shadowed\n+// check:$3 = 233\n+// debugger:print not_shadowed\n+// check:$4 = 232\n+// debugger:print local_to_arm\n+// check:$5 = 234\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print shadowed\n+// check:$6 = 236\n+// debugger:print not_shadowed\n+// check:$7 = 232\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print shadowed\n+// check:$8 = 237\n+// debugger:print not_shadowed\n+// check:$9 = 232\n+// debugger:print local_to_arm\n+// check:$10 = 238\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print shadowed\n+// check:$11 = 239\n+// debugger:print not_shadowed\n+// check:$12 = 232\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print shadowed\n+// check:$13 = 241\n+// debugger:print not_shadowed\n+// check:$14 = 232\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print shadowed\n+// check:$15 = 243\n+// debugger:print *local_to_arm\n+// check:$16 = 244\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print shadowed\n+// check:$17 = 231\n+// debugger:print not_shadowed\n+// check:$18 = 232\n+// debugger:continue\n+\n+struct Struct {\n+    x: int,\n+    y: int\n+}\n+\n+fn main() {\n+\n+    let shadowed = 231;\n+    let not_shadowed = 232;\n+\n+    zzz();\n+    sentinel();\n+\n+    match (233, 234) {\n+        (shadowed, local_to_arm) => {\n+\n+            zzz();\n+            sentinel();\n+        }\n+    }\n+\n+    match (235, 236) {\n+        // with literal\n+        (235, shadowed) => {\n+\n+            zzz();\n+            sentinel();\n+        }\n+        _ => {}\n+    }\n+\n+    match Struct { x: 237, y: 238 } {\n+        Struct { x: shadowed, y: local_to_arm } => {\n+\n+            zzz();\n+            sentinel();\n+        }\n+    }\n+\n+    match Struct { x: 239, y: 240 } {\n+        // ignored field\n+        Struct { x: shadowed, _ } => {\n+\n+            zzz();\n+            sentinel();\n+        }\n+    }\n+\n+    match Struct { x: 241, y: 242 } {\n+        // with literal\n+        Struct { x: shadowed, y: 242 } => {\n+\n+            zzz();\n+            sentinel();\n+        }\n+        _ => {}\n+    }\n+\n+    match (243, 244) {\n+        (shadowed, ref local_to_arm) => {\n+\n+            zzz();\n+            sentinel();\n+        }\n+    }\n+\n+    zzz();\n+    sentinel();\n+}\n+\n+fn zzz() {()}\n+fn sentinel() {()}"}, {"sha": "dd86b4a8673a5acddc6dbcd31e448d75efff135c", "filename": "src/test/debug-info/lexical-scope-in-stack-closure.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-stack-closure.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$1 = false\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$2 = false\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$3 = 1000\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$4 = 2.5\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$5 = true\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$6 = false\n+// debugger:continue\n+\n+fn main() {\n+\n+    let x = false;\n+\n+    zzz();\n+    sentinel();\n+\n+    let stack_closure: &fn(int) = |x| {\n+        zzz();\n+        sentinel();\n+\n+        let x = 2.5;\n+\n+        zzz();\n+        sentinel();\n+\n+        let x = true;\n+\n+        zzz();\n+        sentinel();\n+    };\n+\n+    zzz();\n+    sentinel();\n+\n+    stack_closure(1000);\n+\n+    zzz();\n+    sentinel();\n+}\n+\n+fn zzz() {()}\n+fn sentinel() {()}"}, {"sha": "21c4e74668590ea48b29995177d1bc919d51b5d3", "filename": "src/test/debug-info/lexical-scope-in-unconditional-loop.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-unconditional-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-unconditional-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-unconditional-loop.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// FIRST ITERATION\n+// debugger:finish\n+// debugger:print x\n+// check:$1 = 0\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$2 = 1\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$3 = 101\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$4 = 101\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$5 = -987\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$6 = 101\n+// debugger:continue\n+\n+\n+// SECOND ITERATION\n+// debugger:finish\n+// debugger:print x\n+// check:$7 = 1\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$8 = 2\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$9 = 102\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$10 = 102\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$11 = -987\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$12 = 102\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$13 = 2\n+// debugger:continue\n+\n+fn main() {\n+\n+    let mut x = 0;\n+\n+    loop {\n+        if x >= 2 {\n+            break;\n+        }\n+\n+        zzz();\n+        sentinel();\n+\n+        x += 1;\n+        zzz();\n+        sentinel();\n+\n+        // Shadow x\n+        let x = x + 100;\n+        zzz();\n+        sentinel();\n+\n+        // open scope within loop's top level scope\n+        {\n+            zzz();\n+            sentinel();\n+\n+            let x = -987;\n+\n+            zzz();\n+            sentinel();\n+        }\n+\n+        // Check that we get the x before the inner scope again\n+        zzz();\n+        sentinel();\n+    }\n+\n+    zzz();\n+    sentinel();\n+}\n+\n+fn zzz() {()}\n+fn sentinel() {()}"}, {"sha": "32251f4a8c230ba6db8179cf5e39c241c86d8efd", "filename": "src/test/debug-info/lexical-scope-in-unique-closure.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-unique-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-unique-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-unique-closure.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$1 = false\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$2 = false\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$3 = 1000\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$4 = 2.5\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$5 = true\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$6 = false\n+// debugger:continue\n+\n+fn main() {\n+\n+    let x = false;\n+\n+    zzz();\n+    sentinel();\n+\n+    let unique_closure: ~fn(int) = |x| {\n+        zzz();\n+        sentinel();\n+\n+        let x = 2.5;\n+\n+        zzz();\n+        sentinel();\n+\n+        let x = true;\n+\n+        zzz();\n+        sentinel();\n+    };\n+\n+    zzz();\n+    sentinel();\n+\n+    unique_closure(1000);\n+\n+    zzz();\n+    sentinel();\n+}\n+\n+fn zzz() {()}\n+fn sentinel() {()}"}, {"sha": "b350130df8f40083b98f818e90820c04cce7d426", "filename": "src/test/debug-info/lexical-scope-in-while.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-while.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -0,0 +1,123 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// FIRST ITERATION\n+// debugger:finish\n+// debugger:print x\n+// check:$1 = 0\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$2 = 1\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$3 = 101\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$4 = 101\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$5 = -987\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$6 = 101\n+// debugger:continue\n+\n+\n+// SECOND ITERATION\n+// debugger:finish\n+// debugger:print x\n+// check:$7 = 1\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$8 = 2\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$9 = 102\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$10 = 102\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$11 = -987\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$12 = 102\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$13 = 2\n+// debugger:continue\n+\n+fn main() {\n+\n+    let mut x = 0;\n+\n+    while x < 2 {\n+        zzz();\n+        sentinel();\n+\n+        x += 1;\n+        zzz();\n+        sentinel();\n+\n+        // Shadow x\n+        let x = x + 100;\n+        zzz();\n+        sentinel();\n+\n+        // open scope within loop's top level scope\n+        {\n+            zzz();\n+            sentinel();\n+\n+            let x = -987;\n+\n+            zzz();\n+            sentinel();\n+        }\n+\n+        // Check that we get the x before the inner scope again\n+        zzz();\n+        sentinel();\n+    }\n+\n+    zzz();\n+    sentinel();\n+}\n+\n+fn zzz() {()}\n+fn sentinel() {()}"}, {"sha": "409ecd5a0e2298b7f640bb7c26bc4c9174efbf93", "filename": "src/test/debug-info/lexical-scope-with-macro.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-with-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scope-with-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-with-macro.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print a\n+// check:$1 = 10\n+// debugger:print b\n+// check:$2 = 34\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print a\n+// check:$3 = 890242\n+// debugger:print b\n+// check:$4 = 34\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print a\n+// check:$5 = 10\n+// debugger:print b\n+// check:$6 = 34\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print a\n+// check:$7 = 102\n+// debugger:print b\n+// check:$8 = 34\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print a\n+// check:$9 = 110\n+// debugger:print b\n+// check:$10 = 34\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print a\n+// check:$11 = 10\n+// debugger:print b\n+// check:$12 = 34\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print a\n+// check:$13 = 10\n+// debugger:print b\n+// check:$14 = 34\n+// debugger:print c\n+// check:$15 = 400\n+// debugger:continue\n+\n+macro_rules! trivial(\n+    ($e1:expr) => ($e1)\n+)\n+\n+macro_rules! no_new_scope(\n+    ($e1:expr) => (($e1 + 2) - 1)\n+)\n+\n+macro_rules! new_scope(\n+    () => ({\n+        let a = 890242;\n+        zzz();\n+        sentinel();\n+    })\n+)\n+\n+macro_rules! shadow_within_macro(\n+    ($e1:expr) => ({\n+        let a = $e1 + 2;\n+\n+        zzz();\n+        sentinel();\n+\n+        let a = $e1 + 10;\n+\n+        zzz();\n+        sentinel();\n+    })\n+)\n+\n+\n+macro_rules! dup_expr(\n+    ($e1:expr) => (($e1) + ($e1))\n+)\n+\n+\n+fn main() {\n+\n+    let a = trivial!(10);\n+    let b = no_new_scope!(33);\n+\n+    zzz();\n+    sentinel();\n+\n+    new_scope!();\n+\n+    zzz();\n+    sentinel();\n+\n+    shadow_within_macro!(100);\n+\n+    zzz();\n+    sentinel();\n+\n+    let c = dup_expr!(10 * 20);\n+\n+    zzz();\n+    sentinel();\n+}\n+\n+fn zzz() {()}\n+fn sentinel() {()}"}, {"sha": "03de640053b7e90b1b8bb4665d9d84ca205cb624", "filename": "src/test/debug-info/lexical-scopes-in-block-expression.rs", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scopes-in-block-expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Flexical-scopes-in-block-expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scopes-in-block-expression.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -0,0 +1,344 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// STRUCT EXPRESSION\n+// debugger:finish\n+// debugger:print val\n+// check:$1 = -1\n+// debugger:print ten\n+// check:$2 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$3 = 11\n+// debugger:print ten\n+// check:$4 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$5 = -1\n+// debugger:print ten\n+// check:$6 = 10\n+// debugger:continue\n+\n+// FUNCTION CALL\n+// debugger:finish\n+// debugger:print val\n+// check:$7 = -1\n+// debugger:print ten\n+// check:$8 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$9 = 12\n+// debugger:print ten\n+// check:$10 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$11 = -1\n+// debugger:print ten\n+// check:$12 = 10\n+// debugger:continue\n+\n+// TUPLE EXPRESSION\n+// debugger:finish\n+// debugger:print val\n+// check:$13 = -1\n+// debugger:print ten\n+// check:$14 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$15 = 13\n+// debugger:print ten\n+// check:$16 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$17 = -1\n+// debugger:print ten\n+// check:$18 = 10\n+// debugger:continue\n+\n+// VEC EXPRESSION\n+// debugger:finish\n+// debugger:print val\n+// check:$19 = -1\n+// debugger:print ten\n+// check:$20 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$21 = 14\n+// debugger:print ten\n+// check:$22 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$23 = -1\n+// debugger:print ten\n+// check:$24 = 10\n+// debugger:continue\n+\n+// REPEAT VEC EXPRESSION\n+// debugger:finish\n+// debugger:print val\n+// check:$25 = -1\n+// debugger:print ten\n+// check:$26 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$27 = 15\n+// debugger:print ten\n+// check:$28 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$29 = -1\n+// debugger:print ten\n+// check:$30 = 10\n+// debugger:continue\n+\n+// ASSIGNMENT EXPRESSION\n+// debugger:finish\n+// debugger:print val\n+// check:$31 = -1\n+// debugger:print ten\n+// check:$32 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$33 = 16\n+// debugger:print ten\n+// check:$34 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$35 = -1\n+// debugger:print ten\n+// check:$36 = 10\n+// debugger:continue\n+\n+\n+// ARITHMETIC EXPRESSION\n+// debugger:finish\n+// debugger:print val\n+// check:$37 = -1\n+// debugger:print ten\n+// check:$38 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$39 = 17\n+// debugger:print ten\n+// check:$40 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$41 = -1\n+// debugger:print ten\n+// check:$42 = 10\n+// debugger:continue\n+\n+// INDEX EXPRESSION\n+// debugger:finish\n+// debugger:print val\n+// check:$43 = -1\n+// debugger:print ten\n+// check:$44 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$45 = 18\n+// debugger:print ten\n+// check:$46 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print val\n+// check:$47 = -1\n+// debugger:print ten\n+// check:$48 = 10\n+// debugger:continue\n+\n+struct Point {\n+    x: int,\n+    y: int\n+}\n+\n+fn a_function(x: int) -> int {\n+    x + 1\n+}\n+\n+fn main() {\n+\n+    let val = -1;\n+    let ten = 10;\n+\n+    // surrounded by struct expression\n+    let point = Point {\n+        x: {\n+            zzz();\n+            sentinel();\n+\n+            let val = ten + 1;\n+\n+            zzz();\n+            sentinel();\n+\n+            val\n+        },\n+        y: 10\n+    };\n+\n+    zzz();\n+    sentinel();\n+\n+    // surrounded by function call\n+    let _ = a_function({\n+        zzz();\n+        sentinel();\n+\n+        let val = ten + 2;\n+\n+        zzz();\n+        sentinel();\n+\n+        val\n+    });\n+\n+    zzz();\n+    sentinel();\n+\n+\n+    // surrounded by tup\n+    let _ = ({\n+        zzz();\n+        sentinel();\n+\n+        let val = ten + 3;\n+\n+        zzz();\n+        sentinel();\n+\n+        val\n+    }, 0);\n+\n+    zzz();\n+    sentinel();\n+\n+    // surrounded by vec\n+    let _ = [{\n+        zzz();\n+        sentinel();\n+\n+        let val = ten + 4;\n+\n+        zzz();\n+        sentinel();\n+\n+        val\n+    }, 0, 0];\n+\n+    zzz();\n+    sentinel();\n+\n+    // surrounded by repeat vec\n+    let _ = [{\n+        zzz();\n+        sentinel();\n+\n+        let val = ten + 5;\n+\n+        zzz();\n+        sentinel();\n+\n+        val\n+    }, ..10];\n+\n+    zzz();\n+    sentinel();\n+\n+    // assignment expression\n+    let mut var = 0;\n+    var = {\n+        zzz();\n+        sentinel();\n+\n+        let val = ten + 6;\n+\n+        zzz();\n+        sentinel();\n+\n+        val\n+    };\n+\n+    zzz();\n+    sentinel();\n+\n+    // arithmetic expression\n+    var = 10 + -{\n+        zzz();\n+        sentinel();\n+\n+        let val = ten + 7;\n+\n+        zzz();\n+        sentinel();\n+\n+        val\n+    } * 5;\n+\n+    zzz();\n+    sentinel();\n+\n+    // index expression\n+    let a_vector = [10, ..20];\n+    let _ = a_vector[{\n+        zzz();\n+        sentinel();\n+\n+        let val = ten + 8;\n+\n+        zzz();\n+        sentinel();\n+\n+        val\n+    }];\n+\n+    zzz();\n+    sentinel();\n+}\n+\n+fn zzz() {()}\n+fn sentinel() {()}"}, {"sha": "ba8c08e46fd1086ae39df475731a2d8803556a85", "filename": "src/test/debug-info/name-shadowing-and-scope-nesting.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Fname-shadowing-and-scope-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Fname-shadowing-and-scope-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fname-shadowing-and-scope-nesting.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$1 = false\n+// debugger:print y\n+// check:$2 = true\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$3 = 10\n+// debugger:print y\n+// check:$4 = true\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$5 = 10.5\n+// debugger:print y\n+// check:$6 = 20\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$7 = true\n+// debugger:print y\n+// check:$8 = 2220\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$9 = 203203.5\n+// debugger:print y\n+// check:$10 = 2220\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$11 = 10.5\n+// debugger:print y\n+// check:$12 = 20\n+// debugger:continue\n+\n+fn main() {\n+    let x = false;\n+    let y = true;\n+\n+    zzz();\n+    sentinel();\n+\n+    let x = 10;\n+\n+    zzz();\n+    sentinel();\n+\n+    let x = 10.5;\n+    let y = 20;\n+\n+    zzz();\n+    sentinel();\n+\n+    {\n+        let x = true;\n+        let y = 2220;\n+\n+        zzz();\n+        sentinel();\n+\n+        let x = 203203.5;\n+\n+        zzz();\n+        sentinel();\n+    }\n+\n+    zzz();\n+    sentinel();\n+}\n+\n+fn zzz() {()}\n+fn sentinel() {()}"}, {"sha": "b79b65c5f80db3652f2f24fb592a247b131e82ed", "filename": "src/test/debug-info/shadowed-argument.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Fshadowed-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Fshadowed-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fshadowed-argument.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$1 = false\n+// debugger:print y\n+// check:$2 = true\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$3 = 10\n+// debugger:print y\n+// check:$4 = true\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$5 = 10.5\n+// debugger:print y\n+// check:$6 = 20\n+// debugger:continue\n+\n+fn a_function(x: bool, y: bool) {\n+    zzz();\n+    sentinel();\n+\n+    let x = 10;\n+\n+    zzz();\n+    sentinel();\n+\n+    let x = 10.5;\n+    let y = 20;\n+\n+    zzz();\n+    sentinel();\n+}\n+\n+fn main() {\n+    a_function(false, true);\n+}\n+\n+fn zzz() {()}\n+fn sentinel() {()}"}, {"sha": "a532f7fbc2e0c9ae7e6a42f4327d1b6d8b002dd5", "filename": "src/test/debug-info/shadowed-variable.rs", "status": "renamed", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Fshadowed-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Fshadowed-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fshadowed-variable.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -8,42 +8,51 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run\n+\n // debugger:finish\n // debugger:print x\n // check:$1 = false\n // debugger:print y\n // check:$2 = true\n-\n // debugger:continue\n+\n // debugger:finish\n // debugger:print x\n // check:$3 = 10\n-\n+// debugger:print y\n+// check:$4 = true\n // debugger:continue\n+\n // debugger:finish\n // debugger:print x\n-// check:$4 = false\n+// check:$5 = 10.5\n // debugger:print y\n-// check:$5 = 11\n+// check:$6 = 20\n+// debugger:continue\n \n fn main() {\n     let x = false;\n     let y = true;\n \n     zzz();\n+    sentinel();\n+\n+    let x = 10;\n+\n+    zzz();\n+    sentinel();\n \n-    {\n-        let x = 10;\n-        zzz();\n-    }\n+    let x = 10.5;\n+    let y = 20;\n \n-    let y = 11;\n     zzz();\n+    sentinel();\n }\n \n fn zzz() {()}\n+fn sentinel() {()}", "previous_filename": "src/test/debug-info/variable-scope.rs"}, {"sha": "96a394b5ed7b98fd56786ba7ccc2c521993fec1e", "filename": "src/test/debug-info/simple-lexical-scope.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Fsimple-lexical-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433fbe8fcf13724445cc57c85cc454352c969429/src%2Ftest%2Fdebug-info%2Fsimple-lexical-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fsimple-lexical-scope.rs?ref=433fbe8fcf13724445cc57c85cc454352c969429", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$1 = false\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$2 = false\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$3 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$4 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$5 = 10.5\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$6 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$7 = false\n+// debugger:continue\n+\n+\n+fn main() {\n+    let x = false;\n+\n+    zzz();\n+    sentinel();\n+\n+    {\n+        zzz();\n+        sentinel();\n+\n+        let x = 10;\n+\n+        zzz();\n+        sentinel();\n+\n+        {\n+            zzz();\n+            sentinel();\n+\n+            let x = 10.5;\n+\n+            zzz();\n+            sentinel();\n+        }\n+\n+        zzz();\n+        sentinel();\n+    }\n+\n+    zzz();\n+    sentinel();\n+}\n+\n+fn zzz() {()}\n+fn sentinel() {()}"}]}