{"sha": "54ca8565c96601a0ffa99cdf8f7f3d1550f39180", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0Y2E4NTY1Yzk2NjAxYTBmZmE5OWNkZjhmN2YzZDE1NTBmMzkxODA=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-05-25T17:10:30Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-27T02:42:33Z"}, "message": "Fix bugs: make sure glob imports show up in the right module,\nand make sure that circular glob imports don't diverge.", "tree": {"sha": "fa3bba9c878296065233859b3a61e71f5da1f29c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa3bba9c878296065233859b3a61e71f5da1f29c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54ca8565c96601a0ffa99cdf8f7f3d1550f39180", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54ca8565c96601a0ffa99cdf8f7f3d1550f39180", "html_url": "https://github.com/rust-lang/rust/commit/54ca8565c96601a0ffa99cdf8f7f3d1550f39180", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54ca8565c96601a0ffa99cdf8f7f3d1550f39180/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3375b8fba2bc1481de9bf3d589a020b442351712", "url": "https://api.github.com/repos/rust-lang/rust/commits/3375b8fba2bc1481de9bf3d589a020b442351712", "html_url": "https://github.com/rust-lang/rust/commit/3375b8fba2bc1481de9bf3d589a020b442351712"}], "stats": {"total": 248, "additions": 178, "deletions": 70}, "files": [{"sha": "f0ae03925aa5638cd39b426a6744f2c76473c204", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 92, "deletions": 65, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/54ca8565c96601a0ffa99cdf8f7f3d1550f39180/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ca8565c96601a0ffa99cdf8f7f3d1550f39180/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=54ca8565c96601a0ffa99cdf8f7f3d1550f39180", "patch": "@@ -12,6 +12,7 @@ import util::common::new_str_hash;\n import util::common::span;\n import middle::tstate::ann::ts_ann;\n import std::map::hashmap;\n+import std::list;\n import std::list::list;\n import std::list::nil;\n import std::list::cons;\n@@ -168,40 +169,43 @@ fn map_crate(&@env e, &ast::crate c) {\n     }\n \n     // Next, assemble the links for globbed imports.\n-    \n-    let @indexed_mod cur_mod = e.mod_map.get(-1);\n-\n     cell = @mutable nil[scope];\n-    auto link_globs = \n+    auto link_globs =\n         rec(visit_crate_pre = bind push_env_for_crate(cell, _),\n             visit_crate_post = bind pop_env_for_crate(cell, _),\n-            visit_view_item_pre = bind link_glob(e, cell, cur_mod, _),\n-            visit_item_pre = bind enter_i(e, cell, cur_mod, _),\n+            visit_view_item_pre = bind link_glob(e, cell, _),\n+            visit_item_pre = bind push_env_for_item(cell, _),\n             visit_item_post = bind pop_env_for_item(cell, _)\n             with walk::default_visitor());\n     walk::walk_crate(link_globs, c);\n-    \n-    fn enter_i(@env e, @mutable list[scope] sc, @indexed_mod cur_mod, \n-               &@ast::item i) {\n-        push_env_for_item(sc,i);\n-        alt(i.node) {\n-            case (ast::item_mod(_, _, ?defid)) {\n-                cur_mod = e.mod_map.get(defid._1);\n-            }\n-            case (ast::item_native_mod(_, _, ?defid)) {\n-                cur_mod = e.mod_map.get(defid._1);\n+            \n+    fn link_glob(@env e, @mutable list[scope] sc, &@ast::view_item vi) {\n+        fn find_mod(@env e, list[scope] sc) -> @indexed_mod {\n+            alt (sc) {\n+                case (cons[scope](scope_item(?i), ?tl)) {\n+                    alt(i.node) {\n+                        case (ast::item_mod(_, _, ?defid)) {\n+                            ret e.mod_map.get(defid._1);\n+                        }\n+                        case (ast::item_native_mod(_, _, ?defid)) {\n+                            ret e.mod_map.get(defid._1);\n+                        }\n+                        case (_) {\n+                            be find_mod(e, *tl);\n+                        }\n+                    }\n+                }\n+                case (_) {\n+                    ret e.mod_map.get(-1); //top-level\n+                }\n             }\n-            case (_) {}\n         }\n-    }\n-        \n-    fn link_glob(@env e, @mutable list[scope] sc, @indexed_mod cur_mod,\n-                 &@ast::view_item vi) {\n+\n         alt (vi.node) {\n             //if it really is a glob import, that is\n             case (ast::view_item_import_glob(?path, _)) {\n-                cur_mod.glob_imports += \n-                    [follow_import(*e, *sc, path, vi.span)];\n+                find_mod(e, *sc).glob_imports \n+                    += [follow_import(*e, *sc, path, vi.span)];\n             }\n             case (_) {}\n         }\n@@ -518,10 +522,13 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n     -> option::t[def] {\n     fn in_scope(&env e, &span sp, &ident id, &scope s, namespace ns)\n         -> option::t[def] {\n+        //not recursing through globs\n+        let list[def] no_m = nil[def];\n+\n         alt (s) {\n             case (scope_crate(?c)) {\n                 auto defid = tup(ast::local_crate, -1);\n-                ret lookup_in_local_mod(e, defid, sp, id, ns, inside);\n+                ret lookup_in_local_mod(e, defid, no_m, sp, id, ns, inside);\n             }\n             case (scope_item(?it)) {\n                 alt (it.node) {\n@@ -537,10 +544,12 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n                         }\n                     }\n                     case (ast::item_mod(_, _, ?defid)) {\n-                        ret lookup_in_local_mod(e, defid, sp, id, ns, inside);\n+                        ret lookup_in_local_mod(e, defid, no_m, sp, \n+                                                id, ns, inside);\n                     }\n                     case (ast::item_native_mod(_, ?m, ?defid)) {\n-                        ret lookup_in_local_native_mod(e, defid, sp, id, ns);\n+                        ret lookup_in_local_native_mod(e, defid, no_m, \n+                                                       sp, id, ns);\n                     }\n                     case (ast::item_ty(_, _, ?ty_params, _, _)) {\n                         if (ns == ns_type) {\n@@ -768,26 +777,44 @@ fn lookup_in_mod_strict(&env e, def m, &span sp, &ident id,\n \n fn lookup_in_mod(&env e, def m, &span sp, &ident id, namespace ns, dir dr)\n     -> option::t[def] {\n-    auto defid = ast::def_id_of_def(m);\n-    if (defid._0 != ast::local_crate) { // examining a mod. in an ext. crate\n-        auto cached = e.ext_cache.find(tup(defid,id,ns));\n-        if (!option::is_none(cached)) { ret cached; }\n-        auto path = [id];\n-        if (defid._1 != -1) {\n-            path = e.ext_map.get(defid) + path;\n-        }\n-        auto fnd = lookup_external(e, defid._0, path, ns);\n-        if (!option::is_none(fnd)) {\n-            e.ext_cache.insert(tup(defid,id,ns), option::get(fnd));\n-        }\n-        ret fnd;\n-    }\n+    be lookup_in_mod_recursively(e, cons[def](m, @nil[def]), sp, id, ns, dr);\n+}\n+\n+// this list is simply the stack of glob imports we have passed through\n+// (preventing cyclic glob imports from diverging)\n+fn lookup_in_mod_recursively(&env e, list[def] m, &span sp, &ident id, \n+                             namespace ns, dir dr) -> option::t[def] {\n     alt (m) {\n-        case (ast::def_mod(?defid)) {\n-            ret lookup_in_local_mod(e, defid, sp, id, ns, dr);\n+        case (cons[def](?mod_def, ?tl)) {\n+            if (list::has(*tl, mod_def)) {\n+                ret none[def]; // import glob cycle detected; we're done\n+            }\n+            auto defid = ast::def_id_of_def(mod_def);\n+            if (defid._0 != ast::local_crate) {\n+                // examining a module in an external crate\n+                auto cached = e.ext_cache.find(tup(defid,id,ns));\n+                if (!option::is_none(cached)) { ret cached; }\n+                auto path = [id];\n+                if (defid._1 != -1) {\n+                    path = e.ext_map.get(defid) + path;\n+                }\n+                auto fnd = lookup_external(e, defid._0, path, ns);\n+                if (!option::is_none(fnd)) {\n+                    e.ext_cache.insert(tup(defid,id,ns), option::get(fnd));\n+                }\n+                ret fnd;\n+            }\n+            alt (mod_def) {\n+                case (ast::def_mod(?defid)) {\n+                    ret lookup_in_local_mod(e, defid, m, sp, id, ns, dr);\n+                }\n+                case (ast::def_native_mod(?defid)) {\n+                    ret lookup_in_local_native_mod(e, defid, m, sp, id, ns);\n+                }\n+            }\n         }\n-        case (ast::def_native_mod(?defid)) {\n-            ret lookup_in_local_native_mod(e, defid, sp, id, ns);\n+        case (_) { \n+            e.sess.bug(\"lookup_in_mod_recursively needs a module\"); fail;\n         }\n     }\n }\n@@ -825,8 +852,14 @@ fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n     fail;\n }\n \n-fn lookup_in_local_mod(&env e, def_id defid, &span sp, &ident id, \n-                       namespace ns, dir dr) -> option::t[def] {\n+\n+fn lookup_in_local_native_mod(&env e, def_id defid, list[def] m, &span sp,\n+                              &ident id, namespace ns) -> option::t[def] {\n+    ret lookup_in_local_mod(e, defid, m, sp, id, ns, inside);\n+}\n+\n+fn lookup_in_local_mod(&env e, def_id defid, list[def] m, &span sp, \n+                       &ident id, namespace ns, dir dr) -> option::t[def] {\n     auto info = e.mod_map.get(defid._1);\n     if (dr == outside && !ast::is_exported(id, option::get(info.m))) {\n         // if we're in a native mod, then dr==inside, so info.m is some _mod\n@@ -848,26 +881,24 @@ fn lookup_in_local_mod(&env e, def_id defid, &span sp, &ident id,\n         }\n     }\n     // not local or explicitly imported; try globs:\n-    ret lookup_glob_in_mod(e, info, sp, id, ns, dr);\n+    ret lookup_glob_in_mod(e, info, m, sp, id, ns, dr);\n }\n \n-fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp, &ident id, \n-                      namespace ns, dir dr) -> option::t[def] {\n-    fn l_i_m(&env e, &def d, &span sp, &ident id, namespace ns, dir dr)\n-        -> option::t[def] {\n-        ret lookup_in_mod(e, d, sp, id, ns, dr);\n+fn lookup_glob_in_mod(&env e, @indexed_mod info, list[def] m, &span sp, \n+                      &ident id, namespace ns, dir dr) -> option::t[def] {\n+    fn l_i_m_r(&env e, list[def] prev_ms, &def m, &span sp, &ident id, \n+               namespace ns, dir dr) -> option::t[def] {\n+        be lookup_in_mod_recursively(e, cons[def](m, @prev_ms), \n+                                     sp, id, ns, dr);\n     }\n-    auto matches = vec::filter_map\n-        (bind l_i_m(e, _, sp, id, ns, dr), info.glob_imports);\n+    auto matches = vec::filter_map[def, def]\n+        (bind l_i_m_r(e, m, _, sp, id, ns, dr), \n+         info.glob_imports);\n     if (vec::len(matches) == 0u) {\n         ret none[def];\n     } else if (vec::len(matches) == 1u){\n         ret some[def](matches.(0));\n     } else {\n-        for (def d in matches) {\n-            e.sess.span_note(sp, \"'\" + id + \"' is defined at \" + \n-                             util::common::istr(ast::def_id_of_def(d)._1));\n-        }\n         e.sess.span_err(sp, \"'\" + id + \"' is glob-imported from\" +\n                         \" multiple different modules.\");\n         fail;\n@@ -914,10 +945,6 @@ fn lookup_in_mie(&env e, &mod_index_entry mie, namespace ns)\n     ret none[def];\n }\n \n-fn lookup_in_local_native_mod(&env e, def_id defid, &span sp, &ident id, \n-                              namespace ns) -> option::t[def] {\n-    ret lookup_in_local_mod(e, defid, sp, id, ns, inside);\n-}\n \n \n // Module indexing\n@@ -945,9 +972,8 @@ fn index_mod(&ast::_mod md) -> mod_index {\n             case(ast::view_item_import(?def_ident,_,_)) {\n                 add_to_index(index, def_ident, mie_view_item(it));\n             }\n-            case(ast::view_item_import_glob(?path,_)) {\n-                //globbed imports have to be resolved lazily.\n-            }\n+            //globbed imports have to be resolved lazily.\n+            case(ast::view_item_import_glob(_,_)) {}\n             case(ast::view_item_export(_)) {}\n         }\n     }\n@@ -995,6 +1021,7 @@ fn index_nmod(&ast::native_mod md) -> mod_index {\n             case(ast::view_item_import(?def_ident,_,_)) {\n                 add_to_index(index, def_ident, mie_view_item(it));\n             }\n+            case(ast::view_item_import_glob(_,_)) {}\n             case(ast::view_item_export(_)) {}\n         }\n     }"}, {"sha": "63bc0b57ad213ae75e995a8b1db8dee7bcf04a68", "filename": "src/test/compile-fail/import-glob-0.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/54ca8565c96601a0ffa99cdf8f7f3d1550f39180/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ca8565c96601a0ffa99cdf8f7f3d1550f39180/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs?ref=54ca8565c96601a0ffa99cdf8f7f3d1550f39180", "patch": "@@ -1,5 +1,12 @@\n+// error-pattern: unresolved name\n+\n+import module_of_many_things::*;\n+\n mod module_of_many_things {\n-  export f1, f2, f4;\n+  export f1;\n+  export f2;\n+  export f4;\n+\n   fn f1() {\n     log \"f1\";\n   }\n@@ -14,11 +21,10 @@ mod module_of_many_things {\n   }\n }\n \n-import module_of_many_things::*;\n \n fn main() {\n   f1();\n   f2();\n-  f3();\n+  f999(); // 'export' currently doesn't work?\n   f4();\n }\n\\ No newline at end of file"}, {"sha": "9e9b5e3c9db5c18a148ad10a7b1f4d89e40ee8f6", "filename": "src/test/compile-fail/import-glob-circular.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/54ca8565c96601a0ffa99cdf8f7f3d1550f39180/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ca8565c96601a0ffa99cdf8f7f3d1550f39180/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs?ref=54ca8565c96601a0ffa99cdf8f7f3d1550f39180", "patch": "@@ -0,0 +1,29 @@\n+\n+// error-pattern: unresolved name\n+mod circ1 {\n+  import circ1::*;\n+  fn f1() {\n+    log \"f1\";\n+  }\n+  fn common() -> uint {\n+    ret 0u;\n+  }\n+}\n+\n+mod circ2 {\n+  import circ2::*;\n+  fn f2() {\n+    log \"f2\";\n+  }\n+  fn common() -> uint {\n+    ret 1u;\n+  }\n+}\n+\n+mod test {\n+  import circ1::*;\n+\n+  fn test() {\n+    f1066();\n+  }\n+}\n\\ No newline at end of file"}, {"sha": "33ca7cabd0eeac550ea41e2327603d51cca480fc", "filename": "src/test/run-pass/import-glob-0.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/54ca8565c96601a0ffa99cdf8f7f3d1550f39180/src%2Ftest%2Frun-pass%2Fimport-glob-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ca8565c96601a0ffa99cdf8f7f3d1550f39180/src%2Ftest%2Frun-pass%2Fimport-glob-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-0.rs?ref=54ca8565c96601a0ffa99cdf8f7f3d1550f39180", "patch": "@@ -31,7 +31,6 @@ mod dug {\n             fn also_redstone() {\n               log \"Whatever.\";\n             }\n-            fn f1() {}\n           }\n         }\n       }"}, {"sha": "e02be57dcabf7623a61f6b0ef7069ac701dd7a41", "filename": "src/test/run-pass/import-glob-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54ca8565c96601a0ffa99cdf8f7f3d1550f39180/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ca8565c96601a0ffa99cdf8f7f3d1550f39180/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs?ref=54ca8565c96601a0ffa99cdf8f7f3d1550f39180", "patch": "@@ -1,4 +1,4 @@\n-import a1:b1::word_traveler;\n+import a1::b1::word_traveler;\n \n mod a1 {                    // \n   mod b1 {                  // "}, {"sha": "ba786178b61dba72f1dd33b4d4debe1ad6f244a2", "filename": "src/test/run-pass/import-glob-circular.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/54ca8565c96601a0ffa99cdf8f7f3d1550f39180/src%2Ftest%2Frun-pass%2Fimport-glob-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ca8565c96601a0ffa99cdf8f7f3d1550f39180/src%2Ftest%2Frun-pass%2Fimport-glob-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-circular.rs?ref=54ca8565c96601a0ffa99cdf8f7f3d1550f39180", "patch": "@@ -0,0 +1,47 @@\n+import test1::*;\n+import test2::*;\n+\n+mod circ1 {\n+  import circ1::*;\n+  fn f1() {\n+    log \"f1\";\n+  }\n+  fn common() -> uint {\n+    ret 0u;\n+  }\n+}\n+\n+mod circ2 {\n+  import circ2::*;\n+  fn f2() {\n+    log \"f2\";\n+  }\n+  fn common() -> uint {\n+    ret 1u;\n+  }\n+}\n+\n+mod test1 {\n+  import circ1::*;\n+  fn test1() {\n+    f1();\n+    f2();\n+    assert(common() == 0u);\n+  }\n+}\n+\n+mod test2 {\n+  import circ2::*;\n+  fn test2() {\n+    f1();\n+    f2();\n+    assert(common() == 1u);\n+  }\n+}\n+\n+\n+\n+fn main() {\n+  test1();\n+  test2();\n+}\n\\ No newline at end of file"}]}