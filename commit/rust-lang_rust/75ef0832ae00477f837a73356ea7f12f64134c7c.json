{"sha": "75ef0832ae00477f837a73356ea7f12f64134c7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZWYwODMyYWUwMDQ3N2Y4MzdhNzMzNTZlYTdmMTJmNjQxMzRjN2M=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-07T07:16:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-08T00:54:34Z"}, "message": "rustdoc: Improve handling inlined associated types\n\n* All bounds are now discovered through the trait to be inlined.\n* The `?Sized` bound now renders correctly for inlined associated types.\n* All `QPath`s (`<A as B>::C`) instances are rendered as `A::C` where `C` is a\n  hyperlink to the trait `B`. This should improve at least how the docs look at\n  least.\n* Supertrait bounds are now separated and display as the source lists them.\n\nCloses #20727\nCloses #21145", "tree": {"sha": "589e3b6fb2f10c5d5905650bbd936b8fd249a04f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/589e3b6fb2f10c5d5905650bbd936b8fd249a04f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75ef0832ae00477f837a73356ea7f12f64134c7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75ef0832ae00477f837a73356ea7f12f64134c7c", "html_url": "https://github.com/rust-lang/rust/commit/75ef0832ae00477f837a73356ea7f12f64134c7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75ef0832ae00477f837a73356ea7f12f64134c7c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11f26f999581e639233e64f4f1fbc210a2bb856a", "url": "https://api.github.com/repos/rust-lang/rust/commits/11f26f999581e639233e64f4f1fbc210a2bb856a", "html_url": "https://github.com/rust-lang/rust/commit/11f26f999581e639233e64f4f1fbc210a2bb856a"}], "stats": {"total": 451, "additions": 382, "deletions": 69}, "files": [{"sha": "f9d3d707bb5ddc2e3ab8977dce5c380e9cb8c960", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=75ef0832ae00477f837a73356ea7f12f64134c7c", "patch": "@@ -1264,7 +1264,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n         encode_defaulted(rbml_w, ty::trait_has_default_impl(tcx, def_id));\n         encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n-        encode_generics(rbml_w, ecx, &trait_def.generics, &trait_predicates, tag_item_generics);\n+        encode_generics(rbml_w, ecx, &trait_def.generics, &trait_predicates,\n+                        tag_item_generics);\n         encode_predicates(rbml_w, ecx, &ty::lookup_super_predicates(tcx, def_id),\n                           tag_item_super_predicates);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);"}, {"sha": "24184bae95b69451acc9895f1dd01a1638f78530", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=75ef0832ae00477f837a73356ea7f12f64134c7c", "patch": "@@ -150,11 +150,14 @@ pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n     let def = ty::lookup_trait_def(tcx, did);\n     let trait_items = ty::trait_items(tcx, did).clean(cx);\n     let predicates = ty::lookup_predicates(tcx, did);\n+    let generics = (&def.generics, &predicates, subst::TypeSpace).clean(cx);\n+    let generics = filter_non_trait_generics(did, generics);\n+    let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n     clean::Trait {\n         unsafety: def.unsafety,\n-        generics: (&def.generics, &predicates, subst::TypeSpace).clean(cx),\n+        generics: generics,\n         items: trait_items,\n-        bounds: vec![], // supertraits can be found in the list of predicates\n+        bounds: supertrait_bounds,\n     }\n }\n \n@@ -447,3 +450,48 @@ fn build_static(cx: &DocContext, tcx: &ty::ctxt,\n         expr: \"\\n\\n\\n\".to_string(), // trigger the \"[definition]\" links\n     }\n }\n+\n+/// A trait's generics clause actually contains all of the predicates for all of\n+/// its associated types as well. We specifically move these clauses to the\n+/// associated types instead when displaying, so when we're genering the\n+/// generics for the trait itself we need to be sure to remove them.\n+///\n+/// The inverse of this filtering logic can be found in the `Clean`\n+/// implementation for `AssociatedType`\n+fn filter_non_trait_generics(trait_did: ast::DefId, mut g: clean::Generics)\n+                             -> clean::Generics {\n+    g.where_predicates.retain(|pred| {\n+        match *pred {\n+            clean::WherePredicate::BoundPredicate {\n+                ty: clean::QPath {\n+                    self_type: box clean::Generic(ref s),\n+                    trait_: box clean::ResolvedPath { did, .. },\n+                    name: ref _name,\n+                }, ..\n+            } => *s != \"Self\" || did != trait_did,\n+            _ => true,\n+        }\n+    });\n+    return g;\n+}\n+\n+/// Supertrait bounds for a trait are also listed in the generics coming from\n+/// the metadata for a crate, so we want to separate those out and create a new\n+/// list of explicit supertrait bounds to render nicely.\n+fn separate_supertrait_bounds(mut g: clean::Generics)\n+                              -> (clean::Generics, Vec<clean::TyParamBound>) {\n+    let mut ty_bounds = Vec::new();\n+    g.where_predicates.retain(|pred| {\n+        match *pred {\n+            clean::WherePredicate::BoundPredicate {\n+                ty: clean::Generic(ref s),\n+                ref bounds\n+            } if *s == \"Self\" => {\n+                ty_bounds.extend(bounds.iter().cloned());\n+                false\n+            }\n+            _ => true,\n+        }\n+    });\n+    (g, ty_bounds)\n+}"}, {"sha": "65778114fe0e27de2d8980568d4540da168b32e7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 121, "deletions": 55, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=75ef0832ae00477f837a73356ea7f12f64134c7c", "patch": "@@ -498,6 +498,35 @@ pub enum TyParamBound {\n     TraitBound(PolyTrait, ast::TraitBoundModifier)\n }\n \n+impl TyParamBound {\n+    fn maybe_sized(cx: &DocContext) -> TyParamBound {\n+        use syntax::ast::TraitBoundModifier as TBM;\n+        let mut sized_bound = ty::BuiltinBound::BoundSized.clean(cx);\n+        if let TyParamBound::TraitBound(_, ref mut tbm) = sized_bound {\n+            *tbm = TBM::Maybe\n+        };\n+        sized_bound\n+    }\n+\n+    fn is_sized_bound(&self, cx: &DocContext) -> bool {\n+        use syntax::ast::TraitBoundModifier as TBM;\n+        if let Some(tcx) = cx.tcx_opt() {\n+            let sized_did = match tcx.lang_items.sized_trait() {\n+                Some(did) => did,\n+                None => return false\n+            };\n+            if let TyParamBound::TraitBound(PolyTrait {\n+                trait_: Type::ResolvedPath { did, .. }, ..\n+            }, TBM::None) = *self {\n+                if did == sized_did {\n+                    return true\n+                }\n+            }\n+        }\n+        false\n+    }\n+}\n+\n impl Clean<TyParamBound> for ast::TyParamBound {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n         match *self {\n@@ -835,7 +864,9 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Type {\n         let trait_ = match self.trait_ref.clean(cx) {\n             TyParamBound::TraitBound(t, _) => t.trait_,\n-            TyParamBound::RegionBound(_) => panic!(\"cleaning a trait got a region??\"),\n+            TyParamBound::RegionBound(_) => {\n+                panic!(\"cleaning a trait got a region\")\n+            }\n         };\n         Type::QPath {\n             name: self.item_name.clean(cx),\n@@ -868,28 +899,8 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n                                     subst::ParamSpace) {\n     fn clean(&self, cx: &DocContext) -> Generics {\n         use std::collections::HashSet;\n-        use syntax::ast::TraitBoundModifier as TBM;\n         use self::WherePredicate as WP;\n \n-        fn has_sized_bound(bounds: &[TyParamBound], cx: &DocContext) -> bool {\n-            if let Some(tcx) = cx.tcx_opt() {\n-                let sized_did = match tcx.lang_items.sized_trait() {\n-                    Some(did) => did,\n-                    None => return false\n-                };\n-                for bound in bounds {\n-                    if let TyParamBound::TraitBound(PolyTrait {\n-                        trait_: Type::ResolvedPath { did, .. }, ..\n-                    }, TBM::None) = *bound {\n-                        if did == sized_did {\n-                            return true\n-                        }\n-                    }\n-                }\n-            }\n-            false\n-        }\n-\n         let (gens, preds, space) = *self;\n \n         // Bounds in the type_params and lifetimes fields are repeated in the\n@@ -904,34 +915,38 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n             srp.clean(cx)\n         }).collect::<Vec<_>>();\n \n-        let where_predicates = preds.predicates.get_slice(space)\n-                                               .to_vec().clean(cx);\n+        let mut where_predicates = preds.predicates.get_slice(space)\n+                                                   .to_vec().clean(cx);\n \n-        // Type parameters have a Sized bound by default unless removed with\n+        // Type parameters and have a Sized bound by default unless removed with\n         // ?Sized.  Scan through the predicates and mark any type parameter with\n         // a Sized bound, removing the bounds as we find them.\n+        //\n+        // Note that associated types also have a sized bound by default, but we\n+        // don't actually konw the set of associated types right here so that's\n+        // handled in cleaning associated types\n         let mut sized_params = HashSet::new();\n-        let mut where_predicates = where_predicates.into_iter().filter_map(|pred| {\n-            if let WP::BoundPredicate { ty: Type::Generic(ref g), ref bounds } = pred {\n-                if has_sized_bound(&**bounds, cx) {\n-                    sized_params.insert(g.clone());\n-                    return None\n+        where_predicates.retain(|pred| {\n+            match *pred {\n+                WP::BoundPredicate { ty: Generic(ref g), ref bounds } => {\n+                    if bounds.iter().any(|b| b.is_sized_bound(cx)) {\n+                        sized_params.insert(g.clone());\n+                        false\n+                    } else {\n+                        true\n+                    }\n                 }\n+                _ => true,\n             }\n-            Some(pred)\n-        }).collect::<Vec<_>>();\n+        });\n \n-        // Finally, run through the type parameters again and insert a ?Sized\n+        // Run through the type parameters again and insert a ?Sized\n         // unbound for any we didn't find to be Sized.\n         for tp in &stripped_typarams {\n             if !sized_params.contains(&tp.name) {\n-                let mut sized_bound = ty::BuiltinBound::BoundSized.clean(cx);\n-                if let TyParamBound::TraitBound(_, ref mut tbm) = sized_bound {\n-                    *tbm = TBM::Maybe\n-                };\n                 where_predicates.push(WP::BoundPredicate {\n                     ty: Type::Generic(tp.name.clone()),\n-                    bounds: vec![sized_bound]\n+                    bounds: vec![TyParamBound::maybe_sized(cx)],\n                 })\n             }\n         }\n@@ -1597,17 +1612,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             }\n             ty::ty_tup(ref t) => Tuple(t.clean(cx)),\n \n-            ty::ty_projection(ref data) => {\n-                let trait_ref = match data.trait_ref.clean(cx) {\n-                    TyParamBound::TraitBound(t, _) => t.trait_,\n-                    TyParamBound::RegionBound(_) => panic!(\"cleaning a trait got a region??\"),\n-                };\n-                Type::QPath {\n-                    name: data.item_name.clean(cx),\n-                    self_type: box data.trait_ref.self_ty().clean(cx),\n-                    trait_: box trait_ref,\n-                }\n-            }\n+            ty::ty_projection(ref data) => data.clean(cx),\n \n             ty::ty_param(ref p) => Generic(token::get_name(p.name).to_string()),\n \n@@ -1881,6 +1886,22 @@ pub struct Path {\n     pub segments: Vec<PathSegment>,\n }\n \n+impl Path {\n+    pub fn singleton(name: String) -> Path {\n+        Path {\n+            global: false,\n+            segments: vec![PathSegment {\n+                name: name,\n+                params: PathParameters::AngleBracketed {\n+                    lifetimes: Vec::new(),\n+                    types: Vec::new(),\n+                    bindings: Vec::new()\n+                }\n+            }]\n+        }\n+    }\n+}\n+\n impl Clean<Path> for ast::Path {\n     fn clean(&self, cx: &DocContext) -> Path {\n         Path {\n@@ -2516,21 +2537,66 @@ impl Clean<Stability> for attr::Stability {\n \n impl Clean<Item> for ty::AssociatedType {\n     fn clean(&self, cx: &DocContext) -> Item {\n+        // When loading a cross-crate associated type, the bounds for this type\n+        // are actually located on the trait/impl itself, so we need to load\n+        // all of the generics from there and then look for bounds that are\n+        // applied to this associated type in question.\n+        let predicates = ty::lookup_predicates(cx.tcx(), self.container.id());\n+        let generics = match self.container {\n+            ty::TraitContainer(did) => {\n+                let def = ty::lookup_trait_def(cx.tcx(), did);\n+                (&def.generics, &predicates, subst::TypeSpace).clean(cx)\n+            }\n+            ty::ImplContainer(did) => {\n+                let ty = ty::lookup_item_type(cx.tcx(), did);\n+                (&ty.generics, &predicates, subst::TypeSpace).clean(cx)\n+            }\n+        };\n+        let my_name = self.name.clean(cx);\n+        let mut bounds = generics.where_predicates.iter().filter_map(|pred| {\n+            let (name, self_type, trait_, bounds) = match *pred {\n+                WherePredicate::BoundPredicate {\n+                    ty: QPath { ref name, ref self_type, ref trait_ },\n+                    ref bounds\n+                } => (name, self_type, trait_, bounds),\n+                _ => return None,\n+            };\n+            if *name != my_name { return None }\n+            match **trait_ {\n+                ResolvedPath { did, .. } if did == self.container.id() => {}\n+                _ => return None,\n+            }\n+            match **self_type {\n+                Generic(ref s) if *s == \"Self\" => {}\n+                _ => return None,\n+            }\n+            Some(bounds)\n+        }).flat_map(|i| i.iter().cloned()).collect::<Vec<_>>();\n+\n+        // Our Sized/?Sized bound didn't get handled when creating the generics\n+        // because we didn't actually get our whole set of bounds until just now\n+        // (some of them may have come from the trait). If we do have a sized\n+        // bound, we remove it, and if we don't then we add the `?Sized` bound\n+        // at the end.\n+        match bounds.iter().position(|b| b.is_sized_bound(cx)) {\n+            Some(i) => { bounds.remove(i); }\n+            None => bounds.push(TyParamBound::maybe_sized(cx)),\n+        }\n+\n         Item {\n             source: DUMMY_SP.clean(cx),\n             name: Some(self.name.clean(cx)),\n-            attrs: Vec::new(),\n-            // FIXME(#20727): bounds are missing and need to be filled in from the\n-            // predicates on the trait itself\n-            inner: AssociatedTypeItem(vec![], None),\n-            visibility: None,\n+            attrs: inline::load_attrs(cx, cx.tcx(), self.def_id),\n+            inner: AssociatedTypeItem(bounds, None),\n+            visibility: self.vis.clean(cx),\n             def_id: self.def_id,\n-            stability: None,\n+            stability: stability::lookup(cx.tcx(), self.def_id).clean(cx),\n         }\n     }\n }\n \n-impl<'a> Clean<Typedef> for (ty::TypeScheme<'a>, ty::GenericPredicates<'a>, ParamSpace) {\n+impl<'a> Clean<Typedef> for (ty::TypeScheme<'a>, ty::GenericPredicates<'a>,\n+                             ParamSpace) {\n     fn clean(&self, cx: &DocContext) -> Typedef {\n         let (ref ty_scheme, ref predicates, ps) = *self;\n         Typedef {"}, {"sha": "ae9d9761001b8b1da750912c175f74a5d0f60d8a", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=75ef0832ae00477f837a73356ea7f12f64134c7c", "patch": "@@ -502,6 +502,29 @@ impl fmt::Display for clean::Type {\n                 }\n                 Ok(())\n             }\n+            // It's pretty unsightly to look at `<A as B>::C` in output, and\n+            // we've got hyperlinking on our side, so try to avoid longer\n+            // notation as much as possible by making `C` a hyperlink to trait\n+            // `B` to disambiguate.\n+            //\n+            // FIXME: this is still a lossy conversion and there should probably\n+            //        be a better way of representing this in general? Most of\n+            //        the ugliness comes from inlining across crates where\n+            //        everything comes in as a fully resolved QPath (hard to\n+            //        look at).\n+            clean::QPath {\n+                ref name,\n+                ref self_type,\n+                trait_: box clean::ResolvedPath { did, ref typarams, .. },\n+            } => {\n+                try!(write!(f, \"{}::\", self_type));\n+                let path = clean::Path::singleton(name.clone());\n+                try!(resolved_path(f, did, &path, false));\n+\n+                // FIXME: `typarams` are not rendered, and this seems bad?\n+                drop(typarams);\n+                Ok(())\n+            }\n             clean::QPath { ref name, ref self_type, ref trait_ } => {\n                 write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n             }\n@@ -636,17 +659,7 @@ impl fmt::Display for clean::ViewListIdent {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.source {\n             Some(did) => {\n-                let path = clean::Path {\n-                    global: false,\n-                    segments: vec!(clean::PathSegment {\n-                        name: self.name.clone(),\n-                        params: clean::PathParameters::AngleBracketed {\n-                            lifetimes: Vec::new(),\n-                            types: Vec::new(),\n-                            bindings: Vec::new()\n-                        }\n-                    })\n-                };\n+                let path = clean::Path::singleton(self.name.clone());\n                 resolved_path(f, did, &path, false)\n             }\n             _ => write!(f, \"{}\", self.name),"}, {"sha": "aea8b429d9f753b936bc263f71d0a391cb3346bd", "filename": "src/test/auxiliary/issue-20727.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Ftest%2Fauxiliary%2Fissue-20727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Ftest%2Fauxiliary%2Fissue-20727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-20727.rs?ref=75ef0832ae00477f837a73356ea7f12f64134c7c", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Deref {\n+    type Target: ?Sized;\n+\n+    fn deref<'a>(&'a self) -> &'a Self::Target;\n+}\n+\n+pub trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+\n+pub trait Bar {}\n+pub trait Deref2 {\n+    type Target: Bar;\n+\n+    fn deref(&self) -> Self::Target;\n+}\n+\n+pub trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n+    fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n+}"}, {"sha": "e0122d66de1840d3429aa8f6cfa74a10794db9cf", "filename": "src/test/rustdoc/issue-20727-2.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Ftest%2Frustdoc%2Fissue-20727-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Ftest%2Frustdoc%2Fissue-20727-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-20727-2.rs?ref=75ef0832ae00477f837a73356ea7f12f64134c7c", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-20727.rs\n+\n+extern crate issue_20727;\n+\n+// @has issue_20727_2/trait.Add.html\n+pub trait Add<RHS = Self> {\n+    // @has - '//*[@class=\"rust trait\"]' 'trait Add<RHS = Self> {'\n+    // @has - '//*[@class=\"rust trait\"]' 'type Output;'\n+    type Output;\n+\n+    // @has - '//*[@class=\"rust trait\"]' 'fn add(self, rhs: RHS) -> Self::Output;'\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+// @has issue_20727_2/reexport/trait.Add.html\n+pub mod reexport {\n+    // @has - '//*[@class=\"rust trait\"]' 'trait Add<RHS = Self> {'\n+    // @has - '//*[@class=\"rust trait\"]' 'type Output;'\n+    // @has - '//*[@class=\"rust trait\"]' 'fn add(self, rhs: RHS) -> Self::Output;'\n+    pub use issue_20727::Add;\n+}\n+"}, {"sha": "8338239a29d4a047a178e6b6d39fb8fe90a8c0f3", "filename": "src/test/rustdoc/issue-20727-3.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Ftest%2Frustdoc%2Fissue-20727-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Ftest%2Frustdoc%2Fissue-20727-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-20727-3.rs?ref=75ef0832ae00477f837a73356ea7f12f64134c7c", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-20727.rs\n+\n+extern crate issue_20727;\n+\n+pub trait Bar {}\n+\n+// @has issue_20727_3/trait.Deref2.html\n+pub trait Deref2 {\n+    // @has - '//*[@class=\"rust trait\"]' 'trait Deref2 {'\n+    // @has - '//*[@class=\"rust trait\"]' 'type Target: Bar;'\n+    type Target: Bar;\n+\n+    // @has - '//*[@class=\"rust trait\"]' 'fn deref(&self) -> Self::Target;'\n+    fn deref(&self) -> Self::Target;\n+}\n+\n+// @has issue_20727_3/reexport/trait.Deref2.html\n+pub mod reexport {\n+    // @has - '//*[@class=\"rust trait\"]' 'trait Deref2 {'\n+    // @has - '//*[@class=\"rust trait\"]' 'type Target: Bar;'\n+    // @has - '//*[@class=\"rust trait\"]' 'fn deref(&self) -> Self::Target;'\n+    pub use issue_20727::Deref2;\n+}"}, {"sha": "ed361ed990adcab52bbda426e766f3bf88a5a03e", "filename": "src/test/rustdoc/issue-20727-4.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Ftest%2Frustdoc%2Fissue-20727-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Ftest%2Frustdoc%2Fissue-20727-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-20727-4.rs?ref=75ef0832ae00477f837a73356ea7f12f64134c7c", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-20727.rs\n+\n+extern crate issue_20727;\n+\n+// @has issue_20727_4/trait.Index.html\n+pub trait Index<Idx: ?Sized> {\n+    // @has - '//*[@class=\"rust trait\"]' 'trait Index<Idx: ?Sized> {'\n+    // @has - '//*[@class=\"rust trait\"]' 'type Output: ?Sized'\n+    type Output: ?Sized;\n+\n+    // @has - '//*[@class=\"rust trait\"]' \\\n+    //        'fn index(&self, index: Idx) -> &Self::Output'\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+// @has issue_20727_4/trait.IndexMut.html\n+pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n+    // @has - '//*[@class=\"rust trait\"]' \\\n+    //        'trait IndexMut<Idx: ?Sized>: Index<Idx> {'\n+    // @has - '//*[@class=\"rust trait\"]' \\\n+    //        'fn index_mut(&mut self, index: Idx) -> &mut Self::Output;'\n+    fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n+}\n+\n+pub mod reexport {\n+    // @has issue_20727_4/reexport/trait.Index.html\n+    // @has - '//*[@class=\"rust trait\"]' 'trait Index<Idx> where Idx: ?Sized {'\n+    // @has - '//*[@class=\"rust trait\"]' 'type Output: ?Sized'\n+    // @has - '//*[@class=\"rust trait\"]' \\\n+    //        'fn index(&self, index: Idx) -> &Self::Output'\n+    pub use issue_20727::Index;\n+\n+    // @has issue_20727_4/reexport/trait.IndexMut.html\n+    // @has - '//*[@class=\"rust trait\"]' \\\n+    //        'trait IndexMut<Idx>: Index<Idx> where Idx: ?Sized {'\n+    // @has - '//*[@class=\"rust trait\"]' \\\n+    //        'fn index_mut(&mut self, index: Idx) -> &mut Self::Output;'\n+    pub use issue_20727::IndexMut;\n+}"}, {"sha": "9903ad34b4cd245bb1bc72a0c7970a7bc9c385bf", "filename": "src/test/rustdoc/issue-20727.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Ftest%2Frustdoc%2Fissue-20727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ef0832ae00477f837a73356ea7f12f64134c7c/src%2Ftest%2Frustdoc%2Fissue-20727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-20727.rs?ref=75ef0832ae00477f837a73356ea7f12f64134c7c", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-20727.rs\n+\n+extern crate issue_20727;\n+\n+// @has issue_20727/trait.Deref.html\n+pub trait Deref {\n+    // @has - '//*[@class=\"rust trait\"]' 'trait Deref {'\n+    // @has - '//*[@class=\"rust trait\"]' 'type Target: ?Sized;'\n+    type Target: ?Sized;\n+\n+    // @has - '//*[@class=\"rust trait\"]' \\\n+    //        \"fn deref<'a>(&'a self) -> &'a Self::Target;\"\n+    fn deref<'a>(&'a self) -> &'a Self::Target;\n+}\n+\n+// @has issue_20727/reexport/trait.Deref.html\n+pub mod reexport {\n+    // @has - '//*[@class=\"rust trait\"]' 'trait Deref {'\n+    // @has - '//*[@class=\"rust trait\"]' 'type Target: ?Sized;'\n+    // @has - '//*[@class=\"rust trait\"]' \\\n+    //      \"fn deref(&'a self) -> &'a Self::Target;\"\n+    pub use issue_20727::Deref;\n+}"}]}