{"sha": "220144b93cdb057cc43fa7bdcfdfbdd42bbf7cf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyMDE0NGI5M2NkYjA1N2NjNDNmYTdiZGNmZGZiZGQ0MmJiZjdjZjE=", "commit": {"author": {"name": "Zack Corr", "email": "zack@z0w0.me", "date": "2013-01-17T09:05:19Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-02-16T02:04:10Z"}, "message": "rustpkg: Finish parsing package scripts and finish boilerplate", "tree": {"sha": "1e0e77caed7e425608a0421ac595fb34412dadad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e0e77caed7e425608a0421ac595fb34412dadad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/220144b93cdb057cc43fa7bdcfdfbdd42bbf7cf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/220144b93cdb057cc43fa7bdcfdfbdd42bbf7cf1", "html_url": "https://github.com/rust-lang/rust/commit/220144b93cdb057cc43fa7bdcfdfbdd42bbf7cf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/220144b93cdb057cc43fa7bdcfdfbdd42bbf7cf1/comments", "author": {"login": "z0w0", "id": 676417, "node_id": "MDQ6VXNlcjY3NjQxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/676417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/z0w0", "html_url": "https://github.com/z0w0", "followers_url": "https://api.github.com/users/z0w0/followers", "following_url": "https://api.github.com/users/z0w0/following{/other_user}", "gists_url": "https://api.github.com/users/z0w0/gists{/gist_id}", "starred_url": "https://api.github.com/users/z0w0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/z0w0/subscriptions", "organizations_url": "https://api.github.com/users/z0w0/orgs", "repos_url": "https://api.github.com/users/z0w0/repos", "events_url": "https://api.github.com/users/z0w0/events{/privacy}", "received_events_url": "https://api.github.com/users/z0w0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "226b61ba5f30e0ecb0799626a010161f3ce0b72d", "url": "https://api.github.com/repos/rust-lang/rust/commits/226b61ba5f30e0ecb0799626a010161f3ce0b72d", "html_url": "https://github.com/rust-lang/rust/commit/226b61ba5f30e0ecb0799626a010161f3ce0b72d"}], "stats": {"total": 312, "additions": 284, "deletions": 28}, "files": [{"sha": "309509b420ac70cc40e393f181febec6897c4fc2", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 243, "deletions": 27, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/220144b93cdb057cc43fa7bdcfdfbdd42bbf7cf1/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/220144b93cdb057cc43fa7bdcfdfbdd42bbf7cf1/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=220144b93cdb057cc43fa7bdcfdfbdd42bbf7cf1", "patch": "@@ -39,7 +39,9 @@ mod util;\n struct PackageScript {\n     id: ~str,\n     name: ~str,\n-    vers: Version\n+    vers: Version,\n+    crates: ~[~str],\n+    deps: ~[(~str, Option<~str>)]\n }\n \n impl PackageScript {\n@@ -54,6 +56,8 @@ impl PackageScript {\n         let crate = parse::parse_crate_from_file(&script, ~[], sess);\n         let mut id = None;\n         let mut vers = None;\n+        let mut crates = ~[];\n+        let mut deps = ~[];\n \n         fn load_pkg_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,\n                                                       Option<~str>) {\n@@ -78,6 +82,49 @@ impl PackageScript {\n             (id, vers)\n         }\n \n+        fn load_pkg_dep_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,\n+                                                          Option<~str>) {\n+            let mut url = None;\n+            let mut target = None;\n+\n+            for mis.each |a| {\n+                match a.node {\n+                    ast::meta_name_value(v, ast::spanned {\n+                                                node: ast::lit_str(s),\n+                                                span: _}) => {\n+                        match v {\n+                            ~\"url\" => url = Some(*s),\n+                            ~\"target\" => target = Some(*s),\n+                            _ => ()\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            (url, target)\n+        }\n+\n+        fn load_pkg_crate_attr(mis: ~[@ast::meta_item]) -> Option<~str> {\n+            let mut file = None;\n+\n+            for mis.each |a| {\n+                match a.node {\n+                    ast::meta_name_value(v, ast::spanned {\n+                                                node: ast::lit_str(s),\n+                                                span: _}) => {\n+                        match v {\n+                            ~\"file\" => file = Some(*s),\n+                            _ => ()\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            file\n+        }\n+\n         for crate.node.attrs.each |a| {\n             match a.node.value.node {\n                 ast::meta_list(v, mis) => {\n@@ -88,6 +135,24 @@ impl PackageScript {\n                             id = i;\n                             vers = v;\n                         }\n+                        ~\"pkg_dep\" => {\n+                            let (u, t) = load_pkg_dep_attr(mis);\n+\n+                            if u.is_none() {\n+                                fail ~\"pkg_dep attr without a url value\";\n+                            }\n+\n+                            deps.push((u.get(), t));\n+                        }\n+                        ~\"pkg_crate\" => {\n+                            let f = load_pkg_crate_attr(mis);\n+\n+                            if f.is_none() {\n+                                fail ~\"pkg_file attr without a file value\";\n+                            }\n+\n+                            crates.push(f.get());\n+                        }\n                         _ => {}\n                     }\n                 }\n@@ -105,7 +170,9 @@ impl PackageScript {\n         PackageScript {\n             id: id,\n             name: util::parse_id(id),\n-            vers: util::parse_vers(vers)\n+            vers: util::parse_vers(vers),\n+            crates: crates,\n+            deps: deps\n         }\n     }\n \n@@ -114,63 +181,214 @@ impl PackageScript {\n \n         hasher.write_str(self.id + self.vers.to_str());\n \n-        self.name + hasher.result_str() + self.vers.to_str()\n+        fmt!(\"%s-%s-%s\", self.name, hasher.result_str(), self.vers.to_str())\n     }\n \n     fn work_dir() -> Path {\n-        util::root().push(self.hash())\n+        util::root().push(~\"work\").push(self.hash())\n     }\n }\n \n struct Ctx {\n-    cmd: ~str,\n-    args: ~[~str],\n     cfgs: ~[~str],\n     prefer: bool\n }\n \n impl Ctx {\n-    fn run() {\n-        match self.cmd {\n-            ~\"build\" => self.build(),\n-            ~\"clean\" => self.clean(),\n-            ~\"install\" => self.install(),\n-            ~\"prefer\" => self.prefer(),\n-            ~\"test\" => self.test(),\n-            ~\"uninstall\" => self.uninstall(),\n-            ~\"unprefer\" => self.unprefer(),\n+    fn run(cmd: ~str, args: ~[~str]) {\n+        let root = util::root();\n+\n+        util::need_dir(&root);\n+        util::need_dir(&root.push(~\"work\"));\n+        util::need_dir(&root.push(~\"lib\"));\n+        util::need_dir(&root.push(~\"bin\"));\n+        util::need_dir(&root.push(~\"tmp\"));\n+\n+        match cmd {\n+            ~\"build\" => self.build(args),\n+            ~\"clean\" => self.clean(args),\n+            ~\"install\" => self.install(args),\n+            ~\"prefer\" => self.prefer(args),\n+            ~\"test\" => self.test(args),\n+            ~\"uninstall\" => self.uninstall(args),\n+            ~\"unprefer\" => self.unprefer(args),\n             _ => fail ~\"reached an unhandled command\"\n-        }\n+        };\n     }\n \n-    fn build() {\n+    fn build(_args: ~[~str]) -> bool {\n         let script = PackageScript::parse(os::getcwd());\n+        let dir = script.work_dir();\n+        let mut success = true;\n+\n+        util::need_dir(&dir);\n+        util::info(fmt!(\"building %s v%s (%s)\", script.name, script.vers.to_str(),\n+                                                script.id));\n+\n+        if script.deps.len() >= 1 {\n+            util::info(~\"installing dependencies..\");\n+\n+            for script.deps.each |&dep| {\n+                let (url, target) = dep;\n+\n+                success = self.install(if target.is_none() { ~[url] }\n+                                       else { ~[url, target.get()] });\n+\n+                if !success { break; }\n+            }\n+\n+            if !success {\n+                util::error(fmt!(\"building %s v%s failed: a dep wasn't installed\",\n+                                 script.name, script.vers.to_str()));\n+\n+                return false;\n+            }\n+\n+            util::info(~\"installed dependencies\");\n+        }\n+\n+        for script.crates.each |&crate| {\n+            success = self.compile(&dir, crate, ~[]);\n+\n+            if !success { break; }\n+        }\n+\n+        if !success {\n+            util::error(fmt!(\"building %s v%s failed: a crate failed to compile\",\n+                             script.name, script.vers.to_str()));\n+\n+            return false;\n+        }\n \n-        io::println(fmt!(\"build: %s (v%s)\", script.id, script.vers.to_str()));\n+        util::info(fmt!(\"built %s v%s\", script.name, script.vers.to_str()));\n+\n+        true\n     }\n \n-    fn clean() {\n+    fn compile(dir: &Path, crate: ~str, flags: ~[~str]) -> bool {\n+        util::info(~\"compiling \" + crate);\n \n+        true\n     }\n \n-    fn install() {\n+    fn clean(_args: ~[~str]) -> bool {\n+        let script = PackageScript::parse(os::getcwd());\n+        let dir = script.work_dir();\n+\n+        util::info(fmt!(\"cleaning %s v%s (%s)\", script.name, script.vers.to_str(),\n+                                                script.id));\n+\n+        if os::path_is_dir(&dir) {\n+            if os::remove_dir(&dir) {\n+                util::info(fmt!(\"cleaned %s v%s\", script.name,\n+                                                  script.vers.to_str()));\n+            } else {\n+                util::error(fmt!(\"cleaning %s v%s failed\",\n+                                 script.name, script.vers.to_str()));\n+            }\n+        } else {\n+            util::info(fmt!(\"cleaned %s v%s\", script.name,\n+                                              script.vers.to_str()));\n+        }\n \n+        true\n     }\n \n-    fn prefer() {\n+    fn install(args: ~[~str]) -> bool {\n+        let mut success;\n+        let mut dir;\n+\n+        if args.len() < 1 {\n+            util::info(~\"installing from the cwd\");\n+\n+            dir = os::getcwd();\n+\n+            return true;\n+        } else {\n+            let url = args[0];\n+            let target = if args.len() >= 2 { Some(args[1]) }\n+                         else { None };\n+            let hasher = hash::default_state();\n+\n+            hasher.write_str(url);\n+\n+            if !target.is_none() {\n+                hasher.write_str(target.get());\n+            }\n+\n+            dir = util::root().push(~\"tmp\").push(hasher.result_str());\n+            success = self.fetch(&dir, url, target);\n \n+            if !success {\n+                return false;\n+            }\n+        }\n+\n+        let script = PackageScript::parse(dir);\n+        dir = script.work_dir();\n+\n+        util::info(fmt!(\"installing %s v%s (%s)\", script.name, script.vers.to_str(),\n+                                                  script.id));\n+\n+        if script.deps.len() >= 1 {\n+            util::info(~\"installing dependencies..\");\n+\n+            for script.deps.each |&dep| {\n+                let (url, target) = dep;\n+\n+                success = self.install(if target.is_none() { ~[url] }\n+                                       else { ~[url, target.get()] });\n+\n+                if !success { break; }\n+            }\n+\n+            if !success {\n+                util::error(fmt!(\"installing %s v%s failed: a dep wasn't installed\",\n+                                 script.name, script.vers.to_str()));\n+                return false;\n+            }\n+\n+            util::info(~\"installed dependencies\");\n+        }\n+\n+        for script.crates.each |&crate| {\n+            success = self.compile(&dir, crate, ~[]);\n+\n+            if !success { break; }\n+        }\n+\n+        if !success {\n+            util::error(fmt!(\"installing %s v%s failed: a crate failed to compile\",\n+                             script.name, script.vers.to_str()));\n+            return false;\n+        }\n+\n+        util::info(fmt!(\"installed %s v%s\", script.name,\n+                                            script.vers.to_str()));\n+\n+        true\n     }\n \n-    fn test() {\n+    fn fetch(dir: &Path, url: ~str, target: Option<~str>) -> bool {\n+        util::info(fmt!(\"installing from %s\", url));\n \n+        true\n     }\n \n-    fn uninstall() {\n+    fn prefer(_args: ~[~str]) -> bool {\n+        true\n+    }\n \n+    fn test(_args: ~[~str]) -> bool {\n+        true\n     }\n \n-    fn unprefer() {\n+    fn uninstall(_args: ~[~str]) -> bool {\n+        true\n+    }\n \n+    fn unprefer(_args: ~[~str]) -> bool {\n+        true\n     }\n }\n \n@@ -217,11 +435,9 @@ pub fn main() {\n     }\n \n     Ctx {\n-        cmd: cmd,\n-        args: args,\n         cfgs: cfgs,\n         prefer: prefer\n-    }.run();\n+    }.run(cmd, args);\n }\n \n pub use Crate = api::Crate;"}, {"sha": "b31d86352ab731138bb3b1102cf462cd0ef4641e", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/220144b93cdb057cc43fa7bdcfdfbdd42bbf7cf1/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/220144b93cdb057cc43fa7bdcfdfbdd42bbf7cf1/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=220144b93cdb057cc43fa7bdcfdfbdd42bbf7cf1", "patch": "@@ -1,7 +1,7 @@\n use core::*;\n use rustc::metadata::filesearch;\n use semver::Version;\n-use std::net::url;\n+use std::term;\n \n pub fn root() -> Path {\n     match filesearch::get_rustpkg_root() {\n@@ -40,6 +40,46 @@ pub fn parse_vers(vers: ~str) -> Version {\n     }\n }\n \n+pub fn need_dir(s: &Path) {\n+    if !os::path_is_dir(s) && !os::make_dir(s, 493_i32) {\n+        fail fmt!(\"can't create dir: %s\", s.to_str());\n+    }\n+}\n+\n+pub fn info(msg: ~str) {\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_green);\n+        out.write_str(~\"info: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    } else { out.write_line(~\"info: \" + msg); }\n+}\n+\n+pub fn warn(msg: ~str) {\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_yellow);\n+        out.write_str(~\"warning: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    }else { out.write_line(~\"warning: \" + msg); }\n+}\n+\n+pub fn error(msg: ~str) {\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_red);\n+        out.write_str(~\"error: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    }\n+    else { out.write_line(~\"error: \" + msg); }\n+}\n+\n #[test]\n fn test_is_cmd() {\n     assert is_cmd(~\"build\");"}]}