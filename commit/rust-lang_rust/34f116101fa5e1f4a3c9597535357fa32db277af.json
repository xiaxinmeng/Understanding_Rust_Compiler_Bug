{"sha": "34f116101fa5e1f4a3c9597535357fa32db277af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ZjExNjEwMWZhNWUxZjRhM2M5NTk3NTM1MzU3ZmEzMmRiMjc3YWY=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-06-08T00:39:42Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-06-08T00:41:43Z"}, "message": "Preserve more spans in internal `rustc_queries!` macro\n\nWe now preserve the span of the various query modifiers, and\nuse the span of the query's name for the commas that we\ngenerate to separate the modifiers. This makes debugging issues with the\ninternal query macro infrastructure much nicer - previously, we\nwould get errors messages pointing at the entire call site\n(the `rustc_queries!` invocation), which isn't very useful.\n\nThis should have no effect when compilation succeeds.\n\nA concrete example of an error message produced after this changed:\n\n```\nerror: local ambiguity: multiple parsing options: built-in NTs tt ('modifiers') or 1 other option.\n    --> /home/aaron/repos/rust/compiler/rustc_middle/src/query/mod.rs:23:11\n     |\n12   | / rustc_queries! {\n13   | |     query trigger_delay_span_bug(key: DefId) -> () {\n14   | |         desc { \"trigger a delay span bug\" }\n15   | |     }\n...    |\n23   | |     query hir_crate(key: ()) -> &'tcx Crate<'tcx> {\n     | |           ^^^^^^^^^\n...    |\n1715 | |     }\n1716 | | }\n     | |_- in this expansion of `rustc_query_append!`\n     |\n    ::: compiler/rustc_query_impl/src/lib.rs:51:1\n     |\n51   |   rustc_query_append! { [define_queries!][<'tcx>] }\n     |   ------------------------------------------------- in this macro invocation\n```\n\nThe particular bug shown in this error message will be fixed\nin a separate PR.", "tree": {"sha": "b47ba0d6668852cda7d6b90732b57aaac30e69cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b47ba0d6668852cda7d6b90732b57aaac30e69cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34f116101fa5e1f4a3c9597535357fa32db277af", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmC+vQwACgkQtAh+UQ6Y\nsWT8Lg/7BGS0GF1ScRh6WID8lAtzF9EgnbEnUg6T1R2MO6T7xmH66ltbTiNYvDUT\nx6K128agrPpR+pT7HhMf8T124wy2PeUQIjpiyLh6RD1BqJ692Bx7LK44mCLEULKJ\nD4uB4VZ4rsL1eFHVN4yVsXb5TScMseD5XZkHsMsy1bJB28nLSSmsEc5H5DvLczJk\nZPpt0wbeiIC36fnCqYjGRab94FUVZFvAoF57rs9cBGWVtUf0y9jS30RNnwRYFxe5\nI7xDvcQJRAqemnvJzIiqprispNceeGlGcoQTOE2+MMtKV6xM3DOalBRkX3MDOfDu\nqz8hdXGapC7k4S9JpVshOGi0OYs34fDrxaRAAzoHPy2iN+XHLNL3Ho/WmmsEaOnV\nNsdMwofYPfMWL9ZOyOZ095SMi1B2e4d25EU6BklGJEfqzsIDlehDC7yqfsxW162b\njq91uZ0mDmPqQVw9rc0gLG9v63O+t2zp+NwZHnnlurMl7KWxDMJ6kxBTBBr0pndV\neKu7Is8vN2MVlI47YA6k7gtNJk2HEOeoqD+QHDJsH6Tcm9uIqPddpfs/wAlUbJsH\nzfEltRCziekenYu4NOX3h8U/fZ9dwac5Bn1IaNh4lMQ/5qsqUySjd1y6PGFIKXcs\nevCto9tiUCmlLJNQONBcr/IwjncLgnFj0Nx+ZfziONC7Cdxp2AA=\n=V3/S\n-----END PGP SIGNATURE-----", "payload": "tree b47ba0d6668852cda7d6b90732b57aaac30e69cb\nparent e4a60327063e82413eed50a10df3b7d19b77bda0\nauthor Aaron Hill <aa1ronham@gmail.com> 1623112782 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1623112903 -0500\n\nPreserve more spans in internal `rustc_queries!` macro\n\nWe now preserve the span of the various query modifiers, and\nuse the span of the query's name for the commas that we\ngenerate to separate the modifiers. This makes debugging issues with the\ninternal query macro infrastructure much nicer - previously, we\nwould get errors messages pointing at the entire call site\n(the `rustc_queries!` invocation), which isn't very useful.\n\nThis should have no effect when compilation succeeds.\n\nA concrete example of an error message produced after this changed:\n\n```\nerror: local ambiguity: multiple parsing options: built-in NTs tt ('modifiers') or 1 other option.\n    --> /home/aaron/repos/rust/compiler/rustc_middle/src/query/mod.rs:23:11\n     |\n12   | / rustc_queries! {\n13   | |     query trigger_delay_span_bug(key: DefId) -> () {\n14   | |         desc { \"trigger a delay span bug\" }\n15   | |     }\n...    |\n23   | |     query hir_crate(key: ()) -> &'tcx Crate<'tcx> {\n     | |           ^^^^^^^^^\n...    |\n1715 | |     }\n1716 | | }\n     | |_- in this expansion of `rustc_query_append!`\n     |\n    ::: compiler/rustc_query_impl/src/lib.rs:51:1\n     |\n51   |   rustc_query_append! { [define_queries!][<'tcx>] }\n     |   ------------------------------------------------- in this macro invocation\n```\n\nThe particular bug shown in this error message will be fixed\nin a separate PR.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34f116101fa5e1f4a3c9597535357fa32db277af", "html_url": "https://github.com/rust-lang/rust/commit/34f116101fa5e1f4a3c9597535357fa32db277af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34f116101fa5e1f4a3c9597535357fa32db277af/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4a60327063e82413eed50a10df3b7d19b77bda0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4a60327063e82413eed50a10df3b7d19b77bda0", "html_url": "https://github.com/rust-lang/rust/commit/e4a60327063e82413eed50a10df3b7d19b77bda0"}], "stats": {"total": 104, "additions": 56, "deletions": 48}, "files": [{"sha": "660ad5ac22ef7e74feb02d4b3b9de2f814200e49", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 56, "deletions": 48, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/34f116101fa5e1f4a3c9597535357fa32db277af/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34f116101fa5e1f4a3c9597535357fa32db277af/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=34f116101fa5e1f4a3c9597535357fa32db277af", "patch": "@@ -1,6 +1,6 @@\n use proc_macro::TokenStream;\n use proc_macro2::{Delimiter, TokenTree};\n-use quote::quote;\n+use quote::{quote, quote_spanned};\n use syn::parse::{Parse, ParseStream, Result};\n use syn::punctuated::Punctuated;\n use syn::spanned::Spanned;\n@@ -42,19 +42,19 @@ enum QueryModifier {\n     LoadCached(Ident, Ident, Block),\n \n     /// A cycle error for this query aborting the compilation with a fatal error.\n-    FatalCycle,\n+    FatalCycle(Ident),\n \n     /// A cycle error results in a delay_bug call\n-    CycleDelayBug,\n+    CycleDelayBug(Ident),\n \n     /// Don't hash the result, instead just mark a query red if it runs\n-    NoHash,\n+    NoHash(Ident),\n \n     /// Generate a dep node based on the dependencies of the query\n-    Anon,\n+    Anon(Ident),\n \n     /// Always evaluate the query, ignoring its dependencies\n-    EvalAlways,\n+    EvalAlways(Ident),\n }\n \n impl Parse for QueryModifier {\n@@ -111,15 +111,15 @@ impl Parse for QueryModifier {\n             let ty = args.parse()?;\n             Ok(QueryModifier::Storage(ty))\n         } else if modifier == \"fatal_cycle\" {\n-            Ok(QueryModifier::FatalCycle)\n+            Ok(QueryModifier::FatalCycle(modifier))\n         } else if modifier == \"cycle_delay_bug\" {\n-            Ok(QueryModifier::CycleDelayBug)\n+            Ok(QueryModifier::CycleDelayBug(modifier))\n         } else if modifier == \"no_hash\" {\n-            Ok(QueryModifier::NoHash)\n+            Ok(QueryModifier::NoHash(modifier))\n         } else if modifier == \"anon\" {\n-            Ok(QueryModifier::Anon)\n+            Ok(QueryModifier::Anon(modifier))\n         } else if modifier == \"eval_always\" {\n-            Ok(QueryModifier::EvalAlways)\n+            Ok(QueryModifier::EvalAlways(modifier))\n         } else {\n             Err(Error::new(modifier.span(), \"unknown query modifier\"))\n         }\n@@ -203,19 +203,19 @@ struct QueryModifiers {\n     load_cached: Option<(Ident, Ident, Block)>,\n \n     /// A cycle error for this query aborting the compilation with a fatal error.\n-    fatal_cycle: bool,\n+    fatal_cycle: Option<Ident>,\n \n     /// A cycle error results in a delay_bug call\n-    cycle_delay_bug: bool,\n+    cycle_delay_bug: Option<Ident>,\n \n     /// Don't hash the result, instead just mark a query red if it runs\n-    no_hash: bool,\n+    no_hash: Option<Ident>,\n \n     /// Generate a dep node based on the dependencies of the query\n-    anon: bool,\n+    anon: Option<Ident>,\n \n     // Always evaluate the query, ignoring its dependencies\n-    eval_always: bool,\n+    eval_always: Option<Ident>,\n }\n \n /// Process query modifiers into a struct, erroring on duplicates\n@@ -224,11 +224,11 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n     let mut storage = None;\n     let mut cache = None;\n     let mut desc = None;\n-    let mut fatal_cycle = false;\n-    let mut cycle_delay_bug = false;\n-    let mut no_hash = false;\n-    let mut anon = false;\n-    let mut eval_always = false;\n+    let mut fatal_cycle = None;\n+    let mut cycle_delay_bug = None;\n+    let mut no_hash = None;\n+    let mut anon = None;\n+    let mut eval_always = None;\n     for modifier in query.modifiers.0.drain(..) {\n         match modifier {\n             QueryModifier::LoadCached(tcx, id, block) => {\n@@ -289,35 +289,35 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n                 }\n                 desc = Some((tcx, list));\n             }\n-            QueryModifier::FatalCycle => {\n-                if fatal_cycle {\n+            QueryModifier::FatalCycle(ident) => {\n+                if fatal_cycle.is_some() {\n                     panic!(\"duplicate modifier `fatal_cycle` for query `{}`\", query.name);\n                 }\n-                fatal_cycle = true;\n+                fatal_cycle = Some(ident);\n             }\n-            QueryModifier::CycleDelayBug => {\n-                if cycle_delay_bug {\n+            QueryModifier::CycleDelayBug(ident) => {\n+                if cycle_delay_bug.is_some() {\n                     panic!(\"duplicate modifier `cycle_delay_bug` for query `{}`\", query.name);\n                 }\n-                cycle_delay_bug = true;\n+                cycle_delay_bug = Some(ident);\n             }\n-            QueryModifier::NoHash => {\n-                if no_hash {\n+            QueryModifier::NoHash(ident) => {\n+                if no_hash.is_some() {\n                     panic!(\"duplicate modifier `no_hash` for query `{}`\", query.name);\n                 }\n-                no_hash = true;\n+                no_hash = Some(ident);\n             }\n-            QueryModifier::Anon => {\n-                if anon {\n+            QueryModifier::Anon(ident) => {\n+                if anon.is_some() {\n                     panic!(\"duplicate modifier `anon` for query `{}`\", query.name);\n                 }\n-                anon = true;\n+                anon = Some(ident);\n             }\n-            QueryModifier::EvalAlways => {\n-                if eval_always {\n+            QueryModifier::EvalAlways(ident) => {\n+                if eval_always.is_some() {\n                     panic!(\"duplicate modifier `eval_always` for query `{}`\", query.name);\n                 }\n-                eval_always = true;\n+                eval_always = Some(ident);\n             }\n         }\n     }\n@@ -454,31 +454,39 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n         let mut attributes = Vec::new();\n \n         // Pass on the fatal_cycle modifier\n-        if modifiers.fatal_cycle {\n-            attributes.push(quote! { fatal_cycle });\n+        if let Some(fatal_cycle) = &modifiers.fatal_cycle {\n+            attributes.push(quote! { #fatal_cycle });\n         };\n         // Pass on the storage modifier\n         if let Some(ref ty) = modifiers.storage {\n-            attributes.push(quote! { storage(#ty) });\n+            let span = ty.span();\n+            attributes.push(quote_spanned! {span=> storage(#ty) });\n         };\n         // Pass on the cycle_delay_bug modifier\n-        if modifiers.cycle_delay_bug {\n-            attributes.push(quote! { cycle_delay_bug });\n+        if let Some(cycle_delay_bug) = &modifiers.cycle_delay_bug {\n+            attributes.push(quote! { #cycle_delay_bug });\n         };\n         // Pass on the no_hash modifier\n-        if modifiers.no_hash {\n-            attributes.push(quote! { no_hash });\n+        if let Some(no_hash) = &modifiers.no_hash {\n+            attributes.push(quote! { #no_hash });\n         };\n         // Pass on the anon modifier\n-        if modifiers.anon {\n-            attributes.push(quote! { anon });\n+        if let Some(anon) = &modifiers.anon {\n+            attributes.push(quote! { #anon });\n         };\n         // Pass on the eval_always modifier\n-        if modifiers.eval_always {\n-            attributes.push(quote! { eval_always });\n+        if let Some(eval_always) = &modifiers.eval_always {\n+            attributes.push(quote! { #eval_always });\n         };\n \n-        let attribute_stream = quote! {#(#attributes),*};\n+        // This uses the span of the query definition for the commas,\n+        // which can be important if we later encounter any ambiguity\n+        // errors with any of the numerous macro_rules! macros that\n+        // we use. Using the call-site span would result in a span pointing\n+        // at the entire `rustc_queries!` invocation, which wouldn't\n+        // be very useful.\n+        let span = name.span();\n+        let attribute_stream = quote_spanned! {span=> #(#attributes),*};\n         let doc_comments = query.doc_comments.iter();\n         // Add the query to the group\n         query_stream.extend(quote! {"}]}