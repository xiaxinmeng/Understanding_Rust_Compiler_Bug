{"sha": "9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmY2IxNjU4YWIxM2E3ZjcyMmU0NzQ3YzVhNGI2OTEyOTFlODhhM2I=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-02-05T04:20:55Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-02-05T22:06:27Z"}, "message": "Overhaul `syntax::fold::Folder`.\n\nThis commit changes `syntax::fold::Folder` from a functional style\n(where most methods take a `T` and produce a new `T`) to a more\nimperative style (where most methods take and modify a `&mut T`), and\nrenames it `syntax::mut_visit::MutVisitor`.\n\nThe first benefit is speed. The functional style does not require any\nreallocations, due to the use of `P::map` and\n`MoveMap::move_{,flat_}map`. However, every field in the AST must be\noverwritten; even those fields that are unchanged are overwritten with\nthe same value. This causes a lot of unnecessary memory writes. The\nimperative style reduces instruction counts by 1--3% across a wide range\nof workloads, particularly incremental workloads.\n\nThe second benefit is conciseness; the imperative style is usually more\nconcise. E.g. compare the old functional style:\n```\nfn fold_abc(&mut self, abc: ABC) {\n    ABC {\n        a: fold_a(abc.a),\n        b: fold_b(abc.b),\n        c: abc.c,\n    }\n}\n```\nwith the imperative style:\n```\nfn visit_abc(&mut self, ABC { a, b, c: _ }: &mut ABC) {\n    visit_a(a);\n    visit_b(b);\n}\n```\n(The reductions get larger in more complex examples.)\n\nOverall, the patch removes over 200 lines of code -- even though the new\ncode has more comments -- and a lot of the remaining lines have fewer\ncharacters.\n\nSome notes:\n\n- The old style used methods called `fold_*`. The new style mostly uses\n  methods called `visit_*`, but there are a few methods that map a `T`\n  to something other than a `T`, which are called `flat_map_*` (`T` maps\n  to multiple `T`s) or `filter_map_*` (`T` maps to 0 or 1 `T`s).\n\n- `move_map.rs`/`MoveMap`/`move_map`/`move_flat_map` are renamed\n  `map_in_place.rs`/`MapInPlace`/`map_in_place`/`flat_map_in_place` to\n  reflect their slightly changed signatures.\n\n- Although this commit renames the `fold` module as `mut_visit`, it\n  keeps it in the `fold.rs` file, so as not to confuse git. The next\n  commit will rename the file.", "tree": {"sha": "8c9a307c14cd3fc9e45466f7acca8fd2397ffe28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c9a307c14cd3fc9e45466f7acca8fd2397ffe28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "html_url": "https://github.com/rust-lang/rust/commit/9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "970b5d189af48dd6ec26e90bb8d6d236824edf4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/970b5d189af48dd6ec26e90bb8d6d236824edf4b", "html_url": "https://github.com/rust-lang/rust/commit/970b5d189af48dd6ec26e90bb8d6d236824edf4b"}], "stats": {"total": 2933, "additions": 1417, "deletions": 1516}, "files": [{"sha": "1fb1794d5147d5a49ca119ceac6416823b2b1506", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -16,7 +16,7 @@ use syntax::{\n         expand::ExpansionConfig,\n         hygiene::{self, Mark, SyntaxContext},\n     },\n-    fold::{self, Folder},\n+    mut_visit::{self, MutVisitor},\n     parse::ParseSess,\n     ptr::P,\n     symbol::Symbol\n@@ -28,18 +28,18 @@ use {AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n pub fn modify(\n     sess: &ParseSess,\n     resolver: &mut dyn Resolver,\n-    krate: Crate,\n+    krate: &mut Crate,\n     crate_name: String,\n     handler: &rustc_errors::Handler,\n-) -> ast::Crate {\n+) {\n     ExpandAllocatorDirectives {\n         handler,\n         sess,\n         resolver,\n         found: false,\n         crate_name: Some(crate_name),\n         in_submod: -1, // -1 to account for the \"root\" module\n-    }.fold_crate(krate)\n+    }.visit_crate(krate);\n }\n \n struct ExpandAllocatorDirectives<'a> {\n@@ -54,14 +54,14 @@ struct ExpandAllocatorDirectives<'a> {\n     in_submod: isize,\n }\n \n-impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n-    fn fold_item(&mut self, item: P<Item>) -> SmallVec<[P<Item>; 1]> {\n+impl<'a> MutVisitor for ExpandAllocatorDirectives<'a> {\n+    fn flat_map_item(&mut self, item: P<Item>) -> SmallVec<[P<Item>; 1]> {\n         debug!(\"in submodule {}\", self.in_submod);\n \n         let name = if attr::contains_name(&item.attrs, \"global_allocator\") {\n             \"global_allocator\"\n         } else {\n-            return fold::noop_fold_item(item, self);\n+            return mut_visit::noop_flat_map_item(item, self);\n         };\n         match item.node {\n             ItemKind::Static(..) => {}\n@@ -139,25 +139,24 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n         let name = f.kind.fn_name(\"allocator_abi\");\n         let allocator_abi = Ident::with_empty_ctxt(Symbol::gensym(&name));\n         let module = f.cx.item_mod(span, span, allocator_abi, Vec::new(), items);\n-        let module = f.cx.monotonic_expander().fold_item(module).pop().unwrap();\n+        let module = f.cx.monotonic_expander().flat_map_item(module).pop().unwrap();\n \n         // Return the item and new submodule\n         smallvec![item, module]\n     }\n \n     // If we enter a submodule, take note.\n-    fn fold_mod(&mut self, m: Mod) -> Mod {\n+    fn visit_mod(&mut self, m: &mut Mod) {\n         debug!(\"enter submodule\");\n         self.in_submod += 1;\n-        let ret = fold::noop_fold_mod(m, self);\n+        mut_visit::noop_visit_mod(m, self);\n         self.in_submod -= 1;\n         debug!(\"exit submodule\");\n-        ret\n     }\n \n-    // `fold_mac` is disabled by default. Enable it here.\n-    fn fold_mac(&mut self, mac: Mac) -> Mac {\n-        fold::noop_fold_mac(mac, self)\n+    // `visit_mac` is disabled by default. Enable it here.\n+    fn visit_mac(&mut self, mac: &mut Mac) {\n+        mut_visit::noop_visit_mac(mac, self)\n     }\n }\n "}, {"sha": "ed57c528f51e0de03b0c85741457a3c2c17334e6", "filename": "src/librustc_data_structures/thin_vec.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibrustc_data_structures%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibrustc_data_structures%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fthin_vec.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -39,6 +39,15 @@ impl<T> ::std::ops::Deref for ThinVec<T> {\n     }\n }\n \n+impl<T> ::std::ops::DerefMut for ThinVec<T> {\n+    fn deref_mut(&mut self) -> &mut [T] {\n+        match *self {\n+            ThinVec(None) => &mut [],\n+            ThinVec(Some(ref mut vec)) => vec,\n+        }\n+    }\n+}\n+\n impl<T> Extend<T> for ThinVec<T> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         match *self {"}, {"sha": "4549b20899dd51b4706831362eacc4b72ff2ba4d", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -32,7 +32,7 @@ use rustc_typeck as typeck;\n use syntax::{self, ast, attr, diagnostics, visit};\n use syntax::early_buffered_lints::BufferedEarlyLint;\n use syntax::ext::base::ExtCtxt;\n-use syntax::fold::Folder;\n+use syntax::mut_visit::MutVisitor;\n use syntax::parse::{self, PResult};\n use syntax::util::node_count::NodeCounter;\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -1000,12 +1000,12 @@ where\n     });\n     sess.profiler(|p| p.end_activity(ProfileCategory::Expansion));\n \n-    krate = time(sess, \"maybe building test harness\", || {\n+    time(sess, \"maybe building test harness\", || {\n         syntax::test::modify_for_testing(\n             &sess.parse_sess,\n             &mut resolver,\n             sess.opts.test,\n-            krate,\n+            &mut krate,\n             sess.diagnostic(),\n             &sess.features_untracked(),\n         )\n@@ -1014,7 +1014,7 @@ where\n     // If we're actually rustdoc then there's no need to actually compile\n     // anything, so switch everything to just looping\n     if sess.opts.actually_rustdoc {\n-        krate = ReplaceBodyWithLoop::new(sess).fold_crate(krate);\n+        ReplaceBodyWithLoop::new(sess).visit_crate(&mut krate);\n     }\n \n     let (has_proc_macro_decls, has_global_allocator) = time(sess, \"AST validation\", || {\n@@ -1045,11 +1045,11 @@ where\n \n     if has_global_allocator {\n         // Expand global allocators, which are treated as an in-tree proc macro\n-        krate = time(sess, \"creating allocators\", || {\n+        time(sess, \"creating allocators\", || {\n             allocator::expand::modify(\n                 &sess.parse_sess,\n                 &mut resolver,\n-                krate,\n+                &mut krate,\n                 crate_name.to_string(),\n                 sess.diagnostic(),\n             )"}, {"sha": "d0dc7799c7b72a14eb19fd0cbc70aa92c620491c", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -870,9 +870,9 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 control.after_hir_lowering.stop = Compilation::Stop;\n \n                 control.after_parse.callback = box move |state| {\n-                    state.krate = Some(pretty::fold_crate(state.session,\n-                                                          state.krate.take().unwrap(),\n-                                                          ppm));\n+                    let mut krate = state.krate.take().unwrap();\n+                    pretty::visit_crate(state.session, &mut krate, ppm);\n+                    state.krate = Some(krate);\n                 };\n                 control.after_hir_lowering.callback = box move |state| {\n                     pretty::print_after_hir_lowering(state.session,\n@@ -891,7 +891,8 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 control.after_parse.stop = Compilation::Stop;\n \n                 control.after_parse.callback = box move |state| {\n-                    let krate = pretty::fold_crate(state.session, state.krate.take().unwrap(), ppm);\n+                    let mut krate = state.krate.take().unwrap();\n+                    pretty::visit_crate(state.session, &mut krate, ppm);\n                     pretty::print_after_parsing(state.session,\n                                                 state.input,\n                                                 &krate,"}, {"sha": "4caf2ec676f078a625de69ae208981155a4d19d0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -16,7 +16,7 @@ use rustc_metadata::cstore::CStore;\n use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n use syntax::ast::{self, BlockCheckMode};\n-use syntax::fold::{self, Folder};\n+use syntax::mut_visit::{*, MutVisitor, visit_clobber};\n use syntax::print::{pprust};\n use syntax::print::pprust::PrintState;\n use syntax::ptr::P;\n@@ -28,6 +28,7 @@ use smallvec::SmallVec;\n use std::cell::Cell;\n use std::fs::File;\n use std::io::{self, Write};\n+use std::ops::DerefMut;\n use std::option;\n use std::path::Path;\n use std::str::FromStr;\n@@ -703,42 +704,42 @@ impl<'a> ReplaceBodyWithLoop<'a> {\n     }\n }\n \n-impl<'a> fold::Folder for ReplaceBodyWithLoop<'a> {\n-    fn fold_item_kind(&mut self, i: ast::ItemKind) -> ast::ItemKind {\n+impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n+    fn visit_item_kind(&mut self, i: &mut ast::ItemKind) {\n         let is_const = match i {\n             ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => true,\n             ast::ItemKind::Fn(ref decl, ref header, _, _) =>\n                 header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n             _ => false,\n         };\n-        self.run(is_const, |s| fold::noop_fold_item_kind(i, s))\n+        self.run(is_const, |s| noop_visit_item_kind(i, s))\n     }\n \n-    fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n+    fn flat_map_trait_item(&mut self, i: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n         let is_const = match i.node {\n             ast::TraitItemKind::Const(..) => true,\n             ast::TraitItemKind::Method(ast::MethodSig { ref decl, ref header, .. }, _) =>\n                 header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n             _ => false,\n         };\n-        self.run(is_const, |s| fold::noop_fold_trait_item(i, s))\n+        self.run(is_const, |s| noop_flat_map_trait_item(i, s))\n     }\n \n-    fn fold_impl_item(&mut self, i: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n+    fn flat_map_impl_item(&mut self, i: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n         let is_const = match i.node {\n             ast::ImplItemKind::Const(..) => true,\n             ast::ImplItemKind::Method(ast::MethodSig { ref decl, ref header, .. }, _) =>\n                 header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n             _ => false,\n         };\n-        self.run(is_const, |s| fold::noop_fold_impl_item(i, s))\n+        self.run(is_const, |s| noop_flat_map_impl_item(i, s))\n     }\n \n-    fn fold_anon_const(&mut self, c: ast::AnonConst) -> ast::AnonConst {\n-        self.run(true, |s| fold::noop_fold_anon_const(c, s))\n+    fn visit_anon_const(&mut self, c: &mut ast::AnonConst) {\n+        self.run(true, |s| noop_visit_anon_const(c, s))\n     }\n \n-    fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {\n+    fn visit_block(&mut self, b: &mut P<ast::Block>) {\n         fn stmt_to_block(rules: ast::BlockCheckMode,\n                          s: Option<ast::Stmt>,\n                          sess: &Session) -> ast::Block {\n@@ -780,14 +781,14 @@ impl<'a> fold::Folder for ReplaceBodyWithLoop<'a> {\n         };\n \n         if self.within_static_or_const {\n-            fold::noop_fold_block(b, self)\n+            noop_visit_block(b, self)\n         } else {\n-            b.map(|b| {\n+            visit_clobber(b.deref_mut(), |b| {\n                 let mut stmts = vec![];\n                 for s in b.stmts {\n                     let old_blocks = self.nested_blocks.replace(vec![]);\n \n-                    stmts.extend(self.fold_stmt(s).into_iter().filter(|s| s.is_item()));\n+                    stmts.extend(self.flat_map_stmt(s).into_iter().filter(|s| s.is_item()));\n \n                     // we put a Some in there earlier with that replace(), so this is valid\n                     let new_blocks = self.nested_blocks.take().unwrap();\n@@ -818,9 +819,9 @@ impl<'a> fold::Folder for ReplaceBodyWithLoop<'a> {\n     }\n \n     // in general the pretty printer processes unexpanded code, so\n-    // we override the default `fold_mac` method which panics.\n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(mac, self)\n+    // we override the default `visit_mac` method which panics.\n+    fn visit_mac(&mut self, mac: &mut ast::Mac) {\n+        noop_visit_mac(mac, self)\n     }\n }\n \n@@ -889,12 +890,9 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n     }\n }\n \n-pub fn fold_crate(sess: &Session, krate: ast::Crate, ppm: PpMode) -> ast::Crate {\n+pub fn visit_crate(sess: &Session, krate: &mut ast::Crate, ppm: PpMode) {\n     if let PpmSource(PpmEveryBodyLoops) = ppm {\n-        let mut fold = ReplaceBodyWithLoop::new(sess);\n-        fold.fold_crate(krate)\n-    } else {\n-        krate\n+        ReplaceBodyWithLoop::new(sess).visit_crate(krate);\n     }\n }\n "}, {"sha": "c5a397e048078f2045b7d3c9d173e995beddd384", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -15,6 +15,7 @@ use ast;\n use ast::{AttrId, Attribute, AttrStyle, Name, Ident, Path, PathSegment};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind, GenericParam};\n+use mut_visit::visit_clobber;\n use source_map::{BytePos, Spanned, respan, dummy_spanned};\n use syntax_pos::{FileName, Span};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n@@ -28,6 +29,7 @@ use tokenstream::{TokenStream, TokenTree, DelimSpan};\n use GLOBALS;\n \n use std::iter;\n+use std::ops::DerefMut;\n \n pub fn mark_used(attr: &Attribute) {\n     debug!(\"Marking {:?} as used.\", attr);\n@@ -695,21 +697,21 @@ impl LitKind {\n \n pub trait HasAttrs: Sized {\n     fn attrs(&self) -> &[ast::Attribute];\n-    fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self;\n+    fn visit_attrs<F: FnOnce(&mut Vec<ast::Attribute>)>(&mut self, f: F);\n }\n \n impl<T: HasAttrs> HasAttrs for Spanned<T> {\n     fn attrs(&self) -> &[ast::Attribute] { self.node.attrs() }\n-    fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self {\n-        respan(self.span, self.node.map_attrs(f))\n+    fn visit_attrs<F: FnOnce(&mut Vec<ast::Attribute>)>(&mut self, f: F) {\n+        self.node.visit_attrs(f);\n     }\n }\n \n impl HasAttrs for Vec<Attribute> {\n     fn attrs(&self) -> &[Attribute] {\n         self\n     }\n-    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n+    fn visit_attrs<F: FnOnce(&mut Vec<Attribute>)>(&mut self, f: F) {\n         f(self)\n     }\n }\n@@ -718,17 +720,21 @@ impl HasAttrs for ThinVec<Attribute> {\n     fn attrs(&self) -> &[Attribute] {\n         self\n     }\n-    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n-        f(self.into()).into()\n+    fn visit_attrs<F: FnOnce(&mut Vec<Attribute>)>(&mut self, f: F) {\n+        visit_clobber(self, |this| {\n+            let mut vec = this.into();\n+            f(&mut vec);\n+            vec.into()\n+        });\n     }\n }\n \n impl<T: HasAttrs + 'static> HasAttrs for P<T> {\n     fn attrs(&self) -> &[Attribute] {\n         (**self).attrs()\n     }\n-    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n-        self.map(|t| t.map_attrs(f))\n+    fn visit_attrs<F: FnOnce(&mut Vec<Attribute>)>(&mut self, f: F) {\n+        (**self).visit_attrs(f);\n     }\n }\n \n@@ -745,23 +751,27 @@ impl HasAttrs for StmtKind {\n         }\n     }\n \n-    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n+    fn visit_attrs<F: FnOnce(&mut Vec<Attribute>)>(&mut self, f: F) {\n         match self {\n-            StmtKind::Local(local) => StmtKind::Local(local.map_attrs(f)),\n-            StmtKind::Item(..) => self,\n-            StmtKind::Expr(expr) => StmtKind::Expr(expr.map_attrs(f)),\n-            StmtKind::Semi(expr) => StmtKind::Semi(expr.map_attrs(f)),\n-            StmtKind::Mac(mac) => StmtKind::Mac(mac.map(|(mac, style, attrs)| {\n-                (mac, style, attrs.map_attrs(f))\n-            })),\n+            StmtKind::Local(local) => local.visit_attrs(f),\n+            StmtKind::Item(..) => {}\n+            StmtKind::Expr(expr) => expr.visit_attrs(f),\n+            StmtKind::Semi(expr) => expr.visit_attrs(f),\n+            StmtKind::Mac(mac) => {\n+                let (_mac, _style, attrs) = mac.deref_mut();\n+                attrs.visit_attrs(f);\n+            }\n         }\n     }\n }\n \n impl HasAttrs for Stmt {\n-    fn attrs(&self) -> &[ast::Attribute] { self.node.attrs() }\n-    fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self {\n-        Stmt { id: self.id, node: self.node.map_attrs(f), span: self.span }\n+    fn attrs(&self) -> &[ast::Attribute] {\n+        self.node.attrs()\n+    }\n+\n+    fn visit_attrs<F: FnOnce(&mut Vec<ast::Attribute>)>(&mut self, f: F) {\n+        self.node.visit_attrs(f);\n     }\n }\n \n@@ -770,9 +780,8 @@ impl HasAttrs for GenericParam {\n         &self.attrs\n     }\n \n-    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(mut self, f: F) -> Self {\n-        self.attrs = self.attrs.map_attrs(f);\n-        self\n+    fn visit_attrs<F: FnOnce(&mut Vec<Attribute>)>(&mut self, f: F) {\n+        self.attrs.visit_attrs(f);\n     }\n }\n \n@@ -783,11 +792,8 @@ macro_rules! derive_has_attrs {\n                 &self.attrs\n             }\n \n-            fn map_attrs<F>(mut self, f: F) -> Self\n-                where F: FnOnce(Vec<Attribute>) -> Vec<Attribute>,\n-            {\n-                self.attrs = self.attrs.map_attrs(f);\n-                self\n+            fn visit_attrs<F: FnOnce(&mut Vec<Attribute>)>(&mut self, f: F) {\n+                self.attrs.visit_attrs(f);\n             }\n         }\n     )* }"}, {"sha": "fce2601e3aa84b2570ea52dd00e3c50f3132f031", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 69, "deletions": 97, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -6,16 +6,15 @@ use feature_gate::{\n     get_features,\n     GateIssue,\n };\n-use {fold, attr};\n+use attr;\n use ast;\n-use source_map::Spanned;\n use edition::Edition;\n-use parse::{token, ParseSess};\n-use smallvec::SmallVec;\n use errors::Applicability;\n-use util::move_map::MoveMap;\n-\n+use mut_visit::*;\n+use parse::{token, ParseSess};\n use ptr::P;\n+use smallvec::SmallVec;\n+use util::map_in_place::MapInPlace;\n \n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n@@ -65,8 +64,8 @@ macro_rules! configure {\n }\n \n impl<'a> StripUnconfigured<'a> {\n-    pub fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n-        let node = self.process_cfg_attrs(node);\n+    pub fn configure<T: HasAttrs>(&mut self, mut node: T) -> Option<T> {\n+        self.process_cfg_attrs(&mut node);\n         if self.in_cfg(node.attrs()) { Some(node) } else { None }\n     }\n \n@@ -76,10 +75,10 @@ impl<'a> StripUnconfigured<'a> {\n     /// Gives compiler warnigns if any `cfg_attr` does not contain any\n     /// attributes and is in the original source code. Gives compiler errors if\n     /// the syntax of any `cfg_attr` is incorrect.\n-    pub fn process_cfg_attrs<T: HasAttrs>(&mut self, node: T) -> T {\n-        node.map_attrs(|attrs| {\n-            attrs.into_iter().flat_map(|attr| self.process_cfg_attr(attr)).collect()\n-        })\n+    pub fn process_cfg_attrs<T: HasAttrs>(&mut self, node: &mut T) {\n+        node.visit_attrs(|attrs| {\n+            attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n+        });\n     }\n \n     /// Parse and expand a single `cfg_attr` attribute into a list of attributes\n@@ -218,79 +217,56 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    pub fn configure_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n-        ast::ForeignMod {\n-            abi: foreign_mod.abi,\n-            items: foreign_mod.items.move_flat_map(|item| self.configure(item)),\n-        }\n+    pub fn configure_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n+        let ast::ForeignMod { abi: _, items } = foreign_mod;\n+        items.flat_map_in_place(|item| self.configure(item));\n     }\n \n-    fn configure_variant_data(&mut self, vdata: ast::VariantData) -> ast::VariantData {\n+    fn configure_variant_data(&mut self, vdata: &mut ast::VariantData) {\n         match vdata {\n-            ast::VariantData::Struct(fields, id) => {\n-                let fields = fields.move_flat_map(|field| self.configure(field));\n-                ast::VariantData::Struct(fields, id)\n-            }\n-            ast::VariantData::Tuple(fields, id) => {\n-                let fields = fields.move_flat_map(|field| self.configure(field));\n-                ast::VariantData::Tuple(fields, id)\n-            }\n-            ast::VariantData::Unit(id) => ast::VariantData::Unit(id)\n+            ast::VariantData::Struct(fields, _id) |\n+            ast::VariantData::Tuple(fields, _id) =>\n+                fields.flat_map_in_place(|field| self.configure(field)),\n+            ast::VariantData::Unit(_id) => {}\n         }\n     }\n \n-    pub fn configure_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n+    pub fn configure_item_kind(&mut self, item: &mut ast::ItemKind) {\n         match item {\n-            ast::ItemKind::Struct(def, generics) => {\n-                ast::ItemKind::Struct(self.configure_variant_data(def), generics)\n-            }\n-            ast::ItemKind::Union(def, generics) => {\n-                ast::ItemKind::Union(self.configure_variant_data(def), generics)\n-            }\n-            ast::ItemKind::Enum(def, generics) => {\n-                let variants = def.variants.move_flat_map(|v| {\n-                    self.configure(v).map(|v| {\n-                        Spanned {\n-                            node: ast::Variant_ {\n-                                ident: v.node.ident,\n-                                attrs: v.node.attrs,\n-                                data: self.configure_variant_data(v.node.data),\n-                                disr_expr: v.node.disr_expr,\n-                            },\n-                            span: v.span\n-                        }\n-                    })\n-                });\n-                ast::ItemKind::Enum(ast::EnumDef { variants }, generics)\n+            ast::ItemKind::Struct(def, _generics) |\n+            ast::ItemKind::Union(def, _generics) => self.configure_variant_data(def),\n+            ast::ItemKind::Enum(ast::EnumDef { variants }, _generics) => {\n+                variants.flat_map_in_place(|variant| self.configure(variant));\n+                for variant in variants {\n+                    self.configure_variant_data(&mut variant.node.data);\n+                }\n             }\n-            item => item,\n+            _ => {}\n         }\n     }\n \n-    pub fn configure_expr_kind(&mut self, expr_kind: ast::ExprKind) -> ast::ExprKind {\n+    pub fn configure_expr_kind(&mut self, expr_kind: &mut ast::ExprKind) {\n         match expr_kind {\n-            ast::ExprKind::Match(m, arms) => {\n-                let arms = arms.move_flat_map(|a| self.configure(a));\n-                ast::ExprKind::Match(m, arms)\n+            ast::ExprKind::Match(_m, arms) => {\n+                arms.flat_map_in_place(|arm| self.configure(arm));\n             }\n-            ast::ExprKind::Struct(path, fields, base) => {\n-                let fields = fields.move_flat_map(|field| self.configure(field));\n-                ast::ExprKind::Struct(path, fields, base)\n+            ast::ExprKind::Struct(_path, fields, _base) => {\n+                fields.flat_map_in_place(|field| self.configure(field));\n             }\n-            _ => expr_kind,\n+            _ => {}\n         }\n     }\n \n-    pub fn configure_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n+    pub fn configure_expr(&mut self, expr: &mut P<ast::Expr>) {\n         self.visit_expr_attrs(expr.attrs());\n \n         // If an expr is valid to cfg away it will have been removed by the\n         // outer stmt or expression folder before descending in here.\n         // Anything else is always required, and thus has to error out\n         // in case of a cfg attr.\n         //\n-        // N.B., this is intentionally not part of the fold_expr() function\n-        //     in order for fold_opt_expr() to be able to avoid this check\n+        // N.B., this is intentionally not part of the visit_expr() function\n+        //     in order for filter_map_expr() to be able to avoid this check\n         if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n             let msg = \"removing an expression is not supported in this position\";\n             self.sess.span_diagnostic.span_err(attr.span, msg);\n@@ -299,14 +275,10 @@ impl<'a> StripUnconfigured<'a> {\n         self.process_cfg_attrs(expr)\n     }\n \n-    pub fn configure_pat(&mut self, pattern: P<ast::Pat>) -> P<ast::Pat> {\n-        pattern.map(|mut pattern| {\n-            if let ast::PatKind::Struct(path, fields, etc) = pattern.node {\n-                let fields = fields.move_flat_map(|field| self.configure(field));\n-                pattern.node = ast::PatKind::Struct(path, fields, etc);\n-            }\n-            pattern\n-        })\n+    pub fn configure_pat(&mut self, pat: &mut P<ast::Pat>) {\n+        if let ast::PatKind::Struct(_path, fields, _etc) = &mut pat.node {\n+            fields.flat_map_in_place(|field| self.configure(field));\n+        }\n     }\n \n     // deny #[cfg] on generic parameters until we decide what to do with it.\n@@ -326,54 +298,54 @@ impl<'a> StripUnconfigured<'a> {\n     }\n }\n \n-impl<'a> fold::Folder for StripUnconfigured<'a> {\n-    fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n-        let foreign_mod = self.configure_foreign_mod(foreign_mod);\n-        fold::noop_fold_foreign_mod(foreign_mod, self)\n+impl<'a> MutVisitor for StripUnconfigured<'a> {\n+    fn visit_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n+        self.configure_foreign_mod(foreign_mod);\n+        noop_visit_foreign_mod(foreign_mod, self);\n     }\n \n-    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n-        let item = self.configure_item_kind(item);\n-        fold::noop_fold_item_kind(item, self)\n+    fn visit_item_kind(&mut self, item: &mut ast::ItemKind) {\n+        self.configure_item_kind(item);\n+        noop_visit_item_kind(item, self);\n     }\n \n-    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        let mut expr = self.configure_expr(expr).into_inner();\n-        expr.node = self.configure_expr_kind(expr.node);\n-        P(fold::noop_fold_expr(expr, self))\n+    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n+        self.configure_expr(expr);\n+        self.configure_expr_kind(&mut expr.node);\n+        noop_visit_expr(expr, self);\n     }\n \n-    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        let mut expr = configure!(self, expr).into_inner();\n-        expr.node = self.configure_expr_kind(expr.node);\n-        Some(P(fold::noop_fold_expr(expr, self)))\n+    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        let mut expr = configure!(self, expr);\n+        self.configure_expr_kind(&mut expr.node);\n+        noop_visit_expr(&mut expr, self);\n+        Some(expr)\n     }\n \n-    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n-        fold::noop_fold_stmt(configure!(self, stmt), self)\n+    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n+        noop_flat_map_stmt(configure!(self, stmt), self)\n     }\n \n-    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n-        fold::noop_fold_item(configure!(self, item), self)\n+    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n+        noop_flat_map_item(configure!(self, item), self)\n     }\n \n-    fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]>\n-    {\n-        fold::noop_fold_impl_item(configure!(self, item), self)\n+    fn flat_map_impl_item(&mut self, item: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n+        noop_flat_map_impl_item(configure!(self, item), self)\n     }\n \n-    fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n-        fold::noop_fold_trait_item(configure!(self, item), self)\n+    fn flat_map_trait_item(&mut self, item: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n+        noop_flat_map_trait_item(configure!(self, item), self)\n     }\n \n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+    fn visit_mac(&mut self, _mac: &mut ast::Mac) {\n         // Don't configure interpolated AST (cf. issue #34171).\n         // Interpolated AST will get configured once the surrounding tokens are parsed.\n-        mac\n     }\n \n-    fn fold_pat(&mut self, pattern: P<ast::Pat>) -> P<ast::Pat> {\n-        fold::noop_fold_pat(self.configure_pat(pattern), self)\n+    fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n+        self.configure_pat(pat);\n+        noop_visit_pat(pat, self)\n     }\n }\n "}, {"sha": "b53068f5bc2a42b41f98f7b4feb3dd848843836e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -8,7 +8,7 @@ use edition::Edition;\n use errors::{DiagnosticBuilder, DiagnosticId};\n use ext::expand::{self, AstFragment, Invocation};\n use ext::hygiene::{self, Mark, SyntaxContext, Transparency};\n-use fold::{self, Folder};\n+use mut_visit::{self, MutVisitor};\n use parse::{self, parser, DirectoryOwnership};\n use parse::token;\n use ptr::P;\n@@ -47,15 +47,14 @@ impl HasAttrs for Annotatable {\n         }\n     }\n \n-    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n+    fn visit_attrs<F: FnOnce(&mut Vec<Attribute>)>(&mut self, f: F) {\n         match self {\n-            Annotatable::Item(item) => Annotatable::Item(item.map_attrs(f)),\n-            Annotatable::TraitItem(trait_item) => Annotatable::TraitItem(trait_item.map_attrs(f)),\n-            Annotatable::ImplItem(impl_item) => Annotatable::ImplItem(impl_item.map_attrs(f)),\n-            Annotatable::ForeignItem(foreign_item) =>\n-                Annotatable::ForeignItem(foreign_item.map_attrs(f)),\n-            Annotatable::Stmt(stmt) => Annotatable::Stmt(stmt.map_attrs(f)),\n-            Annotatable::Expr(expr) => Annotatable::Expr(expr.map_attrs(f)),\n+            Annotatable::Item(item) => item.visit_attrs(f),\n+            Annotatable::TraitItem(trait_item) => trait_item.visit_attrs(f),\n+            Annotatable::ImplItem(impl_item) => impl_item.visit_attrs(f),\n+            Annotatable::ForeignItem(foreign_item) => foreign_item.visit_attrs(f),\n+            Annotatable::Stmt(stmt) => stmt.visit_attrs(f),\n+            Annotatable::Expr(expr) => expr.visit_attrs(f),\n         }\n     }\n }\n@@ -263,24 +262,24 @@ impl<F> TTMacroExpander for F\n     ) -> Box<dyn MacResult+'cx> {\n         struct AvoidInterpolatedIdents;\n \n-        impl Folder for AvoidInterpolatedIdents {\n-            fn fold_tt(&mut self, tt: tokenstream::TokenTree) -> tokenstream::TokenTree {\n-                if let tokenstream::TokenTree::Token(_, token::Interpolated(ref nt)) = tt {\n+        impl MutVisitor for AvoidInterpolatedIdents {\n+            fn visit_tt(&mut self, tt: &mut tokenstream::TokenTree) {\n+                if let tokenstream::TokenTree::Token(_, token::Interpolated(nt)) = tt {\n                     if let token::NtIdent(ident, is_raw) = nt.0 {\n-                        return tokenstream::TokenTree::Token(ident.span,\n-                                                             token::Ident(ident, is_raw));\n+                        *tt = tokenstream::TokenTree::Token(ident.span,\n+                                                            token::Ident(ident, is_raw));\n                     }\n                 }\n-                fold::noop_fold_tt(tt, self)\n+                mut_visit::noop_visit_tt(tt, self)\n             }\n \n-            fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-                fold::noop_fold_mac(mac, self)\n+            fn visit_mac(&mut self, mac: &mut ast::Mac) {\n+                mut_visit::noop_visit_mac(mac, self)\n             }\n         }\n \n         let input: Vec<_> =\n-            input.trees().map(|tt| AvoidInterpolatedIdents.fold_tt(tt)).collect();\n+            input.trees().map(|mut tt| { AvoidInterpolatedIdents.visit_tt(&mut tt); tt }).collect();\n         (*self)(ecx, span, &input)\n     }\n }\n@@ -981,17 +980,14 @@ impl<'a> ExtCtxt<'a> {\n /// compilation on error, merely emits a non-fatal error and returns None.\n pub fn expr_to_spanned_string<'a>(\n     cx: &'a mut ExtCtxt,\n-    expr: P<ast::Expr>,\n+    mut expr: P<ast::Expr>,\n     err_msg: &str,\n ) -> Result<Spanned<(Symbol, ast::StrStyle)>, Option<DiagnosticBuilder<'a>>> {\n     // Update `expr.span`'s ctxt now in case expr is an `include!` macro invocation.\n-    let expr = expr.map(|mut expr| {\n-        expr.span = expr.span.apply_mark(cx.current_expansion.mark);\n-        expr\n-    });\n+    expr.span = expr.span.apply_mark(cx.current_expansion.mark);\n \n     // we want to be able to handle e.g., `concat!(\"foo\", \"bar\")`\n-    let expr = cx.expander().fold_expr(expr);\n+    cx.expander().visit_expr(&mut expr);\n     Err(match expr.node {\n         ast::ExprKind::Lit(ref l) => match l.node {\n             ast::LitKind::Str(s, style) => return Ok(respan(expr.span, (s, style))),\n@@ -1055,7 +1051,9 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::Eof {\n-        es.push(cx.expander().fold_expr(panictry!(p.parse_expr())));\n+        let mut expr = panictry!(p.parse_expr());\n+        cx.expander().visit_expr(&mut expr);\n+        es.push(expr);\n         if p.eat(&token::Comma) {\n             continue;\n         }"}, {"sha": "fa8cf6c496a39f248beaf3ee6743dc292142fcb6", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -40,7 +40,7 @@ pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec\n     result\n }\n \n-pub fn add_derived_markers<T>(cx: &mut ExtCtxt, span: Span, traits: &[ast::Path], item: T) -> T\n+pub fn add_derived_markers<T>(cx: &mut ExtCtxt, span: Span, traits: &[ast::Path], item: &mut T)\n     where T: HasAttrs,\n {\n     let (mut names, mut pretty_name) = (FxHashSet::default(), \"derive(\".to_owned());\n@@ -64,7 +64,7 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt, span: Span, traits: &[ast::Path]\n     });\n \n     let span = span.with_ctxt(cx.backtrace());\n-    item.map_attrs(|mut attrs| {\n+    item.visit_attrs(|attrs| {\n         if names.contains(&Symbol::intern(\"Eq\")) && names.contains(&Symbol::intern(\"PartialEq\")) {\n             let meta = cx.meta_word(span, Symbol::intern(\"structural_match\"));\n             attrs.push(cx.attribute(span, meta));\n@@ -73,6 +73,5 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt, span: Span, traits: &[ast::Path]\n             let meta = cx.meta_word(span, Symbol::intern(\"rustc_copy_clone_marker\"));\n             attrs.push(cx.attribute(span, meta));\n         }\n-        attrs\n-    })\n+    });\n }"}, {"sha": "a0ccce986592a043cd3c2f9cf32d19767655622a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 151, "deletions": 139, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -9,7 +9,7 @@ use ext::derive::{add_derived_markers, collect_derives};\n use ext::hygiene::{self, Mark, SyntaxContext};\n use ext::placeholders::{placeholder, PlaceholderExpander};\n use feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n-use fold::*;\n+use mut_visit::*;\n use parse::{DirectoryOwnership, PResult, ParseSess};\n use parse::token::{self, Token};\n use parse::parser::Parser;\n@@ -21,11 +21,13 @@ use syntax_pos::{Span, DUMMY_SP, FileName};\n use syntax_pos::hygiene::ExpnFormat;\n use tokenstream::{TokenStream, TokenTree};\n use visit::{self, Visitor};\n+use util::map_in_place::MapInPlace;\n \n use rustc_data_structures::fx::FxHashMap;\n use std::fs;\n use std::io::ErrorKind;\n use std::{iter, mem};\n+use std::ops::DerefMut;\n use std::rc::Rc;\n use std::path::PathBuf;\n \n@@ -35,8 +37,8 @@ macro_rules! ast_fragments {\n             $kind_name:expr;\n             // FIXME: HACK: this should be `$(one ...)?` and `$(many ...)?` but `?` macro\n             // repetition was removed from 2015 edition in #51587 because of ambiguities.\n-            $(one fn $fold_ast:ident; fn $visit_ast:ident;)*\n-            $(many fn $fold_ast_elt:ident; fn $visit_ast_elt:ident;)*\n+            $(one fn $mut_visit_ast:ident; fn $visit_ast:ident;)*\n+            $(many fn $flat_map_ast_elt:ident; fn $visit_ast_elt:ident;)*\n             fn $make_ast:ident;\n         })*\n     ) => {\n@@ -86,16 +88,20 @@ macro_rules! ast_fragments {\n                 }\n             })*\n \n-            pub fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n+            pub fn mut_visit_with<F: MutVisitor>(&mut self, vis: &mut F) {\n                 match self {\n-                    AstFragment::OptExpr(expr) =>\n-                        AstFragment::OptExpr(expr.and_then(|expr| folder.fold_opt_expr(expr))),\n-                    $($(AstFragment::$Kind(ast) =>\n-                        AstFragment::$Kind(folder.$fold_ast(ast)),)*)*\n+                    AstFragment::OptExpr(opt_expr) => {\n+                        visit_clobber(opt_expr, |opt_expr| {\n+                            if let Some(expr) = opt_expr {\n+                                vis.filter_map_expr(expr)\n+                            } else {\n+                                None\n+                            }\n+                        });\n+                    }\n+                    $($(AstFragment::$Kind(ast) => vis.$mut_visit_ast(ast),)*)*\n                     $($(AstFragment::$Kind(ast) =>\n-                        AstFragment::$Kind(ast.into_iter()\n-                                              .flat_map(|ast| folder.$fold_ast_elt(ast))\n-                                              .collect()),)*)*\n+                        ast.flat_map_in_place(|ast| vis.$flat_map_ast_elt(ast)),)*)*\n                 }\n             }\n \n@@ -111,14 +117,14 @@ macro_rules! ast_fragments {\n             }\n         }\n \n-        impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n-            fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        impl<'a, 'b> MutVisitor for MacroExpander<'a, 'b> {\n+            fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n                 self.expand_fragment(AstFragment::OptExpr(Some(expr))).make_opt_expr()\n             }\n-            $($(fn $fold_ast(&mut self, ast: $AstTy) -> $AstTy {\n-                self.expand_fragment(AstFragment::$Kind(ast)).$make_ast()\n+            $($(fn $mut_visit_ast(&mut self, ast: &mut $AstTy) {\n+                visit_clobber(ast, |ast| self.expand_fragment(AstFragment::$Kind(ast)).$make_ast());\n             })*)*\n-            $($(fn $fold_ast_elt(&mut self, ast_elt: <$AstTy as IntoIterator>::Item) -> $AstTy {\n+            $($(fn $flat_map_ast_elt(&mut self, ast_elt: <$AstTy as IntoIterator>::Item) -> $AstTy {\n                 self.expand_fragment(AstFragment::$Kind(smallvec![ast_elt])).$make_ast()\n             })*)*\n         }\n@@ -133,23 +139,23 @@ macro_rules! ast_fragments {\n }\n \n ast_fragments! {\n-    Expr(P<ast::Expr>) { \"expression\"; one fn fold_expr; fn visit_expr; fn make_expr; }\n-    Pat(P<ast::Pat>) { \"pattern\"; one fn fold_pat; fn visit_pat; fn make_pat; }\n-    Ty(P<ast::Ty>) { \"type\"; one fn fold_ty; fn visit_ty; fn make_ty; }\n+    Expr(P<ast::Expr>) { \"expression\"; one fn visit_expr; fn visit_expr; fn make_expr; }\n+    Pat(P<ast::Pat>) { \"pattern\"; one fn visit_pat; fn visit_pat; fn make_pat; }\n+    Ty(P<ast::Ty>) { \"type\"; one fn visit_ty; fn visit_ty; fn make_ty; }\n     Stmts(SmallVec<[ast::Stmt; 1]>) {\n-        \"statement\"; many fn fold_stmt; fn visit_stmt; fn make_stmts;\n+        \"statement\"; many fn flat_map_stmt; fn visit_stmt; fn make_stmts;\n     }\n     Items(SmallVec<[P<ast::Item>; 1]>) {\n-        \"item\"; many fn fold_item; fn visit_item; fn make_items;\n+        \"item\"; many fn flat_map_item; fn visit_item; fn make_items;\n     }\n     TraitItems(SmallVec<[ast::TraitItem; 1]>) {\n-        \"trait item\"; many fn fold_trait_item; fn visit_trait_item; fn make_trait_items;\n+        \"trait item\"; many fn flat_map_trait_item; fn visit_trait_item; fn make_trait_items;\n     }\n     ImplItems(SmallVec<[ast::ImplItem; 1]>) {\n-        \"impl item\"; many fn fold_impl_item; fn visit_impl_item; fn make_impl_items;\n+        \"impl item\"; many fn flat_map_impl_item; fn visit_impl_item; fn make_impl_items;\n     }\n     ForeignItems(SmallVec<[ast::ForeignItem; 1]>) {\n-        \"foreign item\"; many fn fold_foreign_item; fn visit_foreign_item; fn make_foreign_items;\n+        \"foreign item\"; many fn flat_map_foreign_item; fn visit_foreign_item; fn make_foreign_items;\n     }\n }\n \n@@ -297,7 +303,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         self.cx.current_expansion.depth = 0;\n \n         // Collect all macro invocations and replace them with placeholders.\n-        let (fragment_with_placeholders, mut invocations)\n+        let (mut fragment_with_placeholders, mut invocations)\n             = self.collect_invocations(input_fragment, &[]);\n \n         // Optimization: if we resolve all imports now,\n@@ -369,10 +375,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         err.emit();\n                     }\n \n-                    let item = self.fully_configure(item)\n-                        .map_attrs(|mut attrs| { attrs.retain(|a| a.path != \"derive\"); attrs });\n-                    let item_with_markers =\n-                        add_derived_markers(&mut self.cx, item.span(), &traits, item.clone());\n+                    let mut item = self.fully_configure(item);\n+                    item.visit_attrs(|attrs| attrs.retain(|a| a.path != \"derive\"));\n+                    let mut item_with_markers = item.clone();\n+                    add_derived_markers(&mut self.cx, item.span(), &traits, &mut item_with_markers);\n                     let derives = derives.entry(invoc.expansion_data.mark).or_default();\n \n                     derives.reserve(traits.len());\n@@ -427,7 +433,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                          expanded_fragment, derives);\n             }\n         }\n-        fragment_with_placeholders.fold_with(&mut placeholder_expander)\n+        fragment_with_placeholders.mut_visit_with(&mut placeholder_expander);\n+        fragment_with_placeholders\n     }\n \n     fn resolve_imports(&mut self) {\n@@ -440,12 +447,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// them with \"placeholders\" - dummy macro invocations with specially crafted `NodeId`s.\n     /// Then call into resolver that builds a skeleton (\"reduced graph\") of the fragment and\n     /// prepares data for resolving paths of macro invocations.\n-    fn collect_invocations(&mut self, fragment: AstFragment, derives: &[Mark])\n+    fn collect_invocations(&mut self, mut fragment: AstFragment, derives: &[Mark])\n                            -> (AstFragment, Vec<Invocation>) {\n         // Resolve `$crate`s in the fragment for pretty-printing.\n         self.cx.resolver.resolve_dollar_crates(&fragment);\n \n-        let (fragment_with_placeholders, invocations) = {\n+        let invocations = {\n             let mut collector = InvocationCollector {\n                 cfg: StripUnconfigured {\n                     sess: self.cx.parse_sess,\n@@ -455,16 +462,16 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 invocations: Vec::new(),\n                 monotonic: self.monotonic,\n             };\n-            (fragment.fold_with(&mut collector), collector.invocations)\n+            fragment.mut_visit_with(&mut collector);\n+            collector.invocations\n         };\n \n         if self.monotonic {\n             self.cx.resolver.visit_ast_fragment_with_placeholders(\n-                self.cx.current_expansion.mark, &fragment_with_placeholders, derives\n-            );\n+                self.cx.current_expansion.mark, &fragment, derives);\n         }\n \n-        (fragment_with_placeholders, invocations)\n+        (fragment, invocations)\n     }\n \n     fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n@@ -476,24 +483,25 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         // we know that fold result vector will contain exactly one element\n         match item {\n             Annotatable::Item(item) => {\n-                Annotatable::Item(cfg.fold_item(item).pop().unwrap())\n+                Annotatable::Item(cfg.flat_map_item(item).pop().unwrap())\n             }\n             Annotatable::TraitItem(item) => {\n-                Annotatable::TraitItem(item.map(|item| cfg.fold_trait_item(item).pop().unwrap()))\n+                Annotatable::TraitItem(\n+                    item.map(|item| cfg.flat_map_trait_item(item).pop().unwrap()))\n             }\n             Annotatable::ImplItem(item) => {\n-                Annotatable::ImplItem(item.map(|item| cfg.fold_impl_item(item).pop().unwrap()))\n+                Annotatable::ImplItem(item.map(|item| cfg.flat_map_impl_item(item).pop().unwrap()))\n             }\n             Annotatable::ForeignItem(item) => {\n                 Annotatable::ForeignItem(\n-                    item.map(|item| cfg.fold_foreign_item(item).pop().unwrap())\n+                    item.map(|item| cfg.flat_map_foreign_item(item).pop().unwrap())\n                 )\n             }\n             Annotatable::Stmt(stmt) => {\n-                Annotatable::Stmt(stmt.map(|stmt| cfg.fold_stmt(stmt).pop().unwrap()))\n+                Annotatable::Stmt(stmt.map(|stmt| cfg.flat_map_stmt(stmt).pop().unwrap()))\n             }\n-            Annotatable::Expr(expr) => {\n-                Annotatable::Expr(cfg.fold_expr(expr))\n+            Annotatable::Expr(mut expr) => {\n+                Annotatable::Expr({ cfg.visit_expr(&mut expr); expr })\n             }\n         }\n     }\n@@ -535,7 +543,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                          invoc: Invocation,\n                          ext: &SyntaxExtension)\n                          -> Option<AstFragment> {\n-        let (attr, item) = match invoc.kind {\n+        let (attr, mut item) = match invoc.kind {\n             InvocationKind::Attr { attr, item, .. } => (attr?, item),\n             _ => unreachable!(),\n         };\n@@ -558,7 +566,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         match *ext {\n             NonMacroAttr { .. } => {\n                 attr::mark_known(&attr);\n-                let item = item.map_attrs(|mut attrs| { attrs.push(attr); attrs });\n+                item.visit_attrs(|attrs| attrs.push(attr));\n                 Some(invoc.fragment_kind.expect_from_annotatables(iter::once(item)))\n             }\n             MultiModifier(ref mac) => {\n@@ -1113,34 +1121,32 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n \n     /// If `item` is an attr invocation, remove and return the macro attribute and derive traits.\n-    fn classify_item<T>(&mut self, mut item: T)\n-                        -> (Option<ast::Attribute>, Vec<Path>, T, /* after_derive */ bool)\n+    fn classify_item<T>(&mut self, item: &mut T)\n+                        -> (Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool)\n         where T: HasAttrs,\n     {\n         let (mut attr, mut traits, mut after_derive) = (None, Vec::new(), false);\n \n-        item = item.map_attrs(|mut attrs| {\n+        item.visit_attrs(|mut attrs| {\n             attr = self.find_attr_invoc(&mut attrs, &mut after_derive);\n             traits = collect_derives(&mut self.cx, &mut attrs);\n-            attrs\n         });\n \n-        (attr, traits, item, after_derive)\n+        (attr, traits, after_derive)\n     }\n \n-    /// Alternative of `classify_item()` that ignores `#[derive]` so invocations fallthrough\n+    /// Alternative to `classify_item()` that ignores `#[derive]` so invocations fallthrough\n     /// to the unused-attributes lint (making it an error on statements and expressions\n     /// is a breaking change)\n-    fn classify_nonitem<T: HasAttrs>(&mut self, mut item: T)\n-                                     -> (Option<ast::Attribute>, T, /* after_derive */ bool) {\n+    fn classify_nonitem<T: HasAttrs>(&mut self, nonitem: &mut T)\n+                                     -> (Option<ast::Attribute>, /* after_derive */ bool) {\n         let (mut attr, mut after_derive) = (None, false);\n \n-        item = item.map_attrs(|mut attrs| {\n+        nonitem.visit_attrs(|mut attrs| {\n             attr = self.find_attr_invoc(&mut attrs, &mut after_derive);\n-            attrs\n         });\n \n-        (attr, item, after_derive)\n+        (attr, after_derive)\n     }\n \n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n@@ -1173,14 +1179,14 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n-    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        let expr = self.cfg.configure_expr(expr);\n-        expr.map(|mut expr| {\n-            expr.node = self.cfg.configure_expr_kind(expr.node);\n+impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n+    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n+        self.cfg.configure_expr(expr);\n+        visit_clobber(expr.deref_mut(), |mut expr| {\n+            self.cfg.configure_expr_kind(&mut expr.node);\n \n             // ignore derives so they remain unused\n-            let (attr, expr, after_derive) = self.classify_nonitem(expr);\n+            let (attr, after_derive) = self.classify_nonitem(&mut expr);\n \n             if attr.is_some() {\n                 // Collect the invoc regardless of whether or not attributes are permitted here\n@@ -1189,7 +1195,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n                 // AstFragmentKind::Expr requires the macro to emit an expression.\n                 return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                         AstFragmentKind::Expr, after_derive)\n+                                          AstFragmentKind::Expr, after_derive)\n                     .make_expr()\n                     .into_inner()\n             }\n@@ -1200,18 +1206,19 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                     .make_expr()\n                     .into_inner()\n             } else {\n-                noop_fold_expr(expr, self)\n+                noop_visit_expr(&mut expr, self);\n+                expr\n             }\n-        })\n+        });\n     }\n \n-    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         let expr = configure!(self, expr);\n         expr.filter_map(|mut expr| {\n-            expr.node = self.cfg.configure_expr_kind(expr.node);\n+            self.cfg.configure_expr_kind(&mut expr.node);\n \n             // Ignore derives so they remain unused.\n-            let (attr, expr, after_derive) = self.classify_nonitem(expr);\n+            let (attr, after_derive) = self.classify_nonitem(&mut expr);\n \n             if attr.is_some() {\n                 attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n@@ -1228,44 +1235,45 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                     .make_opt_expr()\n                     .map(|expr| expr.into_inner())\n             } else {\n-                Some(noop_fold_expr(expr, self))\n+                Some({ noop_visit_expr(&mut expr, self); expr })\n             }\n         })\n     }\n \n-    fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n-        let pat = self.cfg.configure_pat(pat);\n+    fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n+        self.cfg.configure_pat(pat);\n         match pat.node {\n             PatKind::Mac(_) => {}\n-            _ => return noop_fold_pat(pat, self),\n+            _ => return noop_visit_pat(pat, self),\n         }\n \n-        pat.and_then(|pat| match pat.node {\n-            PatKind::Mac(mac) => self.collect_bang(mac, pat.span, AstFragmentKind::Pat).make_pat(),\n-            _ => unreachable!(),\n-        })\n+        visit_clobber(pat, |mut pat| {\n+            match mem::replace(&mut pat.node, PatKind::Wild) {\n+                PatKind::Mac(mac) =>\n+                    self.collect_bang(mac, pat.span, AstFragmentKind::Pat).make_pat(),\n+                _ => unreachable!(),\n+            }\n+        });\n     }\n \n-    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n+    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n         let mut stmt = configure!(self, stmt);\n \n         // we'll expand attributes on expressions separately\n         if !stmt.is_expr() {\n-            let (attr, derives, stmt_, after_derive) = if stmt.is_item() {\n-                self.classify_item(stmt)\n+            let (attr, derives, after_derive) = if stmt.is_item() {\n+                self.classify_item(&mut stmt)\n             } else {\n                 // ignore derives on non-item statements so it falls through\n                 // to the unused-attributes lint\n-                let (attr, stmt, after_derive) = self.classify_nonitem(stmt);\n-                (attr, vec![], stmt, after_derive)\n+                let (attr, after_derive) = self.classify_nonitem(&mut stmt);\n+                (attr, vec![], after_derive)\n             };\n \n             if attr.is_some() || !derives.is_empty() {\n-                return self.collect_attr(attr, derives, Annotatable::Stmt(P(stmt_)),\n+                return self.collect_attr(attr, derives, Annotatable::Stmt(P(stmt)),\n                                          AstFragmentKind::Stmts, after_derive).make_stmts();\n             }\n-\n-            stmt = stmt_;\n         }\n \n         if let StmtKind::Mac(mac) = stmt.node {\n@@ -1287,24 +1295,23 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n         // The placeholder expander gives ids to statements, so we avoid folding the id here.\n         let ast::Stmt { id, node, span } = stmt;\n-        noop_fold_stmt_kind(node, self).into_iter().map(|node| {\n+        noop_flat_map_stmt_kind(node, self).into_iter().map(|node| {\n             ast::Stmt { id, node, span }\n         }).collect()\n \n     }\n \n-    fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n+    fn visit_block(&mut self, block: &mut P<Block>) {\n         let old_directory_ownership = self.cx.current_expansion.directory_ownership;\n         self.cx.current_expansion.directory_ownership = DirectoryOwnership::UnownedViaBlock;\n-        let result = noop_fold_block(block, self);\n+        noop_visit_block(block, self);\n         self.cx.current_expansion.directory_ownership = old_directory_ownership;\n-        result\n     }\n \n-    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n-        let item = configure!(self, item);\n+    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n+        let mut item = configure!(self, item);\n \n-        let (attr, traits, item, after_derive) = self.classify_item(item);\n+        let (attr, traits, after_derive) = self.classify_item(&mut item);\n         if attr.is_some() || !traits.is_empty() {\n             return self.collect_attr(attr, traits, Annotatable::Item(item),\n                                      AstFragmentKind::Items, after_derive).make_items();\n@@ -1326,7 +1333,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             }\n             ast::ItemKind::Mod(ast::Mod { inner, .. }) => {\n                 if item.ident == keywords::Invalid.ident() {\n-                    return noop_fold_item(item, self);\n+                    return noop_flat_map_item(item, self);\n                 }\n \n                 let orig_directory_ownership = self.cx.current_expansion.directory_ownership;\n@@ -1366,20 +1373,20 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n                 let orig_module =\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n-                let result = noop_fold_item(item, self);\n+                let result = noop_flat_map_item(item, self);\n                 self.cx.current_expansion.module = orig_module;\n                 self.cx.current_expansion.directory_ownership = orig_directory_ownership;\n                 result\n             }\n \n-            _ => noop_fold_item(item, self),\n+            _ => noop_flat_map_item(item, self),\n         }\n     }\n \n-    fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n-        let item = configure!(self, item);\n+    fn flat_map_trait_item(&mut self, item: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n+        let mut item = configure!(self, item);\n \n-        let (attr, traits, item, after_derive) = self.classify_item(item);\n+        let (attr, traits, after_derive) = self.classify_item(&mut item);\n         if attr.is_some() || !traits.is_empty() {\n             return self.collect_attr(attr, traits, Annotatable::TraitItem(P(item)),\n                                      AstFragmentKind::TraitItems, after_derive).make_trait_items()\n@@ -1391,14 +1398,14 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 self.check_attributes(&attrs);\n                 self.collect_bang(mac, span, AstFragmentKind::TraitItems).make_trait_items()\n             }\n-            _ => noop_fold_trait_item(item, self),\n+            _ => noop_flat_map_trait_item(item, self),\n         }\n     }\n \n-    fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n-        let item = configure!(self, item);\n+    fn flat_map_impl_item(&mut self, item: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n+        let mut item = configure!(self, item);\n \n-        let (attr, traits, item, after_derive) = self.classify_item(item);\n+        let (attr, traits, after_derive) = self.classify_item(&mut item);\n         if attr.is_some() || !traits.is_empty() {\n             return self.collect_attr(attr, traits, Annotatable::ImplItem(P(item)),\n                                      AstFragmentKind::ImplItems, after_derive).make_impl_items();\n@@ -1410,30 +1417,34 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 self.check_attributes(&attrs);\n                 self.collect_bang(mac, span, AstFragmentKind::ImplItems).make_impl_items()\n             }\n-            _ => noop_fold_impl_item(item, self),\n+            _ => noop_flat_map_impl_item(item, self),\n         }\n     }\n \n-    fn fold_ty(&mut self, ty: P<ast::Ty>) -> P<ast::Ty> {\n-        let ty = match ty.node {\n-            ast::TyKind::Mac(_) => ty.into_inner(),\n-            _ => return noop_fold_ty(ty, self),\n+    fn visit_ty(&mut self, ty: &mut P<ast::Ty>) {\n+        match ty.node {\n+            ast::TyKind::Mac(_) => {}\n+            _ => return noop_visit_ty(ty, self),\n         };\n \n-        match ty.node {\n-            ast::TyKind::Mac(mac) => self.collect_bang(mac, ty.span, AstFragmentKind::Ty).make_ty(),\n-            _ => unreachable!(),\n-        }\n+        visit_clobber(ty, |mut ty| {\n+            match mem::replace(&mut ty.node, ast::TyKind::Err) {\n+                ast::TyKind::Mac(mac) =>\n+                    self.collect_bang(mac, ty.span, AstFragmentKind::Ty).make_ty(),\n+                _ => unreachable!(),\n+            }\n+        });\n     }\n \n-    fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n-        noop_fold_foreign_mod(self.cfg.configure_foreign_mod(foreign_mod), self)\n+    fn visit_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n+        self.cfg.configure_foreign_mod(foreign_mod);\n+        noop_visit_foreign_mod(foreign_mod, self);\n     }\n \n-    fn fold_foreign_item(&mut self, foreign_item: ast::ForeignItem)\n+    fn flat_map_foreign_item(&mut self, mut foreign_item: ast::ForeignItem)\n         -> SmallVec<[ast::ForeignItem; 1]>\n     {\n-        let (attr, traits, foreign_item, after_derive) = self.classify_item(foreign_item);\n+        let (attr, traits, after_derive) = self.classify_item(&mut foreign_item);\n \n         if attr.is_some() || !traits.is_empty() {\n             return self.collect_attr(attr, traits, Annotatable::ForeignItem(P(foreign_item)),\n@@ -1447,38 +1458,41 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 .make_foreign_items();\n         }\n \n-        noop_fold_foreign_item(foreign_item, self)\n+        noop_flat_map_foreign_item(foreign_item, self)\n     }\n \n-    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n+    fn visit_item_kind(&mut self, item: &mut ast::ItemKind) {\n         match item {\n-            ast::ItemKind::MacroDef(..) => item,\n-            _ => noop_fold_item_kind(self.cfg.configure_item_kind(item), self),\n+            ast::ItemKind::MacroDef(..) => {}\n+            _ => {\n+                self.cfg.configure_item_kind(item);\n+                noop_visit_item_kind(item, self);\n+            }\n         }\n     }\n \n-    fn fold_generic_param(&mut self, param: ast::GenericParam) -> ast::GenericParam {\n+    fn visit_generic_param(&mut self, param: &mut ast::GenericParam) {\n         self.cfg.disallow_cfg_on_generic_param(&param);\n-        noop_fold_generic_param(param, self)\n+        noop_visit_generic_param(param, self)\n     }\n \n-    fn fold_attribute(&mut self, at: ast::Attribute) -> ast::Attribute {\n+    fn visit_attribute(&mut self, at: &mut ast::Attribute) {\n         // turn `#[doc(include=\"filename\")]` attributes into `#[doc(include(file=\"filename\",\n         // contents=\"file contents\")]` attributes\n         if !at.check_name(\"doc\") {\n-            return noop_fold_attribute(at, self);\n+            return noop_visit_attribute(at, self);\n         }\n \n         if let Some(list) = at.meta_item_list() {\n             if !list.iter().any(|it| it.check_name(\"include\")) {\n-                return noop_fold_attribute(at, self);\n+                return noop_visit_attribute(at, self);\n             }\n \n             let mut items = vec![];\n \n-            for it in list {\n+            for mut it in list {\n                 if !it.check_name(\"include\") {\n-                    items.push(noop_fold_meta_list_item(it, self));\n+                    items.push({ noop_visit_meta_list_item(&mut it, self); it });\n                     continue;\n                 }\n \n@@ -1487,7 +1501,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                     self.check_attribute(&at);\n                     if self.cx.parse_sess.span_diagnostic.err_count() > err_count {\n                         // avoid loading the file if they haven't enabled the feature\n-                        return noop_fold_attribute(at, self);\n+                        return noop_visit_attribute(at, self);\n                     }\n \n                     let filename = self.cx.root_path.join(file.to_string());\n@@ -1582,20 +1596,18 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n             let meta = attr::mk_list_item(DUMMY_SP, Ident::from_str(\"doc\"), items);\n             match at.style {\n-                ast::AttrStyle::Inner => attr::mk_spanned_attr_inner(at.span, at.id, meta),\n-                ast::AttrStyle::Outer => attr::mk_spanned_attr_outer(at.span, at.id, meta),\n+                ast::AttrStyle::Inner => *at = attr::mk_spanned_attr_inner(at.span, at.id, meta),\n+                ast::AttrStyle::Outer => *at = attr::mk_spanned_attr_outer(at.span, at.id, meta),\n             }\n         } else {\n-            noop_fold_attribute(at, self)\n+            noop_visit_attribute(at, self)\n         }\n     }\n \n-    fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n+    fn visit_id(&mut self, id: &mut ast::NodeId) {\n         if self.monotonic {\n-            assert_eq!(id, ast::DUMMY_NODE_ID);\n-            self.cx.resolver.next_node_id()\n-        } else {\n-            id\n+            debug_assert_eq!(*id, ast::DUMMY_NODE_ID);\n+            *id = self.cx.resolver.next_node_id()\n         }\n     }\n }\n@@ -1660,12 +1672,12 @@ impl<'feat> ExpansionConfig<'feat> {\n #[derive(Debug)]\n pub struct Marker(pub Mark);\n \n-impl Folder for Marker {\n-    fn new_span(&mut self, span: Span) -> Span {\n-        span.apply_mark(self.0)\n+impl MutVisitor for Marker {\n+    fn visit_span(&mut self, span: &mut Span) {\n+        *span = span.apply_mark(self.0)\n     }\n \n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        noop_fold_mac(mac, self)\n+    fn visit_mac(&mut self, mac: &mut ast::Mac) {\n+        noop_visit_mac(mac, self)\n     }\n }"}, {"sha": "23b34c2660bdabec3ef849159bde0064bc1d79ef", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -4,12 +4,11 @@ use ext::base::ExtCtxt;\n use ext::expand::{AstFragment, AstFragmentKind};\n use ext::hygiene::Mark;\n use tokenstream::TokenStream;\n-use fold::*;\n+use mut_visit::*;\n use ptr::P;\n use smallvec::SmallVec;\n use symbol::keywords;\n use ThinVec;\n-use util::move_map::MoveMap;\n \n use rustc_data_structures::fx::FxHashMap;\n \n@@ -85,8 +84,8 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n         }\n     }\n \n-    pub fn add(&mut self, id: ast::NodeId, fragment: AstFragment, derives: Vec<Mark>) {\n-        let mut fragment = fragment.fold_with(self);\n+    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, derives: Vec<Mark>) {\n+        fragment.mut_visit_with(self);\n         if let AstFragment::Items(mut items) = fragment {\n             for derive in derives {\n                 match self.remove(NodeId::placeholder_from_mark(derive)) {\n@@ -104,56 +103,56 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n-    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n+impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n+    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         match item.node {\n             ast::ItemKind::Mac(_) => return self.remove(item.id).make_items(),\n             ast::ItemKind::MacroDef(_) => return smallvec![item],\n             _ => {}\n         }\n \n-        noop_fold_item(item, self)\n+        noop_flat_map_item(item, self)\n     }\n \n-    fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n+    fn flat_map_trait_item(&mut self, item: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n         match item.node {\n             ast::TraitItemKind::Macro(_) => self.remove(item.id).make_trait_items(),\n-            _ => noop_fold_trait_item(item, self),\n+            _ => noop_flat_map_trait_item(item, self),\n         }\n     }\n \n-    fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n+    fn flat_map_impl_item(&mut self, item: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n         match item.node {\n             ast::ImplItemKind::Macro(_) => self.remove(item.id).make_impl_items(),\n-            _ => noop_fold_impl_item(item, self),\n+            _ => noop_flat_map_impl_item(item, self),\n         }\n     }\n \n-    fn fold_foreign_item(&mut self, item: ast::ForeignItem) -> SmallVec<[ast::ForeignItem; 1]> {\n+    fn flat_map_foreign_item(&mut self, item: ast::ForeignItem) -> SmallVec<[ast::ForeignItem; 1]> {\n         match item.node {\n             ast::ForeignItemKind::Macro(_) => self.remove(item.id).make_foreign_items(),\n-            _ => noop_fold_foreign_item(item, self),\n+            _ => noop_flat_map_foreign_item(item, self),\n         }\n     }\n \n-    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n+    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n         match expr.node {\n-            ast::ExprKind::Mac(_) => self.remove(expr.id).make_expr(),\n-            _ => expr.map(|expr| noop_fold_expr(expr, self)),\n+            ast::ExprKind::Mac(_) => *expr = self.remove(expr.id).make_expr(),\n+            _ => noop_visit_expr(expr, self),\n         }\n     }\n \n-    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         match expr.node {\n             ast::ExprKind::Mac(_) => self.remove(expr.id).make_opt_expr(),\n-            _ => noop_fold_opt_expr(expr, self),\n+            _ => noop_filter_map_expr(expr, self),\n         }\n     }\n \n-    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n+    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n         let (style, mut stmts) = match stmt.node {\n             ast::StmtKind::Mac(mac) => (mac.1, self.remove(stmt.id).make_stmts()),\n-            _ => return noop_fold_stmt(stmt, self),\n+            _ => return noop_flat_map_stmt(stmt, self),\n         };\n \n         if style == ast::MacStmtStyle::Semicolon {\n@@ -165,44 +164,40 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n         stmts\n     }\n \n-    fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n+    fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n         match pat.node {\n-            ast::PatKind::Mac(_) => self.remove(pat.id).make_pat(),\n-            _ => noop_fold_pat(pat, self),\n+            ast::PatKind::Mac(_) => *pat = self.remove(pat.id).make_pat(),\n+            _ => noop_visit_pat(pat, self),\n         }\n     }\n \n-    fn fold_ty(&mut self, ty: P<ast::Ty>) -> P<ast::Ty> {\n+    fn visit_ty(&mut self, ty: &mut P<ast::Ty>) {\n         match ty.node {\n-            ast::TyKind::Mac(_) => self.remove(ty.id).make_ty(),\n-            _ => noop_fold_ty(ty, self),\n+            ast::TyKind::Mac(_) => *ty = self.remove(ty.id).make_ty(),\n+            _ => noop_visit_ty(ty, self),\n         }\n     }\n \n-    fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n-        noop_fold_block(block, self).map(|mut block| {\n-            block.stmts = block.stmts.move_map(|mut stmt| {\n-                if self.monotonic {\n-                    assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n-                    stmt.id = self.cx.resolver.next_node_id();\n-                }\n-                stmt\n-            });\n+    fn visit_block(&mut self, block: &mut P<ast::Block>) {\n+        noop_visit_block(block, self);\n \n-            block\n-        })\n+        for stmt in block.stmts.iter_mut() {\n+            if self.monotonic {\n+                assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n+                stmt.id = self.cx.resolver.next_node_id();\n+            }\n+        }\n     }\n \n-    fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod {\n-        let mut module = noop_fold_mod(module, self);\n+    fn visit_mod(&mut self, module: &mut ast::Mod) {\n+        noop_visit_mod(module, self);\n         module.items.retain(|item| match item.node {\n             ast::ItemKind::Mac(_) if !self.cx.ecfg.keep_macs => false, // remove macro definitions\n             _ => true,\n         });\n-        module\n     }\n \n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        mac\n+    fn visit_mac(&mut self, _mac: &mut ast::Mac) {\n+        // Do nothing.\n     }\n }"}, {"sha": "08f34b22328b6cd7a7661ab5a28cbab9326dda0b", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -3,7 +3,7 @@ use ext::base::ExtCtxt;\n use ext::expand::Marker;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use ext::tt::quoted;\n-use fold::noop_fold_tt;\n+use mut_visit::noop_visit_tt;\n use parse::token::{self, Token, NtTT};\n use smallvec::SmallVec;\n use syntax_pos::DUMMY_SP;\n@@ -170,7 +170,9 @@ pub fn transcribe(cx: &ExtCtxt,\n             }\n             quoted::TokenTree::Token(sp, tok) => {\n                 let mut marker = Marker(cx.current_expansion.mark);\n-                result.push(noop_fold_tt(TokenTree::Token(sp, tok), &mut marker).into())\n+                let mut tt = TokenTree::Token(sp, tok);\n+                noop_visit_tt(&mut tt, &mut marker);\n+                result.push(tt.into());\n             }\n             quoted::TokenTree::MetaVarDecl(..) => panic!(\"unexpected `TokenTree::MetaVarDecl\"),\n         }"}, {"sha": "93fedb73d271a02eb9feb6d0c6af8a4bc74ad426", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 960, "deletions": 1042, "changes": 2002, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -1,11 +1,10 @@\n-//! A Folder represents an AST->AST fold; it accepts an AST piece,\n-//! and returns a piece of the same type. So, for instance, macro\n-//! expansion is a Folder that walks over an AST and produces another\n-//! AST.\n+//! A MutVisitor represents an AST modification; it accepts an AST piece and\n+//! and mutates it in place. So, for instance, macro expansion is a MutVisitor\n+//! that walks over an AST and modifies it.\n //!\n-//! Note: using a Folder (other than the MacroExpander Folder) on\n+//! Note: using a MutVisitor (other than the MacroExpander MutVisitor) on\n //! an AST before macro expansion is probably a bad idea. For instance,\n-//! a folder renaming item names in a module will miss all of those\n+//! a MutVisitor renaming item names in a module will miss all of those\n //! that are created by the expansion of a macro.\n \n use ast::*;\n@@ -14,10 +13,11 @@ use source_map::{Spanned, respan};\n use parse::token::{self, Token};\n use ptr::P;\n use smallvec::{Array, SmallVec};\n+use std::ops::DerefMut;\n use symbol::keywords;\n use ThinVec;\n use tokenstream::*;\n-use util::move_map::MoveMap;\n+use util::map_in_place::MapInPlace;\n \n use rustc_data_structures::sync::Lrc;\n \n@@ -32,1308 +32,1225 @@ impl<A: Array> ExpectOne<A> for SmallVec<A> {\n     }\n }\n \n-pub trait Folder : Sized {\n-    // Any additions to this trait should happen in form\n-    // of a call to a public `noop_*` function that only calls\n-    // out to the folder again, not other `noop_*` functions.\n+pub trait MutVisitor: Sized {\n+    // Methods in this trait have one of three forms:\n     //\n-    // This is a necessary API workaround to the problem of not\n-    // being able to call out to the super default method\n-    // in an overridden default method.\n+    //   fn visit_t(&mut self, t: &mut T);                      // common\n+    //   fn flat_map_t(&mut self, t: T) -> SmallVec<[T; 1]>;    // rare\n+    //   fn filter_map_t(&mut self, t: T) -> Option<T>;         // rarest\n+    //\n+    // Any additions to this trait should happen in form of a call to a public\n+    // `noop_*` function that only calls out to the visitor again, not other\n+    // `noop_*` functions. This is a necessary API workaround to the problem of\n+    // not being able to call out to the super default method in an overridden\n+    // default method.\n+    //\n+    // When writing these methods, it is better to use destructuring like this:\n+    //\n+    //   fn visit_abc(&mut self, ABC { a, b, c: _ }: &mut ABC) {\n+    //       visit_a(a);\n+    //       visit_b(b);\n+    //   }\n+    //\n+    // than to use field access like this:\n+    //\n+    //   fn visit_abc(&mut self, abc: &mut ABC) {\n+    //       visit_a(&mut abc.a);\n+    //       visit_b(&mut abc.b);\n+    //       // ignore abc.c\n+    //   }\n+    //\n+    // As well as being more concise, the former is explicit about which fields\n+    // are skipped. Furthermore, if a new field is added, the destructuring\n+    // version will cause a compile error, which is good. In comparison, the\n+    // field access version will continue working and it would be easy to\n+    // forget to add handling for it.\n \n-    fn fold_crate(&mut self, c: Crate) -> Crate {\n-        noop_fold_crate(c, self)\n+    fn visit_crate(&mut self, c: &mut Crate) {\n+        noop_visit_crate(c, self)\n     }\n \n-    fn fold_meta_list_item(&mut self, list_item: NestedMetaItem) -> NestedMetaItem {\n-        noop_fold_meta_list_item(list_item, self)\n+    fn visit_meta_list_item(&mut self, list_item: &mut NestedMetaItem) {\n+        noop_visit_meta_list_item(list_item, self);\n     }\n \n-    fn fold_meta_item(&mut self, meta_item: MetaItem) -> MetaItem {\n-        noop_fold_meta_item(meta_item, self)\n+    fn visit_meta_item(&mut self, meta_item: &mut MetaItem) {\n+        noop_visit_meta_item(meta_item, self);\n     }\n \n-    fn fold_use_tree(&mut self, use_tree: UseTree) -> UseTree {\n-        noop_fold_use_tree(use_tree, self)\n+    fn visit_use_tree(&mut self, use_tree: &mut UseTree) {\n+        noop_visit_use_tree(use_tree, self);\n     }\n \n-    fn fold_foreign_item(&mut self, ni: ForeignItem) -> SmallVec<[ForeignItem; 1]> {\n-        noop_fold_foreign_item(ni, self)\n+    fn flat_map_foreign_item(&mut self, ni: ForeignItem) -> SmallVec<[ForeignItem; 1]> {\n+        noop_flat_map_foreign_item(ni, self)\n     }\n \n-    fn fold_item(&mut self, i: P<Item>) -> SmallVec<[P<Item>; 1]> {\n-        noop_fold_item(i, self)\n+    fn flat_map_item(&mut self, i: P<Item>) -> SmallVec<[P<Item>; 1]> {\n+        noop_flat_map_item(i, self)\n     }\n \n-    fn fold_fn_header(&mut self, header: FnHeader) -> FnHeader {\n-        noop_fold_fn_header(header, self)\n+    fn visit_fn_header(&mut self, header: &mut FnHeader) {\n+        noop_visit_fn_header(header, self);\n     }\n \n-    fn fold_struct_field(&mut self, sf: StructField) -> StructField {\n-        noop_fold_struct_field(sf, self)\n+    fn visit_struct_field(&mut self, sf: &mut StructField) {\n+        noop_visit_struct_field(sf, self);\n     }\n \n-    fn fold_item_kind(&mut self, i: ItemKind) -> ItemKind {\n-        noop_fold_item_kind(i, self)\n+    fn visit_item_kind(&mut self, i: &mut ItemKind) {\n+        noop_visit_item_kind(i, self);\n     }\n \n-    fn fold_trait_item(&mut self, i: TraitItem) -> SmallVec<[TraitItem; 1]> {\n-        noop_fold_trait_item(i, self)\n+    fn flat_map_trait_item(&mut self, i: TraitItem) -> SmallVec<[TraitItem; 1]> {\n+        noop_flat_map_trait_item(i, self)\n     }\n \n-    fn fold_impl_item(&mut self, i: ImplItem) -> SmallVec<[ImplItem; 1]> {\n-        noop_fold_impl_item(i, self)\n+    fn flat_map_impl_item(&mut self, i: ImplItem) -> SmallVec<[ImplItem; 1]> {\n+        noop_flat_map_impl_item(i, self)\n     }\n \n-    fn fold_fn_decl(&mut self, d: P<FnDecl>) -> P<FnDecl> {\n-        noop_fold_fn_decl(d, self)\n+    fn visit_fn_decl(&mut self, d: &mut P<FnDecl>) {\n+        noop_visit_fn_decl(d, self);\n     }\n \n-    fn fold_asyncness(&mut self, a: IsAsync) -> IsAsync {\n-        noop_fold_asyncness(a, self)\n+    fn visit_asyncness(&mut self, a: &mut IsAsync) {\n+        noop_visit_asyncness(a, self);\n     }\n \n-    fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n-        noop_fold_block(b, self)\n+    fn visit_block(&mut self, b: &mut P<Block>) {\n+        noop_visit_block(b, self);\n     }\n \n-    fn fold_stmt(&mut self, s: Stmt) -> SmallVec<[Stmt; 1]> {\n-        noop_fold_stmt(s, self)\n+    fn flat_map_stmt(&mut self, s: Stmt) -> SmallVec<[Stmt; 1]> {\n+        noop_flat_map_stmt(s, self)\n     }\n \n-    fn fold_arm(&mut self, a: Arm) -> Arm {\n-        noop_fold_arm(a, self)\n+    fn visit_arm(&mut self, a: &mut Arm) {\n+        noop_visit_arm(a, self);\n     }\n \n-    fn fold_guard(&mut self, g: Guard) -> Guard {\n-        noop_fold_guard(g, self)\n+    fn visit_guard(&mut self, g: &mut Guard) {\n+        noop_visit_guard(g, self);\n     }\n \n-    fn fold_pat(&mut self, p: P<Pat>) -> P<Pat> {\n-        noop_fold_pat(p, self)\n+    fn visit_pat(&mut self, p: &mut P<Pat>) {\n+        noop_visit_pat(p, self);\n     }\n \n-    fn fold_anon_const(&mut self, c: AnonConst) -> AnonConst {\n-        noop_fold_anon_const(c, self)\n+    fn visit_anon_const(&mut self, c: &mut AnonConst) {\n+        noop_visit_anon_const(c, self);\n     }\n \n-    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n-        e.map(|e| noop_fold_expr(e, self))\n+    fn visit_expr(&mut self, e: &mut P<Expr>) {\n+        noop_visit_expr(e, self);\n     }\n \n-    fn fold_opt_expr(&mut self, e: P<Expr>) -> Option<P<Expr>> {\n-        noop_fold_opt_expr(e, self)\n+    fn filter_map_expr(&mut self, e: P<Expr>) -> Option<P<Expr>> {\n+        noop_filter_map_expr(e, self)\n     }\n \n-    fn fold_generic_arg(&mut self, arg: GenericArg) -> GenericArg {\n-        match arg {\n-            GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.fold_lifetime(lt)),\n-            GenericArg::Type(ty) => GenericArg::Type(self.fold_ty(ty)),\n-        }\n+    fn visit_generic_arg(&mut self, arg: &mut GenericArg) {\n+        noop_visit_generic_arg(arg, self);\n     }\n \n-    fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n-        noop_fold_ty(t, self)\n+    fn visit_ty(&mut self, t: &mut P<Ty>) {\n+        noop_visit_ty(t, self);\n     }\n \n-    fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n-        noop_fold_lifetime(l, self)\n+    fn visit_lifetime(&mut self, l: &mut Lifetime) {\n+        noop_visit_lifetime(l, self);\n     }\n \n-    fn fold_ty_binding(&mut self, t: TypeBinding) -> TypeBinding {\n-        noop_fold_ty_binding(t, self)\n+    fn visit_ty_binding(&mut self, t: &mut TypeBinding) {\n+        noop_visit_ty_binding(t, self);\n     }\n \n-    fn fold_mod(&mut self, m: Mod) -> Mod {\n-        noop_fold_mod(m, self)\n+    fn visit_mod(&mut self, m: &mut Mod) {\n+        noop_visit_mod(m, self);\n     }\n \n-    fn fold_foreign_mod(&mut self, nm: ForeignMod) -> ForeignMod {\n-        noop_fold_foreign_mod(nm, self)\n+    fn visit_foreign_mod(&mut self, nm: &mut ForeignMod) {\n+        noop_visit_foreign_mod(nm, self);\n     }\n \n-    fn fold_variant(&mut self, v: Variant) -> Variant {\n-        noop_fold_variant(v, self)\n+    fn visit_variant(&mut self, v: &mut Variant) {\n+        noop_visit_variant(v, self);\n     }\n \n-    fn fold_ident(&mut self, i: Ident) -> Ident {\n-        noop_fold_ident(i, self)\n+    fn visit_ident(&mut self, i: &mut Ident) {\n+        noop_visit_ident(i, self);\n     }\n \n-    fn fold_path(&mut self, p: Path) -> Path {\n-        noop_fold_path(p, self)\n+    fn visit_path(&mut self, p: &mut Path) {\n+        noop_visit_path(p, self);\n     }\n \n-    fn fold_qself(&mut self, qs: Option<QSelf>) -> Option<QSelf> {\n-        noop_fold_qself(qs, self)\n+    fn visit_qself(&mut self, qs: &mut Option<QSelf>) {\n+        noop_visit_qself(qs, self);\n     }\n \n-    fn fold_generic_args(&mut self, p: GenericArgs) -> GenericArgs {\n-        noop_fold_generic_args(p, self)\n+    fn visit_generic_args(&mut self, p: &mut GenericArgs) {\n+        noop_visit_generic_args(p, self);\n     }\n \n-    fn fold_angle_bracketed_parameter_data(&mut self, p: AngleBracketedArgs)\n-                                           -> AngleBracketedArgs\n-    {\n-        noop_fold_angle_bracketed_parameter_data(p, self)\n+    fn visit_angle_bracketed_parameter_data(&mut self, p: &mut AngleBracketedArgs) {\n+        noop_visit_angle_bracketed_parameter_data(p, self);\n     }\n \n-    fn fold_parenthesized_parameter_data(&mut self, p: ParenthesizedArgs)\n-                                         -> ParenthesizedArgs\n-    {\n-        noop_fold_parenthesized_parameter_data(p, self)\n+    fn visit_parenthesized_parameter_data(&mut self, p: &mut ParenthesizedArgs) {\n+        noop_visit_parenthesized_parameter_data(p, self);\n     }\n \n-    fn fold_local(&mut self, l: P<Local>) -> P<Local> {\n-        noop_fold_local(l, self)\n+    fn visit_local(&mut self, l: &mut P<Local>) {\n+        noop_visit_local(l, self);\n     }\n \n-    fn fold_mac(&mut self, _mac: Mac) -> Mac {\n-        panic!(\"fold_mac disabled by default\");\n-        // N.B., see note about macros above.\n-        // if you really want a folder that\n-        // works on macros, use this\n-        // definition in your trait impl:\n-        // fold::noop_fold_mac(_mac, self)\n+    fn visit_mac(&mut self, _mac: &mut Mac) {\n+        panic!(\"visit_mac disabled by default\");\n+        // N.B., see note about macros above. If you really want a visitor that\n+        // works on macros, use this definition in your trait impl:\n+        //   mut_visit::noop_visit_mac(_mac, self);\n     }\n \n-    fn fold_macro_def(&mut self, def: MacroDef) -> MacroDef {\n-        noop_fold_macro_def(def, self)\n+    fn visit_macro_def(&mut self, def: &mut MacroDef) {\n+        noop_visit_macro_def(def, self);\n     }\n \n-    fn fold_label(&mut self, label: Label) -> Label {\n-        noop_fold_label(label, self)\n+    fn visit_label(&mut self, label: &mut Label) {\n+        noop_visit_label(label, self);\n     }\n \n-    fn fold_attribute(&mut self, at: Attribute) -> Attribute {\n-        noop_fold_attribute(at, self)\n+    fn visit_attribute(&mut self, at: &mut Attribute) {\n+        noop_visit_attribute(at, self);\n     }\n \n-    fn fold_arg(&mut self, a: Arg) -> Arg {\n-        noop_fold_arg(a, self)\n+    fn visit_arg(&mut self, a: &mut Arg) {\n+        noop_visit_arg(a, self);\n     }\n \n-    fn fold_generics(&mut self, generics: Generics) -> Generics {\n-        noop_fold_generics(generics, self)\n+    fn visit_generics(&mut self, generics: &mut Generics) {\n+        noop_visit_generics(generics, self);\n     }\n \n-    fn fold_trait_ref(&mut self, p: TraitRef) -> TraitRef {\n-        noop_fold_trait_ref(p, self)\n+    fn visit_trait_ref(&mut self, tr: &mut TraitRef) {\n+        noop_visit_trait_ref(tr, self);\n     }\n \n-    fn fold_poly_trait_ref(&mut self, p: PolyTraitRef) -> PolyTraitRef {\n-        noop_fold_poly_trait_ref(p, self)\n+    fn visit_poly_trait_ref(&mut self, p: &mut PolyTraitRef) {\n+        noop_visit_poly_trait_ref(p, self);\n     }\n \n-    fn fold_variant_data(&mut self, vdata: VariantData) -> VariantData {\n-        noop_fold_variant_data(vdata, self)\n+    fn visit_variant_data(&mut self, vdata: &mut VariantData) {\n+        noop_visit_variant_data(vdata, self);\n     }\n \n-    fn fold_generic_param(&mut self, param: GenericParam) -> GenericParam {\n-        noop_fold_generic_param(param, self)\n+    fn visit_generic_param(&mut self, param: &mut GenericParam) {\n+        noop_visit_generic_param(param, self);\n     }\n \n-    fn fold_generic_params(&mut self, params: Vec<GenericParam>) -> Vec<GenericParam> {\n-        noop_fold_generic_params(params, self)\n+    fn visit_generic_params(&mut self, params: &mut Vec<GenericParam>) {\n+        noop_visit_generic_params(params, self);\n     }\n \n-    fn fold_tt(&mut self, tt: TokenTree) -> TokenTree {\n-        noop_fold_tt(tt, self)\n+    fn visit_tt(&mut self, tt: &mut TokenTree) {\n+        noop_visit_tt(tt, self);\n     }\n \n-    fn fold_tts(&mut self, tts: TokenStream) -> TokenStream {\n-        noop_fold_tts(tts, self)\n+    fn visit_tts(&mut self, tts: &mut TokenStream) {\n+        noop_visit_tts(tts, self);\n     }\n \n-    fn fold_token(&mut self, t: token::Token) -> token::Token {\n-        noop_fold_token(t, self)\n+    fn visit_token(&mut self, t: &mut Token) {\n+        noop_visit_token(t, self);\n     }\n \n-    fn fold_interpolated(&mut self, nt: token::Nonterminal) -> token::Nonterminal {\n-        noop_fold_interpolated(nt, self)\n+    fn visit_interpolated(&mut self, nt: &mut token::Nonterminal) {\n+        noop_visit_interpolated(nt, self);\n     }\n \n-    fn fold_param_bound(&mut self, tpb: GenericBound) -> GenericBound {\n-        noop_fold_param_bound(tpb, self)\n+    fn visit_param_bound(&mut self, tpb: &mut GenericBound) {\n+        noop_visit_param_bound(tpb, self);\n     }\n \n-    fn fold_mt(&mut self, mt: MutTy) -> MutTy {\n-        noop_fold_mt(mt, self)\n+    fn visit_mt(&mut self, mt: &mut MutTy) {\n+        noop_visit_mt(mt, self);\n     }\n \n-    fn fold_field(&mut self, field: Field) -> Field {\n-        noop_fold_field(field, self)\n+    fn visit_field(&mut self, field: &mut Field) {\n+        noop_visit_field(field, self);\n     }\n \n-    fn fold_where_clause(&mut self, where_clause: WhereClause)\n-                         -> WhereClause {\n-        noop_fold_where_clause(where_clause, self)\n+    fn visit_where_clause(&mut self, where_clause: &mut WhereClause) {\n+        noop_visit_where_clause(where_clause, self);\n     }\n \n-    fn fold_where_predicate(&mut self, where_predicate: WherePredicate)\n-                            -> WherePredicate {\n-        noop_fold_where_predicate(where_predicate, self)\n+    fn visit_where_predicate(&mut self, where_predicate: &mut WherePredicate) {\n+        noop_visit_where_predicate(where_predicate, self);\n     }\n \n-    fn fold_vis(&mut self, vis: Visibility) -> Visibility {\n-        noop_fold_vis(vis, self)\n+    fn visit_vis(&mut self, vis: &mut Visibility) {\n+        noop_visit_vis(vis, self);\n     }\n \n-    fn new_id(&mut self, i: NodeId) -> NodeId {\n-        i\n+    fn visit_id(&mut self, _id: &mut NodeId) {\n+        // Do nothing.\n     }\n \n-    fn new_span(&mut self, sp: Span) -> Span {\n-        sp\n+    fn visit_span(&mut self, _sp: &mut Span) {\n+        // Do nothing.\n     }\n }\n \n-// No `noop_` prefix because there isn't a corresponding method in `Folder`.\n-fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribute> {\n-    attrs.move_map(|x| fld.fold_attribute(x))\n+/// Use a map-style function (`FnOnce(T) -> T`) to overwrite a `&mut T`. Useful\n+/// when using a `flat_map_*` or `filter_map_*` method within a `visit_`\n+/// method.\n+//\n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_clobber<T, F>(t: &mut T, f: F) where F: FnOnce(T) -> T {\n+    unsafe { std::ptr::write(t, f(std::ptr::read(t))); }\n }\n \n-// No `noop_` prefix because there isn't a corresponding method in `Folder`.\n-fn fold_thin_attrs<T: Folder>(attrs: ThinVec<Attribute>, fld: &mut T) -> ThinVec<Attribute> {\n-    fold_attrs(attrs.into(), fld).into()\n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+#[inline]\n+pub fn visit_vec<T, F>(elems: &mut Vec<T>, mut visit_elem: F) where F: FnMut(&mut T) {\n+    for elem in elems {\n+        visit_elem(elem);\n+    }\n }\n \n-// No `noop_` prefix because there isn't a corresponding method in `Folder`.\n-fn fold_exprs<T: Folder>(es: Vec<P<Expr>>, fld: &mut T) -> Vec<P<Expr>> {\n-    es.move_flat_map(|e| fld.fold_opt_expr(e))\n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+#[inline]\n+pub fn visit_opt<T, F>(opt: &mut Option<T>, mut visit_elem: F) where F: FnMut(&mut T) {\n+    if let Some(elem) = opt {\n+        visit_elem(elem);\n+    }\n }\n \n-// No `noop_` prefix because there isn't a corresponding method in `Folder`.\n-fn fold_bounds<T: Folder>(bounds: GenericBounds, folder: &mut T) -> GenericBounds {\n-    bounds.move_map(|bound| folder.fold_param_bound(bound))\n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_attrs<T: MutVisitor>(attrs: &mut Vec<Attribute>, vis: &mut T) {\n+    visit_vec(attrs, |attr| vis.visit_attribute(attr));\n }\n \n-// No `noop_` prefix because there isn't a corresponding method in `Folder`.\n-fn fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig {\n-    MethodSig {\n-        header: folder.fold_fn_header(sig.header),\n-        decl: folder.fold_fn_decl(sig.decl)\n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_thin_attrs<T: MutVisitor>(attrs: &mut ThinVec<Attribute>, vis: &mut T) {\n+    for attr in attrs.iter_mut() {\n+        vis.visit_attribute(attr);\n     }\n }\n \n-pub fn noop_fold_use_tree<T: Folder>(use_tree: UseTree, fld: &mut T) -> UseTree {\n-    UseTree {\n-        span: fld.new_span(use_tree.span),\n-        prefix: fld.fold_path(use_tree.prefix),\n-        kind: match use_tree.kind {\n-            UseTreeKind::Simple(rename, id1, id2) =>\n-                UseTreeKind::Simple(rename.map(|ident| fld.fold_ident(ident)),\n-                                    fld.new_id(id1), fld.new_id(id2)),\n-            UseTreeKind::Glob => UseTreeKind::Glob,\n-            UseTreeKind::Nested(items) => UseTreeKind::Nested(items.move_map(|(tree, id)| {\n-                (fld.fold_use_tree(tree), fld.new_id(id))\n-            })),\n-        },\n-    }\n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_exprs<T: MutVisitor>(exprs: &mut Vec<P<Expr>>, vis: &mut T) {\n+    exprs.flat_map_in_place(|expr| vis.filter_map_expr(expr))\n }\n \n-pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm,\n-    fld: &mut T) -> Arm {\n-    Arm {\n-        attrs: fold_attrs(attrs, fld),\n-        pats: pats.move_map(|x| fld.fold_pat(x)),\n-        guard: guard.map(|x| fld.fold_guard(x)),\n-        body: fld.fold_expr(body),\n-    }\n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_bounds<T: MutVisitor>(bounds: &mut GenericBounds, vis: &mut T) {\n+    visit_vec(bounds, |bound| vis.visit_param_bound(bound));\n }\n \n-pub fn noop_fold_guard<T: Folder>(g: Guard, fld: &mut T) -> Guard {\n-    match g {\n-        Guard::If(e) => Guard::If(fld.fold_expr(e)),\n-    }\n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_method_sig<T: MutVisitor>(MethodSig { header, decl }: &mut MethodSig, vis: &mut T) {\n+    vis.visit_fn_header(header);\n+    vis.visit_fn_decl(decl);\n }\n \n-pub fn noop_fold_ty_binding<T: Folder>(b: TypeBinding, fld: &mut T) -> TypeBinding {\n-    TypeBinding {\n-        id: fld.new_id(b.id),\n-        ident: fld.fold_ident(b.ident),\n-        ty: fld.fold_ty(b.ty),\n-        span: fld.new_span(b.span),\n+pub fn noop_visit_use_tree<T: MutVisitor>(use_tree: &mut UseTree, vis: &mut T) {\n+    let UseTree { prefix, kind, span } = use_tree;\n+    vis.visit_path(prefix);\n+    match kind {\n+        UseTreeKind::Simple(rename, id1, id2) => {\n+            visit_opt(rename, |rename| vis.visit_ident(rename));\n+            vis.visit_id(id1);\n+            vis.visit_id(id2);\n+        }\n+        UseTreeKind::Nested(items) => {\n+            for (tree, id) in items {\n+                vis.visit_use_tree(tree);\n+                vis.visit_id(id);\n+            }\n+        }\n+        UseTreeKind::Glob => {}\n     }\n+    vis.visit_span(span);\n }\n \n-pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n-    t.map(|Ty {id, node, span}| Ty {\n-        id: fld.new_id(id),\n-        node: match node {\n-            TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err => node,\n-            TyKind::Slice(ty) => TyKind::Slice(fld.fold_ty(ty)),\n-            TyKind::Ptr(mt) => TyKind::Ptr(fld.fold_mt(mt)),\n-            TyKind::Rptr(region, mt) => {\n-                TyKind::Rptr(region.map(|lt| noop_fold_lifetime(lt, fld)), fld.fold_mt(mt))\n-            }\n-            TyKind::BareFn(f) => {\n-                TyKind::BareFn(f.map(|BareFnTy {generic_params, unsafety, abi, decl}| BareFnTy {\n-                    generic_params: fld.fold_generic_params(generic_params),\n-                    unsafety,\n-                    abi,\n-                    decl: fld.fold_fn_decl(decl)\n-                }))\n-            }\n-            TyKind::Never => node,\n-            TyKind::Tup(tys) => TyKind::Tup(tys.move_map(|ty| fld.fold_ty(ty))),\n-            TyKind::Paren(ty) => TyKind::Paren(fld.fold_ty(ty)),\n-            TyKind::Path(qself, path) => {\n-                TyKind::Path(fld.fold_qself(qself), fld.fold_path(path))\n-            }\n-            TyKind::Array(ty, length) => {\n-                TyKind::Array(fld.fold_ty(ty), fld.fold_anon_const(length))\n-            }\n-            TyKind::Typeof(expr) => {\n-                TyKind::Typeof(fld.fold_anon_const(expr))\n-            }\n-            TyKind::TraitObject(bounds, syntax) => {\n-                TyKind::TraitObject(bounds.move_map(|b| fld.fold_param_bound(b)), syntax)\n-            }\n-            TyKind::ImplTrait(id, bounds) => {\n-                TyKind::ImplTrait(fld.new_id(id), bounds.move_map(|b| fld.fold_param_bound(b)))\n-            }\n-            TyKind::Mac(mac) => {\n-                TyKind::Mac(fld.fold_mac(mac))\n-            }\n-        },\n-        span: fld.new_span(span)\n-    })\n+pub fn noop_visit_arm<T: MutVisitor>(Arm { attrs, pats, guard, body }: &mut Arm, vis: &mut T) {\n+    visit_attrs(attrs, vis);\n+    visit_vec(pats, |pat| vis.visit_pat(pat));\n+    visit_opt(guard, |guard| vis.visit_guard(guard));\n+    vis.visit_expr(body);\n }\n \n-pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, items}: ForeignMod,\n-                                        fld: &mut T) -> ForeignMod {\n-    ForeignMod {\n-        abi,\n-        items: items.move_flat_map(|x| fld.fold_foreign_item(x)),\n+pub fn noop_visit_guard<T: MutVisitor>(g: &mut Guard, vis: &mut T) {\n+    match g {\n+        Guard::If(e) => vis.visit_expr(e),\n     }\n }\n \n-pub fn noop_fold_variant<T: Folder>(v: Variant, fld: &mut T) -> Variant {\n-    Spanned {\n-        node: Variant_ {\n-            ident: fld.fold_ident(v.node.ident),\n-            attrs: fold_attrs(v.node.attrs, fld),\n-            data: fld.fold_variant_data(v.node.data),\n-            disr_expr: v.node.disr_expr.map(|e| fld.fold_anon_const(e)),\n-        },\n-        span: fld.new_span(v.span),\n+pub fn noop_visit_ty_binding<T: MutVisitor>(TypeBinding { id, ident, ty, span }: &mut TypeBinding,\n+                                            vis: &mut T) {\n+    vis.visit_id(id);\n+    vis.visit_ident(ident);\n+    vis.visit_ty(ty);\n+    vis.visit_span(span);\n+}\n+\n+pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n+    let Ty { id, node, span } = ty.deref_mut();\n+    vis.visit_id(id);\n+    match node {\n+        TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err | TyKind::Never => {}\n+        TyKind::Slice(ty) => vis.visit_ty(ty),\n+        TyKind::Ptr(mt) => vis.visit_mt(mt),\n+        TyKind::Rptr(lt, mt) => {\n+            visit_opt(lt, |lt| noop_visit_lifetime(lt, vis));\n+            vis.visit_mt(mt);\n+        }\n+        TyKind::BareFn(bft) => {\n+            let BareFnTy { unsafety: _, abi: _, generic_params, decl } = bft.deref_mut();\n+            vis.visit_generic_params(generic_params);\n+            vis.visit_fn_decl(decl);\n+        }\n+        TyKind::Tup(tys) => visit_vec(tys, |ty| vis.visit_ty(ty)),\n+        TyKind::Paren(ty) => vis.visit_ty(ty),\n+        TyKind::Path(qself, path) => {\n+            vis.visit_qself(qself);\n+            vis.visit_path(path);\n+        }\n+        TyKind::Array(ty, length) => {\n+            vis.visit_ty(ty);\n+            vis.visit_anon_const(length);\n+        }\n+        TyKind::Typeof(expr) => vis.visit_anon_const(expr),\n+        TyKind::TraitObject(bounds, _syntax) =>\n+            visit_vec(bounds, |bound| vis.visit_param_bound(bound)),\n+        TyKind::ImplTrait(id, bounds) => {\n+            vis.visit_id(id);\n+            visit_vec(bounds, |bound| vis.visit_param_bound(bound));\n+        }\n+        TyKind::Mac(mac) => vis.visit_mac(mac),\n     }\n+    vis.visit_span(span);\n+}\n+\n+pub fn noop_visit_foreign_mod<T: MutVisitor>(foreign_mod: &mut ForeignMod, vis: &mut T) {\n+    let ForeignMod { abi: _, items} = foreign_mod;\n+    items.flat_map_in_place(|item| vis.flat_map_foreign_item(item));\n+}\n+\n+pub fn noop_visit_variant<T: MutVisitor>(variant: &mut Variant, vis: &mut T) {\n+    let Spanned { node: Variant_ { ident, attrs, data, disr_expr }, span } = variant;\n+    vis.visit_ident(ident);\n+    visit_attrs(attrs, vis);\n+    vis.visit_variant_data(data);\n+    visit_opt(disr_expr, |disr_expr| vis.visit_anon_const(disr_expr));\n+    vis.visit_span(span);\n }\n \n-pub fn noop_fold_ident<T: Folder>(ident: Ident, fld: &mut T) -> Ident {\n-    Ident::new(ident.name, fld.new_span(ident.span))\n+pub fn noop_visit_ident<T: MutVisitor>(Ident { name: _, span }: &mut Ident, vis: &mut T) {\n+    vis.visit_span(span);\n }\n \n-pub fn noop_fold_path<T: Folder>(Path { segments, span }: Path, fld: &mut T) -> Path {\n-    Path {\n-        segments: segments.move_map(|PathSegment { ident, id, args }| PathSegment {\n-            ident: fld.fold_ident(ident),\n-            id: fld.new_id(id),\n-            args: args.map(|args| args.map(|args| fld.fold_generic_args(args))),\n-        }),\n-        span: fld.new_span(span)\n+pub fn noop_visit_path<T: MutVisitor>(Path { segments, span }: &mut Path, vis: &mut T) {\n+    vis.visit_span(span);\n+    for PathSegment { ident, id, args } in segments {\n+        vis.visit_ident(ident);\n+        vis.visit_id(id);\n+        visit_opt(args, |args| vis.visit_generic_args(args));\n     }\n }\n \n-pub fn noop_fold_qself<T: Folder>(qself: Option<QSelf>, fld: &mut T) -> Option<QSelf> {\n-    qself.map(|QSelf { ty, path_span, position }| {\n-        QSelf {\n-            ty: fld.fold_ty(ty),\n-            path_span: fld.new_span(path_span),\n-            position,\n-        }\n+pub fn noop_visit_qself<T: MutVisitor>(qself: &mut Option<QSelf>, vis: &mut T) {\n+    visit_opt(qself, |QSelf { ty, path_span, position: _ }| {\n+        vis.visit_ty(ty);\n+        vis.visit_span(path_span);\n     })\n }\n \n-pub fn noop_fold_generic_args<T: Folder>(generic_args: GenericArgs, fld: &mut T) -> GenericArgs\n-{\n+pub fn noop_visit_generic_args<T: MutVisitor>(generic_args: &mut GenericArgs, vis: &mut T) {\n     match generic_args {\n-        GenericArgs::AngleBracketed(data) => {\n-            GenericArgs::AngleBracketed(fld.fold_angle_bracketed_parameter_data(data))\n-        }\n-        GenericArgs::Parenthesized(data) => {\n-            GenericArgs::Parenthesized(fld.fold_parenthesized_parameter_data(data))\n-        }\n+        GenericArgs::AngleBracketed(data) => vis.visit_angle_bracketed_parameter_data(data),\n+        GenericArgs::Parenthesized(data) => vis.visit_parenthesized_parameter_data(data),\n     }\n }\n \n-pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedArgs,\n-                                                           fld: &mut T)\n-                                                           -> AngleBracketedArgs\n-{\n-    let AngleBracketedArgs { args, bindings, span } = data;\n-    AngleBracketedArgs {\n-        args: args.move_map(|arg| fld.fold_generic_arg(arg)),\n-        bindings: bindings.move_map(|b| fld.fold_ty_binding(b)),\n-        span: fld.new_span(span)\n+pub fn noop_visit_generic_arg<T: MutVisitor>(arg: &mut GenericArg, vis: &mut T) {\n+    match arg {\n+        GenericArg::Lifetime(lt) => vis.visit_lifetime(lt),\n+        GenericArg::Type(ty) => vis.visit_ty(ty),\n     }\n }\n \n-pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedArgs,\n-                                                         fld: &mut T)\n-                                                         -> ParenthesizedArgs\n-{\n-    let ParenthesizedArgs { inputs, output, span } = data;\n-    ParenthesizedArgs {\n-        inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n-        output: output.map(|ty| fld.fold_ty(ty)),\n-        span: fld.new_span(span)\n-    }\n-}\n-\n-pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n-    l.map(|Local {id, pat, ty, init, span, attrs}| Local {\n-        id: fld.new_id(id),\n-        pat: fld.fold_pat(pat),\n-        ty: ty.map(|t| fld.fold_ty(t)),\n-        init: init.map(|e| fld.fold_expr(e)),\n-        span: fld.new_span(span),\n-        attrs: fold_attrs(attrs.into(), fld).into(),\n-    })\n+pub fn noop_visit_angle_bracketed_parameter_data<T: MutVisitor>(data: &mut AngleBracketedArgs,\n+                                                                vis: &mut T) {\n+    let AngleBracketedArgs { args, bindings, span } = data;\n+    visit_vec(args, |arg| vis.visit_generic_arg(arg));\n+    visit_vec(bindings, |binding| vis.visit_ty_binding(binding));\n+    vis.visit_span(span);\n }\n \n-pub fn noop_fold_attribute<T: Folder>(attr: Attribute, fld: &mut T) -> Attribute {\n-    Attribute {\n-        id: attr.id,\n-        style: attr.style,\n-        path: fld.fold_path(attr.path),\n-        tokens: fld.fold_tts(attr.tokens),\n-        is_sugared_doc: attr.is_sugared_doc,\n-        span: fld.new_span(attr.span),\n-    }\n+pub fn noop_visit_parenthesized_parameter_data<T: MutVisitor>(args: &mut ParenthesizedArgs,\n+                                                              vis: &mut T) {\n+    let ParenthesizedArgs { inputs, output, span } = args;\n+    visit_vec(inputs, |input| vis.visit_ty(input));\n+    visit_opt(output, |output| vis.visit_ty(output));\n+    vis.visit_span(span);\n }\n \n-pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n-    Spanned {\n-        node: Mac_ {\n-            tts: fld.fold_tts(node.stream()).into(),\n-            path: fld.fold_path(node.path),\n-            delim: node.delim,\n-        },\n-        span: fld.new_span(span)\n-    }\n+pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n+    let Local { id, pat, ty, init, span, attrs } = local.deref_mut();\n+    vis.visit_id(id);\n+    vis.visit_pat(pat);\n+    visit_opt(ty, |ty| vis.visit_ty(ty));\n+    visit_opt(init, |init| vis.visit_expr(init));\n+    vis.visit_span(span);\n+    visit_thin_attrs(attrs, vis);\n }\n \n-pub fn noop_fold_macro_def<T: Folder>(def: MacroDef, fld: &mut T) -> MacroDef {\n-    MacroDef {\n-        tokens: fld.fold_tts(def.tokens.into()).into(),\n-        legacy: def.legacy,\n-    }\n+pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n+    let Attribute { id: _, style: _, path, tokens, is_sugared_doc: _, span } = attr;\n+    vis.visit_path(path);\n+    vis.visit_tts(tokens);\n+    vis.visit_span(span);\n }\n \n-pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)\n-    -> NestedMetaItem {\n-    Spanned {\n-        node: match li.node {\n-            NestedMetaItemKind::MetaItem(mi) =>  {\n-                NestedMetaItemKind::MetaItem(fld.fold_meta_item(mi))\n-            },\n-            NestedMetaItemKind::Literal(lit) => NestedMetaItemKind::Literal(lit)\n-        },\n-        span: fld.new_span(li.span)\n-    }\n+pub fn noop_visit_mac<T: MutVisitor>(Spanned { node, span }: &mut Mac, vis: &mut T) {\n+    let Mac_ { path, delim: _, tts } = node;\n+    vis.visit_path(path);\n+    vis.visit_tts(tts);\n+    vis.visit_span(span);\n }\n \n-pub fn noop_fold_meta_item<T: Folder>(mi: MetaItem, fld: &mut T) -> MetaItem {\n-    MetaItem {\n-        ident: mi.ident,\n-        node: match mi.node {\n-            MetaItemKind::Word => MetaItemKind::Word,\n-            MetaItemKind::List(mis) => {\n-                MetaItemKind::List(mis.move_map(|e| fld.fold_meta_list_item(e)))\n-            },\n-            MetaItemKind::NameValue(s) => MetaItemKind::NameValue(s),\n-        },\n-        span: fld.new_span(mi.span)\n+pub fn noop_visit_macro_def<T: MutVisitor>(macro_def: &mut MacroDef, vis: &mut T) {\n+    let MacroDef { tokens, legacy: _ } = macro_def;\n+    vis.visit_tts(tokens);\n+}\n+\n+pub fn noop_visit_meta_list_item<T: MutVisitor>(li: &mut NestedMetaItem, vis: &mut T) {\n+    let Spanned { node, span } = li;\n+    match node {\n+        NestedMetaItemKind::MetaItem(mi) => vis.visit_meta_item(mi),\n+        NestedMetaItemKind::Literal(_lit) => {}\n     }\n+    vis.visit_span(span);\n }\n \n-pub fn noop_fold_arg<T: Folder>(Arg {id, pat, ty}: Arg, fld: &mut T) -> Arg {\n-    Arg {\n-        id: fld.new_id(id),\n-        pat: fld.fold_pat(pat),\n-        ty: fld.fold_ty(ty)\n+pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n+    let MetaItem { ident: _, node, span } = mi;\n+    match node {\n+        MetaItemKind::Word => {}\n+        MetaItemKind::List(mis) => visit_vec(mis, |mi| vis.visit_meta_list_item(mi)),\n+        MetaItemKind::NameValue(_s) => {}\n     }\n+    vis.visit_span(span);\n+}\n+\n+pub fn noop_visit_arg<T: MutVisitor>(Arg { id, pat, ty }: &mut Arg, vis: &mut T) {\n+    vis.visit_id(id);\n+    vis.visit_pat(pat);\n+    vis.visit_ty(ty);\n }\n \n-pub fn noop_fold_tt<T: Folder>(tt: TokenTree, fld: &mut T) -> TokenTree {\n+pub fn noop_visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n     match tt {\n-        TokenTree::Token(span, tok) =>\n-            TokenTree::Token(fld.new_span(span), fld.fold_token(tok)),\n-        TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n-            DelimSpan::from_pair(fld.new_span(span.open), fld.new_span(span.close)),\n-            delim,\n-            fld.fold_tts(tts).into(),\n-        ),\n+        TokenTree::Token(span, tok) => {\n+            vis.visit_span(span);\n+            vis.visit_token(tok);\n+        }\n+        TokenTree::Delimited(DelimSpan { open, close }, _delim, tts) => {\n+            vis.visit_span(open);\n+            vis.visit_span(close);\n+            vis.visit_tts(tts);\n+        }\n     }\n }\n \n-pub fn noop_fold_tts<T: Folder>(tts: TokenStream, fld: &mut T) -> TokenStream {\n-    tts.map(|tt| fld.fold_tt(tt))\n+pub fn noop_visit_tts<T: MutVisitor>(TokenStream(tts): &mut TokenStream, vis: &mut T) {\n+    visit_opt(tts, |tts| {\n+        let tts = Lrc::make_mut(tts);\n+        visit_vec(tts, |(tree, _is_joint)| vis.visit_tt(tree));\n+    })\n }\n \n-// apply ident folder if it's an ident, apply other folds to interpolated nodes\n-pub fn noop_fold_token<T: Folder>(t: token::Token, fld: &mut T) -> token::Token {\n+// apply ident visitor if it's an ident, apply other visits to interpolated nodes\n+pub fn noop_visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n     match t {\n-        token::Ident(id, is_raw) => token::Ident(fld.fold_ident(id), is_raw),\n-        token::Lifetime(id) => token::Lifetime(fld.fold_ident(id)),\n+        token::Ident(id, _is_raw) => vis.visit_ident(id),\n+        token::Lifetime(id) => vis.visit_ident(id),\n         token::Interpolated(nt) => {\n-            let nt = match Lrc::try_unwrap(nt) {\n-                Ok(nt) => nt,\n-                Err(nt) => (*nt).clone(),\n-            };\n-            Token::interpolated(fld.fold_interpolated(nt.0))\n+            let nt = Lrc::make_mut(nt);\n+            vis.visit_interpolated(&mut nt.0);\n+            nt.1 = token::LazyTokenStream::new();\n         }\n-        _ => t\n+        _ => {}\n     }\n }\n \n-/// apply folder to elements of interpolated nodes\n+/// Apply visitor to elements of interpolated nodes.\n //\n-// N.B., this can occur only when applying a fold to partially expanded code, where\n-// parsed pieces have gotten implanted ito *other* macro invocations. This is relevant\n-// for macro hygiene, but possibly not elsewhere.\n+// N.B., this can occur only when applying a visitor to partially expanded\n+// code, where parsed pieces have gotten implanted ito *other* macro\n+// invocations. This is relevant for macro hygiene, but possibly not elsewhere.\n //\n-// One problem here occurs because the types for fold_item, fold_stmt, etc. allow the\n-// folder to return *multiple* items; this is a problem for the nodes here, because\n-// they insist on having exactly one piece. One solution would be to mangle the fold\n-// trait to include one-to-many and one-to-one versions of these entry points, but that\n-// would probably confuse a lot of people and help very few. Instead, I'm just going\n-// to put in dynamic checks. I think the performance impact of this will be pretty much\n-// nonexistent. The danger is that someone will apply a fold to a partially expanded\n-// node, and will be confused by the fact that their \"fold_item\" or \"fold_stmt\" isn't\n-// getting called on NtItem or NtStmt nodes. Hopefully they'll wind up reading this\n-// comment, and doing something appropriate.\n+// One problem here occurs because the types for flat_map_item, flat_map_stmt,\n+// etc. allow the visitor to return *multiple* items; this is a problem for the\n+// nodes here, because they insist on having exactly one piece. One solution\n+// would be to mangle the MutVisitor trait to include one-to-many and\n+// one-to-one versions of these entry points, but that would probably confuse a\n+// lot of people and help very few. Instead, I'm just going to put in dynamic\n+// checks. I think the performance impact of this will be pretty much\n+// nonexistent. The danger is that someone will apply a MutVisitor to a\n+// partially expanded node, and will be confused by the fact that their\n+// \"flat_map_item\" or \"flat_map_stmt\" isn't getting called on NtItem or NtStmt\n+// nodes. Hopefully they'll wind up reading this comment, and doing something\n+// appropriate.\n //\n-// BTW, design choice: I considered just changing the type of, e.g., NtItem to contain\n-// multiple items, but decided against it when I looked at parse_item_or_view_item and\n-// tried to figure out what I would do with multiple items there....\n-pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n-                                         -> token::Nonterminal {\n+// BTW, design choice: I considered just changing the type of, e.g., NtItem to\n+// contain multiple items, but decided against it when I looked at\n+// parse_item_or_view_item and tried to figure out what I would do with\n+// multiple items there....\n+pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis: &mut T) {\n     match nt {\n         token::NtItem(item) =>\n-            token::NtItem(fld.fold_item(item)\n-                          // this is probably okay, because the only folds likely\n-                          // to peek inside interpolated nodes will be renamings/markings,\n-                          // which map single items to single items\n-                          .expect_one(\"expected fold to produce exactly one item\")),\n-        token::NtBlock(block) => token::NtBlock(fld.fold_block(block)),\n+            visit_clobber(item, |item| {\n+                // This is probably okay, because the only visitors likely to\n+                // peek inside interpolated nodes will be renamings/markings,\n+                // which map single items to single items.\n+                vis.flat_map_item(item).expect_one(\"expected visitor to produce exactly one item\")\n+            }),\n+        token::NtBlock(block) => vis.visit_block(block),\n         token::NtStmt(stmt) =>\n-            token::NtStmt(fld.fold_stmt(stmt)\n-                          // this is probably okay, because the only folds likely\n-                          // to peek inside interpolated nodes will be renamings/markings,\n-                          // which map single items to single items\n-                          .expect_one(\"expected fold to produce exactly one statement\")),\n-        token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n-        token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n-        token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n-        token::NtIdent(ident, is_raw) => token::NtIdent(fld.fold_ident(ident), is_raw),\n-        token::NtLifetime(ident) => token::NtLifetime(fld.fold_ident(ident)),\n-        token::NtLiteral(expr) => token::NtLiteral(fld.fold_expr(expr)),\n-        token::NtMeta(meta) => token::NtMeta(fld.fold_meta_item(meta)),\n-        token::NtPath(path) => token::NtPath(fld.fold_path(path)),\n-        token::NtTT(tt) => token::NtTT(fld.fold_tt(tt)),\n-        token::NtArm(arm) => token::NtArm(fld.fold_arm(arm)),\n+            visit_clobber(stmt, |stmt| {\n+                // See reasoning above.\n+                vis.flat_map_stmt(stmt).expect_one(\"expected visitor to produce exactly one item\")\n+            }),\n+        token::NtPat(pat) => vis.visit_pat(pat),\n+        token::NtExpr(expr) => vis.visit_expr(expr),\n+        token::NtTy(ty) => vis.visit_ty(ty),\n+        token::NtIdent(ident, _is_raw) => vis.visit_ident(ident),\n+        token::NtLifetime(ident) => vis.visit_ident(ident),\n+        token::NtLiteral(expr) => vis.visit_expr(expr),\n+        token::NtMeta(meta) => vis.visit_meta_item(meta),\n+        token::NtPath(path) => vis.visit_path(path),\n+        token::NtTT(tt) => vis.visit_tt(tt),\n+        token::NtArm(arm) => vis.visit_arm(arm),\n         token::NtImplItem(item) =>\n-            token::NtImplItem(fld.fold_impl_item(item)\n-                              .expect_one(\"expected fold to produce exactly one item\")),\n+            visit_clobber(item, |item| {\n+                // See reasoning above.\n+                vis.flat_map_impl_item(item)\n+                    .expect_one(\"expected visitor to produce exactly one item\")\n+            }),\n         token::NtTraitItem(item) =>\n-            token::NtTraitItem(fld.fold_trait_item(item)\n-                               .expect_one(\"expected fold to produce exactly one item\")),\n-        token::NtGenerics(generics) => token::NtGenerics(fld.fold_generics(generics)),\n-        token::NtWhereClause(where_clause) =>\n-            token::NtWhereClause(fld.fold_where_clause(where_clause)),\n-        token::NtArg(arg) => token::NtArg(fld.fold_arg(arg)),\n-        token::NtVis(vis) => token::NtVis(fld.fold_vis(vis)),\n-        token::NtForeignItem(ni) =>\n-            token::NtForeignItem(fld.fold_foreign_item(ni)\n-                                 // see reasoning above\n-                                 .expect_one(\"expected fold to produce exactly one item\")),\n-    }\n-}\n-\n-pub fn noop_fold_asyncness<T: Folder>(asyncness: IsAsync, fld: &mut T) -> IsAsync {\n+            visit_clobber(item, |item| {\n+                // See reasoning above.\n+                vis.flat_map_trait_item(item)\n+                    .expect_one(\"expected visitor to produce exactly one item\")\n+            }),\n+        token::NtGenerics(generics) => vis.visit_generics(generics),\n+        token::NtWhereClause(where_clause) => vis.visit_where_clause(where_clause),\n+        token::NtArg(arg) => vis.visit_arg(arg),\n+        token::NtVis(visib) => vis.visit_vis(visib),\n+        token::NtForeignItem(item) =>\n+            visit_clobber(item, |item| {\n+                // See reasoning above.\n+                vis.flat_map_foreign_item(item)\n+                    .expect_one(\"expected visitor to produce exactly one item\")\n+            }),\n+    }\n+}\n+\n+pub fn noop_visit_asyncness<T: MutVisitor>(asyncness: &mut IsAsync, vis: &mut T) {\n     match asyncness {\n-        IsAsync::Async { closure_id, return_impl_trait_id } => IsAsync::Async {\n-            closure_id: fld.new_id(closure_id),\n-            return_impl_trait_id: fld.new_id(return_impl_trait_id),\n-        },\n-        IsAsync::NotAsync => IsAsync::NotAsync,\n+        IsAsync::Async { closure_id, return_impl_trait_id } => {\n+            vis.visit_id(closure_id);\n+            vis.visit_id(return_impl_trait_id);\n+        }\n+        IsAsync::NotAsync => {}\n     }\n }\n \n-pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n-    decl.map(|FnDecl {inputs, output, variadic}| FnDecl {\n-        inputs: inputs.move_map(|x| fld.fold_arg(x)),\n-        output: match output {\n-            FunctionRetTy::Ty(ty) => FunctionRetTy::Ty(fld.fold_ty(ty)),\n-            FunctionRetTy::Default(span) => FunctionRetTy::Default(fld.new_span(span)),\n-        },\n-        variadic,\n-    })\n+pub fn noop_visit_fn_decl<T: MutVisitor>(decl: &mut P<FnDecl>, vis: &mut T) {\n+    let FnDecl { inputs, output, variadic: _ } = decl.deref_mut();\n+    visit_vec(inputs, |input| vis.visit_arg(input));\n+    match output {\n+        FunctionRetTy::Default(span) => vis.visit_span(span),\n+        FunctionRetTy::Ty(ty) => vis.visit_ty(ty),\n+    }\n }\n \n-pub fn noop_fold_param_bound<T>(pb: GenericBound, fld: &mut T) -> GenericBound where T: Folder {\n+pub fn noop_visit_param_bound<T: MutVisitor>(pb: &mut GenericBound, vis: &mut T) {\n     match pb {\n-        GenericBound::Trait(ty, modifier) => {\n-            GenericBound::Trait(fld.fold_poly_trait_ref(ty), modifier)\n-        }\n-        GenericBound::Outlives(lifetime) => {\n-            GenericBound::Outlives(noop_fold_lifetime(lifetime, fld))\n-        }\n+        GenericBound::Trait(ty, _modifier) => vis.visit_poly_trait_ref(ty),\n+        GenericBound::Outlives(lifetime) => noop_visit_lifetime(lifetime, vis),\n     }\n }\n \n-pub fn noop_fold_generic_param<T: Folder>(param: GenericParam, fld: &mut T) -> GenericParam {\n-    GenericParam {\n-        ident: fld.fold_ident(param.ident),\n-        id: fld.new_id(param.id),\n-        attrs: fold_thin_attrs(param.attrs, fld),\n-        bounds: param.bounds.move_map(|l| noop_fold_param_bound(l, fld)),\n-        kind: match param.kind {\n-            GenericParamKind::Lifetime => GenericParamKind::Lifetime,\n-            GenericParamKind::Type { default } => GenericParamKind::Type {\n-                default: default.map(|ty| fld.fold_ty(ty))\n-            }\n+pub fn noop_visit_generic_param<T: MutVisitor>(param: &mut GenericParam, vis: &mut T) {\n+    let GenericParam { id, ident, attrs, bounds, kind } = param;\n+    vis.visit_id(id);\n+    vis.visit_ident(ident);\n+    visit_thin_attrs(attrs, vis);\n+    visit_vec(bounds, |bound| noop_visit_param_bound(bound, vis));\n+    match kind {\n+        GenericParamKind::Lifetime => {}\n+        GenericParamKind::Type { default } => {\n+            visit_opt(default, |default| vis.visit_ty(default));\n         }\n     }\n }\n \n-pub fn noop_fold_generic_params<T: Folder>(\n-    params: Vec<GenericParam>,\n-    fld: &mut T\n-) -> Vec<GenericParam> {\n-    params.move_map(|p| fld.fold_generic_param(p))\n+pub fn noop_visit_generic_params<T: MutVisitor>(params: &mut Vec<GenericParam>, vis: &mut T){\n+    visit_vec(params, |param| vis.visit_generic_param(param));\n }\n \n-pub fn noop_fold_label<T: Folder>(label: Label, fld: &mut T) -> Label {\n-    Label {\n-        ident: fld.fold_ident(label.ident),\n-    }\n+pub fn noop_visit_label<T: MutVisitor>(Label { ident }: &mut Label, vis: &mut T) {\n+    vis.visit_ident(ident);\n }\n \n-fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n-    Lifetime {\n-        id: fld.new_id(l.id),\n-        ident: fld.fold_ident(l.ident),\n-    }\n+fn noop_visit_lifetime<T: MutVisitor>(Lifetime { id, ident }: &mut Lifetime, vis: &mut T) {\n+    vis.visit_id(id);\n+    vis.visit_ident(ident);\n }\n \n-pub fn noop_fold_generics<T: Folder>(Generics { params, where_clause, span }: Generics,\n-                                     fld: &mut T) -> Generics {\n-    Generics {\n-        params: fld.fold_generic_params(params),\n-        where_clause: fld.fold_where_clause(where_clause),\n-        span: fld.new_span(span),\n-    }\n+pub fn noop_visit_generics<T: MutVisitor>(generics: &mut Generics, vis: &mut T) {\n+    let Generics { params, where_clause, span } = generics;\n+    vis.visit_generic_params(params);\n+    vis.visit_where_clause(where_clause);\n+    vis.visit_span(span);\n }\n \n-pub fn noop_fold_where_clause<T: Folder>(\n-                              WhereClause {id, predicates, span}: WhereClause,\n-                              fld: &mut T)\n-                              -> WhereClause {\n-    WhereClause {\n-        id: fld.new_id(id),\n-        predicates: predicates.move_map(|predicate| {\n-            fld.fold_where_predicate(predicate)\n-        }),\n-        span: fld.new_span(span),\n-    }\n+pub fn noop_visit_where_clause<T: MutVisitor>(wc: &mut WhereClause, vis: &mut T) {\n+    let WhereClause { id, predicates, span } = wc;\n+    vis.visit_id(id);\n+    visit_vec(predicates, |predicate| vis.visit_where_predicate(predicate));\n+    vis.visit_span(span);\n }\n \n-pub fn noop_fold_where_predicate<T: Folder>(\n-                                 pred: WherePredicate,\n-                                 fld: &mut T)\n-                                 -> WherePredicate {\n+pub fn noop_visit_where_predicate<T: MutVisitor>(pred: &mut WherePredicate, vis: &mut T) {\n     match pred {\n-        WherePredicate::BoundPredicate(WhereBoundPredicate { bound_generic_params,\n-                                                             bounded_ty,\n-                                                             bounds,\n-                                                             span }) => {\n-            WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                bound_generic_params: fld.fold_generic_params(bound_generic_params),\n-                bounded_ty: fld.fold_ty(bounded_ty),\n-                bounds: bounds.move_map(|x| fld.fold_param_bound(x)),\n-                span: fld.new_span(span)\n-            })\n-        }\n-        WherePredicate::RegionPredicate(WhereRegionPredicate { lifetime, bounds, span }) => {\n-            WherePredicate::RegionPredicate(WhereRegionPredicate {\n-                span: fld.new_span(span),\n-                lifetime: noop_fold_lifetime(lifetime, fld),\n-                bounds: bounds.move_map(|bound| noop_fold_param_bound(bound, fld))\n-            })\n-        }\n-        WherePredicate::EqPredicate(WhereEqPredicate { id, lhs_ty, rhs_ty, span }) => {\n-            WherePredicate::EqPredicate(WhereEqPredicate{\n-                id: fld.new_id(id),\n-                lhs_ty: fld.fold_ty(lhs_ty),\n-                rhs_ty: fld.fold_ty(rhs_ty),\n-                span: fld.new_span(span)\n-            })\n-        }\n-    }\n-}\n-\n-pub fn noop_fold_variant_data<T: Folder>(vdata: VariantData, fld: &mut T) -> VariantData {\n-    match vdata {\n-        VariantData::Struct(fields, id) => {\n-            VariantData::Struct(fields.move_map(|f| fld.fold_struct_field(f)), fld.new_id(id))\n+        WherePredicate::BoundPredicate(bp) => {\n+            let WhereBoundPredicate { span, bound_generic_params, bounded_ty, bounds } = bp;\n+            vis.visit_span(span);\n+            vis.visit_generic_params(bound_generic_params);\n+            vis.visit_ty(bounded_ty);\n+            visit_vec(bounds, |bound| vis.visit_param_bound(bound));\n         }\n-        VariantData::Tuple(fields, id) => {\n-            VariantData::Tuple(fields.move_map(|f| fld.fold_struct_field(f)), fld.new_id(id))\n+        WherePredicate::RegionPredicate(rp) => {\n+            let WhereRegionPredicate { span, lifetime, bounds } = rp;\n+            vis.visit_span(span);\n+            noop_visit_lifetime(lifetime, vis);\n+            visit_vec(bounds, |bound| noop_visit_param_bound(bound, vis));\n+        }\n+        WherePredicate::EqPredicate(ep) => {\n+            let WhereEqPredicate { id, span, lhs_ty, rhs_ty } = ep;\n+            vis.visit_id(id);\n+            vis.visit_span(span);\n+            vis.visit_ty(lhs_ty);\n+            vis.visit_ty(rhs_ty);\n         }\n-        VariantData::Unit(id) => VariantData::Unit(fld.new_id(id))\n     }\n }\n \n-pub fn noop_fold_trait_ref<T: Folder>(p: TraitRef, fld: &mut T) -> TraitRef {\n-    let id = fld.new_id(p.ref_id);\n-    let TraitRef {\n-        path,\n-        ref_id: _,\n-    } = p;\n-    TraitRef {\n-        path: fld.fold_path(path),\n-        ref_id: id,\n+pub fn noop_visit_variant_data<T: MutVisitor>(vdata: &mut VariantData, vis: &mut T) {\n+    match vdata {\n+        VariantData::Struct(fields, id) |\n+        VariantData::Tuple(fields, id) => {\n+            visit_vec(fields, |field| vis.visit_struct_field(field));\n+            vis.visit_id(id);\n+        }\n+        VariantData::Unit(id) => vis.visit_id(id),\n     }\n }\n \n-pub fn noop_fold_poly_trait_ref<T: Folder>(p: PolyTraitRef, fld: &mut T) -> PolyTraitRef {\n-    PolyTraitRef {\n-        bound_generic_params: fld.fold_generic_params(p.bound_generic_params),\n-        trait_ref: fld.fold_trait_ref(p.trait_ref),\n-        span: fld.new_span(p.span),\n-    }\n+pub fn noop_visit_trait_ref<T: MutVisitor>(TraitRef { path, ref_id }: &mut TraitRef, vis: &mut T) {\n+    vis.visit_path(path);\n+    vis.visit_id(ref_id);\n }\n \n-pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructField {\n-    StructField {\n-        span: fld.new_span(f.span),\n-        id: fld.new_id(f.id),\n-        ident: f.ident.map(|ident| fld.fold_ident(ident)),\n-        vis: fld.fold_vis(f.vis),\n-        ty: fld.fold_ty(f.ty),\n-        attrs: fold_attrs(f.attrs, fld),\n-    }\n+pub fn noop_visit_poly_trait_ref<T: MutVisitor>(p: &mut PolyTraitRef, vis: &mut T) {\n+    let PolyTraitRef { bound_generic_params, trait_ref, span } = p;\n+    vis.visit_generic_params(bound_generic_params);\n+    vis.visit_trait_ref(trait_ref);\n+    vis.visit_span(span);\n }\n \n-pub fn noop_fold_field<T: Folder>(f: Field, folder: &mut T) -> Field {\n-    Field {\n-        ident: folder.fold_ident(f.ident),\n-        expr: folder.fold_expr(f.expr),\n-        span: folder.new_span(f.span),\n-        is_shorthand: f.is_shorthand,\n-        attrs: fold_thin_attrs(f.attrs, folder),\n-    }\n+pub fn noop_visit_struct_field<T: MutVisitor>(f: &mut StructField, visitor: &mut T) {\n+    let StructField { span, ident, vis, id, ty, attrs } = f;\n+    visitor.visit_span(span);\n+    visit_opt(ident, |ident| visitor.visit_ident(ident));\n+    visitor.visit_vis(vis);\n+    visitor.visit_id(id);\n+    visitor.visit_ty(ty);\n+    visit_attrs(attrs, visitor);\n }\n \n-pub fn noop_fold_mt<T: Folder>(MutTy {ty, mutbl}: MutTy, folder: &mut T) -> MutTy {\n-    MutTy {\n-        ty: folder.fold_ty(ty),\n-        mutbl,\n-    }\n+pub fn noop_visit_field<T: MutVisitor>(f: &mut Field, vis: &mut T) {\n+    let Field { ident, expr, span, is_shorthand: _, attrs } = f;\n+    vis.visit_ident(ident);\n+    vis.visit_expr(expr);\n+    vis.visit_span(span);\n+    visit_thin_attrs(attrs, vis);\n }\n \n-pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    b.map(|Block {id, stmts, rules, span}| Block {\n-        id: folder.new_id(id),\n-        stmts: stmts.move_flat_map(|s| folder.fold_stmt(s).into_iter()),\n-        rules,\n-        span: folder.new_span(span),\n-    })\n+pub fn noop_visit_mt<T: MutVisitor>(MutTy { ty, mutbl: _ }: &mut MutTy, vis: &mut T) {\n+    vis.visit_ty(ty);\n }\n \n-pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n-    match i {\n-        ItemKind::ExternCrate(orig_name) => ItemKind::ExternCrate(orig_name),\n-        ItemKind::Use(use_tree) => {\n-            ItemKind::Use(use_tree.map(|tree| folder.fold_use_tree(tree)))\n-        }\n-        ItemKind::Static(t, m, e) => {\n-            ItemKind::Static(folder.fold_ty(t), m, folder.fold_expr(e))\n+pub fn noop_visit_block<T: MutVisitor>(block: &mut P<Block>, vis: &mut T) {\n+    let Block { id, stmts, rules: _, span } = block.deref_mut();\n+    vis.visit_id(id);\n+    stmts.flat_map_in_place(|stmt| vis.flat_map_stmt(stmt));\n+    vis.visit_span(span);\n+}\n+\n+pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n+    match kind {\n+        ItemKind::ExternCrate(_orig_name) => {}\n+        ItemKind::Use(use_tree) => vis.visit_use_tree(use_tree),\n+        ItemKind::Static(ty, _mut, expr) => {\n+            vis.visit_ty(ty);\n+            vis.visit_expr(expr);\n         }\n-        ItemKind::Const(t, e) => {\n-            ItemKind::Const(folder.fold_ty(t), folder.fold_expr(e))\n+        ItemKind::Const(ty, expr) => {\n+            vis.visit_ty(ty);\n+            vis.visit_expr(expr);\n         }\n         ItemKind::Fn(decl, header, generics, body) => {\n-            let generics = folder.fold_generics(generics);\n-            let header = folder.fold_fn_header(header);\n-            let decl = folder.fold_fn_decl(decl);\n-            let body = folder.fold_block(body);\n-            ItemKind::Fn(decl, header, generics, body)\n-        }\n-        ItemKind::Mod(m) => ItemKind::Mod(folder.fold_mod(m)),\n-        ItemKind::ForeignMod(nm) => ItemKind::ForeignMod(folder.fold_foreign_mod(nm)),\n-        ItemKind::GlobalAsm(ga) => ItemKind::GlobalAsm(ga),\n-        ItemKind::Ty(t, generics) => {\n-            ItemKind::Ty(folder.fold_ty(t), folder.fold_generics(generics))\n-        }\n-        ItemKind::Existential(bounds, generics) => ItemKind::Existential(\n-            fold_bounds(bounds, folder),\n-            folder.fold_generics(generics),\n-        ),\n-        ItemKind::Enum(enum_definition, generics) => {\n-            let generics = folder.fold_generics(generics);\n-            let variants = enum_definition.variants.move_map(|x| folder.fold_variant(x));\n-            ItemKind::Enum(EnumDef { variants }, generics)\n-        }\n-        ItemKind::Struct(struct_def, generics) => {\n-            let generics = folder.fold_generics(generics);\n-            ItemKind::Struct(folder.fold_variant_data(struct_def), generics)\n-        }\n-        ItemKind::Union(struct_def, generics) => {\n-            let generics = folder.fold_generics(generics);\n-            ItemKind::Union(folder.fold_variant_data(struct_def), generics)\n-        }\n-        ItemKind::Impl(unsafety,\n-                       polarity,\n-                       defaultness,\n-                       generics,\n-                       ifce,\n-                       ty,\n-                       impl_items) => ItemKind::Impl(\n-            unsafety,\n-            polarity,\n-            defaultness,\n-            folder.fold_generics(generics),\n-            ifce.map(|trait_ref| folder.fold_trait_ref(trait_ref)),\n-            folder.fold_ty(ty),\n-            impl_items.move_flat_map(|item| folder.fold_impl_item(item)),\n-        ),\n-        ItemKind::Trait(is_auto, unsafety, generics, bounds, items) => ItemKind::Trait(\n-            is_auto,\n-            unsafety,\n-            folder.fold_generics(generics),\n-            fold_bounds(bounds, folder),\n-            items.move_flat_map(|item| folder.fold_trait_item(item)),\n-        ),\n-        ItemKind::TraitAlias(generics, bounds) => ItemKind::TraitAlias(\n-            folder.fold_generics(generics),\n-            fold_bounds(bounds, folder)),\n-        ItemKind::Mac(m) => ItemKind::Mac(folder.fold_mac(m)),\n-        ItemKind::MacroDef(def) => ItemKind::MacroDef(folder.fold_macro_def(def)),\n-    }\n-}\n-\n-pub fn noop_fold_trait_item<T: Folder>(i: TraitItem, folder: &mut T) -> SmallVec<[TraitItem; 1]> {\n-    smallvec![TraitItem {\n-        id: folder.new_id(i.id),\n-        ident: folder.fold_ident(i.ident),\n-        attrs: fold_attrs(i.attrs, folder),\n-        generics: folder.fold_generics(i.generics),\n-        node: match i.node {\n-            TraitItemKind::Const(ty, default) => {\n-                TraitItemKind::Const(folder.fold_ty(ty),\n-                               default.map(|x| folder.fold_expr(x)))\n-            }\n-            TraitItemKind::Method(sig, body) => {\n-                TraitItemKind::Method(fold_method_sig(sig, folder),\n-                                body.map(|x| folder.fold_block(x)))\n-            }\n-            TraitItemKind::Type(bounds, default) => {\n-                TraitItemKind::Type(fold_bounds(bounds, folder),\n-                              default.map(|x| folder.fold_ty(x)))\n-            }\n-            TraitItemKind::Macro(mac) => {\n-                TraitItemKind::Macro(folder.fold_mac(mac))\n-            }\n-        },\n-        span: folder.new_span(i.span),\n-        tokens: i.tokens,\n-    }]\n-}\n-\n-pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)-> SmallVec<[ImplItem; 1]> {\n-    smallvec![ImplItem {\n-        id: folder.new_id(i.id),\n-        vis: folder.fold_vis(i.vis),\n-        ident: folder.fold_ident(i.ident),\n-        attrs: fold_attrs(i.attrs, folder),\n-        generics: folder.fold_generics(i.generics),\n-        defaultness: i.defaultness,\n-        node: match i.node  {\n-            ImplItemKind::Const(ty, expr) => {\n-                ImplItemKind::Const(folder.fold_ty(ty), folder.fold_expr(expr))\n-            }\n-            ImplItemKind::Method(sig, body) => {\n-                ImplItemKind::Method(fold_method_sig(sig, folder),\n-                               folder.fold_block(body))\n-            }\n-            ImplItemKind::Type(ty) => ImplItemKind::Type(folder.fold_ty(ty)),\n-            ImplItemKind::Existential(bounds) => {\n-                ImplItemKind::Existential(fold_bounds(bounds, folder))\n-            },\n-            ImplItemKind::Macro(mac) => ImplItemKind::Macro(folder.fold_mac(mac))\n-        },\n-        span: folder.new_span(i.span),\n-        tokens: i.tokens,\n-    }]\n-}\n-\n-pub fn noop_fold_fn_header<T: Folder>(mut header: FnHeader, folder: &mut T) -> FnHeader {\n-    header.asyncness = folder.fold_asyncness(header.asyncness);\n-    header\n+            vis.visit_fn_decl(decl);\n+            vis.visit_fn_header(header);\n+            vis.visit_generics(generics);\n+            vis.visit_block(body);\n+        }\n+        ItemKind::Mod(m) => vis.visit_mod(m),\n+        ItemKind::ForeignMod(nm) => vis.visit_foreign_mod(nm),\n+        ItemKind::GlobalAsm(_ga) => {}\n+        ItemKind::Ty(ty, generics) => {\n+            vis.visit_ty(ty);\n+            vis.visit_generics(generics);\n+        }\n+        ItemKind::Existential(bounds, generics) => {\n+            visit_bounds(bounds, vis);\n+            vis.visit_generics(generics);\n+        }\n+        ItemKind::Enum(EnumDef { variants }, generics) => {\n+            visit_vec(variants, |variant| vis.visit_variant(variant));\n+            vis.visit_generics(generics);\n+        }\n+        ItemKind::Struct(variant_data, generics) |\n+        ItemKind::Union(variant_data, generics) => {\n+            vis.visit_variant_data(variant_data);\n+            vis.visit_generics(generics);\n+        }\n+        ItemKind::Impl(_unsafety, _polarity, _defaultness, generics, trait_ref, ty, items) => {\n+            vis.visit_generics(generics);\n+            visit_opt(trait_ref, |trait_ref| vis.visit_trait_ref(trait_ref));\n+            vis.visit_ty(ty);\n+            items.flat_map_in_place(|item| vis.flat_map_impl_item(item));\n+        }\n+        ItemKind::Trait(_is_auto, _unsafety, generics, bounds, items) => {\n+            vis.visit_generics(generics);\n+            visit_bounds(bounds, vis);\n+            items.flat_map_in_place(|item| vis.flat_map_trait_item(item));\n+        }\n+        ItemKind::TraitAlias(generics, bounds) => {\n+            vis.visit_generics(generics);\n+            visit_bounds(bounds, vis);\n+        }\n+        ItemKind::Mac(m) => vis.visit_mac(m),\n+        ItemKind::MacroDef(def) => vis.visit_macro_def(def),\n+    }\n }\n \n-pub fn noop_fold_mod<T: Folder>(Mod {inner, items, inline}: Mod, folder: &mut T) -> Mod {\n-    Mod {\n-        inner: folder.new_span(inner),\n-        items: items.move_flat_map(|x| folder.fold_item(x)),\n-        inline: inline,\n+pub fn noop_flat_map_trait_item<T: MutVisitor>(mut item: TraitItem, vis: &mut T)\n+    -> SmallVec<[TraitItem; 1]>\n+{\n+    let TraitItem { id, ident, attrs, generics, node, span, tokens: _ } = &mut item;\n+    vis.visit_id(id);\n+    vis.visit_ident(ident);\n+    visit_attrs(attrs, vis);\n+    vis.visit_generics(generics);\n+    match node {\n+        TraitItemKind::Const(ty, default) => {\n+            vis.visit_ty(ty);\n+            visit_opt(default, |default| vis.visit_expr(default));\n+        }\n+        TraitItemKind::Method(sig, body) => {\n+            visit_method_sig(sig, vis);\n+            visit_opt(body, |body| vis.visit_block(body));\n+        }\n+        TraitItemKind::Type(bounds, default) => {\n+            visit_bounds(bounds, vis);\n+            visit_opt(default, |default| vis.visit_ty(default));\n+        }\n+        TraitItemKind::Macro(mac) => {\n+            vis.visit_mac(mac);\n+        }\n     }\n-}\n+    vis.visit_span(span);\n \n-pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, span}: Crate,\n-                                  folder: &mut T) -> Crate {\n-    let item = P(Item {\n-        ident: keywords::Invalid.ident(),\n-        attrs,\n-        id: DUMMY_NODE_ID,\n-        vis: respan(span.shrink_to_lo(), VisibilityKind::Public),\n-        span,\n-        node: ItemKind::Mod(module),\n-        tokens: None,\n-    });\n-    let items = folder.fold_item(item);\n+    smallvec![item]\n+}\n \n-    let len = items.len();\n-    if len == 0 {\n-        let module = Mod { inner: span, items: vec![], inline: true };\n-        Crate { module, attrs: vec![], span }\n-    } else if len == 1 {\n-        let Item { attrs, span, node, .. } = items.into_iter().next().unwrap().into_inner();\n-        match node {\n-            ItemKind::Mod(module) => Crate { module, attrs, span },\n-            _ => panic!(\"fold converted a module to not a module\"),\n+pub fn noop_flat_map_impl_item<T: MutVisitor>(mut item: ImplItem, visitor: &mut T)\n+                                              -> SmallVec<[ImplItem; 1]>\n+{\n+    let ImplItem { id, ident, vis, defaultness: _, attrs, generics, node, span, tokens: _ } =\n+        &mut item;\n+    visitor.visit_id(id);\n+    visitor.visit_ident(ident);\n+    visitor.visit_vis(vis);\n+    visit_attrs(attrs, visitor);\n+    visitor.visit_generics(generics);\n+    match node  {\n+        ImplItemKind::Const(ty, expr) => {\n+            visitor.visit_ty(ty);\n+            visitor.visit_expr(expr);\n         }\n-    } else {\n-        panic!(\"a crate cannot expand to more than one item\");\n-    }\n+        ImplItemKind::Method(sig, body) => {\n+            visit_method_sig(sig, visitor);\n+            visitor.visit_block(body);\n+        }\n+        ImplItemKind::Type(ty) => visitor.visit_ty(ty),\n+        ImplItemKind::Existential(bounds) => visit_bounds(bounds, visitor),\n+        ImplItemKind::Macro(mac) => visitor.visit_mac(mac),\n+    }\n+    visitor.visit_span(span);\n+\n+    smallvec![item]\n+}\n+\n+pub fn noop_visit_fn_header<T: MutVisitor>(header: &mut FnHeader, vis: &mut T) {\n+    let FnHeader { unsafety: _, asyncness, constness: _, abi: _ } = header;\n+    vis.visit_asyncness(asyncness);\n+}\n+\n+pub fn noop_visit_mod<T: MutVisitor>(Mod { inner, items, inline: _ }: &mut Mod, vis: &mut T) {\n+    vis.visit_span(inner);\n+    items.flat_map_in_place(|item| vis.flat_map_item(item));\n+}\n+\n+pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n+    visit_clobber(krate, |Crate { module, attrs, span }| {\n+        let item = P(Item {\n+            ident: keywords::Invalid.ident(),\n+            attrs,\n+            id: DUMMY_NODE_ID,\n+            vis: respan(span.shrink_to_lo(), VisibilityKind::Public),\n+            span,\n+            node: ItemKind::Mod(module),\n+            tokens: None,\n+        });\n+        let items = vis.flat_map_item(item);\n+\n+        let len = items.len();\n+        if len == 0 {\n+            let module = Mod { inner: span, items: vec![], inline: true };\n+            Crate { module, attrs: vec![], span }\n+        } else if len == 1 {\n+            let Item { attrs, span, node, .. } = items.into_iter().next().unwrap().into_inner();\n+            match node {\n+                ItemKind::Mod(module) => Crate { module, attrs, span },\n+                _ => panic!(\"visitor converted a module to not a module\"),\n+            }\n+        } else {\n+            panic!(\"a crate cannot expand to more than one item\");\n+        }\n+    });\n }\n \n-// fold one item into possibly many items\n-pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVec<[P<Item>; 1]> {\n-    smallvec![i.map(|i| {\n-        let Item {id, ident, attrs, node, vis, span, tokens} = i;\n-        Item {\n-            id: folder.new_id(id),\n-            vis: folder.fold_vis(vis),\n-            ident: folder.fold_ident(ident),\n-            attrs: fold_attrs(attrs, folder),\n-            node: folder.fold_item_kind(node),\n-            span: folder.new_span(span),\n+// Mutate one item into possibly many items.\n+pub fn noop_flat_map_item<T: MutVisitor>(mut item: P<Item>, visitor: &mut T)\n+                                         -> SmallVec<[P<Item>; 1]> {\n+    let Item { ident, attrs, id, node, vis, span, tokens: _ } = item.deref_mut();\n+    visitor.visit_ident(ident);\n+    visit_attrs(attrs, visitor);\n+    visitor.visit_id(id);\n+    visitor.visit_item_kind(node);\n+    visitor.visit_vis(vis);\n+    visitor.visit_span(span);\n \n-            // FIXME: if this is replaced with a call to `folder.fold_tts` it causes\n-            //        an ICE during resolve... odd!\n-            tokens,\n-        }\n-    })]\n+    // FIXME: if `tokens` is modified with a call to `vis.visit_tts` it causes\n+    //        an ICE during resolve... odd!\n+\n+    smallvec![item]\n }\n \n-pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T)\n+pub fn noop_flat_map_foreign_item<T: MutVisitor>(mut item: ForeignItem, visitor: &mut T)\n     -> SmallVec<[ForeignItem; 1]>\n {\n-    smallvec![ForeignItem {\n-        id: folder.new_id(ni.id),\n-        vis: folder.fold_vis(ni.vis),\n-        ident: folder.fold_ident(ni.ident),\n-        attrs: fold_attrs(ni.attrs, folder),\n-        node: match ni.node {\n-            ForeignItemKind::Fn(fdec, generics) => {\n-                ForeignItemKind::Fn(folder.fold_fn_decl(fdec), folder.fold_generics(generics))\n-            }\n-            ForeignItemKind::Static(t, m) => {\n-                ForeignItemKind::Static(folder.fold_ty(t), m)\n-            }\n-            ForeignItemKind::Ty => ForeignItemKind::Ty,\n-            ForeignItemKind::Macro(mac) => ForeignItemKind::Macro(folder.fold_mac(mac)),\n-        },\n-        span: folder.new_span(ni.span)\n-    }]\n-}\n-\n-pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n-    p.map(|Pat {id, node, span}| Pat {\n-        id: folder.new_id(id),\n-        node: match node {\n-            PatKind::Wild => PatKind::Wild,\n-            PatKind::Ident(binding_mode, ident, sub) => {\n-                PatKind::Ident(binding_mode,\n-                               folder.fold_ident(ident),\n-                               sub.map(|x| folder.fold_pat(x)))\n-            }\n-            PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n-            PatKind::TupleStruct(pth, pats, ddpos) => {\n-                PatKind::TupleStruct(folder.fold_path(pth),\n-                        pats.move_map(|x| folder.fold_pat(x)), ddpos)\n-            }\n-            PatKind::Path(qself, pth) => {\n-                PatKind::Path(folder.fold_qself(qself), folder.fold_path(pth))\n-            }\n-            PatKind::Struct(pth, fields, etc) => {\n-                let pth = folder.fold_path(pth);\n-                let fs = fields.move_map(|f| {\n-                    Spanned { span: folder.new_span(f.span),\n-                              node: FieldPat {\n-                                  ident: folder.fold_ident(f.node.ident),\n-                                  pat: folder.fold_pat(f.node.pat),\n-                                  is_shorthand: f.node.is_shorthand,\n-                                  attrs: fold_attrs(f.node.attrs.into(), folder).into()\n-                              }}\n-                });\n-                PatKind::Struct(pth, fs, etc)\n-            }\n-            PatKind::Tuple(elts, ddpos) => {\n-                PatKind::Tuple(elts.move_map(|x| folder.fold_pat(x)), ddpos)\n-            }\n-            PatKind::Box(inner) => PatKind::Box(folder.fold_pat(inner)),\n-            PatKind::Ref(inner, mutbl) => PatKind::Ref(folder.fold_pat(inner), mutbl),\n-            PatKind::Range(e1, e2, Spanned { span, node }) => {\n-                PatKind::Range(folder.fold_expr(e1),\n-                               folder.fold_expr(e2),\n-                               Spanned { node, span: folder.new_span(span) })\n-            },\n-            PatKind::Slice(before, slice, after) => {\n-                PatKind::Slice(before.move_map(|x| folder.fold_pat(x)),\n-                       slice.map(|x| folder.fold_pat(x)),\n-                       after.move_map(|x| folder.fold_pat(x)))\n-            }\n-            PatKind::Paren(inner) => PatKind::Paren(folder.fold_pat(inner)),\n-            PatKind::Mac(mac) => PatKind::Mac(folder.fold_mac(mac))\n-        },\n-        span: folder.new_span(span)\n-    })\n+    let ForeignItem { ident, attrs, node, id, span, vis } = &mut item;\n+    visitor.visit_ident(ident);\n+    visit_attrs(attrs, visitor);\n+    match node {\n+        ForeignItemKind::Fn(fdec, generics) => {\n+            visitor.visit_fn_decl(fdec);\n+            visitor.visit_generics(generics);\n+        }\n+        ForeignItemKind::Static(t, _m) => visitor.visit_ty(t),\n+        ForeignItemKind::Ty => {}\n+        ForeignItemKind::Macro(mac) => visitor.visit_mac(mac),\n+    }\n+    visitor.visit_id(id);\n+    visitor.visit_span(span);\n+    visitor.visit_vis(vis);\n+\n+    smallvec![item]\n }\n \n-pub fn noop_fold_anon_const<T: Folder>(constant: AnonConst, folder: &mut T) -> AnonConst {\n-    let AnonConst {id, value} = constant;\n-    AnonConst {\n-        id: folder.new_id(id),\n-        value: folder.fold_expr(value),\n+pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n+    let Pat { id, node, span } = pat.deref_mut();\n+    vis.visit_id(id);\n+    match node {\n+        PatKind::Wild => {}\n+        PatKind::Ident(_binding_mode, ident, sub) => {\n+            vis.visit_ident(ident);\n+            visit_opt(sub, |sub| vis.visit_pat(sub));\n+        }\n+        PatKind::Lit(e) => vis.visit_expr(e),\n+        PatKind::TupleStruct(path, pats, _ddpos) => {\n+            vis.visit_path(path);\n+            visit_vec(pats, |pat| vis.visit_pat(pat));\n+        }\n+        PatKind::Path(qself, path) => {\n+            vis.visit_qself(qself);\n+            vis.visit_path(path);\n+        }\n+        PatKind::Struct(path, fields, _etc) => {\n+            vis.visit_path(path);\n+            for Spanned { node: FieldPat { ident, pat, is_shorthand: _, attrs }, span } in fields {\n+                vis.visit_ident(ident);\n+                vis.visit_pat(pat);\n+                visit_thin_attrs(attrs, vis);\n+                vis.visit_span(span);\n+            };\n+        }\n+        PatKind::Tuple(elts, _ddpos) => visit_vec(elts, |elt| vis.visit_pat(elt)),\n+        PatKind::Box(inner) => vis.visit_pat(inner),\n+        PatKind::Ref(inner, _mutbl) => vis.visit_pat(inner),\n+        PatKind::Range(e1, e2, Spanned { span: _, node: _ }) => {\n+            vis.visit_expr(e1);\n+            vis.visit_expr(e2);\n+            vis.visit_span(span);\n+        },\n+        PatKind::Slice(before, slice, after) => {\n+            visit_vec(before, |pat| vis.visit_pat(pat));\n+            visit_opt(slice, |slice| vis.visit_pat(slice));\n+            visit_vec(after, |pat| vis.visit_pat(pat));\n+        }\n+        PatKind::Paren(inner) => vis.visit_pat(inner),\n+        PatKind::Mac(mac) => vis.visit_mac(mac),\n     }\n+    vis.visit_span(span);\n }\n \n-pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mut T) -> Expr {\n-    Expr {\n-        node: match node {\n-            ExprKind::Box(e) => {\n-                ExprKind::Box(folder.fold_expr(e))\n-            }\n-            ExprKind::ObsoleteInPlace(a, b) => {\n-                ExprKind::ObsoleteInPlace(folder.fold_expr(a), folder.fold_expr(b))\n-            }\n-            ExprKind::Array(exprs) => {\n-                ExprKind::Array(fold_exprs(exprs, folder))\n-            }\n-            ExprKind::Repeat(expr, count) => {\n-                ExprKind::Repeat(folder.fold_expr(expr), folder.fold_anon_const(count))\n-            }\n-            ExprKind::Tup(exprs) => ExprKind::Tup(fold_exprs(exprs, folder)),\n-            ExprKind::Call(f, args) => {\n-                ExprKind::Call(folder.fold_expr(f),\n-                         fold_exprs(args, folder))\n-            }\n-            ExprKind::MethodCall(seg, args) => {\n-                ExprKind::MethodCall(\n-                    PathSegment {\n-                        ident: folder.fold_ident(seg.ident),\n-                        id: folder.new_id(seg.id),\n-                        args: seg.args.map(|args| {\n-                            args.map(|args| folder.fold_generic_args(args))\n-                        }),\n-                    },\n-                    fold_exprs(args, folder))\n-            }\n-            ExprKind::Binary(binop, lhs, rhs) => {\n-                ExprKind::Binary(binop,\n-                        folder.fold_expr(lhs),\n-                        folder.fold_expr(rhs))\n-            }\n-            ExprKind::Unary(binop, ohs) => {\n-                ExprKind::Unary(binop, folder.fold_expr(ohs))\n-            }\n-            ExprKind::Lit(l) => ExprKind::Lit(l),\n-            ExprKind::Cast(expr, ty) => {\n-                ExprKind::Cast(folder.fold_expr(expr), folder.fold_ty(ty))\n-            }\n-            ExprKind::Type(expr, ty) => {\n-                ExprKind::Type(folder.fold_expr(expr), folder.fold_ty(ty))\n-            }\n-            ExprKind::AddrOf(m, ohs) => ExprKind::AddrOf(m, folder.fold_expr(ohs)),\n-            ExprKind::If(cond, tr, fl) => {\n-                ExprKind::If(folder.fold_expr(cond),\n-                       folder.fold_block(tr),\n-                       fl.map(|x| folder.fold_expr(x)))\n-            }\n-            ExprKind::IfLet(pats, expr, tr, fl) => {\n-                ExprKind::IfLet(pats.move_map(|pat| folder.fold_pat(pat)),\n-                          folder.fold_expr(expr),\n-                          folder.fold_block(tr),\n-                          fl.map(|x| folder.fold_expr(x)))\n-            }\n-            ExprKind::While(cond, body, opt_label) => {\n-                ExprKind::While(folder.fold_expr(cond),\n-                          folder.fold_block(body),\n-                          opt_label.map(|label| folder.fold_label(label)))\n-            }\n-            ExprKind::WhileLet(pats, expr, body, opt_label) => {\n-                ExprKind::WhileLet(pats.move_map(|pat| folder.fold_pat(pat)),\n-                             folder.fold_expr(expr),\n-                             folder.fold_block(body),\n-                             opt_label.map(|label| folder.fold_label(label)))\n-            }\n-            ExprKind::ForLoop(pat, iter, body, opt_label) => {\n-                ExprKind::ForLoop(folder.fold_pat(pat),\n-                            folder.fold_expr(iter),\n-                            folder.fold_block(body),\n-                            opt_label.map(|label| folder.fold_label(label)))\n-            }\n-            ExprKind::Loop(body, opt_label) => {\n-                ExprKind::Loop(folder.fold_block(body),\n-                               opt_label.map(|label| folder.fold_label(label)))\n-            }\n-            ExprKind::Match(expr, arms) => {\n-                ExprKind::Match(folder.fold_expr(expr),\n-                          arms.move_map(|x| folder.fold_arm(x)))\n-            }\n-            ExprKind::Closure(capture_clause, asyncness, movability, decl, body, span) => {\n-                ExprKind::Closure(capture_clause,\n-                                  folder.fold_asyncness(asyncness),\n-                                  movability,\n-                                  folder.fold_fn_decl(decl),\n-                                  folder.fold_expr(body),\n-                                  folder.new_span(span))\n-            }\n-            ExprKind::Block(blk, opt_label) => {\n-                ExprKind::Block(folder.fold_block(blk),\n-                                opt_label.map(|label| folder.fold_label(label)))\n-            }\n-            ExprKind::Async(capture_clause, node_id, body) => {\n-                ExprKind::Async(\n-                    capture_clause,\n-                    folder.new_id(node_id),\n-                    folder.fold_block(body),\n-                )\n-            }\n-            ExprKind::Assign(el, er) => {\n-                ExprKind::Assign(folder.fold_expr(el), folder.fold_expr(er))\n-            }\n-            ExprKind::AssignOp(op, el, er) => {\n-                ExprKind::AssignOp(op,\n-                            folder.fold_expr(el),\n-                            folder.fold_expr(er))\n-            }\n-            ExprKind::Field(el, ident) => {\n-                ExprKind::Field(folder.fold_expr(el), folder.fold_ident(ident))\n-            }\n-            ExprKind::Index(el, er) => {\n-                ExprKind::Index(folder.fold_expr(el), folder.fold_expr(er))\n-            }\n-            ExprKind::Range(e1, e2, lim) => {\n-                ExprKind::Range(e1.map(|x| folder.fold_expr(x)),\n-                                e2.map(|x| folder.fold_expr(x)),\n-                                lim)\n-            }\n-            ExprKind::Path(qself, path) => {\n-                ExprKind::Path(folder.fold_qself(qself), folder.fold_path(path))\n-            }\n-            ExprKind::Break(opt_label, opt_expr) => {\n-                ExprKind::Break(opt_label.map(|label| folder.fold_label(label)),\n-                                opt_expr.map(|e| folder.fold_expr(e)))\n-            }\n-            ExprKind::Continue(opt_label) => {\n-                ExprKind::Continue(opt_label.map(|label| folder.fold_label(label)))\n-            }\n-            ExprKind::Ret(e) => ExprKind::Ret(e.map(|x| folder.fold_expr(x))),\n-            ExprKind::InlineAsm(asm) => ExprKind::InlineAsm(asm.map(|asm| {\n-                InlineAsm {\n-                    inputs: asm.inputs.move_map(|(c, input)| {\n-                        (c, folder.fold_expr(input))\n-                    }),\n-                    outputs: asm.outputs.move_map(|out| {\n-                        InlineAsmOutput {\n-                            constraint: out.constraint,\n-                            expr: folder.fold_expr(out.expr),\n-                            is_rw: out.is_rw,\n-                            is_indirect: out.is_indirect,\n-                        }\n-                    }),\n-                    ..asm\n-                }\n-            })),\n-            ExprKind::Mac(mac) => ExprKind::Mac(folder.fold_mac(mac)),\n-            ExprKind::Struct(path, fields, maybe_expr) => {\n-                ExprKind::Struct(folder.fold_path(path),\n-                        fields.move_map(|x| folder.fold_field(x)),\n-                        maybe_expr.map(|x| folder.fold_expr(x)))\n-            },\n-            ExprKind::Paren(ex) => {\n-                let sub_expr = folder.fold_expr(ex);\n-                return Expr {\n-                    // Nodes that are equal modulo `Paren` sugar no-ops should have the same ids.\n-                    id: sub_expr.id,\n-                    node: ExprKind::Paren(sub_expr),\n-                    span: folder.new_span(span),\n-                    attrs: fold_attrs(attrs.into(), folder).into(),\n-                };\n+pub fn noop_visit_anon_const<T: MutVisitor>(AnonConst { id, value }: &mut AnonConst, vis: &mut T) {\n+    vis.visit_id(id);\n+    vis.visit_expr(value);\n+}\n+\n+pub fn noop_visit_expr<T: MutVisitor>(Expr { node, id, span, attrs }: &mut Expr, vis: &mut T) {\n+    match node {\n+        ExprKind::Box(expr) => vis.visit_expr(expr),\n+        ExprKind::ObsoleteInPlace(a, b) => {\n+            vis.visit_expr(a);\n+            vis.visit_expr(b);\n+        }\n+        ExprKind::Array(exprs) => visit_exprs(exprs, vis),\n+        ExprKind::Repeat(expr, count) => {\n+            vis.visit_expr(expr);\n+            vis.visit_anon_const(count);\n+        }\n+        ExprKind::Tup(exprs) => visit_exprs(exprs, vis),\n+        ExprKind::Call(f, args) => {\n+            vis.visit_expr(f);\n+            visit_exprs(args, vis);\n+        }\n+        ExprKind::MethodCall(PathSegment { ident, id, args }, exprs) => {\n+            vis.visit_ident(ident);\n+            vis.visit_id(id);\n+            visit_opt(args, |args| vis.visit_generic_args(args));\n+            visit_exprs(exprs, vis);\n+        }\n+        ExprKind::Binary(_binop, lhs, rhs) => {\n+            vis.visit_expr(lhs);\n+            vis.visit_expr(rhs);\n+        }\n+        ExprKind::Unary(_unop, ohs) => vis.visit_expr(ohs),\n+        ExprKind::Lit(_lit) => {}\n+        ExprKind::Cast(expr, ty) => {\n+            vis.visit_expr(expr);\n+            vis.visit_ty(ty);\n+        }\n+        ExprKind::Type(expr, ty) => {\n+            vis.visit_expr(expr);\n+            vis.visit_ty(ty);\n+        }\n+        ExprKind::AddrOf(_m, ohs) => vis.visit_expr(ohs),\n+        ExprKind::If(cond, tr, fl) => {\n+            vis.visit_expr(cond);\n+            vis.visit_block(tr);\n+            visit_opt(fl, |fl| vis.visit_expr(fl));\n+        }\n+        ExprKind::IfLet(pats, expr, tr, fl) => {\n+            visit_vec(pats, |pat| vis.visit_pat(pat));\n+            vis.visit_expr(expr);\n+            vis.visit_block(tr);\n+            visit_opt(fl, |fl| vis.visit_expr(fl));\n+        }\n+        ExprKind::While(cond, body, label) => {\n+            vis.visit_expr(cond);\n+            vis.visit_block(body);\n+            visit_opt(label, |label| vis.visit_label(label));\n+        }\n+        ExprKind::WhileLet(pats, expr, body, label) => {\n+            visit_vec(pats, |pat| vis.visit_pat(pat));\n+            vis.visit_expr(expr);\n+            vis.visit_block(body);\n+            visit_opt(label, |label| vis.visit_label(label));\n+        }\n+        ExprKind::ForLoop(pat, iter, body, label) => {\n+            vis.visit_pat(pat);\n+            vis.visit_expr(iter);\n+            vis.visit_block(body);\n+            visit_opt(label, |label| vis.visit_label(label));\n+        }\n+        ExprKind::Loop(body, label) => {\n+            vis.visit_block(body);\n+            visit_opt(label, |label| vis.visit_label(label));\n+        }\n+        ExprKind::Match(expr, arms) => {\n+            vis.visit_expr(expr);\n+            visit_vec(arms, |arm| vis.visit_arm(arm));\n+        }\n+        ExprKind::Closure(_capture_by, asyncness, _movability, decl, body, span) => {\n+            vis.visit_asyncness(asyncness);\n+            vis.visit_fn_decl(decl);\n+            vis.visit_expr(body);\n+            vis.visit_span(span);\n+        }\n+        ExprKind::Block(blk, label) => {\n+            vis.visit_block(blk);\n+            visit_opt(label, |label| vis.visit_label(label));\n+        }\n+        ExprKind::Async(_capture_by, node_id, body) => {\n+            vis.visit_id(node_id);\n+            vis.visit_block(body);\n+        }\n+        ExprKind::Assign(el, er) => {\n+            vis.visit_expr(el);\n+            vis.visit_expr(er);\n+        }\n+        ExprKind::AssignOp(_op, el, er) => {\n+            vis.visit_expr(el);\n+            vis.visit_expr(er);\n+        }\n+        ExprKind::Field(el, ident) => {\n+            vis.visit_expr(el);\n+            vis.visit_ident(ident);\n+        }\n+        ExprKind::Index(el, er) => {\n+            vis.visit_expr(el);\n+            vis.visit_expr(er);\n+        }\n+        ExprKind::Range(e1, e2, _lim) => {\n+            visit_opt(e1, |e1| vis.visit_expr(e1));\n+            visit_opt(e2, |e2| vis.visit_expr(e2));\n+        }\n+        ExprKind::Path(qself, path) => {\n+            vis.visit_qself(qself);\n+            vis.visit_path(path);\n+        }\n+        ExprKind::Break(label, expr) => {\n+            visit_opt(label, |label| vis.visit_label(label));\n+            visit_opt(expr, |expr| vis.visit_expr(expr));\n+        }\n+        ExprKind::Continue(label) => {\n+            visit_opt(label, |label| vis.visit_label(label));\n+        }\n+        ExprKind::Ret(expr) => {\n+            visit_opt(expr, |expr| vis.visit_expr(expr));\n+        }\n+        ExprKind::InlineAsm(asm) => {\n+            let InlineAsm { asm: _, asm_str_style: _, outputs, inputs, clobbers: _, volatile: _,\n+                            alignstack: _, dialect: _, ctxt: _ } = asm.deref_mut();\n+            for out in outputs {\n+                let InlineAsmOutput { constraint: _, expr, is_rw: _, is_indirect: _ } = out;\n+                vis.visit_expr(expr);\n             }\n-            ExprKind::Yield(ex) => ExprKind::Yield(ex.map(|x| folder.fold_expr(x))),\n-            ExprKind::Try(ex) => ExprKind::Try(folder.fold_expr(ex)),\n-            ExprKind::TryBlock(body) => ExprKind::TryBlock(folder.fold_block(body)),\n-            ExprKind::Err => ExprKind::Err,\n+            visit_vec(inputs, |(_c, expr)| vis.visit_expr(expr));\n+        }\n+        ExprKind::Mac(mac) => vis.visit_mac(mac),\n+        ExprKind::Struct(path, fields, expr) => {\n+            vis.visit_path(path);\n+            visit_vec(fields, |field| vis.visit_field(field));\n+            visit_opt(expr, |expr| vis.visit_expr(expr));\n         },\n-        id: folder.new_id(id),\n-        span: folder.new_span(span),\n-        attrs: fold_attrs(attrs.into(), folder).into(),\n+        ExprKind::Paren(expr) => {\n+            vis.visit_expr(expr);\n+\n+            // Nodes that are equal modulo `Paren` sugar no-ops should have the same ids.\n+            *id = expr.id;\n+            vis.visit_span(span);\n+            visit_thin_attrs(attrs, vis);\n+            return;\n+        }\n+        ExprKind::Yield(expr) => {\n+            visit_opt(expr, |expr| vis.visit_expr(expr));\n+        }\n+        ExprKind::Try(expr) => vis.visit_expr(expr),\n+        ExprKind::TryBlock(body) => vis.visit_block(body),\n+        ExprKind::Err => {}\n     }\n+    vis.visit_id(id);\n+    vis.visit_span(span);\n+    visit_thin_attrs(attrs, vis);\n }\n \n-pub fn noop_fold_opt_expr<T: Folder>(e: P<Expr>, folder: &mut T) -> Option<P<Expr>> {\n-    Some(folder.fold_expr(e))\n+pub fn noop_filter_map_expr<T: MutVisitor>(mut e: P<Expr>, vis: &mut T) -> Option<P<Expr>> {\n+    Some({ vis.visit_expr(&mut e); e })\n }\n \n-pub fn noop_fold_stmt<T: Folder>(Stmt {node, span, id}: Stmt, folder: &mut T) -> SmallVec<[Stmt; 1]>\n+pub fn noop_flat_map_stmt<T: MutVisitor>(Stmt { node, mut span, mut id }: Stmt, vis: &mut T)\n+    -> SmallVec<[Stmt; 1]>\n {\n-    let id = folder.new_id(id);\n-    let span = folder.new_span(span);\n-    noop_fold_stmt_kind(node, folder).into_iter().map(|node| {\n-        Stmt { id: id, node: node, span: span }\n+    vis.visit_id(&mut id);\n+    vis.visit_span(&mut span);\n+    noop_flat_map_stmt_kind(node, vis).into_iter().map(|node| {\n+        Stmt { id, node, span }\n     }).collect()\n }\n \n-pub fn noop_fold_stmt_kind<T: Folder>(node: StmtKind, folder: &mut T) -> SmallVec<[StmtKind; 1]> {\n+pub fn noop_flat_map_stmt_kind<T: MutVisitor>(node: StmtKind, vis: &mut T)\n+                                              -> SmallVec<[StmtKind; 1]> {\n     match node {\n-        StmtKind::Local(local) => smallvec![StmtKind::Local(folder.fold_local(local))],\n-        StmtKind::Item(item) => folder.fold_item(item).into_iter().map(StmtKind::Item).collect(),\n+        StmtKind::Local(mut local) =>\n+            smallvec![StmtKind::Local({ vis.visit_local(&mut local); local })],\n+        StmtKind::Item(item) => vis.flat_map_item(item).into_iter().map(StmtKind::Item).collect(),\n         StmtKind::Expr(expr) => {\n-            folder.fold_opt_expr(expr).into_iter().map(StmtKind::Expr).collect()\n+            vis.filter_map_expr(expr).into_iter().map(StmtKind::Expr).collect()\n         }\n         StmtKind::Semi(expr) => {\n-            folder.fold_opt_expr(expr).into_iter().map(StmtKind::Semi).collect()\n+            vis.filter_map_expr(expr).into_iter().map(StmtKind::Semi).collect()\n+        }\n+        StmtKind::Mac(mut mac) => {\n+            let (mac_, _semi, attrs) = mac.deref_mut();\n+            vis.visit_mac(mac_);\n+            visit_thin_attrs(attrs, vis);\n+            smallvec![StmtKind::Mac(mac)]\n         }\n-        StmtKind::Mac(mac) => smallvec![StmtKind::Mac(mac.map(|(mac, semi, attrs)| {\n-            (folder.fold_mac(mac), semi, fold_attrs(attrs.into(), folder).into())\n-        }))],\n     }\n }\n \n-pub fn noop_fold_vis<T: Folder>(Spanned { node, span }: Visibility, folder: &mut T) -> Visibility {\n-    Visibility {\n-        node: match node {\n-            VisibilityKind::Public => VisibilityKind::Public,\n-            VisibilityKind::Crate(sugar) => VisibilityKind::Crate(sugar),\n-            VisibilityKind::Restricted { path, id } => {\n-                VisibilityKind::Restricted {\n-                    path: path.map(|path| folder.fold_path(path)),\n-                    id: folder.new_id(id),\n-                }\n-            }\n-            VisibilityKind::Inherited => VisibilityKind::Inherited,\n-        },\n-        span: folder.new_span(span),\n+pub fn noop_visit_vis<T: MutVisitor>(Spanned { node, span }: &mut Visibility, vis: &mut T) {\n+    match node {\n+        VisibilityKind::Public | VisibilityKind::Crate(_) | VisibilityKind::Inherited => {}\n+        VisibilityKind::Restricted { path, id } => {\n+            vis.visit_path(path);\n+            vis.visit_id(id);\n+        }\n     }\n+    vis.visit_span(span);\n }\n \n #[cfg(test)]\n@@ -1342,7 +1259,7 @@ mod tests {\n     use ast::{self, Ident};\n     use util::parser_testing::{string_to_crate, matches_codepattern};\n     use print::pprust;\n-    use fold;\n+    use mut_visit;\n     use with_globals;\n     use super::*;\n \n@@ -1353,14 +1270,14 @@ mod tests {\n     }\n \n     // change every identifier to \"zz\"\n-    struct ToZzIdentFolder;\n+    struct ToZzIdentMutVisitor;\n \n-    impl Folder for ToZzIdentFolder {\n-        fn fold_ident(&mut self, _: ast::Ident) -> ast::Ident {\n-            Ident::from_str(\"zz\")\n+    impl MutVisitor for ToZzIdentMutVisitor {\n+        fn visit_ident(&mut self, ident: &mut ast::Ident) {\n+            *ident = Ident::from_str(\"zz\");\n         }\n-        fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-            fold::noop_fold_mac(mac, self)\n+        fn visit_mac(&mut self, mac: &mut ast::Mac) {\n+            mut_visit::noop_visit_mac(mac, self)\n         }\n     }\n \n@@ -1382,31 +1299,32 @@ mod tests {\n     // make sure idents get transformed everywhere\n     #[test] fn ident_transformation () {\n         with_globals(|| {\n-            let mut zz_fold = ToZzIdentFolder;\n-            let ast = string_to_crate(\n+            let mut zz_visitor = ToZzIdentMutVisitor;\n+            let mut krate = string_to_crate(\n                 \"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\".to_string());\n-            let folded_crate = zz_fold.fold_crate(ast);\n+            zz_visitor.visit_crate(&mut krate);\n             assert_pred!(\n                 matches_codepattern,\n                 \"matches_codepattern\",\n-                pprust::to_string(|s| fake_print_crate(s, &folded_crate)),\n+                pprust::to_string(|s| fake_print_crate(s, &krate)),\n                 \"#[zz]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\".to_string());\n         })\n     }\n \n     // even inside macro defs....\n     #[test] fn ident_transformation_in_defs () {\n         with_globals(|| {\n-            let mut zz_fold = ToZzIdentFolder;\n-            let ast = string_to_crate(\n+            let mut zz_visitor = ToZzIdentMutVisitor;\n+            let mut krate = string_to_crate(\n                 \"macro_rules! a {(b $c:expr $(d $e:token)f+ => \\\n                 (g $(d $d $e)+))} \".to_string());\n-            let folded_crate = zz_fold.fold_crate(ast);\n+            zz_visitor.visit_crate(&mut krate);\n             assert_pred!(\n                 matches_codepattern,\n                 \"matches_codepattern\",\n-                pprust::to_string(|s| fake_print_crate(s, &folded_crate)),\n+                pprust::to_string(|s| fake_print_crate(s, &krate)),\n                 \"macro_rules! zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)));\".to_string());\n         })\n     }\n }\n+"}, {"sha": "dacb0d811cedb14b93777b21599e6db4381dec33", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -133,7 +133,7 @@ pub mod util {\n     pub mod parser;\n     #[cfg(test)]\n     pub mod parser_testing;\n-    pub mod move_map;\n+    pub mod map_in_place;\n }\n \n pub mod json;\n@@ -151,7 +151,7 @@ pub mod source_map;\n pub mod config;\n pub mod entry;\n pub mod feature_gate;\n-pub mod fold;\n+#[path=\"fold.rs\"] pub mod mut_visit;    // temporary\n pub mod parse;\n pub mod ptr;\n pub mod show_span;"}, {"sha": "a9f3acecc818bc7e326bbd07314e54be6a79e916", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -7046,7 +7046,8 @@ impl<'a> Parser<'a> {\n                 sess: self.sess,\n                 features: None, // don't perform gated feature checking\n             };\n-            let outer_attrs = strip_unconfigured.process_cfg_attrs(outer_attrs.to_owned());\n+            let mut outer_attrs = outer_attrs.to_owned();\n+            strip_unconfigured.process_cfg_attrs(&mut outer_attrs);\n             (!self.cfg_mods || strip_unconfigured.in_cfg(&outer_attrs), outer_attrs)\n         };\n "}, {"sha": "5181bb8f34e663ea4ac5924f48ef54dbd9996fa0", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -735,7 +735,7 @@ impl fmt::Debug for LazyTokenStream {\n }\n \n impl LazyTokenStream {\n-    fn new() -> Self {\n+    pub fn new() -> Self {\n         LazyTokenStream(Lock::new(None))\n     }\n "}, {"sha": "12f82a01dcfcdbfe0f0d04920f264f67bc3c09f2", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -20,10 +20,9 @@ use ext::base::{ExtCtxt, Resolver};\n use ext::build::AstBuilder;\n use ext::expand::ExpansionConfig;\n use ext::hygiene::{self, Mark, SyntaxContext};\n-use fold::Folder;\n+use mut_visit::{*, ExpectOne};\n use feature_gate::Features;\n-use util::move_map::MoveMap;\n-use fold::{self, ExpectOne};\n+use util::map_in_place::MapInPlace;\n use parse::{token, ParseSess};\n use print::pprust;\n use ast::{self, Ident};\n@@ -57,9 +56,9 @@ struct TestCtxt<'a> {\n pub fn modify_for_testing(sess: &ParseSess,\n                           resolver: &mut dyn Resolver,\n                           should_test: bool,\n-                          krate: ast::Crate,\n+                          krate: &mut ast::Crate,\n                           span_diagnostic: &errors::Handler,\n-                          features: &Features) -> ast::Crate {\n+                          features: &Features) {\n     // Check for #[reexport_test_harness_main = \"some_name\"] which\n     // creates a `use __test::main as some_name;`. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n@@ -75,8 +74,6 @@ pub fn modify_for_testing(sess: &ParseSess,\n     if should_test {\n         generate_test_harness(sess, resolver, reexport_test_harness_main,\n                               krate, span_diagnostic, features, test_runner)\n-    } else {\n-        krate\n     }\n }\n \n@@ -88,21 +85,20 @@ struct TestHarnessGenerator<'a> {\n     tested_submods: Vec<(Ident, Ident)>,\n }\n \n-impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n-    fn fold_crate(&mut self, c: ast::Crate) -> ast::Crate {\n-        let mut folded = fold::noop_fold_crate(c, self);\n+impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n+    fn visit_crate(&mut self, c: &mut ast::Crate) {\n+        noop_visit_crate(c, self);\n \n         // Create a main function to run our tests\n         let test_main = {\n             let unresolved = mk_main(&mut self.cx);\n-            self.cx.ext_cx.monotonic_expander().fold_item(unresolved).pop().unwrap()\n+            self.cx.ext_cx.monotonic_expander().flat_map_item(unresolved).pop().unwrap()\n         };\n \n-        folded.module.items.push(test_main);\n-        folded\n+        c.module.items.push(test_main);\n     }\n \n-    fn fold_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n+    fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let ident = i.ident;\n         if ident.name != keywords::Invalid.name() {\n             self.cx.path.push(ident);\n@@ -123,16 +119,16 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n-        if let ast::ItemKind::Mod(module) = item.node {\n+        if let ast::ItemKind::Mod(mut module) = item.node {\n             let tests = mem::replace(&mut self.tests, Vec::new());\n             let tested_submods = mem::replace(&mut self.tested_submods, Vec::new());\n-            let mut mod_folded = fold::noop_fold_mod(module, self);\n+            noop_visit_mod(&mut module, self);\n             let tests = mem::replace(&mut self.tests, tests);\n             let tested_submods = mem::replace(&mut self.tested_submods, tested_submods);\n \n             if !tests.is_empty() || !tested_submods.is_empty() {\n                 let (it, sym) = mk_reexport_mod(&mut self.cx, item.id, tests, tested_submods);\n-                mod_folded.items.push(it);\n+                module.items.push(it);\n \n                 if !self.cx.path.is_empty() {\n                     self.tested_submods.push((self.cx.path[self.cx.path.len()-1], sym));\n@@ -141,15 +137,17 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                     self.cx.toplevel_reexport = Some(sym);\n                 }\n             }\n-            item.node = ast::ItemKind::Mod(mod_folded);\n+            item.node = ast::ItemKind::Mod(module);\n         }\n         if ident.name != keywords::Invalid.name() {\n             self.cx.path.pop();\n         }\n         smallvec![P(item)]\n     }\n \n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n+    fn visit_mac(&mut self, _mac: &mut ast::Mac) {\n+        // Do nothing.\n+    }\n }\n \n /// A folder used to remove any entry points (like fn main) because the harness\n@@ -159,20 +157,20 @@ struct EntryPointCleaner {\n     depth: usize,\n }\n \n-impl fold::Folder for EntryPointCleaner {\n-    fn fold_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n+impl MutVisitor for EntryPointCleaner {\n+    fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         self.depth += 1;\n-        let folded = fold::noop_fold_item(i, self).expect_one(\"noop did something\");\n+        let item = noop_flat_map_item(i, self).expect_one(\"noop did something\");\n         self.depth -= 1;\n \n         // Remove any #[main] or #[start] from the AST so it doesn't\n         // clash with the one we're going to add, but mark it as\n         // #[allow(dead_code)] to avoid printing warnings.\n-        let folded = match entry::entry_point_type(&folded, self.depth) {\n+        let item = match entry::entry_point_type(&item, self.depth) {\n             EntryPointType::MainNamed |\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n-                folded.map(|ast::Item {id, ident, attrs, node, vis, span, tokens}| {\n+                item.map(|ast::Item {id, ident, attrs, node, vis, span, tokens}| {\n                     let allow_ident = Ident::from_str(\"allow\");\n                     let dc_nested = attr::mk_nested_word_item(Ident::from_str(\"dead_code\"));\n                     let allow_dead_code_item = attr::mk_list_item(DUMMY_SP, allow_ident,\n@@ -197,13 +195,15 @@ impl fold::Folder for EntryPointCleaner {\n                     }\n                 }),\n             EntryPointType::None |\n-            EntryPointType::OtherMain => folded,\n+            EntryPointType::OtherMain => item,\n         };\n \n-        smallvec![folded]\n+        smallvec![item]\n     }\n \n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n+    fn visit_mac(&mut self, _mac: &mut ast::Mac) {\n+        // Do nothing.\n+    }\n }\n \n /// Creates an item (specifically a module) that \"pub use\"s the tests passed in.\n@@ -235,7 +235,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n     let sym = Ident::with_empty_ctxt(Symbol::gensym(\"__test_reexports\"));\n     let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n     cx.ext_cx.current_expansion.mark = cx.ext_cx.resolver.get_module_scope(parent);\n-    let it = cx.ext_cx.monotonic_expander().fold_item(P(ast::Item {\n+    let it = cx.ext_cx.monotonic_expander().flat_map_item(P(ast::Item {\n         ident: sym,\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n@@ -252,13 +252,13 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n fn generate_test_harness(sess: &ParseSess,\n                          resolver: &mut dyn Resolver,\n                          reexport_test_harness_main: Option<Symbol>,\n-                         krate: ast::Crate,\n+                         krate: &mut ast::Crate,\n                          sd: &errors::Handler,\n                          features: &Features,\n-                         test_runner: Option<ast::Path>) -> ast::Crate {\n+                         test_runner: Option<ast::Path>) {\n     // Remove the entry points\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n-    let krate = cleaner.fold_crate(krate);\n+    cleaner.visit_crate(krate);\n \n     let mark = Mark::fresh(Mark::root());\n \n@@ -293,7 +293,7 @@ fn generate_test_harness(sess: &ParseSess,\n         cx,\n         tests: Vec::new(),\n         tested_submods: Vec::new(),\n-    }.fold_crate(krate)\n+    }.visit_crate(krate);\n }\n \n /// Craft a span that will be ignored by the stability lint's"}, {"sha": "ff5978a7ee58182ab49d9c96f6239026174f7b68", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -147,7 +147,7 @@ impl TokenTree {\n /// empty stream is represented with `None`; it may be represented as a `Some`\n /// around an empty `Vec`.\n #[derive(Clone, Debug)]\n-pub struct TokenStream(Option<Lrc<Vec<TreeAndJoint>>>);\n+pub struct TokenStream(pub Option<Lrc<Vec<TreeAndJoint>>>);\n \n pub type TreeAndJoint = (TokenTree, IsJoint);\n "}, {"sha": "5724b540a0dcfb51206bb69300296c419dcc40cc", "filename": "src/libsyntax/util/map_in_place.rs", "status": "renamed", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Futil%2Fmap_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax%2Futil%2Fmap_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fmap_in_place.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -1,18 +1,18 @@\n use std::ptr;\n use smallvec::{Array, SmallVec};\n \n-pub trait MoveMap<T>: Sized {\n-    fn move_map<F>(self, mut f: F) -> Self where F: FnMut(T) -> T {\n-        self.move_flat_map(|e| Some(f(e)))\n+pub trait MapInPlace<T>: Sized {\n+    fn map_in_place<F>(&mut self, mut f: F) where F: FnMut(T) -> T {\n+        self.flat_map_in_place(|e| Some(f(e)))\n     }\n \n-    fn move_flat_map<F, I>(self, f: F) -> Self\n+    fn flat_map_in_place<F, I>(&mut self, f: F)\n         where F: FnMut(T) -> I,\n               I: IntoIterator<Item=T>;\n }\n \n-impl<T> MoveMap<T> for Vec<T> {\n-    fn move_flat_map<F, I>(mut self, mut f: F) -> Self\n+impl<T> MapInPlace<T> for Vec<T> {\n+    fn flat_map_in_place<F, I>(&mut self, mut f: F)\n         where F: FnMut(T) -> I,\n               I: IntoIterator<Item=T>\n     {\n@@ -53,22 +53,11 @@ impl<T> MoveMap<T> for Vec<T> {\n             // write_i tracks the number of actually written new items.\n             self.set_len(write_i);\n         }\n-\n-        self\n-    }\n-}\n-\n-impl<T> MoveMap<T> for ::ptr::P<[T]> {\n-    fn move_flat_map<F, I>(self, f: F) -> Self\n-        where F: FnMut(T) -> I,\n-              I: IntoIterator<Item=T>\n-    {\n-        ::ptr::P::from_vec(self.into_vec().move_flat_map(f))\n     }\n }\n \n-impl<T, A: Array<Item = T>> MoveMap<T> for SmallVec<A> {\n-    fn move_flat_map<F, I>(mut self, mut f: F) -> Self\n+impl<T, A: Array<Item = T>> MapInPlace<T> for SmallVec<A> {\n+    fn flat_map_in_place<F, I>(&mut self, mut f: F)\n         where F: FnMut(T) -> I,\n               I: IntoIterator<Item=T>\n     {\n@@ -109,7 +98,5 @@ impl<T, A: Array<Item = T>> MoveMap<T> for SmallVec<A> {\n             // write_i tracks the number of actually written new items.\n             self.set_len(write_i);\n         }\n-\n-        self\n     }\n }", "previous_filename": "src/libsyntax/util/move_map.rs"}, {"sha": "ec2c3113fab95268fd7751e9c9071f6cf317b8cf", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -189,7 +189,7 @@ use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::source_map::{self, respan};\n-use syntax::util::move_map::MoveMap;\n+use syntax::util::map_in_place::MapInPlace;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::parse::ParseSess;\n@@ -1184,7 +1184,7 @@ impl<'a> MethodDef<'a> {\n                                   enum_def: &'b EnumDef,\n                                   type_attrs: &[ast::Attribute],\n                                   type_ident: Ident,\n-                                  self_args: Vec<P<Expr>>,\n+                                  mut self_args: Vec<P<Expr>>,\n                                   nonself_args: &[P<Expr>])\n                                   -> P<Expr> {\n         let sp = trait_.span;\n@@ -1417,8 +1417,8 @@ impl<'a> MethodDef<'a> {\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-            let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n-            let match_arg = cx.expr(sp, ast::ExprKind::Tup(borrowed_self_args));\n+            self_args.map_in_place(|self_arg| cx.expr_addr_of(sp, self_arg));\n+            let match_arg = cx.expr(sp, ast::ExprKind::Tup(self_args));\n \n             // Lastly we create an expression which branches on all discriminants being equal\n             //  if discriminant_test {\n@@ -1494,8 +1494,8 @@ impl<'a> MethodDef<'a> {\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-            let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n-            let match_arg = cx.expr(sp, ast::ExprKind::Tup(borrowed_self_args));\n+            self_args.map_in_place(|self_arg| cx.expr_addr_of(sp, self_arg));\n+            let match_arg = cx.expr(sp, ast::ExprKind::Tup(self_args));\n             cx.expr_match(sp, match_arg, match_arms)\n         }\n     }"}, {"sha": "663fb12242c44291ac0df9b6d59aef92bfaa7d87", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -9,7 +9,7 @@ use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::ext::hygiene::Mark;\n-use syntax::fold::Folder;\n+use syntax::mut_visit::MutVisitor;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n@@ -412,5 +412,5 @@ fn mk_decls(\n         i\n     });\n \n-    cx.monotonic_expander().fold_item(module).pop().unwrap()\n+    cx.monotonic_expander().flat_map_item(module).pop().unwrap()\n }"}, {"sha": "ee4ecde44f28e3f3b8e47991ef971c7545cf0d8f", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -27,7 +27,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use syntax::ast::*;\n use syntax::source_map::{Spanned, DUMMY_SP, FileName};\n use syntax::source_map::FilePathMapping;\n-use syntax::fold::{self, Folder};\n+use syntax::mut_visit::{self, MutVisitor, visit_clobber};\n use syntax::parse::{self, ParseSess};\n use syntax::print::pprust;\n use syntax::ptr::P;\n@@ -157,32 +157,34 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n \n // Folders for manipulating the placement of `Paren` nodes.  See below for why this is needed.\n \n-/// Folder that removes all `ExprKind::Paren` nodes.\n+/// MutVisitor that removes all `ExprKind::Paren` nodes.\n struct RemoveParens;\n \n-impl Folder for RemoveParens {\n-    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n-        let e = match e.node {\n-            ExprKind::Paren(ref inner) => inner.clone(),\n-            _ => e.clone(),\n+impl MutVisitor for RemoveParens {\n+    fn visit_expr(&mut self, e: &mut P<Expr>) {\n+        match e.node.clone() {\n+            ExprKind::Paren(inner) => *e = inner,\n+            _ => {}\n         };\n-        e.map(|e| fold::noop_fold_expr(e, self))\n+        mut_visit::noop_visit_expr(e, self);\n     }\n }\n \n \n-/// Folder that inserts `ExprKind::Paren` nodes around every `Expr`.\n+/// MutVisitor that inserts `ExprKind::Paren` nodes around every `Expr`.\n struct AddParens;\n \n-impl Folder for AddParens {\n-    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n-        let e = e.map(|e| fold::noop_fold_expr(e, self));\n-        P(Expr {\n-            id: DUMMY_NODE_ID,\n-            node: ExprKind::Paren(e),\n-            span: DUMMY_SP,\n-            attrs: ThinVec::new(),\n-        })\n+impl MutVisitor for AddParens {\n+    fn visit_expr(&mut self, e: &mut P<Expr>) {\n+        mut_visit::noop_visit_expr(e, self);\n+        visit_clobber(e, |e| {\n+            P(Expr {\n+                id: DUMMY_NODE_ID,\n+                node: ExprKind::Paren(e),\n+                span: DUMMY_SP,\n+                attrs: ThinVec::new(),\n+            })\n+        });\n     }\n }\n \n@@ -193,24 +195,26 @@ fn main() {\n fn run() {\n     let ps = ParseSess::new(FilePathMapping::empty());\n \n-    iter_exprs(2, &mut |e| {\n+    iter_exprs(2, &mut |mut e| {\n         // If the pretty printer is correct, then `parse(print(e))` should be identical to `e`,\n         // modulo placement of `Paren` nodes.\n         let printed = pprust::expr_to_string(&e);\n         println!(\"printed: {}\", printed);\n \n-        let parsed = parse_expr(&ps, &printed);\n+        let mut parsed = parse_expr(&ps, &printed);\n \n         // We want to know if `parsed` is structurally identical to `e`, ignoring trivial\n         // differences like placement of `Paren`s or the exact ranges of node spans.\n         // Unfortunately, there is no easy way to make this comparison.  Instead, we add `Paren`s\n         // everywhere we can, then pretty-print.  This should give an unambiguous representation of\n         // each `Expr`, and it bypasses nearly all of the parenthesization logic, so we aren't\n         // relying on the correctness of the very thing we're testing.\n-        let e1 = AddParens.fold_expr(RemoveParens.fold_expr(e));\n-        let text1 = pprust::expr_to_string(&e1);\n-        let e2 = AddParens.fold_expr(RemoveParens.fold_expr(parsed));\n-        let text2 = pprust::expr_to_string(&e2);\n+        RemoveParens.visit_expr(&mut e);\n+        AddParens.visit_expr(&mut e);\n+        let text1 = pprust::expr_to_string(&e);\n+        RemoveParens.visit_expr(&mut parsed);\n+        AddParens.visit_expr(&mut parsed);\n+        let text2 = pprust::expr_to_string(&parsed);\n         assert!(text1 == text2,\n                 \"exprs are not equal:\\n  e =      {:?}\\n  parsed = {:?}\",\n                 text1, text2);"}, {"sha": "ad410f30c04d4cb4297987f22a80e3865c26372c", "filename": "src/test/ui/issues/issue-49934.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Ftest%2Fui%2Fissues%2Fissue-49934.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fcb1658ab13a7f722e4747c5a4b691291e88a3b/src%2Ftest%2Fui%2Fissues%2Fissue-49934.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49934.rs?ref=9fcb1658ab13a7f722e4747c5a4b691291e88a3b", "patch": "@@ -30,12 +30,12 @@ fn main() {\n     #[derive(Debug)] //~ WARN unused attribute\n     let _ = \"Hello, world!\";\n \n-    // fold_expr\n+    // visit_expr\n     let _ = #[derive(Debug)] \"Hello, world!\";\n     //~^ WARN unused attribute\n \n     let _ = [\n-        // fold_opt_expr\n+        // filter_map_expr\n         #[derive(Debug)] //~ WARN unused attribute\n         \"Hello, world!\"\n     ];"}]}