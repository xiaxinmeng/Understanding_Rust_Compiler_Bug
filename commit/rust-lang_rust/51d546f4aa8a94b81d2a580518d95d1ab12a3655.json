{"sha": "51d546f4aa8a94b81d2a580518d95d1ab12a3655", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxZDU0NmY0YWE4YTk0YjgxZDJhNTgwNTE4ZDk1ZDFhYjEyYTM2NTU=", "commit": {"author": {"name": "Sebastian Dr\u00f6ge", "email": "sebastian@centricular.com", "date": "2018-01-02T00:13:20Z"}, "committer": {"name": "Sebastian Dr\u00f6ge", "email": "sebastian@centricular.com", "date": "2018-01-13T10:18:46Z"}, "message": "Add slice::ExactChunks and ::ExactChunksMut iterators\n\nThese guarantee that always the requested slice size will be returned\nand any leftoever elements at the end will be ignored. It allows llvm to\nget rid of bounds checks in the code using the iterator.\n\nThis is inspired by the same iterators provided by ndarray.\n\nSee https://github.com/rust-lang/rust/issues/47115", "tree": {"sha": "c490689fc10b38b4abf7e4494ea72d876c138ef9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c490689fc10b38b4abf7e4494ea72d876c138ef9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51d546f4aa8a94b81d2a580518d95d1ab12a3655", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51d546f4aa8a94b81d2a580518d95d1ab12a3655", "html_url": "https://github.com/rust-lang/rust/commit/51d546f4aa8a94b81d2a580518d95d1ab12a3655", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51d546f4aa8a94b81d2a580518d95d1ab12a3655/comments", "author": {"login": "sdroege", "id": 301846, "node_id": "MDQ6VXNlcjMwMTg0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/301846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdroege", "html_url": "https://github.com/sdroege", "followers_url": "https://api.github.com/users/sdroege/followers", "following_url": "https://api.github.com/users/sdroege/following{/other_user}", "gists_url": "https://api.github.com/users/sdroege/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdroege/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdroege/subscriptions", "organizations_url": "https://api.github.com/users/sdroege/orgs", "repos_url": "https://api.github.com/users/sdroege/repos", "events_url": "https://api.github.com/users/sdroege/events{/privacy}", "received_events_url": "https://api.github.com/users/sdroege/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sdroege", "id": 301846, "node_id": "MDQ6VXNlcjMwMTg0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/301846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdroege", "html_url": "https://github.com/sdroege", "followers_url": "https://api.github.com/users/sdroege/followers", "following_url": "https://api.github.com/users/sdroege/following{/other_user}", "gists_url": "https://api.github.com/users/sdroege/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdroege/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdroege/subscriptions", "organizations_url": "https://api.github.com/users/sdroege/orgs", "repos_url": "https://api.github.com/users/sdroege/repos", "events_url": "https://api.github.com/users/sdroege/events{/privacy}", "received_events_url": "https://api.github.com/users/sdroege/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e33c89ff1518359c4bd5fbed1571ea00cb3b146", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e33c89ff1518359c4bd5fbed1571ea00cb3b146", "html_url": "https://github.com/rust-lang/rust/commit/2e33c89ff1518359c4bd5fbed1571ea00cb3b146"}], "stats": {"total": 287, "additions": 287, "deletions": 0}, "files": [{"sha": "d8ce28695ab6f3049a6ea5e0c5ec7fe6fe8b36de", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51d546f4aa8a94b81d2a580518d95d1ab12a3655/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51d546f4aa8a94b81d2a580518d95d1ab12a3655/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=51d546f4aa8a94b81d2a580518d95d1ab12a3655", "patch": "@@ -124,6 +124,7 @@\n #![feature(unsize)]\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n+#![feature(exact_chunks)]\n \n #![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice, i128))]\n #![cfg_attr(test, feature(test, box_heap))]"}, {"sha": "bae366736379cea0b71bb56516486f0191a0939a", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/51d546f4aa8a94b81d2a580518d95d1ab12a3655/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51d546f4aa8a94b81d2a580518d95d1ab12a3655/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=51d546f4aa8a94b81d2a580518d95d1ab12a3655", "patch": "@@ -123,6 +123,8 @@ pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n pub use core::slice::{from_ref, from_ref_mut};\n #[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n pub use core::slice::SliceIndex;\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+pub use core::slice::{ExactChunks, ExactChunksMut};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods\n@@ -631,6 +633,31 @@ impl<T> [T] {\n         core_slice::SliceExt::chunks(self, chunk_size)\n     }\n \n+    /// Returns an iterator over `chunk_size` elements of the slice at a\n+    /// time. The chunks are slices and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last up to `chunk_size-1`\n+    /// elements will be omitted.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n+    /// let mut iter = slice.chunks(2);\n+    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n+    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n+    /// assert_eq!(iter.next().unwrap(), &['m']);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    #[inline]\n+    pub fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n+        core_slice::SliceExt::exact_chunks(self, chunk_size)\n+    }\n+\n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n     /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n     /// not divide the length of the slice, then the last chunk will not\n@@ -660,6 +687,35 @@ impl<T> [T] {\n         core_slice::SliceExt::chunks_mut(self, chunk_size)\n     }\n \n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last up to `chunk_size-1`\n+    /// elements will be omitted.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = &mut [0, 0, 0, 0, 0];\n+    /// let mut count = 1;\n+    ///\n+    /// for chunk in v.exact_chunks_mut(2) {\n+    ///     for elem in chunk.iter_mut() {\n+    ///         *elem += count;\n+    ///     }\n+    ///     count += 1;\n+    /// }\n+    /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n+    /// ```\n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    #[inline]\n+    pub fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n+        core_slice::SliceExt::exact_chunks_mut(self, chunk_size)\n+    }\n+\n     /// Divides one slice into two at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding"}, {"sha": "5791b1d6e79c6325a2e9c845fe3b38cff24a0633", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/51d546f4aa8a94b81d2a580518d95d1ab12a3655/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51d546f4aa8a94b81d2a580518d95d1ab12a3655/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=51d546f4aa8a94b81d2a580518d95d1ab12a3655", "patch": "@@ -104,6 +104,9 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn chunks(&self, size: usize) -> Chunks<Self::Item>;\n \n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    fn exact_chunks(&self, size: usize) -> ExactChunks<Self::Item>;\n+\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn get<I>(&self, index: I) -> Option<&I::Output>\n         where I: SliceIndex<Self>;\n@@ -181,6 +184,9 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<Self::Item>;\n \n+    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    fn exact_chunks_mut(&mut self, size: usize) -> ExactChunksMut<Self::Item>;\n+\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn swap(&mut self, a: usize, b: usize);\n \n@@ -353,6 +359,14 @@ impl<T> SliceExt for [T] {\n         Chunks { v: self, chunk_size: chunk_size }\n     }\n \n+    #[inline]\n+    fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n+        assert!(chunk_size != 0);\n+        let rem = self.len() % chunk_size;\n+        let len = self.len() - rem;\n+        ExactChunks { v: &self[..len], chunk_size: chunk_size}\n+    }\n+\n     #[inline]\n     fn get<I>(&self, index: I) -> Option<&I::Output>\n         where I: SliceIndex<[T]>\n@@ -536,6 +550,14 @@ impl<T> SliceExt for [T] {\n         ChunksMut { v: self, chunk_size: chunk_size }\n     }\n \n+    #[inline]\n+    fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n+        assert!(chunk_size != 0);\n+        let rem = self.len() % chunk_size;\n+        let len = self.len() - rem;\n+        ExactChunksMut { v: &mut self[..len], chunk_size: chunk_size}\n+    }\n+\n     #[inline]\n     fn swap(&mut self, a: usize, b: usize) {\n         unsafe {\n@@ -2365,6 +2387,214 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n     fn may_have_side_effect() -> bool { false }\n }\n \n+/// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n+/// time).\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last\n+/// up to `chunk_size-1` elements will be omitted.\n+///\n+/// This struct is created by the [`exact_chunks`] method on [slices].\n+///\n+/// [`exact_chunks`]: ../../std/primitive.slice.html#method.exact_chunks\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+pub struct ExactChunks<'a, T:'a> {\n+    v: &'a [T],\n+    chunk_size: usize\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> Clone for ExactChunks<'a, T> {\n+    fn clone(&self) -> ExactChunks<'a, T> {\n+        ExactChunks {\n+            v: self.v,\n+            chunk_size: self.chunk_size,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> Iterator for ExactChunks<'a, T> {\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let (fst, snd) = self.v.split_at(self.chunk_size);\n+            self.v = snd;\n+            Some(fst)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.v.len() / self.chunk_size;\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n+        if start >= self.v.len() || overflow {\n+            self.v = &[];\n+            None\n+        } else {\n+            let end = match start.checked_add(self.chunk_size) {\n+                Some(sum) => cmp::min(self.v.len(), sum),\n+                None => self.v.len(),\n+            };\n+\n+            if end - start != self.chunk_size {\n+                self.v = &[];\n+                None\n+            } else {\n+                let nth = &self.v[start..end];\n+                self.v = &self.v[end..];\n+                Some(nth)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let start = self.v.len() - self.chunk_size;\n+            Some(&self.v[start..])\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> DoubleEndedIterator for ExactChunks<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let (fst, snd) = self.v.split_at(self.v.len() - self.chunk_size);\n+            self.v = fst;\n+            Some(snd)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> ExactSizeIterator for ExactChunks<'a, T> {}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<'a, T> FusedIterator for ExactChunks<'a, T> {}\n+\n+/// An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n+/// elements at a time). When the slice len is not evenly divided by the chunk\n+/// size, the last up to `chunk_size-1` elements will be omitted.\n+///\n+/// This struct is created by the [`exact_chunks_mut`] method on [slices].\n+///\n+/// [`exact_chunks_mut`]: ../../std/primitive.slice.html#method.exact_chunks_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+pub struct ExactChunksMut<'a, T:'a> {\n+    v: &'a mut [T],\n+    chunk_size: usize\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> Iterator for ExactChunksMut<'a, T> {\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n+            self.v = tail;\n+            Some(head)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.v.len() / self.chunk_size;\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n+        let (start, overflow) = n.overflowing_mul(self.chunk_size);\n+        if start >= self.v.len() || overflow {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            let end = match start.checked_add(self.chunk_size) {\n+                Some(sum) => cmp::min(self.v.len(), sum),\n+                None => self.v.len(),\n+            };\n+\n+            if end - start != self.chunk_size {\n+                self.v = &mut [];\n+                None\n+            } else {\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let (head, tail) = tmp.split_at_mut(end);\n+                let (_, nth) =  head.split_at_mut(start);\n+                self.v = tail;\n+                Some(nth)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let start = (self.v.len() - self.chunk_size) / self.chunk_size * self.chunk_size;\n+            Some(&mut self.v[start..])\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> DoubleEndedIterator for ExactChunksMut<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() < self.chunk_size {\n+            None\n+        } else {\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n+            self.v = head;\n+            Some(tail)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+impl<'a, T> ExactSizeIterator for ExactChunksMut<'a, T> {}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<'a, T> FusedIterator for ExactChunksMut<'a, T> {}\n+\n //\n // Free functions\n //"}]}