{"sha": "3a5c8e91f094bb1cb1346651fe3512f0b603d826", "node_id": "C_kwDOAAsO6NoAKDNhNWM4ZTkxZjA5NGJiMWNiMTM0NjY1MWZlMzUxMmYwYjYwM2Q4MjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-19T13:03:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-19T13:03:40Z"}, "message": "Auto merge of #110393 - fee1-dead-contrib:rm-const-traits, r=oli-obk\n\nRm const traits in libcore\n\nSee [zulip thread](https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/topic/.60const.20Trait.60.20removal.20or.20rework)\n\n* [x] Bless ui tests\n* [ ] Re constify some unstable functions with workarounds if they are needed", "tree": {"sha": "9768f32e150f510ea6fa2dd3552ac91080657ca3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9768f32e150f510ea6fa2dd3552ac91080657ca3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a5c8e91f094bb1cb1346651fe3512f0b603d826", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a5c8e91f094bb1cb1346651fe3512f0b603d826", "html_url": "https://github.com/rust-lang/rust/commit/3a5c8e91f094bb1cb1346651fe3512f0b603d826", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a5c8e91f094bb1cb1346651fe3512f0b603d826/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7f9e81650dcee3e2d5ad1973a71da644a2eff93", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7f9e81650dcee3e2d5ad1973a71da644a2eff93", "html_url": "https://github.com/rust-lang/rust/commit/d7f9e81650dcee3e2d5ad1973a71da644a2eff93"}, {"sha": "14d1e87db9bf5e9c3dc8cfe7a0558d260b1e5ff2", "url": "https://api.github.com/repos/rust-lang/rust/commits/14d1e87db9bf5e9c3dc8cfe7a0558d260b1e5ff2", "html_url": "https://github.com/rust-lang/rust/commit/14d1e87db9bf5e9c3dc8cfe7a0558d260b1e5ff2"}], "stats": {"total": 3413, "additions": 1460, "deletions": 1953}, "files": [{"sha": "b07ed1d1c741eeb372d57c0f80a9e6d935bbb3f8", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -10,7 +10,6 @@\n )]\n #![feature(associated_type_bounds)]\n #![feature(box_patterns)]\n-#![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]"}, {"sha": "0140fb752bf92f8c9f11c265f5ae99e527abdaa8", "filename": "compiler/rustc_ast/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/compiler%2Frustc_ast%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/compiler%2Frustc_ast%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fptr.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -126,7 +126,8 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for P<T> {\n }\n \n impl<T> P<[T]> {\n-    pub const fn new() -> P<[T]> {\n+    // FIXME(const-hack) make this const again\n+    pub fn new() -> P<[T]> {\n         P { ptr: Box::default() }\n     }\n "}, {"sha": "6c11edb742c0d3543ed498deaf15b80007ea333a", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -610,10 +610,11 @@ pub struct RawPtrComparison;\n impl<'tcx> NonConstOp<'tcx> for RawPtrComparison {\n     fn build_error(\n         &self,\n-        _: &ConstCx<'_, 'tcx>,\n+        ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        span_bug!(span, \"raw ptr comparison should already be caught in the trait system\");\n+        // FIXME(const_trait_impl): revert to span_bug?\n+        ccx.tcx.sess.create_err(errors::RawPtrComparisonErr { span })\n     }\n }\n "}, {"sha": "ad86c19309831384c2f7bafd8ef6228742734727", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -576,8 +576,7 @@ impl<T, A: Allocator> Box<T, A> {\n     ///\n     /// This conversion does not allocate on the heap and happens in place.\n     #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n-    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n-    pub const fn into_boxed_slice(boxed: Self) -> Box<[T], A> {\n+    pub fn into_boxed_slice(boxed: Self) -> Box<[T], A> {\n         let (raw, alloc) = Box::into_raw_with_allocator(boxed);\n         unsafe { Box::from_raw_in(raw as *mut [T; 1], alloc) }\n     }\n@@ -809,9 +808,8 @@ impl<T, A: Allocator> Box<mem::MaybeUninit<T>, A> {\n     /// assert_eq!(*five, 5)\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n-    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub const unsafe fn assume_init(self) -> Box<T, A> {\n+    pub unsafe fn assume_init(self) -> Box<T, A> {\n         let (raw, alloc) = Box::into_raw_with_allocator(self);\n         unsafe { Box::from_raw_in(raw as *mut T, alloc) }\n     }\n@@ -844,9 +842,8 @@ impl<T, A: Allocator> Box<mem::MaybeUninit<T>, A> {\n     /// }\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n-    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub const fn write(mut boxed: Self, value: T) -> Box<T, A> {\n+    pub fn write(mut boxed: Self, value: T) -> Box<T, A> {\n         unsafe {\n             (*boxed).write(value);\n             boxed.assume_init()\n@@ -1090,9 +1087,8 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     ///\n     /// [memory layout]: self#memory-layout\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub const fn into_raw_with_allocator(b: Self) -> (*mut T, A) {\n+    pub fn into_raw_with_allocator(b: Self) -> (*mut T, A) {\n         let (leaked, alloc) = Box::into_unique(b);\n         (leaked.as_ptr(), alloc)\n     }\n@@ -1102,10 +1098,9 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n         issue = \"none\",\n         reason = \"use `Box::leak(b).into()` or `Unique::from(Box::leak(b))` instead\"\n     )]\n-    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n     #[doc(hidden)]\n-    pub const fn into_unique(b: Self) -> (Unique<T>, A) {\n+    pub fn into_unique(b: Self) -> (Unique<T>, A) {\n         // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n         // raw pointer for the type system. Turning it directly into a raw pointer would not be\n         // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n@@ -1163,9 +1158,8 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     /// assert_eq!(*static_ref, [4, 2, 3]);\n     /// ```\n     #[stable(feature = \"box_leak\", since = \"1.26.0\")]\n-    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub const fn leak<'a>(b: Self) -> &'a mut T\n+    pub fn leak<'a>(b: Self) -> &'a mut T\n     where\n         A: 'a,\n     {\n@@ -1234,8 +1228,7 @@ impl<T: Default> Default for Box<T> {\n \n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for Box<[T]> {\n+impl<T> Default for Box<[T]> {\n     #[inline]\n     fn default() -> Self {\n         let ptr: Unique<[T]> = Unique::<[T; 0]>::dangling();\n@@ -1245,8 +1238,7 @@ impl<T> const Default for Box<[T]> {\n \n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"default_box_extra\", since = \"1.17.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl const Default for Box<str> {\n+impl Default for Box<str> {\n     #[inline]\n     fn default() -> Self {\n         // SAFETY: This is the same as `Unique::cast<U>` but with an unsized `U = str`.\n@@ -1443,8 +1435,7 @@ impl<T> From<T> for Box<T> {\n }\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n-impl<T: ?Sized, A: Allocator> const From<Box<T, A>> for Pin<Box<T, A>>\n+impl<T: ?Sized, A: Allocator> From<Box<T, A>> for Pin<Box<T, A>>\n where\n     A: 'static,\n {\n@@ -1880,8 +1871,7 @@ impl<T: ?Sized, A: Allocator> fmt::Pointer for Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n-impl<T: ?Sized, A: Allocator> const Deref for Box<T, A> {\n+impl<T: ?Sized, A: Allocator> Deref for Box<T, A> {\n     type Target = T;\n \n     fn deref(&self) -> &T {\n@@ -1890,8 +1880,7 @@ impl<T: ?Sized, A: Allocator> const Deref for Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n-impl<T: ?Sized, A: Allocator> const DerefMut for Box<T, A> {\n+impl<T: ?Sized, A: Allocator> DerefMut for Box<T, A> {\n     fn deref_mut(&mut self) -> &mut T {\n         &mut **self\n     }"}, {"sha": "a002421aeef3a472d1cb2cf544b8104338518154", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -106,7 +106,6 @@\n #![feature(coerce_unsized)]\n #![feature(const_align_of_val)]\n #![feature(const_box)]\n-#![feature(const_convert)]\n #![feature(const_cow_is_borrowed)]\n #![feature(const_eval_select)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n@@ -174,7 +173,6 @@\n #![feature(associated_type_bounds)]\n #![feature(c_unwind)]\n #![feature(cfg_sanitize)]\n-#![feature(const_deref)]\n #![feature(const_mut_refs)]\n #![feature(const_precise_live_drops)]\n #![feature(const_ptr_write)]"}, {"sha": "cf16a3424a0927da51c97a40a4dd7ca6eff62a6c", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -2247,8 +2247,7 @@ impl_eq! { Cow<'a, str>, &'b str }\n impl_eq! { Cow<'a, str>, String }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl const Default for String {\n+impl Default for String {\n     /// Creates an empty `String`.\n     #[inline]\n     fn default() -> String {"}, {"sha": "765c095e37bfcba1b0d1f113607de1d836f4064f", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -3022,8 +3022,7 @@ unsafe impl<#[may_dangle] T, A: Allocator> Drop for Vec<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for Vec<T> {\n+impl<T> Default for Vec<T> {\n     /// Creates an empty `Vec<T>`.\n     ///\n     /// The vector will not allocate until elements are pushed onto it."}, {"sha": "4cacee0414d7d9b95090595b44701d46496623da", "filename": "library/alloc/tests/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Falloc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Falloc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fboxed.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -61,7 +61,7 @@ fn box_deref_lval() {\n \n pub struct ConstAllocator;\n \n-unsafe impl const Allocator for ConstAllocator {\n+unsafe impl Allocator for ConstAllocator {\n     fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n         match layout.size() {\n             0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),"}, {"sha": "4e7d7fc833ea1d874537e21fc6f0aa4807e472f4", "filename": "library/alloc/tests/const_fns.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Falloc%2Ftests%2Fconst_fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Falloc%2Ftests%2Fconst_fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fconst_fns.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,13 +1,16 @@\n // Test const functions in the library\n \n pub const MY_VEC: Vec<usize> = Vec::new();\n-pub const MY_VEC2: Vec<usize> = Default::default();\n+\n+// FIXME(#110395)\n+// pub const MY_VEC2: Vec<usize> = Default::default();\n \n pub const MY_STRING: String = String::new();\n-pub const MY_STRING2: String = Default::default();\n \n-pub const MY_BOXED_SLICE: Box<[usize]> = Default::default();\n-pub const MY_BOXED_STR: Box<str> = Default::default();\n+// pub const MY_STRING2: String = Default::default();\n+\n+// pub const MY_BOXED_SLICE: Box<[usize]> = Default::default();\n+// pub const MY_BOXED_STR: Box<str> = Default::default();\n \n use std::collections::{BTreeMap, BTreeSet};\n \n@@ -23,11 +26,11 @@ pub const SET_IS_EMPTY: bool = SET.is_empty();\n \n #[test]\n fn test_const() {\n-    assert_eq!(MY_VEC, MY_VEC2);\n-    assert_eq!(MY_STRING, MY_STRING2);\n+    assert_eq!(MY_VEC, /* MY_VEC */ vec![]);\n+    assert_eq!(MY_STRING, /* MY_STRING2 */ String::default());\n \n-    assert_eq!(MY_VEC, *MY_BOXED_SLICE);\n-    assert_eq!(MY_STRING, *MY_BOXED_STR);\n+    // assert_eq!(MY_VEC, *MY_BOXED_SLICE);\n+    // assert_eq!(MY_STRING, *MY_BOXED_STR);\n \n     assert_eq!(MAP_LEN, 0);\n     assert_eq!(SET_LEN, 0);"}, {"sha": "0eca4c9bb07aa6cad094aa60835d3a1b51ebf12d", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -3,7 +3,6 @@\n #![feature(assert_matches)]\n #![feature(btree_drain_filter)]\n #![feature(cow_is_borrowed)]\n-#![feature(const_convert)]\n #![feature(const_cow_is_borrowed)]\n #![feature(const_heap)]\n #![feature(const_mut_refs)]\n@@ -33,7 +32,6 @@\n #![feature(slice_partition_dedup)]\n #![feature(string_remove_matches)]\n #![feature(const_btree_len)]\n-#![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n #![feature(const_str_from_utf8)]\n #![feature(panic_update_hook)]"}, {"sha": "597303037345ed72ff00b97bb591f0de8b210c8e", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -231,9 +231,8 @@ impl Layout {\n     /// Returns an error if the combination of `self.size()` and the given\n     /// `align` violates the conditions listed in [`Layout::from_size_align`].\n     #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub const fn align_to(&self, align: usize) -> Result<Self, LayoutError> {\n+    pub fn align_to(&self, align: usize) -> Result<Self, LayoutError> {\n         Layout::from_size_align(self.size(), cmp::max(self.align(), align))\n     }\n \n@@ -315,9 +314,8 @@ impl Layout {\n     ///\n     /// On arithmetic overflow, returns `LayoutError`.\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub const fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutError> {\n+    pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutError> {\n         // This cannot overflow. Quoting from the invariant of Layout:\n         // > `size`, when rounded up to the nearest multiple of `align`,\n         // > must not overflow isize (i.e., the rounded value must be\n@@ -376,9 +374,8 @@ impl Layout {\n     /// # assert_eq!(repr_c(&[u64, u32, u16, u32]), Ok((s, vec![0, 8, 12, 16])));\n     /// ```\n     #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub const fn extend(&self, next: Self) -> Result<(Self, usize), LayoutError> {\n+    pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutError> {\n         let new_align = cmp::max(self.align, next.align);\n         let pad = self.padding_needed_for(next.align());\n \n@@ -403,9 +400,8 @@ impl Layout {\n     ///\n     /// On arithmetic overflow, returns `LayoutError`.\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub const fn repeat_packed(&self, n: usize) -> Result<Self, LayoutError> {\n+    pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutError> {\n         let size = self.size().checked_mul(n).ok_or(LayoutError)?;\n         // The safe constructor is called here to enforce the isize size limit.\n         Layout::from_size_alignment(size, self.align)\n@@ -418,9 +414,8 @@ impl Layout {\n     ///\n     /// On arithmetic overflow, returns `LayoutError`.\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub const fn extend_packed(&self, next: Self) -> Result<Self, LayoutError> {\n+    pub fn extend_packed(&self, next: Self) -> Result<Self, LayoutError> {\n         let new_size = self.size().checked_add(next.size()).ok_or(LayoutError)?;\n         // The safe constructor is called here to enforce the isize size limit.\n         Layout::from_size_alignment(new_size, self.align)"}, {"sha": "d6ae2b8213f560e67d1bc8e18c0ab3ff8e7d2144", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -105,7 +105,6 @@ impl fmt::Display for AllocError {\n ///\n /// [*currently allocated*]: #currently-allocated-memory\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[const_trait]\n pub unsafe trait Allocator {\n     /// Attempts to allocate a block of memory.\n     ///"}, {"sha": "bb93ea509d8eeee6e8f43469cd4e007f02f413bc", "filename": "library/core/src/any.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fany.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -662,8 +662,7 @@ impl dyn Any + Send + Sync {\n /// While `TypeId` implements `Hash`, `PartialOrd`, and `Ord`, it is worth\n /// noting that the hashes and ordering will vary between Rust releases. Beware\n /// of relying on them inside of your code!\n-#[derive(Clone, Copy, Debug, Hash, Eq)]\n-#[derive_const(PartialEq, PartialOrd, Ord)]\n+#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TypeId {\n     t: u64,"}, {"sha": "98c87b2c393ea7d7a37c6cf07fa75e8d5788908a", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -148,8 +148,7 @@ impl Error for TryFromSliceError {\n }\n \n #[stable(feature = \"try_from_slice_error\", since = \"1.36.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<Infallible> for TryFromSliceError {\n+impl From<Infallible> for TryFromSliceError {\n     fn from(x: Infallible) -> TryFromSliceError {\n         match x {}\n     }\n@@ -172,16 +171,14 @@ impl<T, const N: usize> AsMut<[T]> for [T; N] {\n }\n \n #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-#[rustc_const_unstable(feature = \"const_borrow\", issue = \"91522\")]\n-impl<T, const N: usize> const Borrow<[T]> for [T; N] {\n+impl<T, const N: usize> Borrow<[T]> for [T; N] {\n     fn borrow(&self) -> &[T] {\n         self\n     }\n }\n \n #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-#[rustc_const_unstable(feature = \"const_borrow\", issue = \"91522\")]\n-impl<T, const N: usize> const BorrowMut<[T]> for [T; N] {\n+impl<T, const N: usize> BorrowMut<[T]> for [T; N] {\n     fn borrow_mut(&mut self) -> &mut [T] {\n         self\n     }\n@@ -336,10 +333,9 @@ impl<'a, T, const N: usize> IntoIterator for &'a mut [T; N] {\n }\n \n #[stable(feature = \"index_trait_on_arrays\", since = \"1.50.0\")]\n-#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-impl<T, I, const N: usize> const Index<I> for [T; N]\n+impl<T, I, const N: usize> Index<I> for [T; N]\n where\n-    [T]: ~const Index<I>,\n+    [T]: Index<I>,\n {\n     type Output = <[T] as Index<I>>::Output;\n \n@@ -350,10 +346,9 @@ where\n }\n \n #[stable(feature = \"index_trait_on_arrays\", since = \"1.50.0\")]\n-#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-impl<T, I, const N: usize> const IndexMut<I> for [T; N]\n+impl<T, I, const N: usize> IndexMut<I> for [T; N]\n where\n-    [T]: ~const IndexMut<I>,\n+    [T]: IndexMut<I>,\n {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut Self::Output {\n@@ -435,8 +430,7 @@ impl<T: Copy> SpecArrayClone for T {\n macro_rules! array_impl_default {\n     {$n:expr, $t:ident $($ts:ident)*} => {\n         #[stable(since = \"1.4.0\", feature = \"array_default\")]\n-        #[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-        impl<T> const Default for [T; $n] where T: ~const Default {\n+        impl<T> Default for [T; $n] where T: Default {\n             fn default() -> [T; $n] {\n                 [$t::default(), $($ts::default()),*]\n             }\n@@ -445,8 +439,7 @@ macro_rules! array_impl_default {\n     };\n     {$n:expr,} => {\n         #[stable(since = \"1.4.0\", feature = \"array_default\")]\n-        #[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-        impl<T> const Default for [T; $n] {\n+        impl<T> Default for [T; $n] {\n             fn default() -> [T; $n] { [] }\n         }\n     };"}, {"sha": "03cdff9b13be171ac8b6871e63fe5c4eed7cafb2", "filename": "library/core/src/bool.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fbool.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,7 +1,5 @@\n //! impl bool {}\n \n-use crate::marker::Destruct;\n-\n impl bool {\n     /// Returns `Some(t)` if the `bool` is [`true`](../std/keyword.true.html),\n     /// or `None` otherwise.\n@@ -31,12 +29,8 @@ impl bool {\n     /// assert_eq!(a, 2);\n     /// ```\n     #[stable(feature = \"bool_to_option\", since = \"1.62.0\")]\n-    #[rustc_const_unstable(feature = \"const_bool_to_option\", issue = \"91917\")]\n     #[inline]\n-    pub const fn then_some<T>(self, t: T) -> Option<T>\n-    where\n-        T: ~const Destruct,\n-    {\n+    pub fn then_some<T>(self, t: T) -> Option<T> {\n         if self { Some(t) } else { None }\n     }\n \n@@ -61,13 +55,8 @@ impl bool {\n     /// assert_eq!(a, 1);\n     /// ```\n     #[stable(feature = \"lazy_bool_to_option\", since = \"1.50.0\")]\n-    #[rustc_const_unstable(feature = \"const_bool_to_option\", issue = \"91917\")]\n     #[inline]\n-    pub const fn then<T, F>(self, f: F) -> Option<T>\n-    where\n-        F: ~const FnOnce() -> T,\n-        F: ~const Destruct,\n-    {\n+    pub fn then<T, F: FnOnce() -> T>(self, f: F) -> Option<T> {\n         if self { Some(f()) } else { None }\n     }\n }"}, {"sha": "efc9ada3891a035526e9290059eee48ec7c027cb", "filename": "library/core/src/borrow.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fborrow.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -154,7 +154,6 @@\n /// [`String`]: ../../std/string/struct.String.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Borrow\"]\n-#[const_trait]\n pub trait Borrow<Borrowed: ?Sized> {\n     /// Immutably borrows from an owned value.\n     ///\n@@ -185,7 +184,6 @@ pub trait Borrow<Borrowed: ?Sized> {\n /// an underlying type by providing a mutable reference. See [`Borrow<T>`]\n /// for more information on borrowing as another type.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[const_trait]\n pub trait BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed> {\n     /// Mutably borrows from an owned value.\n     ///\n@@ -207,41 +205,36 @@ pub trait BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_borrow\", issue = \"91522\")]\n-impl<T: ?Sized> const Borrow<T> for T {\n+impl<T: ?Sized> Borrow<T> for T {\n     #[rustc_diagnostic_item = \"noop_method_borrow\"]\n     fn borrow(&self) -> &T {\n         self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_borrow\", issue = \"91522\")]\n-impl<T: ?Sized> const BorrowMut<T> for T {\n+impl<T: ?Sized> BorrowMut<T> for T {\n     fn borrow_mut(&mut self) -> &mut T {\n         self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_borrow\", issue = \"91522\")]\n-impl<T: ?Sized> const Borrow<T> for &T {\n+impl<T: ?Sized> Borrow<T> for &T {\n     fn borrow(&self) -> &T {\n         &**self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_borrow\", issue = \"91522\")]\n-impl<T: ?Sized> const Borrow<T> for &mut T {\n+impl<T: ?Sized> Borrow<T> for &mut T {\n     fn borrow(&self) -> &T {\n         &**self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_borrow\", issue = \"91522\")]\n-impl<T: ?Sized> const BorrowMut<T> for &mut T {\n+impl<T: ?Sized> BorrowMut<T> for &mut T {\n     fn borrow_mut(&mut self) -> &mut T {\n         &mut **self\n     }"}, {"sha": "bcca8d924cdd62960fc0ef41e624b50fe572899c", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -370,8 +370,7 @@ impl<T: Ord + Copy> Ord for Cell<T> {\n }\n \n #[stable(feature = \"cell_from\", since = \"1.12.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for Cell<T> {\n+impl<T> From<T> for Cell<T> {\n     /// Creates a new `Cell<T>` containing the given value.\n     fn from(t: T) -> Cell<T> {\n         Cell::new(t)\n@@ -1318,8 +1317,7 @@ impl<T: ?Sized + Ord> Ord for RefCell<T> {\n }\n \n #[stable(feature = \"cell_from\", since = \"1.12.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for RefCell<T> {\n+impl<T> From<T> for RefCell<T> {\n     /// Creates a new `RefCell<T>` containing the given value.\n     fn from(t: T) -> RefCell<T> {\n         RefCell::new(t)\n@@ -2126,8 +2124,7 @@ impl<T: Default> Default for UnsafeCell<T> {\n }\n \n #[stable(feature = \"cell_from\", since = \"1.12.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for UnsafeCell<T> {\n+impl<T> From<T> for UnsafeCell<T> {\n     /// Creates a new `UnsafeCell<T>` containing the given value.\n     fn from(t: T) -> UnsafeCell<T> {\n         UnsafeCell::new(t)\n@@ -2226,8 +2223,7 @@ impl<T: Default> Default for SyncUnsafeCell<T> {\n }\n \n #[unstable(feature = \"sync_unsafe_cell\", issue = \"95439\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for SyncUnsafeCell<T> {\n+impl<T> From<T> for SyncUnsafeCell<T> {\n     /// Creates a new `SyncUnsafeCell<T>` containing the given value.\n     fn from(t: T) -> SyncUnsafeCell<T> {\n         SyncUnsafeCell::new(t)"}, {"sha": "a7cd59e50fc318307329e79c99ef11f8fc29aef8", "filename": "library/core/src/cell/once.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -284,8 +284,7 @@ impl<T: PartialEq> PartialEq for OnceCell<T> {\n impl<T: Eq> Eq for OnceCell<T> {}\n \n #[stable(feature = \"once_cell\", since = \"CURRENT_RUSTC_VERSION\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for OnceCell<T> {\n+impl<T> From<T> for OnceCell<T> {\n     /// Creates a new `OnceCell<T>` which already contains the given `value`.\n     #[inline]\n     fn from(value: T) -> Self {"}, {"sha": "b84e4b35b1c77883c8f884cf855bc6b2142d46a6", "filename": "library/core/src/char/convert.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -27,8 +27,7 @@ pub(super) const unsafe fn from_u32_unchecked(i: u32) -> char {\n }\n \n #[stable(feature = \"char_convert\", since = \"1.13.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<char> for u32 {\n+impl From<char> for u32 {\n     /// Converts a [`char`] into a [`u32`].\n     ///\n     /// # Examples\n@@ -47,8 +46,7 @@ impl const From<char> for u32 {\n }\n \n #[stable(feature = \"more_char_conversions\", since = \"1.51.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<char> for u64 {\n+impl From<char> for u64 {\n     /// Converts a [`char`] into a [`u64`].\n     ///\n     /// # Examples\n@@ -69,8 +67,7 @@ impl const From<char> for u64 {\n }\n \n #[stable(feature = \"more_char_conversions\", since = \"1.51.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<char> for u128 {\n+impl From<char> for u128 {\n     /// Converts a [`char`] into a [`u128`].\n     ///\n     /// # Examples\n@@ -123,8 +120,7 @@ impl TryFrom<char> for u8 {\n /// for a superset of Windows-1252 that fills the remaining blanks with corresponding\n /// C0 and C1 control codes.\n #[stable(feature = \"char_convert\", since = \"1.13.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<u8> for char {\n+impl From<u8> for char {\n     /// Converts a [`u8`] into a [`char`].\n     ///\n     /// # Examples"}, {"sha": "a6d6230d3a62b6a18700cca3d3b525fcc5afb701", "filename": "library/core/src/clone.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fclone.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -36,8 +36,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::marker::Destruct;\n-\n /// A common trait for the ability to explicitly duplicate an object.\n ///\n /// Differs from [`Copy`] in that [`Copy`] is implicit and an inexpensive bit-wise copy, while\n@@ -106,7 +104,6 @@ use crate::marker::Destruct;\n #[lang = \"clone\"]\n #[rustc_diagnostic_item = \"Clone\"]\n #[rustc_trivial_field_reads]\n-#[const_trait]\n pub trait Clone: Sized {\n     /// Returns a copy of the value.\n     ///\n@@ -129,10 +126,7 @@ pub trait Clone: Sized {\n     /// allocations.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn clone_from(&mut self, source: &Self)\n-    where\n-        Self: ~const Destruct,\n-    {\n+    fn clone_from(&mut self, source: &Self) {\n         *self = source.clone()\n     }\n }\n@@ -182,8 +176,7 @@ mod impls {\n         ($($t:ty)*) => {\n             $(\n                 #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-                #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-                impl const Clone for $t {\n+                impl Clone for $t {\n                     #[inline(always)]\n                     fn clone(&self) -> Self {\n                         *self\n@@ -201,26 +194,23 @@ mod impls {\n     }\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n-    #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-    impl const Clone for ! {\n+    impl Clone for ! {\n         #[inline]\n         fn clone(&self) -> Self {\n             *self\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-    impl<T: ?Sized> const Clone for *const T {\n+    impl<T: ?Sized> Clone for *const T {\n         #[inline(always)]\n         fn clone(&self) -> Self {\n             *self\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-    impl<T: ?Sized> const Clone for *mut T {\n+    impl<T: ?Sized> Clone for *mut T {\n         #[inline(always)]\n         fn clone(&self) -> Self {\n             *self\n@@ -229,8 +219,7 @@ mod impls {\n \n     /// Shared references can be cloned, but mutable references *cannot*!\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-    impl<T: ?Sized> const Clone for &T {\n+    impl<T: ?Sized> Clone for &T {\n         #[inline(always)]\n         #[rustc_diagnostic_item = \"noop_method_clone\"]\n         fn clone(&self) -> Self {"}, {"sha": "90825c4ce32e1c68b4e86265fdabcd6971351002", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 27, "deletions": 75, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -25,8 +25,6 @@\n mod bytewise;\n pub(crate) use bytewise::BytewiseEq;\n \n-use crate::marker::Destruct;\n-\n use self::Ordering::*;\n \n /// Trait for equality comparisons.\n@@ -212,7 +210,6 @@ use self::Ordering::*;\n     label = \"no implementation for `{Self} == {Rhs}`\",\n     append_const_msg\n )]\n-#[const_trait]\n #[rustc_diagnostic_item = \"PartialEq\"]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used\n@@ -333,8 +330,7 @@ pub struct AssertParamIsEq<T: Eq + ?Sized> {\n /// let result = 2.cmp(&1);\n /// assert_eq!(Ordering::Greater, result);\n /// ```\n-#[derive(Clone, Copy, Eq, Debug, Hash)]\n-#[derive_const(PartialOrd, Ord, PartialEq)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(i8)]\n pub enum Ordering {\n@@ -604,8 +600,7 @@ impl Ordering {\n pub struct Reverse<T>(#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")] pub T);\n \n #[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-impl<T: ~const PartialOrd> const PartialOrd for Reverse<T> {\n+impl<T: PartialOrd> PartialOrd for Reverse<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n         other.0.partial_cmp(&self.0)\n@@ -763,7 +758,6 @@ impl<T: Clone> Clone for Reverse<T> {\n #[doc(alias = \">=\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Ord\"]\n-#[const_trait]\n pub trait Ord: Eq + PartialOrd<Self> {\n     /// This method returns an [`Ordering`] between `self` and `other`.\n     ///\n@@ -799,7 +793,6 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     fn max(self, other: Self) -> Self\n     where\n         Self: Sized,\n-        Self: ~const Destruct,\n     {\n         max_by(self, other, Ord::cmp)\n     }\n@@ -820,7 +813,6 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     fn min(self, other: Self) -> Self\n     where\n         Self: Sized,\n-        Self: ~const Destruct,\n     {\n         min_by(self, other, Ord::cmp)\n     }\n@@ -846,8 +838,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     fn clamp(self, min: Self, max: Self) -> Self\n     where\n         Self: Sized,\n-        Self: ~const Destruct,\n-        Self: ~const PartialOrd,\n+        Self: PartialOrd,\n     {\n         assert!(min <= max);\n         if self < min {\n@@ -1035,7 +1026,6 @@ pub macro Ord($item:item) {\n     label = \"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\",\n     append_const_msg\n )]\n-#[const_trait]\n #[rustc_diagnostic_item = \"PartialOrd\"]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values if one exists.\n@@ -1166,9 +1156,8 @@ pub macro PartialOrd($item:item) {\n #[inline]\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"cmp_min\")]\n-pub const fn min<T: ~const Ord + ~const Destruct>(v1: T, v2: T) -> T {\n+pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     v1.min(v2)\n }\n \n@@ -1187,12 +1176,7 @@ pub const fn min<T: ~const Ord + ~const Destruct>(v1: T, v2: T) -> T {\n #[inline]\n #[must_use]\n #[stable(feature = \"cmp_min_max_by\", since = \"1.53.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-pub const fn min_by<T, F: ~const FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T\n-where\n-    T: ~const Destruct,\n-    F: ~const Destruct,\n-{\n+pub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n     match compare(&v1, &v2) {\n         Ordering::Less | Ordering::Equal => v1,\n         Ordering::Greater => v2,\n@@ -1214,14 +1198,8 @@ where\n #[inline]\n #[must_use]\n #[stable(feature = \"cmp_min_max_by\", since = \"1.53.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-pub const fn min_by_key<T, F: ~const FnMut(&T) -> K, K: ~const Ord>(v1: T, v2: T, mut f: F) -> T\n-where\n-    T: ~const Destruct,\n-    F: ~const Destruct,\n-    K: ~const Destruct,\n-{\n-    min_by(v1, v2, const |v1, v2| f(v1).cmp(&f(v2)))\n+pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n+    min_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))\n }\n \n /// Compares and returns the maximum of two values.\n@@ -1241,9 +1219,8 @@ where\n #[inline]\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"cmp_max\")]\n-pub const fn max<T: ~const Ord + ~const Destruct>(v1: T, v2: T) -> T {\n+pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     v1.max(v2)\n }\n \n@@ -1262,12 +1239,7 @@ pub const fn max<T: ~const Ord + ~const Destruct>(v1: T, v2: T) -> T {\n #[inline]\n #[must_use]\n #[stable(feature = \"cmp_min_max_by\", since = \"1.53.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-pub const fn max_by<T, F: ~const FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T\n-where\n-    T: ~const Destruct,\n-    F: ~const Destruct,\n-{\n+pub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n     match compare(&v1, &v2) {\n         Ordering::Less | Ordering::Equal => v2,\n         Ordering::Greater => v1,\n@@ -1289,14 +1261,8 @@ where\n #[inline]\n #[must_use]\n #[stable(feature = \"cmp_min_max_by\", since = \"1.53.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-pub const fn max_by_key<T, F: ~const FnMut(&T) -> K, K: ~const Ord>(v1: T, v2: T, mut f: F) -> T\n-where\n-    T: ~const Destruct,\n-    F: ~const Destruct,\n-    K: ~const Destruct,\n-{\n-    max_by(v1, v2, const |v1, v2| f(v1).cmp(&f(v2)))\n+pub fn max_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n+    max_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))\n }\n \n // Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types\n@@ -1307,8 +1273,7 @@ mod impls {\n     macro_rules! partial_eq_impl {\n         ($($t:ty)*) => ($(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-            impl const PartialEq for $t {\n+            impl PartialEq for $t {\n                 #[inline]\n                 fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n                 #[inline]\n@@ -1318,8 +1283,7 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const PartialEq for () {\n+    impl PartialEq for () {\n         #[inline]\n         fn eq(&self, _other: &()) -> bool {\n             true\n@@ -1346,8 +1310,7 @@ mod impls {\n     macro_rules! partial_ord_impl {\n         ($($t:ty)*) => ($(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-            impl const PartialOrd for $t {\n+            impl PartialOrd for $t {\n                 #[inline]\n                 fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n                     match (*self <= *other, *self >= *other) {\n@@ -1370,17 +1333,15 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const PartialOrd for () {\n+    impl PartialOrd for () {\n         #[inline]\n         fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n             Some(Equal)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const PartialOrd for bool {\n+    impl PartialOrd for bool {\n         #[inline]\n         fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n             Some(self.cmp(other))\n@@ -1392,8 +1353,7 @@ mod impls {\n     macro_rules! ord_impl {\n         ($($t:ty)*) => ($(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-            impl const PartialOrd for $t {\n+            impl PartialOrd for $t {\n                 #[inline]\n                 fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n                     Some(self.cmp(other))\n@@ -1409,8 +1369,7 @@ mod impls {\n             }\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-            impl const Ord for $t {\n+            impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n                     // The order here is important to generate more optimal assembly.\n@@ -1424,17 +1383,15 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const Ord for () {\n+    impl Ord for () {\n         #[inline]\n         fn cmp(&self, _other: &()) -> Ordering {\n             Equal\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const Ord for bool {\n+    impl Ord for bool {\n         #[inline]\n         fn cmp(&self, other: &bool) -> Ordering {\n             // Casting to i8's and converting the difference to an Ordering generates\n@@ -1453,8 +1410,7 @@ mod impls {\n     ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const PartialEq for ! {\n+    impl PartialEq for ! {\n         fn eq(&self, _: &!) -> bool {\n             *self\n         }\n@@ -1464,16 +1420,14 @@ mod impls {\n     impl Eq for ! {}\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const PartialOrd for ! {\n+    impl PartialOrd for ! {\n         fn partial_cmp(&self, _: &!) -> Option<Ordering> {\n             *self\n         }\n     }\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const Ord for ! {\n+    impl Ord for ! {\n         fn cmp(&self, _: &!) -> Ordering {\n             *self\n         }\n@@ -1482,10 +1436,9 @@ mod impls {\n     // & pointers\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl<A: ?Sized, B: ?Sized> const PartialEq<&B> for &A\n+    impl<A: ?Sized, B: ?Sized> PartialEq<&B> for &A\n     where\n-        A: ~const PartialEq<B>,\n+        A: PartialEq<B>,\n     {\n         #[inline]\n         fn eq(&self, other: &&B) -> bool {\n@@ -1497,10 +1450,9 @@ mod impls {\n         }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl<A: ?Sized, B: ?Sized> const PartialOrd<&B> for &A\n+    impl<A: ?Sized, B: ?Sized> PartialOrd<&B> for &A\n     where\n-        A: ~const PartialOrd<B>,\n+        A: PartialOrd<B>,\n     {\n         #[inline]\n         fn partial_cmp(&self, other: &&B) -> Option<Ordering> {"}, {"sha": "3ae787cac71f85d6eb4a4b1b6cc235a2147cd671", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -214,7 +214,6 @@ pub const fn identity<T>(x: T) -> T {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"AsRef\")]\n-#[const_trait]\n pub trait AsRef<T: ?Sized> {\n     /// Converts this type into a shared reference of the (usually inferred) input type.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -366,7 +365,6 @@ pub trait AsRef<T: ?Sized> {\n /// `&mut Vec<u8>`, for example, is the better choice (callers need to pass the correct type then).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"AsMut\")]\n-#[const_trait]\n pub trait AsMut<T: ?Sized> {\n     /// Converts this type into a mutable reference of the (usually inferred) input type.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -443,7 +441,6 @@ pub trait AsMut<T: ?Sized> {\n /// [`Vec`]: ../../std/vec/struct.Vec.html\n #[rustc_diagnostic_item = \"Into\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[const_trait]\n pub trait Into<T>: Sized {\n     /// Converts this type into the (usually inferred) input type.\n     #[must_use]\n@@ -539,7 +536,6 @@ pub trait Into<T>: Sized {\n     all(_Self = \"&str\", T = \"std::string::String\"),\n     note = \"to coerce a `{T}` into a `{Self}`, use `&*` as a prefix\",\n ))]\n-#[const_trait]\n pub trait From<T>: Sized {\n     /// Converts to this type from the input type.\n     #[rustc_diagnostic_item = \"from_fn\"]\n@@ -564,7 +560,6 @@ pub trait From<T>: Sized {\n /// [`Into`], see there for details.\n #[rustc_diagnostic_item = \"TryInto\"]\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-#[const_trait]\n pub trait TryInto<T>: Sized {\n     /// The type returned in the event of a conversion error.\n     #[stable(feature = \"try_from\", since = \"1.34.0\")]\n@@ -641,7 +636,6 @@ pub trait TryInto<T>: Sized {\n /// [`try_from`]: TryFrom::try_from\n #[rustc_diagnostic_item = \"TryFrom\"]\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-#[const_trait]\n pub trait TryFrom<T>: Sized {\n     /// The type returned in the event of a conversion error.\n     #[stable(feature = \"try_from\", since = \"1.34.0\")]\n@@ -658,10 +652,9 @@ pub trait TryFrom<T>: Sized {\n \n // As lifts over &\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T: ?Sized, U: ?Sized> const AsRef<U> for &T\n+impl<T: ?Sized, U: ?Sized> AsRef<U> for &T\n where\n-    T: ~const AsRef<U>,\n+    T: AsRef<U>,\n {\n     #[inline]\n     fn as_ref(&self) -> &U {\n@@ -671,10 +664,9 @@ where\n \n // As lifts over &mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T: ?Sized, U: ?Sized> const AsRef<U> for &mut T\n+impl<T: ?Sized, U: ?Sized> AsRef<U> for &mut T\n where\n-    T: ~const AsRef<U>,\n+    T: AsRef<U>,\n {\n     #[inline]\n     fn as_ref(&self) -> &U {\n@@ -692,10 +684,9 @@ where\n \n // AsMut lifts over &mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T: ?Sized, U: ?Sized> const AsMut<U> for &mut T\n+impl<T: ?Sized, U: ?Sized> AsMut<U> for &mut T\n where\n-    T: ~const AsMut<U>,\n+    T: AsMut<U>,\n {\n     #[inline]\n     fn as_mut(&mut self) -> &mut U {\n@@ -713,10 +704,9 @@ where\n \n // From implies Into\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T, U> const Into<U> for T\n+impl<T, U> Into<U> for T\n where\n-    U: ~const From<T>,\n+    U: From<T>,\n {\n     /// Calls `U::from(self)`.\n     ///\n@@ -730,8 +720,7 @@ where\n \n // From (and thus Into) is reflexive\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for T {\n+impl<T> From<T> for T {\n     /// Returns the argument unchanged.\n     #[inline(always)]\n     fn from(t: T) -> T {\n@@ -748,19 +737,17 @@ impl<T> const From<T> for T {\n #[allow(unused_attributes)] // FIXME(#58633): do a principled fix instead.\n #[rustc_reservation_impl = \"permitting this impl would forbid us from adding \\\n                             `impl<T> From<!> for T` later; see rust-lang/rust#64715 for details\"]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<!> for T {\n+impl<T> From<!> for T {\n     fn from(t: !) -> T {\n         t\n     }\n }\n \n // TryFrom implies TryInto\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T, U> const TryInto<U> for T\n+impl<T, U> TryInto<U> for T\n where\n-    U: ~const TryFrom<T>,\n+    U: TryFrom<T>,\n {\n     type Error = U::Error;\n \n@@ -773,10 +760,9 @@ where\n // Infallible conversions are semantically equivalent to fallible conversions\n // with an uninhabited error type.\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T, U> const TryFrom<U> for T\n+impl<T, U> TryFrom<U> for T\n where\n-    U: ~const Into<T>,\n+    U: Into<T>,\n {\n     type Error = Infallible;\n \n@@ -876,8 +862,7 @@ impl AsMut<str> for str {\n pub enum Infallible {}\n \n #[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-impl const Clone for Infallible {\n+impl Clone for Infallible {\n     fn clone(&self) -> Infallible {\n         match *self {}\n     }\n@@ -929,8 +914,7 @@ impl Ord for Infallible {\n }\n \n #[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<!> for Infallible {\n+impl From<!> for Infallible {\n     fn from(x: !) -> Self {\n         x\n     }"}, {"sha": "56ab63be27d37def1df7a18ed203ecc5a2d6e6e5", "filename": "library/core/src/convert/num.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -44,8 +44,7 @@ impl_float_to_int!(f64 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n macro_rules! impl_from {\n     ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n         #[$attr]\n-        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-        impl const From<$Small> for $Large {\n+        impl From<$Small> for $Large {\n             // Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.\n             // Rustdocs on functions do not.\n             #[doc = $doc]\n@@ -170,8 +169,7 @@ impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\"\n \n // bool -> Float\n #[stable(feature = \"float_from_bool\", since = \"1.68.0\")]\n-#[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-impl const From<bool> for f32 {\n+impl From<bool> for f32 {\n     /// Converts `bool` to `f32` losslessly. The resulting value is positive\n     /// `0.0` for `false` and `1.0` for `true` values.\n     ///\n@@ -190,8 +188,7 @@ impl const From<bool> for f32 {\n     }\n }\n #[stable(feature = \"float_from_bool\", since = \"1.68.0\")]\n-#[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-impl const From<bool> for f64 {\n+impl From<bool> for f64 {\n     /// Converts `bool` to `f64` losslessly. The resulting value is positive\n     /// `0.0` for `false` and `1.0` for `true` values.\n     ///\n@@ -214,8 +211,7 @@ impl const From<bool> for f64 {\n macro_rules! try_from_unbounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-        impl const TryFrom<$source> for $target {\n+        impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n             /// Try to create the target number type from a source\n@@ -233,8 +229,7 @@ macro_rules! try_from_unbounded {\n macro_rules! try_from_lower_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-        impl const TryFrom<$source> for $target {\n+        impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n             /// Try to create the target number type from a source\n@@ -256,8 +251,7 @@ macro_rules! try_from_lower_bounded {\n macro_rules! try_from_upper_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-        impl const TryFrom<$source> for $target {\n+        impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n             /// Try to create the target number type from a source\n@@ -279,8 +273,7 @@ macro_rules! try_from_upper_bounded {\n macro_rules! try_from_both_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-        impl const TryFrom<$source> for $target {\n+        impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n             /// Try to create the target number type from a source\n@@ -431,8 +424,7 @@ use crate::num::NonZeroUsize;\n macro_rules! nzint_impl_from {\n     ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n         #[$attr]\n-        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-        impl const From<$Small> for $Large {\n+        impl From<$Small> for $Large {\n             // Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.\n             // Rustdocs on functions do not.\n             #[doc = $doc]"}, {"sha": "09dbc95810f51216c18e3d8a39e0449d9eb6d194", "filename": "library/core/src/default.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fdefault.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -99,7 +99,6 @@\n /// ```\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Default\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[const_trait]\n pub trait Default: Sized {\n     /// Returns the \"default value\" for a type.\n     ///\n@@ -190,8 +189,7 @@ pub macro Default($item:item) {\n macro_rules! default_impl {\n     ($t:ty, $v:expr, $doc:tt) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-        impl const Default for $t {\n+        impl Default for $t {\n             #[inline]\n             #[doc = $doc]\n             fn default() -> $t {"}, {"sha": "bd2b2c36c4315af1f3b6222dc33f4dad270b1479", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -324,14 +324,15 @@ impl CStr {\n     /// assert_eq!(c_str.to_str().unwrap(), \"AAAAAAAA\");\n     /// ```\n     ///\n-    #[rustc_allow_const_fn_unstable(const_slice_index)]\n     #[stable(feature = \"cstr_from_bytes_until_nul\", since = \"1.69.0\")]\n     #[rustc_const_stable(feature = \"cstr_from_bytes_until_nul\", since = \"1.69.0\")]\n     pub const fn from_bytes_until_nul(bytes: &[u8]) -> Result<&CStr, FromBytesUntilNulError> {\n         let nul_pos = memchr::memchr(0, bytes);\n         match nul_pos {\n             Some(nul_pos) => {\n-                let subslice = &bytes[..nul_pos + 1];\n+                // FIXME(const-hack) replace with range index\n+                // SAFETY: nul_pos + 1 <= bytes.len()\n+                let subslice = unsafe { crate::slice::from_raw_parts(bytes.as_ptr(), nul_pos + 1) };\n                 // SAFETY: We know there is a nul byte at nul_pos, so this slice\n                 // (ending at the nul byte) is a well-formed C string.\n                 Ok(unsafe { CStr::from_bytes_with_nul_unchecked(subslice) })\n@@ -536,7 +537,8 @@ impl CStr {\n     pub const fn is_empty(&self) -> bool {\n         // SAFETY: We know there is at least one byte; for empty strings it\n         // is the NUL terminator.\n-        (unsafe { self.inner.get_unchecked(0) }) == &0\n+        // FIXME(const-hack): use get_unchecked\n+        unsafe { *self.inner.as_ptr() == 0 }\n     }\n \n     /// Converts this C string to a byte slice.\n@@ -560,8 +562,7 @@ impl CStr {\n     #[must_use = \"this returns the result of the operation, \\\n                   without modifying the original\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cstr_methods\", issue = \"101719\")]\n-    pub const fn to_bytes(&self) -> &[u8] {\n+    pub fn to_bytes(&self) -> &[u8] {\n         let bytes = self.to_bytes_with_nul();\n         // SAFETY: to_bytes_with_nul returns slice with length at least 1\n         unsafe { bytes.get_unchecked(..bytes.len() - 1) }\n@@ -612,8 +613,7 @@ impl CStr {\n     /// assert_eq!(cstr.to_str(), Ok(\"foo\"));\n     /// ```\n     #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n-    #[rustc_const_unstable(feature = \"const_cstr_methods\", issue = \"101719\")]\n-    pub const fn to_str(&self) -> Result<&str, str::Utf8Error> {\n+    pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n         // N.B., when `CStr` is changed to perform the length check in `.to_bytes()`\n         // instead of in `from_ptr()`, it may be worth considering if this should\n         // be rewritten to do the UTF-8 check inline with the length calculation"}, {"sha": "a73b5b610a4ad7e3f8dbcc72072464364e5e3625", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 31, "deletions": 60, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -86,8 +86,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fmt;\n-use crate::intrinsics::const_eval_select;\n-use crate::marker::{self, Destruct};\n+use crate::marker;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n@@ -184,7 +183,6 @@ mod sip;\n /// [impl]: ../../std/primitive.str.html#impl-Hash-for-str\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Hash\"]\n-#[const_trait]\n pub trait Hash {\n     /// Feeds this value into the given [`Hasher`].\n     ///\n@@ -199,7 +197,7 @@ pub trait Hash {\n     /// println!(\"Hash is {:x}!\", hasher.finish());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn hash<H: ~const Hasher>(&self, state: &mut H);\n+    fn hash<H: Hasher>(&self, state: &mut H);\n \n     /// Feeds a slice of this type into the given [`Hasher`].\n     ///\n@@ -236,25 +234,13 @@ pub trait Hash {\n     /// [`hash`]: Hash::hash\n     /// [`hash_slice`]: Hash::hash_slice\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n-    fn hash_slice<H: ~const Hasher>(data: &[Self], state: &mut H)\n+    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n     where\n         Self: Sized,\n     {\n-        //FIXME(const_trait_impl): revert to only a for loop\n-        fn rt<T: Hash, H: Hasher>(data: &[T], state: &mut H) {\n-            for piece in data {\n-                piece.hash(state)\n-            }\n-        }\n-        const fn ct<T: ~const Hash, H: ~const Hasher>(data: &[T], state: &mut H) {\n-            let mut i = 0;\n-            while i < data.len() {\n-                data[i].hash(state);\n-                i += 1;\n-            }\n+        for piece in data {\n+            piece.hash(state)\n         }\n-        // SAFETY: same behavior, CT just uses while instead of for\n-        unsafe { const_eval_select((data, state), ct, rt) };\n     }\n }\n \n@@ -327,7 +313,6 @@ pub use macros::Hash;\n /// [`write_u8`]: Hasher::write_u8\n /// [`write_u32`]: Hasher::write_u32\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[const_trait]\n pub trait Hasher {\n     /// Returns the hash value for the values written so far.\n     ///\n@@ -573,8 +558,7 @@ pub trait Hasher {\n }\n \n #[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\n-#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-impl<H: ~const Hasher + ?Sized> const Hasher for &mut H {\n+impl<H: Hasher + ?Sized> Hasher for &mut H {\n     fn finish(&self) -> u64 {\n         (**self).finish()\n     }\n@@ -654,7 +638,6 @@ impl<H: ~const Hasher + ?Sized> const Hasher for &mut H {\n /// [`build_hasher`]: BuildHasher::build_hasher\n /// [`HashMap`]: ../../std/collections/struct.HashMap.html\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n-#[const_trait]\n pub trait BuildHasher {\n     /// Type of the hasher that will be created.\n     #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n@@ -715,10 +698,10 @@ pub trait BuildHasher {\n     /// );\n     /// ```\n     #[unstable(feature = \"build_hasher_simple_hash_one\", issue = \"86161\")]\n-    fn hash_one<T: ~const Hash + ~const Destruct>(&self, x: T) -> u64\n+    fn hash_one<T: Hash>(&self, x: T) -> u64\n     where\n         Self: Sized,\n-        Self::Hasher: ~const Hasher + ~const Destruct,\n+        Self::Hasher: Hasher,\n     {\n         let mut hasher = self.build_hasher();\n         x.hash(&mut hasher);\n@@ -782,8 +765,7 @@ impl<H> fmt::Debug for BuildHasherDefault<H> {\n }\n \n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n-#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-impl<H: ~const Default + Hasher> const BuildHasher for BuildHasherDefault<H> {\n+impl<H: Default + Hasher> BuildHasher for BuildHasherDefault<H> {\n     type Hasher = H;\n \n     fn build_hasher(&self) -> H {\n@@ -799,8 +781,7 @@ impl<H> Clone for BuildHasherDefault<H> {\n }\n \n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<H> const Default for BuildHasherDefault<H> {\n+impl<H> Default for BuildHasherDefault<H> {\n     fn default() -> BuildHasherDefault<H> {\n         BuildHasherDefault(marker::PhantomData)\n     }\n@@ -825,15 +806,14 @@ mod impls {\n     macro_rules! impl_write {\n         ($(($ty:ident, $meth:ident),)*) => {$(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-            impl const Hash for $ty {\n+            impl Hash for $ty {\n                 #[inline]\n-                fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+                fn hash<H: Hasher>(&self, state: &mut H) {\n                     state.$meth(*self)\n                 }\n \n                 #[inline]\n-                fn hash_slice<H: ~const Hasher>(data: &[$ty], state: &mut H) {\n+                fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n                     let newlen = mem::size_of_val(data);\n                     let ptr = data.as_ptr() as *const u8;\n                     // SAFETY: `ptr` is valid and aligned, as this macro is only used\n@@ -862,60 +842,54 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-    impl const Hash for bool {\n+    impl Hash for bool {\n         #[inline]\n-        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n             state.write_u8(*self as u8)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-    impl const Hash for char {\n+    impl Hash for char {\n         #[inline]\n-        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n             state.write_u32(*self as u32)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-    impl const Hash for str {\n+    impl Hash for str {\n         #[inline]\n-        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n             state.write_str(self);\n         }\n     }\n \n     #[stable(feature = \"never_hash\", since = \"1.29.0\")]\n-    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-    impl const Hash for ! {\n+    impl Hash for ! {\n         #[inline]\n-        fn hash<H: ~const Hasher>(&self, _: &mut H) {\n+        fn hash<H: Hasher>(&self, _: &mut H) {\n             *self\n         }\n     }\n \n     macro_rules! impl_hash_tuple {\n         () => (\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-            impl const Hash for () {\n+            impl Hash for () {\n                 #[inline]\n-                fn hash<H: ~const Hasher>(&self, _state: &mut H) {}\n+                fn hash<H: Hasher>(&self, _state: &mut H) {}\n             }\n         );\n \n         ( $($name:ident)+) => (\n             maybe_tuple_doc! {\n                 $($name)+ @\n                 #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-                #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-                impl<$($name: ~const Hash),+> const Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n+                impl<$($name: Hash),+> Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n                     #[allow(non_snake_case)]\n                     #[inline]\n-                    fn hash<S: ~const Hasher>(&self, state: &mut S) {\n+                    fn hash<S: Hasher>(&self, state: &mut S) {\n                         let ($(ref $name,)+) = *self;\n                         $($name.hash(state);)+\n                     }\n@@ -958,29 +932,26 @@ mod impls {\n     impl_hash_tuple! { T B C D E F G H I J K L }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-    impl<T: ~const Hash> const Hash for [T] {\n+    impl<T: Hash> Hash for [T] {\n         #[inline]\n-        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n             state.write_length_prefix(self.len());\n             Hash::hash_slice(self, state)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-    impl<T: ?Sized + ~const Hash> const Hash for &T {\n+    impl<T: ?Sized + Hash> Hash for &T {\n         #[inline]\n-        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n             (**self).hash(state);\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-    impl<T: ?Sized + ~const Hash> const Hash for &mut T {\n+    impl<T: ?Sized + Hash> Hash for &mut T {\n         #[inline]\n-        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n             (**self).hash(state);\n         }\n     }"}, {"sha": "6b9f2e84257d185f66f81d721267d354c3ce637c", "filename": "library/core/src/hash/sip.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -118,7 +118,7 @@ macro_rules! load_int_le {\n /// Safety: this performs unchecked indexing of `buf` at `start..start+len`, so\n /// that must be in-bounds.\n #[inline]\n-const unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n+unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n     debug_assert!(len < 8);\n     let mut i = 0; // current byte index (from LSB) in the output u64\n     let mut out = 0;\n@@ -225,8 +225,7 @@ impl<S: Sip> Hasher<S> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-impl const super::Hasher for SipHasher {\n+impl super::Hasher for SipHasher {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         self.0.hasher.write(msg)\n@@ -244,8 +243,7 @@ impl const super::Hasher for SipHasher {\n }\n \n #[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n-#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-impl const super::Hasher for SipHasher13 {\n+impl super::Hasher for SipHasher13 {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         self.hasher.write(msg)\n@@ -262,7 +260,7 @@ impl const super::Hasher for SipHasher13 {\n     }\n }\n \n-impl<S: ~const Sip> const super::Hasher for Hasher<S> {\n+impl<S: Sip> super::Hasher for Hasher<S> {\n     // Note: no integer hashing methods (`write_u*`, `write_i*`) are defined\n     // for this type. We could add them, copy the `short_write` implementation\n     // in librustc_data_structures/sip128.rs, and add `write_u*`/`write_i*`\n@@ -342,7 +340,7 @@ impl<S: ~const Sip> const super::Hasher for Hasher<S> {\n     }\n }\n \n-impl<S: Sip> const Clone for Hasher<S> {\n+impl<S: Sip> Clone for Hasher<S> {\n     #[inline]\n     fn clone(&self) -> Hasher<S> {\n         Hasher {\n@@ -366,7 +364,6 @@ impl<S: Sip> Default for Hasher<S> {\n }\n \n #[doc(hidden)]\n-#[const_trait]\n trait Sip {\n     fn c_rounds(_: &mut State);\n     fn d_rounds(_: &mut State);\n@@ -375,7 +372,7 @@ trait Sip {\n #[derive(Debug, Clone, Default)]\n struct Sip13Rounds;\n \n-impl const Sip for Sip13Rounds {\n+impl Sip for Sip13Rounds {\n     #[inline]\n     fn c_rounds(state: &mut State) {\n         compress!(state);\n@@ -392,7 +389,7 @@ impl const Sip for Sip13Rounds {\n #[derive(Debug, Clone, Default)]\n struct Sip24Rounds;\n \n-impl const Sip for Sip24Rounds {\n+impl Sip for Sip24Rounds {\n     #[inline]\n     fn c_rounds(state: &mut State) {\n         compress!(state);"}, {"sha": "5774107f5207f7a9d04247b41cf5b1e2f9dbb2fc", "filename": "library/core/src/internal_macros.rs", "status": "modified", "additions": 4, "deletions": 67, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Finternal_macros.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,23 +1,10 @@\n // implements the unary operator \"op &T\"\n // based on \"op T\" where T is expected to be `Copy`able\n macro_rules! forward_ref_unop {\n-    (impl const $imp:ident, $method:ident for $t:ty) => {\n-        forward_ref_unop!(impl const $imp, $method for $t,\n+    (impl $imp:ident, $method:ident for $t:ty) => {\n+        forward_ref_unop!(impl $imp, $method for $t,\n                 #[stable(feature = \"rust1\", since = \"1.0.0\")]);\n     };\n-    // Equivalent to the non-const version, with the addition of `rustc_const_unstable`\n-    (impl const $imp:ident, $method:ident for $t:ty, #[$attr:meta]) => {\n-        #[$attr]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const $imp for &$t {\n-            type Output = <$t as $imp>::Output;\n-\n-            #[inline]\n-            fn $method(self) -> <$t as $imp>::Output {\n-                $imp::$method(*self)\n-            }\n-        }\n-    };\n     (impl $imp:ident, $method:ident for $t:ty, #[$attr:meta]) => {\n         #[$attr]\n         impl $imp for &$t {\n@@ -34,45 +21,10 @@ macro_rules! forward_ref_unop {\n // implements binary operators \"&T op U\", \"T op &U\", \"&T op &U\"\n // based on \"T op U\" where T and U are expected to be `Copy`able\n macro_rules! forward_ref_binop {\n-    (impl const $imp:ident, $method:ident for $t:ty, $u:ty) => {\n-        forward_ref_binop!(impl const $imp, $method for $t, $u,\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n+        forward_ref_binop!(impl $imp, $method for $t, $u,\n                 #[stable(feature = \"rust1\", since = \"1.0.0\")]);\n     };\n-    // Equivalent to the non-const version, with the addition of `rustc_const_unstable`\n-    (impl const $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n-        #[$attr]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl<'a> const $imp<$u> for &'a $t {\n-            type Output = <$t as $imp<$u>>::Output;\n-\n-            #[inline]\n-            fn $method(self, other: $u) -> <$t as $imp<$u>>::Output {\n-                $imp::$method(*self, other)\n-            }\n-        }\n-\n-        #[$attr]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const $imp<&$u> for $t {\n-            type Output = <$t as $imp<$u>>::Output;\n-\n-            #[inline]\n-            fn $method(self, other: &$u) -> <$t as $imp<$u>>::Output {\n-                $imp::$method(self, *other)\n-            }\n-        }\n-\n-        #[$attr]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const $imp<&$u> for &$t {\n-            type Output = <$t as $imp<$u>>::Output;\n-\n-            #[inline]\n-            fn $method(self, other: &$u) -> <$t as $imp<$u>>::Output {\n-                $imp::$method(*self, *other)\n-            }\n-        }\n-    };\n     (impl $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n         #[$attr]\n         impl<'a> $imp<$u> for &'a $t {\n@@ -113,21 +65,6 @@ macro_rules! forward_ref_op_assign {\n         forward_ref_op_assign!(impl $imp, $method for $t, $u,\n                 #[stable(feature = \"op_assign_builtins_by_ref\", since = \"1.22.0\")]);\n     };\n-    (impl const $imp:ident, $method:ident for $t:ty, $u:ty) => {\n-        forward_ref_op_assign!(impl const $imp, $method for $t, $u,\n-                #[stable(feature = \"op_assign_builtins_by_ref\", since = \"1.22.0\")]);\n-    };\n-    // Equivalent to the non-const version, with the addition of `rustc_const_unstable`\n-    (impl const $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n-        #[$attr]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const $imp<&$u> for $t {\n-            #[inline]\n-            fn $method(&mut self, other: &$u) {\n-                $imp::$method(self, *other);\n-            }\n-        }\n-    };\n     (impl $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n         #[$attr]\n         impl $imp<&$u> for $t {"}, {"sha": "243df015f9a26e767c4435583be54e86dea5a07c", "filename": "library/core/src/iter/sources/empty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -81,8 +81,7 @@ impl<T> Clone for Empty<T> {\n // not #[derive] because that adds a Default bound on T,\n // which isn't necessary.\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for Empty<T> {\n+impl<T> Default for Empty<T> {\n     fn default() -> Empty<T> {\n         Empty(marker::PhantomData)\n     }"}, {"sha": "76b3a32880d1b053046c3efcf9545f34be514121", "filename": "library/core/src/iter/traits/collect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -228,7 +228,6 @@ pub trait FromIterator<A>: Sized {\n #[rustc_diagnostic_item = \"IntoIterator\"]\n #[rustc_skip_array_during_method_dispatch]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[const_trait]\n pub trait IntoIterator {\n     /// The type of the elements being iterated over.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -264,7 +263,7 @@ pub trait IntoIterator {\n \n #[rustc_const_unstable(feature = \"const_intoiterator_identity\", issue = \"90603\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator> const IntoIterator for I {\n+impl<I: Iterator> IntoIterator for I {\n     type Item = I::Item;\n     type IntoIter = I;\n "}, {"sha": "dabfce1447483b9504333d137b4fc4ef3fdbbac6", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -70,7 +70,6 @@ fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n #[doc(notable_trait)]\n #[rustc_diagnostic_item = \"Iterator\"]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[const_trait]\n pub trait Iterator {\n     /// The type of the elements being iterated over.\n     #[rustc_diagnostic_item = \"IteratorItem\"]"}, {"sha": "24a9d81d03784e072b465fd8ff0b50f26bdce278", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -112,11 +112,7 @@\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n #![feature(const_char_from_u32_unchecked)]\n-#![feature(const_clone)]\n-#![feature(const_cmp)]\n-#![feature(const_convert)]\n #![feature(const_cstr_methods)]\n-#![feature(const_default_impls)]\n #![feature(const_discriminant)]\n #![feature(const_eval_select)]\n #![feature(const_exact_div)]\n@@ -131,14 +127,11 @@\n #![feature(const_intrinsic_forget)]\n #![feature(const_ipv4)]\n #![feature(const_ipv6)]\n-#![feature(const_is_char_boundary)]\n #![feature(const_likely)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n #![feature(const_maybe_uninit_assume_init)]\n #![feature(const_maybe_uninit_uninit_array)]\n #![feature(const_nonnull_new)]\n-#![feature(const_num_from_num)]\n-#![feature(const_ops)]\n #![feature(const_option)]\n #![feature(const_option_ext)]\n #![feature(const_pin)]\n@@ -151,7 +144,6 @@\n #![feature(const_ptr_write)]\n #![feature(const_raw_ptr_comparison)]\n #![feature(const_replace)]\n-#![feature(const_result_drop)]\n #![feature(const_size_of_val)]\n #![feature(const_size_of_val_raw)]\n #![feature(const_slice_from_raw_parts_mut)]\n@@ -161,7 +153,6 @@\n #![feature(const_slice_split_at_mut)]\n #![feature(const_str_from_utf8_unchecked_mut)]\n #![feature(const_swap)]\n-#![feature(const_trait_impl)]\n #![feature(const_transmute_copy)]\n #![feature(const_try)]\n #![feature(const_type_id)]\n@@ -207,9 +198,9 @@\n #![feature(const_mut_refs)]\n #![feature(const_precise_live_drops)]\n #![feature(const_refs_to_cell)]\n+#![feature(const_trait_impl)]\n #![feature(decl_macro)]\n #![feature(deprecated_suggestion)]\n-#![feature(derive_const)]\n #![feature(doc_cfg)]\n #![feature(doc_cfg_hide)]\n #![feature(doc_notable_trait)]"}, {"sha": "e85c0c0a688902d68f3cf768e0b81705f24745c4", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -732,8 +732,7 @@ impl<T: ?Sized> Clone for PhantomData<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T: ?Sized> const Default for PhantomData<T> {\n+impl<T: ?Sized> Default for PhantomData<T> {\n     fn default() -> Self {\n         Self\n     }\n@@ -858,8 +857,8 @@ impl<T: ?Sized> Unpin for *mut T {}\n #[unstable(feature = \"const_trait_impl\", issue = \"67792\")]\n #[lang = \"destruct\"]\n #[rustc_on_unimplemented(message = \"can't drop `{Self}`\", append_const_msg)]\n-#[const_trait]\n #[rustc_deny_explicit_impl]\n+#[const_trait]\n pub trait Destruct {}\n \n /// A marker for tuple types."}, {"sha": "5f3d66e3773f1edf257e2e8dd0cbdabdb09c9d50", "filename": "library/core/src/mem/manually_drop.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -146,8 +146,7 @@ impl<T: ?Sized> ManuallyDrop<T> {\n }\n \n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-#[rustc_const_unstable(feature = \"const_deref\", issue = \"88955\")]\n-impl<T: ?Sized> const Deref for ManuallyDrop<T> {\n+impl<T: ?Sized> Deref for ManuallyDrop<T> {\n     type Target = T;\n     #[inline(always)]\n     fn deref(&self) -> &T {\n@@ -156,8 +155,7 @@ impl<T: ?Sized> const Deref for ManuallyDrop<T> {\n }\n \n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-#[rustc_const_unstable(feature = \"const_deref\", issue = \"88955\")]\n-impl<T: ?Sized> const DerefMut for ManuallyDrop<T> {\n+impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n     #[inline(always)]\n     fn deref_mut(&mut self) -> &mut T {\n         &mut self.value"}, {"sha": "87ae30619c63bc091aec8e65c223f943905530de", "filename": "library/core/src/mem/transmutability.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -81,8 +81,7 @@ impl Assume {\n // FIXME(jswrenn): This const op is not actually usable. Why?\n // https://github.com/rust-lang/rust/pull/100726#issuecomment-1219928926\n #[unstable(feature = \"transmutability\", issue = \"99571\")]\n-#[rustc_const_unstable(feature = \"transmutability\", issue = \"99571\")]\n-impl const core::ops::Add for Assume {\n+impl core::ops::Add for Assume {\n     type Output = Assume;\n \n     fn add(self, other_assumptions: Assume) -> Assume {\n@@ -93,8 +92,7 @@ impl const core::ops::Add for Assume {\n // FIXME(jswrenn): This const op is not actually usable. Why?\n // https://github.com/rust-lang/rust/pull/100726#issuecomment-1219928926\n #[unstable(feature = \"transmutability\", issue = \"99571\")]\n-#[rustc_const_unstable(feature = \"transmutability\", issue = \"99571\")]\n-impl const core::ops::Sub for Assume {\n+impl core::ops::Sub for Assume {\n     type Output = Assume;\n \n     fn sub(self, other_assumptions: Assume) -> Assume {"}, {"sha": "2ad0f1dc5063e05ad1e8be800c6d436b3ea26a12", "filename": "library/core/src/num/error.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -26,15 +26,14 @@ impl Error for TryFromIntError {\n }\n \n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<Infallible> for TryFromIntError {\n+impl From<Infallible> for TryFromIntError {\n     fn from(x: Infallible) -> TryFromIntError {\n         match x {}\n     }\n }\n \n #[unstable(feature = \"never_type\", issue = \"35121\")]\n-impl const From<!> for TryFromIntError {\n+impl From<!> for TryFromIntError {\n     fn from(never: !) -> TryFromIntError {\n         // Match rather than coerce to make sure that code like\n         // `From<Infallible> for TryFromIntError` above will keep working"}, {"sha": "17715c9291feea7b3f67a03477949472e75dc8d3", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -785,7 +785,7 @@ macro_rules! int_impl {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shl`.\n             // Any legal shift amount is losslessly representable in the self type.\n-            unsafe { intrinsics::unchecked_shl(self, rhs.try_into().ok().unwrap_unchecked()) }\n+            unsafe { intrinsics::unchecked_shl(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }\n         }\n \n         /// Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is\n@@ -833,7 +833,7 @@ macro_rules! int_impl {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shr`.\n             // Any legal shift amount is losslessly representable in the self type.\n-            unsafe { intrinsics::unchecked_shr(self, rhs.try_into().ok().unwrap_unchecked()) }\n+            unsafe { intrinsics::unchecked_shr(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }\n         }\n \n         /// Checked absolute value. Computes `self.abs()`, returning `None` if\n@@ -2603,13 +2603,16 @@ macro_rules! int_impl {\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n-        #[rustc_allow_const_fn_unstable(const_cmp)]\n         pub const fn signum(self) -> Self {\n             // Picking the right way to phrase this is complicated\n             // (<https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign>)\n             // so delegate it to `Ord` which is already producing -1/0/+1\n             // exactly like we need and can be the place to deal with the complexity.\n-            self.cmp(&0) as _\n+\n+            // FIXME(const-hack): replace with cmp\n+            if self < 0 { -1 }\n+            else if self == 0 { 0 }\n+            else { 1 }\n         }\n \n         /// Returns `true` if `self` is positive and `false` if the number is zero or"}, {"sha": "fdd7be625ed9327020b58ebaee11d1c2848d1bb3", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -225,6 +225,23 @@ macro_rules! widening_impl {\n     };\n }\n \n+macro_rules! conv_rhs_for_unchecked_shift {\n+    ($SelfT:ty, $x:expr) => {{\n+        #[inline]\n+        fn conv(x: u32) -> $SelfT {\n+            // FIXME(const-hack) replace with `.try_into().ok().unwrap_unchecked()`.\n+            // SAFETY: Any legal shift amount must be losslessly representable in the self type.\n+            unsafe { x.try_into().ok().unwrap_unchecked() }\n+        }\n+        #[inline]\n+        const fn const_conv(x: u32) -> $SelfT {\n+            x as _\n+        }\n+\n+        intrinsics::const_eval_select(($x,), const_conv, conv)\n+    }};\n+}\n+\n impl i8 {\n     int_impl! {\n         Self = i8,"}, {"sha": "54e03067d1c7ae5ed260a420022cbb56b3d0d7d1", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -96,8 +96,7 @@ macro_rules! nonzero_integers {\n             }\n \n             #[stable(feature = \"from_nonzero\", since = \"1.31.0\")]\n-            #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-            impl const From<$Ty> for $Int {\n+            impl From<$Ty> for $Int {\n                 #[doc = concat!(\"Converts a `\", stringify!($Ty), \"` into an `\", stringify!($Int), \"`\")]\n                 #[inline]\n                 fn from(nonzero: $Ty) -> Self {\n@@ -106,8 +105,7 @@ macro_rules! nonzero_integers {\n             }\n \n             #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-            impl const BitOr for $Ty {\n+            impl BitOr for $Ty {\n                 type Output = Self;\n                 #[inline]\n                 fn bitor(self, rhs: Self) -> Self::Output {\n@@ -118,8 +116,7 @@ macro_rules! nonzero_integers {\n             }\n \n             #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-            impl const BitOr<$Int> for $Ty {\n+            impl BitOr<$Int> for $Ty {\n                 type Output = Self;\n                 #[inline]\n                 fn bitor(self, rhs: $Int) -> Self::Output {\n@@ -131,8 +128,7 @@ macro_rules! nonzero_integers {\n             }\n \n             #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-            impl const BitOr<$Ty> for $Int {\n+            impl BitOr<$Ty> for $Int {\n                 type Output = $Ty;\n                 #[inline]\n                 fn bitor(self, rhs: $Ty) -> Self::Output {\n@@ -144,17 +140,15 @@ macro_rules! nonzero_integers {\n             }\n \n             #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-            impl const BitOrAssign for $Ty {\n+            impl BitOrAssign for $Ty {\n                 #[inline]\n                 fn bitor_assign(&mut self, rhs: Self) {\n                     *self = *self | rhs;\n                 }\n             }\n \n             #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-            impl const BitOrAssign<$Int> for $Ty {\n+            impl BitOrAssign<$Int> for $Ty {\n                 #[inline]\n                 fn bitor_assign(&mut self, rhs: $Int) {\n                     *self = *self | rhs;\n@@ -276,8 +270,7 @@ macro_rules! nonzero_integers_div {\n     ( $( $Ty: ident($Int: ty); )+ ) => {\n         $(\n             #[stable(feature = \"nonzero_div\", since = \"1.51.0\")]\n-            #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-            impl const Div<$Ty> for $Int {\n+            impl Div<$Ty> for $Int {\n                 type Output = $Int;\n                 /// This operation rounds towards zero,\n                 /// truncating any fractional part of the exact result, and cannot panic.\n@@ -290,8 +283,7 @@ macro_rules! nonzero_integers_div {\n             }\n \n             #[stable(feature = \"nonzero_div\", since = \"1.51.0\")]\n-            #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-            impl const Rem<$Ty> for $Int {\n+            impl Rem<$Ty> for $Int {\n                 type Output = $Int;\n                 /// This operation satisfies `n % d == n - (n / d) * d`, and cannot panic.\n                 #[inline]"}, {"sha": "6f6b6dbb80b3fa9b7434623d637b394693b02ebe", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -939,7 +939,7 @@ macro_rules! uint_impl {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shl`.\n             // Any legal shift amount is losslessly representable in the self type.\n-            unsafe { intrinsics::unchecked_shl(self, rhs.try_into().ok().unwrap_unchecked()) }\n+            unsafe { intrinsics::unchecked_shl(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }\n         }\n \n         /// Checked shift right. Computes `self >> rhs`, returning `None`\n@@ -987,7 +987,7 @@ macro_rules! uint_impl {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_shr`.\n             // Any legal shift amount is losslessly representable in the self type.\n-            unsafe { intrinsics::unchecked_shr(self, rhs.try_into().ok().unwrap_unchecked()) }\n+            unsafe { intrinsics::unchecked_shr(self, conv_rhs_for_unchecked_shift!($SelfT, rhs)) }\n         }\n \n         /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if"}, {"sha": "ed354a2e50bda9b4c4cabb9b1a626e0cb3e7bd75", "filename": "library/core/src/num/wrapping.rs", "status": "modified", "additions": 67, "deletions": 101, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fwrapping.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -87,8 +87,7 @@ impl<T: fmt::UpperHex> fmt::UpperHex for Wrapping<T> {\n macro_rules! sh_impl_signed {\n     ($t:ident, $f:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Shl<$f> for Wrapping<$t> {\n+        impl Shl<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n@@ -100,22 +99,20 @@ macro_rules! sh_impl_signed {\n                 }\n             }\n         }\n-        forward_ref_binop! { impl const Shl, shl for Wrapping<$t>, $f,\n+        forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n         #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const ShlAssign<$f> for Wrapping<$t> {\n+        impl ShlAssign<$f> for Wrapping<$t> {\n             #[inline]\n             fn shl_assign(&mut self, other: $f) {\n                 *self = *self << other;\n             }\n         }\n-        forward_ref_op_assign! { impl const ShlAssign, shl_assign for Wrapping<$t>, $f }\n+        forward_ref_op_assign! { impl ShlAssign, shl_assign for Wrapping<$t>, $f }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Shr<$f> for Wrapping<$t> {\n+        impl Shr<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n@@ -127,68 +124,63 @@ macro_rules! sh_impl_signed {\n                 }\n             }\n         }\n-        forward_ref_binop! { impl const Shr, shr for Wrapping<$t>, $f,\n+        forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n         #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const ShrAssign<$f> for Wrapping<$t> {\n+        impl ShrAssign<$f> for Wrapping<$t> {\n             #[inline]\n             fn shr_assign(&mut self, other: $f) {\n                 *self = *self >> other;\n             }\n         }\n-        forward_ref_op_assign! { impl const ShrAssign, shr_assign for Wrapping<$t>, $f }\n+        forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n     };\n }\n \n macro_rules! sh_impl_unsigned {\n     ($t:ident, $f:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Shl<$f> for Wrapping<$t> {\n+        impl Shl<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn shl(self, other: $f) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))\n             }\n         }\n-        forward_ref_binop! { impl const Shl, shl for Wrapping<$t>, $f,\n+        forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n         #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const ShlAssign<$f> for Wrapping<$t> {\n+        impl ShlAssign<$f> for Wrapping<$t> {\n             #[inline]\n             fn shl_assign(&mut self, other: $f) {\n                 *self = *self << other;\n             }\n         }\n-        forward_ref_op_assign! { impl const ShlAssign, shl_assign for Wrapping<$t>, $f }\n+        forward_ref_op_assign! { impl ShlAssign, shl_assign for Wrapping<$t>, $f }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Shr<$f> for Wrapping<$t> {\n+        impl Shr<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn shr(self, other: $f) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))\n             }\n         }\n-        forward_ref_binop! { impl const Shr, shr for Wrapping<$t>, $f,\n+        forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n         #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const ShrAssign<$f> for Wrapping<$t> {\n+        impl ShrAssign<$f> for Wrapping<$t> {\n             #[inline]\n             fn shr_assign(&mut self, other: $f) {\n                 *self = *self >> other;\n             }\n         }\n-        forward_ref_op_assign! { impl const ShrAssign, shr_assign for Wrapping<$t>, $f }\n+        forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n     };\n }\n \n@@ -217,74 +209,67 @@ sh_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n macro_rules! wrapping_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Add for Wrapping<$t> {\n+        impl Add for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_add(other.0))\n             }\n         }\n-        forward_ref_binop! { impl const Add, add for Wrapping<$t>, Wrapping<$t>,\n+        forward_ref_binop! { impl Add, add for Wrapping<$t>, Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const AddAssign for Wrapping<$t> {\n+        impl AddAssign for Wrapping<$t> {\n             #[inline]\n             fn add_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self + other;\n             }\n         }\n-        forward_ref_op_assign! { impl const AddAssign, add_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl AddAssign, add_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const AddAssign<$t> for Wrapping<$t> {\n+        impl AddAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn add_assign(&mut self, other: $t) {\n                 *self = *self + Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const AddAssign, add_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl AddAssign, add_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Sub for Wrapping<$t> {\n+        impl Sub for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_sub(other.0))\n             }\n         }\n-        forward_ref_binop! { impl const Sub, sub for Wrapping<$t>, Wrapping<$t>,\n+        forward_ref_binop! { impl Sub, sub for Wrapping<$t>, Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const SubAssign for Wrapping<$t> {\n+        impl SubAssign for Wrapping<$t> {\n             #[inline]\n             fn sub_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self - other;\n             }\n         }\n-        forward_ref_op_assign! { impl const SubAssign, sub_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl SubAssign, sub_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const SubAssign<$t> for Wrapping<$t> {\n+        impl SubAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn sub_assign(&mut self, other: $t) {\n                 *self = *self - Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const SubAssign, sub_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl SubAssign, sub_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Mul for Wrapping<$t> {\n+        impl Mul for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n@@ -296,213 +281,194 @@ macro_rules! wrapping_impl {\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const MulAssign for Wrapping<$t> {\n+        impl MulAssign for Wrapping<$t> {\n             #[inline]\n             fn mul_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self * other;\n             }\n         }\n-        forward_ref_op_assign! { impl const MulAssign, mul_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl MulAssign, mul_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const MulAssign<$t> for Wrapping<$t> {\n+        impl MulAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn mul_assign(&mut self, other: $t) {\n                 *self = *self * Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const MulAssign, mul_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl MulAssign, mul_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"wrapping_div\", since = \"1.3.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Div for Wrapping<$t> {\n+        impl Div for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_div(other.0))\n             }\n         }\n-        forward_ref_binop! { impl const Div, div for Wrapping<$t>, Wrapping<$t>,\n+        forward_ref_binop! { impl Div, div for Wrapping<$t>, Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const DivAssign for Wrapping<$t> {\n+        impl DivAssign for Wrapping<$t> {\n             #[inline]\n             fn div_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self / other;\n             }\n         }\n-        forward_ref_op_assign! { impl const DivAssign, div_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl DivAssign, div_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const DivAssign<$t> for Wrapping<$t> {\n+        impl DivAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn div_assign(&mut self, other: $t) {\n                 *self = *self / Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const DivAssign, div_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl DivAssign, div_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Rem for Wrapping<$t> {\n+        impl Rem for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_rem(other.0))\n             }\n         }\n-        forward_ref_binop! { impl const Rem, rem for Wrapping<$t>, Wrapping<$t>,\n+        forward_ref_binop! { impl Rem, rem for Wrapping<$t>, Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const RemAssign for Wrapping<$t> {\n+        impl RemAssign for Wrapping<$t> {\n             #[inline]\n             fn rem_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self % other;\n             }\n         }\n-        forward_ref_op_assign! { impl const RemAssign, rem_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl RemAssign, rem_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const RemAssign<$t> for Wrapping<$t> {\n+        impl RemAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn rem_assign(&mut self, other: $t) {\n                 *self = *self % Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const RemAssign, rem_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl RemAssign, rem_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Not for Wrapping<$t> {\n+        impl Not for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn not(self) -> Wrapping<$t> {\n                 Wrapping(!self.0)\n             }\n         }\n-        forward_ref_unop! { impl const Not, not for Wrapping<$t>,\n+        forward_ref_unop! { impl Not, not for Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitXor for Wrapping<$t> {\n+        impl BitXor for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0 ^ other.0)\n             }\n         }\n-        forward_ref_binop! { impl const BitXor, bitxor for Wrapping<$t>, Wrapping<$t>,\n+        forward_ref_binop! { impl BitXor, bitxor for Wrapping<$t>, Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitXorAssign for Wrapping<$t> {\n+        impl BitXorAssign for Wrapping<$t> {\n             #[inline]\n             fn bitxor_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self ^ other;\n             }\n         }\n-        forward_ref_op_assign! { impl const BitXorAssign, bitxor_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitXorAssign<$t> for Wrapping<$t> {\n+        impl BitXorAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn bitxor_assign(&mut self, other: $t) {\n                 *self = *self ^ Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const BitXorAssign, bitxor_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitOr for Wrapping<$t> {\n+        impl BitOr for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0 | other.0)\n             }\n         }\n-        forward_ref_binop! { impl const BitOr, bitor for Wrapping<$t>, Wrapping<$t>,\n+        forward_ref_binop! { impl BitOr, bitor for Wrapping<$t>, Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitOrAssign for Wrapping<$t> {\n+        impl BitOrAssign for Wrapping<$t> {\n             #[inline]\n             fn bitor_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self | other;\n             }\n         }\n-        forward_ref_op_assign! { impl const BitOrAssign, bitor_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitOrAssign<$t> for Wrapping<$t> {\n+        impl BitOrAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn bitor_assign(&mut self, other: $t) {\n                 *self = *self | Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const BitOrAssign, bitor_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitAnd for Wrapping<$t> {\n+        impl BitAnd for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0 & other.0)\n             }\n         }\n-        forward_ref_binop! { impl const BitAnd, bitand for Wrapping<$t>, Wrapping<$t>,\n+        forward_ref_binop! { impl BitAnd, bitand for Wrapping<$t>, Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitAndAssign for Wrapping<$t> {\n+        impl BitAndAssign for Wrapping<$t> {\n             #[inline]\n             fn bitand_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self & other;\n             }\n         }\n-        forward_ref_op_assign! { impl const BitAndAssign, bitand_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitAndAssign<$t> for Wrapping<$t> {\n+        impl BitAndAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn bitand_assign(&mut self, other: $t) {\n                 *self = *self & Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const BitAndAssign, bitand_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"wrapping_neg\", since = \"1.10.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Neg for Wrapping<$t> {\n+        impl Neg for Wrapping<$t> {\n             type Output = Self;\n             #[inline]\n             fn neg(self) -> Self {\n                 Wrapping(0) - self\n             }\n         }\n-        forward_ref_unop! { impl const Neg, neg for Wrapping<$t>,\n+        forward_ref_unop! { impl Neg, neg for Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n     )*)"}, {"sha": "1501dc4e38b710e5fcc432413f7be0445a375740", "filename": "library/core/src/ops/arith.rs", "status": "modified", "additions": 26, "deletions": 50, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Farith.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -73,7 +73,6 @@\n     append_const_msg\n )]\n #[doc(alias = \"+\")]\n-#[const_trait]\n pub trait Add<Rhs = Self> {\n     /// The resulting type after applying the `+` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -95,16 +94,15 @@ pub trait Add<Rhs = Self> {\n macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Add for $t {\n+        impl Add for $t {\n             type Output = $t;\n \n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn add(self, other: $t) -> $t { self + other }\n         }\n \n-        forward_ref_binop! { impl const Add, add for $t, $t }\n+        forward_ref_binop! { impl Add, add for $t, $t }\n     )*)\n }\n \n@@ -183,7 +181,6 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n     append_const_msg\n )]\n #[doc(alias = \"-\")]\n-#[const_trait]\n pub trait Sub<Rhs = Self> {\n     /// The resulting type after applying the `-` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -205,16 +202,15 @@ pub trait Sub<Rhs = Self> {\n macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Sub for $t {\n+        impl Sub for $t {\n             type Output = $t;\n \n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn sub(self, other: $t) -> $t { self - other }\n         }\n \n-        forward_ref_binop! { impl const Sub, sub for $t, $t }\n+        forward_ref_binop! { impl Sub, sub for $t, $t }\n     )*)\n }\n \n@@ -314,7 +310,6 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n     label = \"no implementation for `{Self} * {Rhs}`\"\n )]\n #[doc(alias = \"*\")]\n-#[const_trait]\n pub trait Mul<Rhs = Self> {\n     /// The resulting type after applying the `*` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -336,16 +331,15 @@ pub trait Mul<Rhs = Self> {\n macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Mul for $t {\n+        impl Mul for $t {\n             type Output = $t;\n \n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn mul(self, other: $t) -> $t { self * other }\n         }\n \n-        forward_ref_binop! { impl const Mul, mul for $t, $t }\n+        forward_ref_binop! { impl Mul, mul for $t, $t }\n     )*)\n }\n \n@@ -449,7 +443,6 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n     label = \"no implementation for `{Self} / {Rhs}`\"\n )]\n #[doc(alias = \"/\")]\n-#[const_trait]\n pub trait Div<Rhs = Self> {\n     /// The resulting type after applying the `/` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -477,15 +470,14 @@ macro_rules! div_impl_integer {\n         ///\n         #[doc = $panic]\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Div for $t {\n+        impl Div for $t {\n             type Output = $t;\n \n             #[inline]\n             fn div(self, other: $t) -> $t { self / other }\n         }\n \n-        forward_ref_binop! { impl const Div, div for $t, $t }\n+        forward_ref_binop! { impl Div, div for $t, $t }\n     )*)*)\n }\n \n@@ -497,15 +489,14 @@ div_impl_integer! {\n macro_rules! div_impl_float {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Div for $t {\n+        impl Div for $t {\n             type Output = $t;\n \n             #[inline]\n             fn div(self, other: $t) -> $t { self / other }\n         }\n \n-        forward_ref_binop! { impl const Div, div for $t, $t }\n+        forward_ref_binop! { impl Div, div for $t, $t }\n     )*)\n }\n \n@@ -553,7 +544,6 @@ div_impl_float! { f32 f64 }\n     label = \"no implementation for `{Self} % {Rhs}`\"\n )]\n #[doc(alias = \"%\")]\n-#[const_trait]\n pub trait Rem<Rhs = Self> {\n     /// The resulting type after applying the `%` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -581,15 +571,14 @@ macro_rules! rem_impl_integer {\n         ///\n         #[doc = $panic]\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Rem for $t {\n+        impl Rem for $t {\n             type Output = $t;\n \n             #[inline]\n             fn rem(self, other: $t) -> $t { self % other }\n         }\n \n-        forward_ref_binop! { impl const Rem, rem for $t, $t }\n+        forward_ref_binop! { impl Rem, rem for $t, $t }\n     )*)*)\n }\n \n@@ -616,15 +605,14 @@ macro_rules! rem_impl_float {\n         /// assert_eq!(x % y, remainder);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Rem for $t {\n+        impl Rem for $t {\n             type Output = $t;\n \n             #[inline]\n             fn rem(self, other: $t) -> $t { self % other }\n         }\n \n-        forward_ref_binop! { impl const Rem, rem for $t, $t }\n+        forward_ref_binop! { impl Rem, rem for $t, $t }\n     )*)\n }\n \n@@ -669,7 +657,6 @@ rem_impl_float! { f32 f64 }\n #[lang = \"neg\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"-\")]\n-#[const_trait]\n pub trait Neg {\n     /// The resulting type after applying the `-` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -692,16 +679,15 @@ pub trait Neg {\n macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Neg for $t {\n+        impl Neg for $t {\n             type Output = $t;\n \n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn neg(self) -> $t { -self }\n         }\n \n-        forward_ref_unop! { impl const Neg, neg for $t }\n+        forward_ref_unop! { impl Neg, neg for $t }\n     )*)\n }\n \n@@ -744,7 +730,6 @@ neg_impl! { isize i8 i16 i32 i64 i128 f32 f64 }\n )]\n #[doc(alias = \"+\")]\n #[doc(alias = \"+=\")]\n-#[const_trait]\n pub trait AddAssign<Rhs = Self> {\n     /// Performs the `+=` operation.\n     ///\n@@ -762,14 +747,13 @@ pub trait AddAssign<Rhs = Self> {\n macro_rules! add_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const AddAssign for $t {\n+        impl AddAssign for $t {\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn add_assign(&mut self, other: $t) { *self += other }\n         }\n \n-        forward_ref_op_assign! { impl const AddAssign, add_assign for $t, $t }\n+        forward_ref_op_assign! { impl AddAssign, add_assign for $t, $t }\n     )+)\n }\n \n@@ -812,7 +796,6 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n )]\n #[doc(alias = \"-\")]\n #[doc(alias = \"-=\")]\n-#[const_trait]\n pub trait SubAssign<Rhs = Self> {\n     /// Performs the `-=` operation.\n     ///\n@@ -830,14 +813,13 @@ pub trait SubAssign<Rhs = Self> {\n macro_rules! sub_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const SubAssign for $t {\n+        impl SubAssign for $t {\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn sub_assign(&mut self, other: $t) { *self -= other }\n         }\n \n-        forward_ref_op_assign! { impl const SubAssign, sub_assign for $t, $t }\n+        forward_ref_op_assign! { impl SubAssign, sub_assign for $t, $t }\n     )+)\n }\n \n@@ -871,7 +853,6 @@ sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n )]\n #[doc(alias = \"*\")]\n #[doc(alias = \"*=\")]\n-#[const_trait]\n pub trait MulAssign<Rhs = Self> {\n     /// Performs the `*=` operation.\n     ///\n@@ -889,14 +870,13 @@ pub trait MulAssign<Rhs = Self> {\n macro_rules! mul_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const MulAssign for $t {\n+        impl MulAssign for $t {\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn mul_assign(&mut self, other: $t) { *self *= other }\n         }\n \n-        forward_ref_op_assign! { impl const MulAssign, mul_assign for $t, $t }\n+        forward_ref_op_assign! { impl MulAssign, mul_assign for $t, $t }\n     )+)\n }\n \n@@ -930,7 +910,6 @@ mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n )]\n #[doc(alias = \"/\")]\n #[doc(alias = \"/=\")]\n-#[const_trait]\n pub trait DivAssign<Rhs = Self> {\n     /// Performs the `/=` operation.\n     ///\n@@ -948,13 +927,12 @@ pub trait DivAssign<Rhs = Self> {\n macro_rules! div_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const DivAssign for $t {\n+        impl DivAssign for $t {\n             #[inline]\n             fn div_assign(&mut self, other: $t) { *self /= other }\n         }\n \n-        forward_ref_op_assign! { impl const DivAssign, div_assign for $t, $t }\n+        forward_ref_op_assign! { impl DivAssign, div_assign for $t, $t }\n     )+)\n }\n \n@@ -992,7 +970,6 @@ div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n )]\n #[doc(alias = \"%\")]\n #[doc(alias = \"%=\")]\n-#[const_trait]\n pub trait RemAssign<Rhs = Self> {\n     /// Performs the `%=` operation.\n     ///\n@@ -1010,13 +987,12 @@ pub trait RemAssign<Rhs = Self> {\n macro_rules! rem_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const RemAssign for $t {\n+        impl RemAssign for $t {\n             #[inline]\n             fn rem_assign(&mut self, other: $t) { *self %= other }\n         }\n \n-        forward_ref_op_assign! { impl const RemAssign, rem_assign for $t, $t }\n+        forward_ref_op_assign! { impl RemAssign, rem_assign for $t, $t }\n     )+)\n }\n "}, {"sha": "c70f4a3da2ed8fe2627bf3ee65af701fb750ee21", "filename": "library/core/src/ops/bit.rs", "status": "modified", "additions": 23, "deletions": 46, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fbit.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -31,7 +31,6 @@\n #[lang = \"not\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"!\")]\n-#[const_trait]\n pub trait Not {\n     /// The resulting type after applying the `!` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -55,23 +54,21 @@ pub trait Not {\n macro_rules! not_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Not for $t {\n+        impl Not for $t {\n             type Output = $t;\n \n             #[inline]\n             fn not(self) -> $t { !self }\n         }\n \n-        forward_ref_unop! { impl const Not, not for $t }\n+        forward_ref_unop! { impl Not, not for $t }\n     )*)\n }\n \n not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n #[stable(feature = \"not_never\", since = \"1.60.0\")]\n-#[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-impl const Not for ! {\n+impl Not for ! {\n     type Output = !;\n \n     #[inline]\n@@ -144,7 +141,6 @@ impl const Not for ! {\n     message = \"no implementation for `{Self} & {Rhs}`\",\n     label = \"no implementation for `{Self} & {Rhs}`\"\n )]\n-#[const_trait]\n pub trait BitAnd<Rhs = Self> {\n     /// The resulting type after applying the `&` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -168,15 +164,14 @@ pub trait BitAnd<Rhs = Self> {\n macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitAnd for $t {\n+        impl BitAnd for $t {\n             type Output = $t;\n \n             #[inline]\n             fn bitand(self, rhs: $t) -> $t { self & rhs }\n         }\n \n-        forward_ref_binop! { impl const BitAnd, bitand for $t, $t }\n+        forward_ref_binop! { impl BitAnd, bitand for $t, $t }\n     )*)\n }\n \n@@ -246,7 +241,6 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n     message = \"no implementation for `{Self} | {Rhs}`\",\n     label = \"no implementation for `{Self} | {Rhs}`\"\n )]\n-#[const_trait]\n pub trait BitOr<Rhs = Self> {\n     /// The resulting type after applying the `|` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -270,15 +264,14 @@ pub trait BitOr<Rhs = Self> {\n macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitOr for $t {\n+        impl BitOr for $t {\n             type Output = $t;\n \n             #[inline]\n             fn bitor(self, rhs: $t) -> $t { self | rhs }\n         }\n \n-        forward_ref_binop! { impl const BitOr, bitor for $t, $t }\n+        forward_ref_binop! { impl BitOr, bitor for $t, $t }\n     )*)\n }\n \n@@ -348,7 +341,6 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n     message = \"no implementation for `{Self} ^ {Rhs}`\",\n     label = \"no implementation for `{Self} ^ {Rhs}`\"\n )]\n-#[const_trait]\n pub trait BitXor<Rhs = Self> {\n     /// The resulting type after applying the `^` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -372,15 +364,14 @@ pub trait BitXor<Rhs = Self> {\n macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitXor for $t {\n+        impl BitXor for $t {\n             type Output = $t;\n \n             #[inline]\n             fn bitxor(self, other: $t) -> $t { self ^ other }\n         }\n \n-        forward_ref_binop! { impl const BitXor, bitxor for $t, $t }\n+        forward_ref_binop! { impl BitXor, bitxor for $t, $t }\n     )*)\n }\n \n@@ -449,7 +440,6 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n     message = \"no implementation for `{Self} << {Rhs}`\",\n     label = \"no implementation for `{Self} << {Rhs}`\"\n )]\n-#[const_trait]\n pub trait Shl<Rhs = Self> {\n     /// The resulting type after applying the `<<` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -471,8 +461,7 @@ pub trait Shl<Rhs = Self> {\n macro_rules! shl_impl {\n     ($t:ty, $f:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Shl<$f> for $t {\n+        impl Shl<$f> for $t {\n             type Output = $t;\n \n             #[inline]\n@@ -482,7 +471,7 @@ macro_rules! shl_impl {\n             }\n         }\n \n-        forward_ref_binop! { impl const Shl, shl for $t, $f }\n+        forward_ref_binop! { impl Shl, shl for $t, $f }\n     };\n }\n \n@@ -569,7 +558,6 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n     message = \"no implementation for `{Self} >> {Rhs}`\",\n     label = \"no implementation for `{Self} >> {Rhs}`\"\n )]\n-#[const_trait]\n pub trait Shr<Rhs = Self> {\n     /// The resulting type after applying the `>>` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -591,8 +579,7 @@ pub trait Shr<Rhs = Self> {\n macro_rules! shr_impl {\n     ($t:ty, $f:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Shr<$f> for $t {\n+        impl Shr<$f> for $t {\n             type Output = $t;\n \n             #[inline]\n@@ -602,7 +589,7 @@ macro_rules! shr_impl {\n             }\n         }\n \n-        forward_ref_binop! { impl const Shr, shr for $t, $f }\n+        forward_ref_binop! { impl Shr, shr for $t, $f }\n     };\n }\n \n@@ -698,7 +685,6 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n     message = \"no implementation for `{Self} &= {Rhs}`\",\n     label = \"no implementation for `{Self} &= {Rhs}`\"\n )]\n-#[const_trait]\n pub trait BitAndAssign<Rhs = Self> {\n     /// Performs the `&=` operation.\n     ///\n@@ -728,13 +714,12 @@ pub trait BitAndAssign<Rhs = Self> {\n macro_rules! bitand_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitAndAssign for $t {\n+        impl BitAndAssign for $t {\n             #[inline]\n             fn bitand_assign(&mut self, other: $t) { *self &= other }\n         }\n \n-        forward_ref_op_assign! { impl const BitAndAssign, bitand_assign for $t, $t }\n+        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for $t, $t }\n     )+)\n }\n \n@@ -771,7 +756,6 @@ bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n     message = \"no implementation for `{Self} |= {Rhs}`\",\n     label = \"no implementation for `{Self} |= {Rhs}`\"\n )]\n-#[const_trait]\n pub trait BitOrAssign<Rhs = Self> {\n     /// Performs the `|=` operation.\n     ///\n@@ -801,13 +785,12 @@ pub trait BitOrAssign<Rhs = Self> {\n macro_rules! bitor_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitOrAssign for $t {\n+        impl BitOrAssign for $t {\n             #[inline]\n             fn bitor_assign(&mut self, other: $t) { *self |= other }\n         }\n \n-        forward_ref_op_assign! { impl const BitOrAssign, bitor_assign for $t, $t }\n+        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for $t, $t }\n     )+)\n }\n \n@@ -844,7 +827,6 @@ bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n     message = \"no implementation for `{Self} ^= {Rhs}`\",\n     label = \"no implementation for `{Self} ^= {Rhs}`\"\n )]\n-#[const_trait]\n pub trait BitXorAssign<Rhs = Self> {\n     /// Performs the `^=` operation.\n     ///\n@@ -874,13 +856,12 @@ pub trait BitXorAssign<Rhs = Self> {\n macro_rules! bitxor_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitXorAssign for $t {\n+        impl BitXorAssign for $t {\n             #[inline]\n             fn bitxor_assign(&mut self, other: $t) { *self ^= other }\n         }\n \n-        forward_ref_op_assign! { impl const BitXorAssign, bitxor_assign for $t, $t }\n+        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for $t, $t }\n     )+)\n }\n \n@@ -915,7 +896,6 @@ bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n     message = \"no implementation for `{Self} <<= {Rhs}`\",\n     label = \"no implementation for `{Self} <<= {Rhs}`\"\n )]\n-#[const_trait]\n pub trait ShlAssign<Rhs = Self> {\n     /// Performs the `<<=` operation.\n     ///\n@@ -937,16 +917,15 @@ pub trait ShlAssign<Rhs = Self> {\n macro_rules! shl_assign_impl {\n     ($t:ty, $f:ty) => {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const ShlAssign<$f> for $t {\n+        impl ShlAssign<$f> for $t {\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn shl_assign(&mut self, other: $f) {\n                 *self <<= other\n             }\n         }\n \n-        forward_ref_op_assign! { impl const ShlAssign, shl_assign for $t, $f }\n+        forward_ref_op_assign! { impl ShlAssign, shl_assign for $t, $f }\n     };\n }\n \n@@ -999,7 +978,6 @@ shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n     message = \"no implementation for `{Self} >>= {Rhs}`\",\n     label = \"no implementation for `{Self} >>= {Rhs}`\"\n )]\n-#[const_trait]\n pub trait ShrAssign<Rhs = Self> {\n     /// Performs the `>>=` operation.\n     ///\n@@ -1021,16 +999,15 @@ pub trait ShrAssign<Rhs = Self> {\n macro_rules! shr_assign_impl {\n     ($t:ty, $f:ty) => {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const ShrAssign<$f> for $t {\n+        impl ShrAssign<$f> for $t {\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn shr_assign(&mut self, other: $f) {\n                 *self >>= other\n             }\n         }\n \n-        forward_ref_op_assign! { impl const ShrAssign, shr_assign for $t, $f }\n+        forward_ref_op_assign! { impl ShrAssign, shr_assign for $t, $f }\n     };\n }\n "}, {"sha": "e10c438ef43008a5299dc19c1d962b788adbc7c7", "filename": "library/core/src/ops/control_flow.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -97,8 +97,7 @@ pub enum ControlFlow<B, C = ()> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<B, C> const ops::Try for ControlFlow<B, C> {\n+impl<B, C> ops::Try for ControlFlow<B, C> {\n     type Output = C;\n     type Residual = ControlFlow<B, convert::Infallible>;\n \n@@ -117,8 +116,7 @@ impl<B, C> const ops::Try for ControlFlow<B, C> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<B, C> const ops::FromResidual for ControlFlow<B, C> {\n+impl<B, C> ops::FromResidual for ControlFlow<B, C> {\n     #[inline]\n     fn from_residual(residual: ControlFlow<B, convert::Infallible>) -> Self {\n         match residual {\n@@ -128,8 +126,7 @@ impl<B, C> const ops::FromResidual for ControlFlow<B, C> {\n }\n \n #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n-#[rustc_const_unstable(feature = \"const_try\", issue = \"74935\")]\n-impl<B, C> const ops::Residual<C> for ControlFlow<B, convert::Infallible> {\n+impl<B, C> ops::Residual<C> for ControlFlow<B, convert::Infallible> {\n     type TryType = ControlFlow<B, C>;\n }\n "}, {"sha": "08c35b6dac309368a7f898375f83c587a1997a04", "filename": "library/core/src/ops/deref.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fderef.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -61,7 +61,6 @@\n #[doc(alias = \"&*\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Deref\"]\n-#[const_trait]\n pub trait Deref {\n     /// The resulting type after dereferencing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -77,8 +76,7 @@ pub trait Deref {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_deref\", issue = \"88955\")]\n-impl<T: ?Sized> const Deref for &T {\n+impl<T: ?Sized> Deref for &T {\n     type Target = T;\n \n     #[rustc_diagnostic_item = \"noop_method_deref\"]\n@@ -91,8 +89,7 @@ impl<T: ?Sized> const Deref for &T {\n impl<T: ?Sized> !DerefMut for &T {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_deref\", issue = \"88955\")]\n-impl<T: ?Sized> const Deref for &mut T {\n+impl<T: ?Sized> Deref for &mut T {\n     type Target = T;\n \n     fn deref(&self) -> &T {\n@@ -170,7 +167,6 @@ impl<T: ?Sized> const Deref for &mut T {\n #[lang = \"deref_mut\"]\n #[doc(alias = \"*\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[const_trait]\n pub trait DerefMut: Deref {\n     /// Mutably dereferences the value.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "67c8245f0bfe098542d330edbe59812bd9fcc661", "filename": "library/core/src/ops/function.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -254,32 +254,29 @@ mod impls {\n     use crate::marker::Tuple;\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A: Tuple, F: ?Sized> const Fn<A> for &F\n+    impl<A: Tuple, F: ?Sized> Fn<A> for &F\n     where\n-        F: ~const Fn<A>,\n+        F: Fn<A>,\n     {\n         extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n             (**self).call(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A: Tuple, F: ?Sized> const FnMut<A> for &F\n+    impl<A: Tuple, F: ?Sized> FnMut<A> for &F\n     where\n-        F: ~const Fn<A>,\n+        F: Fn<A>,\n     {\n         extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n             (**self).call(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A: Tuple, F: ?Sized> const FnOnce<A> for &F\n+    impl<A: Tuple, F: ?Sized> FnOnce<A> for &F\n     where\n-        F: ~const Fn<A>,\n+        F: Fn<A>,\n     {\n         type Output = F::Output;\n \n@@ -289,21 +286,19 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A: Tuple, F: ?Sized> const FnMut<A> for &mut F\n+    impl<A: Tuple, F: ?Sized> FnMut<A> for &mut F\n     where\n-        F: ~const FnMut<A>,\n+        F: FnMut<A>,\n     {\n         extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n             (*self).call_mut(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A: Tuple, F: ?Sized> const FnOnce<A> for &mut F\n+    impl<A: Tuple, F: ?Sized> FnOnce<A> for &mut F\n     where\n-        F: ~const FnMut<A>,\n+        F: FnMut<A>,\n     {\n         type Output = F::Output;\n         extern \"rust-call\" fn call_once(self, args: A) -> F::Output {"}, {"sha": "1f1784ec9b255cd3e945162a9cd4f0265ebab3d5", "filename": "library/core/src/ops/index.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Findex.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -55,7 +55,6 @@\n #[doc(alias = \"]\")]\n #[doc(alias = \"[\")]\n #[doc(alias = \"[]\")]\n-#[const_trait]\n pub trait Index<Idx: ?Sized> {\n     /// The returned type after indexing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -165,8 +164,7 @@ see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#ind\n #[doc(alias = \"[\")]\n #[doc(alias = \"]\")]\n #[doc(alias = \"[]\")]\n-#[const_trait]\n-pub trait IndexMut<Idx: ?Sized>: ~const Index<Idx> {\n+pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n     /// Performs the mutable indexing (`container[index]`) operation.\n     ///\n     /// # Panics"}, {"sha": "ba5e6ddc752a40c7407d4ce84f18c6adde1b9fde", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 37, "deletions": 58, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -96,7 +96,7 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n     }\n }\n \n-impl<Idx: ~const PartialOrd<Idx>> Range<Idx> {\n+impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -116,11 +116,10 @@ impl<Idx: ~const PartialOrd<Idx>> Range<Idx> {\n     /// assert!(!(f32::NAN..1.0).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-    pub const fn contains<U>(&self, item: &U) -> bool\n+    pub fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: ~const PartialOrd<U>,\n-        U: ?Sized + ~const PartialOrd<Idx>,\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -143,8 +142,7 @@ impl<Idx: ~const PartialOrd<Idx>> Range<Idx> {\n     /// assert!( (f32::NAN..5.0).is_empty());\n     /// ```\n     #[stable(feature = \"range_is_empty\", since = \"1.47.0\")]\n-    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-    pub const fn is_empty(&self) -> bool {\n+    pub fn is_empty(&self) -> bool {\n         !(self.start < self.end)\n     }\n }\n@@ -201,7 +199,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n     }\n }\n \n-impl<Idx: ~const PartialOrd<Idx>> RangeFrom<Idx> {\n+impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -216,11 +214,10 @@ impl<Idx: ~const PartialOrd<Idx>> RangeFrom<Idx> {\n     /// assert!(!(f32::NAN..).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-    pub const fn contains<U>(&self, item: &U) -> bool\n+    pub fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: ~const PartialOrd<U>,\n-        U: ?Sized + ~const PartialOrd<Idx>,\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -283,7 +280,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n     }\n }\n \n-impl<Idx: ~const PartialOrd<Idx>> RangeTo<Idx> {\n+impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -298,11 +295,10 @@ impl<Idx: ~const PartialOrd<Idx>> RangeTo<Idx> {\n     /// assert!(!(..f32::NAN).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-    pub const fn contains<U>(&self, item: &U) -> bool\n+    pub fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: ~const PartialOrd<U>,\n-        U: ?Sized + ~const PartialOrd<Idx>,\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -474,7 +470,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     }\n }\n \n-impl<Idx: ~const PartialOrd<Idx>> RangeInclusive<Idx> {\n+impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -505,11 +501,10 @@ impl<Idx: ~const PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(!r.contains(&3) && !r.contains(&5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-    pub const fn contains<U>(&self, item: &U) -> bool\n+    pub fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: ~const PartialOrd<U>,\n-        U: ?Sized + ~const PartialOrd<Idx>,\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -541,9 +536,8 @@ impl<Idx: ~const PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(r.is_empty());\n     /// ```\n     #[stable(feature = \"range_is_empty\", since = \"1.47.0\")]\n-    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n     #[inline]\n-    pub const fn is_empty(&self) -> bool {\n+    pub fn is_empty(&self) -> bool {\n         self.exhausted || !(self.start <= self.end)\n     }\n }\n@@ -605,7 +599,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n     }\n }\n \n-impl<Idx: ~const PartialOrd<Idx>> RangeToInclusive<Idx> {\n+impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -620,11 +614,10 @@ impl<Idx: ~const PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// assert!(!(..=f32::NAN).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-    pub const fn contains<U>(&self, item: &U) -> bool\n+    pub fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: ~const PartialOrd<U>,\n-        U: ?Sized + ~const PartialOrd<Idx>,\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -765,7 +758,6 @@ impl<T: Clone> Bound<&T> {\n /// `RangeBounds` is implemented by Rust's built-in range types, produced\n /// by range syntax like `..`, `a..`, `..b`, `..=c`, `d..e`, or `f..=g`.\n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[const_trait]\n pub trait RangeBounds<T: ?Sized> {\n     /// Start index bound.\n     ///\n@@ -818,8 +810,8 @@ pub trait RangeBounds<T: ?Sized> {\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     fn contains<U>(&self, item: &U) -> bool\n     where\n-        T: ~const PartialOrd<U>,\n-        U: ?Sized + ~const PartialOrd<T>,\n+        T: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<T>,\n     {\n         (match self.start_bound() {\n             Included(start) => start <= item,\n@@ -836,8 +828,7 @@ pub trait RangeBounds<T: ?Sized> {\n use self::Bound::{Excluded, Included, Unbounded};\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T: ?Sized> const RangeBounds<T> for RangeFull {\n+impl<T: ?Sized> RangeBounds<T> for RangeFull {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -847,8 +838,7 @@ impl<T: ?Sized> const RangeBounds<T> for RangeFull {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeFrom<T> {\n+impl<T> RangeBounds<T> for RangeFrom<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n@@ -858,8 +848,7 @@ impl<T> const RangeBounds<T> for RangeFrom<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeTo<T> {\n+impl<T> RangeBounds<T> for RangeTo<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -869,8 +858,7 @@ impl<T> const RangeBounds<T> for RangeTo<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for Range<T> {\n+impl<T> RangeBounds<T> for Range<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n@@ -880,8 +868,7 @@ impl<T> const RangeBounds<T> for Range<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeInclusive<T> {\n+impl<T> RangeBounds<T> for RangeInclusive<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n@@ -897,8 +884,7 @@ impl<T> const RangeBounds<T> for RangeInclusive<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeToInclusive<T> {\n+impl<T> RangeBounds<T> for RangeToInclusive<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -908,8 +894,7 @@ impl<T> const RangeBounds<T> for RangeToInclusive<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for (Bound<T>, Bound<T>) {\n+impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n     fn start_bound(&self) -> Bound<&T> {\n         match *self {\n             (Included(ref start), _) => Included(start),\n@@ -928,8 +913,7 @@ impl<T> const RangeBounds<T> for (Bound<T>, Bound<T>) {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<'a, T: ?Sized + 'a> const RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n+impl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n     fn start_bound(&self) -> Bound<&T> {\n         self.0\n     }\n@@ -940,8 +924,7 @@ impl<'a, T: ?Sized + 'a> const RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeFrom<&T> {\n+impl<T> RangeBounds<T> for RangeFrom<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n@@ -951,8 +934,7 @@ impl<T> const RangeBounds<T> for RangeFrom<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeTo<&T> {\n+impl<T> RangeBounds<T> for RangeTo<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -962,8 +944,7 @@ impl<T> const RangeBounds<T> for RangeTo<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for Range<&T> {\n+impl<T> RangeBounds<T> for Range<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n@@ -973,8 +954,7 @@ impl<T> const RangeBounds<T> for Range<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeInclusive<&T> {\n+impl<T> RangeBounds<T> for RangeInclusive<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n@@ -984,8 +964,7 @@ impl<T> const RangeBounds<T> for RangeInclusive<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeToInclusive<&T> {\n+impl<T> RangeBounds<T> for RangeToInclusive<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }"}, {"sha": "b4f69d0b21309253eda811fd54fd2bb27fed6574", "filename": "library/core/src/ops/try_trait.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -128,8 +128,7 @@ use crate::ops::ControlFlow;\n )]\n #[doc(alias = \"?\")]\n #[lang = \"Try\"]\n-#[const_trait]\n-pub trait Try: ~const FromResidual {\n+pub trait Try: FromResidual {\n     /// The type of the value produced by `?` when *not* short-circuiting.\n     #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n     type Output;\n@@ -305,7 +304,6 @@ pub trait Try: ~const FromResidual {\n )]\n #[rustc_diagnostic_item = \"FromResidual\"]\n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-#[const_trait]\n pub trait FromResidual<R = <Self as Try>::Residual> {\n     /// Constructs the type from a compatible `Residual` type.\n     ///\n@@ -358,11 +356,10 @@ where\n /// and in the other direction,\n /// `<Result<Infallible, E> as Residual<T>>::TryType = Result<T, E>`.\n #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n-#[const_trait]\n pub trait Residual<O> {\n     /// The \"return\" type of this meta-function.\n     #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n-    type TryType: ~const Try<Output = O, Residual = Self>;\n+    type TryType: Try<Output = O, Residual = Self>;\n }\n \n #[unstable(feature = \"pub_crate_should_not_need_unstable_attr\", issue = \"none\")]\n@@ -389,16 +386,14 @@ impl<T> NeverShortCircuit<T> {\n     }\n \n     #[inline]\n-    pub fn wrap_mut_2<A, B>(\n-        mut f: impl ~const FnMut(A, B) -> T,\n-    ) -> impl ~const FnMut(A, B) -> Self {\n-        const move |a, b| NeverShortCircuit(f(a, b))\n+    pub fn wrap_mut_2<A, B>(mut f: impl FnMut(A, B) -> T) -> impl FnMut(A, B) -> Self {\n+        move |a, b| NeverShortCircuit(f(a, b))\n     }\n }\n \n pub(crate) enum NeverShortCircuitResidual {}\n \n-impl<T> const Try for NeverShortCircuit<T> {\n+impl<T> Try for NeverShortCircuit<T> {\n     type Output = T;\n     type Residual = NeverShortCircuitResidual;\n \n@@ -413,14 +408,14 @@ impl<T> const Try for NeverShortCircuit<T> {\n     }\n }\n \n-impl<T> const FromResidual for NeverShortCircuit<T> {\n+impl<T> FromResidual for NeverShortCircuit<T> {\n     #[inline]\n     fn from_residual(never: NeverShortCircuitResidual) -> Self {\n         match never {}\n     }\n }\n \n-impl<T> const Residual<T> for NeverShortCircuitResidual {\n+impl<T> Residual<T> for NeverShortCircuitResidual {\n     type TryType = NeverShortCircuit<T>;\n }\n "}, {"sha": "82e7e69215edba27d7203b733a61d4a2d6df6649", "filename": "library/core/src/option.rs", "status": "modified", "additions": 54, "deletions": 135, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -547,7 +547,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::iter::{self, FromIterator, FusedIterator, TrustedLen};\n-use crate::marker::Destruct;\n use crate::panicking::{panic, panic_str};\n use crate::pin::Pin;\n use crate::{\n@@ -967,11 +966,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn unwrap_or(self, default: T) -> T\n-    where\n-        T: ~const Destruct,\n-    {\n+    pub fn unwrap_or(self, default: T) -> T {\n         match self {\n             Some(x) => x,\n             None => default,\n@@ -989,11 +984,9 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn unwrap_or_else<F>(self, f: F) -> T\n+    pub fn unwrap_or_else<F>(self, f: F) -> T\n     where\n-        F: ~const FnOnce() -> T,\n-        F: ~const Destruct,\n+        F: FnOnce() -> T,\n     {\n         match self {\n             Some(x) => x,\n@@ -1022,10 +1015,9 @@ impl<T> Option<T> {\n     /// [`FromStr`]: crate::str::FromStr\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn unwrap_or_default(self) -> T\n+    pub fn unwrap_or_default(self) -> T\n     where\n-        T: ~const Default,\n+        T: Default,\n     {\n         match self {\n             Some(x) => x,\n@@ -1089,11 +1081,9 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn map<U, F>(self, f: F) -> Option<U>\n+    pub fn map<U, F>(self, f: F) -> Option<U>\n     where\n-        F: ~const FnOnce(T) -> U,\n-        F: ~const Destruct,\n+        F: FnOnce(T) -> U,\n     {\n         match self {\n             Some(x) => Some(f(x)),\n@@ -1118,11 +1108,9 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"result_option_inspect\", issue = \"91345\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn inspect<F>(self, f: F) -> Self\n+    pub fn inspect<F>(self, f: F) -> Self\n     where\n-        F: ~const FnOnce(&T),\n-        F: ~const Destruct,\n+        F: FnOnce(&T),\n     {\n         if let Some(ref x) = self {\n             f(x);\n@@ -1151,12 +1139,9 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn map_or<U, F>(self, default: U, f: F) -> U\n+    pub fn map_or<U, F>(self, default: U, f: F) -> U\n     where\n-        F: ~const FnOnce(T) -> U,\n-        F: ~const Destruct,\n-        U: ~const Destruct,\n+        F: FnOnce(T) -> U,\n     {\n         match self {\n             Some(t) => f(t),\n@@ -1180,13 +1165,10 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn map_or_else<U, D, F>(self, default: D, f: F) -> U\n+    pub fn map_or_else<U, D, F>(self, default: D, f: F) -> U\n     where\n-        D: ~const FnOnce() -> U,\n-        D: ~const Destruct,\n-        F: ~const FnOnce(T) -> U,\n-        F: ~const Destruct,\n+        D: FnOnce() -> U,\n+        F: FnOnce(T) -> U,\n     {\n         match self {\n             Some(t) => f(t),\n@@ -1217,11 +1199,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn ok_or<E>(self, err: E) -> Result<T, E>\n-    where\n-        E: ~const Destruct,\n-    {\n+    pub fn ok_or<E>(self, err: E) -> Result<T, E> {\n         match self {\n             Some(v) => Ok(v),\n             None => Err(err),\n@@ -1246,11 +1224,9 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn ok_or_else<E, F>(self, err: F) -> Result<T, E>\n+    pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E>\n     where\n-        F: ~const FnOnce() -> E,\n-        F: ~const Destruct,\n+        F: FnOnce() -> E,\n     {\n         match self {\n             Some(v) => Ok(v),\n@@ -1274,10 +1250,9 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn as_deref(&self) -> Option<&T::Target>\n+    pub fn as_deref(&self) -> Option<&T::Target>\n     where\n-        T: ~const Deref,\n+        T: Deref,\n     {\n         match self.as_ref() {\n             Some(t) => Some(t.deref()),\n@@ -1301,10 +1276,9 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn as_deref_mut(&mut self) -> Option<&mut T::Target>\n+    pub fn as_deref_mut(&mut self) -> Option<&mut T::Target>\n     where\n-        T: ~const DerefMut,\n+        T: DerefMut,\n     {\n         match self.as_mut() {\n             Some(t) => Some(t.deref_mut()),\n@@ -1388,12 +1362,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn and<U>(self, optb: Option<U>) -> Option<U>\n-    where\n-        T: ~const Destruct,\n-        U: ~const Destruct,\n-    {\n+    pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n         match self {\n             Some(_) => optb,\n             None => None,\n@@ -1430,11 +1399,9 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn and_then<U, F>(self, f: F) -> Option<U>\n+    pub fn and_then<U, F>(self, f: F) -> Option<U>\n     where\n-        F: ~const FnOnce(T) -> Option<U>,\n-        F: ~const Destruct,\n+        F: FnOnce(T) -> Option<U>,\n     {\n         match self {\n             Some(x) => f(x),\n@@ -1468,12 +1435,9 @@ impl<T> Option<T> {\n     /// [`Some(t)`]: Some\n     #[inline]\n     #[stable(feature = \"option_filter\", since = \"1.27.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn filter<P>(self, predicate: P) -> Self\n+    pub fn filter<P>(self, predicate: P) -> Self\n     where\n-        T: ~const Destruct,\n-        P: ~const FnOnce(&T) -> bool,\n-        P: ~const Destruct,\n+        P: FnOnce(&T) -> bool,\n     {\n         if let Some(x) = self {\n             if predicate(&x) {\n@@ -1512,11 +1476,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn or(self, optb: Option<T>) -> Option<T>\n-    where\n-        T: ~const Destruct,\n-    {\n+    pub fn or(self, optb: Option<T>) -> Option<T> {\n         match self {\n             Some(x) => Some(x),\n             None => optb,\n@@ -1538,11 +1498,9 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn or_else<F>(self, f: F) -> Option<T>\n+    pub fn or_else<F>(self, f: F) -> Option<T>\n     where\n-        F: ~const FnOnce() -> Option<T>,\n-        F: ~const Destruct,\n+        F: FnOnce() -> Option<T>,\n     {\n         match self {\n             Some(x) => Some(x),\n@@ -1573,11 +1531,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"option_xor\", since = \"1.37.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn xor(self, optb: Option<T>) -> Option<T>\n-    where\n-        T: ~const Destruct,\n-    {\n+    pub fn xor(self, optb: Option<T>) -> Option<T> {\n         match (self, optb) {\n             (Some(a), None) => Some(a),\n             (None, Some(b)) => Some(b),\n@@ -1611,11 +1565,7 @@ impl<T> Option<T> {\n     #[must_use = \"if you intended to set a value, consider assignment instead\"]\n     #[inline]\n     #[stable(feature = \"option_insert\", since = \"1.53.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn insert(&mut self, value: T) -> &mut T\n-    where\n-        T: ~const Destruct,\n-    {\n+    pub fn insert(&mut self, value: T) -> &mut T {\n         *self = Some(value);\n \n         // SAFETY: the code above just filled the option\n@@ -1644,11 +1594,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn get_or_insert(&mut self, value: T) -> &mut T\n-    where\n-        T: ~const Destruct,\n-    {\n+    pub fn get_or_insert(&mut self, value: T) -> &mut T {\n         if let None = *self {\n             *self = Some(value);\n         }\n@@ -1679,12 +1625,11 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"option_get_or_insert_default\", issue = \"82901\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn get_or_insert_default(&mut self) -> &mut T\n+    pub fn get_or_insert_default(&mut self) -> &mut T\n     where\n-        T: ~const Default,\n+        T: Default,\n     {\n-        const fn default<T: ~const Default>() -> T {\n+        fn default<T: Default>() -> T {\n             T::default()\n         }\n \n@@ -1710,11 +1655,9 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn get_or_insert_with<F>(&mut self, f: F) -> &mut T\n+    pub fn get_or_insert_with<F>(&mut self, f: F) -> &mut T\n     where\n-        F: ~const FnOnce() -> T,\n-        F: ~const Destruct,\n+        F: FnOnce() -> T,\n     {\n         if let None = *self {\n             // the compiler isn't smart enough to know that we are not dropping a `T`\n@@ -1794,12 +1737,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.zip(z), None);\n     /// ```\n     #[stable(feature = \"option_zip_option\", since = \"1.46.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn zip<U>(self, other: Option<U>) -> Option<(T, U)>\n-    where\n-        T: ~const Destruct,\n-        U: ~const Destruct,\n-    {\n+    pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)> {\n         match (self, other) {\n             (Some(a), Some(b)) => Some((a, b)),\n             _ => None,\n@@ -1835,13 +1773,9 @@ impl<T> Option<T> {\n     /// assert_eq!(x.zip_with(None, Point::new), None);\n     /// ```\n     #[unstable(feature = \"option_zip\", issue = \"70086\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn zip_with<U, F, R>(self, other: Option<U>, f: F) -> Option<R>\n+    pub fn zip_with<U, F, R>(self, other: Option<U>, f: F) -> Option<R>\n     where\n-        F: ~const FnOnce(T, U) -> R,\n-        F: ~const Destruct,\n-        T: ~const Destruct,\n-        U: ~const Destruct,\n+        F: FnOnce(T, U) -> R,\n     {\n         match (self, other) {\n             (Some(a), Some(b)) => Some(f(a, b)),\n@@ -1867,12 +1801,7 @@ impl<T, U> Option<(T, U)> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"unzip_option\", since = \"1.66.0\")]\n-    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n-    pub const fn unzip(self) -> (Option<T>, Option<U>)\n-    where\n-        T: ~const Destruct,\n-        U: ~const Destruct,\n-    {\n+    pub fn unzip(self) -> (Option<T>, Option<U>) {\n         match self {\n             Some((a, b)) => (Some(a), Some(b)),\n             None => (None, None),\n@@ -1922,10 +1851,9 @@ impl<T> Option<&T> {\n     /// ```\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_cloned\", issue = \"91582\")]\n-    pub const fn cloned(self) -> Option<T>\n+    pub fn cloned(self) -> Option<T>\n     where\n-        T: ~const Clone,\n+        T: Clone,\n     {\n         match self {\n             Some(t) => Some(t.clone()),\n@@ -1974,10 +1902,9 @@ impl<T> Option<&mut T> {\n     /// ```\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[stable(since = \"1.26.0\", feature = \"option_ref_mut_cloned\")]\n-    #[rustc_const_unstable(feature = \"const_option_cloned\", issue = \"91582\")]\n-    pub const fn cloned(self) -> Option<T>\n+    pub fn cloned(self) -> Option<T>\n     where\n-        T: ~const Clone,\n+        T: Clone,\n     {\n         match self {\n             Some(t) => Some(t.clone()),\n@@ -2030,10 +1957,9 @@ const fn expect_failed(msg: &str) -> ! {\n /////////////////////////////////////////////////////////////////////////////\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-impl<T> const Clone for Option<T>\n+impl<T> Clone for Option<T>\n where\n-    T: ~const Clone + ~const Destruct,\n+    T: Clone,\n {\n     #[inline]\n     fn clone(&self) -> Self {\n@@ -2053,8 +1979,7 @@ where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for Option<T> {\n+impl<T> Default for Option<T> {\n     /// Returns [`None`][Option::None].\n     ///\n     /// # Examples\n@@ -2114,8 +2039,7 @@ impl<'a, T> IntoIterator for &'a mut Option<T> {\n }\n \n #[stable(since = \"1.12.0\", feature = \"option_from\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for Option<T> {\n+impl<T> From<T> for Option<T> {\n     /// Moves `val` into a new [`Some`].\n     ///\n     /// # Examples\n@@ -2131,8 +2055,7 @@ impl<T> const From<T> for Option<T> {\n }\n \n #[stable(feature = \"option_ref_from_ref_option\", since = \"1.30.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<'a, T> const From<&'a Option<T>> for Option<&'a T> {\n+impl<'a, T> From<&'a Option<T>> for Option<&'a T> {\n     /// Converts from `&Option<T>` to `Option<&T>`.\n     ///\n     /// # Examples\n@@ -2159,8 +2082,7 @@ impl<'a, T> const From<&'a Option<T>> for Option<&'a T> {\n }\n \n #[stable(feature = \"option_ref_from_ref_option\", since = \"1.30.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<'a, T> const From<&'a mut Option<T>> for Option<&'a mut T> {\n+impl<'a, T> From<&'a mut Option<T>> for Option<&'a mut T> {\n     /// Converts from `&mut Option<T>` to `Option<&mut T>`\n     ///\n     /// # Examples\n@@ -2507,8 +2429,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const ops::Try for Option<T> {\n+impl<T> ops::Try for Option<T> {\n     type Output = T;\n     type Residual = Option<convert::Infallible>;\n \n@@ -2527,8 +2448,7 @@ impl<T> const ops::Try for Option<T> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const ops::FromResidual for Option<T> {\n+impl<T> ops::FromResidual for Option<T> {\n     #[inline]\n     fn from_residual(residual: Option<convert::Infallible>) -> Self {\n         match residual {\n@@ -2546,8 +2466,7 @@ impl<T> ops::FromResidual<ops::Yeet<()>> for Option<T> {\n }\n \n #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n-#[rustc_const_unstable(feature = \"const_try\", issue = \"74935\")]\n-impl<T> const ops::Residual<T> for Option<convert::Infallible> {\n+impl<T> ops::Residual<T> for Option<convert::Infallible> {\n     type TryType = Option<T>;\n }\n "}, {"sha": "bbf7199fffa06889e73ea335a5df707733d323bd", "filename": "library/core/src/ptr/alignment.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -9,8 +9,7 @@ use crate::{cmp, fmt, hash, mem, num};\n /// Note that particularly large alignments, while representable in this type,\n /// are likely not to be supported by actual allocators and linkers.\n #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n-#[derive(Copy, Clone, Eq)]\n-#[derive_const(PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n #[repr(transparent)]\n pub struct Alignment(AlignmentEnum);\n \n@@ -170,7 +169,7 @@ impl From<Alignment> for usize {\n \n #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n-impl const cmp::Ord for Alignment {\n+impl cmp::Ord for Alignment {\n     #[inline]\n     fn cmp(&self, other: &Self) -> cmp::Ordering {\n         self.as_nonzero().get().cmp(&other.as_nonzero().get())\n@@ -179,7 +178,7 @@ impl const cmp::Ord for Alignment {\n \n #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n-impl const cmp::PartialOrd for Alignment {\n+impl cmp::PartialOrd for Alignment {\n     #[inline]\n     fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n         Some(self.cmp(other))\n@@ -201,8 +200,7 @@ type AlignmentEnum = AlignmentEnum32;\n #[cfg(target_pointer_width = \"64\")]\n type AlignmentEnum = AlignmentEnum64;\n \n-#[derive(Copy, Clone, Eq)]\n-#[derive_const(PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n #[repr(u16)]\n enum AlignmentEnum16 {\n     _Align1Shl0 = 1 << 0,\n@@ -223,8 +221,7 @@ enum AlignmentEnum16 {\n     _Align1Shl15 = 1 << 15,\n }\n \n-#[derive(Copy, Clone, Eq)]\n-#[derive_const(PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n #[repr(u32)]\n enum AlignmentEnum32 {\n     _Align1Shl0 = 1 << 0,\n@@ -261,8 +258,7 @@ enum AlignmentEnum32 {\n     _Align1Shl31 = 1 << 31,\n }\n \n-#[derive(Copy, Clone, Eq)]\n-#[derive_const(PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n #[repr(u64)]\n enum AlignmentEnum64 {\n     _Align1Shl0 = 1 << 0,"}, {"sha": "603bd88733393d038eb12adc2556ed8328575d90", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1650,11 +1650,10 @@ impl<T> *const [T] {\n     /// }\n     /// ```\n     #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n-    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline]\n-    pub const unsafe fn get_unchecked<I>(self, index: I) -> *const I::Output\n+    pub unsafe fn get_unchecked<I>(self, index: I) -> *const I::Output\n     where\n-        I: ~const SliceIndex<[T]>,\n+        I: SliceIndex<[T]>,\n     {\n         // SAFETY: the caller ensures that `self` is dereferenceable and `index` in-bounds.\n         unsafe { index.get_unchecked(self) }"}, {"sha": "555d58fad844027c98e48c36218b005930b01f8c", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1764,7 +1764,12 @@ pub(crate) const unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usiz\n     // miracles, given the situations this case has to deal with.\n \n     // SAFETY: a is power-of-two hence non-zero. stride == 0 case is handled above.\n-    let gcdpow = unsafe { cttz_nonzero(stride).min(cttz_nonzero(a)) };\n+    // FIXME(const-hack) replace with min\n+    let gcdpow = unsafe {\n+        let x = cttz_nonzero(stride);\n+        let y = cttz_nonzero(a);\n+        if x < y { x } else { y }\n+    };\n     // SAFETY: gcdpow has an upper-bound that\u2019s at most the number of bits in a usize.\n     let gcd = unsafe { unchecked_shl(1usize, gcdpow) };\n     // SAFETY: gcd is always greater or equal to 1."}, {"sha": "24b66c549a6e4378fddfd13dd7a0b9dd210881ea", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -2036,11 +2036,10 @@ impl<T> *mut [T] {\n     /// }\n     /// ```\n     #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n-    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline(always)]\n-    pub const unsafe fn get_unchecked_mut<I>(self, index: I) -> *mut I::Output\n+    pub unsafe fn get_unchecked_mut<I>(self, index: I) -> *mut I::Output\n     where\n-        I: ~const SliceIndex<[T]>,\n+        I: SliceIndex<[T]>,\n     {\n         // SAFETY: the caller ensures that `self` is dereferenceable and `index` in-bounds.\n         unsafe { index.get_unchecked_mut(self) }"}, {"sha": "506d891d989b174026d47df923605b938e16e58b", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -676,11 +676,10 @@ impl<T> NonNull<[T]> {\n     /// }\n     /// ```\n     #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n-    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline]\n-    pub const unsafe fn get_unchecked_mut<I>(self, index: I) -> NonNull<I::Output>\n+    pub unsafe fn get_unchecked_mut<I>(self, index: I) -> NonNull<I::Output>\n     where\n-        I: ~const SliceIndex<[T]>,\n+        I: SliceIndex<[T]>,\n     {\n         // SAFETY: the caller ensures that `self` is dereferenceable and `index` in-bounds.\n         // As a consequence, the resulting pointer cannot be null.\n@@ -689,8 +688,7 @@ impl<T> NonNull<[T]> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-impl<T: ?Sized> const Clone for NonNull<T> {\n+impl<T: ?Sized> Clone for NonNull<T> {\n     #[inline(always)]\n     fn clone(&self) -> Self {\n         *self\n@@ -756,8 +754,7 @@ impl<T: ?Sized> hash::Hash for NonNull<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"none\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T: ?Sized> const From<Unique<T>> for NonNull<T> {\n+impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n     #[inline]\n     fn from(unique: Unique<T>) -> Self {\n         // SAFETY: A Unique pointer cannot be null, so the conditions for\n@@ -767,8 +764,7 @@ impl<T: ?Sized> const From<Unique<T>> for NonNull<T> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T: ?Sized> const From<&mut T> for NonNull<T> {\n+impl<T: ?Sized> From<&mut T> for NonNull<T> {\n     /// Converts a `&mut T` to a `NonNull<T>`.\n     ///\n     /// This conversion is safe and infallible since references cannot be null.\n@@ -780,8 +776,7 @@ impl<T: ?Sized> const From<&mut T> for NonNull<T> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T: ?Sized> const From<&T> for NonNull<T> {\n+impl<T: ?Sized> From<&T> for NonNull<T> {\n     /// Converts a `&T` to a `NonNull<T>`.\n     ///\n     /// This conversion is safe and infallible since references cannot be null."}, {"sha": "a853f15edb7e0d00292af5282583735ab8656338", "filename": "library/core/src/ptr/unique.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Funique.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -70,7 +70,8 @@ impl<T: Sized> Unique<T> {\n     #[must_use]\n     #[inline]\n     pub const fn dangling() -> Self {\n-        Self::from(NonNull::dangling())\n+        // FIXME(const-hack) replace with `From`\n+        Unique { pointer: NonNull::dangling(), _marker: PhantomData }\n     }\n }\n \n@@ -134,13 +135,14 @@ impl<T: ?Sized> Unique<T> {\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[inline]\n     pub const fn cast<U>(self) -> Unique<U> {\n-        Unique::from(self.pointer.cast())\n+        // FIXME(const-hack): replace with `From`\n+        // SAFETY: is `NonNull`\n+        unsafe { Unique::new_unchecked(self.pointer.cast().as_ptr()) }\n     }\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"none\")]\n-#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-impl<T: ?Sized> const Clone for Unique<T> {\n+impl<T: ?Sized> Clone for Unique<T> {\n     #[inline]\n     fn clone(&self) -> Self {\n         *self\n@@ -171,7 +173,7 @@ impl<T: ?Sized> fmt::Pointer for Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"none\")]\n-impl<T: ?Sized> const From<&mut T> for Unique<T> {\n+impl<T: ?Sized> From<&mut T> for Unique<T> {\n     /// Converts a `&mut T` to a `Unique<T>`.\n     ///\n     /// This conversion is infallible since references cannot be null.\n@@ -182,7 +184,7 @@ impl<T: ?Sized> const From<&mut T> for Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"none\")]\n-impl<T: ?Sized> const From<NonNull<T>> for Unique<T> {\n+impl<T: ?Sized> From<NonNull<T>> for Unique<T> {\n     /// Converts a `NonNull<T>` to a `Unique<T>`.\n     ///\n     /// This conversion is infallible since `NonNull` cannot be null."}, {"sha": "28cb02989ecc0d1af7ab9ca8f130f3678117d714", "filename": "library/core/src/result.rs", "status": "modified", "additions": 16, "deletions": 58, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -489,7 +489,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::iter::{self, FromIterator, FusedIterator, TrustedLen};\n-use crate::marker::Destruct;\n use crate::ops::{self, ControlFlow, Deref, DerefMut};\n use crate::{convert, fmt, hint};\n \n@@ -629,16 +628,10 @@ impl<T, E> Result<T, E> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_result_drop\", issue = \"92384\")]\n-    pub const fn ok(self) -> Option<T>\n-    where\n-        E: ~const Destruct,\n-    {\n+    pub fn ok(self) -> Option<T> {\n         match self {\n             Ok(x) => Some(x),\n-            // FIXME: ~const Drop doesn't quite work right yet\n-            #[allow(unused_variables)]\n-            Err(x) => None,\n+            Err(_) => None,\n         }\n     }\n \n@@ -658,15 +651,9 @@ impl<T, E> Result<T, E> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_result_drop\", issue = \"92384\")]\n-    pub const fn err(self) -> Option<E>\n-    where\n-        T: ~const Destruct,\n-    {\n+    pub fn err(self) -> Option<E> {\n         match self {\n-            // FIXME: ~const Drop doesn't quite work right yet\n-            #[allow(unused_variables)]\n-            Ok(x) => None,\n+            Ok(_) => None,\n             Err(x) => Some(x),\n         }\n     }\n@@ -1287,18 +1274,10 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.and(y), Ok(\"different result type\"));\n     /// ```\n     #[inline]\n-    #[rustc_const_unstable(feature = \"const_result_drop\", issue = \"92384\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub const fn and<U>(self, res: Result<U, E>) -> Result<U, E>\n-    where\n-        T: ~const Destruct,\n-        U: ~const Destruct,\n-        E: ~const Destruct,\n-    {\n+    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n         match self {\n-            // FIXME: ~const Drop doesn't quite work right yet\n-            #[allow(unused_variables)]\n-            Ok(x) => res,\n+            Ok(_) => res,\n             Err(e) => Err(e),\n         }\n     }\n@@ -1370,19 +1349,11 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.or(y), Ok(2));\n     /// ```\n     #[inline]\n-    #[rustc_const_unstable(feature = \"const_result_drop\", issue = \"92384\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub const fn or<F>(self, res: Result<T, F>) -> Result<T, F>\n-    where\n-        T: ~const Destruct,\n-        E: ~const Destruct,\n-        F: ~const Destruct,\n-    {\n+    pub fn or<F>(self, res: Result<T, F>) -> Result<T, F> {\n         match self {\n             Ok(v) => Ok(v),\n-            // FIXME: ~const Drop doesn't quite work right yet\n-            #[allow(unused_variables)]\n-            Err(e) => res,\n+            Err(_) => res,\n         }\n     }\n \n@@ -1430,18 +1401,11 @@ impl<T, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_or(default), default);\n     /// ```\n     #[inline]\n-    #[rustc_const_unstable(feature = \"const_result_drop\", issue = \"92384\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub const fn unwrap_or(self, default: T) -> T\n-    where\n-        T: ~const Destruct,\n-        E: ~const Destruct,\n-    {\n+    pub fn unwrap_or(self, default: T) -> T {\n         match self {\n             Ok(t) => t,\n-            // FIXME: ~const Drop doesn't quite work right yet\n-            #[allow(unused_variables)]\n-            Err(e) => default,\n+            Err(_) => default,\n         }\n     }\n \n@@ -1704,11 +1668,10 @@ fn unwrap_failed<T>(_msg: &str, _error: &T) -> ! {\n /////////////////////////////////////////////////////////////////////////////\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-impl<T, E> const Clone for Result<T, E>\n+impl<T, E> Clone for Result<T, E>\n where\n-    T: ~const Clone + ~const Destruct,\n-    E: ~const Clone + ~const Destruct,\n+    T: Clone,\n+    E: Clone,\n {\n     #[inline]\n     fn clone(&self) -> Self {\n@@ -1971,8 +1934,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T, E> const ops::Try for Result<T, E> {\n+impl<T, E> ops::Try for Result<T, E> {\n     type Output = T;\n     type Residual = Result<convert::Infallible, E>;\n \n@@ -1991,10 +1953,7 @@ impl<T, E> const ops::Try for Result<T, E> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T, E, F: ~const From<E>> const ops::FromResidual<Result<convert::Infallible, E>>\n-    for Result<T, F>\n-{\n+impl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>> for Result<T, F> {\n     #[inline]\n     #[track_caller]\n     fn from_residual(residual: Result<convert::Infallible, E>) -> Self {\n@@ -2013,7 +1972,6 @@ impl<T, E, F: From<E>> ops::FromResidual<ops::Yeet<E>> for Result<T, F> {\n }\n \n #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n-#[rustc_const_unstable(feature = \"const_try\", issue = \"74935\")]\n-impl<T, E> const ops::Residual<T> for Result<convert::Infallible, E> {\n+impl<T, E> ops::Residual<T> for Result<convert::Infallible, E> {\n     type TryType = Result<T, E>;\n }"}, {"sha": "6ef9f9c95e843be9ede86e176c64c1ccd1fcb435", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -7,10 +7,9 @@ use crate::ops;\n use crate::ptr;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-impl<T, I> const ops::Index<I> for [T]\n+impl<T, I> ops::Index<I> for [T]\n where\n-    I: ~const SliceIndex<[T]>,\n+    I: SliceIndex<[T]>,\n {\n     type Output = I::Output;\n \n@@ -21,10 +20,9 @@ where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-impl<T, I> const ops::IndexMut<I> for [T]\n+impl<T, I> ops::IndexMut<I> for [T]\n where\n-    I: ~const SliceIndex<[T]>,\n+    I: SliceIndex<[T]>,\n {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut I::Output {\n@@ -162,7 +160,6 @@ mod private_slice_index {\n     message = \"the type `{T}` cannot be indexed by `{Self}`\",\n     label = \"slice indices are of type `usize` or ranges of `usize`\"\n )]\n-#[const_trait]\n pub unsafe trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n     /// The output type returned by methods.\n     #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n@@ -211,7 +208,7 @@ pub unsafe trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for usize {\n+unsafe impl<T> SliceIndex<[T]> for usize {\n     type Output = T;\n \n     #[inline]\n@@ -271,7 +268,7 @@ unsafe impl<T> const SliceIndex<[T]> for usize {\n /// Because `IndexRange` guarantees `start <= end`, fewer checks are needed here\n /// than there are for a general `Range<usize>` (which might be `100..3`).\n #[rustc_const_unstable(feature = \"const_index_range_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for ops::IndexRange {\n+unsafe impl<T> SliceIndex<[T]> for ops::IndexRange {\n     type Output = [T];\n \n     #[inline]\n@@ -347,7 +344,7 @@ unsafe impl<T> const SliceIndex<[T]> for ops::IndexRange {\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -428,7 +425,7 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for ops::RangeTo<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -466,7 +463,7 @@ unsafe impl<T> const SliceIndex<[T]> for ops::RangeTo<usize> {\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for ops::RangeFrom<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -512,7 +509,7 @@ unsafe impl<T> const SliceIndex<[T]> for ops::RangeFrom<usize> {\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for ops::RangeFull {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeFull {\n     type Output = [T];\n \n     #[inline]\n@@ -548,7 +545,7 @@ unsafe impl<T> const SliceIndex<[T]> for ops::RangeFull {\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for ops::RangeInclusive<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -592,7 +589,7 @@ unsafe impl<T> const SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n     type Output = [T];\n \n     #[inline]"}, {"sha": "3a8b59d727b4a5479bb8d00188a1eef3b3543599", "filename": "library/core/src/slice/memchr.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,7 +1,6 @@\n // Original implementation taken from rust-memchr.\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n-use crate::cmp;\n use crate::mem;\n \n const LO_USIZE: usize = usize::repeat_u8(0x01);\n@@ -83,8 +82,12 @@ const fn memchr_aligned(x: u8, text: &[u8]) -> Option<usize> {\n     let mut offset = ptr.align_offset(USIZE_BYTES);\n \n     if offset > 0 {\n-        offset = cmp::min(offset, len);\n-        if let Some(index) = memchr_naive(x, &text[..offset]) {\n+        // FIXME(const-hack, fee1-dead): replace with min\n+        offset = if offset < len { offset } else { len };\n+        // FIXME(const-hack, fee1-dead): replace with range slicing\n+        // SAFETY: offset is within bounds\n+        let slice = unsafe { super::from_raw_parts(text.as_ptr(), offset) };\n+        if let Some(index) = memchr_naive(x, slice) {\n             return Some(index);\n         }\n     }\n@@ -110,7 +113,10 @@ const fn memchr_aligned(x: u8, text: &[u8]) -> Option<usize> {\n \n     // Find the byte after the point the body loop stopped.\n     // FIXME(const-hack): Use `?` instead.\n-    if let Some(i) = memchr_naive(x, &text[offset..]) { Some(offset + i) } else { None }\n+    // FIXME(const-hack, fee1-dead): use range slicing\n+    // SAFETY: offset is within bounds\n+    let slice = unsafe { super::from_raw_parts(text.as_ptr().add(offset), text.len() - offset) };\n+    if let Some(i) = memchr_naive(x, slice) { Some(offset + i) } else { None }\n }\n \n /// Returns the last index matching the byte `x` in `text`."}, {"sha": "d12809357a8909cbd1b8d5b332df83782e2c44fd", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -333,12 +333,11 @@ impl<T> [T] {\n     /// assert_eq!(None, v.get(0..4));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline]\n     #[must_use]\n-    pub const fn get<I>(&self, index: I) -> Option<&I::Output>\n+    pub fn get<I>(&self, index: I) -> Option<&I::Output>\n     where\n-        I: ~const SliceIndex<Self>,\n+        I: SliceIndex<Self>,\n     {\n         index.get(self)\n     }\n@@ -359,12 +358,11 @@ impl<T> [T] {\n     /// assert_eq!(x, &[0, 42, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline]\n     #[must_use]\n-    pub const fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n+    pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n     where\n-        I: ~const SliceIndex<Self>,\n+        I: SliceIndex<Self>,\n     {\n         index.get_mut(self)\n     }\n@@ -392,12 +390,11 @@ impl<T> [T] {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline]\n     #[must_use]\n-    pub const unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n+    pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n     where\n-        I: ~const SliceIndex<Self>,\n+        I: SliceIndex<Self>,\n     {\n         // SAFETY: the caller must uphold most of the safety requirements for `get_unchecked`;\n         // the slice is dereferenceable because `self` is a safe reference.\n@@ -430,12 +427,11 @@ impl<T> [T] {\n     /// assert_eq!(x, &[1, 13, 4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline]\n     #[must_use]\n-    pub const unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n+    pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n     where\n-        I: ~const SliceIndex<Self>,\n+        I: SliceIndex<Self>,\n     {\n         // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`;\n         // the slice is dereferenceable because `self` is a safe reference.\n@@ -678,9 +674,8 @@ impl<T> [T] {\n     /// assert!(v == [3, 2, 1]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_reverse\", issue = \"100784\")]\n     #[inline]\n-    pub const fn reverse(&mut self) {\n+    pub fn reverse(&mut self) {\n         let half_len = self.len() / 2;\n         let Range { start, end } = self.as_mut_ptr_range();\n \n@@ -703,7 +698,7 @@ impl<T> [T] {\n         revswap(front_half, back_half, half_len);\n \n         #[inline]\n-        const fn revswap<T>(a: &mut [T], b: &mut [T], n: usize) {\n+        fn revswap<T>(a: &mut [T], b: &mut [T], n: usize) {\n             debug_assert!(a.len() == n);\n             debug_assert!(b.len() == n);\n \n@@ -4404,17 +4399,15 @@ where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for &[T] {\n+impl<T> Default for &[T] {\n     /// Creates an empty slice.\n     fn default() -> Self {\n         &[]\n     }\n }\n \n #[stable(feature = \"mut_slice_default\", since = \"1.5.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for &mut [T] {\n+impl<T> Default for &mut [T] {\n     /// Creates a mutable empty slice.\n     fn default() -> Self {\n         &mut []"}, {"sha": "a13107fd0de09352103c3606828db35e9b8f1a28", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -206,9 +206,8 @@ impl str {\n     /// ```\n     #[must_use]\n     #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n-    #[rustc_const_unstable(feature = \"const_is_char_boundary\", issue = \"none\")]\n     #[inline]\n-    pub const fn is_char_boundary(&self, index: usize) -> bool {\n+    pub fn is_char_boundary(&self, index: usize) -> bool {\n         // 0 is always ok.\n         // Test for 0 explicitly so that it can optimize out the check\n         // easily and skip reading string data for that case.\n@@ -436,9 +435,8 @@ impl str {\n     /// assert!(v.get(..42).is_none());\n     /// ```\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline]\n-    pub const fn get<I: ~const SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n+    pub fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n         i.get(self)\n     }\n \n@@ -469,9 +467,8 @@ impl str {\n     /// assert_eq!(\"HEllo\", v);\n     /// ```\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline]\n-    pub const fn get_mut<I: ~const SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n+    pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n         i.get_mut(self)\n     }\n \n@@ -502,9 +499,8 @@ impl str {\n     /// }\n     /// ```\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline]\n-    pub const unsafe fn get_unchecked<I: ~const SliceIndex<str>>(&self, i: I) -> &I::Output {\n+    pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n         // the slice is dereferenceable because `self` is a safe reference.\n         // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n@@ -538,12 +534,8 @@ impl str {\n     /// }\n     /// ```\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline]\n-    pub const unsafe fn get_unchecked_mut<I: ~const SliceIndex<str>>(\n-        &mut self,\n-        i: I,\n-    ) -> &mut I::Output {\n+    pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`;\n         // the slice is dereferenceable because `self` is a safe reference.\n         // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n@@ -2582,8 +2574,7 @@ impl AsRef<[u8]> for str {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl const Default for &str {\n+impl Default for &str {\n     /// Creates an empty str\n     #[inline]\n     fn default() -> Self {"}, {"sha": "1d52335f28ebf2f82f410b8790fe3b95ffa0af28", "filename": "library/core/src/str/traits.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -50,10 +50,9 @@ impl PartialOrd for str {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-impl<I> const ops::Index<I> for str\n+impl<I> ops::Index<I> for str\n where\n-    I: ~const SliceIndex<str>,\n+    I: SliceIndex<str>,\n {\n     type Output = I::Output;\n \n@@ -64,10 +63,9 @@ where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-impl<I> const ops::IndexMut<I> for str\n+impl<I> ops::IndexMut<I> for str\n where\n-    I: ~const SliceIndex<str>,\n+    I: SliceIndex<str>,\n {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut I::Output {\n@@ -96,7 +94,7 @@ const fn str_index_overflow_fail() -> ! {\n /// Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`.\n #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl const SliceIndex<str> for ops::RangeFull {\n+unsafe impl SliceIndex<str> for ops::RangeFull {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -161,7 +159,7 @@ unsafe impl const SliceIndex<str> for ops::RangeFull {\n /// ```\n #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl const SliceIndex<str> for ops::Range<usize> {\n+unsafe impl SliceIndex<str> for ops::Range<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -271,7 +269,7 @@ unsafe impl const SliceIndex<str> for ops::Range<usize> {\n /// character (as defined by `is_char_boundary`), or if `end > len`.\n #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl const SliceIndex<str> for ops::RangeTo<usize> {\n+unsafe impl SliceIndex<str> for ops::RangeTo<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -340,7 +338,7 @@ unsafe impl const SliceIndex<str> for ops::RangeTo<usize> {\n /// a character (as defined by `is_char_boundary`), or if `begin > len`.\n #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl const SliceIndex<str> for ops::RangeFrom<usize> {\n+unsafe impl SliceIndex<str> for ops::RangeFrom<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -412,7 +410,7 @@ unsafe impl const SliceIndex<str> for ops::RangeFrom<usize> {\n /// byte offset or equal to `len`), if `begin > end`, or if `end >= len`.\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl const SliceIndex<str> for ops::RangeInclusive<usize> {\n+unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -464,7 +462,7 @@ unsafe impl const SliceIndex<str> for ops::RangeInclusive<usize> {\n /// `is_char_boundary`, or equal to `len`), or if `end >= len`.\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl const SliceIndex<str> for ops::RangeToInclusive<usize> {\n+unsafe impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {"}, {"sha": "b0ab634905ffed4698dc5df4e0f81f24945b1aab", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -147,8 +147,7 @@ pub struct AtomicBool {\n \n #[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl const Default for AtomicBool {\n+impl Default for AtomicBool {\n     /// Creates an `AtomicBool` initialized to `false`.\n     #[inline]\n     fn default() -> Self {\n@@ -179,8 +178,7 @@ pub struct AtomicPtr<T> {\n \n #[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for AtomicPtr<T> {\n+impl<T> Default for AtomicPtr<T> {\n     /// Creates a null `AtomicPtr<T>`.\n     fn default() -> AtomicPtr<T> {\n         AtomicPtr::new(crate::ptr::null_mut())\n@@ -1916,8 +1914,7 @@ impl<T> AtomicPtr<T> {\n \n #[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<bool> for AtomicBool {\n+impl From<bool> for AtomicBool {\n     /// Converts a `bool` into an `AtomicBool`.\n     ///\n     /// # Examples\n@@ -1935,8 +1932,7 @@ impl const From<bool> for AtomicBool {\n \n #[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"atomic_from\", since = \"1.23.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<*mut T> for AtomicPtr<T> {\n+impl<T> From<*mut T> for AtomicPtr<T> {\n     /// Converts a `*mut T` into an `AtomicPtr<T>`.\n     #[inline]\n     fn from(p: *mut T) -> Self {\n@@ -2002,17 +1998,15 @@ macro_rules! atomic_int {\n         pub const $atomic_init: $atomic_type = $atomic_type::new(0);\n \n         #[$stable]\n-        #[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-        impl const Default for $atomic_type {\n+        impl Default for $atomic_type {\n             #[inline]\n             fn default() -> Self {\n                 Self::new(Default::default())\n             }\n         }\n \n         #[$stable_from]\n-        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-        impl const From<$int_type> for $atomic_type {\n+        impl From<$int_type> for $atomic_type {\n             #[doc = concat!(\"Converts an `\", stringify!($int_type), \"` into an `\", stringify!($atomic_type), \"`.\")]\n             #[inline]\n             fn from(v: $int_type) -> Self { Self::new(v) }"}, {"sha": "168516263f19019205620b7d5fe6a22d16d3317a", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -247,8 +247,7 @@ impl<T, E> Poll<Option<Result<T, E>>> {\n }\n \n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for Poll<T> {\n+impl<T> From<T> for Poll<T> {\n     /// Moves the value into a [`Poll::Ready`] to make a `Poll<T>`.\n     ///\n     /// # Example"}, {"sha": "b74fe013665945b073c4292c56f1aeb37e82ce1f", "filename": "library/core/src/time.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -735,8 +735,7 @@ impl Duration {\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use]\n     #[inline]\n-    #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n-    pub const fn from_secs_f64(secs: f64) -> Duration {\n+    pub fn from_secs_f64(secs: f64) -> Duration {\n         match Duration::try_from_secs_f64(secs) {\n             Ok(v) => v,\n             Err(e) => panic!(\"{}\", e.description()),\n@@ -773,8 +772,7 @@ impl Duration {\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use]\n     #[inline]\n-    #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n-    pub const fn from_secs_f32(secs: f32) -> Duration {\n+    pub fn from_secs_f32(secs: f32) -> Duration {\n         match Duration::try_from_secs_f32(secs) {\n             Ok(v) => v,\n             Err(e) => panic!(\"{}\", e.description()),\n@@ -798,8 +796,7 @@ impl Duration {\n     #[must_use = \"this returns the result of the operation, \\\n                   without modifying the original\"]\n     #[inline]\n-    #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n-    pub const fn mul_f64(self, rhs: f64) -> Duration {\n+    pub fn mul_f64(self, rhs: f64) -> Duration {\n         Duration::from_secs_f64(rhs * self.as_secs_f64())\n     }\n \n@@ -820,8 +817,7 @@ impl Duration {\n     #[must_use = \"this returns the result of the operation, \\\n                   without modifying the original\"]\n     #[inline]\n-    #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n-    pub const fn mul_f32(self, rhs: f32) -> Duration {\n+    pub fn mul_f32(self, rhs: f32) -> Duration {\n         Duration::from_secs_f32(rhs * self.as_secs_f32())\n     }\n \n@@ -842,8 +838,7 @@ impl Duration {\n     #[must_use = \"this returns the result of the operation, \\\n                   without modifying the original\"]\n     #[inline]\n-    #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n-    pub const fn div_f64(self, rhs: f64) -> Duration {\n+    pub fn div_f64(self, rhs: f64) -> Duration {\n         Duration::from_secs_f64(self.as_secs_f64() / rhs)\n     }\n \n@@ -866,8 +861,7 @@ impl Duration {\n     #[must_use = \"this returns the result of the operation, \\\n                   without modifying the original\"]\n     #[inline]\n-    #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n-    pub const fn div_f32(self, rhs: f32) -> Duration {\n+    pub fn div_f32(self, rhs: f32) -> Duration {\n         Duration::from_secs_f32(self.as_secs_f32() / rhs)\n     }\n \n@@ -1402,9 +1396,8 @@ impl Duration {\n     /// assert_eq!(res, Ok(Duration::new(1, 2_929_688)));\n     /// ```\n     #[stable(feature = \"duration_checked_float\", since = \"1.66.0\")]\n-    #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n     #[inline]\n-    pub const fn try_from_secs_f32(secs: f32) -> Result<Duration, TryFromFloatSecsError> {\n+    pub fn try_from_secs_f32(secs: f32) -> Result<Duration, TryFromFloatSecsError> {\n         try_from_secs!(\n             secs = secs,\n             mantissa_bits = 23,\n@@ -1479,9 +1472,8 @@ impl Duration {\n     /// assert_eq!(res, Ok(Duration::new(1, 2_929_688)));\n     /// ```\n     #[stable(feature = \"duration_checked_float\", since = \"1.66.0\")]\n-    #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n     #[inline]\n-    pub const fn try_from_secs_f64(secs: f64) -> Result<Duration, TryFromFloatSecsError> {\n+    pub fn try_from_secs_f64(secs: f64) -> Result<Duration, TryFromFloatSecsError> {\n         try_from_secs!(\n             secs = secs,\n             mantissa_bits = 52,"}, {"sha": "75d7a3f40058e5edeecaf2583339b3bd0f0b22ec", "filename": "library/core/src/tuple.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Fsrc%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftuple.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -22,8 +22,7 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-            impl<$($T: ~const PartialEq),+> const PartialEq for ($($T,)+)\n+            impl<$($T: PartialEq),+> PartialEq for ($($T,)+)\n             where\n                 last_type!($($T,)+): ?Sized\n             {\n@@ -50,8 +49,7 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-            impl<$($T: ~const PartialOrd + ~const PartialEq),+> const PartialOrd for ($($T,)+)\n+            impl<$($T: PartialOrd),+> PartialOrd for ($($T,)+)\n             where\n                 last_type!($($T,)+): ?Sized\n             {\n@@ -81,8 +79,7 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-            impl<$($T: ~const Ord),+> const Ord for ($($T,)+)\n+            impl<$($T: Ord),+> Ord for ($($T,)+)\n             where\n                 last_type!($($T,)+): ?Sized\n             {\n@@ -96,8 +93,7 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-            impl<$($T: ~const Default),+> const Default for ($($T,)+) {\n+            impl<$($T: Default),+> Default for ($($T,)+) {\n                 #[inline]\n                 fn default() -> ($($T,)+) {\n                     ($({ let x: $T = Default::default(); x},)+)"}, {"sha": "a67a842d3407ffab5d09dd9c6eb02318b0760774", "filename": "library/core/tests/atomic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fatomic.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -306,9 +306,11 @@ fn atomic_compare_exchange() {\n     ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst).ok();\n }\n \n+/* FIXME(#110395)\n #[test]\n fn atomic_const_from() {\n     const _ATOMIC_U8: AtomicU8 = AtomicU8::from(1);\n     const _ATOMIC_BOOL: AtomicBool = AtomicBool::from(true);\n     const _ATOMIC_PTR: AtomicPtr<u32> = AtomicPtr::from(core::ptr::null_mut());\n }\n+*/"}, {"sha": "47f6459915b3e1dd7992fc506fcc4deb1d039f6f", "filename": "library/core/tests/bool.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fbool.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -89,6 +89,7 @@ fn test_bool_to_option() {\n     assert_eq!(false.then(|| 0), None);\n     assert_eq!(true.then(|| 0), Some(0));\n \n+    /* FIXME(#110395)\n     const fn zero() -> i32 {\n         0\n     }\n@@ -102,4 +103,5 @@ fn test_bool_to_option() {\n     assert_eq!(B, Some(0));\n     assert_eq!(C, None);\n     assert_eq!(D, Some(0));\n+    */\n }"}, {"sha": "e084f867943d3ad1ab1fe70060e564f5af5aed7e", "filename": "library/core/tests/cell.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fcell.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -468,6 +468,7 @@ fn const_cells() {\n     const CELL: Cell<i32> = Cell::new(3);\n     const _: i32 = CELL.into_inner();\n \n+/* FIXME(#110395)\n     const UNSAFE_CELL_FROM: UnsafeCell<i32> = UnsafeCell::from(3);\n     const _: i32 = UNSAFE_CELL.into_inner();\n \n@@ -476,4 +477,5 @@ fn const_cells() {\n \n     const CELL_FROM: Cell<i32> = Cell::from(3);\n     const _: i32 = CELL.into_inner();\n+*/\n }"}, {"sha": "85ba51c9228e3aafb63738fa56fba86731d3ef85", "filename": "library/core/tests/char.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fchar.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -21,6 +21,7 @@ fn test_convert() {\n     assert!(char::try_from(0xFFFF_FFFF_u32).is_err());\n }\n \n+/* FIXME(#110395)\n #[test]\n const fn test_convert_const() {\n     assert!(u32::from('a') == 0x61);\n@@ -30,6 +31,7 @@ const fn test_convert_const() {\n     assert!(char::from(b'a') == 'a');\n     assert!(char::from(b'\\xFF') == '\\u{FF}');\n }\n+*/\n \n #[test]\n fn test_from_str() {"}, {"sha": "72fdd490da152c58707c04866180fcdae8535652", "filename": "library/core/tests/cmp.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fcmp.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -217,18 +217,19 @@ fn cmp_default() {\n     assert_eq!(Fool(false), Fool(true));\n }\n \n+/* FIXME(#110395)\n mod const_cmp {\n     use super::*;\n \n     struct S(i32);\n \n-    impl const PartialEq for S {\n+    impl PartialEq for S {\n         fn eq(&self, other: &Self) -> bool {\n             self.0 == other.0\n         }\n     }\n \n-    impl const PartialOrd for S {\n+    impl PartialOrd for S {\n         fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n             let ret = match (self.0, other.0) {\n                 (a, b) if a > b => Ordering::Greater,\n@@ -248,3 +249,4 @@ mod const_cmp {\n     const _: () = assert!(S(0) < S(1));\n     const _: () = assert!(S(1) > S(0));\n }\n+*/"}, {"sha": "f76dd277884e20f0abc8bc6b90a97a00171d3622", "filename": "library/core/tests/convert.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fconvert.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,3 +1,4 @@\n+/* FIXME(#110395)\n #[test]\n fn convert() {\n     const fn from(x: i32) -> i32 {\n@@ -14,3 +15,4 @@ fn convert() {\n     const BAR: Vec<String> = into(Vec::new());\n     assert_eq!(BAR, Vec::<String>::new());\n }\n+*/"}, {"sha": "033bd1ed6ed9e055e1cc613f16b25ea74624cfa7", "filename": "library/core/tests/hash/mod.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fhash%2Fmod.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -9,13 +9,13 @@ struct MyHasher {\n     hash: u64,\n }\n \n-impl const Default for MyHasher {\n+impl Default for MyHasher {\n     fn default() -> MyHasher {\n         MyHasher { hash: 0 }\n     }\n }\n \n-impl const Hasher for MyHasher {\n+impl Hasher for MyHasher {\n     fn write(&mut self, buf: &[u8]) {\n         // FIXME(const_trait_impl): change to for loop\n         let mut i = 0;\n@@ -35,13 +35,14 @@ impl const Hasher for MyHasher {\n \n #[test]\n fn test_writer_hasher() {\n-    const fn hash<T: ~const Hash>(t: &T) -> u64 {\n+    // FIXME(#110395)\n+    /* const */ fn hash<T: Hash>(t: &T) -> u64 {\n         let mut s = MyHasher { hash: 0 };\n         t.hash(&mut s);\n         s.finish()\n     }\n \n-    const {\n+    /* const {\n         // FIXME(fee1-dead): assert_eq\n         assert!(hash(&()) == 0);\n         assert!(hash(&5_u8) == 5);\n@@ -52,7 +53,7 @@ fn test_writer_hasher() {\n \n         let s: &str = \"a\";\n         assert!(hash(&s) == 97 + 0xFF);\n-    };\n+    }; */\n \n     assert_eq!(hash(&()), 0);\n \n@@ -113,7 +114,7 @@ struct CustomHasher {\n     output: u64,\n }\n \n-impl const Hasher for CustomHasher {\n+impl Hasher for CustomHasher {\n     fn finish(&self) -> u64 {\n         self.output\n     }\n@@ -125,29 +126,30 @@ impl const Hasher for CustomHasher {\n     }\n }\n \n-impl const Default for CustomHasher {\n+impl Default for CustomHasher {\n     fn default() -> CustomHasher {\n         CustomHasher { output: 0 }\n     }\n }\n \n-impl const Hash for Custom {\n-    fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+impl Hash for Custom {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         state.write_u64(self.hash);\n     }\n }\n \n #[test]\n fn test_custom_state() {\n-    const fn hash<T: ~const Hash>(t: &T) -> u64 {\n+    // FIXME(#110395)\n+    /* const */ fn hash<T: Hash>(t: &T) -> u64 {\n         let mut c = CustomHasher { output: 0 };\n         t.hash(&mut c);\n         c.finish()\n     }\n \n     assert_eq!(hash(&Custom { hash: 5 }), 5);\n \n-    const { assert!(hash(&Custom { hash: 6 }) == 6) };\n+    // const { assert!(hash(&Custom { hash: 6 }) == 6) };\n }\n \n // FIXME: Instantiated functions with i128 in the signature is not supported in Emscripten."}, {"sha": "0a67c485c98bb3ebcd3ccdc95706a14d23affe3d", "filename": "library/core/tests/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fhash%2Fsip.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -23,19 +23,21 @@ fn hash<T: Hash>(x: &T) -> u64 {\n     hash_with(SipHasher::new(), x)\n }\n \n+/* FIXME(#110395)\n #[test]\n const fn test_const_sip() {\n     let val1 = 0x45;\n     let val2 = 0xfeed;\n \n-    const fn const_hash<T: ~const Hash>(x: &T) -> u64 {\n+    const fn const_hash<T: Hash>(x: &T) -> u64 {\n         let mut st = SipHasher::new();\n         x.hash(&mut st);\n         st.finish()\n     }\n \n     assert!(const_hash(&(val1)) != const_hash(&(val2)));\n }\n+*/\n \n #[test]\n #[allow(unused_must_use)]"}, {"sha": "e2f526d155e878b6ce0216171cde7d7bb3dce86d", "filename": "library/core/tests/lazy.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flazy.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -46,11 +46,13 @@ fn unsync_once_cell_drop_empty() {\n     drop(x);\n }\n \n+/* FIXME(#110395)\n #[test]\n const fn once_cell_const() {\n     let _once_cell: OnceCell<u32> = OnceCell::new();\n     let _once_cell: OnceCell<u32> = OnceCell::from(32);\n }\n+*/\n \n #[test]\n fn clone() {"}, {"sha": "f460da35dd3e650d59193e73d787c026ca6ab63a", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -8,16 +8,13 @@\n #![feature(const_assume)]\n #![feature(const_align_of_val_raw)]\n #![feature(const_black_box)]\n-#![feature(const_bool_to_option)]\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n-#![feature(const_convert)]\n #![feature(const_hash)]\n #![feature(const_heap)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n #![feature(const_maybe_uninit_assume_init_read)]\n #![feature(const_nonnull_new)]\n-#![feature(const_num_from_num)]\n #![feature(const_pointer_byte_offsets)]\n #![feature(const_pointer_is_aligned)]\n #![feature(const_ptr_as_ref)]"}, {"sha": "96356b728e926f656f669c1dc86a5f0dadea61f5", "filename": "library/core/tests/nonzero.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnonzero.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -215,11 +215,13 @@ fn nonzero_const() {\n     const ONE: Option<NonZeroU8> = NonZeroU8::new(1);\n     assert!(ONE.is_some());\n \n+    /* FIXME(#110395)\n     const FROM_NONZERO_U8: u8 = u8::from(NONZERO_U8);\n     assert_eq!(FROM_NONZERO_U8, 5);\n \n     const NONZERO_CONVERT: NonZeroU32 = NonZeroU32::from(NONZERO_U8);\n     assert_eq!(NONZERO_CONVERT.get(), 5);\n+    */\n }\n \n #[test]"}, {"sha": "fa58e77187915458b333d05e53a060b0098659ef", "filename": "library/core/tests/num/const_from.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fnum%2Fconst_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Fnum%2Fconst_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fconst_from.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,3 +1,4 @@\n+/* FIXME(#110395)\n #[test]\n fn from() {\n     use core::convert::TryFrom;\n@@ -23,3 +24,4 @@ fn from() {\n     const I16_FROM_U16: Result<i16, TryFromIntError> = i16::try_from(1u16);\n     assert_eq!(I16_FROM_U16, Ok(1i16));\n }\n+*/"}, {"sha": "5defeb50d40f99d88c4818fef47f67427ce847dc", "filename": "library/core/tests/option.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Foption.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -88,6 +88,7 @@ fn test_and() {\n     assert_eq!(x.and(Some(2)), None);\n     assert_eq!(x.and(None::<isize>), None);\n \n+    /* FIXME(#110395)\n     const FOO: Option<isize> = Some(1);\n     const A: Option<isize> = FOO.and(Some(2));\n     const B: Option<isize> = FOO.and(None);\n@@ -99,6 +100,7 @@ fn test_and() {\n     const D: Option<isize> = BAR.and(None);\n     assert_eq!(C, None);\n     assert_eq!(D, None);\n+    */\n }\n \n #[test]\n@@ -119,6 +121,7 @@ fn test_and_then() {\n     assert_eq!(x.and_then(plus_one), None);\n     assert_eq!(x.and_then(none), None);\n \n+    /* FIXME(#110395)\n     const FOO: Option<isize> = Some(1);\n     const A: Option<isize> = FOO.and_then(plus_one);\n     const B: Option<isize> = FOO.and_then(none);\n@@ -130,6 +133,7 @@ fn test_and_then() {\n     const D: Option<isize> = BAR.and_then(none);\n     assert_eq!(C, None);\n     assert_eq!(D, None);\n+    */\n }\n \n #[test]\n@@ -142,6 +146,7 @@ fn test_or() {\n     assert_eq!(x.or(Some(2)), Some(2));\n     assert_eq!(x.or(None), None);\n \n+    /* FIXME(#110395)\n     const FOO: Option<isize> = Some(1);\n     const A: Option<isize> = FOO.or(Some(2));\n     const B: Option<isize> = FOO.or(None);\n@@ -153,6 +158,7 @@ fn test_or() {\n     const D: Option<isize> = BAR.or(None);\n     assert_eq!(C, Some(2));\n     assert_eq!(D, None);\n+    */\n }\n \n #[test]\n@@ -173,6 +179,7 @@ fn test_or_else() {\n     assert_eq!(x.or_else(two), Some(2));\n     assert_eq!(x.or_else(none), None);\n \n+/* FIXME(#110395)\n     const FOO: Option<isize> = Some(1);\n     const A: Option<isize> = FOO.or_else(two);\n     const B: Option<isize> = FOO.or_else(none);\n@@ -184,6 +191,7 @@ fn test_or_else() {\n     const D: Option<isize> = BAR.or_else(none);\n     assert_eq!(C, Some(2));\n     assert_eq!(D, None);\n+*/\n }\n \n #[test]\n@@ -215,10 +223,12 @@ fn test_unwrap_or() {\n     let x: Option<isize> = None;\n     assert_eq!(x.unwrap_or(2), 2);\n \n+    /* FIXME(#110395)\n     const A: isize = Some(1).unwrap_or(2);\n     const B: isize = None.unwrap_or(2);\n     assert_eq!(A, 1);\n     assert_eq!(B, 2);\n+    */\n }\n \n #[test]\n@@ -233,10 +243,12 @@ fn test_unwrap_or_else() {\n     let x: Option<isize> = None;\n     assert_eq!(x.unwrap_or_else(two), 2);\n \n+    /* FIXME(#110395)\n     const A: isize = Some(1).unwrap_or_else(two);\n     const B: isize = None.unwrap_or_else(two);\n     assert_eq!(A, 1);\n     assert_eq!(B, 2);\n+    */\n }\n \n #[test]\n@@ -439,14 +451,15 @@ fn option_const() {\n     const OPTION: Option<usize> = Some(32);\n     assert_eq!(OPTION, Some(32));\n \n-    const OPTION_FROM: Option<usize> = Option::from(32);\n-    assert_eq!(OPTION_FROM, Some(32));\n+    // FIXME(#110395)\n+    // const OPTION_FROM: Option<usize> = Option::from(32);\n+    // assert_eq!(OPTION_FROM, Some(32));\n \n     const REF: Option<&usize> = OPTION.as_ref();\n     assert_eq!(REF, Some(&32));\n \n-    const REF_FROM: Option<&usize> = Option::from(&OPTION);\n-    assert_eq!(REF_FROM, Some(&32));\n+    // const REF_FROM: Option<&usize> = Option::from(&OPTION);\n+    // assert_eq!(REF_FROM, Some(&32));\n \n     const IS_SOME: bool = OPTION.is_some();\n     assert!(IS_SOME);\n@@ -474,14 +487,15 @@ const fn option_const_mut() {\n             None => unreachable!(),\n         }\n     }\n-\n+/* FIXME(const-hack)\n     {\n         let as_mut: Option<&mut usize> = Option::from(&mut option);\n         match as_mut {\n             Some(v) => *v = 42,\n             None => unreachable!(),\n         }\n     }\n+*/\n }\n \n #[test]"}, {"sha": "872611937cc084a0fc6120793415b18eface483f", "filename": "library/core/tests/time.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ftime.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -425,14 +425,16 @@ fn duration_const() {\n     const SECONDS_F32: f32 = Duration::SECOND.as_secs_f32();\n     assert_eq!(SECONDS_F32, 1.0);\n \n-    const FROM_SECONDS_F32: Duration = Duration::from_secs_f32(1.0);\n-    assert_eq!(FROM_SECONDS_F32, Duration::SECOND);\n+    // FIXME(#110395)\n+    // const FROM_SECONDS_F32: Duration = Duration::from_secs_f32(1.0);\n+    // assert_eq!(FROM_SECONDS_F32, Duration::SECOND);\n \n     const SECONDS_F64: f64 = Duration::SECOND.as_secs_f64();\n     assert_eq!(SECONDS_F64, 1.0);\n \n-    const FROM_SECONDS_F64: Duration = Duration::from_secs_f64(1.0);\n-    assert_eq!(FROM_SECONDS_F64, Duration::SECOND);\n+    // FIXME(#110395)\n+    // const FROM_SECONDS_F64: Duration = Duration::from_secs_f64(1.0);\n+    // assert_eq!(FROM_SECONDS_F64, Duration::SECOND);\n \n     const MILLIS: u128 = Duration::SECOND.as_millis();\n     assert_eq!(MILLIS, 1_000);\n@@ -463,6 +465,7 @@ fn duration_const() {\n     const CHECKED_MUL: Option<Duration> = Duration::SECOND.checked_mul(1);\n     assert_eq!(CHECKED_MUL, Some(Duration::SECOND));\n \n+/*  FIXME(#110395)\n     const MUL_F32: Duration = Duration::SECOND.mul_f32(1.0);\n     assert_eq!(MUL_F32, Duration::SECOND);\n \n@@ -477,6 +480,7 @@ fn duration_const() {\n \n     const DIV_F64: Duration = Duration::SECOND.div_f64(1.0);\n     assert_eq!(DIV_F64, Duration::SECOND);\n+*/\n \n     const DIV_DURATION_F32: f32 = Duration::SECOND.div_duration_f32(Duration::SECOND);\n     assert_eq!(DIV_DURATION_F32, 1.0);"}, {"sha": "c722bad2e4f6365b1d1188061ae9ad0053e6758d", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -3168,8 +3168,7 @@ impl DefaultHasher {\n }\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n-#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-impl const Default for DefaultHasher {\n+impl Default for DefaultHasher {\n     /// Creates a new `DefaultHasher` using [`new`].\n     /// See its documentation for more.\n     ///\n@@ -3181,8 +3180,7 @@ impl const Default for DefaultHasher {\n }\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n-#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-impl const Hasher for DefaultHasher {\n+impl Hasher for DefaultHasher {\n     // The underlying `SipHasher13` doesn't override the other\n     // `write_*` methods, so it's ok not to forward them here.\n "}, {"sha": "36951c4f13e9c934c005b2039661ff0ef5627e55", "filename": "library/std/src/sync/once_lock.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -344,8 +344,7 @@ impl<T: RefUnwindSafe + UnwindSafe> RefUnwindSafe for OnceLock<T> {}\n impl<T: UnwindSafe> UnwindSafe for OnceLock<T> {}\n \n #[stable(feature = \"once_cell\", since = \"CURRENT_RUSTC_VERSION\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for OnceLock<T> {\n+impl<T> Default for OnceLock<T> {\n     /// Creates a new empty cell.\n     ///\n     /// # Example"}, {"sha": "473e02f1cb1c800016e5462e25c44c7aa847cf9d", "filename": "tests/mir-opt/inline/unchecked_shifts.unchecked_shl_unsigned_smaller.Inline.diff", "status": "modified", "additions": 14, "deletions": 107, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.Inline.diff?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -10,51 +10,9 @@\n +     scope 1 (inlined core::num::<impl u16>::unchecked_shl) { // at $DIR/unchecked_shifts.rs:11:7: 11:23\n +         debug self => _3;                // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n +         debug rhs => _4;                 // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+         let mut _5: u16;                 // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+         let mut _6: std::option::Option<u16>; // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+         let mut _7: std::result::Result<u16, std::num::TryFromIntError>; // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n++         let mut _5: u16;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         let mut _6: (u32,);              // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n +         scope 2 {\n-+             scope 3 (inlined <u32 as TryInto<u16>>::try_into) { // at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+                 debug self => _4;        // in scope 3 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-+                 scope 4 (inlined convert::num::<impl TryFrom<u32> for u16>::try_from) { // at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-+                     debug u => _4;       // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                     let mut _8: bool;    // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                     let mut _9: u32;     // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                     let mut _10: u16;    // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                 }\n-+             }\n-+             scope 5 (inlined Result::<u16, TryFromIntError>::ok) { // at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+                 debug self => _7;        // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+                 let mut _11: isize;      // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+                 let _12: u16;            // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+                 scope 6 {\n-+                     debug x => _12;      // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-+                 }\n-+                 scope 7 {\n-+                     scope 8 {\n-+                         debug x => const TryFromIntError(()); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-+                     }\n-+                 }\n-+             }\n-+             scope 9 (inlined #[track_caller] Option::<u16>::unwrap_unchecked) { // at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+                 debug self => _6;        // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+                 let mut _13: &std::option::Option<u16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+                 let mut _14: isize;      // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+                 scope 10 {\n-+                     debug val => _5;     // in scope 10 at $SRC_DIR/core/src/option.rs:LL:COL\n-+                 }\n-+                 scope 11 {\n-+                     scope 13 (inlined unreachable_unchecked) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-+                         scope 14 {\n-+                             scope 15 (inlined unreachable_unchecked::runtime) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-+                             }\n-+                         }\n-+                     }\n-+                 }\n-+                 scope 12 (inlined Option::<u16>::is_some) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-+                     debug self => _13;   // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n-+                 }\n-+             }\n +         }\n +     }\n   \n@@ -64,81 +22,30 @@\n           StorageLive(_4);                 // scope 0 at $DIR/unchecked_shifts.rs:+1:21: +1:22\n           _4 = _2;                         // scope 0 at $DIR/unchecked_shifts.rs:+1:21: +1:22\n -         _0 = core::num::<impl u16>::unchecked_shl(move _3, move _4) -> bb1; // scope 0 at $DIR/unchecked_shifts.rs:+1:5: +1:23\n--                                          // mir::Constant\n++         StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         StorageLive(_6);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         _6 = (_4,);                      // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         _5 = core::num::<impl u16>::unchecked_shl::conv(move (_6.0: u32)) -> bb1; // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                           // mir::Constant\n -                                          // + span: $DIR/unchecked_shifts.rs:11:7: 11:20\n -                                          // + literal: Const { ty: unsafe fn(u16, u32) -> u16 {core::num::<impl u16>::unchecked_shl}, val: Value(<ZST>) }\n-+         StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+         StorageLive(_6);                 // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+         StorageLive(_7);                 // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+         StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageLive(_9);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _9 = const 65535_u32;            // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _8 = Gt(_4, move _9);            // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageDead(_9);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         switchInt(move _8) -> [0: bb4, otherwise: bb3]; // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++                                          // + span: $SRC_DIR/core/src/num/mod.rs:LL:COL\n++                                          // + literal: Const { ty: fn(u32) -> u16 {core::num::<impl u16>::unchecked_shl::conv}, val: Value(<ZST>) }\n       }\n   \n       bb1: {\n-+         StorageDead(_12);                // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+         StorageDead(_7);                 // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+         StorageLive(_13);                // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+         _14 = discriminant(_6);          // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+         switchInt(move _14) -> [1: bb9, otherwise: bb7]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n++         StorageDead(_6);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         _0 = unchecked_shl::<u16>(_3, move _5) -> [return: bb2, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n++                                          // mir::Constant\n++                                          // + span: $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u16, u16) -> u16 {unchecked_shl::<u16>}, val: Value(<ZST>) }\n +     }\n + \n +     bb2: {\n +         StorageDead(_5);                 // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n           StorageDead(_4);                 // scope 0 at $DIR/unchecked_shifts.rs:+1:22: +1:23\n           StorageDead(_3);                 // scope 0 at $DIR/unchecked_shifts.rs:+1:22: +1:23\n           return;                          // scope 0 at $DIR/unchecked_shifts.rs:+2:2: +2:2\n-+     }\n-+ \n-+     bb3: {\n-+         _7 = Result::<u16, TryFromIntError>::Err(const TryFromIntError(())); // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                                          // mir::Constant\n-+                                          // + span: no-location\n-+                                          // + literal: Const { ty: TryFromIntError, val: Value(<ZST>) }\n-+         goto -> bb5;                     // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+     }\n-+ \n-+     bb4: {\n-+         StorageLive(_10);                // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _10 = _4 as u16 (IntToInt);      // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _7 = Result::<u16, TryFromIntError>::Ok(move _10); // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageDead(_10);                // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         goto -> bb5;                     // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+     }\n-+ \n-+     bb5: {\n-+         StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageLive(_12);                // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+         _11 = discriminant(_7);          // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         switchInt(move _11) -> [0: bb8, 1: bb6, otherwise: bb7]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+     }\n-+ \n-+     bb6: {\n-+         _6 = Option::<u16>::None;        // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         goto -> bb1;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-+     }\n-+ \n-+     bb7: {\n-+         unreachable;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+     }\n-+ \n-+     bb8: {\n-+         _12 = move ((_7 as Ok).0: u16);  // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         _6 = Option::<u16>::Some(move _12); // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         goto -> bb1;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+     }\n-+ \n-+     bb9: {\n-+         _5 = move ((_6 as Some).0: u16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+         StorageDead(_13);                // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+         StorageDead(_6);                 // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+         _0 = unchecked_shl::<u16>(_3, move _5) -> [return: bb2, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+                                          // mir::Constant\n-+                                          // + span: $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u16, u16) -> u16 {unchecked_shl::<u16>}, val: Value(<ZST>) }\n       }\n   }\n   "}, {"sha": "9b7b11ef659aac1bfd0512148d9659ec3883dd65", "filename": "tests/mir-opt/inline/unchecked_shifts.unchecked_shl_unsigned_smaller.PreCodegen.after.mir", "status": "modified", "additions": 14, "deletions": 106, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.PreCodegen.after.mir?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -7,124 +7,32 @@ fn unchecked_shl_unsigned_smaller(_1: u16, _2: u32) -> u16 {\n     scope 1 (inlined core::num::<impl u16>::unchecked_shl) { // at $DIR/unchecked_shifts.rs:11:7: 11:23\n         debug self => _1;                // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n         debug rhs => _2;                 // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        let mut _3: u16;                 // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        let mut _4: std::option::Option<u16>; // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        let mut _5: std::result::Result<u16, std::num::TryFromIntError>; // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        let mut _3: u16;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        let mut _4: (u32,);              // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n         scope 2 {\n-            scope 3 (inlined <u32 as TryInto<u16>>::try_into) { // at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-                debug self => _2;        // in scope 3 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-                scope 4 (inlined convert::num::<impl TryFrom<u32> for u16>::try_from) { // at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-                    debug u => _2;       // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                    let mut _6: bool;    // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                    let mut _7: u32;     // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                    let mut _8: u16;     // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                }\n-            }\n-            scope 5 (inlined Result::<u16, TryFromIntError>::ok) { // at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-                debug self => _5;        // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-                let mut _9: isize;       // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-                let _10: u16;            // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-                scope 6 {\n-                    debug x => _10;      // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-                }\n-                scope 7 {\n-                    scope 8 {\n-                        debug x => const TryFromIntError(()); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                    }\n-                }\n-            }\n-            scope 9 (inlined #[track_caller] Option::<u16>::unwrap_unchecked) { // at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-                debug self => _4;        // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-                let mut _11: &std::option::Option<u16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-                let mut _12: isize;      // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-                scope 10 {\n-                    debug val => _3;     // in scope 10 at $SRC_DIR/core/src/option.rs:LL:COL\n-                }\n-                scope 11 {\n-                    scope 13 (inlined unreachable_unchecked) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-                        scope 14 {\n-                            scope 15 (inlined unreachable_unchecked::runtime) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                            }\n-                        }\n-                    }\n-                }\n-                scope 12 (inlined Option::<u16>::is_some) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-                    debug self => _11;   // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n-                }\n-            }\n         }\n     }\n \n     bb0: {\n-        StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        StorageLive(_4);                 // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        StorageLive(_6);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageLive(_7);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _7 = const 65535_u32;            // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _6 = Gt(_2, move _7);            // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        switchInt(move _6) -> [0: bb4, otherwise: bb3]; // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_4);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _4 = (_2,);                      // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _3 = core::num::<impl u16>::unchecked_shl::conv(move (_4.0: u32)) -> bb1; // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                         // + literal: Const { ty: fn(u32) -> u16 {core::num::<impl u16>::unchecked_shl::conv}, val: Value(<ZST>) }\n     }\n \n     bb1: {\n-        StorageDead(_10);                // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        StorageDead(_5);                 // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        StorageLive(_11);                // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        _12 = discriminant(_4);          // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-        switchInt(move _12) -> [1: bb9, otherwise: bb7]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_4);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _0 = unchecked_shl::<u16>(_1, move _3) -> [return: bb2, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                                         // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u16, u16) -> u16 {unchecked_shl::<u16>}, val: Value(<ZST>) }\n     }\n \n     bb2: {\n         StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n         return;                          // scope 0 at $DIR/unchecked_shifts.rs:+2:2: +2:2\n     }\n-\n-    bb3: {\n-        _5 = Result::<u16, TryFromIntError>::Err(const TryFromIntError(())); // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                                         // mir::Constant\n-                                         // + span: no-location\n-                                         // + literal: Const { ty: TryFromIntError, val: Value(<ZST>) }\n-        goto -> bb5;                     // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-    }\n-\n-    bb4: {\n-        StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _8 = _2 as u16 (IntToInt);       // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _5 = Result::<u16, TryFromIntError>::Ok(move _8); // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        goto -> bb5;                     // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-    }\n-\n-    bb5: {\n-        StorageDead(_6);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageLive(_10);                // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        _9 = discriminant(_5);           // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        switchInt(move _9) -> [0: bb8, 1: bb6, otherwise: bb7]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-    }\n-\n-    bb6: {\n-        _4 = Option::<u16>::None;        // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-        goto -> bb1;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-    }\n-\n-    bb7: {\n-        unreachable;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-    }\n-\n-    bb8: {\n-        _10 = move ((_5 as Ok).0: u16);  // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        _4 = Option::<u16>::Some(move _10); // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-        goto -> bb1;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-    }\n-\n-    bb9: {\n-        _3 = move ((_4 as Some).0: u16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-        StorageDead(_11);                // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        StorageDead(_4);                 // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        _0 = unchecked_shl::<u16>(_1, move _3) -> [return: bb2, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-                                         // mir::Constant\n-                                         // + span: $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-                                         // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u16, u16) -> u16 {unchecked_shl::<u16>}, val: Value(<ZST>) }\n-    }\n }"}, {"sha": "9638ddda46b715558497df4f3404c5d8c3a7bb7d", "filename": "tests/mir-opt/inline/unchecked_shifts.unchecked_shr_signed_smaller.Inline.diff", "status": "modified", "additions": 14, "deletions": 107, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.Inline.diff?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -10,51 +10,9 @@\n +     scope 1 (inlined core::num::<impl i16>::unchecked_shr) { // at $DIR/unchecked_shifts.rs:17:7: 17:23\n +         debug self => _3;                // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n +         debug rhs => _4;                 // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+         let mut _5: i16;                 // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+         let mut _6: std::option::Option<i16>; // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+         let mut _7: std::result::Result<i16, std::num::TryFromIntError>; // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n++         let mut _5: i16;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         let mut _6: (u32,);              // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n +         scope 2 {\n-+             scope 3 (inlined <u32 as TryInto<i16>>::try_into) { // at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+                 debug self => _4;        // in scope 3 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-+                 scope 4 (inlined convert::num::<impl TryFrom<u32> for i16>::try_from) { // at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-+                     debug u => _4;       // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                     let mut _8: bool;    // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                     let mut _9: u32;     // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                     let mut _10: i16;    // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                 }\n-+             }\n-+             scope 5 (inlined Result::<i16, TryFromIntError>::ok) { // at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+                 debug self => _7;        // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+                 let mut _11: isize;      // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+                 let _12: i16;            // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+                 scope 6 {\n-+                     debug x => _12;      // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-+                 }\n-+                 scope 7 {\n-+                     scope 8 {\n-+                         debug x => const TryFromIntError(()); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-+                     }\n-+                 }\n-+             }\n-+             scope 9 (inlined #[track_caller] Option::<i16>::unwrap_unchecked) { // at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+                 debug self => _6;        // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+                 let mut _13: &std::option::Option<i16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+                 let mut _14: isize;      // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+                 scope 10 {\n-+                     debug val => _5;     // in scope 10 at $SRC_DIR/core/src/option.rs:LL:COL\n-+                 }\n-+                 scope 11 {\n-+                     scope 13 (inlined unreachable_unchecked) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-+                         scope 14 {\n-+                             scope 15 (inlined unreachable_unchecked::runtime) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-+                             }\n-+                         }\n-+                     }\n-+                 }\n-+                 scope 12 (inlined Option::<i16>::is_some) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-+                     debug self => _13;   // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n-+                 }\n-+             }\n +         }\n +     }\n   \n@@ -64,81 +22,30 @@\n           StorageLive(_4);                 // scope 0 at $DIR/unchecked_shifts.rs:+1:21: +1:22\n           _4 = _2;                         // scope 0 at $DIR/unchecked_shifts.rs:+1:21: +1:22\n -         _0 = core::num::<impl i16>::unchecked_shr(move _3, move _4) -> bb1; // scope 0 at $DIR/unchecked_shifts.rs:+1:5: +1:23\n--                                          // mir::Constant\n++         StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         StorageLive(_6);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         _6 = (_4,);                      // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         _5 = core::num::<impl i16>::unchecked_shr::conv(move (_6.0: u32)) -> bb1; // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                           // mir::Constant\n -                                          // + span: $DIR/unchecked_shifts.rs:17:7: 17:20\n -                                          // + literal: Const { ty: unsafe fn(i16, u32) -> i16 {core::num::<impl i16>::unchecked_shr}, val: Value(<ZST>) }\n-+         StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+         StorageLive(_6);                 // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+         StorageLive(_7);                 // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+         StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageLive(_9);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _9 = const 32767_u32;            // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _8 = Gt(_4, move _9);            // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageDead(_9);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         switchInt(move _8) -> [0: bb4, otherwise: bb3]; // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++                                          // + span: $SRC_DIR/core/src/num/mod.rs:LL:COL\n++                                          // + literal: Const { ty: fn(u32) -> i16 {core::num::<impl i16>::unchecked_shr::conv}, val: Value(<ZST>) }\n       }\n   \n       bb1: {\n-+         StorageDead(_12);                // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+         StorageDead(_7);                 // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+         StorageLive(_13);                // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+         _14 = discriminant(_6);          // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+         switchInt(move _14) -> [1: bb9, otherwise: bb7]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n++         StorageDead(_6);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         _0 = unchecked_shr::<i16>(_3, move _5) -> [return: bb2, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n++                                          // mir::Constant\n++                                          // + span: $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(i16, i16) -> i16 {unchecked_shr::<i16>}, val: Value(<ZST>) }\n +     }\n + \n +     bb2: {\n +         StorageDead(_5);                 // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n           StorageDead(_4);                 // scope 0 at $DIR/unchecked_shifts.rs:+1:22: +1:23\n           StorageDead(_3);                 // scope 0 at $DIR/unchecked_shifts.rs:+1:22: +1:23\n           return;                          // scope 0 at $DIR/unchecked_shifts.rs:+2:2: +2:2\n-+     }\n-+ \n-+     bb3: {\n-+         _7 = Result::<i16, TryFromIntError>::Err(const TryFromIntError(())); // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                                          // mir::Constant\n-+                                          // + span: no-location\n-+                                          // + literal: Const { ty: TryFromIntError, val: Value(<ZST>) }\n-+         goto -> bb5;                     // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+     }\n-+ \n-+     bb4: {\n-+         StorageLive(_10);                // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _10 = _4 as i16 (IntToInt);      // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _7 = Result::<i16, TryFromIntError>::Ok(move _10); // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageDead(_10);                // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         goto -> bb5;                     // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+     }\n-+ \n-+     bb5: {\n-+         StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageLive(_12);                // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+         _11 = discriminant(_7);          // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         switchInt(move _11) -> [0: bb8, 1: bb6, otherwise: bb7]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+     }\n-+ \n-+     bb6: {\n-+         _6 = Option::<i16>::None;        // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         goto -> bb1;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-+     }\n-+ \n-+     bb7: {\n-+         unreachable;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+     }\n-+ \n-+     bb8: {\n-+         _12 = move ((_7 as Ok).0: i16);  // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         _6 = Option::<i16>::Some(move _12); // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         goto -> bb1;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+     }\n-+ \n-+     bb9: {\n-+         _5 = move ((_6 as Some).0: i16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+         StorageDead(_13);                // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+         StorageDead(_6);                 // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+         _0 = unchecked_shr::<i16>(_3, move _5) -> [return: bb2, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+                                          // mir::Constant\n-+                                          // + span: $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(i16, i16) -> i16 {unchecked_shr::<i16>}, val: Value(<ZST>) }\n       }\n   }\n   "}, {"sha": "afe6d08741b4722f94f7ef8fc6f08a75ec0ac17a", "filename": "tests/mir-opt/inline/unchecked_shifts.unchecked_shr_signed_smaller.PreCodegen.after.mir", "status": "modified", "additions": 14, "deletions": 106, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.PreCodegen.after.mir?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -7,124 +7,32 @@ fn unchecked_shr_signed_smaller(_1: i16, _2: u32) -> i16 {\n     scope 1 (inlined core::num::<impl i16>::unchecked_shr) { // at $DIR/unchecked_shifts.rs:17:7: 17:23\n         debug self => _1;                // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n         debug rhs => _2;                 // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        let mut _3: i16;                 // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        let mut _4: std::option::Option<i16>; // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        let mut _5: std::result::Result<i16, std::num::TryFromIntError>; // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n+        let mut _3: i16;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        let mut _4: (u32,);              // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n         scope 2 {\n-            scope 3 (inlined <u32 as TryInto<i16>>::try_into) { // at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-                debug self => _2;        // in scope 3 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-                scope 4 (inlined convert::num::<impl TryFrom<u32> for i16>::try_from) { // at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-                    debug u => _2;       // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                    let mut _6: bool;    // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                    let mut _7: u32;     // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                    let mut _8: i16;     // in scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                }\n-            }\n-            scope 5 (inlined Result::<i16, TryFromIntError>::ok) { // at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-                debug self => _5;        // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-                let mut _9: isize;       // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-                let _10: i16;            // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-                scope 6 {\n-                    debug x => _10;      // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-                }\n-                scope 7 {\n-                    scope 8 {\n-                        debug x => const TryFromIntError(()); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                    }\n-                }\n-            }\n-            scope 9 (inlined #[track_caller] Option::<i16>::unwrap_unchecked) { // at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-                debug self => _4;        // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-                let mut _11: &std::option::Option<i16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-                let mut _12: isize;      // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-                scope 10 {\n-                    debug val => _3;     // in scope 10 at $SRC_DIR/core/src/option.rs:LL:COL\n-                }\n-                scope 11 {\n-                    scope 13 (inlined unreachable_unchecked) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-                        scope 14 {\n-                            scope 15 (inlined unreachable_unchecked::runtime) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                            }\n-                        }\n-                    }\n-                }\n-                scope 12 (inlined Option::<i16>::is_some) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-                    debug self => _11;   // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n-                }\n-            }\n         }\n     }\n \n     bb0: {\n-        StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        StorageLive(_4);                 // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        StorageLive(_6);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageLive(_7);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _7 = const 32767_u32;            // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _6 = Gt(_2, move _7);            // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        switchInt(move _6) -> [0: bb4, otherwise: bb3]; // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_4);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _4 = (_2,);                      // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _3 = core::num::<impl i16>::unchecked_shr::conv(move (_4.0: u32)) -> bb1; // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                         // + literal: Const { ty: fn(u32) -> i16 {core::num::<impl i16>::unchecked_shr::conv}, val: Value(<ZST>) }\n     }\n \n     bb1: {\n-        StorageDead(_10);                // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        StorageDead(_5);                 // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        StorageLive(_11);                // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        _12 = discriminant(_4);          // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-        switchInt(move _12) -> [1: bb9, otherwise: bb7]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_4);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _0 = unchecked_shr::<i16>(_1, move _3) -> [return: bb2, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n+                                         // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(i16, i16) -> i16 {unchecked_shr::<i16>}, val: Value(<ZST>) }\n     }\n \n     bb2: {\n         StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n         return;                          // scope 0 at $DIR/unchecked_shifts.rs:+2:2: +2:2\n     }\n-\n-    bb3: {\n-        _5 = Result::<i16, TryFromIntError>::Err(const TryFromIntError(())); // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                                         // mir::Constant\n-                                         // + span: no-location\n-                                         // + literal: Const { ty: TryFromIntError, val: Value(<ZST>) }\n-        goto -> bb5;                     // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-    }\n-\n-    bb4: {\n-        StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _8 = _2 as i16 (IntToInt);       // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _5 = Result::<i16, TryFromIntError>::Ok(move _8); // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        goto -> bb5;                     // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-    }\n-\n-    bb5: {\n-        StorageDead(_6);                 // scope 4 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageLive(_10);                // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        _9 = discriminant(_5);           // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        switchInt(move _9) -> [0: bb8, 1: bb6, otherwise: bb7]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-    }\n-\n-    bb6: {\n-        _4 = Option::<i16>::None;        // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-        goto -> bb1;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-    }\n-\n-    bb7: {\n-        unreachable;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-    }\n-\n-    bb8: {\n-        _10 = move ((_5 as Ok).0: i16);  // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-        _4 = Option::<i16>::Some(move _10); // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-        goto -> bb1;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-    }\n-\n-    bb9: {\n-        _3 = move ((_4 as Some).0: i16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-        StorageDead(_11);                // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        StorageDead(_4);                 // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        _0 = unchecked_shr::<i16>(_1, move _3) -> [return: bb2, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-                                         // mir::Constant\n-                                         // + span: $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-                                         // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(i16, i16) -> i16 {unchecked_shr::<i16>}, val: Value(<ZST>) }\n-    }\n }"}, {"sha": "1ee8037a1e79abb42b26fd3ef587f7e1089fc34e", "filename": "tests/run-make/coverage/uses_crate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Frun-make%2Fcoverage%2Fuses_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Frun-make%2Fcoverage%2Fuses_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fcoverage%2Fuses_crate.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,3 +1,6 @@\n+// FIXME #110395\n+// ignore-llvm-cov-show-diffs\n+\n #![allow(unused_assignments, unused_variables)]\n // compile-flags: -C opt-level=3 # validates coverage now works with optimizations\n extern crate used_crate;"}, {"sha": "f7aff3c3f8a5dfb809464196aa65df067f31ca3b", "filename": "tests/run-make/coverage/uses_inline_crate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Frun-make%2Fcoverage%2Fuses_inline_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Frun-make%2Fcoverage%2Fuses_inline_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fcoverage%2Fuses_inline_crate.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,3 +1,6 @@\n+// FIXME #110395\n+// ignore-llvm-cov-show-diffs\n+\n #![allow(unused_assignments, unused_variables)]\n \n // compile-flags: -C opt-level=3 # validates coverage now works with optimizations"}, {"sha": "6006354eba4e5154c455771b4b4b79291890b5fc", "filename": "tests/rustdoc/hide-complex-unevaluated-const-arguments.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Frustdoc%2Fhide-complex-unevaluated-const-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Frustdoc%2Fhide-complex-unevaluated-const-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fhide-complex-unevaluated-const-arguments.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -29,7 +29,7 @@ pub trait Stage {\n     //\n     // @has - '//*[@id=\"associatedconstant.ARRAY1\"]' \\\n     //        'const ARRAY1: [u8; { _ }]'\n-    const ARRAY1: [u8; Struct::new(/* ... */) + Self::ABSTRACT * 1_000];\n+    const ARRAY1: [u8; Struct::new(/* ... */).do_something(Self::ABSTRACT * 1_000)];\n \n     // @has - '//*[@id=\"associatedconstant.VERBOSE\"]' \\\n     //        'const VERBOSE: [u16; { _ }]'\n@@ -73,10 +73,14 @@ pub struct Struct { private: () }\n \n impl Struct {\n     const fn new() -> Self { Self { private: () } }\n+    const fn do_something(self, x: usize) -> usize {\n+        x\n+    }\n }\n-\n+/* FIXME(const-trait): readd this\n impl const std::ops::Add<usize> for Struct {\n     type Output = usize;\n \n     fn add(self, _: usize) -> usize { 0 }\n }\n+*/"}, {"sha": "5d742dc391a53e0c64f7325e5d2a6764f890d67c", "filename": "tests/rustdoc/rfc-2632-const-trait-impl.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Frustdoc%2Frfc-2632-const-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Frustdoc%2Frfc-2632-const-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Frfc-2632-const-trait-impl.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -13,57 +13,57 @@ use std::marker::Destruct;\n pub struct S<T>(T);\n \n // @!has foo/trait.Tr.html '//pre[@class=\"rust item-decl\"]/code/a[@class=\"trait\"]' '~const'\n-// @has - '//pre[@class=\"rust item-decl\"]/code/a[@class=\"trait\"]' 'Clone'\n+// @has - '//pre[@class=\"rust item-decl\"]/code/a[@class=\"trait\"]' 'Fn'\n // @!has - '//pre[@class=\"rust item-decl\"]/code/span[@class=\"where\"]' '~const'\n-// @has - '//pre[@class=\"rust item-decl\"]/code/span[@class=\"where\"]' ': Clone'\n+// @has - '//pre[@class=\"rust item-decl\"]/code/span[@class=\"where\"]' ': Fn'\n #[const_trait]\n pub trait Tr<T> {\n     // @!has - '//section[@id=\"method.a\"]/h4[@class=\"code-header\"]' '~const'\n-    // @has - '//section[@id=\"method.a\"]/h4[@class=\"code-header\"]/a[@class=\"trait\"]' 'Clone'\n+    // @has - '//section[@id=\"method.a\"]/h4[@class=\"code-header\"]/a[@class=\"trait\"]' 'Fn'\n     // @!has - '//section[@id=\"method.a\"]/h4[@class=\"code-header\"]/span[@class=\"where\"]' '~const'\n-    // @has - '//section[@id=\"method.a\"]/h4[@class=\"code-header\"]/span[@class=\"where fmt-newline\"]' ': Clone'\n-    fn a<A: ~const Clone + ~const Destruct>()\n+    // @has - '//section[@id=\"method.a\"]/h4[@class=\"code-header\"]/span[@class=\"where fmt-newline\"]' ': Fn'\n+    fn a<A: ~const Fn() + ~const Destruct>()\n     where\n-        Option<A>: ~const Clone + ~const Destruct,\n+        Option<A>: ~const Fn() + ~const Destruct,\n     {\n     }\n }\n \n // @has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]' ''\n // @!has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]/h3[@class=\"code-header\"]' '~const'\n-// @has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]/h3[@class=\"code-header\"]/a[@class=\"trait\"]' 'Clone'\n+// @has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]/h3[@class=\"code-header\"]/a[@class=\"trait\"]' 'Fn'\n // @!has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]/h3[@class=\"code-header\"]/span[@class=\"where\"]' '~const'\n-// @has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]/h3[@class=\"code-header\"]/span[@class=\"where fmt-newline\"]' ': Clone'\n-impl<T: ~const Clone + ~const Destruct> const Tr<T> for T\n+// @has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]/h3[@class=\"code-header\"]/span[@class=\"where fmt-newline\"]' ': Fn'\n+impl<T: ~const Fn() + ~const Destruct> const Tr<T> for T\n where\n-    Option<T>: ~const Clone + ~const Destruct,\n+    Option<T>: ~const Fn() + ~const Destruct,\n {\n-    fn a<A: ~const Clone + ~const Destruct>()\n+    fn a<A: ~const Fn() + ~const Destruct>()\n     where\n-        Option<A>: ~const Clone + ~const Destruct,\n+        Option<A>: ~const Fn() + ~const Destruct,\n     {\n     }\n }\n \n // @!has foo/fn.foo.html '//pre[@class=\"rust item-decl\"]/code/a[@class=\"trait\"]' '~const'\n-// @has - '//pre[@class=\"rust item-decl\"]/code/a[@class=\"trait\"]' 'Clone'\n+// @has - '//pre[@class=\"rust item-decl\"]/code/a[@class=\"trait\"]' 'Fn'\n // @!has - '//pre[@class=\"rust item-decl\"]/code/span[@class=\"where fmt-newline\"]' '~const'\n-// @has - '//pre[@class=\"rust item-decl\"]/code/span[@class=\"where fmt-newline\"]' ': Clone'\n-pub const fn foo<F: ~const Clone + ~const Destruct>()\n+// @has - '//pre[@class=\"rust item-decl\"]/code/span[@class=\"where fmt-newline\"]' ': Fn'\n+pub const fn foo<F: ~const Fn() + ~const Destruct>()\n where\n-    Option<F>: ~const Clone + ~const Destruct,\n+    Option<F>: ~const Fn() + ~const Destruct,\n {\n     F::a()\n }\n \n impl<T> S<T> {\n     // @!has foo/struct.S.html '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]' '~const'\n-    // @has - '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]/a[@class=\"trait\"]' 'Clone'\n+    // @has - '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]/a[@class=\"trait\"]' 'Fn'\n     // @!has - '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]/span[@class=\"where\"]' '~const'\n-    // @has - '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]/span[@class=\"where fmt-newline\"]' ': Clone'\n-    pub const fn foo<B, C: ~const Clone + ~const Destruct>()\n+    // @has - '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]/span[@class=\"where fmt-newline\"]' ': Fn'\n+    pub const fn foo<B, C: ~const Fn() + ~const Destruct>()\n     where\n-        B: ~const Clone + ~const Destruct,\n+        B: ~const Fn() + ~const Destruct,\n     {\n         B::a()\n     }"}, {"sha": "ae9207cf8555b66132b8cdbc771b2c3caad6378d", "filename": "tests/ui/const-generics/generic_const_exprs/unify-op-with-fn-call.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,3 +1,5 @@\n+// known-bug: #110395\n+\n #![feature(generic_const_exprs, adt_const_params, const_trait_impl)]\n #![allow(incomplete_features)]\n \n@@ -26,7 +28,6 @@ struct Evaluatable2<const N: usize>;\n \n fn foo2<const N: usize>(a: Evaluatable2<{ N + N }>) {\n     bar2::<{ std::ops::Add::add(N, N) }>();\n-    //~^ error: unconstrained generic constant\n     // FIXME(generic_const_exprs) make this not an error\n }\n "}, {"sha": "7f28771cee83f99139c5aa3e767a8fef2a56412c", "filename": "tests/ui/const-generics/generic_const_exprs/unify-op-with-fn-call.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funify-op-with-fn-call.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,10 +1,11 @@\n-error: unconstrained generic constant\n-  --> $DIR/unify-op-with-fn-call.rs:28:12\n+error: const `impl` for trait `Add` which is not marked with `#[const_trait]`\n+  --> $DIR/unify-op-with-fn-call.rs:10:12\n    |\n-LL |     bar2::<{ std::ops::Add::add(N, N) }>();\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | impl const std::ops::Add for Foo {\n+   |            ^^^^^^^^^^^^^\n    |\n-   = help: try adding a `where` bound using this expression: `where [(); { std::ops::Add::add(N, N) }]:`\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n \n error: aborting due to previous error\n "}, {"sha": "05f33c33946a896444f70031dbac0aabf3426131", "filename": "tests/ui/consts/const-eval/const-eval-overflow-3b.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -4,13 +4,13 @@ error[E0308]: mismatched types\n LL |     = [0; (i8::MAX + 1u8) as usize];\n    |                      ^^^ expected `i8`, found `u8`\n \n-error[E0277]: cannot add `u8` to `i8` in const contexts\n+error[E0277]: cannot add `u8` to `i8`\n   --> $DIR/const-eval-overflow-3b.rs:16:20\n    |\n LL |     = [0; (i8::MAX + 1u8) as usize];\n    |                    ^ no implementation for `i8 + u8`\n    |\n-   = help: the trait `~const Add<u8>` is not implemented for `i8`\n+   = help: the trait `Add<u8>` is not implemented for `i8`\n    = help: the following other types implement trait `Add<Rhs>`:\n              <&'a i8 as Add<i8>>\n              <&i8 as Add<&i8>>"}, {"sha": "d019f5920b5174f7d7d5fef6db03921096ce7c8c", "filename": "tests/ui/consts/const-eval/const-eval-overflow-4b.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -4,13 +4,13 @@ error[E0308]: mismatched types\n LL |     : [u32; (i8::MAX as i8 + 1u8) as usize]\n    |                              ^^^ expected `i8`, found `u8`\n \n-error[E0277]: cannot add `u8` to `i8` in const contexts\n+error[E0277]: cannot add `u8` to `i8`\n   --> $DIR/const-eval-overflow-4b.rs:9:28\n    |\n LL |     : [u32; (i8::MAX as i8 + 1u8) as usize]\n    |                            ^ no implementation for `i8 + u8`\n    |\n-   = help: the trait `~const Add<u8>` is not implemented for `i8`\n+   = help: the trait `Add<u8>` is not implemented for `i8`\n    = help: the following other types implement trait `Add<Rhs>`:\n              <&'a i8 as Add<i8>>\n              <&i8 as Add<&i8>>"}, {"sha": "432a05756d305ef401b03c665a6ff5fe32647250", "filename": "tests/ui/consts/const-eval/const_raw_ptr_ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,6 +1,6 @@\n fn main() {}\n \n // unconst and bad, will thus error in miri\n-const X: bool = unsafe { &1 as *const i32 == &2 as *const i32 }; //~ ERROR can't compare\n+const X: bool = unsafe { &1 as *const i32 == &2 as *const i32 }; //~ ERROR pointers cannot\n // unconst and bad, will thus error in miri\n-const X2: bool = unsafe { 42 as *const i32 == 43 as *const i32 }; //~ ERROR can't compare\n+const X2: bool = unsafe { 42 as *const i32 == 43 as *const i32 }; //~ ERROR pointers cannot"}, {"sha": "1f5bca273d3b040012c8b4dd13c8e613d1b9fcdb", "filename": "tests/ui/consts/const-eval/const_raw_ptr_ops.stderr", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,29 +1,18 @@\n-error[E0277]: can't compare `*const i32` with `_` in const contexts\n-  --> $DIR/const_raw_ptr_ops.rs:4:43\n+error: pointers cannot be reliably compared during const eval\n+  --> $DIR/const_raw_ptr_ops.rs:4:26\n    |\n LL | const X: bool = unsafe { &1 as *const i32 == &2 as *const i32 };\n-   |                                           ^^ no implementation for `*const i32 == _`\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the trait `~const PartialEq<_>` is not implemented for `*const i32`\n-note: the trait `PartialEq<_>` is implemented for `*const i32`, but that implementation is not `const`\n-  --> $DIR/const_raw_ptr_ops.rs:4:43\n-   |\n-LL | const X: bool = unsafe { &1 as *const i32 == &2 as *const i32 };\n-   |                                           ^^\n+   = note: see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n \n-error[E0277]: can't compare `*const i32` with `_` in const contexts\n-  --> $DIR/const_raw_ptr_ops.rs:6:44\n+error: pointers cannot be reliably compared during const eval\n+  --> $DIR/const_raw_ptr_ops.rs:6:27\n    |\n LL | const X2: bool = unsafe { 42 as *const i32 == 43 as *const i32 };\n-   |                                            ^^ no implementation for `*const i32 == _`\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the trait `~const PartialEq<_>` is not implemented for `*const i32`\n-note: the trait `PartialEq<_>` is implemented for `*const i32`, but that implementation is not `const`\n-  --> $DIR/const_raw_ptr_ops.rs:6:44\n-   |\n-LL | const X2: bool = unsafe { 42 as *const i32 == 43 as *const i32 };\n-   |                                            ^^\n+   = note: see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "ebc5543b380a542ceeb8b30071962661fb83ded4", "filename": "tests/ui/consts/const-eval/ub-slice-get-unchecked.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-slice-get-unchecked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-slice-get-unchecked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-slice-get-unchecked.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,3 +1,5 @@\n+// known-bug: #110395\n+\n #![feature(const_slice_index)]\n \n const A: [(); 5] = [(), (), (), (), ()];"}, {"sha": "403fb5e09404d99b3f8cbb70747cb54a93685621", "filename": "tests/ui/consts/const-eval/ub-slice-get-unchecked.stderr", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-slice-get-unchecked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-slice-get-unchecked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-slice-get-unchecked.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,18 +1,11 @@\n-error[E0080]: evaluation of constant value failed\n-  --> $SRC_DIR/core/src/slice/index.rs:LL:COL\n-   |\n-   = note: overflow executing `unchecked_sub`\n-   |\n-note: inside `<std::ops::Range<usize> as SliceIndex<[()]>>::get_unchecked`\n-  --> $SRC_DIR/core/src/slice/index.rs:LL:COL\n-note: inside `core::slice::<impl [()]>::get_unchecked::<std::ops::Range<usize>>`\n-  --> $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-note: inside `B`\n-  --> $DIR/ub-slice-get-unchecked.rs:7:27\n+error[E0015]: cannot call non-const fn `core::slice::<impl [()]>::get_unchecked::<std::ops::Range<usize>>` in constants\n+  --> $DIR/ub-slice-get-unchecked.rs:9:29\n    |\n LL | const B: &[()] = unsafe { A.get_unchecked(3..1) };\n-   |                           ^^^^^^^^^^^^^^^^^^^^^\n+   |                             ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0080`.\n+For more information about this error, try `rustc --explain E0015`."}, {"sha": "3a5d5bb46e912049db656af29af311be7c46de3c", "filename": "tests/ui/consts/const-float-classify.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-float-classify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-float-classify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-float-classify.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -8,11 +8,33 @@\n // Don't promote\n const fn nop<T>(x: T) -> T { x }\n \n+// FIXME(const-hack): replace with PartialEq\n+#[const_trait]\n+trait MyEq<T> {\n+    fn eq(self, b: T) -> bool;\n+}\n+\n+impl const MyEq<bool> for bool {\n+    fn eq(self, b: bool) -> bool {\n+        self == b\n+    }\n+}\n+\n+impl const MyEq<NonDet> for bool {\n+    fn eq(self, _: NonDet) -> bool {\n+        true\n+    }\n+}\n+\n+const fn eq<A: ~const MyEq<B>, B>(x: A, y: B) -> bool {\n+    x.eq(y)\n+}\n+\n macro_rules! const_assert {\n     ($a:expr, $b:expr) => {\n         {\n-            const _: () = assert!($a == $b);\n-            assert_eq!(nop($a), nop($b));\n+            const _: () = assert!(eq($a, $b));\n+            assert!(eq(nop($a), nop($b)));\n         }\n     };\n }\n@@ -47,15 +69,6 @@ macro_rules! suite_inner {\n #[derive(Debug)]\n struct NonDet;\n \n-impl const PartialEq<NonDet> for bool {\n-    fn eq(&self, _: &NonDet) -> bool {\n-        true\n-    }\n-    fn ne(&self, _: &NonDet) -> bool {\n-        false\n-    }\n-}\n-\n // The result of the `is_sign` methods are not checked for correctness, since LLVM does not\n // guarantee anything about the signedness of NaNs. See\n // https://github.com/rust-lang/rust/issues/55131."}, {"sha": "50b7ce1f8c01db3c869fb447dba119458f8a3f86", "filename": "tests/ui/consts/const-fn-error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-fn-error.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -7,7 +7,6 @@ const fn f(x: usize) -> usize {\n         //~| ERROR `for` is not allowed in a `const fn`\n         //~| ERROR mutable references are not allowed in constant functions\n         //~| ERROR cannot call non-const fn\n-        //~| ERROR the trait bound\n         sum += i;\n     }\n     sum"}, {"sha": "f735b3d53ce43202b6b00c0a48b0769287e7d511", "filename": "tests/ui/consts/const-fn-error.stderr", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-fn-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-fn-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-fn-error.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -5,7 +5,7 @@ LL | /     for i in 0..x {\n LL | |\n LL | |\n LL | |\n-...  |\n+LL | |\n LL | |         sum += i;\n LL | |     }\n    | |_____^\n@@ -33,19 +33,6 @@ LL |     for i in 0..x {\n    = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n    = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n-error[E0277]: the trait bound `std::ops::Range<usize>: Iterator` is not satisfied\n-  --> $DIR/const-fn-error.rs:5:14\n-   |\n-LL |     for i in 0..x {\n-   |              ^^^^ `std::ops::Range<usize>` is not an iterator\n-   |\n-   = help: the trait `~const Iterator` is not implemented for `std::ops::Range<usize>`\n-note: the trait `Iterator` is implemented for `std::ops::Range<usize>`, but that implementation is not `const`\n-  --> $DIR/const-fn-error.rs:5:14\n-   |\n-LL |     for i in 0..x {\n-   |              ^^^^\n-\n error[E0015]: cannot call non-const fn `<std::ops::Range<usize> as Iterator>::next` in constant functions\n   --> $DIR/const-fn-error.rs:5:14\n    |\n@@ -55,7 +42,7 @@ LL |     for i in 0..x {\n    = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n    = help: add `#![feature(const_trait_impl)]` to the crate attributes to enable\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0015, E0277, E0658.\n+Some errors have detailed explanations: E0015, E0658.\n For more information about an error, try `rustc --explain E0015`."}, {"sha": "8db2485355833d3b58313271859f15afbc05c843", "filename": "tests/ui/consts/const-for.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-for.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -5,7 +5,6 @@ const _: () = {\n     for _ in 0..5 {}\n     //~^ error: cannot call\n     //~| error: cannot convert\n-    //~| error: the trait bound\n };\n \n fn main() {}"}, {"sha": "3fb9787c0d868455fe8d88840560ee407d8cec19", "filename": "tests/ui/consts/const-for.stderr", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-for.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-for.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-for.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -9,19 +9,6 @@ note: impl defined here, but it is not `const`\n    = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n    = help: add `#![feature(const_trait_impl)]` to the crate attributes to enable\n \n-error[E0277]: the trait bound `std::ops::Range<i32>: Iterator` is not satisfied\n-  --> $DIR/const-for.rs:5:14\n-   |\n-LL |     for _ in 0..5 {}\n-   |              ^^^^ `std::ops::Range<i32>` is not an iterator\n-   |\n-   = help: the trait `~const Iterator` is not implemented for `std::ops::Range<i32>`\n-note: the trait `Iterator` is implemented for `std::ops::Range<i32>`, but that implementation is not `const`\n-  --> $DIR/const-for.rs:5:14\n-   |\n-LL |     for _ in 0..5 {}\n-   |              ^^^^\n-\n error[E0015]: cannot call non-const fn `<std::ops::Range<i32> as Iterator>::next` in constants\n   --> $DIR/const-for.rs:5:14\n    |\n@@ -31,7 +18,6 @@ LL |     for _ in 0..5 {}\n    = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n    = help: add `#![feature(const_trait_impl)]` to the crate attributes to enable\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0015, E0277.\n-For more information about an error, try `rustc --explain E0015`.\n+For more information about this error, try `rustc --explain E0015`."}, {"sha": "6b7ba8f1e32b40beceb2e71f1f6954fbd5602f04", "filename": "tests/ui/consts/const-try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-try.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// known-bug: #110395\n \n // Demonstrates what's needed to make use of `?` in const contexts.\n "}, {"sha": "37014f9b83f69fb61a264d260a2b2e8fdad638fc", "filename": "tests/ui/consts/const-try.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-try.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst-try.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-try.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,20 @@\n+error: const `impl` for trait `FromResidual` which is not marked with `#[const_trait]`\n+  --> $DIR/const-try.rs:15:12\n+   |\n+LL | impl const FromResidual<Error> for TryMe {\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+\n+error: const `impl` for trait `Try` which is not marked with `#[const_trait]`\n+  --> $DIR/const-try.rs:21:12\n+   |\n+LL | impl const Try for TryMe {\n+   |            ^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "19cee2022ac079832c76d49cf5367966e01f759b", "filename": "tests/ui/consts/const_cmp_type_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst_cmp_type_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst_cmp_type_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst_cmp_type_id.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// run-pass\n+// known-bug: #110395\n #![feature(const_type_id)]\n #![feature(const_trait_impl)]\n "}, {"sha": "319d2b924a88ca11966c4dca7bbeb1a7ee740423", "filename": "tests/ui/consts/const_cmp_type_id.stderr", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst_cmp_type_id.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fconst_cmp_type_id.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst_cmp_type_id.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,76 @@\n+error[E0277]: can't compare `TypeId` with `TypeId` in const contexts\n+  --> $DIR/const_cmp_type_id.rs:8:13\n+   |\n+LL |     assert!(TypeId::of::<u8>() == TypeId::of::<u8>());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `TypeId == TypeId`\n+   |\n+   = help: the trait `~const PartialEq` is not implemented for `TypeId`\n+note: the trait `PartialEq` is implemented for `TypeId`, but that implementation is not `const`\n+  --> $DIR/const_cmp_type_id.rs:8:13\n+   |\n+LL |     assert!(TypeId::of::<u8>() == TypeId::of::<u8>());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0015]: cannot call non-const operator in constant functions\n+  --> $DIR/const_cmp_type_id.rs:8:13\n+   |\n+LL |     assert!(TypeId::of::<u8>() == TypeId::of::<u8>());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/core/src/any.rs:LL:COL\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `TypeId` with `TypeId` in const contexts\n+  --> $DIR/const_cmp_type_id.rs:9:13\n+   |\n+LL |     assert!(TypeId::of::<()>() != TypeId::of::<u8>());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `TypeId == TypeId`\n+   |\n+   = help: the trait `~const PartialEq` is not implemented for `TypeId`\n+note: the trait `PartialEq` is implemented for `TypeId`, but that implementation is not `const`\n+  --> $DIR/const_cmp_type_id.rs:9:13\n+   |\n+LL |     assert!(TypeId::of::<()>() != TypeId::of::<u8>());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0015]: cannot call non-const operator in constant functions\n+  --> $DIR/const_cmp_type_id.rs:9:13\n+   |\n+LL |     assert!(TypeId::of::<()>() != TypeId::of::<u8>());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/core/src/any.rs:LL:COL\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `TypeId` with `TypeId` in const contexts\n+  --> $DIR/const_cmp_type_id.rs:10:22\n+   |\n+LL |     const _A: bool = TypeId::of::<u8>() < TypeId::of::<u16>();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `TypeId < TypeId` and `TypeId > TypeId`\n+   |\n+   = help: the trait `~const PartialOrd` is not implemented for `TypeId`\n+note: the trait `PartialOrd` is implemented for `TypeId`, but that implementation is not `const`\n+  --> $DIR/const_cmp_type_id.rs:10:22\n+   |\n+LL |     const _A: bool = TypeId::of::<u8>() < TypeId::of::<u16>();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0015]: cannot call non-const operator in constants\n+  --> $DIR/const_cmp_type_id.rs:10:22\n+   |\n+LL |     const _A: bool = TypeId::of::<u8>() < TypeId::of::<u16>();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/core/src/any.rs:LL:COL\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the derive macro `PartialOrd` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "be11ac7264a1ab867d50a9c3b4915708008f50dc", "filename": "tests/ui/consts/fn_trait_refs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Ffn_trait_refs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Ffn_trait_refs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Ffn_trait_refs.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// known-bug: #110395\n \n #![feature(const_fn_trait_ref_impls)]\n #![feature(fn_traits)]"}, {"sha": "bfebf66701bd9c05aaf146993c7da729590bf0e7", "filename": "tests/ui/consts/fn_trait_refs.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Ffn_trait_refs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Ffn_trait_refs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Ffn_trait_refs.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,15 @@\n+error[E0635]: unknown feature `const_fn_trait_ref_impls`\n+  --> $DIR/fn_trait_refs.rs:3:12\n+   |\n+LL | #![feature(const_fn_trait_ref_impls)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0635]: unknown feature `const_cmp`\n+  --> $DIR/fn_trait_refs.rs:8:12\n+   |\n+LL | #![feature(const_cmp)]\n+   |            ^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0635`."}, {"sha": "f5ed5aeedc39c238cae98a9d3bb53bc2c196ab99", "filename": "tests/ui/consts/issue-25826.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fissue-25826.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fissue-25826.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-25826.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,6 +1,6 @@\n fn id<T>(t: T) -> T { t }\n fn main() {\n     const A: bool = unsafe { id::<u8> as *const () < id::<u16> as *const () };\n-    //~^ ERROR can't compare\n+    //~^ ERROR pointers cannot\n     println!(\"{}\", A);\n }"}, {"sha": "780edd2149fe102ce3ed1fd78264ecf77f247b4c", "filename": "tests/ui/consts/issue-25826.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fissue-25826.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fissue-25826.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-25826.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,16 +1,10 @@\n-error[E0277]: can't compare `*const ()` with `*const ()` in const contexts\n-  --> $DIR/issue-25826.rs:3:52\n+error: pointers cannot be reliably compared during const eval\n+  --> $DIR/issue-25826.rs:3:30\n    |\n LL |     const A: bool = unsafe { id::<u8> as *const () < id::<u16> as *const () };\n-   |                                                    ^ no implementation for `*const () < *const ()` and `*const () > *const ()`\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: the trait `~const PartialOrd` is not implemented for `*const ()`\n-note: the trait `PartialOrd` is implemented for `*const ()`, but that implementation is not `const`\n-  --> $DIR/issue-25826.rs:3:52\n-   |\n-LL |     const A: bool = unsafe { id::<u8> as *const () < id::<u16> as *const () };\n-   |                                                    ^\n+   = note: see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "a3b9510036d0fd859427ee8c99cfcc4d8e257739", "filename": "tests/ui/consts/issue-73976-monomorphic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fissue-73976-monomorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fissue-73976-monomorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-73976-monomorphic.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// known-bug: #110395\n //\n // This test is complement to the test in issue-73976-polymorphic.rs.\n // In that test we ensure that polymorphic use of type_id and type_name in patterns"}, {"sha": "95ab78b1b23b35f85f51c345c642d30c95eb85e6", "filename": "tests/ui/consts/issue-73976-monomorphic.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fissue-73976-monomorphic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fissue-73976-monomorphic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-73976-monomorphic.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,28 @@\n+error[E0277]: can't compare `TypeId` with `TypeId` in const contexts\n+  --> $DIR/issue-73976-monomorphic.rs:21:5\n+   |\n+LL |     GetTypeId::<T>::VALUE == GetTypeId::<usize>::VALUE\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `TypeId == TypeId`\n+   |\n+   = help: the trait `~const PartialEq` is not implemented for `TypeId`\n+note: the trait `PartialEq` is implemented for `TypeId`, but that implementation is not `const`\n+  --> $DIR/issue-73976-monomorphic.rs:21:5\n+   |\n+LL |     GetTypeId::<T>::VALUE == GetTypeId::<usize>::VALUE\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0015]: cannot call non-const operator in constant functions\n+  --> $DIR/issue-73976-monomorphic.rs:21:5\n+   |\n+LL |     GetTypeId::<T>::VALUE == GetTypeId::<usize>::VALUE\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/core/src/any.rs:LL:COL\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "38c8129b8cfd918d0302fb9f95d51931400caf28", "filename": "tests/ui/consts/issue-94675.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fissue-94675.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fissue-94675.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-94675.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -7,8 +7,9 @@ struct Foo<'a> {\n impl<'a> Foo<'a> {\n     const fn spam(&mut self, baz: &mut Vec<u32>) {\n         self.bar[0] = baz.len();\n-        //~^ the trait bound `Vec<usize>: ~const Index<_>` is not satisfied\n-        //~| the trait bound `Vec<usize>: ~const IndexMut<usize>` is not satisfied\n+        //~^ ERROR: cannot call\n+        //~| ERROR: cannot call\n+        //~| ERROR: the trait bound\n     }\n }\n "}, {"sha": "b4e5db44e7105847789fe3f65bb133848d241c48", "filename": "tests/ui/consts/issue-94675.stderr", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fissue-94675.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fissue-94675.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-94675.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,15 +1,10 @@\n-error[E0277]: the trait bound `Vec<usize>: ~const Index<_>` is not satisfied\n-  --> $DIR/issue-94675.rs:9:9\n+error[E0015]: cannot call non-const fn `Vec::<u32>::len` in constant functions\n+  --> $DIR/issue-94675.rs:9:27\n    |\n LL |         self.bar[0] = baz.len();\n-   |         ^^^^^^^^^^^ vector indices are of type `usize` or ranges of `usize`\n-   |\n-   = help: the trait `~const Index<_>` is not implemented for `Vec<usize>`\n-note: the trait `Index<_>` is implemented for `Vec<usize>`, but that implementation is not `const`\n-  --> $DIR/issue-94675.rs:9:9\n+   |                           ^^^^^\n    |\n-LL |         self.bar[0] = baz.len();\n-   |         ^^^^^^^^^^^\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error[E0277]: the trait bound `Vec<usize>: ~const IndexMut<usize>` is not satisfied\n   --> $DIR/issue-94675.rs:9:9\n@@ -24,6 +19,17 @@ note: the trait `IndexMut<usize>` is implemented for `Vec<usize>`, but that impl\n LL |         self.bar[0] = baz.len();\n    |         ^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error[E0015]: cannot call non-const operator in constant functions\n+  --> $DIR/issue-94675.rs:9:9\n+   |\n+LL |         self.bar[0] = baz.len();\n+   |         ^^^^^^^^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "c5990a7f5155f402769a0d48282c90d3791ded04", "filename": "tests/ui/consts/min_const_fn/cmp_fn_pointers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fmin_const_fn%2Fcmp_fn_pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fmin_const_fn%2Fcmp_fn_pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fmin_const_fn%2Fcmp_fn_pointers.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,6 +1,6 @@\n const fn cmp(x: fn(), y: fn()) -> bool {\n     unsafe { x == y }\n-    //~^ ERROR can't compare\n+    //~^ ERROR pointers cannot\n }\n \n fn main() {}"}, {"sha": "3845068d8411c652cfca567167c846d75d0d4a4d", "filename": "tests/ui/consts/min_const_fn/cmp_fn_pointers.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fmin_const_fn%2Fcmp_fn_pointers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fmin_const_fn%2Fcmp_fn_pointers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fmin_const_fn%2Fcmp_fn_pointers.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,16 +1,10 @@\n-error[E0277]: can't compare `fn()` with `_` in const contexts\n-  --> $DIR/cmp_fn_pointers.rs:2:16\n+error: pointers cannot be reliably compared during const eval\n+  --> $DIR/cmp_fn_pointers.rs:2:14\n    |\n LL |     unsafe { x == y }\n-   |                ^^ no implementation for `fn() == _`\n+   |              ^^^^^^\n    |\n-   = help: the trait `~const PartialEq<_>` is not implemented for `fn()`\n-note: the trait `PartialEq<_>` is implemented for `fn()`, but that implementation is not `const`\n-  --> $DIR/cmp_fn_pointers.rs:2:16\n-   |\n-LL |     unsafe { x == y }\n-   |                ^^\n+   = note: see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "dae6cafaebb34bd0a298f4676bf011412c6a615e", "filename": "tests/ui/consts/promoted_const_call.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fpromoted_const_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fpromoted_const_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fpromoted_const_call.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,7 +1,9 @@\n #![feature(const_mut_refs)]\n #![feature(const_trait_impl)]\n+\n struct Panic;\n impl const Drop for Panic { fn drop(&mut self) { panic!(); } }\n+\n pub const fn id<T>(x: T) -> T { x }\n pub const C: () = {\n     let _: &'static _ = &id(&Panic);"}, {"sha": "1cbd8cbe6999c855db0f22a8a69538b8839f549a", "filename": "tests/ui/consts/promoted_const_call.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fpromoted_const_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Fpromoted_const_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fpromoted_const_call.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,5 +1,5 @@\n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/promoted_const_call.rs:7:26\n+  --> $DIR/promoted_const_call.rs:9:26\n    |\n LL |     let _: &'static _ = &id(&Panic);\n    |            ----------    ^^^^^^^^^^ creates a temporary value which is freed while still in use\n@@ -10,7 +10,7 @@ LL | };\n    | - temporary value is freed at the end of this statement\n \n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/promoted_const_call.rs:7:30\n+  --> $DIR/promoted_const_call.rs:9:30\n    |\n LL |     let _: &'static _ = &id(&Panic);\n    |            ----------        ^^^^^ - temporary value is freed at the end of this statement\n@@ -19,7 +19,7 @@ LL |     let _: &'static _ = &id(&Panic);\n    |            type annotation requires that borrow lasts for `'static`\n \n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/promoted_const_call.rs:13:26\n+  --> $DIR/promoted_const_call.rs:15:26\n    |\n LL |     let _: &'static _ = &id(&Panic);\n    |            ----------    ^^^^^^^^^^ creates a temporary value which is freed while still in use\n@@ -30,7 +30,7 @@ LL | }\n    | - temporary value is freed at the end of this statement\n \n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/promoted_const_call.rs:13:30\n+  --> $DIR/promoted_const_call.rs:15:30\n    |\n LL |     let _: &'static _ = &id(&Panic);\n    |            ----------        ^^^^^ - temporary value is freed at the end of this statement\n@@ -39,7 +39,7 @@ LL |     let _: &'static _ = &id(&Panic);\n    |            type annotation requires that borrow lasts for `'static`\n \n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/promoted_const_call.rs:16:26\n+  --> $DIR/promoted_const_call.rs:18:26\n    |\n LL |     let _: &'static _ = &&(Panic, 0).1;\n    |            ----------    ^^^^^^^^^^^^^ creates a temporary value which is freed while still in use\n@@ -50,7 +50,7 @@ LL | }\n    | - temporary value is freed at the end of this statement\n \n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/promoted_const_call.rs:16:27\n+  --> $DIR/promoted_const_call.rs:18:27\n    |\n LL |     let _: &'static _ = &&(Panic, 0).1;\n    |            ----------     ^^^^^^^^^^ creates a temporary value which is freed while still in use"}, {"sha": "a1a741e80e55e713a89d35330882357a81695aab", "filename": "tests/ui/consts/rustc-impl-const-stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Frustc-impl-const-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Frustc-impl-const-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Frustc-impl-const-stability.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// known-bug: #110395\n \n #![crate_type = \"lib\"]\n #![feature(staged_api)]"}, {"sha": "e6930da71ec7810c3b61abf6aefbc1e14c7bfba0", "filename": "tests/ui/consts/rustc-impl-const-stability.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Frustc-impl-const-stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Frustc-impl-const-stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Frustc-impl-const-stability.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,11 @@\n+error: const `impl` for trait `Default` which is not marked with `#[const_trait]`\n+  --> $DIR/rustc-impl-const-stability.rs:15:12\n+   |\n+LL | impl const Default for Data {\n+   |            ^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+\n+error: aborting due to previous error\n+"}, {"sha": "ed69f492fb969a3408b2beff852e67a7e76076a9", "filename": "tests/ui/consts/try-operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Ftry-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Ftry-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Ftry-operator.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// run-pass\n+// known-bug: #110395\n \n #![feature(try_trait_v2)]\n #![feature(const_trait_impl)]"}, {"sha": "f6a651c5e663c2be2c0151454c0e8a9fcd0d5bcd", "filename": "tests/ui/consts/try-operator.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Ftry-operator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fconsts%2Ftry-operator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Ftry-operator.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,9 @@\n+error[E0635]: unknown feature `const_convert`\n+  --> $DIR/try-operator.rs:6:12\n+   |\n+LL | #![feature(const_convert)]\n+   |            ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0635`."}, {"sha": "26986684f0c0a0a2d19f5df67e1b528b6957f532", "filename": "tests/ui/did_you_mean/issue-49746-unicode-confusable-in-float-literal-expt.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fdid_you_mean%2Fissue-49746-unicode-confusable-in-float-literal-expt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fdid_you_mean%2Fissue-49746-unicode-confusable-in-float-literal-expt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fissue-49746-unicode-confusable-in-float-literal-expt.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -15,13 +15,13 @@ help: Unicode character '\u2212' (Minus Sign) looks like '-' (Minus/Hyphen), but it\n LL | const UNIVERSAL_GRAVITATIONAL_CONSTANT: f64 = 6.674e-11; // m\u00b3\u22c5kg\u207b\u00b9\u22c5s\u207b\u00b2\n    |                                                     ~\n \n-error[E0277]: cannot subtract `{integer}` from `{float}` in const contexts\n+error[E0277]: cannot subtract `{integer}` from `{float}`\n   --> $DIR/issue-49746-unicode-confusable-in-float-literal-expt.rs:1:53\n    |\n LL | const UNIVERSAL_GRAVITATIONAL_CONSTANT: f64 = 6.674e\u221211; // m\u00b3\u22c5kg\u207b\u00b9\u22c5s\u207b\u00b2\n    |                                                     ^ no implementation for `{float} - {integer}`\n    |\n-   = help: the trait `~const Sub<{integer}>` is not implemented for `{float}`\n+   = help: the trait `Sub<{integer}>` is not implemented for `{float}`\n    = help: the following other types implement trait `Sub<Rhs>`:\n              <&'a f32 as Sub<f32>>\n              <&'a f64 as Sub<f64>>"}, {"sha": "85e12463a903dca4f9964557282053d8174332e8", "filename": "tests/ui/issues/issue-25901.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fissues%2Fissue-25901.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fissues%2Fissue-25901.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-25901.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -2,7 +2,7 @@ struct A;\n struct B;\n \n static S: &'static B = &A;\n-//~^ ERROR the trait bound\n+//~^ ERROR cannot perform deref coercion\n \n use std::ops::Deref;\n "}, {"sha": "1427e43854f57de283f4dc807f0bcbdc66788f36", "filename": "tests/ui/issues/issue-25901.stderr", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fissues%2Fissue-25901.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fissues%2Fissue-25901.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-25901.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,15 +1,24 @@\n-error[E0277]: the trait bound `A: Deref` is not satisfied\n+error[E0015]: cannot perform deref coercion on `A` in statics\n   --> $DIR/issue-25901.rs:4:24\n    |\n LL | static S: &'static B = &A;\n-   |                        ^^ the trait `~const Deref` is not implemented for `A`\n+   |                        ^^\n    |\n-note: the trait `Deref` is implemented for `A`, but that implementation is not `const`\n-  --> $DIR/issue-25901.rs:4:24\n+   = note: attempting to deref into `B`\n+note: deref defined here\n+  --> $DIR/issue-25901.rs:10:5\n    |\n-LL | static S: &'static B = &A;\n-   |                        ^^\n+LL |     type Target = B;\n+   |     ^^^^^^^^^^^\n+note: impl defined here, but it is not `const`\n+  --> $DIR/issue-25901.rs:9:1\n+   |\n+LL | impl Deref for A {\n+   | ^^^^^^^^^^^^^^^^\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n+   = help: add `#![feature(const_trait_impl)]` to the crate attributes to enable\n+   = note: consider wrapping this expression in `Lazy::new(|| ...)` from the `once_cell` crate: https://crates.io/crates/once_cell\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0015`."}, {"sha": "3d527eb6b4e4a56ec09a7536af60d3cf364bda5b", "filename": "tests/ui/issues/issue-50582.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fissues%2Fissue-50582.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fissues%2Fissue-50582.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-50582.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -7,13 +7,13 @@ LL |     Vec::<[(); 1 + for x in 0..1 {}]>::new();\n    = note: see issue #87575 <https://github.com/rust-lang/rust/issues/87575> for more information\n    = help: add `#![feature(const_for)]` to the crate attributes to enable\n \n-error[E0277]: cannot add `()` to `{integer}` in const contexts\n+error[E0277]: cannot add `()` to `{integer}`\n   --> $DIR/issue-50582.rs:2:18\n    |\n LL |     Vec::<[(); 1 + for x in 0..1 {}]>::new();\n    |                  ^ no implementation for `{integer} + ()`\n    |\n-   = help: the trait `~const Add<()>` is not implemented for `{integer}`\n+   = help: the trait `Add<()>` is not implemented for `{integer}`\n    = help: the following other types implement trait `Add<Rhs>`:\n              <&'a f32 as Add<f32>>\n              <&'a f64 as Add<f64>>"}, {"sha": "0498a8a16259010501a0387c4bcfb61a2e839a74", "filename": "tests/ui/never_type/issue-52443.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fnever_type%2Fissue-52443.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fnever_type%2Fissue-52443.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_type%2Fissue-52443.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -11,5 +11,4 @@ fn main() {\n     //~| ERROR cannot convert\n     //~| ERROR mutable references\n     //~| ERROR cannot call\n-    //~| ERROR the trait bound\n }"}, {"sha": "99dfce869034323b3549a951d8f345b2f0f04179", "filename": "tests/ui/never_type/issue-52443.stderr", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fnever_type%2Fissue-52443.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fnever_type%2Fissue-52443.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_type%2Fissue-52443.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -58,19 +58,6 @@ LL |     [(); { for _ in 0usize.. {}; 0}];\n    = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n    = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n-error[E0277]: the trait bound `RangeFrom<usize>: Iterator` is not satisfied\n-  --> $DIR/issue-52443.rs:9:21\n-   |\n-LL |     [(); { for _ in 0usize.. {}; 0}];\n-   |                     ^^^^^^^^ `RangeFrom<usize>` is not an iterator\n-   |\n-   = help: the trait `~const Iterator` is not implemented for `RangeFrom<usize>`\n-note: the trait `Iterator` is implemented for `RangeFrom<usize>`, but that implementation is not `const`\n-  --> $DIR/issue-52443.rs:9:21\n-   |\n-LL |     [(); { for _ in 0usize.. {}; 0}];\n-   |                     ^^^^^^^^\n-\n error[E0015]: cannot call non-const fn `<RangeFrom<usize> as Iterator>::next` in constants\n   --> $DIR/issue-52443.rs:9:21\n    |\n@@ -80,7 +67,7 @@ LL |     [(); { for _ in 0usize.. {}; 0}];\n    = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n    = help: add `#![feature(const_trait_impl)]` to the crate attributes to enable\n \n-error: aborting due to 7 previous errors; 1 warning emitted\n+error: aborting due to 6 previous errors; 1 warning emitted\n \n-Some errors have detailed explanations: E0015, E0277, E0308, E0658.\n+Some errors have detailed explanations: E0015, E0308, E0658.\n For more information about an error, try `rustc --explain E0015`."}, {"sha": "96790a87311dd2127e780c804973dca01bd6d850", "filename": "tests/ui/rfc-2632-const-trait-impl/assoc-type.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,3 +1,5 @@\n+// known-bug: #110395\n+\n #![feature(const_trait_impl)]\n \n struct NonConstAdd(i32);\n@@ -17,7 +19,6 @@ trait Foo {\n \n impl const Foo for NonConstAdd {\n     type Bar = NonConstAdd;\n-    //~^ ERROR: cannot add `NonConstAdd` to `NonConstAdd` in const contexts\n }\n \n #[const_trait]"}, {"sha": "0cffae1da8d97510c4afbc489a2bdbf5a4f8fe6d", "filename": "tests/ui/rfc-2632-const-trait-impl/assoc-type.stderr", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,21 +1,8 @@\n-error[E0277]: cannot add `NonConstAdd` to `NonConstAdd` in const contexts\n-  --> $DIR/assoc-type.rs:19:16\n-   |\n-LL |     type Bar = NonConstAdd;\n-   |                ^^^^^^^^^^^ no implementation for `NonConstAdd + NonConstAdd`\n-   |\n-   = help: the trait `~const Add` is not implemented for `NonConstAdd`\n-note: the trait `Add` is implemented for `NonConstAdd`, but that implementation is not `const`\n-  --> $DIR/assoc-type.rs:19:16\n-   |\n-LL |     type Bar = NonConstAdd;\n-   |                ^^^^^^^^^^^\n-note: required by a bound in `Foo::Bar`\n-  --> $DIR/assoc-type.rs:15:15\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/assoc-type.rs:17:22\n    |\n LL |     type Bar: ~const std::ops::Add;\n-   |               ^^^^^^^^^^^^^^^^^^^^ required by this bound in `Foo::Bar`\n+   |                      ^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "ae0c2e6bcfa413620339acd759423a83d51b70c3", "filename": "tests/ui/rfc-2632-const-trait-impl/call-const-trait-method-pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-pass.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// run-pass\n+// known-bug: #110395\n \n #![feature(const_trait_impl)]\n "}, {"sha": "ff53eea1110c00027be6736e9c107fd620825a5d", "filename": "tests/ui/rfc-2632-const-trait-impl/call-const-trait-method-pass.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-pass.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-pass.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-pass.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,20 @@\n+error: const `impl` for trait `Add` which is not marked with `#[const_trait]`\n+  --> $DIR/call-const-trait-method-pass.rs:7:12\n+   |\n+LL | impl const std::ops::Add for Int {\n+   |            ^^^^^^^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+\n+error: const `impl` for trait `PartialEq` which is not marked with `#[const_trait]`\n+  --> $DIR/call-const-trait-method-pass.rs:15:12\n+   |\n+LL | impl const PartialEq for Int {\n+   |            ^^^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "5120e6bfb41178cbcff34161a715f0af39f966fa", "filename": "tests/ui/rfc-2632-const-trait-impl/call-generic-in-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-in-impl.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// known-bug: #110395\n #![feature(const_trait_impl)]\n \n #[const_trait]"}, {"sha": "02d53cc78ee56974e8e64b6818ec9934bf363cd5", "filename": "tests/ui/rfc-2632-const-trait-impl/call-generic-in-impl.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-in-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-in-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-in-impl.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,8 @@\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/call-generic-in-impl.rs:9:16\n+   |\n+LL | impl<T: ~const PartialEq> const MyPartialEq for T {\n+   |                ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "3febb328a83ca02600b7bfcbb06e8a7597190e86", "filename": "tests/ui/rfc-2632-const-trait-impl/call-generic-method-chain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-chain.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,6 +1,6 @@\n //! Basic test for calling methods on generic type parameters in `const fn`.\n \n-// check-pass\n+// known-bug: #110395\n \n #![feature(const_trait_impl)]\n "}, {"sha": "529a472e0bda5260c47577391bef8456024950ce", "filename": "tests/ui/rfc-2632-const-trait-impl/call-generic-method-chain.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-chain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-chain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-chain.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,23 @@\n+error: const `impl` for trait `PartialEq` which is not marked with `#[const_trait]`\n+  --> $DIR/call-generic-method-chain.rs:9:12\n+   |\n+LL | impl const PartialEq for S {\n+   |            ^^^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/call-generic-method-chain.rs:18:32\n+   |\n+LL | const fn equals_self<T: ~const PartialEq>(t: &T) -> bool {\n+   |                                ^^^^^^^^^\n+\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/call-generic-method-chain.rs:22:40\n+   |\n+LL | const fn equals_self_wrapper<T: ~const PartialEq>(t: &T) -> bool {\n+   |                                        ^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "e618160d3b6f0a01205f03f66cbefd9e00992241", "filename": "tests/ui/rfc-2632-const-trait-impl/call-generic-method-dup-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-dup-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-dup-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-dup-bound.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// known-bug: #110395\n \n #![feature(const_trait_impl)]\n "}, {"sha": "bdc6ccc8aec233e3c8ec00a9d2bf41e8d2b4a847", "filename": "tests/ui/rfc-2632-const-trait-impl/call-generic-method-dup-bound.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-dup-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-dup-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-dup-bound.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,23 @@\n+error: const `impl` for trait `PartialEq` which is not marked with `#[const_trait]`\n+  --> $DIR/call-generic-method-dup-bound.rs:7:12\n+   |\n+LL | impl const PartialEq for S {\n+   |            ^^^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/call-generic-method-dup-bound.rs:18:44\n+   |\n+LL | const fn equals_self<T: PartialEq + ~const PartialEq>(t: &T) -> bool {\n+   |                                            ^^^^^^^^^\n+\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/call-generic-method-dup-bound.rs:25:37\n+   |\n+LL | const fn equals_self2<T: A + ~const PartialEq>(t: &T) -> bool {\n+   |                                     ^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "fe1abbf42071577852c752bfbe030538f187d58b", "filename": "tests/ui/rfc-2632-const-trait-impl/call-generic-method-fail.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,8 +1,9 @@\n+// known-bug: #110395\n #![feature(const_trait_impl)]\n \n pub const fn equals_self<T: PartialEq>(t: &T) -> bool {\n     *t == *t\n-    //~^ ERROR can't compare\n+    // (remove this) ~^ ERROR can't compare\n }\n \n fn main() {}"}, {"sha": "3963f64ad32b3b90b59cb9f2b9ae9b7588012b38", "filename": "tests/ui/rfc-2632-const-trait-impl/call-generic-method-fail.stderr", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,15 +1,28 @@\n-error[E0277]: can't compare `T` with `_` in const contexts\n-  --> $DIR/call-generic-method-fail.rs:4:8\n+error[E0277]: can't compare `T` with `T` in const contexts\n+  --> $DIR/call-generic-method-fail.rs:5:5\n    |\n LL |     *t == *t\n-   |        ^^ no implementation for `T == _`\n+   |     ^^^^^^^^ no implementation for `T == T`\n    |\n-note: the trait `PartialEq<_>` is implemented for `T`, but that implementation is not `const`\n-  --> $DIR/call-generic-method-fail.rs:4:8\n+note: the trait `PartialEq` is implemented for `T`, but that implementation is not `const`\n+  --> $DIR/call-generic-method-fail.rs:5:5\n    |\n LL |     *t == *t\n-   |        ^^\n+   |     ^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0015]: cannot call non-const operator in constant functions\n+  --> $DIR/call-generic-method-fail.rs:5:5\n+   |\n+LL |     *t == *t\n+   |     ^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+help: consider further restricting this bound\n+   |\n+LL | pub const fn equals_self<T: PartialEq + ~const std::cmp::PartialEq>(t: &T) -> bool {\n+   |                                       ++++++++++++++++++++++++++++\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "09f35a277371e2c4d3a60224f05824917e6c6932", "filename": "tests/ui/rfc-2632-const-trait-impl/call-generic-method-pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-pass.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,6 +1,6 @@\n //! Basic test for calling methods on generic type parameters in `const fn`.\n \n-// check-pass\n+// known-bug: #110395\n \n #![feature(const_trait_impl)]\n "}, {"sha": "7fbe89dba3cb37162598f73fef2c605a4be64aa7", "filename": "tests/ui/rfc-2632-const-trait-impl/call-generic-method-pass.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-pass.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-pass.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-pass.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,17 @@\n+error: const `impl` for trait `PartialEq` which is not marked with `#[const_trait]`\n+  --> $DIR/call-generic-method-pass.rs:9:12\n+   |\n+LL | impl const PartialEq for S {\n+   |            ^^^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/call-generic-method-pass.rs:18:32\n+   |\n+LL | const fn equals_self<T: ~const PartialEq>(t: &T) -> bool {\n+   |                                ^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "9ba19e800dd65ba38414c60fe1eeffab82694efd", "filename": "tests/ui/rfc-2632-const-trait-impl/const-and-non-const-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,9 +1,10 @@\n+// known-bug: #110395\n+\n #![feature(const_trait_impl)]\n \n pub struct Int(i32);\n \n impl const std::ops::Add for i32 {\n-    //~^ ERROR only traits defined in the current crate can be implemented for primitive types\n     type Output = Self;\n \n     fn add(self, rhs: Self) -> Self {\n@@ -20,7 +21,6 @@ impl std::ops::Add for Int {\n }\n \n impl const std::ops::Add for Int {\n-    //~^ ERROR conflicting implementations of trait\n     type Output = Self;\n \n     fn add(self, rhs: Self) -> Self {"}, {"sha": "4f858d61eebaa717cb4dad5895d1c881999485af", "filename": "tests/ui/rfc-2632-const-trait-impl/const-and-non-const-impl.stderr", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,25 +1,20 @@\n-error[E0117]: only traits defined in the current crate can be implemented for primitive types\n-  --> $DIR/const-and-non-const-impl.rs:5:1\n+error: const `impl` for trait `Add` which is not marked with `#[const_trait]`\n+  --> $DIR/const-and-non-const-impl.rs:7:12\n    |\n LL | impl const std::ops::Add for i32 {\n-   | ^^^^^^^^^^^-------------^^^^^---\n-   | |          |                 |\n-   | |          |                 `i32` is not defined in the current crate\n-   | |          `i32` is not defined in the current crate\n-   | impl doesn't use only types from inside the current crate\n+   |            ^^^^^^^^^^^^^\n    |\n-   = note: define and implement a trait or new type instead\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n \n-error[E0119]: conflicting implementations of trait `Add` for type `Int`\n-  --> $DIR/const-and-non-const-impl.rs:22:1\n+error: const `impl` for trait `Add` which is not marked with `#[const_trait]`\n+  --> $DIR/const-and-non-const-impl.rs:23:12\n    |\n-LL | impl std::ops::Add for Int {\n-   | -------------------------- first implementation here\n-...\n LL | impl const std::ops::Add for Int {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `Int`\n+   |            ^^^^^^^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0117, E0119.\n-For more information about an error, try `rustc --explain E0117`."}, {"sha": "b4cc7a9e17e64be0546eb26811eec884f71df989", "filename": "tests/ui/rfc-2632-const-trait-impl/const-closure-trait-method-fail.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-closure-trait-method-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-closure-trait-method-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-closure-trait-method-fail.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,3 +1,5 @@\n+// known-bug: #110395\n+\n #![feature(const_trait_impl)]\n \n #[const_trait]\n@@ -14,6 +16,5 @@ const fn need_const_closure<T: ~const FnOnce(()) -> i32>(x: T) -> i32 {\n }\n \n const _: () = assert!(need_const_closure(Tr::a) == 42);\n-//~^ ERROR: the trait bound\n \n fn main() {}"}, {"sha": "112416a354343baf184186979be2cb792b3952af", "filename": "tests/ui/rfc-2632-const-trait-impl/const-closure-trait-method-fail.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-closure-trait-method-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-closure-trait-method-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-closure-trait-method-fail.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,11 +1,11 @@\n error[E0277]: the trait bound `(): ~const Tr` is not satisfied in `fn(()) -> i32 {<() as Tr>::a}`\n-  --> $DIR/const-closure-trait-method-fail.rs:16:23\n+  --> $DIR/const-closure-trait-method-fail.rs:18:23\n    |\n LL | const _: () = assert!(need_const_closure(Tr::a) == 42);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^ within `fn(()) -> i32 {<() as Tr>::a}`, the trait `~const Tr` is not implemented for `()`\n    |\n note: the trait `Tr` is implemented for `()`, but that implementation is not `const`\n-  --> $DIR/const-closure-trait-method-fail.rs:16:23\n+  --> $DIR/const-closure-trait-method-fail.rs:18:23\n    |\n LL | const _: () = assert!(need_const_closure(Tr::a) == 42);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "7c55b51c8f5f0a0a9bb89d7f7e5e5e6087edb129", "filename": "tests/ui/rfc-2632-const-trait-impl/const-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-closures.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// run-pass\n+// check-pass\n \n #![feature(const_trait_impl)]\n "}, {"sha": "13350a6d14a42dee4d3ecf2347e22d7f032ca4cb", "filename": "tests/ui/rfc-2632-const-trait-impl/const-drop-fail-2.precise.stderr", "status": "modified", "additions": 15, "deletions": 39, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail-2.precise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail-2.precise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail-2.precise.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,50 +1,26 @@\n-error[E0277]: the trait bound `NonTrivialDrop: ~const A` is not satisfied\n-  --> $DIR/const-drop-fail-2.rs:31:23\n+error: const `impl` for trait `Drop` which is not marked with `#[const_trait]`\n+  --> $DIR/const-drop-fail-2.rs:23:25\n    |\n-LL | const _: () = check::<ConstDropImplWithBounds<NonTrivialDrop>>(\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `~const A` is not implemented for `NonTrivialDrop`\n+LL | impl<T: ~const A> const Drop for ConstDropImplWithBounds<T> {\n+   |                         ^^^^\n    |\n-note: the trait `A` is implemented for `NonTrivialDrop`, but that implementation is not `const`\n-  --> $DIR/const-drop-fail-2.rs:31:23\n-   |\n-LL | const _: () = check::<ConstDropImplWithBounds<NonTrivialDrop>>(\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: required by a bound in `ConstDropImplWithBounds`\n-  --> $DIR/const-drop-fail-2.rs:21:35\n-   |\n-LL | struct ConstDropImplWithBounds<T: ~const A>(PhantomData<T>);\n-   |                                   ^^^^^^^^ required by this bound in `ConstDropImplWithBounds`\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n \n-error[E0277]: the trait bound `NonTrivialDrop: ~const A` is not satisfied\n-  --> $DIR/const-drop-fail-2.rs:33:5\n-   |\n-LL |     ConstDropImplWithBounds(PhantomData)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `~const A` is not implemented for `NonTrivialDrop`\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/const-drop-fail-2.rs:29:26\n    |\n-note: the trait `A` is implemented for `NonTrivialDrop`, but that implementation is not `const`\n-  --> $DIR/const-drop-fail-2.rs:33:5\n-   |\n-LL |     ConstDropImplWithBounds(PhantomData)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: required by a bound in `ConstDropImplWithBounds`\n-  --> $DIR/const-drop-fail-2.rs:21:35\n-   |\n-LL | struct ConstDropImplWithBounds<T: ~const A>(PhantomData<T>);\n-   |                                   ^^^^^^^^ required by this bound in `ConstDropImplWithBounds`\n+LL | const fn check<T: ~const Destruct>(_: T) {}\n+   |                          ^^^^^^^^\n \n-error[E0367]: `Drop` impl requires `T: ~const A` but the struct it is implemented for does not\n-  --> $DIR/const-drop-fail-2.rs:39:9\n+error: const `impl` for trait `Drop` which is not marked with `#[const_trait]`\n+  --> $DIR/const-drop-fail-2.rs:39:25\n    |\n LL | impl<T: ~const A> const Drop for ConstDropImplWithNonConstBounds<T> {\n-   |         ^^^^^^^^\n-   |\n-note: the implementor must specify the same requirement\n-  --> $DIR/const-drop-fail-2.rs:37:1\n+   |                         ^^^^\n    |\n-LL | struct ConstDropImplWithNonConstBounds<T: A>(PhantomData<T>);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0277, E0367.\n-For more information about an error, try `rustc --explain E0277`."}, {"sha": "3de9d37d49337782ad94b4fc7f4824442fa34003", "filename": "tests/ui/rfc-2632-const-trait-impl/const-drop-fail-2.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail-2.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// revisions: stock precise\n+// known-bug: #110395\n #![feature(const_trait_impl)]\n #![feature(const_mut_refs)]\n #![cfg_attr(precise, feature(const_precise_live_drops))]\n@@ -29,15 +29,12 @@ impl<T: ~const A> const Drop for ConstDropImplWithBounds<T> {\n const fn check<T: ~const Destruct>(_: T) {}\n \n const _: () = check::<ConstDropImplWithBounds<NonTrivialDrop>>(\n-    //~^ ERROR the trait bound\n     ConstDropImplWithBounds(PhantomData)\n-    //~^ ERROR the trait bound\n );\n \n struct ConstDropImplWithNonConstBounds<T: A>(PhantomData<T>);\n \n impl<T: ~const A> const Drop for ConstDropImplWithNonConstBounds<T> {\n-//~^ ERROR `Drop` impl requires `T: ~const A` but the struct it is implemented for does not\n     fn drop(&mut self) {\n         T::a();\n     }"}, {"sha": "375f5d2c52d644413c143a22bcf7af1f3c463dc4", "filename": "tests/ui/rfc-2632-const-trait-impl/const-drop-fail-2.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail-2.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,50 @@\n+error[E0277]: the trait bound `NonTrivialDrop: ~const A` is not satisfied\n+  --> $DIR/const-drop-fail-2.rs:31:23\n+   |\n+LL | const _: () = check::<ConstDropImplWithBounds<NonTrivialDrop>>(\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `~const A` is not implemented for `NonTrivialDrop`\n+   |\n+note: the trait `A` is implemented for `NonTrivialDrop`, but that implementation is not `const`\n+  --> $DIR/const-drop-fail-2.rs:31:23\n+   |\n+LL | const _: () = check::<ConstDropImplWithBounds<NonTrivialDrop>>(\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: required by a bound in `ConstDropImplWithBounds`\n+  --> $DIR/const-drop-fail-2.rs:21:35\n+   |\n+LL | struct ConstDropImplWithBounds<T: ~const A>(PhantomData<T>);\n+   |                                   ^^^^^^^^ required by this bound in `ConstDropImplWithBounds`\n+\n+error[E0277]: the trait bound `NonTrivialDrop: ~const A` is not satisfied\n+  --> $DIR/const-drop-fail-2.rs:32:5\n+   |\n+LL |     ConstDropImplWithBounds(PhantomData)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `~const A` is not implemented for `NonTrivialDrop`\n+   |\n+note: the trait `A` is implemented for `NonTrivialDrop`, but that implementation is not `const`\n+  --> $DIR/const-drop-fail-2.rs:32:5\n+   |\n+LL |     ConstDropImplWithBounds(PhantomData)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: required by a bound in `ConstDropImplWithBounds`\n+  --> $DIR/const-drop-fail-2.rs:21:35\n+   |\n+LL | struct ConstDropImplWithBounds<T: ~const A>(PhantomData<T>);\n+   |                                   ^^^^^^^^ required by this bound in `ConstDropImplWithBounds`\n+\n+error[E0367]: `Drop` impl requires `T: ~const A` but the struct it is implemented for does not\n+  --> $DIR/const-drop-fail-2.rs:37:9\n+   |\n+LL | impl<T: ~const A> const Drop for ConstDropImplWithNonConstBounds<T> {\n+   |         ^^^^^^^^\n+   |\n+note: the implementor must specify the same requirement\n+  --> $DIR/const-drop-fail-2.rs:35:1\n+   |\n+LL | struct ConstDropImplWithNonConstBounds<T: A>(PhantomData<T>);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0277, E0367.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "13350a6d14a42dee4d3ecf2347e22d7f032ca4cb", "filename": "tests/ui/rfc-2632-const-trait-impl/const-drop-fail-2.stock.stderr", "status": "modified", "additions": 15, "deletions": 39, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail-2.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail-2.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail-2.stock.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,50 +1,26 @@\n-error[E0277]: the trait bound `NonTrivialDrop: ~const A` is not satisfied\n-  --> $DIR/const-drop-fail-2.rs:31:23\n+error: const `impl` for trait `Drop` which is not marked with `#[const_trait]`\n+  --> $DIR/const-drop-fail-2.rs:23:25\n    |\n-LL | const _: () = check::<ConstDropImplWithBounds<NonTrivialDrop>>(\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `~const A` is not implemented for `NonTrivialDrop`\n+LL | impl<T: ~const A> const Drop for ConstDropImplWithBounds<T> {\n+   |                         ^^^^\n    |\n-note: the trait `A` is implemented for `NonTrivialDrop`, but that implementation is not `const`\n-  --> $DIR/const-drop-fail-2.rs:31:23\n-   |\n-LL | const _: () = check::<ConstDropImplWithBounds<NonTrivialDrop>>(\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: required by a bound in `ConstDropImplWithBounds`\n-  --> $DIR/const-drop-fail-2.rs:21:35\n-   |\n-LL | struct ConstDropImplWithBounds<T: ~const A>(PhantomData<T>);\n-   |                                   ^^^^^^^^ required by this bound in `ConstDropImplWithBounds`\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n \n-error[E0277]: the trait bound `NonTrivialDrop: ~const A` is not satisfied\n-  --> $DIR/const-drop-fail-2.rs:33:5\n-   |\n-LL |     ConstDropImplWithBounds(PhantomData)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `~const A` is not implemented for `NonTrivialDrop`\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/const-drop-fail-2.rs:29:26\n    |\n-note: the trait `A` is implemented for `NonTrivialDrop`, but that implementation is not `const`\n-  --> $DIR/const-drop-fail-2.rs:33:5\n-   |\n-LL |     ConstDropImplWithBounds(PhantomData)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: required by a bound in `ConstDropImplWithBounds`\n-  --> $DIR/const-drop-fail-2.rs:21:35\n-   |\n-LL | struct ConstDropImplWithBounds<T: ~const A>(PhantomData<T>);\n-   |                                   ^^^^^^^^ required by this bound in `ConstDropImplWithBounds`\n+LL | const fn check<T: ~const Destruct>(_: T) {}\n+   |                          ^^^^^^^^\n \n-error[E0367]: `Drop` impl requires `T: ~const A` but the struct it is implemented for does not\n-  --> $DIR/const-drop-fail-2.rs:39:9\n+error: const `impl` for trait `Drop` which is not marked with `#[const_trait]`\n+  --> $DIR/const-drop-fail-2.rs:39:25\n    |\n LL | impl<T: ~const A> const Drop for ConstDropImplWithNonConstBounds<T> {\n-   |         ^^^^^^^^\n-   |\n-note: the implementor must specify the same requirement\n-  --> $DIR/const-drop-fail-2.rs:37:1\n+   |                         ^^^^\n    |\n-LL | struct ConstDropImplWithNonConstBounds<T: A>(PhantomData<T>);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0277, E0367.\n-For more information about an error, try `rustc --explain E0277`."}, {"sha": "e745cbd24429249af98ae4836c955dd922451763", "filename": "tests/ui/rfc-2632-const-trait-impl/const-drop-fail.precise.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: can't drop `NonTrivialDrop` in const contexts\n-  --> $DIR/const-drop-fail.rs:26:23\n+  --> $DIR/const-drop-fail.rs:28:23\n    |\n LL |           const _: () = check($exp);\n    |                         ^^^^^^^^^^^ the trait `~const Destruct` is not implemented for `NonTrivialDrop`\n@@ -11,7 +11,7 @@ LL | | }\n    | |_- in this macro invocation\n    |\n note: the trait `Destruct` is implemented for `NonTrivialDrop`, but that implementation is not `const`\n-  --> $DIR/const-drop-fail.rs:26:23\n+  --> $DIR/const-drop-fail.rs:28:23\n    |\n LL |           const _: () = check($exp);\n    |                         ^^^^^^^^^^^\n@@ -24,7 +24,7 @@ LL | | }\n    = note: this error originates in the macro `check_all` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't drop `NonTrivialDrop` in const contexts\n-  --> $DIR/const-drop-fail.rs:26:23\n+  --> $DIR/const-drop-fail.rs:28:23\n    |\n LL |           const _: () = check($exp);\n    |                         ^^^^^^^^^^^ within `ConstImplWithDropGlue`, the trait `~const Destruct` is not implemented for `NonTrivialDrop`\n@@ -36,7 +36,7 @@ LL | | }\n    | |_- in this macro invocation\n    |\n note: the trait `Destruct` is implemented for `NonTrivialDrop`, but that implementation is not `const`\n-  --> $DIR/const-drop-fail.rs:26:23\n+  --> $DIR/const-drop-fail.rs:28:23\n    |\n LL |           const _: () = check($exp);\n    |                         ^^^^^^^^^^^\n@@ -47,7 +47,7 @@ LL | |     ConstImplWithDropGlue(NonTrivialDrop),\n LL | | }\n    | |_- in this macro invocation\n note: required because it appears within the type `ConstImplWithDropGlue`\n-  --> $DIR/const-drop-fail.rs:16:8\n+  --> $DIR/const-drop-fail.rs:18:8\n    |\n LL | struct ConstImplWithDropGlue(NonTrivialDrop);\n    |        ^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "1c37648ff1cbac609117dc0b74e6e8bfadf0eea6", "filename": "tests/ui/rfc-2632-const-trait-impl/const-drop-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,3 +1,5 @@\n+// known-bug: #110395\n+\n // revisions: stock precise\n #![feature(const_trait_impl)]\n #![feature(const_mut_refs)]\n@@ -24,8 +26,6 @@ const fn check<T: ~const Destruct>(_: T) {}\n macro_rules! check_all {\n     ($($exp:expr),*$(,)?) => {$(\n         const _: () = check($exp);\n-        //~^ ERROR can't drop\n-        //~| ERROR can't drop\n     )*};\n }\n "}, {"sha": "e745cbd24429249af98ae4836c955dd922451763", "filename": "tests/ui/rfc-2632-const-trait-impl/const-drop-fail.stock.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: can't drop `NonTrivialDrop` in const contexts\n-  --> $DIR/const-drop-fail.rs:26:23\n+  --> $DIR/const-drop-fail.rs:28:23\n    |\n LL |           const _: () = check($exp);\n    |                         ^^^^^^^^^^^ the trait `~const Destruct` is not implemented for `NonTrivialDrop`\n@@ -11,7 +11,7 @@ LL | | }\n    | |_- in this macro invocation\n    |\n note: the trait `Destruct` is implemented for `NonTrivialDrop`, but that implementation is not `const`\n-  --> $DIR/const-drop-fail.rs:26:23\n+  --> $DIR/const-drop-fail.rs:28:23\n    |\n LL |           const _: () = check($exp);\n    |                         ^^^^^^^^^^^\n@@ -24,7 +24,7 @@ LL | | }\n    = note: this error originates in the macro `check_all` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't drop `NonTrivialDrop` in const contexts\n-  --> $DIR/const-drop-fail.rs:26:23\n+  --> $DIR/const-drop-fail.rs:28:23\n    |\n LL |           const _: () = check($exp);\n    |                         ^^^^^^^^^^^ within `ConstImplWithDropGlue`, the trait `~const Destruct` is not implemented for `NonTrivialDrop`\n@@ -36,7 +36,7 @@ LL | | }\n    | |_- in this macro invocation\n    |\n note: the trait `Destruct` is implemented for `NonTrivialDrop`, but that implementation is not `const`\n-  --> $DIR/const-drop-fail.rs:26:23\n+  --> $DIR/const-drop-fail.rs:28:23\n    |\n LL |           const _: () = check($exp);\n    |                         ^^^^^^^^^^^\n@@ -47,7 +47,7 @@ LL | |     ConstImplWithDropGlue(NonTrivialDrop),\n LL | | }\n    | |_- in this macro invocation\n note: required because it appears within the type `ConstImplWithDropGlue`\n-  --> $DIR/const-drop-fail.rs:16:8\n+  --> $DIR/const-drop-fail.rs:18:8\n    |\n LL | struct ConstImplWithDropGlue(NonTrivialDrop);\n    |        ^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "f396deff4fe899d75287790d41ea83cf58752487", "filename": "tests/ui/rfc-2632-const-trait-impl/const-impl-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-impl-trait.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// known-bug: #110395\n #![allow(incomplete_features)]\n #![feature(\n     associated_type_bounds,"}, {"sha": "f9078e227910d49d69aab09cadf64042571f6206", "filename": "tests/ui/rfc-2632-const-trait-impl/const-impl-trait.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst-impl-trait.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,39 @@\n+error[E0635]: unknown feature `const_cmp`\n+  --> $DIR/const-impl-trait.rs:6:5\n+   |\n+LL |     const_cmp,\n+   |     ^^^^^^^^^\n+\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/const-impl-trait.rs:12:30\n+   |\n+LL | const fn cmp(a: &impl ~const PartialEq) -> bool {\n+   |                              ^^^^^^^^^\n+\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/const-impl-trait.rs:16:30\n+   |\n+LL | const fn wrap(x: impl ~const PartialEq + ~const Destruct)\n+   |                              ^^^^^^^^^\n+\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/const-impl-trait.rs:17:20\n+   |\n+LL |     -> impl ~const PartialEq + ~const Destruct\n+   |                    ^^^^^^^^^\n+\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/const-impl-trait.rs:24:29\n+   |\n+LL |     fn huh() -> impl ~const PartialEq + ~const Destruct + Copy;\n+   |                             ^^^^^^^^^\n+\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/const-impl-trait.rs:28:29\n+   |\n+LL |     fn huh() -> impl ~const PartialEq + ~const Destruct + Copy {\n+   |                             ^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0635`."}, {"sha": "dba3ad7f8701eab252601e0f5ca8e4e2097b537c", "filename": "tests/ui/rfc-2632-const-trait-impl/const_derives/derive-const-gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-gate.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,5 @@\n #[derive_const(Default)] //~ ERROR use of unstable library feature\n+//~^ ERROR not marked with `#[const_trait]`\n pub struct S;\n \n fn main() {}"}, {"sha": "6a81f96d88d2e77f5ab89cb4bb626ae848925625", "filename": "tests/ui/rfc-2632-const-trait-impl/const_derives/derive-const-gate.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-gate.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -6,6 +6,16 @@ LL | #[derive_const(Default)]\n    |\n    = help: add `#![feature(derive_const)]` to the crate attributes to enable\n \n-error: aborting due to previous error\n+error: const `impl` for trait `Default` which is not marked with `#[const_trait]`\n+  --> $DIR/derive-const-gate.rs:1:16\n+   |\n+LL | #[derive_const(Default)]\n+   |                ^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+   = note: this error originates in the derive macro `Default` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "b575ea8dae2980d745ad76b8c05c5bc2d15430b9", "filename": "tests/ui/rfc-2632-const-trait-impl/const_derives/derive-const-non-const-type.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-non-const-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-non-const-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-non-const-type.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,3 +1,4 @@\n+// known-bug: #110395\n #![feature(derive_const)]\n \n pub struct A;\n@@ -8,7 +9,5 @@ impl Default for A {\n \n #[derive_const(Default)]\n pub struct S(A);\n-//~^ cannot call non-const fn\n-//~| the trait bound\n \n fn main() {}"}, {"sha": "1c69ad4317142a70e24a2a169d4e8cda921b3009", "filename": "tests/ui/rfc-2632-const-trait-impl/const_derives/derive-const-non-const-type.stderr", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-non-const-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-non-const-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-non-const-type.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,38 +1,12 @@\n-error[E0277]: the trait bound `A: Default` is not satisfied\n-  --> $DIR/derive-const-non-const-type.rs:10:14\n+error: const `impl` for trait `Default` which is not marked with `#[const_trait]`\n+  --> $DIR/derive-const-non-const-type.rs:10:16\n    |\n LL | #[derive_const(Default)]\n-   |                ------- in this derive macro expansion\n-LL | pub struct S(A);\n-   |              ^ the trait `~const Default` is not implemented for `A`\n+   |                ^^^^^^^\n    |\n-note: the trait `Default` is implemented for `A`, but that implementation is not `const`\n-  --> $DIR/derive-const-non-const-type.rs:10:14\n-   |\n-LL | #[derive_const(Default)]\n-   |                ------- in this derive macro expansion\n-LL | pub struct S(A);\n-   |              ^\n-   = note: this error originates in the derive macro `Default` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: consider annotating `A` with `#[derive(Default)]`\n-   |\n-LL + #[derive(Default)]\n-LL | pub struct A;\n-   |\n-\n-error[E0015]: cannot call non-const fn `<A as Default>::default` in constant functions\n-  --> $DIR/derive-const-non-const-type.rs:10:14\n-   |\n-LL | #[derive_const(Default)]\n-   |                ------- in this derive macro expansion\n-LL | pub struct S(A);\n-   |              ^\n-   |\n-   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-   = help: add `#![feature(const_trait_impl)]` to the crate attributes to enable\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n    = note: this error originates in the derive macro `Default` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0015, E0277.\n-For more information about an error, try `rustc --explain E0015`."}, {"sha": "69098542b7e360fa1a9d86786f49de0cc83af8c8", "filename": "tests/ui/rfc-2632-const-trait-impl/const_derives/derive-const-use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-use.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// known-bug: #110395\n #![feature(const_trait_impl, const_cmp, const_default_impls, derive_const)]\n \n pub struct A;"}, {"sha": "88054096e630bcfa38ea2b92e81acecaeb2ea7a7", "filename": "tests/ui/rfc-2632-const-trait-impl/const_derives/derive-const-use.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-use.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,53 @@\n+error[E0635]: unknown feature `const_cmp`\n+  --> $DIR/derive-const-use.rs:2:30\n+   |\n+LL | #![feature(const_trait_impl, const_cmp, const_default_impls, derive_const)]\n+   |                              ^^^^^^^^^\n+\n+error[E0635]: unknown feature `const_default_impls`\n+  --> $DIR/derive-const-use.rs:2:41\n+   |\n+LL | #![feature(const_trait_impl, const_cmp, const_default_impls, derive_const)]\n+   |                                         ^^^^^^^^^^^^^^^^^^^\n+\n+error: const `impl` for trait `Default` which is not marked with `#[const_trait]`\n+  --> $DIR/derive-const-use.rs:6:12\n+   |\n+LL | impl const Default for A {\n+   |            ^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+\n+error: const `impl` for trait `PartialEq` which is not marked with `#[const_trait]`\n+  --> $DIR/derive-const-use.rs:10:12\n+   |\n+LL | impl const PartialEq for A {\n+   |            ^^^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+\n+error: const `impl` for trait `Default` which is not marked with `#[const_trait]`\n+  --> $DIR/derive-const-use.rs:14:16\n+   |\n+LL | #[derive_const(Default, PartialEq)]\n+   |                ^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+   = note: this error originates in the derive macro `Default` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: const `impl` for trait `PartialEq` which is not marked with `#[const_trait]`\n+  --> $DIR/derive-const-use.rs:14:25\n+   |\n+LL | #[derive_const(Default, PartialEq)]\n+   |                         ^^^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0635`."}, {"sha": "2a5d0176ba0043db97100f33311fd4b4eeedda19", "filename": "tests/ui/rfc-2632-const-trait-impl/const_derives/derive-const-with-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-with-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-with-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-with-params.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// known-bug: #110395\n \n #![feature(derive_const)]\n #![feature(const_trait_impl)]"}, {"sha": "fa78326587c71bae6da205539be5a50897f18851", "filename": "tests/ui/rfc-2632-const-trait-impl/const_derives/derive-const-with-params.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-with-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-with-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-with-params.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,20 @@\n+error: const `impl` for trait `PartialEq` which is not marked with `#[const_trait]`\n+  --> $DIR/derive-const-with-params.rs:6:16\n+   |\n+LL | #[derive_const(PartialEq)]\n+   |                ^^^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/derive-const-with-params.rs:6:16\n+   |\n+LL | #[derive_const(PartialEq)]\n+   |                ^^^^^^^^^\n+   |\n+   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "d665c4479c9ab53889e94a48e166bee77a1bfe63", "filename": "tests/ui/rfc-2632-const-trait-impl/generic-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fgeneric-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fgeneric-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fgeneric-bound.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// run-pass\n+// known-bug: #110395\n \n #![feature(const_trait_impl)]\n "}, {"sha": "1b21d7c0e0e60a66b3695d562770aead491ad102", "filename": "tests/ui/rfc-2632-const-trait-impl/generic-bound.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fgeneric-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fgeneric-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fgeneric-bound.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,11 @@\n+error: const `impl` for trait `Add` which is not marked with `#[const_trait]`\n+  --> $DIR/generic-bound.rs:16:15\n+   |\n+LL | impl<T> const std::ops::Add for S<T> {\n+   |               ^^^^^^^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+\n+error: aborting due to previous error\n+"}, {"sha": "dff8a244453af255528f1c6fd6b81e431790a9a4", "filename": "tests/ui/rfc-2632-const-trait-impl/non-const-op-in-closure-in-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fnon-const-op-in-closure-in-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fnon-const-op-in-closure-in-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fnon-const-op-in-closure-in-const.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// known-bug: #110395\n \n #![feature(const_trait_impl)]\n "}, {"sha": "cfdda4713a7932bca75e470842f4bc13e01c6bf2", "filename": "tests/ui/rfc-2632-const-trait-impl/non-const-op-in-closure-in-const.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fnon-const-op-in-closure-in-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fnon-const-op-in-closure-in-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fnon-const-op-in-closure-in-const.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,8 @@\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/non-const-op-in-closure-in-const.rs:10:51\n+   |\n+LL | impl<A, B> const Convert<B> for A where B: ~const From<A> {\n+   |                                                   ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "5c2a3f80170eaa0b84299ef5db5a62589ce1c2bb", "filename": "tests/ui/rfc-2632-const-trait-impl/specializing-constness.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecializing-constness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecializing-constness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecializing-constness.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -11,13 +11,16 @@ pub trait A {\n     fn a() -> u32;\n }\n \n-impl<T: ~const Default> const A for T {\n+#[const_trait]\n+pub trait Spec {}\n+\n+impl<T: ~const Spec> const A for T {\n     default fn a() -> u32 {\n         2\n     }\n }\n \n-impl<T: Default + Sup> A for T {\n+impl<T: Spec + Sup> A for T {\n //~^ ERROR: cannot specialize\n //~| ERROR: missing `~const` qualifier\n     fn a() -> u32 {"}, {"sha": "1ffdc50e5893233d1ed9c13e502276df2164af5a", "filename": "tests/ui/rfc-2632-const-trait-impl/specializing-constness.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecializing-constness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecializing-constness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecializing-constness.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,14 +1,14 @@\n error: cannot specialize on const impl with non-const impl\n-  --> $DIR/specializing-constness.rs:20:1\n+  --> $DIR/specializing-constness.rs:23:1\n    |\n-LL | impl<T: Default + Sup> A for T {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | impl<T: Spec + Sup> A for T {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing `~const` qualifier for specialization\n-  --> $DIR/specializing-constness.rs:20:9\n+  --> $DIR/specializing-constness.rs:23:9\n    |\n-LL | impl<T: Default + Sup> A for T {\n-   |         ^^^^^^^\n+LL | impl<T: Spec + Sup> A for T {\n+   |         ^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "78aab9469e8221474950f1e546007eb085b4776d", "filename": "tests/ui/rfc-2632-const-trait-impl/std-impl-gate.gated.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.gated.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,9 @@\n+error[E0635]: unknown feature `const_default_impls`\n+  --> $DIR/std-impl-gate.rs:6:46\n+   |\n+LL | #![cfg_attr(gated, feature(const_trait_impl, const_default_impls))]\n+   |                                              ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0635`."}, {"sha": "e9e5e0235df3377a46440e72e4c548168e8b6c7a", "filename": "tests/ui/rfc-2632-const-trait-impl/std-impl-gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,7 +1,7 @@\n // This tests feature gates for const impls in the standard library.\n \n // revisions: stock gated\n-//[gated] run-pass\n+//[gated] known-bug: #110395\n \n #![cfg_attr(gated, feature(const_trait_impl, const_default_impls))]\n "}, {"sha": "8d56295e738370e554972ec28fbfb28ff4d32690", "filename": "tests/ui/rfc-2632-const-trait-impl/trait-default-body-stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-default-body-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-default-body-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-default-body-stability.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// known-bug: #110395\n \n #![feature(staged_api)]\n #![feature(const_trait_impl)]"}, {"sha": "35dc1ca129b12e3844714c76e41f36ae4376d71f", "filename": "tests/ui/rfc-2632-const-trait-impl/trait-default-body-stability.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-default-body-stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-default-body-stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-default-body-stability.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,20 @@\n+error: const `impl` for trait `Try` which is not marked with `#[const_trait]`\n+  --> $DIR/trait-default-body-stability.rs:18:12\n+   |\n+LL | impl const Try for T {\n+   |            ^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+\n+error: const `impl` for trait `FromResidual` which is not marked with `#[const_trait]`\n+  --> $DIR/trait-default-body-stability.rs:33:12\n+   |\n+LL | impl const FromResidual for T {\n+   |            ^^^^^^^^^^^^\n+   |\n+   = note: marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+   = note: adding a non-const method body in the future would be a breaking change\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "b1ec58c3df31b0e45b4ab97e4737f71edd28adc3", "filename": "tests/ui/specialization/const_trait_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fspecialization%2Fconst_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fspecialization%2Fconst_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fconst_trait_impl.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -1,4 +1,5 @@\n-// check-pass\n+// known-bug: #110395\n+\n #![feature(const_trait_impl, min_specialization, rustc_attrs)]\n \n #[rustc_specialization_trait]"}, {"sha": "d13cd8f55553d32f4b03aa62be11a164fae18ba6", "filename": "tests/ui/specialization/const_trait_impl.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fspecialization%2Fconst_trait_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fspecialization%2Fconst_trait_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fconst_trait_impl.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -0,0 +1,20 @@\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/const_trait_impl.rs:34:16\n+   |\n+LL | impl<T: ~const Default> const A for T {\n+   |                ^^^^^^^\n+\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/const_trait_impl.rs:40:16\n+   |\n+LL | impl<T: ~const Default + ~const Sup> const A for T {\n+   |                ^^^^^^^\n+\n+error: ~const can only be applied to `#[const_trait]` traits\n+  --> $DIR/const_trait_impl.rs:46:16\n+   |\n+LL | impl<T: ~const Default + ~const Sub> const A for T {\n+   |                ^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "c479326f935343163db2280911f19f3435212b2d", "filename": "tests/ui/suggestions/issue-109436.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fsuggestions%2Fissue-109436.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Fsuggestions%2Fissue-109436.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-109436.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -2,7 +2,7 @@ error[E0277]: the trait bound `Foo: Into<_>` is not satisfied\n   --> $DIR/issue-109436.rs:12:22\n    |\n LL |     let b: Bar = foo.into();\n-   |                      ^^^^ the trait `~const Into<_>` is not implemented for `Foo`\n+   |                      ^^^^ the trait `Into<_>` is not implemented for `Foo`\n    |\n    = note: required for `Foo` to implement `Into<Bar>`\n help: consider borrowing here"}, {"sha": "46aed0f603e870249d613d6db9edbcdc0131ace6", "filename": "tests/ui/typeck/typeck_type_placeholder_item.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -227,6 +227,4 @@ fn evens_squared(n: usize) -> _ {\n }\n \n const _: _ = (1..10).filter(|x| x % 2 == 0).map(|x| x * x);\n-//~^ ERROR the trait bound\n-//~| ERROR the trait bound\n-//~| ERROR the placeholder\n+//~^ ERROR the placeholder"}, {"sha": "bc02547c65eb8d89f4954ea75a31166f7d5de7b1", "filename": "tests/ui/typeck/typeck_type_placeholder_item.stderr", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a5c8e91f094bb1cb1346651fe3512f0b603d826/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr?ref=3a5c8e91f094bb1cb1346651fe3512f0b603d826", "patch": "@@ -437,37 +437,17 @@ LL | fn evens_squared(n: usize) -> _ {\n    |                               not allowed in type signatures\n    |                               help: replace with an appropriate return type: `impl Iterator<Item = usize>`\n \n-error[E0277]: the trait bound `std::ops::Range<{integer}>: Iterator` is not satisfied\n-  --> $DIR/typeck_type_placeholder_item.rs:229:22\n-   |\n-LL | const _: _ = (1..10).filter(|x| x % 2 == 0).map(|x| x * x);\n-   |                      ^^^^^^ `std::ops::Range<{integer}>` is not an iterator\n-   |\n-   = help: the trait `~const Iterator` is not implemented for `std::ops::Range<{integer}>`\n-note: the trait `Iterator` is implemented for `std::ops::Range<{integer}>`, but that implementation is not `const`\n-  --> $DIR/typeck_type_placeholder_item.rs:229:14\n-   |\n-LL | const _: _ = (1..10).filter(|x| x % 2 == 0).map(|x| x * x);\n-   |              ^^^^^^^\n-\n-error[E0277]: the trait bound `Filter<std::ops::Range<{integer}>, [closure@$DIR/typeck_type_placeholder_item.rs:229:29: 229:32]>: Iterator` is not satisfied\n-  --> $DIR/typeck_type_placeholder_item.rs:229:45\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n+  --> $DIR/typeck_type_placeholder_item.rs:229:10\n    |\n LL | const _: _ = (1..10).filter(|x| x % 2 == 0).map(|x| x * x);\n-   |                                             ^^^ `Filter<std::ops::Range<{integer}>, [closure@$DIR/typeck_type_placeholder_item.rs:229:29: 229:32]>` is not an iterator\n+   |          ^ not allowed in type signatures\n    |\n-   = help: the trait `~const Iterator` is not implemented for `Filter<std::ops::Range<{integer}>, [closure@$DIR/typeck_type_placeholder_item.rs:229:29: 229:32]>`\n-note: the trait `Iterator` is implemented for `Filter<std::ops::Range<{integer}>, [closure@$DIR/typeck_type_placeholder_item.rs:229:29: 229:32]>`, but that implementation is not `const`\n+note: however, the inferred type `Map<Filter<Range<i32>, [closure@typeck_type_placeholder_item.rs:229:29]>, [closure@typeck_type_placeholder_item.rs:229:49]>` cannot be named\n   --> $DIR/typeck_type_placeholder_item.rs:229:14\n    |\n LL | const _: _ = (1..10).filter(|x| x % 2 == 0).map(|x| x * x);\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n-  --> $DIR/typeck_type_placeholder_item.rs:229:10\n-   |\n-LL | const _: _ = (1..10).filter(|x| x % 2 == 0).map(|x| x * x);\n-   |          ^ not allowed in type signatures\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:140:31\n@@ -677,7 +657,7 @@ LL |     const D: _ = 42;\n    |              not allowed in type signatures\n    |              help: replace with the correct type: `i32`\n \n-error: aborting due to 73 previous errors\n+error: aborting due to 71 previous errors\n \n-Some errors have detailed explanations: E0121, E0277, E0282, E0403.\n+Some errors have detailed explanations: E0121, E0282, E0403.\n For more information about an error, try `rustc --explain E0121`."}]}