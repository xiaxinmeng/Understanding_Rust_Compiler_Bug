{"sha": "0102fb41337ac0442e689d410bb424d215e9a7bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMDJmYjQxMzM3YWMwNDQyZTY4OWQ0MTBiYjQyNGQyMTVlOWE3YmQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-21T09:21:46Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-21T10:25:03Z"}, "message": "Decouple Resolver", "tree": {"sha": "c77bf501427adc77c0fc92fe75fd9f314087b120", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c77bf501427adc77c0fc92fe75fd9f314087b120"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0102fb41337ac0442e689d410bb424d215e9a7bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0102fb41337ac0442e689d410bb424d215e9a7bd", "html_url": "https://github.com/rust-lang/rust/commit/0102fb41337ac0442e689d410bb424d215e9a7bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0102fb41337ac0442e689d410bb424d215e9a7bd/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "612a72fc4ea4376920f2a7da7b3c334227c1716c", "url": "https://api.github.com/repos/rust-lang/rust/commits/612a72fc4ea4376920f2a7da7b3c334227c1716c", "html_url": "https://github.com/rust-lang/rust/commit/612a72fc4ea4376920f2a7da7b3c334227c1716c"}], "stats": {"total": 296, "additions": 188, "deletions": 108}, "files": [{"sha": "550ab1a985c481d8a6a0aee95c8893b2371943be", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=0102fb41337ac0442e689d410bb424d215e9a7bd", "patch": "@@ -12,8 +12,8 @@ use hir_def::{\n     builtin_type::BuiltinType,\n     traits::TraitData,\n     type_ref::{Mutability, TypeRef},\n-    AssocItemId, ContainerId, CrateModuleId, HasModule, ImplId, LocalEnumVariantId,\n-    LocalStructFieldId, Lookup, ModuleId, UnionId,\n+    ContainerId, CrateModuleId, HasModule, ImplId, LocalEnumVariantId, LocalStructFieldId, Lookup,\n+    ModuleId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n@@ -842,9 +842,10 @@ impl Trait {\n                 _ => None,\n             })\n             .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path) {\n-                Some(TypeNs::Trait(t)) => Some(t),\n+                Some(TypeNs::TraitId(t)) => Some(t),\n                 _ => None,\n             })\n+            .map(Trait::from)\n             .collect()\n     }\n \n@@ -871,14 +872,9 @@ impl Trait {\n \n     pub fn associated_type_by_name(self, db: &impl DefDatabase, name: &Name) -> Option<TypeAlias> {\n         let trait_data = self.trait_data(db);\n-        trait_data\n-            .items\n-            .iter()\n-            .filter_map(|item| match item {\n-                AssocItemId::TypeAliasId(t) => Some(TypeAlias::from(*t)),\n-                _ => None,\n-            })\n-            .find(|t| &t.name(db) == name)\n+        let res =\n+            trait_data.associated_types().map(TypeAlias::from).find(|t| &t.name(db) == name)?;\n+        Some(res)\n     }\n \n     pub fn associated_type_by_name_including_super_traits("}, {"sha": "8c4c63fda3446c8b3a1a39d49add270068319047", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=0102fb41337ac0442e689d410bb424d215e9a7bd", "patch": "@@ -46,7 +46,7 @@ pub(crate) fn resolver_for_scope(\n     let scopes = owner.expr_scopes(db);\n     let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n     for scope in scope_chain.into_iter().rev() {\n-        r = r.push_expr_scope(owner, Arc::clone(&scopes), scope);\n+        r = r.push_expr_scope(owner.into(), Arc::clone(&scopes), scope);\n     }\n     r\n }\n@@ -152,7 +152,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             _ => return,\n         };\n \n-        let std_result_ctor = TypeCtor::Adt(Adt::Enum(std_result_enum));\n+        let std_result_ctor = TypeCtor::Adt(Adt::Enum(std_result_enum.into()));\n         let params = match &mismatch.expected {\n             Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &std_result_ctor => parameters,\n             _ => return,"}, {"sha": "7042422ccf81b7f4f9d04185305b06ab14d003a8", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 63, "deletions": 2, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=0102fb41337ac0442e689d410bb424d215e9a7bd", "patch": "@@ -3,9 +3,14 @@\n //! It's unclear if we need this long-term, but it's definitelly useful while we\n //! are splitting the hir.\n \n-use hir_def::{AdtId, AssocItemId, DefWithBodyId, EnumVariantId, GenericDefId, ModuleDefId};\n+use hir_def::{\n+    AdtId, AssocItemId, DefWithBodyId, EnumId, EnumVariantId, GenericDefId, ModuleDefId, StructId,\n+    TypeAliasId, UnionId,\n+};\n \n-use crate::{Adt, AssocItem, DefWithBody, EnumVariant, GenericDef, ModuleDef};\n+use crate::{\n+    ty::TypableDef, Adt, AssocItem, DefWithBody, EnumVariant, GenericDef, ModuleDef, TypeAlias,\n+};\n \n macro_rules! from_id {\n     ($(($id:path, $ty:path)),*) => {$(\n@@ -83,6 +88,16 @@ impl From<DefWithBody> for DefWithBodyId {\n     }\n }\n \n+impl From<DefWithBodyId> for DefWithBody {\n+    fn from(def: DefWithBodyId) -> Self {\n+        match def {\n+            DefWithBodyId::FunctionId(it) => DefWithBody::Function(it.into()),\n+            DefWithBodyId::StaticId(it) => DefWithBody::Static(it.into()),\n+            DefWithBodyId::ConstId(it) => DefWithBody::Const(it.into()),\n+        }\n+    }\n+}\n+\n impl From<AssocItemId> for AssocItem {\n     fn from(def: AssocItemId) -> Self {\n         match def {\n@@ -122,3 +137,49 @@ impl From<GenericDefId> for GenericDef {\n         }\n     }\n }\n+\n+impl From<AdtId> for TypableDef {\n+    fn from(id: AdtId) -> Self {\n+        Adt::from(id).into()\n+    }\n+}\n+\n+impl From<StructId> for TypableDef {\n+    fn from(id: StructId) -> Self {\n+        AdtId::StructId(id).into()\n+    }\n+}\n+\n+impl From<UnionId> for TypableDef {\n+    fn from(id: UnionId) -> Self {\n+        AdtId::UnionId(id).into()\n+    }\n+}\n+\n+impl From<EnumId> for TypableDef {\n+    fn from(id: EnumId) -> Self {\n+        AdtId::EnumId(id).into()\n+    }\n+}\n+\n+impl From<EnumVariantId> for TypableDef {\n+    fn from(id: EnumVariantId) -> Self {\n+        EnumVariant::from(id).into()\n+    }\n+}\n+\n+impl From<TypeAliasId> for TypableDef {\n+    fn from(id: TypeAliasId) -> Self {\n+        TypeAlias::from(id).into()\n+    }\n+}\n+\n+impl From<Adt> for GenericDefId {\n+    fn from(id: Adt) -> Self {\n+        match id {\n+            Adt::Struct(it) => it.id.into(),\n+            Adt::Union(it) => it.id.into(),\n+            Adt::Enum(it) => it.id.into(),\n+        }\n+    }\n+}"}, {"sha": "f4165babd374767514c4b72b7c92a85e88e2c571", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 61, "deletions": 56, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=0102fb41337ac0442e689d410bb424d215e9a7bd", "patch": "@@ -3,19 +3,21 @@ use std::sync::Arc;\n \n use hir_def::{\n     builtin_type::BuiltinType,\n+    db::DefDatabase2,\n+    generics::GenericParams,\n     nameres::CrateDefMap,\n     path::{Path, PathKind},\n-    AdtId, CrateModuleId, ModuleDefId,\n+    AdtId, CrateModuleId, DefWithBodyId, EnumId, EnumVariantId, GenericDefId, ImplId, ModuleDefId,\n+    StructId, TraitId, TypeAliasId,\n };\n use hir_expand::name::{self, Name};\n use rustc_hash::FxHashSet;\n \n use crate::{\n     code_model::Crate,\n-    db::{DefDatabase, HirDatabase},\n+    db::DefDatabase,\n     expr::{ExprScopes, PatId, ScopeId},\n-    generics::{GenericParams, HasGenericParams},\n-    Adt, Const, Container, DefWithBody, Enum, EnumVariant, Function, GenericDef, ImplBlock, Local,\n+    Adt, Const, Container, DefWithBody, EnumVariant, Function, GenericDef, ImplBlock, Local,\n     MacroDef, Module, ModuleDef, PerNs, Static, Struct, Trait, TypeAlias,\n };\n \n@@ -33,7 +35,7 @@ pub(crate) struct ModuleItemMap {\n \n #[derive(Debug, Clone)]\n pub(crate) struct ExprScope {\n-    owner: DefWithBody,\n+    owner: DefWithBodyId,\n     expr_scopes: Arc<ExprScopes>,\n     scope_id: ScopeId,\n }\n@@ -43,28 +45,28 @@ pub(crate) enum Scope {\n     /// All the items and imported names of a module\n     ModuleScope(ModuleItemMap),\n     /// Brings the generic parameters of an item into scope\n-    GenericParams { def: GenericDef, params: Arc<GenericParams> },\n+    GenericParams { def: GenericDefId, params: Arc<GenericParams> },\n     /// Brings `Self` in `impl` block into scope\n-    ImplBlockScope(ImplBlock),\n+    ImplBlockScope(ImplId),\n     /// Brings `Self` in enum, struct and union definitions into scope\n-    AdtScope(Adt),\n+    AdtScope(AdtId),\n     /// Local bindings\n     ExprScope(ExprScope),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub(crate) enum TypeNs {\n-    SelfType(ImplBlock),\n+    SelfType(ImplId),\n     GenericParam(u32),\n-    Adt(Adt),\n-    AdtSelfType(Adt),\n-    EnumVariant(EnumVariant),\n-    TypeAlias(TypeAlias),\n+    AdtId(AdtId),\n+    AdtSelfType(AdtId),\n+    EnumVariantId(EnumVariantId),\n+    TypeAliasId(TypeAliasId),\n     BuiltinType(BuiltinType),\n-    Trait(Trait),\n+    TraitId(TraitId),\n     // Module belong to type ns, but the resolver is used when all module paths\n     // are fully resolved.\n-    // Module(Module)\n+    // ModuleId(ModuleId)\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -85,38 +87,42 @@ pub(crate) enum ValueNs {\n \n impl Resolver {\n     /// Resolve known trait from std, like `std::futures::Future`\n-    pub(crate) fn resolve_known_trait(&self, db: &impl HirDatabase, path: &Path) -> Option<Trait> {\n+    pub(crate) fn resolve_known_trait(\n+        &self,\n+        db: &impl DefDatabase2,\n+        path: &Path,\n+    ) -> Option<TraitId> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            ModuleDefId::TraitId(it) => Some(it.into()),\n+            ModuleDefId::TraitId(it) => Some(it),\n             _ => None,\n         }\n     }\n \n     /// Resolve known struct from std, like `std::boxed::Box`\n     pub(crate) fn resolve_known_struct(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &impl DefDatabase2,\n         path: &Path,\n-    ) -> Option<Struct> {\n+    ) -> Option<StructId> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            ModuleDefId::AdtId(AdtId::StructId(it)) => Some(it.into()),\n+            ModuleDefId::AdtId(AdtId::StructId(it)) => Some(it),\n             _ => None,\n         }\n     }\n \n     /// Resolve known enum from std, like `std::result::Result`\n-    pub(crate) fn resolve_known_enum(&self, db: &impl HirDatabase, path: &Path) -> Option<Enum> {\n+    pub(crate) fn resolve_known_enum(&self, db: &impl DefDatabase2, path: &Path) -> Option<EnumId> {\n         let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            ModuleDefId::AdtId(AdtId::EnumId(it)) => Some(it.into()),\n+            ModuleDefId::AdtId(AdtId::EnumId(it)) => Some(it),\n             _ => None,\n         }\n     }\n \n     /// pub only for source-binder\n-    pub(crate) fn resolve_module_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs {\n+    pub(crate) fn resolve_module_path(&self, db: &impl DefDatabase2, path: &Path) -> PerNs {\n         let (item_map, module) = match self.module() {\n             Some(it) => it,\n             None => return PerNs::none(),\n@@ -130,7 +136,7 @@ impl Resolver {\n \n     pub(crate) fn resolve_path_in_type_ns(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &impl DefDatabase2,\n         path: &Path,\n     ) -> Option<(TypeNs, Option<usize>)> {\n         if path.is_type_relative() {\n@@ -164,13 +170,13 @@ impl Resolver {\n                 Scope::ModuleScope(m) => {\n                     let (module_def, idx) = m.crate_def_map.resolve_path(db, m.module_id, path);\n                     let res = match module_def.take_types()? {\n-                        ModuleDefId::AdtId(it) => TypeNs::Adt(it.into()),\n-                        ModuleDefId::EnumVariantId(it) => TypeNs::EnumVariant(it.into()),\n+                        ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n+                        ModuleDefId::EnumVariantId(it) => TypeNs::EnumVariantId(it),\n \n-                        ModuleDefId::TypeAliasId(it) => TypeNs::TypeAlias(it.into()),\n+                        ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n                         ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n \n-                        ModuleDefId::TraitId(it) => TypeNs::Trait(it.into()),\n+                        ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n \n                         ModuleDefId::FunctionId(_)\n                         | ModuleDefId::ConstId(_)\n@@ -186,7 +192,7 @@ impl Resolver {\n \n     pub(crate) fn resolve_path_in_type_ns_fully(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &impl DefDatabase2,\n         path: &Path,\n     ) -> Option<TypeNs> {\n         let (res, unresolved) = self.resolve_path_in_type_ns(db, path)?;\n@@ -198,7 +204,7 @@ impl Resolver {\n \n     pub(crate) fn resolve_path_in_value_ns<'p>(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &impl DefDatabase2,\n         path: &'p Path,\n     ) -> Option<ResolveValueResult> {\n         if path.is_type_relative() {\n@@ -278,9 +284,9 @@ impl Resolver {\n                         }\n                         Some(idx) => {\n                             let ty = match module_def.take_types()? {\n-                                ModuleDefId::AdtId(it) => TypeNs::Adt(it.into()),\n-                                ModuleDefId::TraitId(it) => TypeNs::Trait(it.into()),\n-                                ModuleDefId::TypeAliasId(it) => TypeNs::TypeAlias(it.into()),\n+                                ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n+                                ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n+                                ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n                                 ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n \n                                 ModuleDefId::ModuleId(_)\n@@ -300,7 +306,7 @@ impl Resolver {\n \n     pub(crate) fn resolve_path_in_value_ns_fully(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &impl DefDatabase2,\n         path: &Path,\n     ) -> Option<ValueNs> {\n         match self.resolve_path_in_value_ns(db, path)? {\n@@ -311,7 +317,7 @@ impl Resolver {\n \n     pub(crate) fn resolve_path_as_macro(\n         &self,\n-        db: &impl DefDatabase,\n+        db: &impl DefDatabase2,\n         path: &Path,\n     ) -> Option<MacroDef> {\n         let (item_map, module) = self.module()?;\n@@ -320,24 +326,23 @@ impl Resolver {\n \n     pub(crate) fn process_all_names(\n         &self,\n-        db: &impl HirDatabase,\n+        db: &impl DefDatabase2,\n         f: &mut dyn FnMut(Name, ScopeDef),\n     ) {\n         for scope in self.scopes.iter().rev() {\n             scope.process_names(db, f);\n         }\n     }\n \n-    pub(crate) fn traits_in_scope(&self, db: &impl HirDatabase) -> FxHashSet<Trait> {\n+    pub(crate) fn traits_in_scope(&self, db: &impl DefDatabase2) -> FxHashSet<TraitId> {\n         let mut traits = FxHashSet::default();\n         for scope in &self.scopes {\n             if let Scope::ModuleScope(m) = scope {\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);\n-                    traits\n-                        .extend(prelude_def_map[prelude.module_id].scope.traits().map(Trait::from));\n+                    traits.extend(prelude_def_map[prelude.module_id].scope.traits());\n                 }\n-                traits.extend(m.crate_def_map[m.module_id].scope.traits().map(Trait::from));\n+                traits.extend(m.crate_def_map[m.module_id].scope.traits());\n             }\n         }\n         traits\n@@ -367,7 +372,7 @@ impl Resolver {\n             .flat_map(|params| params.where_predicates.iter())\n     }\n \n-    pub(crate) fn generic_def(&self) -> Option<crate::generics::GenericDef> {\n+    pub(crate) fn generic_def(&self) -> Option<GenericDefId> {\n         self.scopes.iter().find_map(|scope| match scope {\n             Scope::GenericParams { def, .. } => Some(*def),\n             _ => None,\n@@ -383,18 +388,18 @@ impl Resolver {\n \n     pub(crate) fn push_generic_params_scope(\n         self,\n-        db: &impl DefDatabase,\n-        def: GenericDef,\n+        db: &impl DefDatabase2,\n+        def: GenericDefId,\n     ) -> Resolver {\n-        let params = def.generic_params(db);\n+        let params = db.generic_params(def);\n         if params.params.is_empty() {\n             self\n         } else {\n             self.push_scope(Scope::GenericParams { def, params })\n         }\n     }\n \n-    pub(crate) fn push_impl_block_scope(self, impl_block: ImplBlock) -> Resolver {\n+    pub(crate) fn push_impl_block_scope(self, impl_block: ImplId) -> Resolver {\n         self.push_scope(Scope::ImplBlockScope(impl_block))\n     }\n \n@@ -408,7 +413,7 @@ impl Resolver {\n \n     pub(crate) fn push_expr_scope(\n         self,\n-        owner: DefWithBody,\n+        owner: DefWithBodyId,\n         expr_scopes: Arc<ExprScopes>,\n         scope_id: ScopeId,\n     ) -> Resolver {\n@@ -440,7 +445,7 @@ impl From<PerNs> for ScopeDef {\n }\n \n impl Scope {\n-    fn process_names(&self, db: &impl HirDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {\n+    fn process_names(&self, db: &impl DefDatabase2, f: &mut dyn FnMut(Name, ScopeDef)) {\n         match self {\n             Scope::ModuleScope(m) => {\n                 // FIXME: should we provide `self` here?\n@@ -472,14 +477,14 @@ impl Scope {\n                 }\n             }\n             Scope::ImplBlockScope(i) => {\n-                f(name::SELF_TYPE, ScopeDef::ImplSelfType(*i));\n+                f(name::SELF_TYPE, ScopeDef::ImplSelfType((*i).into()));\n             }\n             Scope::AdtScope(i) => {\n-                f(name::SELF_TYPE, ScopeDef::AdtSelfType(*i));\n+                f(name::SELF_TYPE, ScopeDef::AdtSelfType((*i).into()));\n             }\n             Scope::ExprScope(scope) => {\n                 scope.expr_scopes.entries(scope.scope_id).iter().for_each(|e| {\n-                    let local = Local { parent: scope.owner, pat_id: e.pat() };\n+                    let local = Local { parent: scope.owner.into(), pat_id: e.pat() };\n                     f(e.name().clone(), ScopeDef::Local(local));\n                 });\n             }\n@@ -501,7 +506,7 @@ impl HasResolver for Module {\n \n impl HasResolver for Trait {\n     fn resolver(self, db: &impl DefDatabase) -> Resolver {\n-        self.module(db).resolver(db).push_generic_params_scope(db, self.into())\n+        self.module(db).resolver(db).push_generic_params_scope(db, self.id.into())\n     }\n }\n \n@@ -511,7 +516,7 @@ impl<T: Into<Adt>> HasResolver for T {\n         def.module(db)\n             .resolver(db)\n             .push_generic_params_scope(db, def.into())\n-            .push_scope(Scope::AdtScope(def))\n+            .push_scope(Scope::AdtScope(def.into()))\n     }\n }\n \n@@ -520,7 +525,7 @@ impl HasResolver for Function {\n         self.container(db)\n             .map(|c| c.resolver(db))\n             .unwrap_or_else(|| self.module(db).resolver(db))\n-            .push_generic_params_scope(db, self.into())\n+            .push_generic_params_scope(db, self.id.into())\n     }\n }\n \n@@ -551,7 +556,7 @@ impl HasResolver for TypeAlias {\n         self.container(db)\n             .map(|ib| ib.resolver(db))\n             .unwrap_or_else(|| self.module(db).resolver(db))\n-            .push_generic_params_scope(db, self.into())\n+            .push_generic_params_scope(db, self.id.into())\n     }\n }\n \n@@ -582,7 +587,7 @@ impl HasResolver for ImplBlock {\n     fn resolver(self, db: &impl DefDatabase) -> Resolver {\n         self.module(db)\n             .resolver(db)\n-            .push_generic_params_scope(db, self.into())\n-            .push_impl_block_scope(self)\n+            .push_generic_params_scope(db, self.id.into())\n+            .push_impl_block_scope(self.id)\n     }\n }"}, {"sha": "5abb8d6933bda55ea746d7954fd5e0ce0e8fbcd3", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=0102fb41337ac0442e689d410bb424d215e9a7bd", "patch": "@@ -25,8 +25,9 @@ use crate::{\n     ids::LocationCtx,\n     resolve::{HasResolver, ScopeDef, TypeNs, ValueNs},\n     ty::method_resolution::{self, implements_trait},\n-    AssocItem, Const, DefWithBody, Either, Enum, FromSource, Function, GenericParam, HasBody,\n-    HirFileId, Local, MacroDef, Module, Name, Path, Resolver, Static, Struct, Ty,\n+    Adt, AssocItem, Const, DefWithBody, Either, Enum, EnumVariant, FromSource, Function,\n+    GenericParam, HasBody, HirFileId, Local, MacroDef, Module, Name, Path, Resolver, Static,\n+    Struct, Trait, Ty, TypeAlias,\n };\n \n fn try_get_resolver_for_node(db: &impl HirDatabase, node: Source<&SyntaxNode>) -> Option<Resolver> {\n@@ -240,16 +241,18 @@ impl SourceAnalyzer {\n         path: &crate::Path,\n     ) -> Option<PathResolution> {\n         let types = self.resolver.resolve_path_in_type_ns_fully(db, &path).map(|ty| match ty {\n-            TypeNs::SelfType(it) => PathResolution::SelfType(it),\n+            TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n             TypeNs::GenericParam(idx) => PathResolution::GenericParam(GenericParam {\n-                parent: self.resolver.generic_def().unwrap(),\n+                parent: self.resolver.generic_def().unwrap().into(),\n                 idx,\n             }),\n-            TypeNs::AdtSelfType(it) | TypeNs::Adt(it) => PathResolution::Def(it.into()),\n-            TypeNs::EnumVariant(it) => PathResolution::Def(it.into()),\n-            TypeNs::TypeAlias(it) => PathResolution::Def(it.into()),\n+            TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => {\n+                PathResolution::Def(Adt::from(it).into())\n+            }\n+            TypeNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n+            TypeNs::TypeAliasId(it) => PathResolution::Def(TypeAlias::from(it).into()),\n             TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n-            TypeNs::Trait(it) => PathResolution::Def(it.into()),\n+            TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n         });\n         let values = self.resolver.resolve_path_in_value_ns_fully(db, &path).and_then(|val| {\n             let res = match val {\n@@ -392,7 +395,7 @@ impl SourceAnalyzer {\n         let std_future_path = known::std_future_future();\n \n         let std_future_trait = match self.resolver.resolve_known_trait(db, &std_future_path) {\n-            Some(it) => it,\n+            Some(it) => it.into(),\n             _ => return false,\n         };\n "}, {"sha": "684d6694610595a48c90b1afacfb78ab091ae570", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=0102fb41337ac0442e689d410bb424d215e9a7bd", "patch": "@@ -24,6 +24,7 @@ use rustc_hash::FxHashMap;\n use hir_def::{\n     path::known,\n     type_ref::{Mutability, TypeRef},\n+    AdtId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name};\n use ra_arena::map::ArenaMap;\n@@ -43,7 +44,7 @@ use crate::{\n     resolve::{HasResolver, Resolver, TypeNs},\n     ty::infer::diagnostics::InferenceDiagnostic,\n     Adt, AssocItem, ConstData, DefWithBody, FloatTy, FnData, Function, HasBody, IntTy, Path,\n-    StructField, VariantDef,\n+    StructField, Trait, VariantDef,\n };\n \n macro_rules! ty_app {\n@@ -518,17 +519,17 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             // FIXME: this should resolve assoc items as well, see this example:\n             // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n             match resolver.resolve_path_in_type_ns_fully(self.db, &path) {\n-                Some(TypeNs::Adt(Adt::Struct(it))) => it.into(),\n-                Some(TypeNs::Adt(Adt::Union(it))) => it.into(),\n+                Some(TypeNs::AdtId(AdtId::StructId(it))) => it.into(),\n+                Some(TypeNs::AdtId(AdtId::UnionId(it))) => it.into(),\n                 Some(TypeNs::AdtSelfType(adt)) => adt.into(),\n-                Some(TypeNs::EnumVariant(it)) => it.into(),\n-                Some(TypeNs::TypeAlias(it)) => it.into(),\n+                Some(TypeNs::EnumVariantId(it)) => it.into(),\n+                Some(TypeNs::TypeAliasId(it)) => it.into(),\n \n                 Some(TypeNs::SelfType(_)) |\n                 Some(TypeNs::GenericParam(_)) |\n                 Some(TypeNs::BuiltinType(_)) |\n-                Some(TypeNs::Trait(_)) |\n-                Some(TypeNs::Adt(Adt::Enum(_))) |\n+                Some(TypeNs::TraitId(_)) |\n+                Some(TypeNs::AdtId(AdtId::EnumId(_))) |\n                 None => {\n                     return (Ty::Unknown, None)\n                 }\n@@ -576,26 +577,26 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAlias> {\n         let path = known::std_iter_into_iterator();\n-        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n         trait_.associated_type_by_name(self.db, &name::ITEM_TYPE)\n     }\n \n     fn resolve_ops_try_ok(&self) -> Option<TypeAlias> {\n         let path = known::std_ops_try();\n-        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n         trait_.associated_type_by_name(self.db, &name::OK_TYPE)\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAlias> {\n         let path = known::std_future_future();\n-        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n         trait_.associated_type_by_name(self.db, &name::OUTPUT_TYPE)\n     }\n \n     fn resolve_boxed_box(&self) -> Option<Adt> {\n         let path = known::std_boxed_box();\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n-        Some(Adt::Struct(struct_))\n+        Some(Adt::Struct(struct_.into()))\n     }\n }\n "}, {"sha": "f36a2792934b9d2c40188d9dae822266ea00b7f3", "filename": "crates/ra_hir/src/ty/infer/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs?ref=0102fb41337ac0442e689d410bb424d215e9a7bd", "patch": "@@ -94,13 +94,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let is_before_last = remaining_segments.len() == 1;\n \n         match (def, is_before_last) {\n-            (TypeNs::Trait(trait_), true) => {\n+            (TypeNs::TraitId(trait_), true) => {\n                 let segment =\n                     remaining_segments.last().expect(\"there should be at least one segment here\");\n                 let trait_ref = TraitRef::from_resolved_path(\n                     self.db,\n                     &self.resolver,\n-                    trait_,\n+                    trait_.into(),\n                     resolved_segment,\n                     None,\n                 );"}, {"sha": "d4fbddac0205ac0b564d0ac6fc355c8bedeaa944", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=0102fb41337ac0442e689d410bb424d215e9a7bd", "patch": "@@ -28,8 +28,8 @@ use crate::{\n         Adt,\n     },\n     util::make_mut_slice,\n-    Const, Enum, EnumVariant, Function, ModuleDef, Path, Static, Struct, StructField, Trait,\n-    TypeAlias, Union, VariantDef,\n+    Const, Enum, EnumVariant, Function, ImplBlock, ModuleDef, Path, Static, Struct, StructField,\n+    Trait, TypeAlias, Union, VariantDef,\n };\n \n // FIXME: this is only really used in `type_for_def`, which contains a bunch of\n@@ -156,9 +156,14 @@ impl Ty {\n         remaining_segments: &[PathSegment],\n     ) -> Ty {\n         let ty = match resolution {\n-            TypeNs::Trait(trait_) => {\n-                let trait_ref =\n-                    TraitRef::from_resolved_path(db, resolver, trait_, resolved_segment, None);\n+            TypeNs::TraitId(trait_) => {\n+                let trait_ref = TraitRef::from_resolved_path(\n+                    db,\n+                    resolver,\n+                    trait_.into(),\n+                    resolved_segment,\n+                    None,\n+                );\n                 return if remaining_segments.len() == 1 {\n                     let segment = &remaining_segments[0];\n                     match trait_ref\n@@ -189,18 +194,18 @@ impl Ty {\n                 let name = resolved_segment.name.clone();\n                 Ty::Param { idx, name }\n             }\n-            TypeNs::SelfType(impl_block) => impl_block.target_ty(db),\n-            TypeNs::AdtSelfType(adt) => adt.ty(db),\n+            TypeNs::SelfType(impl_block) => ImplBlock::from(impl_block).target_ty(db),\n+            TypeNs::AdtSelfType(adt) => Adt::from(adt).ty(db),\n \n-            TypeNs::Adt(it) => Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into()),\n+            TypeNs::AdtId(it) => Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into()),\n             TypeNs::BuiltinType(it) => {\n                 Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into())\n             }\n-            TypeNs::TypeAlias(it) => {\n+            TypeNs::TypeAliasId(it) => {\n                 Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into())\n             }\n             // FIXME: report error\n-            TypeNs::EnumVariant(_) => return Ty::Unknown,\n+            TypeNs::EnumVariantId(_) => return Ty::Unknown,\n         };\n \n         Ty::from_type_relative_path(db, resolver, ty, remaining_segments)\n@@ -247,7 +252,7 @@ impl Ty {\n             Some(def) => def,\n             None => return Ty::Unknown, // this can't actually happen\n         };\n-        let predicates = db.generic_predicates_for_param(def, param_idx);\n+        let predicates = db.generic_predicates_for_param(def.into(), param_idx);\n         let traits_from_env = predicates.iter().filter_map(|pred| match pred {\n             GenericPredicate::Implemented(tr) if tr.self_ty() == &self_ty => Some(tr.trait_),\n             _ => None,\n@@ -391,11 +396,11 @@ impl TraitRef {\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n         let resolved = match resolver.resolve_path_in_type_ns_fully(db, &path)? {\n-            TypeNs::Trait(tr) => tr,\n+            TypeNs::TraitId(tr) => tr,\n             _ => return None,\n         };\n         let segment = path.segments.last().expect(\"path should have at least one segment\");\n-        Some(TraitRef::from_resolved_path(db, resolver, resolved, segment, explicit_self_ty))\n+        Some(TraitRef::from_resolved_path(db, resolver, resolved.into(), segment, explicit_self_ty))\n     }\n \n     pub(super) fn from_resolved_path("}, {"sha": "26dd06171c31ea03b9190c7fe311d662de91dadb", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=0102fb41337ac0442e689d410bb424d215e9a7bd", "patch": "@@ -224,7 +224,9 @@ fn iterate_trait_method_candidates<T>(\n         .trait_predicates_for_self_ty(&ty.value)\n         .map(|tr| tr.trait_)\n         .flat_map(|t| t.all_super_traits(db));\n-    let traits = inherent_trait.chain(traits_from_env).chain(resolver.traits_in_scope(db));\n+    let traits = inherent_trait\n+        .chain(traits_from_env)\n+        .chain(resolver.traits_in_scope(db).into_iter().map(Trait::from));\n     'traits: for t in traits {\n         let data = t.trait_data(db);\n "}, {"sha": "6c2d5b2a9f7be9bbdb1aa293ad054dc99bf55977", "filename": "crates/ra_hir_def/src/traits.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0102fb41337ac0442e689d410bb424d215e9a7bd/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs?ref=0102fb41337ac0442e689d410bb424d215e9a7bd", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::ast::{self, NameOwner};\n \n use crate::{\n     db::DefDatabase2, AssocItemId, AstItemDef, ConstLoc, ContainerId, FunctionLoc, Intern, TraitId,\n-    TypeAliasLoc,\n+    TypeAliasId, TypeAliasLoc,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -56,4 +56,11 @@ impl TraitData {\n         };\n         Arc::new(TraitData { name, items, auto })\n     }\n+\n+    pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {\n+        self.items.iter().filter_map(|item| match item {\n+            AssocItemId::TypeAliasId(t) => Some(*t),\n+            _ => None,\n+        })\n+    }\n }"}]}