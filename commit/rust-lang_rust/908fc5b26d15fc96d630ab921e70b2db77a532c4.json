{"sha": "908fc5b26d15fc96d630ab921e70b2db77a532c4", "node_id": "C_kwDOAAsO6NoAKDkwOGZjNWIyNmQxNWZjOTZkNjMwYWI5MjFlNzBiMmRiNzdhNTMyYzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-10T23:50:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-10T23:50:18Z"}, "message": "Auto merge of #99174 - scottmcm:reoptimize-layout-array, r=joshtriplett\n\nReoptimize layout array\n\nThis way it's one check instead of two, so hopefully (cc #99117) it'll be simpler for rustc perf too \ud83e\udd1e\n\nQuick demonstration:\n```rust\npub fn demo(n: usize) -> Option<Layout> {\n    Layout::array::<i32>(n).ok()\n}\n```\n\nNightly: <https://play.rust-lang.org/?version=nightly&mode=release&edition=2021&gist=e97bf33508aa03f38968101cdeb5322d>\n```nasm\n\tmov\trax, rdi\n\tmov\tecx, 4\n\tmul\trcx\n\tseto\tcl\n\tmovabs\trdx, 9223372036854775805\n\txor\tesi, esi\n\tcmp\trax, rdx\n\tsetb\tsil\n\tshl\trsi, 2\n\txor\tedx, edx\n\ttest\tcl, cl\n\tcmove\trdx, rsi\n\tret\n```\n\nThis PR (note no `mul`, in addition to being much shorter):\n```nasm\n\txor\tedx, edx\n\tlea\trax, [4*rcx]\n\tshr\trcx, 61\n\tsete\tdl\n\tshl\trdx, 2\n\tret\n```\n\nThis is built atop `@CAD97` 's #99136; the new changes are cb8aba66ef6a0e17f08a0574e4820653e31b45a0.\n\nI added a bunch more tests for `Layout::from_size_align` and `Layout::array` too.", "tree": {"sha": "e41b2f2e13cb2eaa1596013bcebdbb440f41c38c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e41b2f2e13cb2eaa1596013bcebdbb440f41c38c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/908fc5b26d15fc96d630ab921e70b2db77a532c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/908fc5b26d15fc96d630ab921e70b2db77a532c4", "html_url": "https://github.com/rust-lang/rust/commit/908fc5b26d15fc96d630ab921e70b2db77a532c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/908fc5b26d15fc96d630ab921e70b2db77a532c4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29e4a9ee0253cd39e552a77f51f11f9a5f1c41e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e4a9ee0253cd39e552a77f51f11f9a5f1c41e6", "html_url": "https://github.com/rust-lang/rust/commit/29e4a9ee0253cd39e552a77f51f11f9a5f1c41e6"}, {"sha": "a32305a80fd1409b054e97836321bd0621b142fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a32305a80fd1409b054e97836321bd0621b142fd", "html_url": "https://github.com/rust-lang/rust/commit/a32305a80fd1409b054e97836321bd0621b142fd"}], "stats": {"total": 125, "additions": 115, "deletions": 10}, "files": [{"sha": "3473ac09e956fe3a95aec2f497074ebffb90ad5f", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/908fc5b26d15fc96d630ab921e70b2db77a532c4/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/908fc5b26d15fc96d630ab921e70b2db77a532c4/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=908fc5b26d15fc96d630ab921e70b2db77a532c4", "patch": "@@ -72,9 +72,8 @@ impl Layout {\n         Layout::from_size_valid_align(size, unsafe { ValidAlign::new_unchecked(align) })\n     }\n \n-    /// Internal helper constructor to skip revalidating alignment validity.\n-    #[inline]\n-    const fn from_size_valid_align(size: usize, align: ValidAlign) -> Result<Self, LayoutError> {\n+    #[inline(always)]\n+    const fn max_size_for_align(align: ValidAlign) -> usize {\n         // (power-of-two implies align != 0.)\n \n         // Rounded up size is:\n@@ -89,7 +88,13 @@ impl Layout {\n         //\n         // Above implies that checking for summation overflow is both\n         // necessary and sufficient.\n-        if size > isize::MAX as usize - (align.as_nonzero().get() - 1) {\n+        isize::MAX as usize - (align.as_usize() - 1)\n+    }\n+\n+    /// Internal helper constructor to skip revalidating alignment validity.\n+    #[inline]\n+    const fn from_size_valid_align(size: usize, align: ValidAlign) -> Result<Self, LayoutError> {\n+        if size > Self::max_size_for_align(align) {\n             return Err(LayoutError);\n         }\n \n@@ -128,7 +133,7 @@ impl Layout {\n                   without modifying the layout\"]\n     #[inline]\n     pub const fn align(&self) -> usize {\n-        self.align.as_nonzero().get()\n+        self.align.as_usize()\n     }\n \n     /// Constructs a `Layout` suitable for holding a value of type `T`.\n@@ -410,13 +415,33 @@ impl Layout {\n \n     /// Creates a layout describing the record for a `[T; n]`.\n     ///\n-    /// On arithmetic overflow, returns `LayoutError`.\n+    /// On arithmetic overflow or when the total size would exceed\n+    /// `isize::MAX`, returns `LayoutError`.\n     #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n     #[inline]\n     pub fn array<T>(n: usize) -> Result<Self, LayoutError> {\n-        let array_size = mem::size_of::<T>().checked_mul(n).ok_or(LayoutError)?;\n-        // The safe constructor is called here to enforce the isize size limit.\n-        Layout::from_size_valid_align(array_size, ValidAlign::of::<T>())\n+        // Reduce the amount of code we need to monomorphize per `T`.\n+        return inner(mem::size_of::<T>(), ValidAlign::of::<T>(), n);\n+\n+        #[inline]\n+        fn inner(element_size: usize, align: ValidAlign, n: usize) -> Result<Layout, LayoutError> {\n+            // We need to check two things about the size:\n+            //  - That the total size won't overflow a `usize`, and\n+            //  - That the total size still fits in an `isize`.\n+            // By using division we can check them both with a single threshold.\n+            // That'd usually be a bad idea, but thankfully here the element size\n+            // and alignment are constants, so the compiler will fold all of it.\n+            if element_size != 0 && n > Layout::max_size_for_align(align) / element_size {\n+                return Err(LayoutError);\n+            }\n+\n+            let array_size = element_size * n;\n+\n+            // SAFETY: We just checked above that the `array_size` will not\n+            // exceed `isize::MAX` even when rounded up to the alignment.\n+            // And `ValidAlign` guarantees it's a power of two.\n+            unsafe { Ok(Layout::from_size_align_unchecked(array_size, align.as_usize())) }\n+        }\n     }\n }\n "}, {"sha": "b9ccc0b4c799f3763ce520805d16d034744bc24f", "filename": "library/core/src/mem/valid_align.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/908fc5b26d15fc96d630ab921e70b2db77a532c4/library%2Fcore%2Fsrc%2Fmem%2Fvalid_align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/908fc5b26d15fc96d630ab921e70b2db77a532c4/library%2Fcore%2Fsrc%2Fmem%2Fvalid_align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fvalid_align.rs?ref=908fc5b26d15fc96d630ab921e70b2db77a532c4", "patch": "@@ -35,10 +35,15 @@ impl ValidAlign {\n         unsafe { mem::transmute::<usize, ValidAlign>(align) }\n     }\n \n+    #[inline]\n+    pub(crate) const fn as_usize(self) -> usize {\n+        self.0 as usize\n+    }\n+\n     #[inline]\n     pub(crate) const fn as_nonzero(self) -> NonZeroUsize {\n         // SAFETY: All the discriminants are non-zero.\n-        unsafe { NonZeroUsize::new_unchecked(self.0 as usize) }\n+        unsafe { NonZeroUsize::new_unchecked(self.as_usize()) }\n     }\n \n     /// Returns the base 2 logarithm of the alignment."}, {"sha": "3ceaeadcec6c36d8bc0ca34d78a06e185ecdc62c", "filename": "library/core/tests/alloc.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/908fc5b26d15fc96d630ab921e70b2db77a532c4/library%2Fcore%2Ftests%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/908fc5b26d15fc96d630ab921e70b2db77a532c4/library%2Fcore%2Ftests%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Falloc.rs?ref=908fc5b26d15fc96d630ab921e70b2db77a532c4", "patch": "@@ -1,4 +1,5 @@\n use core::alloc::Layout;\n+use core::mem::size_of;\n use core::ptr::{self, NonNull};\n \n #[test]\n@@ -12,6 +13,49 @@ fn const_unchecked_layout() {\n     assert_eq!(Some(DANGLING), NonNull::new(ptr::invalid_mut(ALIGN)));\n }\n \n+#[test]\n+fn layout_round_up_to_align_edge_cases() {\n+    const MAX_SIZE: usize = isize::MAX as usize;\n+\n+    for shift in 0..usize::BITS {\n+        let align = 1_usize << shift;\n+        let edge = (MAX_SIZE + 1) - align;\n+        let low = edge.saturating_sub(10);\n+        let high = edge.saturating_add(10);\n+        assert!(Layout::from_size_align(low, align).is_ok());\n+        assert!(Layout::from_size_align(high, align).is_err());\n+        for size in low..=high {\n+            assert_eq!(\n+                Layout::from_size_align(size, align).is_ok(),\n+                size.next_multiple_of(align) <= MAX_SIZE,\n+            );\n+        }\n+    }\n+}\n+\n+#[test]\n+fn layout_array_edge_cases() {\n+    for_type::<i64>();\n+    for_type::<[i32; 0b10101]>();\n+    for_type::<[u8; 0b1010101]>();\n+\n+    // Make sure ZSTs don't lead to divide-by-zero\n+    assert_eq!(Layout::array::<()>(usize::MAX).unwrap(), Layout::from_size_align(0, 1).unwrap());\n+\n+    fn for_type<T>() {\n+        const MAX_SIZE: usize = isize::MAX as usize;\n+\n+        let edge = (MAX_SIZE + 1) / size_of::<T>();\n+        let low = edge.saturating_sub(10);\n+        let high = edge.saturating_add(10);\n+        assert!(Layout::array::<T>(low).is_ok());\n+        assert!(Layout::array::<T>(high).is_err());\n+        for n in low..=high {\n+            assert_eq!(Layout::array::<T>(n).is_ok(), n * size_of::<T>() <= MAX_SIZE);\n+        }\n+    }\n+}\n+\n #[test]\n fn layout_debug_shows_log2_of_alignment() {\n     // `Debug` is not stable, but here's what it does right now"}, {"sha": "d067cc10a948c3ea2424a943fa397dfb00dc5e6c", "filename": "src/test/codegen/layout-size-checks.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/908fc5b26d15fc96d630ab921e70b2db77a532c4/src%2Ftest%2Fcodegen%2Flayout-size-checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/908fc5b26d15fc96d630ab921e70b2db77a532c4/src%2Ftest%2Fcodegen%2Flayout-size-checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flayout-size-checks.rs?ref=908fc5b26d15fc96d630ab921e70b2db77a532c4", "patch": "@@ -0,0 +1,31 @@\n+// compile-flags: -O\n+// only-x86_64\n+// ignore-debug: the debug assertions get in the way\n+\n+#![crate_type = \"lib\"]\n+\n+use std::alloc::Layout;\n+\n+type RGB48 = [u16; 3];\n+\n+// CHECK-LABEL: @layout_array_rgb48\n+#[no_mangle]\n+pub fn layout_array_rgb48(n: usize) -> Layout {\n+    // CHECK-NOT: llvm.umul.with.overflow.i64\n+    // CHECK: icmp ugt i64 %n, 1537228672809129301\n+    // CHECK-NOT: llvm.umul.with.overflow.i64\n+    // CHECK: mul nuw nsw i64 %n, 6\n+    // CHECK-NOT: llvm.umul.with.overflow.i64\n+    Layout::array::<RGB48>(n).unwrap()\n+}\n+\n+// CHECK-LABEL: @layout_array_i32\n+#[no_mangle]\n+pub fn layout_array_i32(n: usize) -> Layout {\n+    // CHECK-NOT: llvm.umul.with.overflow.i64\n+    // CHECK: icmp ugt i64 %n, 2305843009213693951\n+    // CHECK-NOT: llvm.umul.with.overflow.i64\n+    // CHECK: shl nuw nsw i64 %n, 2\n+    // CHECK-NOT: llvm.umul.with.overflow.i64\n+    Layout::array::<i32>(n).unwrap()\n+}"}]}