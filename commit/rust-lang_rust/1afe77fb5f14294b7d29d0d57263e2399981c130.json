{"sha": "1afe77fb5f14294b7d29d0d57263e2399981c130", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhZmU3N2ZiNWYxNDI5NGI3ZDI5ZDBkNTcyNjNlMjM5OTk4MWMxMzA=", "commit": {"author": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-04-15T21:55:59Z"}, "committer": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-04-15T21:55:59Z"}, "message": "Cleaned up throughout std::path's docs\n\nPart of #29368.\n* added missing links\n* updated method summaries to use 3rd person style\n* added missing periods in `Component`'s variant summaries\n* use standard iterator boilerplate in `Components`' and `Iter`'s docs\n* added example to `Iter::as_path`, adapted from `Components::as_path`'s\n  example\n* consolidated examples for `Path::file_name`\n* some other small fixes", "tree": {"sha": "2337354f5247899d5e6ff5bebfdc5a803fa7ee8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2337354f5247899d5e6ff5bebfdc5a803fa7ee8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1afe77fb5f14294b7d29d0d57263e2399981c130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1afe77fb5f14294b7d29d0d57263e2399981c130", "html_url": "https://github.com/rust-lang/rust/commit/1afe77fb5f14294b7d29d0d57263e2399981c130", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1afe77fb5f14294b7d29d0d57263e2399981c130/comments", "author": null, "committer": null, "parents": [{"sha": "ae23e65eb8f207d0c9be82e7f2043d98a32d4f57", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae23e65eb8f207d0c9be82e7f2043d98a32d4f57", "html_url": "https://github.com/rust-lang/rust/commit/ae23e65eb8f207d0c9be82e7f2043d98a32d4f57"}], "stats": {"total": 125, "additions": 78, "deletions": 47}, "files": [{"sha": "b751122e970d6473fc731da558e3d2c2522812c3", "filename": "src/libstd/path.rs", "status": "modified", "additions": 78, "deletions": 47, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/1afe77fb5f14294b7d29d0d57263e2399981c130/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1afe77fb5f14294b7d29d0d57263e2399981c130/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=1afe77fb5f14294b7d29d0d57263e2399981c130", "patch": "@@ -370,13 +370,15 @@ pub struct PrefixComponent<'a> {\n }\n \n impl<'a> PrefixComponent<'a> {\n-    /// The parsed prefix data.\n+    /// Returns the parsed prefix data.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn kind(&self) -> Prefix<'a> {\n         self.parsed\n     }\n \n-    /// The raw `OsStr` slice for this prefix.\n+    /// Returns the raw [`OsStr`] slice for this prefix.\n+    ///\n+    /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(&self) -> &'a OsStr {\n         self.raw\n@@ -446,25 +448,25 @@ pub enum Component<'a> {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")] PrefixComponent<'a>\n     ),\n \n-    /// The root directory component, appears after any prefix and before anything else\n+    /// The root directory component, appears after any prefix and before anything else.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     RootDir,\n \n-    /// A reference to the current directory, i.e. `.`\n+    /// A reference to the current directory, i.e. `.`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     CurDir,\n \n-    /// A reference to the parent directory, i.e. `..`\n+    /// A reference to the parent directory, i.e. `..`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     ParentDir,\n \n-    /// A normal component, i.e. `a` and `b` in `a/b`\n+    /// A normal component, e.g. `a` and `b` in `a/b`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Normal(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr),\n }\n \n impl<'a> Component<'a> {\n-    /// Extracts the underlying `OsStr` slice.\n+    /// Extracts the underlying [`OsStr`] slice.\n     ///\n     /// # Examples\n     ///\n@@ -475,6 +477,8 @@ impl<'a> Component<'a> {\n     /// let components: Vec<_> = path.components().map(|comp| comp.as_os_str()).collect();\n     /// assert_eq!(&components, &[\".\", \"tmp\", \"foo\", \"bar.txt\"]);\n     /// ```\n+    ///\n+    /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(self) -> &'a OsStr {\n         match self {\n@@ -494,12 +498,10 @@ impl<'a> AsRef<OsStr> for Component<'a> {\n     }\n }\n \n-/// The core iterator giving the components of a path.\n+/// An interator over the [`Component`]s of a [`Path`].\n ///\n-/// See the module documentation for an in-depth explanation of components and\n-/// their role in the API.\n-///\n-/// This `struct` is created by the [`path::Path::components`] method.\n+/// This `struct` is created by the [`components`] method on [`Path`].\n+/// See its documentation for more.\n ///\n /// # Examples\n ///\n@@ -513,7 +515,9 @@ impl<'a> AsRef<OsStr> for Component<'a> {\n /// }\n /// ```\n ///\n-/// [`path::Path::components`]: struct.Path.html#method.components\n+/// [`Component`]: enum.Component.html\n+/// [`components`]: struct.Path.html#method.components\n+/// [`Path`]: struct.Path.html\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Components<'a> {\n@@ -534,9 +538,15 @@ pub struct Components<'a> {\n     back: State,\n }\n \n-/// An iterator over the components of a path, as [`OsStr`] slices.\n+/// An iterator over the [`Component`]s of a [`Path`], as [`OsStr`] slices.\n ///\n+/// This `struct` is created by the [`iter`] method on [`Path`].\n+/// See its documentation for more.\n+///\n+/// [`Component`]: enum.Component.html\n+/// [`iter`]: struct.Path.html#method.iter\n /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n+/// [`Path`]: struct.Path.html\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a> {\n@@ -762,6 +772,18 @@ impl<'a> fmt::Debug for Iter<'a> {\n \n impl<'a> Iter<'a> {\n     /// Extracts a slice corresponding to the portion of the path remaining for iteration.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let mut iter = Path::new(\"/tmp/foo/bar.txt\").iter();\n+    /// iter.next();\n+    /// iter.next();\n+    ///\n+    /// assert_eq!(Path::new(\"foo/bar.txt\"), iter.as_path());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_path(&self) -> &'a Path {\n         self.inner.as_path()\n@@ -1067,9 +1089,10 @@ impl PathBuf {\n \n     /// Truncate `self` to [`self.parent`].\n     ///\n-    /// Returns false and does nothing if [`self.file_name`] is `None`.\n+    /// Returns `false` and does nothing if [`self.file_name`] is [`None`].\n     /// Otherwise, returns `true`.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     /// [`self.parent`]: struct.PathBuf.html#method.parent\n     /// [`self.file_name`]: struct.PathBuf.html#method.file_name\n     ///\n@@ -1132,10 +1155,11 @@ impl PathBuf {\n \n     /// Updates [`self.extension`] to `extension`.\n     ///\n-    /// If [`self.file_name`] is `None`, does nothing and returns `false`.\n+    /// Returns `false` and does nothing if [`self.file_name`] is [`None`],\n+    /// returns `true` and updates the extension otherwise.\n     ///\n-    /// Otherwise, returns `true`; if [`self.extension`] is [`None`], the\n-    /// extension is added; otherwise it is replaced.\n+    /// If [`self.extension`] is [`None`], the extension is added; otherwise\n+    /// it is replaced.\n     ///\n     /// [`self.file_name`]: struct.PathBuf.html#method.file_name\n     /// [`self.extension`]: struct.PathBuf.html#method.extension\n@@ -1195,7 +1219,10 @@ impl PathBuf {\n         self.inner\n     }\n \n-    /// Converts this `PathBuf` into a boxed `Path`.\n+    /// Converts this `PathBuf` into a [boxed][`Box`] [`Path`].\n+    ///\n+    /// [`Box`]: ../../std/boxed/struct.Box.html\n+    /// [`Path`]: struct.Path.html\n     #[unstable(feature = \"into_boxed_path\", issue = \"40380\")]\n     pub fn into_boxed_path(self) -> Box<Path> {\n         unsafe { mem::transmute(self.inner.into_boxed_os_str()) }\n@@ -1402,10 +1429,14 @@ pub struct Path {\n     inner: OsStr,\n }\n \n-/// An error returned from the [`Path::strip_prefix`] method indicating that the\n-/// prefix was not found in `self`.\n+/// An error returned from [`Path::strip_prefix`][`strip_prefix`] if the prefix\n+/// was not found.\n+///\n+/// This `struct` is created by the [`strip_prefix`] method on [`Path`].\n+/// See its documentation for more.\n ///\n-/// [`Path::strip_prefix`]: struct.Path.html#method.strip_prefix\n+/// [`strip_prefix`]: struct.Path.html#method.strip_prefix\n+/// [`Path`]: struct.Path.html\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\n pub struct StripPrefixError(());\n@@ -1421,7 +1452,7 @@ impl Path {\n         os_str_as_u8_slice(&self.inner)\n     }\n \n-    /// Directly wrap a string slice as a `Path` slice.\n+    /// Directly wraps a string slice as a `Path` slice.\n     ///\n     /// This is a cost-free conversion.\n     ///\n@@ -1525,10 +1556,11 @@ impl Path {\n         PathBuf::from(self.inner.to_os_string())\n     }\n \n-    /// A path is *absolute* if it is independent of the current directory.\n+    /// Returns `true` if the `Path` is absolute, i.e. if it is independent of\n+    /// the current directory.\n     ///\n     /// * On Unix, a path is absolute if it starts with the root, so\n-    /// `is_absolute` and `has_root` are equivalent.\n+    /// `is_absolute` and [`has_root`] are equivalent.\n     ///\n     /// * On Windows, a path is absolute if it has a prefix and starts with the\n     /// root: `c:\\windows` is absolute, while `c:temp` and `\\temp` are not.\n@@ -1540,14 +1572,18 @@ impl Path {\n     ///\n     /// assert!(!Path::new(\"foo.txt\").is_absolute());\n     /// ```\n+    ///\n+    /// [`has_root`]: #method.has_root\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n     pub fn is_absolute(&self) -> bool {\n         // FIXME: Remove target_os = \"redox\" and allow Redox prefixes\n         self.has_root() && (cfg!(unix) || cfg!(target_os = \"redox\") || self.prefix().is_some())\n     }\n \n-    /// A path is *relative* if it is not absolute.\n+    /// Return `false` if the `Path` is relative, i.e. not absolute.\n+    ///\n+    /// See [`is_absolute`]'s documentation for more details.\n     ///\n     /// # Examples\n     ///\n@@ -1556,6 +1592,8 @@ impl Path {\n     ///\n     /// assert!(Path::new(\"foo.txt\").is_relative());\n     /// ```\n+    ///\n+    /// [`is_absolute`]: #method.is_absolute\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_relative(&self) -> bool {\n         !self.is_absolute()\n@@ -1565,7 +1603,7 @@ impl Path {\n         self.components().prefix\n     }\n \n-    /// A path has a root if the body of the path begins with the directory separator.\n+    /// Returns `true` if the `Path` has a root.\n     ///\n     /// * On Unix, a path has a root if it begins with `/`.\n     ///\n@@ -1586,7 +1624,7 @@ impl Path {\n         self.components().has_root()\n     }\n \n-    /// The path without its final component, if any.\n+    /// Returns the `Path` without its final component, if there is one.\n     ///\n     /// Returns [`None`] if the path terminates in a root or prefix.\n     ///\n@@ -1619,9 +1657,9 @@ impl Path {\n         })\n     }\n \n-    /// The final component of the path, if it is a normal file.\n+    /// Returns the final component of the `Path`, if it is a normal file.\n     ///\n-    /// If the path terminates in `..`, `file_name` will return [`None`].\n+    /// Returns [`None`] If the path terminates in `..`.\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n@@ -1631,18 +1669,7 @@ impl Path {\n     /// use std::path::Path;\n     /// use std::ffi::OsStr;\n     ///\n-    /// let path = Path::new(\"foo.txt\");\n-    /// let os_str = OsStr::new(\"foo.txt\");\n-    ///\n-    /// assert_eq!(Some(os_str), path.file_name());\n-    /// ```\n-    ///\n-    /// # Other examples\n-    ///\n-    /// ```\n-    /// use std::path::Path;\n-    /// use std::ffi::OsStr;\n-    ///\n+    /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt\").file_name());\n     /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.\").file_name());\n     /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.//\").file_name());\n     /// assert_eq!(None, Path::new(\"foo.txt/..\").file_name());\n@@ -1869,7 +1896,7 @@ impl Path {\n         buf\n     }\n \n-    /// Produce an iterator over the components of the path.\n+    /// Produces an iterator over the components of the path.\n     ///\n     /// # Examples\n     ///\n@@ -1896,7 +1923,7 @@ impl Path {\n         }\n     }\n \n-    /// Produce an iterator over the path's components viewed as [`OsStr`] slices.\n+    /// Produces an iterator over the path's components viewed as [`OsStr`] slices.\n     ///\n     /// [`OsStr`]: ../ffi/struct.OsStr.html\n     ///\n@@ -1936,7 +1963,7 @@ impl Path {\n         Display { path: self }\n     }\n \n-    /// Query the file system to get information about a file, directory, etc.\n+    /// Queries the file system to get information about a file, directory, etc.\n     ///\n     /// This function will traverse symbolic links to query information about the\n     /// destination file.\n@@ -1959,7 +1986,7 @@ impl Path {\n         fs::metadata(self)\n     }\n \n-    /// Query the metadata about a file without following symlinks.\n+    /// Queries the metadata about a file without following symlinks.\n     ///\n     /// This is an alias to [`fs::symlink_metadata`].\n     ///\n@@ -2096,7 +2123,11 @@ impl Path {\n         fs::metadata(self).map(|m| m.is_dir()).unwrap_or(false)\n     }\n \n-    /// Converts a `Box<Path>` into a `PathBuf` without copying or allocating.\n+    /// Converts a [`Box<Path>`][`Box`] into a [`PathBuf`] without copying or\n+    /// allocating.\n+    ///\n+    /// [`Box`]: ../../std/boxed/struct.Box.html\n+    /// [`PathBuf`]: struct.PathBuf.html\n     #[unstable(feature = \"into_boxed_path\", issue = \"40380\")]\n     pub fn into_path_buf(self: Box<Path>) -> PathBuf {\n         let inner: Box<OsStr> = unsafe { mem::transmute(self) };"}]}