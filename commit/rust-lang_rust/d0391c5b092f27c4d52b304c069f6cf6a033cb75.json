{"sha": "d0391c5b092f27c4d52b304c069f6cf6a033cb75", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwMzkxYzViMDkyZjI3YzRkNTJiMzA0YzA2OWY2Y2Y2YTAzM2NiNzU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T19:47:18Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T19:48:46Z"}, "message": "libcore: De-export libcore. rs=deexporting", "tree": {"sha": "3beedf6df902d36a5418e4f8004ee05171fe723f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3beedf6df902d36a5418e4f8004ee05171fe723f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0391c5b092f27c4d52b304c069f6cf6a033cb75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0391c5b092f27c4d52b304c069f6cf6a033cb75", "html_url": "https://github.com/rust-lang/rust/commit/d0391c5b092f27c4d52b304c069f6cf6a033cb75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0391c5b092f27c4d52b304c069f6cf6a033cb75/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ead38bae7ed244f5df9e71ebd1f739d5de0feb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ead38bae7ed244f5df9e71ebd1f739d5de0feb7", "html_url": "https://github.com/rust-lang/rust/commit/4ead38bae7ed244f5df9e71ebd1f739d5de0feb7"}], "stats": {"total": 163, "additions": 73, "deletions": 90}, "files": [{"sha": "be95148e5540c4da17d8b5bfedd9413a48afcf8d", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=d0391c5b092f27c4d52b304c069f6cf6a033cb75", "patch": "@@ -29,16 +29,14 @@ use vec;\n \n #[abi = \"cdecl\"]\n pub extern mod rustrt {\n-    #[legacy_exports];\n-    unsafe fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n-                                        ++v: **vec::raw::VecRepr,\n-                                        ++n: libc::size_t);\n+    pub unsafe fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n+                                            ++v: **vec::raw::VecRepr,\n+                                            ++n: libc::size_t);\n }\n \n #[abi = \"rust-intrinsic\"]\n pub extern mod rusti {\n-    #[legacy_exports];\n-    fn move_val_init<T>(dst: &mut T, -src: T);\n+    pub fn move_val_init<T>(dst: &mut T, -src: T);\n }\n \n /// Returns the number of elements the vector can hold without reallocating"}, {"sha": "8428484f6300a4fe0e599fca6e50612c0c9babc5", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=d0391c5b092f27c4d52b304c069f6cf6a033cb75", "patch": "@@ -161,9 +161,8 @@ pub unsafe fn annihilate() {\n \n /// Bindings to the runtime\n extern mod rustrt {\n-    #[legacy_exports];\n     #[rust_stack]\n     // FIXME (#4386): Unable to make following method private.\n-    /* priv */ unsafe fn rust_get_task() -> *c_void;\n+    pub unsafe fn rust_get_task() -> *c_void;\n }\n "}, {"sha": "fe881f1830ab7645c08535ddf5721bfa1c268399", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 38, "deletions": 40, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=d0391c5b092f27c4d52b304c069f6cf6a033cb75", "patch": "@@ -488,15 +488,13 @@ impl<T: Copy> DList<T> {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n-\n     use dlist::{DList, concat, from_vec, new_dlist_node};\n     use iter;\n     use option::{None, Some};\n     use vec;\n \n     #[test]\n-    fn test_dlist_concat() {\n+    pub fn test_dlist_concat() {\n         let a = from_vec(~[1,2]);\n         let b = from_vec(~[3,4]);\n         let c = from_vec(~[5,6]);\n@@ -516,7 +514,7 @@ mod tests {\n         abcd.assert_consistent(); assert abcd.is_empty();\n     }\n     #[test]\n-    fn test_dlist_append() {\n+    pub fn test_dlist_append() {\n         let a = from_vec(~[1,2,3]);\n         let b = from_vec(~[4,5,6]);\n         a.append(b);\n@@ -532,7 +530,7 @@ mod tests {\n         a.assert_consistent(); assert a.is_empty();\n     }\n     #[test]\n-    fn test_dlist_append_empty() {\n+    pub fn test_dlist_append_empty() {\n         let a = from_vec(~[1,2,3]);\n         let b = DList::<int>();\n         a.append(b);\n@@ -545,7 +543,7 @@ mod tests {\n         a.assert_consistent(); assert a.is_empty();\n     }\n     #[test]\n-    fn test_dlist_append_to_empty() {\n+    pub fn test_dlist_append_to_empty() {\n         let a = DList::<int>();\n         let b = from_vec(~[4,5,6]);\n         a.append(b);\n@@ -558,7 +556,7 @@ mod tests {\n         a.assert_consistent(); assert a.is_empty();\n     }\n     #[test]\n-    fn test_dlist_append_two_empty() {\n+    pub fn test_dlist_append_two_empty() {\n         let a = DList::<int>();\n         let b = DList::<int>();\n         a.append(b);\n@@ -570,19 +568,19 @@ mod tests {\n     #[test]\n     #[ignore(cfg(windows))]\n     #[should_fail]\n-    fn test_dlist_append_self() {\n+    pub fn test_dlist_append_self() {\n         let a = DList::<int>();\n         a.append(a);\n     }\n     #[test]\n     #[ignore(cfg(windows))]\n     #[should_fail]\n-    fn test_dlist_prepend_self() {\n+    pub fn test_dlist_prepend_self() {\n         let a = DList::<int>();\n         a.prepend(a);\n     }\n     #[test]\n-    fn test_dlist_prepend() {\n+    pub fn test_dlist_prepend() {\n         let a = from_vec(~[1,2,3]);\n         let b = from_vec(~[4,5,6]);\n         b.prepend(a);\n@@ -598,7 +596,7 @@ mod tests {\n         b.assert_consistent(); assert b.is_empty();\n     }\n     #[test]\n-    fn test_dlist_reverse() {\n+    pub fn test_dlist_reverse() {\n         let a = from_vec(~[5,4,3,2,1]);\n         a.reverse();\n         assert a.len() == 5;\n@@ -610,14 +608,14 @@ mod tests {\n         a.assert_consistent(); assert a.is_empty();\n     }\n     #[test]\n-    fn test_dlist_reverse_empty() {\n+    pub fn test_dlist_reverse_empty() {\n         let a = DList::<int>();\n         a.reverse();\n         assert a.len() == 0;\n         a.assert_consistent();\n     }\n     #[test]\n-    fn test_dlist_each_node() {\n+    pub fn test_dlist_each_node() {\n         let a = from_vec(~[1,2,4,5]);\n         for a.each_node |nobe| {\n             if nobe.data > 3 {\n@@ -634,28 +632,28 @@ mod tests {\n         a.assert_consistent(); assert a.is_empty();\n     }\n     #[test]\n-    fn test_dlist_clear() {\n+    pub fn test_dlist_clear() {\n         let a = from_vec(~[5,4,3,2,1]);\n         a.clear();\n         assert a.len() == 0;\n         a.assert_consistent();\n     }\n     #[test]\n-    fn test_dlist_is_empty() {\n+    pub fn test_dlist_is_empty() {\n         let empty = DList::<int>();\n         let full1 = from_vec(~[1,2,3]);\n         assert empty.is_empty();\n         assert !full1.is_empty();\n     }\n     #[test]\n-    fn test_dlist_head_tail() {\n+    pub fn test_dlist_head_tail() {\n         let l = from_vec(~[1,2,3]);\n         assert l.head() == 1;\n         assert l.tail() == 3;\n         assert l.len() == 3;\n     }\n     #[test]\n-    fn test_dlist_pop() {\n+    pub fn test_dlist_pop() {\n         let l = from_vec(~[1,2,3]);\n         assert l.pop().get() == 1;\n         assert l.tail() == 3;\n@@ -668,7 +666,7 @@ mod tests {\n         assert l.pop().is_none();\n     }\n     #[test]\n-    fn test_dlist_pop_tail() {\n+    pub fn test_dlist_pop_tail() {\n         let l = from_vec(~[1,2,3]);\n         assert l.pop_tail().get() == 3;\n         assert l.tail() == 2;\n@@ -681,7 +679,7 @@ mod tests {\n         assert l.pop_tail().is_none();\n     }\n     #[test]\n-    fn test_dlist_push() {\n+    pub fn test_dlist_push() {\n         let l = DList::<int>();\n         l.push(1);\n         assert l.head() == 1;\n@@ -695,7 +693,7 @@ mod tests {\n         assert l.len() == 3;\n     }\n     #[test]\n-    fn test_dlist_push_head() {\n+    pub fn test_dlist_push_head() {\n         let l = DList::<int>();\n         l.push_head(3);\n         assert l.head() == 3;\n@@ -709,12 +707,12 @@ mod tests {\n         assert l.len() == 3;\n     }\n     #[test]\n-    fn test_dlist_foldl() {\n+    pub fn test_dlist_foldl() {\n         let l = from_vec(vec::from_fn(101, |x|x));\n         assert iter::foldl(&l, 0, |accum,elem| *accum+*elem) == 5050;\n     }\n     #[test]\n-    fn test_dlist_break_early() {\n+    pub fn test_dlist_break_early() {\n         let l = from_vec(~[1,2,3,4,5]);\n         let mut x = 0;\n         for l.each |i| {\n@@ -724,7 +722,7 @@ mod tests {\n         assert x == 3;\n     }\n     #[test]\n-    fn test_dlist_remove_head() {\n+    pub fn test_dlist_remove_head() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -739,7 +737,7 @@ mod tests {\n         l.assert_consistent(); assert l.is_empty();\n     }\n     #[test]\n-    fn test_dlist_remove_mid() {\n+    pub fn test_dlist_remove_mid() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -754,7 +752,7 @@ mod tests {\n         l.assert_consistent(); assert l.is_empty();\n     }\n     #[test]\n-    fn test_dlist_remove_tail() {\n+    pub fn test_dlist_remove_tail() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -769,7 +767,7 @@ mod tests {\n         l.assert_consistent(); assert l.is_empty();\n     }\n     #[test]\n-    fn test_dlist_remove_one_two() {\n+    pub fn test_dlist_remove_one_two() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -785,7 +783,7 @@ mod tests {\n         l.assert_consistent(); assert l.is_empty();\n     }\n     #[test]\n-    fn test_dlist_remove_one_three() {\n+    pub fn test_dlist_remove_one_three() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -800,7 +798,7 @@ mod tests {\n         l.assert_consistent(); assert l.is_empty();\n     }\n     #[test]\n-    fn test_dlist_remove_two_three() {\n+    pub fn test_dlist_remove_two_three() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -815,7 +813,7 @@ mod tests {\n         l.assert_consistent(); assert l.is_empty();\n     }\n     #[test]\n-    fn test_dlist_remove_all() {\n+    pub fn test_dlist_remove_all() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -828,7 +826,7 @@ mod tests {\n         l.assert_consistent(); assert l.is_empty();\n     }\n     #[test]\n-    fn test_dlist_insert_n_before() {\n+    pub fn test_dlist_insert_n_before() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -844,7 +842,7 @@ mod tests {\n         l.assert_consistent(); assert l.is_empty();\n     }\n     #[test]\n-    fn test_dlist_insert_n_after() {\n+    pub fn test_dlist_insert_n_after() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -860,7 +858,7 @@ mod tests {\n         l.assert_consistent(); assert l.is_empty();\n     }\n     #[test]\n-    fn test_dlist_insert_before_head() {\n+    pub fn test_dlist_insert_before_head() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -875,7 +873,7 @@ mod tests {\n         l.assert_consistent(); assert l.is_empty();\n     }\n     #[test]\n-    fn test_dlist_insert_after_tail() {\n+    pub fn test_dlist_insert_after_tail() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -890,15 +888,15 @@ mod tests {\n         l.assert_consistent(); assert l.is_empty();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_asymmetric_link() {\n+    pub fn test_dlist_asymmetric_link() {\n         let l = DList::<int>();\n         let _one = l.push_n(1);\n         let two = l.push_n(2);\n         two.prev = None;\n         l.assert_consistent();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_cyclic_list() {\n+    pub fn test_dlist_cyclic_list() {\n         let l = DList::<int>();\n         let one = l.push_n(1);\n         let _two = l.push_n(2);\n@@ -908,32 +906,32 @@ mod tests {\n         l.assert_consistent();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_headless() {\n+    pub fn test_dlist_headless() {\n         DList::<int>().head();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_insert_already_present_before() {\n+    pub fn test_dlist_insert_already_present_before() {\n         let l = DList::<int>();\n         let one = l.push_n(1);\n         let two = l.push_n(2);\n         l.insert_n_before(two, one);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_insert_already_present_after() {\n+    pub fn test_dlist_insert_already_present_after() {\n         let l = DList::<int>();\n         let one = l.push_n(1);\n         let two = l.push_n(2);\n         l.insert_n_after(one, two);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_insert_before_orphan() {\n+    pub fn test_dlist_insert_before_orphan() {\n         let l = DList::<int>();\n         let one = new_dlist_node(1);\n         let two = new_dlist_node(2);\n         l.insert_n_before(one, two);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_dlist_insert_after_orphan() {\n+    pub fn test_dlist_insert_after_orphan() {\n         let l = DList::<int>();\n         let one = new_dlist_node(1);\n         let two = new_dlist_node(2);"}, {"sha": "b04d5be596503643644636d7e4c9ad929124ae84", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=d0391c5b092f27c4d52b304c069f6cf6a033cb75", "patch": "@@ -62,16 +62,15 @@ struct StackSegment {\n }\n \n extern mod rustrt {\n-    #[legacy_exports];\n     #[rust_stack]\n-    unsafe fn rust_call_tydesc_glue(root: *Word,\n-                                    tydesc: *Word,\n-                                    field: size_t);\n+    pub unsafe fn rust_call_tydesc_glue(root: *Word,\n+                                        tydesc: *Word,\n+                                        field: size_t);\n \n     #[rust_stack]\n-    unsafe fn rust_gc_metadata() -> *Word;\n+    pub unsafe fn rust_gc_metadata() -> *Word;\n \n-    unsafe fn rust_get_stack_segment() -> *StackSegment;\n+    pub unsafe fn rust_get_stack_segment() -> *StackSegment;\n }\n \n unsafe fn bump<T, U>(ptr: *T, count: uint) -> *U {"}, {"sha": "21a74ac08d005c12fe247c5919d9d6813c3064ca", "filename": "src/libcore/private.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=d0391c5b092f27c4d52b304c069f6cf6a033cb75", "patch": "@@ -37,15 +37,13 @@ pub mod finally;\n pub mod weak_task;\n \n extern mod rustrt {\n-    #[legacy_exports];\n+    pub unsafe fn rust_create_little_lock() -> rust_little_lock;\n+    pub unsafe fn rust_destroy_little_lock(lock: rust_little_lock);\n+    pub unsafe fn rust_lock_little_lock(lock: rust_little_lock);\n+    pub unsafe fn rust_unlock_little_lock(lock: rust_little_lock);\n \n-    unsafe fn rust_create_little_lock() -> rust_little_lock;\n-    unsafe fn rust_destroy_little_lock(lock: rust_little_lock);\n-    unsafe fn rust_lock_little_lock(lock: rust_little_lock);\n-    unsafe fn rust_unlock_little_lock(lock: rust_little_lock);\n-\n-    unsafe fn rust_raw_thread_start(f: &fn()) -> *raw_thread;\n-    unsafe fn rust_raw_thread_join_delete(thread: *raw_thread);\n+    pub unsafe fn rust_raw_thread_start(f: &fn()) -> *raw_thread;\n+    pub unsafe fn rust_raw_thread_join_delete(thread: *raw_thread);\n }\n \n #[abi = \"rust-intrinsic\"]"}, {"sha": "c8c76e86aa6b0337dec49b68da80ad539f0f3758", "filename": "src/libcore/result.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=d0391c5b092f27c4d52b304c069f6cf6a033cb75", "patch": "@@ -398,31 +398,29 @@ pub pure fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n #[cfg(test)]\n #[allow(non_implicitly_copyable_typarams)]\n mod tests {\n-    #[legacy_exports];\n-\n     use result::{Err, Ok, Result, chain, get, get_err};\n     use result;\n \n-    fn op1() -> result::Result<int, ~str> { result::Ok(666) }\n+    pub fn op1() -> result::Result<int, ~str> { result::Ok(666) }\n \n-    fn op2(i: int) -> result::Result<uint, ~str> {\n+    pub fn op2(i: int) -> result::Result<uint, ~str> {\n         result::Ok(i as uint + 1u)\n     }\n \n-    fn op3() -> result::Result<int, ~str> { result::Err(~\"sadface\") }\n+    pub fn op3() -> result::Result<int, ~str> { result::Err(~\"sadface\") }\n \n     #[test]\n-    fn chain_success() {\n+    pub fn chain_success() {\n         assert get(&chain(op1(), op2)) == 667u;\n     }\n \n     #[test]\n-    fn chain_failure() {\n+    pub fn chain_failure() {\n         assert get_err(&chain(op3(), op2)) == ~\"sadface\";\n     }\n \n     #[test]\n-    fn test_impl_iter() {\n+    pub fn test_impl_iter() {\n         let mut valid = false;\n         Ok::<~str, ~str>(~\"a\").iter(|_x| valid = true);\n         assert valid;\n@@ -432,7 +430,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_impl_iter_err() {\n+    pub fn test_impl_iter_err() {\n         let mut valid = true;\n         Ok::<~str, ~str>(~\"a\").iter_err(|_x| valid = false);\n         assert valid;\n@@ -443,19 +441,19 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_impl_map() {\n+    pub fn test_impl_map() {\n         assert Ok::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Ok(~\"b\");\n         assert Err::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Err(~\"a\");\n     }\n \n     #[test]\n-    fn test_impl_map_err() {\n+    pub fn test_impl_map_err() {\n         assert Ok::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Ok(~\"a\");\n         assert Err::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Err(~\"b\");\n     }\n \n     #[test]\n-    fn test_get_ref_method() {\n+    pub fn test_get_ref_method() {\n         let foo: Result<int, ()> = Ok(100);\n         assert *foo.get_ref() == 100;\n     }"}, {"sha": "2d2d24e60184b425d2ecdb984ed3eef88ceb3838", "filename": "src/libcore/rt.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt.rs?ref=d0391c5b092f27c4d52b304c069f6cf6a033cb75", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[legacy_exports];\n-\n // NB: transitionary, de-mode-ing.\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n@@ -27,11 +25,11 @@ use gc::{cleanup_stack_for_failure, gc, Word};\n pub type rust_task = c_void;\n \n #[cfg(target_word_size = \"32\")]\n-const FROZEN_BIT: uint = 0x80000000;\n+pub const FROZEN_BIT: uint = 0x80000000;\n #[cfg(target_word_size = \"64\")]\n-const FROZEN_BIT: uint = 0x8000000000000000;\n+pub const FROZEN_BIT: uint = 0x8000000000000000;\n \n-extern mod rustrt {\n+pub extern mod rustrt {\n     #[rust_stack]\n     unsafe fn rust_upcall_exchange_malloc(td: *c_char, size: uintptr_t)\n                                        -> *c_char;"}, {"sha": "17921a1a1b0656f602787f5f959e54e257ca564f", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=d0391c5b092f27c4d52b304c069f6cf6a033cb75", "patch": "@@ -97,12 +97,10 @@ fn frame_address(f: fn(++x: *u8)) {\n }\n \n extern mod rustrt {\n-    #[legacy_exports];\n-    unsafe fn rust_dbg_breakpoint();\n+    pub unsafe fn rust_dbg_breakpoint();\n }\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    #[legacy_exports];\n-    fn frame_address(f: &once fn(++x: *u8));\n+    pub fn frame_address(f: &once fn(++x: *u8));\n }"}, {"sha": "dedd5d12c5528bb1d144ba9b3a4c809aefa15ac1", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=d0391c5b092f27c4d52b304c069f6cf6a033cb75", "patch": "@@ -2574,7 +2574,6 @@ pub mod general_category {\n \n }\n mod derived_property {\n-    #[legacy_exports];\n     /// Check if a character has the alphabetic unicode property\n     pub pure fn Alphabetic(c: char) -> bool {\n         return match c {\n@@ -4690,5 +4689,5 @@ mod derived_property {\n           _ => false\n         };\n     }\n-\n }\n+"}, {"sha": "fba3e68511ca0dc325645d32daacf85b66577aa8", "filename": "src/libcore/util.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0391c5b092f27c4d52b304c069f6cf6a033cb75/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=d0391c5b092f27c4d52b304c069f6cf6a033cb75", "patch": "@@ -104,29 +104,27 @@ pub fn unreachable() -> ! {\n }\n \n mod tests {\n-    #[legacy_exports];\n-\n     use option::{None, Some};\n     use util::{NonCopyable, id, replace, swap};\n \n     #[test]\n-    fn identity_crisis() {\n+    pub fn identity_crisis() {\n         // Writing a test for the identity function. How did it come to this?\n         let x = ~[(5, false)];\n         //FIXME #3387 assert x.eq(id(copy x));\n         let y = copy x;\n         assert x.eq(&id(move y));\n     }\n     #[test]\n-    fn test_swap() {\n+    pub fn test_swap() {\n         let mut x = 31337;\n         let mut y = 42;\n         swap(&mut x, &mut y);\n         assert x == 42;\n         assert y == 31337;\n     }\n     #[test]\n-    fn test_replace() {\n+    pub fn test_replace() {\n         let mut x = Some(NonCopyable());\n         let y = replace(&mut x, None);\n         assert x.is_none();"}]}