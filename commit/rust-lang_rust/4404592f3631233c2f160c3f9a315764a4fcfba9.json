{"sha": "4404592f3631233c2f160c3f9a315764a4fcfba9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MDQ1OTJmMzYzMTIzM2MyZjE2MGMzZjlhMzE1NzY0YTRmY2ZiYTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-17T19:16:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T14:36:21Z"}, "message": "Implement associated type projection and normalization.", "tree": {"sha": "16abf46234f6e2e1b5153a0d26054894913baca3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16abf46234f6e2e1b5153a0d26054894913baca3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4404592f3631233c2f160c3f9a315764a4fcfba9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4404592f3631233c2f160c3f9a315764a4fcfba9", "html_url": "https://github.com/rust-lang/rust/commit/4404592f3631233c2f160c3f9a315764a4fcfba9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4404592f3631233c2f160c3f9a315764a4fcfba9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "html_url": "https://github.com/rust-lang/rust/commit/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b"}], "stats": {"total": 3994, "additions": 2478, "deletions": 1516}, "files": [{"sha": "2a58da8cb3be78825b8ccba819e692c144bdea25", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -256,3 +256,6 @@ pub const tag_predicate_space: uint = 0xa9;\n pub const tag_predicate_data: uint = 0xb0;\n \n pub const tag_unsafety: uint = 0xb1;\n+\n+pub const tag_associated_type_names: uint = 0xb2;\n+pub const tag_associated_type_name: uint = 0xb3;"}, {"sha": "fe0a2beb9ab2133b84206dd11703ff39ede7bea4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -369,6 +369,17 @@ fn parse_unsafety(item_doc: rbml::Doc) -> ast::Unsafety {\n     }\n }\n \n+fn parse_associated_type_names(item_doc: rbml::Doc) -> Vec<ast::Name> {\n+    let names_doc = reader::get_doc(item_doc, tag_associated_type_names);\n+    let mut names = Vec::new();\n+    reader::tagged_docs(names_doc, tag_associated_type_name, |name_doc| {\n+        let name = token::intern(name_doc.as_str_slice());\n+        names.push(name);\n+        true\n+    });\n+    names\n+}\n+\n pub fn get_trait_def<'tcx>(cdata: Cmd,\n                            item_id: ast::NodeId,\n                            tcx: &ty::ctxt<'tcx>) -> ty::TraitDef<'tcx>\n@@ -377,12 +388,14 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n     let bounds = trait_def_bounds(item_doc, tcx, cdata);\n     let unsafety = parse_unsafety(item_doc);\n+    let associated_type_names = parse_associated_type_names(item_doc);\n \n     ty::TraitDef {\n         unsafety: unsafety,\n         generics: generics,\n         bounds: bounds,\n-        trait_ref: Rc::new(item_trait_ref(item_doc, tcx, cdata))\n+        trait_ref: Rc::new(item_trait_ref(item_doc, tcx, cdata)),\n+        associated_type_names: associated_type_names,\n     }\n }\n "}, {"sha": "e541768b3578efdf9f069578a11f9cf2682bce11", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -1316,6 +1316,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(rbml_w, ecx, item.id);\n         let trait_def = ty::lookup_trait_def(tcx, def_id);\n         encode_unsafety(rbml_w, trait_def.unsafety);\n+        encode_associated_type_names(rbml_w, trait_def.associated_type_names.as_slice());\n         encode_generics(rbml_w, ecx, &trait_def.generics, tag_item_generics);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n@@ -1689,6 +1690,14 @@ fn encode_unsafety(rbml_w: &mut Encoder, unsafety: ast::Unsafety) {\n     rbml_w.wr_tagged_u8(tag_unsafety, byte);\n }\n \n+fn encode_associated_type_names(rbml_w: &mut Encoder, names: &[ast::Name]) {\n+    rbml_w.start_tag(tag_associated_type_names);\n+    for &name in names.iter() {\n+        rbml_w.wr_tagged_str(tag_associated_type_name, token::get_name(name).get());\n+    }\n+    rbml_w.end_tag();\n+}\n+\n fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n     fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<decoder::CrateDep> {\n         // Pull the cnums and name,vers,hash out of cstore"}, {"sha": "7daef30e25325c4c2ca32d974450fab33349149f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -504,6 +504,12 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n           return ty::mk_unboxed_closure(st.tcx, did,\n                   st.tcx.mk_region(region), st.tcx.mk_substs(substs));\n       }\n+      'P' => {\n+          assert_eq!(next(st), '[');\n+          let trait_ref = parse_trait_ref(st, |x,y| conv(x,y));\n+          let name = token::str_to_ident(parse_str(st, ']').as_slice()).name;\n+          return ty::mk_projection(tcx, trait_ref, name);\n+      }\n       'e' => {\n           return tcx.types.err;\n       }\n@@ -683,17 +689,32 @@ pub fn parse_predicate<'a,'tcx>(st: &mut PState<'a, 'tcx>,\n                                 -> ty::Predicate<'tcx>\n {\n     match next(st) {\n-        't' => Rc::new(ty::Binder(parse_trait_ref(st, conv))).as_predicate(),\n+        't' => ty::Binder(Rc::new(parse_trait_ref(st, conv))).as_predicate(),\n         'e' => ty::Binder(ty::EquatePredicate(parse_ty(st, |x,y| conv(x,y)),\n                                               parse_ty(st, |x,y| conv(x,y)))).as_predicate(),\n         'r' => ty::Binder(ty::OutlivesPredicate(parse_region(st, |x,y| conv(x,y)),\n                                                 parse_region(st, |x,y| conv(x,y)))).as_predicate(),\n         'o' => ty::Binder(ty::OutlivesPredicate(parse_ty(st, |x,y| conv(x,y)),\n                                                 parse_region(st, |x,y| conv(x,y)))).as_predicate(),\n+        'p' => ty::Binder(parse_projection_predicate(st, conv)).as_predicate(),\n         c => panic!(\"Encountered invalid character in metadata: {}\", c)\n     }\n }\n \n+fn parse_projection_predicate<'a,'tcx>(\n+    st: &mut PState<'a, 'tcx>,\n+    conv: conv_did)\n+     -> ty::ProjectionPredicate<'tcx>\n+{\n+    ty::ProjectionPredicate {\n+        projection_ty: ty::ProjectionTy {\n+            trait_ref: Rc::new(parse_trait_ref(st, |x,y| conv(x,y))),\n+            item_name: token::str_to_ident(parse_str(st, '|').as_slice()).name,\n+        },\n+        ty: parse_ty(st, |x,y| conv(x,y)),\n+    }\n+}\n+\n pub fn parse_type_param_def_data<'tcx>(data: &[u8], start: uint,\n                                        crate_num: ast::CrateNum, tcx: &ty::ctxt<'tcx>,\n                                        conv: conv_did) -> ty::TypeParameterDef<'tcx>\n@@ -710,10 +731,6 @@ fn parse_type_param_def<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n     assert_eq!(next(st), '|');\n     let index = parse_u32(st);\n     assert_eq!(next(st), '|');\n-    let associated_with = parse_opt(st, |st| {\n-        parse_def(st, NominalType, |x,y| conv(x,y))\n-    });\n-    assert_eq!(next(st), '|');\n     let bounds = parse_bounds(st, |x,y| conv(x,y));\n     let default = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)));\n \n@@ -722,7 +739,6 @@ fn parse_type_param_def<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n         def_id: def_id,\n         space: space,\n         index: index,\n-        associated_with: associated_with,\n         bounds: bounds,\n         default: default\n     }\n@@ -768,7 +784,8 @@ fn parse_bounds<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n     let mut param_bounds = ty::ParamBounds {\n         region_bounds: Vec::new(),\n         builtin_bounds: builtin_bounds,\n-        trait_bounds: Vec::new()\n+        trait_bounds: Vec::new(),\n+        projection_bounds: Vec::new(),\n     };\n     loop {\n         match next(st) {\n@@ -778,7 +795,11 @@ fn parse_bounds<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n             }\n             'I' => {\n                 param_bounds.trait_bounds.push(\n-                    Rc::new(ty::Binder(parse_trait_ref(st, |x,y| conv(x,y)))));\n+                    ty::Binder(Rc::new(parse_trait_ref(st, |x,y| conv(x,y)))));\n+            }\n+            'P' => {\n+                param_bounds.projection_bounds.push(\n+                    ty::Binder(parse_projection_predicate(st, |x,y| conv(x,y))));\n             }\n             '.' => {\n                 return param_bounds;"}, {"sha": "6d2b7e0ba93f6652a3b35283f535249c84c249e2", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -149,6 +149,11 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n+        ty::ty_projection(ref data) => {\n+            mywrite!(w, \"P[\");\n+            enc_trait_ref(w, cx, &data.trait_ref);\n+            mywrite!(w, \"{}]\", token::get_name(data.item_name));\n+        }\n         ty::ty_err => {\n             mywrite!(w, \"e\");\n         }\n@@ -403,7 +408,12 @@ pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n \n     for tp in bs.trait_bounds.iter() {\n         mywrite!(w, \"I\");\n-        enc_trait_ref(w, cx, &tp.0);\n+        enc_trait_ref(w, cx, &*tp.0);\n+    }\n+\n+    for tp in bs.projection_bounds.iter() {\n+        mywrite!(w, \"P\");\n+        enc_projection_predicate(w, cx, &tp.0);\n     }\n \n     mywrite!(w, \".\");\n@@ -414,8 +424,6 @@ pub fn enc_type_param_def<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tc\n     mywrite!(w, \"{}:{}|{}|{}|\",\n              token::get_name(v.name), (cx.ds)(v.def_id),\n              v.space.to_uint(), v.index);\n-    enc_opt(w, v.associated_with, |w, did| mywrite!(w, \"{}\", (cx.ds)(did)));\n-    mywrite!(w, \"|\");\n     enc_bounds(w, cx, &v.bounds);\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n }\n@@ -427,7 +435,7 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n     match *p {\n         ty::Predicate::Trait(ref trait_ref) => {\n             mywrite!(w, \"t\");\n-            enc_trait_ref(w, cx, &trait_ref.0);\n+            enc_trait_ref(w, cx, &*trait_ref.0.trait_ref);\n         }\n         ty::Predicate::Equate(ty::Binder(ty::EquatePredicate(a, b))) => {\n             mywrite!(w, \"e\");\n@@ -444,5 +452,17 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n             enc_ty(w, cx, a);\n             enc_region(w, cx, b);\n         }\n+        ty::Predicate::Projection(ty::Binder(ref data)) => {\n+            mywrite!(w, \"p\");\n+            enc_projection_predicate(w, cx, data)\n+        }\n     }\n }\n+\n+fn enc_projection_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n+                                      cx: &ctxt<'a, 'tcx>,\n+                                      data: &ty::ProjectionPredicate<'tcx>) {\n+    enc_trait_ref(w, cx, &*data.projection_ty.trait_ref);\n+    mywrite!(w, \"{}|\", token::get_name(data.projection_ty.item_name));\n+    enc_ty(w, cx, data.ty);\n+}"}, {"sha": "57dac607fa6b70a35a74682a20932e7cf771733a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -1284,7 +1284,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_trait_ref(ecx, &trait_ref.0);\n+                rbml_w.emit_trait_ref(ecx, &*trait_ref.0);\n             })\n         })\n     }\n@@ -1364,7 +1364,7 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n     fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                               -> Rc<ty::TraitRef<'tcx>>;\n     fn read_poly_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                   -> Rc<ty::PolyTraitRef<'tcx>>;\n+                                   -> ty::PolyTraitRef<'tcx>;\n     fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> ty::TypeParameterDef<'tcx>;\n     fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1558,8 +1558,8 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     }\n \n     fn read_poly_trait_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                   -> Rc<ty::PolyTraitRef<'tcx>> {\n-        Rc::new(ty::Binder(self.read_opaque(|this, doc| {\n+                                   -> ty::PolyTraitRef<'tcx> {\n+        ty::Binder(Rc::new(self.read_opaque(|this, doc| {\n             let ty = tydecode::parse_trait_ref_data(\n                 doc.data,\n                 dcx.cdata.cnum,\n@@ -1786,7 +1786,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                 Ok(this.read_poly_trait_ref(dcx))\n                             }));\n                             Ok(ty::TyTrait {\n-                                principal: (*principal).clone(),\n+                                principal: ty::Binder((*principal.0).clone()),\n                                 bounds: try!(this.read_struct_field(\"bounds\", 1, |this| {\n                                     Ok(this.read_existential_bounds(dcx))\n                                 })),"}, {"sha": "dcbd94b8482fdd5516ab6b6b08490ecd6851f34d", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -58,7 +58,7 @@ pub fn simplify_type(tcx: &ty::ctxt,\n         ty::ty_vec(..) => Some(VecSimplifiedType),\n         ty::ty_ptr(_) => Some(PtrSimplifiedType),\n         ty::ty_trait(ref trait_info) => {\n-            Some(TraitSimplifiedType(trait_info.principal.def_id()))\n+            Some(TraitSimplifiedType(trait_info.principal_def_id()))\n         }\n         ty::ty_struct(def_id, _) => {\n             Some(StructSimplifiedType(def_id))\n@@ -86,6 +86,9 @@ pub fn simplify_type(tcx: &ty::ctxt,\n         ty::ty_bare_fn(_, ref f) => {\n             Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n         }\n+        ty::ty_projection(_) => {\n+            None\n+        }\n         ty::ty_param(_) => {\n             if can_simplify_params {\n                 Some(ParameterSimplifiedType)"}, {"sha": "8ff2d0ba1f0d8a9101ad00b86f039676f6e9871e", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -51,6 +51,7 @@ use middle::ty_fold;\n use middle::ty_fold::{TypeFoldable};\n use util::ppaux::Repr;\n \n+use std::rc::Rc;\n use syntax::ast::{Onceness, Unsafety};\n use syntax::ast;\n use syntax::abi;\n@@ -358,6 +359,18 @@ pub trait Combineable<'tcx> : Repr<'tcx> + TypeFoldable<'tcx> {\n     fn combine<C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> cres<'tcx, Self>;\n }\n \n+impl<'tcx,T> Combineable<'tcx> for Rc<T>\n+    where T : Combineable<'tcx>\n+{\n+    fn combine<C:Combine<'tcx>>(combiner: &C,\n+                                a: &Rc<T>,\n+                                b: &Rc<T>)\n+                                -> cres<'tcx, Rc<T>>\n+    {\n+        Ok(Rc::new(try!(Combineable::combine(combiner, &**a, &**b))))\n+    }\n+}\n+\n impl<'tcx> Combineable<'tcx> for ty::TraitRef<'tcx> {\n     fn combine<C:Combine<'tcx>>(combiner: &C,\n                                 a: &ty::TraitRef<'tcx>,\n@@ -581,6 +594,15 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n         })\n       }\n \n+      (&ty::ty_projection(ref a_data), &ty::ty_projection(ref b_data)) => {\n+          if a_data.item_name == b_data.item_name {\n+              let trait_ref = try!(this.trait_refs(&a_data.trait_ref, &b_data.trait_ref));\n+              Ok(ty::mk_projection(tcx, trait_ref, a_data.item_name))\n+          } else {\n+              Err(ty::terr_sorts(expected_found(this, a, b)))\n+          }\n+      }\n+\n       _ => Err(ty::terr_sorts(expected_found(this, a, b)))\n     };\n "}, {"sha": "e38b721ce2d0d82295b130766566f4fcd83636be", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -1437,6 +1437,11 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                 format!(\" for {}in generic type\",\n                         bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n             }\n+            infer::LateBoundRegion(_, br, infer::AssocTypeProjection(type_name)) => {\n+                format!(\" for {}in trait containing associated type `{}`\",\n+                        bound_region_to_string(self.tcx, \"lifetime parameter \", true, br),\n+                        token::get_name(type_name))\n+            }\n             infer::EarlyBoundRegion(_, name) => {\n                 format!(\" for lifetime parameter `{}`\",\n                         token::get_name(name).get())\n@@ -1661,13 +1666,16 @@ impl<'tcx> Resolvable<'tcx> for Rc<ty::TraitRef<'tcx>> {\n     }\n }\n \n-impl<'tcx> Resolvable<'tcx> for Rc<ty::PolyTraitRef<'tcx>> {\n-    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n-                   -> Rc<ty::PolyTraitRef<'tcx>> {\n-        Rc::new(infcx.resolve_type_vars_if_possible(&**self))\n+impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n+    fn resolve<'a>(&self,\n+                   infcx: &InferCtxt<'a, 'tcx>)\n+                   -> ty::PolyTraitRef<'tcx>\n+    {\n+        infcx.resolve_type_vars_if_possible(self)\n     }\n+\n     fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(&self.0)\n+        ty::trait_ref_contains_error(&*self.0)\n     }\n }\n "}, {"sha": "33174409f899bec8b4bab9450a5551ac9553c251", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -157,6 +157,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::ty_struct(..) |\n             ty::ty_unboxed_closure(..) |\n             ty::ty_tup(..) |\n+            ty::ty_projection(..) |\n             ty::ty_param(..) => {\n                 ty_fold::super_fold_ty(self, t)\n             }"}, {"sha": "cf9520ecfbbde08c2a3d269429f2daf007c22e47", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -139,7 +139,7 @@ pub enum TypeOrigin {\n pub enum ValuePairs<'tcx> {\n     Types(ty::expected_found<Ty<'tcx>>),\n     TraitRefs(ty::expected_found<Rc<ty::TraitRef<'tcx>>>),\n-    PolyTraitRefs(ty::expected_found<Rc<ty::PolyTraitRef<'tcx>>>),\n+    PolyTraitRefs(ty::expected_found<ty::PolyTraitRef<'tcx>>),\n }\n \n /// The trace designates the path through inference that we took to\n@@ -231,6 +231,9 @@ pub enum LateBoundRegionConversionTime {\n \n     /// when two higher-ranked types are compared\n     HigherRankedType,\n+\n+    /// when projecting an associated type\n+    AssocTypeProjection(ast::Name),\n }\n \n /// Reasons to create a region inference variable\n@@ -407,8 +410,8 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                    a_is_expected: bool,\n                                    origin: TypeOrigin,\n-                                   a: Rc<ty::PolyTraitRef<'tcx>>,\n-                                   b: Rc<ty::PolyTraitRef<'tcx>>)\n+                                   a: ty::PolyTraitRef<'tcx>,\n+                                   b: ty::PolyTraitRef<'tcx>)\n                                    -> ures<'tcx>\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n@@ -703,8 +706,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn sub_poly_trait_refs(&self,\n                                a_is_expected: bool,\n                                origin: TypeOrigin,\n-                               a: Rc<ty::PolyTraitRef<'tcx>>,\n-                               b: Rc<ty::PolyTraitRef<'tcx>>)\n+                               a: ty::PolyTraitRef<'tcx>,\n+                               b: ty::PolyTraitRef<'tcx>)\n                                -> ures<'tcx>\n     {\n         debug!(\"sub_poly_trait_refs({} <: {})\",\n@@ -715,7 +718,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace).binders(&*a, &*b).to_ures()\n+            self.sub(a_is_expected, trace).binders(&a, &b).to_ures()\n         })\n     }\n \n@@ -750,7 +753,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                          -> T\n         where T : TypeFoldable<'tcx> + Repr<'tcx>\n     {\n-        /*! See `higher_ranked::leak_check` */\n+        /*! See `higher_ranked::plug_leaks` */\n \n         higher_ranked::plug_leaks(self, skol_map, snapshot, value)\n     }"}, {"sha": "d8b39d92c692fad9ca0c392338ce1db322ef18ed", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -45,7 +45,9 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n     let param_env = ty::empty_parameter_environment();\n     let mut selcx = SelectionContext::intercrate(infcx, &param_env, infcx.tcx);\n     let obligation = Obligation::new(ObligationCause::dummy(),\n-                                     Rc::new(ty::Binder(impl1_trait_ref)));\n+                                     ty::Binder(ty::TraitPredicate {\n+                                         trait_ref: Rc::new(impl1_trait_ref),\n+                                     }));\n     debug!(\"impl_can_satisfy(obligation={})\", obligation.repr(infcx.tcx));\n     selcx.evaluate_impl(impl2_def_id, &obligation)\n }\n@@ -140,7 +142,7 @@ pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         }\n \n         ty::ty_trait(ref tt) => {\n-            tt.principal.def_id().krate == ast::LOCAL_CRATE\n+            tt.principal_def_id().krate == ast::LOCAL_CRATE\n         }\n \n         // Type parameters may be bound to types that are not local to\n@@ -149,6 +151,11 @@ pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n             false\n         }\n \n+        // Associated types could be anything, I guess.\n+        ty::ty_projection(..) => {\n+            false\n+        }\n+\n         ty::ty_infer(..) |\n         ty::ty_open(..) |\n         ty::ty_err => {"}, {"sha": "a3d92c698a2ad358ca7e368708e76c797146ab15", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 90, "deletions": 102, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -8,12 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{FulfillmentError, FulfillmentErrorCode,\n-            ObligationCauseCode, SelectionError,\n-            PredicateObligation, OutputTypeParameterMismatch};\n+use super::{\n+    FulfillmentError,\n+    FulfillmentErrorCode,\n+    MismatchedProjectionTypes,\n+    ObligationCauseCode,\n+    OutputTypeParameterMismatch,\n+    PredicateObligation,\n+    SelectionError,\n+};\n \n use middle::infer::InferCtxt;\n-use middle::ty::{mod};\n+use middle::ty::{mod, AsPredicate, ReferencesError, ToPolyTraitRef};\n use syntax::codemap::Span;\n use util::ppaux::{Repr, UserString};\n \n@@ -30,51 +36,46 @@ fn report_fulfillment_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         FulfillmentErrorCode::CodeSelectionError(ref e) => {\n             report_selection_error(infcx, &error.obligation, e);\n         }\n+        FulfillmentErrorCode::CodeProjectionError(ref e) => {\n+            report_projection_error(infcx, &error.obligation, e);\n+        }\n         FulfillmentErrorCode::CodeAmbiguity => {\n             maybe_report_ambiguity(infcx, &error.obligation);\n         }\n     }\n }\n \n+pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                         obligation: &PredicateObligation<'tcx>,\n+                                         error: &MismatchedProjectionTypes<'tcx>)\n+{\n+    let predicate =\n+        infcx.resolve_type_vars_if_possible(&obligation.predicate);\n+    if !predicate.references_error() {\n+        infcx.tcx.sess.span_err(\n+            obligation.cause.span,\n+            format!(\n+                \"type mismatch resolving `{}`: {}\",\n+                predicate.user_string(infcx.tcx),\n+                ty::type_err_to_str(infcx.tcx, &error.err)).as_slice());\n+        note_obligation_cause(infcx, obligation);\n+    }\n+}\n+\n pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                         obligation: &PredicateObligation<'tcx>,\n                                         error: &SelectionError<'tcx>)\n {\n     match *error {\n         SelectionError::Overflow => {\n             // We could track the stack here more precisely if we wanted, I imagine.\n-            match obligation.trait_ref {\n-                ty::Predicate::Trait(ref trait_ref) => {\n-                    let trait_ref =\n-                        infcx.resolve_type_vars_if_possible(&**trait_ref);\n-                    infcx.tcx.sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"overflow evaluating the trait `{}` for the type `{}`\",\n-                            trait_ref.user_string(infcx.tcx),\n-                            trait_ref.self_ty().user_string(infcx.tcx))[]);\n-                }\n-\n-                ty::Predicate::Equate(ref predicate) => {\n-                    let predicate = infcx.resolve_type_vars_if_possible(predicate);\n-                    let err = infcx.equality_predicate(obligation.cause.span,\n-                                                       &predicate).unwrap_err();\n-\n-                    infcx.tcx.sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate.user_string(infcx.tcx),\n-                            ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n-                }\n-\n-                ty::Predicate::TypeOutlives(..) |\n-                ty::Predicate::RegionOutlives(..) => {\n-                    infcx.tcx.sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\"overflow evaluating lifetime predicate\").as_slice());\n-                }\n-            }\n+            let predicate =\n+                infcx.resolve_type_vars_if_possible(&obligation.predicate);\n+            infcx.tcx.sess.span_err(\n+                obligation.cause.span,\n+                format!(\n+                    \"overflow evaluating the requirement `{}`\",\n+                    predicate.user_string(infcx.tcx)).as_slice());\n \n             let current_limit = infcx.tcx.sess.recursion_limit.get();\n             let suggested_limit = current_limit * 2;\n@@ -87,27 +88,37 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             note_obligation_cause(infcx, obligation);\n         }\n         SelectionError::Unimplemented => {\n-            match obligation.trait_ref {\n-                ty::Predicate::Trait(ref trait_ref) => {\n-                    let trait_ref =\n-                        infcx.resolve_type_vars_if_possible(\n-                            &**trait_ref);\n-                    if !ty::type_is_error(trait_ref.self_ty()) {\n+            match obligation.predicate {\n+                ty::Predicate::Trait(ref trait_predicate) => {\n+                    let trait_predicate =\n+                        infcx.resolve_type_vars_if_possible(trait_predicate);\n+                    if !trait_predicate.references_error() {\n+                        let trait_ref = trait_predicate.to_poly_trait_ref();\n                         infcx.tcx.sess.span_err(\n                             obligation.cause.span,\n                             format!(\n                                 \"the trait `{}` is not implemented for the type `{}`\",\n                                 trait_ref.user_string(infcx.tcx),\n                                 trait_ref.self_ty().user_string(infcx.tcx)).as_slice());\n-                        note_obligation_cause(infcx, obligation);\n                     }\n                 }\n \n                 ty::Predicate::Equate(ref predicate) => {\n                     let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                     let err = infcx.equality_predicate(obligation.cause.span,\n-                                                       &predicate).unwrap_err();\n+                                                             &predicate).unwrap_err();\n+                    infcx.tcx.sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate.user_string(infcx.tcx),\n+                            ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                }\n \n+                ty::Predicate::RegionOutlives(ref predicate) => {\n+                    let predicate = infcx.resolve_type_vars_if_possible(predicate);\n+                    let err = infcx.region_outlives_predicate(obligation.cause.span,\n+                                                              &predicate).unwrap_err();\n                     infcx.tcx.sess.span_err(\n                         obligation.cause.span,\n                         format!(\n@@ -116,9 +127,10 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n                 }\n \n-                ty::Predicate::TypeOutlives(..) |\n-                ty::Predicate::RegionOutlives(..) => {\n-                    let predicate = infcx.resolve_type_vars_if_possible(&obligation.trait_ref);\n+                ty::Predicate::Projection(..) |\n+                ty::Predicate::TypeOutlives(..) => {\n+                    let predicate =\n+                        infcx.resolve_type_vars_if_possible(&obligation.predicate);\n                     infcx.tcx.sess.span_err(\n                         obligation.cause.span,\n                         format!(\n@@ -128,12 +140,8 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             }\n         }\n         OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n-            let expected_trait_ref =\n-                infcx.resolve_type_vars_if_possible(\n-                    &**expected_trait_ref);\n-            let actual_trait_ref =\n-                infcx.resolve_type_vars_if_possible(\n-                    &**actual_trait_ref);\n+            let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n+            let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n             if !ty::type_is_error(actual_trait_ref.self_ty()) {\n                 infcx.tcx.sess.span_err(\n                     obligation.cause.span,\n@@ -150,24 +158,26 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n-fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                    obligation: &PredicateObligation<'tcx>) {\n+pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                        obligation: &PredicateObligation<'tcx>) {\n     // Unable to successfully determine, probably means\n     // insufficient type information, but could mean\n     // ambiguous impls. The latter *ought* to be a\n     // coherence violation, so we don't report it here.\n \n-    let trait_ref = match obligation.trait_ref {\n-        ty::Predicate::Trait(ref trait_ref) => {\n-            infcx.resolve_type_vars_if_possible(&**trait_ref)\n+    let trait_ref = match obligation.predicate {\n+        ty::Predicate::Trait(ref trait_predicate) => {\n+            infcx.resolve_type_vars_if_possible(\n+                &trait_predicate.to_poly_trait_ref())\n         }\n         _ => {\n             infcx.tcx.sess.span_bug(\n                 obligation.cause.span,\n                 format!(\"ambiguity from something other than a trait: {}\",\n-                        obligation.trait_ref.repr(infcx.tcx)).as_slice());\n+                        obligation.predicate.repr(infcx.tcx)).as_slice());\n         }\n     };\n+\n     let self_ty = trait_ref.self_ty();\n \n     debug!(\"maybe_report_ambiguity(trait_ref={}, self_ty={}, obligation={})\",\n@@ -208,7 +218,7 @@ fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                          locate the impl of the trait `{}` for \\\n                          the type `{}`; type annotations required\",\n                         trait_ref.user_string(infcx.tcx),\n-                        self_ty.user_string(infcx.tcx))[]);\n+                        self_ty.user_string(infcx.tcx)).as_slice());\n                 note_obligation_cause(infcx, obligation);\n             }\n         }\n@@ -221,56 +231,38 @@ fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                  cannot locate the impl of the trait `{}` for \\\n                  the type `{}`\",\n                 trait_ref.user_string(infcx.tcx),\n-                self_ty.user_string(infcx.tcx))[]);\n+                self_ty.user_string(infcx.tcx)).as_slice());\n     }\n }\n \n fn note_obligation_cause<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                    obligation: &PredicateObligation<'tcx>)\n {\n-    let trait_ref = match obligation.trait_ref {\n-        ty::Predicate::Trait(ref trait_ref) => {\n-            infcx.resolve_type_vars_if_possible(&**trait_ref)\n-        }\n-        _ => {\n-            infcx.tcx.sess.span_bug(\n-                obligation.cause.span,\n-                format!(\"ambiguity from something other than a trait: {}\",\n-                        obligation.trait_ref.repr(infcx.tcx)).as_slice());\n-        }\n-    };\n-\n     note_obligation_cause_code(infcx,\n-                               &trait_ref,\n+                               &obligation.predicate,\n                                obligation.cause.span,\n-                               &obligation.cause.code)\n+                               &obligation.cause.code);\n }\n \n fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                        trait_ref: &ty::PolyTraitRef<'tcx>,\n+                                        _predicate: &ty::Predicate<'tcx>,\n                                         cause_span: Span,\n                                         cause_code: &ObligationCauseCode<'tcx>)\n {\n     let tcx = infcx.tcx;\n-    let trait_name = ty::item_path_str(tcx, trait_ref.def_id());\n     match *cause_code {\n         ObligationCauseCode::MiscObligation => { }\n         ObligationCauseCode::ItemObligation(item_def_id) => {\n             let item_name = ty::item_path_str(tcx, item_def_id);\n             tcx.sess.span_note(\n                 cause_span,\n-                format!(\n-                    \"the trait `{}` must be implemented because it is required by `{}`\",\n-                    trait_name,\n-                    item_name).as_slice());\n+                format!(\"required by `{}`\", item_name).as_slice());\n         }\n         ObligationCauseCode::ObjectCastObligation(object_ty) => {\n             tcx.sess.span_note(\n                 cause_span,\n                 format!(\n-                    \"the trait `{}` must be implemented for the cast \\\n-                     to the object type `{}`\",\n-                    trait_name,\n+                    \"required for the cast to the object type `{}`\",\n                     infcx.ty_to_string(object_ty)).as_slice());\n         }\n         ObligationCauseCode::RepeatVec => {\n@@ -323,27 +315,23 @@ fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             span_note!(tcx.sess, cause_span,\n                        \"shared static variables must have a type that implements `Sync`\");\n         }\n-        ObligationCauseCode::BuiltinDerivedObligation(ref root_trait_ref, ref root_cause_code) => {\n-            let root_trait_ref =\n-                infcx.resolve_type_vars_if_possible(&**root_trait_ref);\n+        ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+            let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n             span_note!(tcx.sess, cause_span,\n-                       \"the type `{}` must implement `{}` because it appears within the type `{}`\",\n-                       trait_ref.self_ty().user_string(infcx.tcx),\n-                       trait_ref.user_string(infcx.tcx),\n-                       root_trait_ref.self_ty().user_string(infcx.tcx));\n-            note_obligation_cause_code(infcx, &root_trait_ref, cause_span, &**root_cause_code);\n+                       \"required because it appears within the type `{}`\",\n+                       parent_trait_ref.0.self_ty().user_string(infcx.tcx));\n+            let parent_predicate = parent_trait_ref.as_predicate();\n+            note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n-        ObligationCauseCode::ImplDerivedObligation(ref root_trait_ref, ref root_cause_code) => {\n-            let root_trait_ref =\n-                infcx.resolve_type_vars_if_possible(&**root_trait_ref);\n+        ObligationCauseCode::ImplDerivedObligation(ref data) => {\n+            let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n             span_note!(tcx.sess, cause_span,\n-                       \"the type `{}` must implement `{}` due to the requirements \\\n-                        on the impl of `{}` for the type `{}`\",\n-                       trait_ref.self_ty().user_string(infcx.tcx),\n-                       trait_ref.user_string(infcx.tcx),\n-                       root_trait_ref.user_string(infcx.tcx),\n-                       root_trait_ref.self_ty().user_string(infcx.tcx));\n-            note_obligation_cause_code(infcx, &root_trait_ref, cause_span, &**root_cause_code);\n+                       \"required because of the requirements on the impl of `{}` for `{}`\",\n+                       parent_trait_ref.user_string(infcx.tcx),\n+                       parent_trait_ref.0.self_ty().user_string(infcx.tcx));\n+            let parent_predicate = parent_trait_ref.as_predicate();\n+            note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n     }\n }\n+"}, {"sha": "e5024e000df0d8ef353709e2e59d3289c1092dd3", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 142, "deletions": 30, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::infer::InferCtxt;\n+use middle::infer::{mod, InferCtxt};\n use middle::mem_categorization::Typer;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, AsPredicate, RegionEscape, Ty, ToPolyTraitRef};\n use std::collections::HashSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::default::Default;\n@@ -21,15 +21,16 @@ use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n \n use super::CodeAmbiguity;\n+use super::CodeProjectionError;\n use super::CodeSelectionError;\n use super::FulfillmentError;\n use super::Obligation;\n use super::ObligationCause;\n use super::PredicateObligation;\n-use super::Selection;\n+use super::project;\n use super::select::SelectionContext;\n-use super::poly_trait_ref_for_builtin_bound;\n use super::Unimplemented;\n+use super::util::predicate_for_builtin_bound;\n \n /// The fulfillment context is used to drive trait resolution.  It\n /// consists of a list of obligations that must be (eventually)\n@@ -101,35 +102,41 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n+    pub fn normalize_associated_type<'a>(&mut self,\n+                                         infcx: &InferCtxt<'a,'tcx>,\n+                                         trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                                         item_name: ast::Name,\n+                                         cause: ObligationCause<'tcx>)\n+                                         -> Ty<'tcx>\n+    {\n+        assert!(!trait_ref.has_escaping_regions());\n+\n+        let ty_var = infcx.next_ty_var();\n+        let projection =\n+            ty::Binder(ty::ProjectionPredicate {\n+                projection_ty: ty::ProjectionTy { trait_ref: trait_ref,\n+                                                  item_name: item_name },\n+                ty: ty_var\n+            });\n+        let obligation = Obligation::new(cause, projection.as_predicate());\n+        self.register_predicate(infcx.tcx, obligation);\n+        ty_var\n+    }\n+\n     pub fn register_builtin_bound(&mut self,\n                                   tcx: &ty::ctxt<'tcx>,\n                                   ty: Ty<'tcx>,\n                                   builtin_bound: ty::BuiltinBound,\n                                   cause: ObligationCause<'tcx>)\n     {\n-        match poly_trait_ref_for_builtin_bound(tcx, builtin_bound, ty) {\n-            Ok(trait_ref) => {\n-                self.register_trait_ref(tcx, trait_ref, cause);\n+        match predicate_for_builtin_bound(tcx, cause, builtin_bound, 0, ty) {\n+            Ok(predicate) => {\n+                self.register_predicate(tcx, predicate);\n             }\n             Err(ErrorReported) => { }\n         }\n     }\n \n-    pub fn register_trait_ref<'a>(&mut self,\n-                                  tcx: &ty::ctxt<'tcx>,\n-                                  trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n-                                  cause: ObligationCause<'tcx>)\n-    {\n-        /*!\n-         * A convenience function for registering trait obligations.\n-         */\n-\n-        let trait_obligation = Obligation { cause: cause,\n-                                            recursion_depth: 0,\n-                                            predicate: ty::Predicate::Trait(trait_ref) };\n-        self.register_predicate(tcx, trait_obligation)\n-    }\n-\n     pub fn register_region_obligation(&mut self,\n                                       tcx: &ty::ctxt<'tcx>,\n                                       t_a: Ty<'tcx>,\n@@ -232,7 +239,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             debug!(\"select_where_possible({} obligations) iteration\",\n                    count);\n \n-            let mut selections = Vec::new();\n+            let mut new_obligations = Vec::new();\n \n             // If we are only attempting obligations we haven't seen yet,\n             // then set `skip` to the number of obligations we've already\n@@ -253,7 +260,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                     let processed =\n                         if skip == 0 {\n                             process_predicate(selcx, predicate,\n-                                              &mut selections, &mut errors, region_obligations)\n+                                              &mut new_obligations, &mut errors, region_obligations)\n                         } else {\n                             skip -= 1;\n                             false\n@@ -271,8 +278,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n             // Now go through all the successful ones,\n             // registering any nested obligations for the future.\n-            for selection in selections.into_iter() {\n-                selection.map_move_nested(|p| self.register_predicate(tcx, p));\n+            for new_obligation in new_obligations.into_iter() {\n+                self.register_predicate(tcx, new_obligation);\n             }\n         }\n \n@@ -290,7 +297,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                               obligation: &PredicateObligation<'tcx>,\n-                              selections: &mut Vec<Selection<'tcx>>,\n+                              new_obligations: &mut Vec<PredicateObligation<'tcx>>,\n                               errors: &mut Vec<FulfillmentError<'tcx>>,\n                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n                               -> bool\n@@ -304,14 +311,14 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n \n     let tcx = selcx.tcx();\n     match obligation.predicate {\n-        ty::Predicate::Trait(ref trait_ref) => {\n-            let trait_obligation = obligation.with(trait_ref.clone());\n+        ty::Predicate::Trait(ref data) => {\n+            let trait_obligation = obligation.with(data.clone());\n             match selcx.select(&trait_obligation) {\n                 Ok(None) => {\n                     false\n                 }\n                 Ok(Some(s)) => {\n-                    selections.push(s);\n+                    s.map_move_nested(|p| new_obligations.push(p));\n                     true\n                 }\n                 Err(selection_err) => {\n@@ -372,6 +379,111 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n             }\n             true\n         }\n+\n+        ty::Predicate::Projection(ref data) => {\n+            let project_obligation = obligation.with(data.clone());\n+            let result = project::poly_project_and_unify_type(selcx, &project_obligation);\n+            debug!(\"poly_project_and_unify_type({}) = {}\",\n+                   project_obligation.repr(tcx),\n+                   result.repr(tcx));\n+            match result {\n+                Ok(()) => {\n+                    true\n+                }\n+                Err(project::ProjectionError::TooManyCandidates) => {\n+                    // Without more type information, we can't say much.\n+                    false\n+                }\n+                Err(project::ProjectionError::NoCandidate) => {\n+                    // This means that we have a type like `<T as\n+                    // Trait>::name = U` but we couldn't find any more\n+                    // information. This could just be that we're in a\n+                    // function like:\n+                    //\n+                    //     fn foo<T:Trait>(...)\n+                    //\n+                    // in which case this is not an error. But it\n+                    // might also mean we're in a situation where we\n+                    // don't actually know that `T : Trait` holds,\n+                    // which would be weird (e.g., if `T` was not a\n+                    // parameter type but a normal type, like `int`).\n+                    //\n+                    // So what we do is to (1) add a requirement that\n+                    // `T : Trait` (just in case) and (2) try to unify\n+                    // `U` with `<T as Trait>::name`.\n+\n+                    if !ty::binds_late_bound_regions(selcx.tcx(), data) {\n+                        // Check that `T : Trait` holds.\n+                        let trait_ref = data.to_poly_trait_ref();\n+                        new_obligations.push(obligation.with(trait_ref.as_predicate()));\n+\n+                        // Fallback to `<T as Trait>::name`. If this\n+                        // fails, then the output must be at least\n+                        // somewhat constrained, and we cannot verify\n+                        // that constraint, so yield an error.\n+                        let ty_projection = ty::mk_projection(tcx,\n+                                                             (*trait_ref.0).clone(),\n+                                                             data.0.projection_ty.item_name);\n+\n+                        debug!(\"process_predicate: falling back to projection {}\",\n+                               ty_projection.repr(selcx.tcx()));\n+\n+                        match infer::mk_eqty(selcx.infcx(),\n+                                             true,\n+                                             infer::EquatePredicate(obligation.cause.span),\n+                                             ty_projection,\n+                                             data.0.ty) {\n+                            Ok(()) => { }\n+                            Err(_) => {\n+                                debug!(\"process_predicate: fallback failed to unify; error\");\n+                                errors.push(\n+                                    FulfillmentError::new(\n+                                        obligation.clone(),\n+                                        CodeSelectionError(Unimplemented)));\n+                            }\n+                        }\n+\n+                        true\n+                    } else {\n+                        // If we have something like\n+                        //\n+                        //     for<'a> <T<'a> as Trait>::name == &'a int\n+                        //\n+                        // there is no \"canonical form\" for us to\n+                        // make, so just report the lack of candidates\n+                        // as an error.\n+\n+                        debug!(\"process_predicate: can't fallback, higher-ranked\");\n+                        errors.push(\n+                            FulfillmentError::new(\n+                                obligation.clone(),\n+                                CodeSelectionError(Unimplemented)));\n+\n+                        true\n+                    }\n+                }\n+                Err(project::ProjectionError::MismatchedTypes(e)) => {\n+                    errors.push(\n+                        FulfillmentError::new(\n+                            obligation.clone(),\n+                            CodeProjectionError(e)));\n+                    true\n+                }\n+                Err(project::ProjectionError::TraitSelectionError(e)) => {\n+                    // Extract just the `T : Trait` from `<T as\n+                    // Trait>::Name == U`, so that when we report an\n+                    // error to the user, it says something like \"`T :\n+                    // Trait` not satisfied\".5D\n+                    let trait_predicate = data.to_poly_trait_ref();\n+                    let trait_obligation = obligation.with(trait_predicate.as_predicate());\n+                    errors.push(\n+                        FulfillmentError::new(\n+                            trait_obligation,\n+                            CodeSelectionError(e)));\n+                    true\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "b7e2304849a142cf860d78c8482f419a03354b0a", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -18,28 +18,32 @@ pub use self::ObligationCauseCode::*;\n use middle::subst;\n use middle::ty::{mod, Ty};\n use middle::infer::InferCtxt;\n-use std::rc::Rc;\n use std::slice::Iter;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n use util::ppaux::Repr;\n \n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n+pub use self::project::MismatchedProjectionTypes;\n+pub use self::project::project_type;\n+pub use self::project::ProjectionResult;\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n pub use self::util::elaborate_predicates;\n+pub use self::util::trait_ref_for_builtin_bound;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n pub use self::util::search_trait_and_supertraits_from_bound;\n pub use self::util::transitive_bounds;\n-pub use self::util::poly_trait_ref_for_builtin_bound;\n \n mod coherence;\n mod error_reporting;\n mod fulfill;\n+mod project;\n mod select;\n mod util;\n \n@@ -57,7 +61,7 @@ pub struct Obligation<'tcx, T> {\n }\n \n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n-pub type TraitObligation<'tcx> = Obligation<'tcx, Rc<ty::PolyTraitRef<'tcx>>>;\n+pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n /// Why did we incur this obligation? Used for error reporting.\n #[deriving(Clone)]\n@@ -107,9 +111,18 @@ pub enum ObligationCauseCode<'tcx> {\n     // static items must have `Sync` type\n     SharedStatic,\n \n-    BuiltinDerivedObligation(Rc<ty::PolyTraitRef<'tcx>>, Rc<ObligationCauseCode<'tcx>>),\n+    BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n \n-    ImplDerivedObligation(Rc<ty::PolyTraitRef<'tcx>>, Rc<ObligationCauseCode<'tcx>>),\n+    ImplDerivedObligation(DerivedObligationCause<'tcx>),\n+}\n+\n+#[deriving(Clone)]\n+pub struct DerivedObligationCause<'tcx> {\n+    /// Resolving this trait led to the current obligation\n+    parent_trait_ref: ty::PolyTraitRef<'tcx>,\n+\n+    /// The parent trait had this cause\n+    parent_code: Rc<ObligationCauseCode<'tcx>>\n }\n \n pub type Obligations<'tcx, O> = subst::VecPerParamSpace<Obligation<'tcx, O>>;\n@@ -122,8 +135,8 @@ pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n pub enum SelectionError<'tcx> {\n     Unimplemented,\n     Overflow,\n-    OutputTypeParameterMismatch(Rc<ty::PolyTraitRef<'tcx>>,\n-                                Rc<ty::PolyTraitRef<'tcx>>,\n+    OutputTypeParameterMismatch(ty::PolyTraitRef<'tcx>,\n+                                ty::PolyTraitRef<'tcx>,\n                                 ty::type_err<'tcx>),\n }\n \n@@ -135,6 +148,7 @@ pub struct FulfillmentError<'tcx> {\n #[deriving(Clone)]\n pub enum FulfillmentErrorCode<'tcx> {\n     CodeSelectionError(SelectionError<'tcx>),\n+    CodeProjectionError(MismatchedProjectionTypes<'tcx>),\n     CodeAmbiguity,\n }\n \n@@ -235,7 +249,7 @@ pub struct VtableBuiltinData<N> {\n #[deriving(PartialEq,Eq,Clone)]\n pub struct VtableParamData<'tcx> {\n     // In the above example, this would `Eq`\n-    pub bound: Rc<ty::PolyTraitRef<'tcx>>,\n+    pub bound: ty::PolyTraitRef<'tcx>,\n }\n \n /// True if neither the trait nor self type is local. Note that `impl_def_id` must refer to an impl\n@@ -324,12 +338,6 @@ impl<'tcx,O> Obligation<'tcx,O> {\n     }\n }\n \n-impl<'tcx> TraitObligation<'tcx> {\n-    pub fn self_ty(&self) -> Ty<'tcx> {\n-        self.predicate.self_ty()\n-    }\n-}\n-\n impl<'tcx> ObligationCause<'tcx> {\n     pub fn new(span: Span,\n                body_id: ast::NodeId,\n@@ -441,6 +449,13 @@ impl<'tcx> FulfillmentError<'tcx> {\n             CodeAmbiguity => false,\n             CodeSelectionError(Overflow) => true,\n             CodeSelectionError(_) => false,\n+            CodeProjectionError(_) => false,\n         }\n     }\n }\n+\n+impl<'tcx> TraitObligation<'tcx> {\n+    fn self_ty(&self) -> Ty<'tcx> {\n+        self.predicate.0.self_ty()\n+    }\n+}"}, {"sha": "083227d02bd0697555f28a03c171011317e8b034", "filename": "src/librustc/middle/traits/project.rs", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -0,0 +1,374 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code for projecting associated types out of trait references.\n+\n+use super::elaborate_predicates;\n+use super::Obligation;\n+use super::PredicateObligation;\n+use super::SelectionContext;\n+use super::SelectionError;\n+use super::VtableImplData;\n+\n+use middle::infer;\n+use middle::subst::Subst;\n+use middle::ty::{mod, ToPolyTraitRef, Ty};\n+use std::fmt;\n+use util::ppaux::Repr;\n+\n+pub type PolyProjectionObligation<'tcx> =\n+    Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n+\n+pub type ProjectionObligation<'tcx> =\n+    Obligation<'tcx, ty::ProjectionPredicate<'tcx>>;\n+\n+pub type ProjectionTyObligation<'tcx> =\n+    Obligation<'tcx, ty::ProjectionTy<'tcx>>;\n+\n+/// When attempting to resolve `<T as TraitRef>::Name == U`...\n+pub enum ProjectionError<'tcx> {\n+    NoCandidate,\n+    TooManyCandidates,\n+\n+    ///\n+    MismatchedTypes(MismatchedProjectionTypes<'tcx>),\n+\n+    /// ...an error occurred matching `T : TraitRef`\n+    TraitSelectionError(SelectionError<'tcx>),\n+}\n+\n+#[deriving(Clone)]\n+pub struct MismatchedProjectionTypes<'tcx> {\n+    pub err: ty::type_err<'tcx> // TODO expected/actual/etc\n+}\n+\n+pub type ProjectionResult<'tcx, T> = Result<T, ProjectionError<'tcx>>;\n+\n+enum ProjectionTyCandidate<'tcx> {\n+    ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n+    Impl(VtableImplData<'tcx, PredicateObligation<'tcx>>),\n+}\n+\n+struct ProjectionTyCandidateSet<'tcx> {\n+    vec: Vec<ProjectionTyCandidate<'tcx>>,\n+    ambiguous: bool\n+}\n+\n+pub fn poly_project_and_unify_type<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &PolyProjectionObligation<'tcx>)\n+    -> ProjectionResult<'tcx, ()>\n+{\n+    debug!(\"poly_project(obligation={})\",\n+           obligation.repr(selcx.tcx()));\n+\n+    let infcx = selcx.infcx();\n+\n+    infcx.try(|snapshot| {\n+        let (skol_predicate, skol_map) =\n+            infcx.skolemize_late_bound_regions(&obligation.predicate, snapshot);\n+\n+        let skol_obligation = obligation.with(skol_predicate);\n+        let () = try!(project_and_unify_type(selcx, &skol_obligation));\n+        match infcx.leak_check(&skol_map, snapshot) {\n+            Ok(()) => Ok(()),\n+            Err(e) => Err(ProjectionError::MismatchedTypes(MismatchedProjectionTypes{err: e})),\n+        }\n+    })\n+}\n+\n+/// Compute result of projecting an associated type and unify it with\n+/// `obligation.predicate.ty` (if we can).\n+pub fn project_and_unify_type<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionObligation<'tcx>)\n+    -> ProjectionResult<'tcx, ()>\n+{\n+    debug!(\"project_and_unify(obligation={})\",\n+           obligation.repr(selcx.tcx()));\n+\n+    let ty_obligation = obligation.with(obligation.predicate.projection_ty.clone());\n+    let projected_ty = try!(project_type(selcx, &ty_obligation));\n+    let infcx = selcx.infcx();\n+    let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+    debug!(\"project_and_unify_type: projected_ty = {}\", projected_ty.repr(selcx.tcx()));\n+    match infer::mk_eqty(infcx, true, origin, projected_ty, obligation.predicate.ty) {\n+        Ok(()) => Ok(()),\n+        Err(e) => Err(ProjectionError::MismatchedTypes(MismatchedProjectionTypes{err: e})),\n+    }\n+}\n+\n+/// Compute the result of a projection type (if we can).\n+pub fn project_type<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>)\n+    -> ProjectionResult<'tcx, Ty<'tcx>>\n+{\n+    debug!(\"project(obligation={})\",\n+           obligation.repr(selcx.tcx()));\n+\n+    let mut candidates = ProjectionTyCandidateSet {\n+        vec: Vec::new(),\n+        ambiguous: false,\n+    };\n+\n+    let () = assemble_candidates_from_param_env(selcx,\n+                                                obligation,\n+                                                &mut candidates);\n+\n+    let () = try!(assemble_candidates_from_impls(selcx,\n+                                                 obligation,\n+                                                 &mut candidates));\n+\n+    debug!(\"{} candidates, ambiguous={}\",\n+           candidates.vec.len(),\n+           candidates.ambiguous);\n+\n+    // We probably need some winnowing logic similar to select here.\n+\n+    if candidates.ambiguous || candidates.vec.len() > 1 {\n+        return Err(ProjectionError::TooManyCandidates);\n+    }\n+\n+    match candidates.vec.pop() {\n+        Some(candidate) => {\n+            Ok(try!(confirm_candidate(selcx, obligation, candidate)))\n+        }\n+        None => {\n+            Err(ProjectionError::NoCandidate)\n+        }\n+    }\n+}\n+\n+/// The first thing we have to do is scan through the parameter\n+/// environment to see whether there are any projection predicates\n+/// there that can answer this question.\n+fn assemble_candidates_from_param_env<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation:  &ProjectionTyObligation<'tcx>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n+{\n+    let infcx = selcx.infcx();\n+    let env_predicates = selcx.param_env().caller_bounds.predicates.clone();\n+    let env_predicates = env_predicates.iter().cloned().collect();\n+    for predicate in elaborate_predicates(selcx.tcx(), env_predicates) {\n+        match predicate {\n+            ty::Predicate::Projection(ref data) => {\n+                let is_match = infcx.probe(|_| {\n+                    let origin = infer::Misc(obligation.cause.span);\n+                    let obligation_poly_trait_ref =\n+                        obligation.predicate.trait_ref.to_poly_trait_ref();\n+                    let data_poly_trait_ref =\n+                        data.to_poly_trait_ref();\n+                    infcx.sub_poly_trait_refs(false,\n+                                              origin,\n+                                              obligation_poly_trait_ref,\n+                                              data_poly_trait_ref).is_ok()\n+                });\n+\n+                if is_match {\n+                    candidate_set.vec.push(\n+                        ProjectionTyCandidate::ParamEnv(data.clone()));\n+                }\n+            }\n+            _ => { }\n+        }\n+    }\n+}\n+\n+fn assemble_candidates_from_impls<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation:  &ProjectionTyObligation<'tcx>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n+    -> ProjectionResult<'tcx, ()>\n+{\n+    // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n+    // start out by selecting the predicate `T as TraitRef<...>`:\n+    let trait_ref =\n+        obligation.predicate.trait_ref.to_poly_trait_ref();\n+    let trait_obligation =\n+        obligation.with(trait_ref.to_poly_trait_predicate());\n+    let vtable = match selcx.select(&trait_obligation) {\n+        Ok(Some(vtable)) => vtable,\n+        Ok(None) => {\n+            candidate_set.ambiguous = true;\n+            return Ok(());\n+        }\n+        Err(e) => {\n+            debug!(\"assemble_candidates_from_impls: selection error {}\",\n+                   e.repr(selcx.tcx()));\n+            return Err(ProjectionError::TraitSelectionError(e));\n+        }\n+    };\n+\n+    match vtable {\n+        super::VtableImpl(data) => {\n+            candidate_set.vec.push(\n+                ProjectionTyCandidate::Impl(data));\n+        }\n+        super::VtableParam(..) => {\n+            // This case tell us nothing about the value of an\n+            // associated type. Consider:\n+            //\n+            // ```\n+            // trait SomeTrait { type Foo; }\n+            // fn foo<T:SomeTrait>(...) { }\n+            // ```\n+            //\n+            // If the user writes `<T as SomeTrait>::Foo`, then the `T\n+            // : SomeTrait` binding does not help us decide what the\n+            // type `Foo` is (at least, not more specifically than\n+            // what we already knew).\n+            //\n+            // But wait, you say! What about an example like this:\n+            //\n+            // ```\n+            // fn bar<T:SomeTrait<Foo=uint>>(...) { ... }\n+            // ```\n+            //\n+            // Doesn't the `T : Sometrait<Foo=uint>` predicate help\n+            // resolve `T::Foo`? And of course it does, but in fact\n+            // that single predicate is desugared into two predicates\n+            // in the compiler: a trait predicate (`T : SomeTrait`) and a\n+            // projection. And the projection where clause is handled\n+            // in `assemble_candidates_from_param_env`.\n+        }\n+        super::VtableBuiltin(..) |\n+        super::VtableUnboxedClosure(..) |\n+        super::VtableFnPointer(..) => {\n+            // These traits have no associated types.\n+            selcx.tcx().sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"Cannot project an associated type from `{}`\",\n+                        vtable.repr(selcx.tcx())).as_slice());\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn confirm_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation:  &ProjectionTyObligation<'tcx>,\n+    candidate: ProjectionTyCandidate<'tcx>)\n+    -> ProjectionResult<'tcx, Ty<'tcx>>\n+{\n+    let infcx = selcx.infcx();\n+\n+    debug!(\"confirm_candidate(candidate={}, obligation={})\",\n+           candidate.repr(infcx.tcx),\n+           obligation.repr(infcx.tcx));\n+\n+    let projected_ty = match candidate {\n+        ProjectionTyCandidate::ParamEnv(poly_projection) => {\n+            let projection =\n+                infcx.replace_late_bound_regions_with_fresh_var(\n+                    obligation.cause.span,\n+                    infer::LateBoundRegionConversionTime::HigherRankedType,\n+                    &poly_projection).0;\n+\n+            assert_eq!(projection.projection_ty.item_name,\n+                       obligation.predicate.item_name);\n+\n+            let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+            match infcx.sub_trait_refs(false,\n+                                       origin,\n+                                       obligation.predicate.trait_ref.clone(),\n+                                       projection.projection_ty.trait_ref.clone()) {\n+                Ok(()) => { }\n+                Err(e) => {\n+                    selcx.tcx().sess.span_bug(\n+                        obligation.cause.span,\n+                        format!(\"Failed to unify `{}` and `{}` in projection: {}\",\n+                                obligation.repr(selcx.tcx()),\n+                                projection.repr(selcx.tcx()),\n+                                ty::type_err_to_str(selcx.tcx(), &e)).as_slice());\n+                }\n+            }\n+\n+            projection.ty\n+        }\n+\n+        ProjectionTyCandidate::Impl(impl_vtable) => {\n+            // there don't seem to be nicer accessors to these:\n+            let impl_items_map = selcx.tcx().impl_items.borrow();\n+            let impl_or_trait_items_map = selcx.tcx().impl_or_trait_items.borrow();\n+\n+            let impl_items = &impl_items_map[impl_vtable.impl_def_id];\n+            let mut impl_ty = None;\n+            for impl_item in impl_items.iter() {\n+                let assoc_type = match impl_or_trait_items_map[impl_item.def_id()] {\n+                    ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n+                    ty::MethodTraitItem(..) => { continue; }\n+                };\n+\n+                if assoc_type.name != obligation.predicate.item_name {\n+                    continue;\n+                }\n+\n+                let impl_poly_ty = ty::lookup_item_type(selcx.tcx(), assoc_type.def_id);\n+                impl_ty = Some(impl_poly_ty.ty.subst(selcx.tcx(), &impl_vtable.substs));\n+                break;\n+            }\n+\n+            match impl_ty {\n+                Some(ty) => ty,\n+                None => {\n+                    selcx.tcx().sess.span_bug(\n+                        obligation.cause.span,\n+                        format!(\"impl `{}` did not contain projection for `{}`\",\n+                                impl_vtable.repr(selcx.tcx()),\n+                                obligation.repr(selcx.tcx())).as_slice());\n+                }\n+            }\n+        }\n+    };\n+\n+    Ok(projected_ty)\n+}\n+\n+impl<'tcx> Repr<'tcx> for super::MismatchedProjectionTypes<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        self.err.repr(tcx)\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ProjectionError<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match *self {\n+            ProjectionError::NoCandidate =>\n+                format!(\"NoCandidate\"),\n+            ProjectionError::TooManyCandidates =>\n+                format!(\"NoCandidate\"),\n+            ProjectionError::MismatchedTypes(ref m) =>\n+                format!(\"MismatchedTypes({})\", m.repr(tcx)),\n+            ProjectionError::TraitSelectionError(ref e) =>\n+                format!(\"TraitSelectionError({})\", e.repr(tcx)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Show for super::MismatchedProjectionTypes<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"MismatchedProjectionTypes(..)\")\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ProjectionTyCandidate<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match *self {\n+            ProjectionTyCandidate::ParamEnv(ref data) =>\n+                format!(\"ParamEnv({})\", data.repr(tcx)),\n+            ProjectionTyCandidate::Impl(ref data) =>\n+                format!(\"Impl({})\", data.repr(tcx))\n+        }\n+    }\n+}\n+"}, {"sha": "2a3bb3c80c894a1d5faa415cab44bb43bf689929", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 91, "deletions": 77, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -13,10 +13,11 @@\n \n pub use self::MethodMatchResult::*;\n pub use self::MethodMatchedData::*;\n-use self::Candidate::*;\n+use self::SelectionCandidate::*;\n use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n+use super::{DerivedObligationCause};\n use super::{PredicateObligation, Obligation, TraitObligation, ObligationCause};\n use super::{ObligationCauseCode, BuiltinDerivedObligation};\n use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n@@ -29,7 +30,7 @@ use super::{util};\n use middle::fast_reject;\n use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n-use middle::ty::{mod, AsPredicate, RegionEscape, Ty};\n+use middle::ty::{mod, AsPredicate, RegionEscape, ToPolyTraitRef, Ty};\n use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n@@ -75,15 +76,15 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n \n     /// Trait ref from `obligation` but skolemized with the\n     /// selection-context's freshener. Used to check for recursion.\n-    fresh_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n+    fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n \n     previous: Option<&'prev TraitObligationStack<'prev, 'tcx>>\n }\n \n #[deriving(Clone)]\n pub struct SelectionCache<'tcx> {\n-    hashmap: RefCell<HashMap<Rc<ty::PolyTraitRef<'tcx>>,\n-                             SelectionResult<'tcx, Candidate<'tcx>>>>,\n+    hashmap: RefCell<HashMap<Rc<ty::TraitRef<'tcx>>,\n+                             SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n }\n \n pub enum MethodMatchResult {\n@@ -128,7 +129,7 @@ pub enum MethodMatchedData {\n /// clauses can give additional information (like, the types of output\n /// parameters) that would have to be inferred from the impl.\n #[deriving(PartialEq,Eq,Show,Clone)]\n-enum Candidate<'tcx> {\n+enum SelectionCandidate<'tcx> {\n     BuiltinCandidate(ty::BuiltinBound),\n     ParamCandidate(VtableParamData<'tcx>),\n     ImplCandidate(ast::DefId),\n@@ -144,8 +145,8 @@ enum Candidate<'tcx> {\n     ErrorCandidate,\n }\n \n-struct CandidateSet<'tcx> {\n-    vec: Vec<Candidate<'tcx>>,\n+struct SelectionCandidateSet<'tcx> {\n+    vec: Vec<SelectionCandidate<'tcx>>,\n     ambiguous: bool\n }\n \n@@ -193,6 +194,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx\n     }\n \n+    pub fn param_env(&self) -> &'cx ty::ParameterEnvironment<'tcx> {\n+        self.param_env\n+    }\n+\n     pub fn tcx(&self) -> &'cx ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -302,6 +307,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // evaluating trait matches\n                 EvaluatedToOk\n             }\n+\n+            ty::Predicate::Projection(..) => {\n+                // FIXME(#20296) -- we should be able to give a more precise answer here\n+                EvaluatedToAmbig\n+            }\n         }\n     }\n \n@@ -411,9 +421,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         self.infcx.probe(|snapshot| {\n             let (skol_obligation_trait_ref, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(&*obligation.predicate, snapshot);\n+                self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);\n             match self.match_impl(impl_def_id, obligation, snapshot,\n-                                  &skol_map, Rc::new(skol_obligation_trait_ref)) {\n+                                  &skol_map, skol_obligation_trait_ref.trait_ref.clone()) {\n                 Ok(substs) => {\n                     let vtable_impl = self.vtable_impl(impl_def_id,\n                                                        substs,\n@@ -439,7 +449,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn candidate_from_obligation<'o>(&mut self,\n                                      stack: &TraitObligationStack<'o, 'tcx>)\n-                                     -> SelectionResult<'tcx, Candidate<'tcx>>\n+                                     -> SelectionResult<'tcx, SelectionCandidate<'tcx>>\n     {\n         // Watch out for overflow. This intentionally bypasses (and does\n         // not update) the cache.\n@@ -455,17 +465,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // separately rather than using `stack.fresh_trait_ref` -- this\n         // is because we want the unbound variables to be replaced\n         // with fresh skolemized types starting from index 0.\n-        let cache_fresh_trait_ref =\n+        let cache_fresh_trait_pred =\n             self.infcx.freshen(stack.obligation.predicate.clone());\n-        debug!(\"candidate_from_obligation(cache_fresh_trait_ref={}, obligation={})\",\n-               cache_fresh_trait_ref.repr(self.tcx()),\n+        debug!(\"candidate_from_obligation(cache_fresh_trait_pred={}, obligation={})\",\n+               cache_fresh_trait_pred.repr(self.tcx()),\n                stack.repr(self.tcx()));\n         assert!(!stack.obligation.predicate.has_escaping_regions());\n \n-        match self.check_candidate_cache(cache_fresh_trait_ref.clone()) {\n+        match self.check_candidate_cache(&cache_fresh_trait_pred) {\n             Some(c) => {\n-                debug!(\"CACHE HIT: cache_fresh_trait_ref={}, candidate={}\",\n-                       cache_fresh_trait_ref.repr(self.tcx()),\n+                debug!(\"CACHE HIT: cache_fresh_trait_pred={}, candidate={}\",\n+                       cache_fresh_trait_pred.repr(self.tcx()),\n                        c.repr(self.tcx()));\n                 return c;\n             }\n@@ -474,17 +484,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // If no match, compute result and insert into cache.\n         let candidate = self.candidate_from_obligation_no_cache(stack);\n-        debug!(\"CACHE MISS: cache_fresh_trait_ref={}, candidate={}\",\n-               cache_fresh_trait_ref.repr(self.tcx()), candidate.repr(self.tcx()));\n-        self.insert_candidate_cache(cache_fresh_trait_ref, candidate.clone());\n+        debug!(\"CACHE MISS: cache_fresh_trait_pred={}, candidate={}\",\n+               cache_fresh_trait_pred.repr(self.tcx()), candidate.repr(self.tcx()));\n+        self.insert_candidate_cache(cache_fresh_trait_pred, candidate.clone());\n         candidate\n     }\n \n     fn candidate_from_obligation_no_cache<'o>(&mut self,\n                                               stack: &TraitObligationStack<'o, 'tcx>)\n-                                              -> SelectionResult<'tcx, Candidate<'tcx>>\n+                                              -> SelectionResult<'tcx, SelectionCandidate<'tcx>>\n     {\n-        if ty::type_is_error(stack.obligation.self_ty()) {\n+        if ty::type_is_error(stack.obligation.predicate.0.self_ty()) {\n             return Ok(Some(ErrorCandidate));\n         }\n \n@@ -576,7 +586,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn pick_candidate_cache(&self,\n-                            cache_fresh_trait_ref: &Rc<ty::PolyTraitRef<'tcx>>)\n+                            cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>)\n                             -> &SelectionCache<'tcx>\n     {\n         // High-level idea: we have to decide whether to consult the\n@@ -598,7 +608,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // If the trait refers to any parameters in scope, then use\n         // the cache of the param-environment.\n         if\n-            cache_fresh_trait_ref.0.input_types().iter().any(\n+            cache_fresh_trait_pred.0.input_types().iter().any(\n                 |&t| ty::type_has_self(t) || ty::type_has_params(t))\n         {\n             return &self.param_env.selection_cache;\n@@ -611,7 +621,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // See the discussion in doc.rs for more details.\n         if\n             !self.param_env.caller_bounds.is_empty() &&\n-            cache_fresh_trait_ref.0.input_types().iter().any(\n+            cache_fresh_trait_pred.0.input_types().iter().any(\n                 |&t| ty::type_has_ty_infer(t))\n         {\n             return &self.param_env.selection_cache;\n@@ -622,32 +632,32 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn check_candidate_cache(&mut self,\n-                             cache_fresh_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n-                             -> Option<SelectionResult<'tcx, Candidate<'tcx>>>\n+                             cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>)\n+                             -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>>\n     {\n-        let cache = self.pick_candidate_cache(&cache_fresh_trait_ref);\n+        let cache = self.pick_candidate_cache(cache_fresh_trait_pred);\n         let hashmap = cache.hashmap.borrow();\n-        hashmap.get(&cache_fresh_trait_ref).map(|c| (*c).clone())\n+        hashmap.get(&cache_fresh_trait_pred.0.trait_ref).map(|c| (*c).clone())\n     }\n \n     fn insert_candidate_cache(&mut self,\n-                              cache_fresh_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n-                              candidate: SelectionResult<'tcx, Candidate<'tcx>>)\n+                              cache_fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+                              candidate: SelectionResult<'tcx, SelectionCandidate<'tcx>>)\n     {\n-        let cache = self.pick_candidate_cache(&cache_fresh_trait_ref);\n+        let cache = self.pick_candidate_cache(&cache_fresh_trait_pred);\n         let mut hashmap = cache.hashmap.borrow_mut();\n-        hashmap.insert(cache_fresh_trait_ref, candidate);\n+        hashmap.insert(cache_fresh_trait_pred.0.trait_ref.clone(), candidate);\n     }\n \n     fn assemble_candidates<'o>(&mut self,\n                                stack: &TraitObligationStack<'o, 'tcx>)\n-                               -> Result<CandidateSet<'tcx>, SelectionError<'tcx>>\n+                               -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>>\n     {\n         // Check for overflow.\n \n         let TraitObligationStack { obligation, .. } = *stack;\n \n-        let mut candidates = CandidateSet {\n+        let mut candidates = SelectionCandidateSet {\n             vec: Vec::new(),\n             ambiguous: false\n         };\n@@ -658,7 +668,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n             Some(ty::BoundCopy) => {\n                 debug!(\"obligation self ty is {}\",\n-                       obligation.self_ty().repr(self.tcx()));\n+                       obligation.predicate.0.self_ty().repr(self.tcx()));\n \n                 // If the user has asked for the older, compatibility\n                 // behavior, ignore user-defined impls here. This will\n@@ -707,15 +717,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Never affects inference environment.\n     fn assemble_candidates_from_caller_bounds(&mut self,\n                                               obligation: &TraitObligation<'tcx>,\n-                                              candidates: &mut CandidateSet<'tcx>)\n+                                              candidates: &mut SelectionCandidateSet<'tcx>)\n                                               -> Result<(),SelectionError<'tcx>>\n     {\n         debug!(\"assemble_candidates_from_caller_bounds({})\",\n                obligation.repr(self.tcx()));\n \n         let caller_trait_refs: Vec<_> =\n             self.param_env.caller_bounds.predicates.iter()\n-            .filter_map(|o| o.to_trait())\n+            .filter_map(|o| o.to_opt_poly_trait_ref())\n             .collect();\n \n         let all_bounds =\n@@ -744,10 +754,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// unified during the confirmation step.\n     fn assemble_unboxed_closure_candidates(&mut self,\n                                            obligation: &TraitObligation<'tcx>,\n-                                           candidates: &mut CandidateSet<'tcx>)\n+                                           candidates: &mut SelectionCandidateSet<'tcx>)\n                                            -> Result<(),SelectionError<'tcx>>\n     {\n-        let kind = match self.fn_family_trait_kind(obligation.predicate.def_id()) {\n+        let kind = match self.fn_family_trait_kind(obligation.predicate.0.def_id()) {\n             Some(k) => k,\n             None => { return Ok(()); }\n         };\n@@ -789,7 +799,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Implement one of the `Fn()` family for a fn pointer.\n     fn assemble_fn_pointer_candidates(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n-                                      candidates: &mut CandidateSet<'tcx>)\n+                                      candidates: &mut SelectionCandidateSet<'tcx>)\n                                       -> Result<(),SelectionError<'tcx>>\n     {\n         // We provide a `Fn` impl for fn pointers. There is no need to provide\n@@ -827,16 +837,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Search for impls that might apply to `obligation`.\n     fn assemble_candidates_from_impls(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n-                                      candidate_vec: &mut Vec<Candidate<'tcx>>)\n+                                      candidate_vec: &mut Vec<SelectionCandidate<'tcx>>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n         let all_impls = self.all_impls(obligation.predicate.def_id());\n         for &impl_def_id in all_impls.iter() {\n             self.infcx.probe(|snapshot| {\n-                let (skol_obligation_trait_ref, skol_map) =\n-                    self.infcx().skolemize_late_bound_regions(&*obligation.predicate, snapshot);\n+                let (skol_obligation_trait_pred, skol_map) =\n+                    self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);\n                 match self.match_impl(impl_def_id, obligation, snapshot,\n-                                      &skol_map, Rc::new(skol_obligation_trait_ref)) {\n+                                      &skol_map, skol_obligation_trait_pred.trait_ref.clone()) {\n                     Ok(_) => {\n                         candidate_vec.push(ImplCandidate(impl_def_id));\n                     }\n@@ -861,7 +871,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// scrutiny.\n     fn winnow_candidate<'o>(&mut self,\n                             stack: &TraitObligationStack<'o, 'tcx>,\n-                            candidate: &Candidate<'tcx>)\n+                            candidate: &SelectionCandidate<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n         debug!(\"winnow_candidate: candidate={}\", candidate.repr(self.tcx()));\n@@ -918,8 +928,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// a case where doing the opposite caused us harm.\n     fn candidate_should_be_dropped_in_favor_of<'o>(&mut self,\n                                                    stack: &TraitObligationStack<'o, 'tcx>,\n-                                                   candidate_i: &Candidate<'tcx>,\n-                                                   candidate_j: &Candidate<'tcx>)\n+                                                   candidate_i: &SelectionCandidate<'tcx>,\n+                                                   candidate_j: &SelectionCandidate<'tcx>)\n                                                    -> bool\n     {\n         match (candidate_i, candidate_j) {\n@@ -931,16 +941,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.infcx.probe(|snapshot| {\n                     let (skol_obligation_trait_ref, skol_map) =\n                         self.infcx().skolemize_late_bound_regions(\n-                            &*stack.obligation.predicate, snapshot);\n+                            &stack.obligation.predicate, snapshot);\n                     let impl_substs =\n                         self.rematch_impl(impl_def_id, stack.obligation, snapshot,\n-                                          &skol_map, Rc::new(skol_obligation_trait_ref));\n+                                          &skol_map, skol_obligation_trait_ref.trait_ref.clone());\n                     let impl_trait_ref =\n                         ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap();\n                     let impl_trait_ref =\n                         impl_trait_ref.subst(self.tcx(), &impl_substs);\n                     let poly_impl_trait_ref =\n-                        Rc::new(ty::Binder((*impl_trait_ref).clone()));\n+                        ty::Binder(impl_trait_ref);\n                     let origin =\n                         infer::RelateOutputImplTypes(stack.obligation.cause.span);\n                     self.infcx\n@@ -966,7 +976,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn assemble_builtin_bound_candidates<'o>(&mut self,\n                                              bound: ty::BuiltinBound,\n                                              stack: &TraitObligationStack<'o, 'tcx>,\n-                                             candidates: &mut CandidateSet<'tcx>)\n+                                             candidates: &mut SelectionCandidateSet<'tcx>)\n                                              -> Result<(),SelectionError<'tcx>>\n     {\n         match self.builtin_bound(bound, stack.obligation) {\n@@ -987,7 +997,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                      obligation: &TraitObligation<'tcx>)\n                      -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n     {\n-        let self_ty = self.infcx.shallow_resolve(obligation.predicate.self_ty());\n+        // TODO seems like we ought to skolemize here, oder?\n+        let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n         return match self_ty.sty {\n             ty::ty_infer(ty::IntVar(_)) |\n             ty::ty_infer(ty::FloatVar(_)) |\n@@ -1269,6 +1280,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nominal(self, bound, def_id, types)\n             }\n \n+            ty::ty_projection(_) |\n             ty::ty_param(_) => {\n                 // Note: A type parameter is only considered to meet a\n                 // particular bound if there is a where clause telling\n@@ -1360,7 +1372,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn confirm_candidate(&mut self,\n                          obligation: &TraitObligation<'tcx>,\n-                         candidate: Candidate<'tcx>)\n+                         candidate: SelectionCandidate<'tcx>)\n                          -> Result<Selection<'tcx>,SelectionError<'tcx>>\n     {\n         debug!(\"confirm_candidate({}, {})\",\n@@ -1416,7 +1428,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // trait-ref. Repeat that unification now without any\n         // transactional boundary; it should not fail.\n         match self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                           obligation.predicate.clone(),\n+                                           obligation.predicate.to_poly_trait_ref(),\n                                            param.bound.clone()) {\n             Ok(()) => Ok(param),\n             Err(_) => {\n@@ -1501,9 +1513,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // this time not in a probe.\n         self.infcx.try(|snapshot| {\n             let (skol_obligation_trait_ref, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(&*obligation.predicate, snapshot);\n-            let substs = self.rematch_impl(impl_def_id, obligation,\n-                                           snapshot, &skol_map, Rc::new(skol_obligation_trait_ref));\n+                self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);\n+            let substs =\n+                self.rematch_impl(impl_def_id, obligation,\n+                                  snapshot, &skol_map, skol_obligation_trait_ref.trait_ref);\n             debug!(\"confirm_impl_candidate substs={}\", substs);\n             Ok(self.vtable_impl(impl_def_id, substs, obligation.cause.clone(),\n                                 obligation.recursion_depth + 1, skol_map, snapshot))\n@@ -1574,13 +1587,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 vec![],\n                 vec![],\n                 self_ty);\n-        let trait_ref = Rc::new(ty::Binder(ty::TraitRef {\n+        let trait_ref = ty::Binder(Rc::new(ty::TraitRef {\n             def_id: obligation.predicate.def_id(),\n             substs: self.tcx().mk_substs(substs),\n         }));\n \n         try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                          obligation.predicate.clone(),\n+                                          obligation.predicate.to_poly_trait_ref(),\n                                           trait_ref));\n         Ok(self_ty)\n     }\n@@ -1615,7 +1628,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 vec![],\n                 vec![],\n                 obligation.self_ty());\n-        let trait_ref = Rc::new(ty::Binder(ty::TraitRef {\n+        let trait_ref = ty::Binder(Rc::new(ty::TraitRef {\n             def_id: obligation.predicate.def_id(),\n             substs: self.tcx().mk_substs(substs),\n         }));\n@@ -1625,7 +1638,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                trait_ref.repr(self.tcx()));\n \n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                     obligation.predicate.clone(),\n+                                     obligation.predicate.to_poly_trait_ref(),\n                                      trait_ref)\n     }\n \n@@ -1656,8 +1669,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// report an error to the user.\n     fn confirm_poly_trait_refs(&mut self,\n                                obligation_cause: ObligationCause,\n-                               obligation_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n-                               expected_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+                               obligation_trait_ref: ty::PolyTraitRef<'tcx>,\n+                               expected_trait_ref: ty::PolyTraitRef<'tcx>)\n                                -> Result<(), SelectionError<'tcx>>\n     {\n         let origin = infer::RelateOutputImplTypes(obligation_cause.span);\n@@ -1770,7 +1783,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // substitution if we find that any of the input types, when\n         // simplified, do not match.\n \n-        obligation.predicate.input_types().iter()\n+        obligation.predicate.0.input_types().iter()\n             .zip(impl_trait_ref.input_types().iter())\n             .any(|(&obligation_ty, &impl_ty)| {\n                 let simplified_obligation_ty =\n@@ -1786,7 +1799,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_where_clause(&mut self,\n                           obligation: &TraitObligation<'tcx>,\n-                          where_clause_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+                          where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                         -> Result<(),()>\n     {\n         debug!(\"match_where_clause: obligation={} where_clause_trait_ref={}\",\n@@ -1797,7 +1810,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.infcx.sub_poly_trait_refs(false,\n                                              origin,\n                                              where_clause_trait_ref,\n-                                             obligation.predicate.clone()) {\n+                                             obligation.predicate.to_poly_trait_ref()) {\n             Ok(()) => Ok(()),\n             Err(_) => Err(()),\n         }\n@@ -1879,7 +1892,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             obligation: &'o TraitObligation<'tcx>)\n                             -> TraitObligationStack<'o, 'tcx>\n     {\n-        let fresh_trait_ref = obligation.predicate.fold_with(&mut self.freshener);\n+        let fresh_trait_ref =\n+            obligation.predicate.to_poly_trait_ref().fold_with(&mut self.freshener);\n \n         TraitObligationStack {\n             obligation: obligation,\n@@ -1932,9 +1946,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     #[allow(unused_comparisons)]\n     fn derived_cause(&self,\n                      obligation: &TraitObligation<'tcx>,\n-                     variant: fn(Rc<ty::Binder<ty::TraitRef<'tcx>>>,\n-                                 Rc<ObligationCauseCode<'tcx>>)\n-                                 -> ObligationCauseCode<'tcx>)\n+                     variant: fn(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>)\n                      -> ObligationCause<'tcx>\n     {\n         /*!\n@@ -1951,17 +1963,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // chain. Ideally, we should have a way to configure this either\n         // by using -Z verbose or just a CLI argument.\n         if obligation.recursion_depth >= 0 {\n+            let derived_cause = DerivedObligationCause {\n+                parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n+                parent_code: Rc::new(obligation.cause.code.clone()),\n+            };\n             ObligationCause::new(obligation.cause.span,\n-                                 obligation.trait_ref.def_id().node,\n-                                 variant(obligation.trait_ref.clone(),\n-                                         Rc::new(obligation.cause.code.clone())))\n+                                 obligation.cause.body_id,\n+                                 variant(derived_cause))\n         } else {\n             obligation.cause.clone()\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for Candidate<'tcx> {\n+impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n@@ -2021,8 +2036,7 @@ impl<'tcx> EvaluationResult<'tcx> {\n             EvaluatedToOk |\n             EvaluatedToAmbig |\n             EvaluatedToErr(Overflow) |\n-            EvaluatedToErr(OutputTypeParameterMismatch(..)) |\n-            EvaluatedToErr(ProjectionMismatch(..)) => {\n+            EvaluatedToErr(OutputTypeParameterMismatch(..)) => {\n                 true\n             }\n             EvaluatedToErr(Unimplemented) => {"}, {"sha": "00995e1ee43cff70b1bf62f90234f7a6b6773cd1", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -10,7 +10,7 @@\n \n use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::infer::InferCtxt;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, Ty, AsPredicate, ToPolyTraitRef};\n use std::collections::HashSet;\n use std::fmt;\n use std::rc::Rc;\n@@ -46,19 +46,19 @@ struct StackEntry<'tcx> {\n \n pub fn elaborate_trait_ref<'cx, 'tcx>(\n     tcx: &'cx ty::ctxt<'tcx>,\n-    trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+    trait_ref: ty::PolyTraitRef<'tcx>)\n     -> Elaborator<'cx, 'tcx>\n {\n-    elaborate_predicates(tcx, vec![ty::Predicate::Trait(trait_ref)])\n+    elaborate_predicates(tcx, vec![trait_ref.as_predicate()])\n }\n \n pub fn elaborate_trait_refs<'cx, 'tcx>(\n     tcx: &'cx ty::ctxt<'tcx>,\n-    trait_refs: &[Rc<ty::PolyTraitRef<'tcx>>])\n+    trait_refs: &[ty::PolyTraitRef<'tcx>])\n     -> Elaborator<'cx, 'tcx>\n {\n     let predicates = trait_refs.iter()\n-                               .map(|trait_ref| ty::Predicate::Trait((*trait_ref).clone()))\n+                               .map(|trait_ref| trait_ref.as_predicate())\n                                .collect();\n     elaborate_predicates(tcx, predicates)\n }\n@@ -80,21 +80,28 @@ pub fn elaborate_predicates<'cx, 'tcx>(\n impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n     fn push(&mut self, predicate: &ty::Predicate<'tcx>) {\n         match *predicate {\n-            ty::Predicate::Trait(ref trait_ref) => {\n+            ty::Predicate::Trait(ref data) => {\n                 let mut predicates =\n-                    ty::predicates_for_trait_ref(self.tcx, &**trait_ref);\n+                    ty::predicates_for_trait_ref(self.tcx,\n+                                                 &data.to_poly_trait_ref());\n \n                 // Only keep those bounds that we haven't already\n                 // seen.  This is necessary to prevent infinite\n                 // recursion in some cases.  One common case is when\n                 // people define `trait Sized { }` rather than `trait\n                 // Sized for Sized? { }`.\n-                predicates.retain(|r| self.visited.insert((*r).clone()));\n+                predicates.retain(|r| self.visited.insert(r.clone()));\n \n                 self.stack.push(StackEntry { position: 0,\n                                              predicates: predicates });\n             }\n             ty::Predicate::Equate(..) => {\n+                // Currently, we do not \"elaborate\" predicates like\n+                // `X == Y`, though conceivably we might. For example,\n+                // `&X == &Y` implies that `X == Y`.\n+            }\n+            ty::Predicate::Projection(..) => {\n+                // Nothing to elaborate in a projection predicate.\n             }\n             ty::Predicate::RegionOutlives(..) |\n             ty::Predicate::TypeOutlives(..) => {\n@@ -173,34 +180,32 @@ pub struct Supertraits<'cx, 'tcx:'cx> {\n }\n \n pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                              trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+                              trait_ref: ty::PolyTraitRef<'tcx>)\n                               -> Supertraits<'cx, 'tcx>\n {\n     let elaborator = elaborate_trait_ref(tcx, trait_ref);\n     Supertraits { elaborator: elaborator }\n }\n \n pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                                    bounds: &[Rc<ty::PolyTraitRef<'tcx>>])\n+                                    bounds: &[ty::PolyTraitRef<'tcx>])\n                                     -> Supertraits<'cx, 'tcx>\n {\n     let elaborator = elaborate_trait_refs(tcx, bounds);\n     Supertraits { elaborator: elaborator }\n }\n \n-impl<'cx, 'tcx> Iterator<Rc<ty::PolyTraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n-    fn next(&mut self) -> Option<Rc<ty::PolyTraitRef<'tcx>>> {\n+impl<'cx, 'tcx> Iterator<ty::PolyTraitRef<'tcx>> for Supertraits<'cx, 'tcx> {\n+    fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n         loop {\n             match self.elaborator.next() {\n                 None => {\n                     return None;\n                 }\n-                Some(ty::Predicate::Trait(trait_ref)) => {\n-                    return Some(trait_ref);\n+                Some(ty::Predicate::Trait(data)) => {\n+                    return Some(data.to_poly_trait_ref());\n                 }\n-                Some(ty::Predicate::Equate(..)) |\n-                Some(ty::Predicate::RegionOutlives(..)) |\n-                Some(ty::Predicate::TypeOutlives(..)) => {\n+                Some(_) => {\n                 }\n             }\n         }\n@@ -265,18 +270,18 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n     })\n }\n \n-pub fn poly_trait_ref_for_builtin_bound<'tcx>(\n+pub fn trait_ref_for_builtin_bound<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n     param_ty: Ty<'tcx>)\n-    -> Result<Rc<ty::PolyTraitRef<'tcx>>, ErrorReported>\n+    -> Result<Rc<ty::TraitRef<'tcx>>, ErrorReported>\n {\n     match tcx.lang_items.from_builtin_kind(builtin_bound) {\n         Ok(def_id) => {\n-            Ok(Rc::new(ty::Binder(ty::TraitRef {\n+            Ok(Rc::new(ty::TraitRef {\n                 def_id: def_id,\n                 substs: tcx.mk_substs(Substs::empty().with_self_ty(param_ty))\n-            })))\n+            }))\n         }\n         Err(e) => {\n             tcx.sess.err(e.as_slice());\n@@ -293,11 +298,11 @@ pub fn predicate_for_builtin_bound<'tcx>(\n     param_ty: Ty<'tcx>)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n-    let trait_ref = try!(poly_trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty));\n+    let trait_ref = try!(trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty));\n     Ok(Obligation {\n         cause: cause,\n         recursion_depth: recursion_depth,\n-        predicate: ty::Predicate::Trait(trait_ref),\n+        predicate: trait_ref.as_predicate(),\n     })\n }\n \n@@ -306,7 +311,7 @@ pub fn predicate_for_builtin_bound<'tcx>(\n /// true, where `d` is the def-id of the trait/supertrait. If any is found, return `Some(p)` where\n /// `p` is the path to that trait/supertrait. Else `None`.\n pub fn search_trait_and_supertraits_from_bound<'tcx,F>(tcx: &ty::ctxt<'tcx>,\n-                                                       caller_bound: Rc<ty::PolyTraitRef<'tcx>>,\n+                                                       caller_bound: ty::PolyTraitRef<'tcx>,\n                                                        mut test: F)\n                                                        -> Option<VtableParamData<'tcx>>\n     where F: FnMut(ast::DefId) -> bool,\n@@ -390,12 +395,6 @@ impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n                         a.repr(tcx),\n                         b.repr(tcx),\n                         c.repr(tcx)),\n-\n-            super::ProjectionMismatch(ref a, ref b, ref c) =>\n-                format!(\"PrjectionMismatch({},{},{})\",\n-                        a.repr(tcx),\n-                        b.repr(tcx),\n-                        c.repr(tcx)),\n         }\n     }\n }\n@@ -412,6 +411,7 @@ impl<'tcx> Repr<'tcx> for super::FulfillmentErrorCode<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             super::CodeSelectionError(ref o) => o.repr(tcx),\n+            super::CodeProjectionError(ref o) => o.repr(tcx),\n             super::CodeAmbiguity => format!(\"Ambiguity\")\n         }\n     }\n@@ -421,6 +421,7 @@ impl<'tcx> fmt::Show for super::FulfillmentErrorCode<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             super::CodeSelectionError(ref e) => write!(f, \"{}\", e),\n+            super::CodeProjectionError(ref e) => write!(f, \"{}\", e),\n             super::CodeAmbiguity => write!(f, \"Ambiguity\")\n         }\n     }\n@@ -431,3 +432,4 @@ impl<'tcx> Repr<'tcx> for ty::type_err<'tcx> {\n         ty::type_err_to_str(tcx, self)\n     }\n }\n+"}, {"sha": "da65feb8fd3f8b9f2dfa633a311bac49abf940f8", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 435, "deletions": 47, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -587,7 +587,7 @@ pub enum vtable_origin<'tcx> {\n \n // For every explicit cast into an object type, maps from the cast\n // expr to the associated trait ref.\n-pub type ObjectCastMap<'tcx> = RefCell<NodeMap<Rc<ty::PolyTraitRef<'tcx>>>>;\n+pub type ObjectCastMap<'tcx> = RefCell<NodeMap<ty::PolyTraitRef<'tcx>>>;\n \n /// A restriction that certain types must be the same size. The use of\n /// `transmute` gives rise to these restrictions. These generally\n@@ -843,6 +843,7 @@ bitflags! {\n         const HAS_RE_LATE_BOUND   = 0b10000,\n         const HAS_REGIONS         = 0b100000,\n         const HAS_TY_ERR          = 0b1000000,\n+        const HAS_PROJECTION      = 0b10000000,\n         const NEEDS_SUBST   = HAS_PARAMS.bits | HAS_SELF.bits | HAS_REGIONS.bits,\n     }\n }\n@@ -989,6 +990,9 @@ pub fn type_has_ty_infer(ty: Ty) -> bool {\n pub fn type_needs_infer(ty: Ty) -> bool {\n     ty.flags.intersects(HAS_TY_INFER | HAS_RE_INFER)\n }\n+pub fn type_has_projection(ty: Ty) -> bool {\n+    ty.flags.intersects(HAS_PROJECTION)\n+}\n \n pub fn type_has_late_bound_regions(ty: Ty) -> bool {\n     ty.flags.intersects(HAS_RE_LATE_BOUND)\n@@ -1354,7 +1358,9 @@ pub enum sty<'tcx> {\n \n     ty_tup(Vec<Ty<'tcx>>),\n \n+    ty_projection(Box<TyProjection<'tcx>>),\n     ty_param(ParamTy), // type parameter\n+\n     ty_open(Ty<'tcx>), // A deref'ed fat pointer, i.e., a dynamically sized value\n                        // and its size. Only ever used in trans. It is not necessary\n                        // earlier since we don't need to distinguish a DST with its\n@@ -1370,22 +1376,30 @@ pub enum sty<'tcx> {\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct TyTrait<'tcx> {\n     // Principal trait reference.\n-    pub principal: PolyTraitRef<'tcx>,\n+    pub principal: ty::Binder<TraitRef<'tcx>>,\n     pub bounds: ExistentialBounds\n }\n \n impl<'tcx> TyTrait<'tcx> {\n+    pub fn principal_def_id(&self) -> ast::DefId {\n+        self.principal.0.def_id\n+    }\n+\n     /// Object types don't have a self-type specified. Therefore, when\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self-type. A common choice is `mk_err()`\n     /// or some skolemized type.\n     pub fn principal_trait_ref_with_self_ty(&self,\n-                                            tcx: &ctxt<'tcx>, self_ty: Ty<'tcx>)\n-                                            -> Rc<ty::PolyTraitRef<'tcx>>\n+                                            tcx: &ctxt<'tcx>,\n+                                            self_ty: Ty<'tcx>)\n+                                            -> ty::PolyTraitRef<'tcx>\n     {\n-        Rc::new(ty::Binder(ty::TraitRef {\n-            def_id: self.principal.def_id(),\n-            substs: tcx.mk_substs(self.principal.substs().with_self_ty(self_ty)),\n+        // otherwise the escaping regions would be captured by the binder\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        ty::Binder(Rc::new(ty::TraitRef {\n+            def_id: self.principal.0.def_id,\n+            substs: tcx.mk_substs(self.principal.0.substs.with_self_ty(self_ty)),\n         }))\n     }\n }\n@@ -1411,7 +1425,7 @@ pub struct TraitRef<'tcx> {\n     pub substs: &'tcx Substs<'tcx>,\n }\n \n-pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n+pub type PolyTraitRef<'tcx> = Binder<Rc<TraitRef<'tcx>>>;\n \n impl<'tcx> PolyTraitRef<'tcx> {\n     pub fn self_ty(&self) -> Ty<'tcx> {\n@@ -1429,6 +1443,17 @@ impl<'tcx> PolyTraitRef<'tcx> {\n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n         self.0.input_types()\n     }\n+\n+    pub fn to_poly_trait_predicate(&self) -> PolyTraitPredicate<'tcx> {\n+        // Note that we preserve binding levels\n+        Binder(TraitPredicate { trait_ref: self.0.clone() })\n+    }\n+\n+    pub fn remove_rc(&self) -> ty::Binder<ty::TraitRef<'tcx>> {\n+        // Annoyingly, we can't easily put a `Rc` into a `sty` structure,\n+        // and hence we have to remove the rc to put this into a `TyTrait`.\n+        ty::Binder((*self.0).clone())\n+    }\n }\n \n /// Binder is a binder for higher-ranked lifetimes. It is part of the\n@@ -1501,7 +1526,8 @@ pub enum type_err<'tcx> {\n pub struct ParamBounds<'tcx> {\n     pub region_bounds: Vec<ty::Region>,\n     pub builtin_bounds: BuiltinBounds,\n-    pub trait_bounds: Vec<Rc<PolyTraitRef<'tcx>>>\n+    pub trait_bounds: Vec<PolyTraitRef<'tcx>>,\n+    pub projection_bounds: Vec<PolyProjectionPredicate<'tcx>>,\n }\n \n /// Bounds suitable for an existentially quantified type parameter\n@@ -1672,7 +1698,6 @@ pub struct TypeParameterDef<'tcx> {\n     pub def_id: ast::DefId,\n     pub space: subst::ParamSpace,\n     pub index: u32,\n-    pub associated_with: Option<ast::DefId>,\n     pub bounds: ParamBounds<'tcx>,\n     pub default: Option<Ty<'tcx>>,\n }\n@@ -1731,7 +1756,7 @@ pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the parameters in the `TypeSpace`.\n-    Trait(Rc<PolyTraitRef<'tcx>>),\n+    Trait(PolyTraitPredicate<'tcx>),\n \n     /// where `T1 == T2`.\n     Equate(PolyEquatePredicate<'tcx>),\n@@ -1741,6 +1766,35 @@ pub enum Predicate<'tcx> {\n \n     /// where T : 'a\n     TypeOutlives(PolyTypeOutlivesPredicate<'tcx>),\n+\n+    ///\n+    Projection(PolyProjectionPredicate<'tcx>),\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub struct TraitPredicate<'tcx> {\n+    pub trait_ref: Rc<TraitRef<'tcx>>\n+}\n+pub type PolyTraitPredicate<'tcx> = ty::Binder<TraitPredicate<'tcx>>;\n+\n+impl<'tcx> TraitPredicate<'tcx> {\n+    pub fn def_id(&self) -> ast::DefId {\n+        self.trait_ref.def_id\n+    }\n+\n+    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+        self.trait_ref.substs.types.as_slice()\n+    }\n+\n+    pub fn self_ty(&self) -> Ty<'tcx> {\n+        self.trait_ref.self_ty()\n+    }\n+}\n+\n+impl<'tcx> PolyTraitPredicate<'tcx> {\n+    pub fn def_id(&self) -> ast::DefId {\n+        self.0.def_id()\n+    }\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n@@ -1753,13 +1807,90 @@ pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n pub type PolyRegionOutlivesPredicate = PolyOutlivesPredicate<ty::Region, ty::Region>;\n pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::Region>;\n \n+/// This kind of predicate has no *direct* correspondent in the\n+/// syntax, but it roughly corresponds to the syntactic forms:\n+///\n+/// 1. `T : TraitRef<..., Item=Type>`\n+/// 2. `<T as TraitRef<...>>::Item == Type` (NYI)\n+///\n+/// In particular, form #1 is \"desugared\" to the combination of a\n+/// normal trait predicate (`T : TraitRef<...>`) and one of these\n+/// predicates. Form #2 is a broader form in that it also permits\n+/// equality between arbitrary types. Processing an instance of Form\n+/// #2 eventually yields one of these `ProjectionPredicate`\n+/// instances to normalize the LHS.\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub struct ProjectionPredicate<'tcx> {\n+    pub projection_ty: ProjectionTy<'tcx>,\n+    pub ty: Ty<'tcx>,\n+}\n+\n+pub type PolyProjectionPredicate<'tcx> = Binder<ProjectionPredicate<'tcx>>;\n+\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub struct ProjectionTy<'tcx> {\n+    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    pub item_name: ast::Name,\n+}\n+\n+// Annoying: a version of `ProjectionTy` that avoids the `Rc`, because\n+// it is difficult to place an `Rc` in the `sty` struct. Eventually\n+// these two types ought to be unified.\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub struct TyProjection<'tcx> {\n+    pub trait_ref: ty::TraitRef<'tcx>,\n+    pub item_name: ast::Name,\n+}\n+\n+pub trait ToPolyTraitRef<'tcx> {\n+    fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx>;\n+}\n+\n+impl<'tcx> ToPolyTraitRef<'tcx> for Rc<TraitRef<'tcx>> {\n+    fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {\n+        assert!(!self.has_escaping_regions());\n+        ty::Binder(self.clone())\n+    }\n+}\n+\n+impl<'tcx> ToPolyTraitRef<'tcx> for PolyTraitPredicate<'tcx> {\n+    fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {\n+        // We are just preserving the binder levels here\n+        ty::Binder(self.0.trait_ref.clone())\n+    }\n+}\n+\n+impl<'tcx> ToPolyTraitRef<'tcx> for PolyProjectionPredicate<'tcx> {\n+    fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {\n+        // Note: unlike with TraitRef::to_poly_trait_ref(),\n+        // self.0.trait_ref is permitted to have escaping regions.\n+        // This is because here `self` has a `Binder` and so does our\n+        // return value, so we are preserving the number of binding\n+        // levels.\n+        ty::Binder(self.0.projection_ty.trait_ref.clone())\n+    }\n+}\n+\n pub trait AsPredicate<'tcx> {\n     fn as_predicate(&self) -> Predicate<'tcx>;\n }\n \n-impl<'tcx> AsPredicate<'tcx> for Rc<PolyTraitRef<'tcx>> {\n+impl<'tcx> AsPredicate<'tcx> for Rc<TraitRef<'tcx>> {\n     fn as_predicate(&self) -> Predicate<'tcx> {\n-        Predicate::Trait(self.clone())\n+        // we're about to add a binder, so let's check that we don't\n+        // accidentally capture anything, or else that might be some\n+        // weird debruijn accounting.\n+        assert!(!self.has_escaping_regions());\n+\n+        ty::Predicate::Trait(ty::Binder(ty::TraitPredicate {\n+            trait_ref: self.clone()\n+        }))\n+    }\n+}\n+\n+impl<'tcx> AsPredicate<'tcx> for PolyTraitRef<'tcx> {\n+    fn as_predicate(&self) -> Predicate<'tcx> {\n+        ty::Predicate::Trait(self.to_poly_trait_predicate())\n     }\n }\n \n@@ -1781,21 +1912,29 @@ impl<'tcx> AsPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> AsPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n+    fn as_predicate(&self) -> Predicate<'tcx> {\n+        Predicate::Projection(self.clone())\n+    }\n+}\n+\n impl<'tcx> Predicate<'tcx> {\n     pub fn has_escaping_regions(&self) -> bool {\n         match *self {\n             Predicate::Trait(ref trait_ref) => trait_ref.has_escaping_regions(),\n             Predicate::Equate(ref p) => p.has_escaping_regions(),\n             Predicate::RegionOutlives(ref p) => p.has_escaping_regions(),\n             Predicate::TypeOutlives(ref p) => p.has_escaping_regions(),\n+            Predicate::Projection(ref p) => p.has_escaping_regions(),\n         }\n     }\n \n-    pub fn to_trait(&self) -> Option<Rc<PolyTraitRef<'tcx>>> {\n+    pub fn to_opt_poly_trait_ref(&self) -> Option<PolyTraitRef<'tcx>> {\n         match *self {\n             Predicate::Trait(ref t) => {\n-                Some(t.clone())\n+                Some(t.to_poly_trait_ref())\n             }\n+            Predicate::Projection(..) |\n             Predicate::Equate(..) |\n             Predicate::RegionOutlives(..) |\n             Predicate::TypeOutlives(..) => {\n@@ -2032,7 +2171,12 @@ pub struct TraitDef<'tcx> {\n \n     /// The \"supertrait\" bounds.\n     pub bounds: ParamBounds<'tcx>,\n+\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+\n+    /// A list of the associated types defined in this trait. Useful\n+    /// for resolving `X::Foo` type markers.\n+    pub associated_type_names: Vec<ast::Name>,\n }\n \n /// Records the substitutions used to translate the polytype for an\n@@ -2330,9 +2474,14 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n+            &ty_projection(ref data) => {\n+                self.add_flags(HAS_PROJECTION);\n+                self.add_substs(&data.trait_ref.substs);\n+            }\n+\n             &ty_trait(box TyTrait { ref principal, ref bounds }) => {\n                 let mut computation = FlagComputation::new();\n-                computation.add_substs(principal.substs());\n+                computation.add_substs(&principal.0.substs);\n                 self.add_bound_computation(&computation);\n \n                 self.add_bounds(bounds);\n@@ -2540,9 +2689,8 @@ pub fn mk_ctor_fn<'tcx>(cx: &ctxt<'tcx>,\n                 }))\n }\n \n-\n pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n-                      principal: ty::PolyTraitRef<'tcx>,\n+                      principal: ty::Binder<ty::TraitRef<'tcx>>,\n                       bounds: ExistentialBounds)\n                       -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n@@ -2553,6 +2701,15 @@ pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n     mk_t(cx, ty_trait(inner))\n }\n \n+pub fn mk_projection<'tcx>(cx: &ctxt<'tcx>,\n+                           trait_ref: ty::TraitRef<'tcx>,\n+                           item_name: ast::Name)\n+                           -> Ty<'tcx> {\n+    // take a copy of substs so that we own the vectors inside\n+    let inner = box TyProjection { trait_ref: trait_ref, item_name: item_name };\n+    mk_t(cx, ty_projection(inner))\n+}\n+\n pub fn mk_struct<'tcx>(cx: &ctxt<'tcx>, struct_id: ast::DefId,\n                        substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n@@ -2615,7 +2772,12 @@ pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n             maybe_walk_ty(tm.ty, f);\n         }\n         ty_trait(box TyTrait { ref principal, .. }) => {\n-            for subty in principal.substs().types.iter() {\n+            for subty in principal.0.substs.types.iter() {\n+                maybe_walk_ty(*subty, |x| f(x));\n+            }\n+        }\n+        ty_projection(box TyProjection { ref trait_ref, .. }) => {\n+            for subty in trait_ref.substs.types.iter() {\n                 maybe_walk_ty(*subty, |x| f(x));\n             }\n         }\n@@ -2693,6 +2855,7 @@ impl<'tcx> ParamBounds<'tcx> {\n             builtin_bounds: empty_builtin_bounds(),\n             trait_bounds: Vec::new(),\n             region_bounds: Vec::new(),\n+            projection_bounds: Vec::new(),\n         }\n     }\n }\n@@ -3191,6 +3354,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 apply_lang_items(cx, did, res)\n             }\n \n+            ty_projection(..) |\n             ty_param(_) => {\n                 TC::All\n             }\n@@ -3372,6 +3536,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             ty_infer(_) |\n             ty_err |\n             ty_param(_) |\n+            ty_projection(_) |\n             ty_vec(_, None) => {\n                 false\n             }\n@@ -4448,7 +4613,7 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n         ty_bare_fn(None, _) => \"fn pointer\".to_string(),\n         ty_closure(_) => \"fn\".to_string(),\n         ty_trait(ref inner) => {\n-            format!(\"trait {}\", item_path_str(cx, inner.principal.def_id()))\n+            format!(\"trait {}\", item_path_str(cx, inner.principal_def_id()))\n         }\n         ty_struct(id, _) => {\n             format!(\"struct {}\", item_path_str(cx, id))\n@@ -4460,6 +4625,7 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n         ty_infer(FloatVar(_)) => \"floating-point variable\".to_string(),\n         ty_infer(FreshTy(_)) => \"skolemized type\".to_string(),\n         ty_infer(FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n+        ty_projection(_) => \"associated type\".to_string(),\n         ty_param(ref p) => {\n             if p.space == subst::SelfSpace {\n                 \"Self\".to_string()\n@@ -4871,7 +5037,7 @@ pub fn try_add_builtin_trait(\n pub fn ty_to_def_id(ty: Ty) -> Option<ast::DefId> {\n     match ty.sty {\n         ty_trait(ref tt) =>\n-            Some(tt.principal.def_id()),\n+            Some(tt.principal_def_id()),\n         ty_struct(id, _) |\n         ty_enum(id, _) |\n         ty_unboxed_closure(id, _, _) =>\n@@ -5128,7 +5294,12 @@ pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n }\n \n /// Given a reference to a trait, returns the \"superbounds\" declared\n-/// on the trait, with appropriate substitutions applied.\n+/// on the trait, with appropriate substitutions applied. Basically,\n+/// this applies a filter to the where clauses on the trait, returning\n+/// those that have the form:\n+///\n+///     Self : SuperTrait<...>\n+///     Self : 'region\n pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n                                       trait_ref: &PolyTraitRef<'tcx>)\n                                       -> Vec<ty::Predicate<'tcx>>\n@@ -5205,13 +5376,7 @@ pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n     let trait_bounds: Vec<_> =\n         trait_def.bounds.trait_bounds\n         .iter()\n-        .map(|bound_trait_ref| {\n-            let substs = tcx.mk_substs(bound_trait_ref.substs().subst(tcx, trait_ref.substs()));\n-            ty::Binder(\n-                ty::TraitRef::new(bound_trait_ref.def_id(),\n-                                  substs))\n-        })\n-        .map(|bound_trait_ref| Rc::new(bound_trait_ref))\n+        .map(|poly_trait_ref| ty::Binder(poly_trait_ref.0.subst(tcx, trait_ref.substs())))\n         .collect();\n \n     debug!(\"bounds_for_trait_ref: trait_bounds={}\",\n@@ -5228,6 +5393,11 @@ pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n         trait_bounds: trait_bounds,\n         region_bounds: region_bounds,\n         builtin_bounds: builtin_bounds,\n+\n+        // FIXME(#19451) -- if a trait has a bound like `trait Foo :\n+        // Bar<T=X>`, we should probably be returning that, but this\n+        // code here will just ignore it.\n+        projection_bounds: Vec::new(),\n     };\n \n     predicates(tcx, trait_ref.self_ty(), &bounds)\n@@ -5242,7 +5412,7 @@ pub fn predicates<'tcx>(\n     let mut vec = Vec::new();\n \n     for builtin_bound in bounds.builtin_bounds.iter() {\n-        match traits::poly_trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n+        match traits::trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n             Ok(trait_ref) => { vec.push(trait_ref.as_predicate()); }\n             Err(ErrorReported) => { }\n         }\n@@ -5259,6 +5429,10 @@ pub fn predicates<'tcx>(\n         vec.push(bound_trait_ref.as_predicate());\n     }\n \n+    for projection in bounds.projection_bounds.iter() {\n+        vec.push(projection.as_predicate());\n+    }\n+\n     vec\n }\n \n@@ -5594,10 +5768,10 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n // relation on the supertraits from each bounded trait's constraint\n // list.\n pub fn each_bound_trait_and_supertraits<'tcx, F>(tcx: &ctxt<'tcx>,\n-                                                 bounds: &[Rc<PolyTraitRef<'tcx>>],\n+                                                 bounds: &[PolyTraitRef<'tcx>],\n                                                  mut f: F)\n                                                  -> bool where\n-    F: FnMut(Rc<PolyTraitRef<'tcx>>) -> bool,\n+    F: FnMut(PolyTraitRef<'tcx>) -> bool,\n {\n     for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n         if !f(bound_trait_ref) {\n@@ -5607,25 +5781,29 @@ pub fn each_bound_trait_and_supertraits<'tcx, F>(tcx: &ctxt<'tcx>,\n     return true;\n }\n \n-pub fn object_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n-                                  opt_principal: Option<&PolyTraitRef<'tcx>>, // None for closures\n-                                  others: BuiltinBounds)\n-                                  -> Vec<ty::Region>\n+pub fn object_region_bounds<'tcx>(\n+    tcx: &ctxt<'tcx>,\n+    opt_principal: Option<&Binder<TraitRef<'tcx>>>, // None for closures\n+    others: BuiltinBounds)\n+    -> Vec<ty::Region>\n {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n     // a skolemized type.\n     let open_ty = ty::mk_infer(tcx, FreshTy(0));\n \n     let opt_trait_ref = opt_principal.map_or(Vec::new(), |principal| {\n-        let substs = principal.substs().with_self_ty(open_ty);\n-        vec!(Rc::new(ty::Binder(ty::TraitRef::new(principal.def_id(), tcx.mk_substs(substs)))))\n+        // Note that we preserve the overall binding levels here.\n+        assert!(!open_ty.has_escaping_regions());\n+        let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n+        vec!(ty::Binder(Rc::new(ty::TraitRef::new(principal.0.def_id, substs))))\n     });\n \n     let param_bounds = ty::ParamBounds {\n         region_bounds: Vec::new(),\n         builtin_bounds: others,\n         trait_bounds: opt_trait_ref,\n+        projection_bounds: Vec::new(), // not relevant to computing region bounds\n     };\n \n     let predicates = ty::predicates(tcx, open_ty, &param_bounds);\n@@ -5656,6 +5834,7 @@ pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|predicate| {\n             match predicate {\n+                ty::Predicate::Projection(..) |\n                 ty::Predicate::Trait(..) |\n                 ty::Predicate::Equate(..) |\n                 ty::Predicate::RegionOutlives(..) => {\n@@ -6007,12 +6186,12 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n \n                     return false;\n                 }\n-                ty_trait(box TyTrait { ref principal, bounds }) => {\n+                ty_trait(ref data) => {\n                     byte!(17);\n-                    did(state, principal.def_id());\n-                    hash!(bounds);\n+                    did(state, data.principal_def_id());\n+                    hash!(data.bounds);\n \n-                    let principal = anonymize_late_bound_regions(tcx, principal);\n+                    let principal = anonymize_late_bound_regions(tcx, &data.principal);\n                     for subty in principal.substs.types.iter() {\n                         helper(tcx, *subty, svh, state);\n                     }\n@@ -6040,6 +6219,11 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                     did(state, d);\n                     region(state, *r);\n                 }\n+                ty_projection(ref data) => {\n+                    byte!(25);\n+                    did(state, data.trait_ref.def_id);\n+                    hash!(token::get_name(data.item_name));\n+                }\n             }\n             true\n         });\n@@ -6156,7 +6340,10 @@ pub fn construct_parameter_environment<'tcx>(\n \n         for predicate in bounds.predicates.iter() {\n             match *predicate {\n-                Predicate::Trait(..) | Predicate::Equate(..) | Predicate::TypeOutlives(..) => {\n+                Predicate::Projection(..) |\n+                Predicate::Trait(..) |\n+                Predicate::Equate(..) |\n+                Predicate::TypeOutlives(..) => {\n                     // No region bounds here\n                 }\n                 Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n@@ -6283,7 +6470,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                 accumulator.push(*region)\n             }\n             ty_trait(ref t) => {\n-                accumulator.push_all(t.principal.substs().regions().as_slice());\n+                accumulator.push_all(t.principal.0.substs.regions().as_slice());\n             }\n             ty_enum(_, substs) |\n             ty_struct(_, substs) => {\n@@ -6310,6 +6497,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_ptr(_) |\n             ty_bare_fn(..) |\n             ty_tup(_) |\n+            ty_projection(_) |\n             ty_param(_) |\n             ty_infer(_) |\n             ty_open(_) |\n@@ -6400,6 +6588,15 @@ pub fn count_late_bound_regions<'tcx, T>(\n     skol_map.len()\n }\n \n+pub fn binds_late_bound_regions<'tcx, T>(\n+    tcx: &ty::ctxt<'tcx>,\n+    value: &Binder<T>)\n+    -> bool\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+{\n+    count_late_bound_regions(tcx, value) > 0\n+}\n+\n /// Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also\n /// method lookup and a few other places where precise region relationships are not required.\n pub fn erase_late_bound_regions<'tcx, T>(\n@@ -6540,9 +6737,10 @@ impl<'tcx> Repr<'tcx> for ty::Predicate<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n             Predicate::Trait(ref a) => a.repr(tcx),\n-            Predicate::Equate(ref pair) => format!(\"Equate({})\", pair.repr(tcx)),\n-            Predicate::RegionOutlives(ref pair) => format!(\"Outlives({})\", pair.repr(tcx)),\n-            Predicate::TypeOutlives(ref pair) => format!(\"Outlives({})\", pair.repr(tcx)),\n+            Predicate::Equate(ref pair) => pair.repr(tcx),\n+            Predicate::RegionOutlives(ref pair) => pair.repr(tcx),\n+            Predicate::TypeOutlives(ref pair) => pair.repr(tcx),\n+            Predicate::Projection(ref pair) => pair.repr(tcx),\n         }\n     }\n }\n@@ -6638,6 +6836,11 @@ pub fn can_type_implement_copy<'tcx>(tcx: &ctxt<'tcx>,\n     Ok(())\n }\n \n+// TODO -- all of these types basically walk various structures to\n+// test whether types/regions are reachable with various\n+// properties. It should be possible to express them in terms of one\n+// common \"walker\" trait or something.\n+\n pub trait RegionEscape {\n     fn has_escaping_regions(&self) -> bool {\n         self.has_regions_escaping_depth(0)\n@@ -6677,8 +6880,193 @@ impl<'tcx> RegionEscape for EquatePredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> RegionEscape for TraitPredicate<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.trait_ref.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n impl<T:RegionEscape,U:RegionEscape> RegionEscape for OutlivesPredicate<T,U> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)\n     }\n }\n+\n+impl<'tcx> RegionEscape for ProjectionPredicate<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.projection_ty.has_regions_escaping_depth(depth) ||\n+            self.ty.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ProjectionTy<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.trait_ref.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"ProjectionPredicate({}, {})\",\n+                self.projection_ty.repr(tcx),\n+                self.ty.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ty::TyProjection<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"TyProjection({}, {})\",\n+                self.trait_ref.repr(tcx),\n+                self.item_name.repr(tcx))\n+    }\n+}\n+\n+pub trait HasProjectionTypes {\n+    fn has_projection_types(&self) -> bool;\n+}\n+\n+impl<'tcx> HasProjectionTypes for Ty<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        ty::type_has_projection(*self)\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for ty::TraitRef<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.substs.has_projection_types()\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for subst::Substs<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.types.iter().any(|t| t.has_projection_types())\n+    }\n+}\n+\n+impl<'tcx,T> HasProjectionTypes for Option<T>\n+    where T : HasProjectionTypes\n+{\n+    fn has_projection_types(&self) -> bool {\n+        self.iter().any(|t| t.has_projection_types())\n+    }\n+}\n+\n+impl<'tcx,T> HasProjectionTypes for Rc<T>\n+    where T : HasProjectionTypes\n+{\n+    fn has_projection_types(&self) -> bool {\n+        (**self).has_projection_types()\n+    }\n+}\n+\n+impl<'tcx,T> HasProjectionTypes for Box<T>\n+    where T : HasProjectionTypes\n+{\n+    fn has_projection_types(&self) -> bool {\n+        (**self).has_projection_types()\n+    }\n+}\n+\n+impl<T> HasProjectionTypes for ty::Binder<T>\n+    where T : HasProjectionTypes\n+{\n+    fn has_projection_types(&self) -> bool {\n+        self.0.has_projection_types()\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for ty::FnOutput<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        match *self {\n+            ty::FnConverging(t) => t.has_projection_types(),\n+            ty::FnDiverging => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for ty::FnSig<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.inputs.iter().any(|t| t.has_projection_types()) ||\n+            self.output.has_projection_types()\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for ty::BareFnTy<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.sig.has_projection_types()\n+    }\n+}\n+\n+pub trait ReferencesError {\n+    fn references_error(&self) -> bool;\n+}\n+\n+impl<T:ReferencesError> ReferencesError for ty::Binder<T> {\n+    fn references_error(&self) -> bool {\n+        self.0.references_error()\n+    }\n+}\n+\n+impl<T:ReferencesError> ReferencesError for Rc<T> {\n+    fn references_error(&self) -> bool {\n+        (&*self).references_error()\n+    }\n+}\n+\n+impl<'tcx> ReferencesError for ty::TraitPredicate<'tcx> {\n+    fn references_error(&self) -> bool {\n+        self.trait_ref.references_error()\n+    }\n+}\n+\n+impl<'tcx> ReferencesError for ty::ProjectionPredicate<'tcx> {\n+    fn references_error(&self) -> bool {\n+        self.projection_ty.trait_ref.references_error() || self.ty.references_error()\n+    }\n+}\n+\n+impl<'tcx> ReferencesError for ty::TraitRef<'tcx> {\n+    fn references_error(&self) -> bool {\n+        self.input_types().iter().any(|t| t.references_error())\n+    }\n+}\n+\n+impl<'tcx> ReferencesError for ty::Ty<'tcx> {\n+    fn references_error(&self) -> bool {\n+        ty::type_is_error(*self)\n+    }\n+}\n+\n+impl<'tcx> ReferencesError for ty::Predicate<'tcx> {\n+    fn references_error(&self) -> bool {\n+        match *self {\n+            ty::Predicate::Trait(ref data) => data.references_error(),\n+            ty::Predicate::Equate(ref data) => data.references_error(),\n+            ty::Predicate::RegionOutlives(ref data) => data.references_error(),\n+            ty::Predicate::TypeOutlives(ref data) => data.references_error(),\n+            ty::Predicate::Projection(ref data) => data.references_error(),\n+        }\n+    }\n+}\n+\n+impl<A,B> ReferencesError for ty::OutlivesPredicate<A,B>\n+    where A : ReferencesError, B : ReferencesError\n+{\n+    fn references_error(&self) -> bool {\n+        self.0.references_error() || self.1.references_error()\n+    }\n+}\n+\n+impl<'tcx> ReferencesError for ty::EquatePredicate<'tcx>\n+{\n+    fn references_error(&self) -> bool {\n+        self.0.references_error() || self.1.references_error()\n+    }\n+}\n+\n+impl ReferencesError for ty::Region\n+{\n+    fn references_error(&self) -> bool {\n+        false\n+    }\n+}"}, {"sha": "036fbfec28024b9beabd430f545b1e3d5fca46d4", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -170,6 +170,13 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n     }\n }\n \n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Box<T> {\n+        let content: T = (**self).fold_with(folder);\n+        box content\n+    }\n+}\n+\n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Vec<T> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n@@ -354,6 +361,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ParamBounds<'tcx> {\n             region_bounds: self.region_bounds.fold_with(folder),\n             builtin_bounds: self.builtin_bounds.fold_with(folder),\n             trait_bounds: self.trait_bounds.fold_with(folder),\n+            projection_bounds: self.projection_bounds.fold_with(folder),\n         }\n     }\n }\n@@ -365,7 +373,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n             def_id: self.def_id,\n             space: self.space,\n             index: self.index,\n-            associated_with: self.associated_with,\n             bounds: self.bounds.fold_with(folder),\n             default: self.default.fold_with(folder),\n         }\n@@ -405,6 +412,35 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n                 ty::Predicate::RegionOutlives(binder.fold_with(folder)),\n             ty::Predicate::TypeOutlives(ref binder) =>\n                 ty::Predicate::TypeOutlives(binder.fold_with(folder)),\n+            ty::Predicate::Projection(ref binder) =>\n+                ty::Predicate::Projection(binder.fold_with(folder)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ProjectionPredicate<'tcx> {\n+        ty::ProjectionPredicate {\n+            projection_ty: self.projection_ty.fold_with(folder),\n+            ty: self.ty.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ProjectionTy<'tcx> {\n+        ty::ProjectionTy {\n+            trait_ref: self.trait_ref.fold_with(folder),\n+            item_name: self.item_name,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::TyProjection<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TyProjection<'tcx> {\n+        ty::TyProjection {\n+            trait_ref: self.trait_ref.fold_with(folder),\n+            item_name: self.item_name,\n         }\n     }\n }\n@@ -495,6 +531,14 @@ impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitPredicate<'tcx> {\n+        ty::TraitPredicate {\n+            trait_ref: self.trait_ref.fold_with(folder)\n+        }\n+    }\n+}\n+\n impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n     where T : TypeFoldable<'tcx>,\n           U : TypeFoldable<'tcx>,\n@@ -544,7 +588,7 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             ty::ty_bare_fn(opt_def_id, this.tcx().mk_bare_fn(bfn))\n         }\n         ty::ty_closure(ref f) => {\n-            ty::ty_closure(box f.fold_with(this))\n+            ty::ty_closure(f.fold_with(this))\n         }\n         ty::ty_rptr(r, ref tm) => {\n             let r = r.fold_with(this);\n@@ -559,6 +603,9 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             let s = substs.fold_with(this);\n             ty::ty_unboxed_closure(did, this.tcx().mk_region(r), this.tcx().mk_substs(s))\n         }\n+        ty::ty_projection(ref data) => {\n+            ty::ty_projection(data.fold_with(this))\n+        }\n         ty::ty_bool | ty::ty_char | ty::ty_str |\n         ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n         ty::ty_err | ty::ty_infer(_) |"}, {"sha": "134a47225072d02bdc280e049f8d2bcb13cbb4ee", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -448,6 +448,12 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                     bound_sep,\n                     bound_str)\n         }\n+        ty::ty_projection(ref data) => {\n+            format!(\"<{} as {}>::{}\",\n+                    data.trait_ref.self_ty().user_string(cx),\n+                    data.trait_ref.user_string(cx),\n+                    data.item_name.user_string(cx))\n+        }\n         ty_str => \"str\".to_string(),\n         ty_unboxed_closure(ref did, _, substs) => {\n             let unboxed_closures = cx.unboxed_closures.borrow();\n@@ -1408,17 +1414,55 @@ impl<'tcx> UserString<'tcx> for ty::EquatePredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for ty::TraitPredicate<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"TraitPredicate({})\",\n+                self.trait_ref.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for ty::TraitPredicate<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"{} : {}\",\n+                self.trait_ref.self_ty().user_string(tcx),\n+                self.trait_ref.user_string(tcx))\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"{} == {}\",\n+                self.projection_ty.user_string(tcx),\n+                self.ty.user_string(tcx))\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ty::ProjectionTy<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"<{} as {}>::{}\",\n+                self.trait_ref.self_ty().repr(tcx),\n+                self.trait_ref.repr(tcx),\n+                self.item_name.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for ty::ProjectionTy<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"<{} as {}>::{}\",\n+                self.trait_ref.self_ty().user_string(tcx),\n+                self.trait_ref.user_string(tcx),\n+                self.item_name.user_string(tcx))\n+    }\n+}\n+\n impl<'tcx> UserString<'tcx> for ty::Predicate<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n-            ty::Predicate::Trait(ref trait_ref) => {\n-                format!(\"{} : {}\",\n-                        trait_ref.self_ty().user_string(tcx),\n-                        trait_ref.user_string(tcx))\n-            }\n+            ty::Predicate::Trait(ref data) => data.user_string(tcx),\n             ty::Predicate::Equate(ref predicate) => predicate.user_string(tcx),\n             ty::Predicate::RegionOutlives(ref predicate) => predicate.user_string(tcx),\n             ty::Predicate::TypeOutlives(ref predicate) => predicate.user_string(tcx),\n+            ty::Predicate::Projection(ref predicate) => predicate.user_string(tcx),\n         }\n     }\n }"}, {"sha": "c5d3ad805d93428d013b93507efcc379de8c655c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -281,6 +281,8 @@ pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n \n pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n+    let fn_ty = monomorphize::normalize_associated_type(ccx.tcx(), &fn_ty);\n+\n     let (inputs, output, abi, env) = match fn_ty.sty {\n         ty::ty_bare_fn(_, ref f) => {\n             (f.sig.0.inputs.clone(), f.sig.0.output, f.abi, None)\n@@ -1453,7 +1455,8 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n \n     let uses_outptr = match output_type {\n         ty::FnConverging(output_type) => {\n-            let substd_output_type = output_type.subst(ccx.tcx(), param_substs);\n+            let substd_output_type =\n+                monomorphize::apply_param_substs(ccx.tcx(), param_substs, &output_type);\n             type_of::return_uses_outptr(ccx, substd_output_type)\n         }\n         ty::FnDiverging => false\n@@ -1512,7 +1515,7 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n     if let ty::FnConverging(output_type) = output {\n         // This shouldn't need to recompute the return type,\n         // as new_fn_ctxt did it already.\n-        let substd_output_type = output_type.subst(fcx.ccx.tcx(), fcx.param_substs);\n+        let substd_output_type = fcx.monomorphize(&output_type);\n         if !return_type_is_void(fcx.ccx, substd_output_type) {\n             // If the function returns nil/bot, there is no real return\n             // value, so do not set `llretslotptr`.\n@@ -1732,7 +1735,7 @@ pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n \n     // This shouldn't need to recompute the return type,\n     // as new_fn_ctxt did it already.\n-    let substd_retty = retty.subst(fcx.ccx.tcx(), fcx.param_substs);\n+    let substd_retty = fcx.monomorphize(&retty);\n     build_return_block(fcx, ret_cx, substd_retty);\n \n     debuginfo::clear_source_location(fcx);\n@@ -2074,7 +2077,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n                                                      param_substs: &Substs<'tcx>,\n                                                      llfndecl: ValueRef) {\n     let ctor_ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n-    let ctor_ty = ctor_ty.subst(ccx.tcx(), param_substs);\n+    let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &ctor_ty);\n \n     let result_ty = match ctor_ty.sty {\n         ty::ty_bare_fn(_, ref bft) => bft.sig.0.output,\n@@ -2764,6 +2767,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     }\n \n     let item = ccx.tcx().map.get(id);\n+    debug!(\"get_item_val: id={} item={}\", id, item);\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);"}, {"sha": "169e52bcfe5bef7e280477cb832d16a1f15b6ba3", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -516,6 +516,7 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n \n     // Type scheme of the function item (may have type params)\n     let fn_type_scheme = ty::lookup_item_type(tcx, def_id);\n+    let fn_type = monomorphize::normalize_associated_type(tcx, &fn_type_scheme.ty);\n \n     // Find the actual function pointer.\n     let mut val = {\n@@ -524,7 +525,7 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n             get_item_val(ccx, def_id.node)\n         } else {\n             // External reference.\n-            trans_external_path(ccx, def_id, fn_type_scheme.ty)\n+            trans_external_path(ccx, def_id, fn_type)\n         }\n     };\n \n@@ -551,7 +552,7 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n     // This can occur on either a crate-local or crate-external\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n-    let llty = type_of::type_of_fn_from_ty(ccx, fn_type_scheme.ty);\n+    let llty = type_of::type_of_fn_from_ty(ccx, fn_type);\n     let llptrty = llty.ptr_to();\n     if val_ty(val) != llptrty {\n         debug!(\"trans_fn_ref_with_vtables(): casting pointer!\");"}, {"sha": "694fbf251ddbf0985cddc4c5df91aa483acbac4b", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -24,28 +24,27 @@ use middle::infer;\n use middle::lang_items::LangItem;\n use middle::mem_categorization as mc;\n use middle::region;\n-use middle::subst;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::{mod, Subst, Substs};\n use trans::base;\n use trans::build;\n use trans::cleanup;\n use trans::datum;\n use trans::debuginfo;\n use trans::machine;\n+use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n use middle::traits;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, HasProjectionTypes, Ty};\n use middle::ty_fold;\n-use middle::ty_fold::TypeFoldable;\n+use middle::ty_fold::{TypeFolder, TypeFoldable};\n use util::ppaux::Repr;\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use arena::TypedArena;\n use libc::{c_uint, c_char};\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n-use std::rc::Rc;\n use std::vec::Vec;\n use syntax::ast::Ident;\n use syntax::ast;\n@@ -137,7 +136,7 @@ pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<\n \n                 ty::ty_enum(did, substs) =>\n                     ty::enum_variants(tcx, did).iter().any(|v|\n-                        v.args.iter().any(|aty| {\n+                        v.args.iter().any(|&aty| {\n                             let t = aty.subst(tcx, substs);\n                             type_needs_unwind_cleanup_(tcx, t, tycache)\n                         })\n@@ -465,6 +464,14 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         }\n         return out;\n     }\n+\n+    pub fn monomorphize<T>(&self, value: &T) -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+    {\n+        monomorphize::apply_param_substs(self.ccx.tcx(),\n+                                         self.param_substs,\n+                                         value)\n+    }\n }\n \n // Basic block context.  We create a block context for each basic block\n@@ -557,6 +564,14 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     pub fn to_str(&self) -> String {\n         format!(\"[block {:p}]\", self)\n     }\n+\n+    pub fn monomorphize<T>(&self, value: &T) -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+    {\n+        monomorphize::apply_param_substs(self.tcx(),\n+                                         self.fcx.param_substs,\n+                                         value)\n+    }\n }\n \n impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n@@ -859,7 +874,7 @@ pub fn is_null(val: ValueRef) -> bool {\n }\n \n pub fn monomorphize_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n-    t.subst(bcx.tcx(), bcx.fcx.param_substs)\n+    bcx.fcx.monomorphize(&t)\n }\n \n pub fn node_id_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n@@ -881,7 +896,7 @@ pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) ->\n /// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     span: Span,\n-                                    trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+                                    trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> traits::Vtable<'tcx, ()>\n {\n     let tcx = ccx.tcx();\n@@ -911,7 +926,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // shallow result we are looking for -- that is, what specific impl.\n     let mut selcx = traits::SelectionContext::new(&infcx, &param_env, tcx);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n-                                             trait_ref.clone());\n+                                             trait_ref.to_poly_trait_predicate());\n     let selection = match selcx.select(&obligation) {\n         Ok(Some(selection)) => selection,\n         Ok(None) => {\n@@ -991,7 +1006,8 @@ pub enum ExprOrMethodCall {\n \n pub fn node_id_substs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   node: ExprOrMethodCall)\n-                                  -> subst::Substs<'tcx> {\n+                                  -> subst::Substs<'tcx>\n+{\n     let tcx = bcx.tcx();\n \n     let substs = match node {\n@@ -1012,7 +1028,7 @@ pub fn node_id_substs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     let substs = substs.erase_regions();\n-    substs.subst(tcx, bcx.fcx.param_substs)\n+    bcx.monomorphize(&substs)\n }\n \n pub fn langcall(bcx: Block,"}, {"sha": "9ceb0c63990936164226641f939b79f13eac1164", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -100,7 +100,7 @@ pub struct LocalCrateContext<'tcx> {\n     monomorphized: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::PolyTraitRef<'tcx>>), ValueRef>>,\n+    vtables: RefCell<FnvHashMap<(Ty<'tcx>, ty::PolyTraitRef<'tcx>), ValueRef>>,\n     /// Cache of constant strings,\n     const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n \n@@ -151,7 +151,7 @@ pub struct LocalCrateContext<'tcx> {\n     /// contexts around the same size.\n     n_llvm_insns: Cell<uint>,\n \n-    trait_cache: RefCell<FnvHashMap<Rc<ty::PolyTraitRef<'tcx>>,\n+    trait_cache: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>,\n                                     traits::Vtable<'tcx, ()>>>,\n }\n \n@@ -607,7 +607,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.monomorphizing\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::PolyTraitRef<'tcx>>),\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(Ty<'tcx>, ty::PolyTraitRef<'tcx>),\n                                                             ValueRef>> {\n         &self.local.vtables\n     }\n@@ -705,7 +705,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.n_llvm_insns.set(self.local.n_llvm_insns.get() + 1);\n     }\n \n-    pub fn trait_cache(&self) -> &RefCell<FnvHashMap<Rc<ty::PolyTraitRef<'tcx>>,\n+    pub fn trait_cache(&self) -> &RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>,\n                                                      traits::Vtable<'tcx, ()>>> {\n         &self.local.trait_cache\n     }"}, {"sha": "e94ce55e704a82cdb130e1fc112520c9a1a5608d", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -198,6 +198,7 @@ use middle::subst::{mod, Subst, Substs};\n use trans::{mod, adt, machine, type_of};\n use trans::common::*;\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n+use trans::monomorphize;\n use trans::type_::Type;\n use middle::ty::{mod, Ty};\n use middle::pat_util;\n@@ -426,8 +427,8 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 from_def_id_and_substs(self,\n                                        cx,\n-                                       trait_data.principal.def_id(),\n-                                       trait_data.principal.substs(),\n+                                       trait_data.principal_def_id(),\n+                                       &trait_data.principal.0.substs,\n                                        &mut unique_type_id);\n             },\n             ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n@@ -1438,7 +1439,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 assert_type_for_node_id(cx, fn_ast_id, error_reporting_span);\n \n                 let return_type = ty::node_id_to_type(cx.tcx(), fn_ast_id);\n-                let return_type = return_type.subst(cx.tcx(), param_substs);\n+                let return_type = monomorphize::apply_param_substs(cx.tcx(),\n+                                                                   param_substs,\n+                                                                   &return_type);\n                 signature.push(type_metadata(cx, return_type, codemap::DUMMY_SP));\n             }\n         }\n@@ -1447,7 +1450,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         for arg in fn_decl.inputs.iter() {\n             assert_type_for_node_id(cx, arg.pat.id, arg.pat.span);\n             let arg_type = ty::node_id_to_type(cx.tcx(), arg.pat.id);\n-            let arg_type = arg_type.subst(cx.tcx(), param_substs);\n+            let arg_type = monomorphize::apply_param_substs(cx.tcx(),\n+                                                            param_substs,\n+                                                            &arg_type);\n             signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n         }\n \n@@ -1459,8 +1464,10 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                          param_substs: &Substs<'tcx>,\n                                          file_metadata: DIFile,\n                                          name_to_append_suffix_to: &mut String)\n-                                         -> DIArray {\n+                                         -> DIArray\n+    {\n         let self_type = param_substs.self_ty();\n+        let self_type = monomorphize::normalize_associated_type(cx.tcx(), &self_type);\n \n         // Only true for static default methods:\n         let has_self_type = self_type.is_some();\n@@ -2878,7 +2885,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // But it does not describe the trait's methods.\n \n     let def_id = match trait_type.sty {\n-        ty::ty_trait(box ty::TyTrait { ref principal, .. }) => principal.def_id(),\n+        ty::ty_trait(ref data) => data.principal_def_id(),\n         _ => {\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(format!(\"debuginfo: Unexpected trait-object type in \\\n@@ -3811,8 +3818,8 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push(']');\n         },\n         ty::ty_trait(ref trait_data) => {\n-            push_item_name(cx, trait_data.principal.def_id(), false, output);\n-            push_type_params(cx, trait_data.principal.substs(), output);\n+            push_item_name(cx, trait_data.principal_def_id(), false, output);\n+            push_type_params(cx, &trait_data.principal.0.substs, output);\n         },\n         ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n             if unsafety == ast::Unsafety::Unsafe {\n@@ -3920,9 +3927,10 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_unboxed_closure(..) => {\n             output.push_str(\"closure\");\n         }\n-        ty::ty_err      |\n+        ty::ty_err |\n         ty::ty_infer(_) |\n         ty::ty_open(_) |\n+        ty::ty_projection(..) |\n         ty::ty_param(_) => {\n             cx.sess().bug(format!(\"debuginfo: Trying to create type name for \\\n                 unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t))[]);"}, {"sha": "5a7131cf68ecbb599f0493c9a7a9acfc08079638", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -39,7 +39,7 @@ use back::abi;\n use llvm::{mod, ValueRef};\n use middle::def;\n use middle::mem_categorization::Typer;\n-use middle::subst::{mod, Subst, Substs};\n+use middle::subst::{mod, Substs};\n use trans::{_match, adt, asm, base, callee, closure, consts, controlflow};\n use trans::base::*;\n use trans::build::*;\n@@ -319,11 +319,13 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           bcx.ty_to_string(unadjusted_ty))[])\n             },\n             &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n-                let substs = principal.substs().with_self_ty(unadjusted_ty).erase_regions();\n+                // Note that we preserve binding levels here:\n+                let substs = principal.0.substs.with_self_ty(unadjusted_ty).erase_regions();\n+                let substs = tcx.tcx().mk_substs(substs);\n                 let trait_ref =\n-                    Rc::new(ty::Binder(ty::TraitRef { def_id: principal.def_id(),\n-                                                      substs: bcx.tcx().mk_substs(substs) }));\n-                let trait_ref = trait_ref.subst(bcx.tcx(), bcx.fcx.param_substs);\n+                    ty::Binder(Rc::new(ty::TraitRef { def_id: principal.def_id(),\n+                                                      substs: substs }));\n+                let trait_ref = bcx.monomorphize(&trait_ref);\n                 let box_ty = mk_ty(unadjusted_ty);\n                 PointerCast(bcx,\n                             meth::get_vtable(bcx, box_ty, trait_ref),\n@@ -1204,7 +1206,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                              .get(&expr.id)\n                                              .map(|t| (*t).clone())\n                                              .unwrap();\n-                let trait_ref = trait_ref.subst(bcx.tcx(), bcx.fcx.param_substs);\n+                let trait_ref = bcx.monomorphize(&trait_ref);\n                 let datum = unpack_datum!(bcx, trans(bcx, &**val));\n                 meth::trans_trait_cast(bcx, datum, expr.id,\n                                        trait_ref, dest)"}, {"sha": "e234d77914b646e010614804676c7333f3822d6b", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -19,11 +19,12 @@ use trans::build::*;\n use trans::cabi;\n use trans::common::*;\n use trans::machine;\n+use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of::*;\n use trans::type_of;\n use middle::ty::{mod, Ty};\n-use middle::subst::{Subst, Substs};\n+use middle::subst::{Substs};\n use std::cmp;\n use libc::c_uint;\n use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n@@ -525,7 +526,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n \n     let fnty = ty::node_id_to_type(ccx.tcx(), id);\n-    let mty = fnty.subst(ccx.tcx(), param_substs);\n+    let mty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fnty);\n     let tys = foreign_types_for_fn_ty(ccx, mty);\n \n     unsafe { // unsafe because we call LLVM operations\n@@ -543,10 +544,12 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                attrs: &[ast::Attribute],\n                                id: ast::NodeId,\n                                hash: Option<&str>)\n-                               -> ValueRef {\n+                               -> ValueRef\n+    {\n         let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n         let tcx = ccx.tcx();\n-        let t = ty::node_id_to_type(tcx, id).subst(ccx.tcx(), param_substs);\n+        let t = ty::node_id_to_type(tcx, id);\n+        let t = monomorphize::apply_param_substs(tcx, param_substs, &t);\n \n         let ps = ccx.tcx().map.with_path(id, |path| {\n             let abi = Some(ast_map::PathName(special_idents::clownshoe_abi.name));"}, {"sha": "00b17ca00dfb8af1d9c210570925b127613a5d69", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -13,7 +13,7 @@ use back::abi;\n use llvm;\n use llvm::ValueRef;\n use metadata::csearch;\n-use middle::subst::{Subst,Substs};\n+use middle::subst::{Substs};\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n@@ -132,8 +132,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             ref trait_ref,\n             method_num\n         }) => {\n-            let trait_ref =\n-                Rc::new(ty::Binder((**trait_ref).subst(bcx.tcx(), bcx.fcx.param_substs)));\n+            let trait_ref = ty::Binder(bcx.monomorphize(trait_ref));\n             let span = bcx.tcx().map.span(method_call.expr_id);\n             debug!(\"method_call={} trait_ref={}\",\n                    method_call,\n@@ -142,8 +141,11 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                             span,\n                                             trait_ref.clone());\n             debug!(\"origin = {}\", origin.repr(bcx.tcx()));\n-            trans_monomorphized_callee(bcx, method_call, trait_ref.def_id(),\n-                                       method_num, origin)\n+            trans_monomorphized_callee(bcx,\n+                                       method_call,\n+                                       trait_ref.def_id(),\n+                                       method_num,\n+                                       origin)\n         }\n \n         ty::MethodTraitObject(ref mt) => {\n@@ -238,9 +240,10 @@ pub fn trans_static_method_callee(bcx: Block,\n                                              rcvr_self,\n                                              rcvr_assoc,\n                                              Vec::new()));\n+    let trait_substs = bcx.tcx().mk_substs(trait_substs);\n     debug!(\"trait_substs={}\", trait_substs.repr(bcx.tcx()));\n-    let trait_ref = Rc::new(ty::Binder(ty::TraitRef { def_id: trait_id,\n-                                                      substs: bcx.tcx().mk_substs(trait_substs) }));\n+    let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: trait_id,\n+                                                      substs: trait_substs }));\n     let vtbl = fulfill_obligation(bcx.ccx(),\n                                   DUMMY_SP,\n                                   trait_ref);\n@@ -515,7 +518,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// This will hopefully change now that DST is underway.\n pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               box_ty: Ty<'tcx>,\n-                              trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+                              trait_ref: ty::PolyTraitRef<'tcx>)\n                               -> ValueRef\n {\n     debug!(\"get_vtable(box_ty={}, trait_ref={})\",\n@@ -671,7 +674,7 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     datum: Datum<'tcx, Expr>,\n                                     id: ast::NodeId,\n-                                    trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n+                                    trait_ref: ty::PolyTraitRef<'tcx>,\n                                     dest: expr::Dest)\n                                     -> Block<'blk, 'tcx> {\n     let mut bcx = bcx;"}, {"sha": "dcfe5f40ecee91ad600d428ecaa857d321cbbc8f", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 92, "deletions": 2, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -12,15 +12,18 @@ use back::link::exported_name;\n use session;\n use llvm::ValueRef;\n use llvm;\n+use middle::infer;\n use middle::subst;\n-use middle::subst::Subst;\n+use middle::subst::{Subst, Substs};\n+use middle::traits;\n+use middle::ty_fold::{mod, TypeFolder, TypeFoldable};\n use trans::base::{set_llvm_fn_attrs, set_inline_hint};\n use trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n use trans::base::{trans_fn, decl_internal_rust_fn};\n use trans::base;\n use trans::common::*;\n use trans::foreign;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, HasProjectionTypes, Ty};\n use util::ppaux::Repr;\n \n use syntax::abi;\n@@ -29,6 +32,7 @@ use syntax::ast_map;\n use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::attr;\n use std::hash::{sip, Hash};\n+use std::rc::Rc;\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: ast::DefId,\n@@ -92,7 +96,12 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx()));\n+\n     let mono_ty = llitem_ty.subst(ccx.tcx(), psubsts);\n+    debug!(\"mono_ty = {} (post-substitution)\", mono_ty.repr(ccx.tcx()));\n+\n+    let mono_ty = normalize_associated_type(ccx.tcx(), &mono_ty);\n+    debug!(\"mono_ty = {} (post-normalization)\", mono_ty.repr(ccx.tcx()));\n \n     ccx.stats().n_monos.set(ccx.stats().n_monos.get() + 1);\n \n@@ -282,3 +291,84 @@ pub struct MonoId<'tcx> {\n     pub def: ast::DefId,\n     pub params: subst::VecPerParamSpace<Ty<'tcx>>\n }\n+\n+/// Monomorphizes a type from the AST by first applying the in-scope\n+/// substitutions and then normalizing any associated types.\n+pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n+                                  param_substs: &Substs<'tcx>,\n+                                  value: &T)\n+                                  -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+{\n+    assert!(param_substs.regions.is_erased());\n+\n+    let substituted = value.subst(tcx, param_substs);\n+    normalize_associated_type(tcx, &substituted)\n+}\n+\n+/// Removes associated types, if any. Since this during\n+/// monomorphization, we know that only concrete types are involved,\n+/// and hence we can be sure that all associated types will be\n+/// completely normalized away.\n+pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, t: &T) -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+{\n+    debug!(\"normalize_associated_type(t={})\", t.repr(tcx));\n+\n+    if !t.has_projection_types() {\n+        return t.clone();\n+    }\n+\n+    // TODO cache\n+\n+    let infcx = infer::new_infer_ctxt(tcx);\n+    let param_env = ty::empty_parameter_environment();\n+    let mut selcx = traits::SelectionContext::new(&infcx, &param_env, tcx);\n+    let mut normalizer = AssociatedTypeNormalizer { selcx: &mut selcx };\n+    let result = t.fold_with(&mut normalizer);\n+\n+    debug!(\"normalize_associated_type: t={} result={}\",\n+           t.repr(tcx),\n+           result.repr(tcx));\n+\n+    result\n+}\n+\n+struct AssociatedTypeNormalizer<'a,'tcx:'a> {\n+    selcx: &'a mut traits::SelectionContext<'a,'tcx>,\n+}\n+\n+impl<'a,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.selcx.tcx() }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match ty.sty {\n+            ty::ty_projection(ref data) => {\n+                debug!(\"ty_projection({})\", data.repr(self.tcx()));\n+\n+                let tcx = self.selcx.tcx();\n+                let substs = data.trait_ref.substs.clone().erase_regions();\n+                assert!(substs.types.iter().all(|&t| (!ty::type_has_params(t) &&\n+                                                      !ty::type_has_self(t))));\n+                let trait_ref = Rc::new(ty::TraitRef::new(data.trait_ref.def_id, substs));\n+                let projection_ty = ty::ProjectionTy { trait_ref: trait_ref.clone(),\n+                                                       item_name: data.item_name };\n+                let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n+                                                         projection_ty);\n+                match traits::project_type(self.selcx, &obligation) {\n+                    Ok(ty) => ty,\n+                    Err(errors) => {\n+                        tcx.sess.bug(\n+                            format!(\"Encountered error(s) `{}` selecting `{}` during trans\",\n+                                    errors.repr(tcx),\n+                                    trait_ref.repr(tcx)).as_slice());\n+                    }\n+                }\n+            }\n+\n+            _ => {\n+                ty_fold::super_fold_ty(self, ty)\n+            }\n+        }\n+    }\n+}"}, {"sha": "0bc35390cd7c090c9308be9c28e519f928d5e98c", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -241,7 +241,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n         }\n \n-        ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n+        ty::ty_projection(..) | ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n             cx.sess().bug(format!(\"fictitious type {} in sizing_type_of()\",\n                                   ppaux::ty_to_string(cx.tcx(), t))[])\n         }\n@@ -414,6 +414,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n       },\n \n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),\n+      ty::ty_projection(..) => cx.sess().bug(\"type_of with ty_projection\"),\n       ty::ty_param(..) => cx.sess().bug(\"type_of with ty_param\"),\n       ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\"),\n     };"}, {"sha": "00d3478e6a5175df8c58a41662209a7922870432", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 265, "deletions": 189, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -51,7 +51,7 @@ use middle::astconv_util::{ast_ty_to_prim_ty, check_path_args, NO_TPS, NO_REGION\n use middle::const_eval;\n use middle::def;\n use middle::resolve_lifetime as rl;\n-use middle::subst::{FnSpace, TypeSpace, AssocSpace, SelfSpace, Subst, Substs};\n+use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n use middle::ty::{mod, RegionEscape, Ty};\n use rscope::{mod, UnelidableRscope, RegionScope, SpecificRscope,\n@@ -84,25 +84,45 @@ pub trait AstConv<'tcx> {\n     /// What type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n \n-    /// Returns true if associated types from the given trait and type are\n-    /// allowed to be used here and false otherwise.\n-    fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty<'tcx>,\n-                                           trait_id: ast::DefId)\n-                                           -> bool;\n-\n-    /// Returns the concrete type bound to the given associated type (indicated\n-    /// by associated_type_id) in the current context. For example,\n-    /// in `trait Foo { type A; }` looking up `A` will give a type variable;\n-    /// in `impl Foo for ... { type A = int; ... }` looking up `A` will give `int`.\n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               self_ty: Option<Ty<'tcx>>,\n-                               // DefId for the declaration of the trait\n-                               // in which the associated type is declared.\n-                               trait_id: ast::DefId,\n-                               associated_type_id: ast::DefId)\n-                               -> Option<Ty<'tcx>>;\n+    /// Projecting an associated type from a (potentially)\n+    /// higher-ranked trait reference is more complicated, because of\n+    /// the possibility of late-bound regions appearing in the\n+    /// associated type binding. This is not legal in function\n+    /// signatures for that reason. In a function body, we can always\n+    /// handle it because we can use inference variables to remove the\n+    /// late-bound regions.\n+    fn projected_ty_from_poly_trait_ref(&self,\n+                                        span: Span,\n+                                        poly_trait_ref: ty::PolyTraitRef<'tcx>,\n+                                        item_name: ast::Name)\n+                                        -> Ty<'tcx>\n+    {\n+        if ty::binds_late_bound_regions(self.tcx(), &poly_trait_ref) {\n+            self.tcx().sess.span_err(\n+                span,\n+                \"cannot extract an associated type from a higher-ranked trait bound \\\n+                 in this context\");\n+            self.tcx().types.err\n+        } else {\n+            // no late-bound regions, we can just ignore the binder\n+            self.projected_ty(span, poly_trait_ref.0.clone(), item_name)\n+        }\n+    }\n+\n+    /// Project an associated type from a non-higher-ranked trait reference.\n+    /// This is fairly straightforward and can be accommodated in any context.\n+    fn projected_ty(&self,\n+                    span: Span,\n+                    _trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                    _item_name: ast::Name)\n+                    -> Ty<'tcx>\n+    {\n+        self.tcx().sess.span_err(\n+            span,\n+            \"associated types are not accepted in this context\");\n+\n+        self.tcx().types.err\n+    }\n }\n \n pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n@@ -255,28 +275,28 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n         }\n     };\n \n+    prohibit_projections(this.tcx(), assoc_bindings.as_slice());\n+\n     create_substs_for_ast_path(this,\n                                rscope,\n                                path.span,\n                                decl_def_id,\n                                decl_generics,\n                                None,\n                                types,\n-                               regions,\n-                               assoc_bindings)\n+                               regions)\n }\n \n fn create_substs_for_ast_path<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    decl_def_id: ast::DefId,\n+    _decl_def_id: ast::DefId,\n     decl_generics: &ty::Generics<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     types: Vec<Ty<'tcx>>,\n-    regions: Vec<ty::Region>,\n-    assoc_bindings: Vec<(ast::Ident, Ty<'tcx>)>)\n-    -> Substs<'tcx>\n+    regions: Vec<ty::Region>)\n+ -> Substs<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let tcx = this.tcx();\n@@ -382,52 +402,21 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n         }\n     }\n \n-    for formal_assoc in decl_generics.types.get_slice(AssocSpace).iter() {\n-        let mut found = false;\n-        for &(ident, ty) in assoc_bindings.iter() {\n-            if formal_assoc.name.ident() == ident {\n-                substs.types.push(AssocSpace, ty);\n-                found = true;\n-                break;\n-            }\n-        }\n-        if !found {\n-            match this.associated_type_binding(span,\n-                                               self_ty,\n-                                               decl_def_id,\n-                                               formal_assoc.def_id) {\n-                Some(ty) => {\n-                    substs.types.push(AssocSpace, ty);\n-                }\n-                None => {\n-                    substs.types.push(AssocSpace, ty::mk_err());\n-                    span_err!(this.tcx().sess, span, E0171,\n-                              \"missing type for associated type `{}`\",\n-                              token::get_ident(formal_assoc.name.ident()));\n-                }\n-            }\n-        }\n-    }\n-\n-    for &(ident, _) in assoc_bindings.iter() {\n-        let mut formal_idents = decl_generics.types.get_slice(AssocSpace)\n-                                .iter().map(|t| t.name.ident());\n-        if !formal_idents.any(|i| i == ident) {\n-            span_err!(this.tcx().sess, span, E0177,\n-                      \"associated type `{}` does not exist\",\n-                      token::get_ident(ident));\n-        }\n-    }\n-\n     return substs;\n }\n \n+struct ConvertedBinding<'tcx> {\n+    item_name: ast::Name,\n+    ty: Ty<'tcx>,\n+    span: Span,\n+}\n+\n fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n                                                     rscope: &RS,\n                                                     data: &ast::AngleBracketedParameterData)\n                                                     -> (Vec<ty::Region>,\n                                                         Vec<Ty<'tcx>>,\n-                                                        Vec<(ast::Ident, Ty<'tcx>)>)\n+                                                        Vec<ConvertedBinding<'tcx>>)\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let regions: Vec<_> =\n@@ -442,7 +431,9 @@ fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n \n     let assoc_bindings: Vec<_> =\n         data.bindings.iter()\n-        .map(|b| (b.ident, ast_ty_to_ty(this, rscope, &*b.ty)))\n+        .map(|b| ConvertedBinding { item_name: b.ident.name,\n+                                    ty: ast_ty_to_ty(this, rscope, &*b.ty),\n+                                    span: b.span })\n         .collect();\n \n     (regions, types, assoc_bindings)\n@@ -534,38 +525,47 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n     rscope: &RS,\n     ast_trait_ref: &ast::PolyTraitRef,\n     self_ty: Option<Ty<'tcx>>,\n-    allow_eq: AllowEqConstraints)\n-    -> Rc<ty::PolyTraitRef<'tcx>>\n+    poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n+    -> ty::PolyTraitRef<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n+    let mut projections = Vec::new();\n+\n     let trait_ref =\n-        instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty, allow_eq);\n-    let trait_ref = (*trait_ref).clone();\n-    Rc::new(ty::Binder(trait_ref)) // Ugh.\n+        instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref,\n+                              self_ty, Some(&mut projections));\n+\n+    for projection in projections.into_iter() {\n+        poly_projections.push(ty::Binder(projection));\n+    }\n+\n+    ty::Binder(trait_ref)\n }\n \n /// Instantiates the path for the given trait reference, assuming that it's\n /// bound to a valid trait type. Returns the def_id for the defining trait.\n /// Fails if the type is a type other than a trait type.\n-pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n-                                         rscope: &RS,\n-                                         ast_trait_ref: &ast::TraitRef,\n-                                         self_ty: Option<Ty<'tcx>>,\n-                                         allow_eq: AllowEqConstraints)\n-                                         -> Rc<ty::TraitRef<'tcx>>\n-                                         where AC: AstConv<'tcx>,\n-                                               RS: RegionScope\n+///\n+/// If the `projections` argument is `None`, then assoc type bindings like `Foo<T=X>`\n+/// are disallowed. Otherwise, they are pushed onto the vector given.\n+pub fn instantiate_trait_ref<'tcx,AC,RS>(\n+    this: &AC,\n+    rscope: &RS,\n+    ast_trait_ref: &ast::TraitRef,\n+    self_ty: Option<Ty<'tcx>>,\n+    projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n+    -> Rc<ty::TraitRef<'tcx>>\n+    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     match ::lookup_def_tcx(this.tcx(), ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => {\n-            let trait_ref = Rc::new(ast_path_to_trait_ref(this,\n-                                                          rscope,\n-                                                          trait_def_id,\n-                                                          self_ty,\n-                                                          &ast_trait_ref.path,\n-                                                          allow_eq));\n-            this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n-                                                      trait_ref.clone());\n+            let trait_ref = ast_path_to_trait_ref(this,\n+                                                  rscope,\n+                                                  trait_def_id,\n+                                                  self_ty,\n+                                                  &ast_trait_ref.path,\n+                                                  projections);\n+            this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id, trait_ref.clone());\n             trait_ref\n         }\n         _ => {\n@@ -576,20 +576,14 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n     }\n }\n \n-#[deriving(PartialEq,Show)]\n-pub enum AllowEqConstraints {\n-    Allow,\n-    DontAllow\n-}\n-\n-fn ast_path_to_trait_ref<'tcx,AC,RS>(\n+fn ast_path_to_trait_ref<'a,'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     trait_def_id: ast::DefId,\n     self_ty: Option<Ty<'tcx>>,\n     path: &ast::Path,\n-    allow_eq: AllowEqConstraints)\n-    -> ty::TraitRef<'tcx>\n+    mut projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n+    -> Rc<ty::TraitRef<'tcx>>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     debug!(\"ast_path_to_trait_ref {}\", path);\n@@ -624,22 +618,76 @@ fn ast_path_to_trait_ref<'tcx,AC,RS>(\n         }\n     };\n \n-    if allow_eq == AllowEqConstraints::DontAllow && assoc_bindings.len() > 0 {\n-        span_err!(this.tcx().sess, path.span, E0173,\n-                  \"equality constraints are not allowed in this position\");\n-    }\n-\n     let substs = create_substs_for_ast_path(this,\n                                             &shifted_rscope,\n                                             path.span,\n                                             trait_def_id,\n                                             &trait_def.generics,\n                                             self_ty,\n                                             types,\n-                                            regions,\n-                                            assoc_bindings);\n+                                            regions);\n+    let substs = this.tcx().mk_substs(substs);\n+\n+    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n+\n+    match projections {\n+        None => {\n+            prohibit_projections(this.tcx(), assoc_bindings.as_slice());\n+        }\n+        Some(ref mut v) => {\n+            for binding in assoc_bindings.iter() {\n+                match ast_type_binding_to_projection_predicate(this, trait_ref.clone(), binding) {\n+                    Ok(pp) => { v.push(pp); }\n+                    Err(ErrorReported) => { }\n+                }\n+            }\n+        }\n+    }\n+\n+    trait_ref\n+}\n \n-    ty::TraitRef::new(trait_def_id, this.tcx().mk_substs(substs))\n+pub fn ast_type_binding_to_projection_predicate<'tcx,AC>(\n+    this: &AC,\n+    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    binding: &ConvertedBinding<'tcx>)\n+    -> Result<ty::ProjectionPredicate<'tcx>, ErrorReported>\n+    where AC : AstConv<'tcx>\n+{\n+    // Given something like `U : SomeTrait<T=X>`, we want to produce a\n+    // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n+    // subtle in the event that `T` is defined in a supertrait of\n+    // `SomeTrait`, because in that case we need to upcast.\n+    //\n+    // That is, consider this case:\n+    //\n+    // ```\n+    // trait SubTrait : SuperTrait<int> { }\n+    // trait SuperTrait<A> { type T; }\n+    //\n+    // ... B : SubTrait<T=foo> ...\n+    // ```\n+    //\n+    // We want to produce `<B as SuperTrait<int>>::T == foo`.\n+\n+    // FIXME(#19541): supertrait upcasting not actually impl'd :)\n+\n+    if !trait_defines_associated_type_named(this, trait_ref.def_id, binding.item_name) {\n+        this.tcx().sess.span_err(\n+            binding.span,\n+            format!(\"no associated type `{}` defined in `{}`\",\n+                    token::get_name(binding.item_name),\n+                    trait_ref.user_string(this.tcx())).as_slice());\n+        return Err(ErrorReported);\n+    }\n+\n+    Ok(ty::ProjectionPredicate {\n+        projection_ty: ty::ProjectionTy {\n+            trait_ref: trait_ref,\n+            item_name: binding.item_name,\n+        },\n+        ty: binding.ty,\n+    })\n }\n \n pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n@@ -784,12 +832,14 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n         ast::TyPath(ref path, id) => {\n             match this.tcx().def_map.borrow().get(&id) {\n                 Some(&def::DefTrait(trait_def_id)) => {\n-                    return Ok(ty::Binder(ast_path_to_trait_ref(this,\n-                                                               rscope,\n-                                                               trait_def_id,\n-                                                               None,\n-                                                               path,\n-                                                               AllowEqConstraints::Allow)));\n+                    // TODO do something with this\n+                    let mut projections = Vec::new();\n+                    Ok(ty::Binder(ast_path_to_trait_ref(this,\n+                                                        rscope,\n+                                                        trait_def_id,\n+                                                        None,\n+                                                        path,\n+                                                        Some(&mut projections))))\n                 }\n                 _ => {\n                     span_err!(this.tcx().sess, ty.span, E0172, \"expected a reference to a trait\");\n@@ -831,7 +881,7 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n                                         rscope: &RS,\n                                         span: Span,\n-                                        trait_ref: ty::PolyTraitRef<'tcx>,\n+                                        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n                                         bounds: &[ast::TyParamBound])\n                                         -> Ty<'tcx>\n     where AC : AstConv<'tcx>, RS : RegionScope\n@@ -849,6 +899,68 @@ fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n     result\n }\n \n+fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n+                                   ast_ty: &ast::Ty,\n+                                   provenance: def::TyParamProvenance,\n+                                   assoc_name: ast::Name)\n+                                   -> Ty<'tcx>\n+{\n+    let tcx = this.tcx();\n+    let ty_param_def_id = provenance.def_id();\n+    let mut suitable_bounds: Vec<_>;\n+    let ty_param_name: ast::Name;\n+    { // contain scope of refcell:\n+        let ty_param_defs = tcx.ty_param_defs.borrow();\n+        let ty_param_def = &ty_param_defs[ty_param_def_id.node];\n+        ty_param_name = ty_param_def.name;\n+\n+        // FIXME(#19541): we should consider associated types in\n+        // super-traits. Probably by elaborating the bounds.\n+\n+        suitable_bounds =\n+            ty_param_def.bounds.trait_bounds // TODO trait_bounds, no good\n+            .iter()\n+            .cloned()\n+            .filter(|b| trait_defines_associated_type_named(this, b.def_id(), assoc_name))\n+            .collect();\n+    }\n+\n+    if suitable_bounds.len() == 0 {\n+        tcx.sess.span_err(ast_ty.span,\n+                          format!(\"associated type `{}` not found for type parameter `{}`\",\n+                                  token::get_name(assoc_name),\n+                                  token::get_name(ty_param_name)).as_slice());\n+        return this.tcx().types.err;\n+    }\n+\n+    if suitable_bounds.len() > 1 {\n+        tcx.sess.span_err(ast_ty.span,\n+                          format!(\"ambiguous associated type `{}` in bounds of `{}`\",\n+                                  token::get_name(assoc_name),\n+                                  token::get_name(ty_param_name)).as_slice());\n+\n+        for suitable_bound in suitable_bounds.iter() {\n+            span_note!(this.tcx().sess, ast_ty.span,\n+                       \"associated type `{}` could derive from `{}`\",\n+                       token::get_name(ty_param_name),\n+                       suitable_bound.user_string(this.tcx()));\n+        }\n+    }\n+\n+    let suitable_bound = suitable_bounds.pop().unwrap().clone();\n+    return this.projected_ty_from_poly_trait_ref(ast_ty.span, suitable_bound, assoc_name);\n+}\n+\n+fn trait_defines_associated_type_named(this: &AstConv,\n+                                       trait_def_id: ast::DefId,\n+                                       assoc_name: ast::Name)\n+                                       -> bool\n+{\n+    let tcx = this.tcx();\n+    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+    trait_def.associated_type_names.contains(&assoc_name)\n+}\n+\n fn qpath_to_ty<'tcx,AC,RS>(this: &AC,\n                            rscope: &RS,\n                            ast_ty: &ast::Ty, // the TyQPath\n@@ -867,33 +979,13 @@ fn qpath_to_ty<'tcx,AC,RS>(this: &AC,\n                                           rscope,\n                                           &*qpath.trait_ref,\n                                           Some(self_type),\n-                                          AllowEqConstraints::DontAllow);\n+                                          None);\n \n     debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(this.tcx()));\n \n-    if let Some(ty) = find_assoc_ty(this, &*trait_ref, qpath.item_name) {\n-        return ty;\n-    }\n-\n-    this.tcx().sess.span_bug(ast_ty.span,\n-                             \"this associated type didn't get added \\\n-                              as a parameter for some reason\")\n-}\n-\n-fn find_assoc_ty<'tcx, AC>(this: &AC,\n-                           trait_ref: &ty::TraitRef<'tcx>,\n-                           type_name: ast::Ident)\n-                           -> Option<Ty<'tcx>>\n-where AC: AstConv<'tcx> {\n-    let trait_def = this.get_trait_def(trait_ref.def_id);\n-\n-    for ty_param_def in trait_def.generics.types.get_slice(AssocSpace).iter() {\n-        if ty_param_def.name == type_name.name {\n-            return Some(trait_ref.substs.type_for_def(ty_param_def));\n-        }\n-    }\n-\n-    None\n+    return this.projected_ty(ast_ty.span,\n+                             trait_ref,\n+                             qpath.item_name.name); // TODO change qpath to use name\n }\n \n // Parses the programmer's textual representation of a type into our\n@@ -928,6 +1020,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             ast::TyObjectSum(ref ty, ref bounds) => {\n                 match ast_ty_to_trait_ref(this, rscope, &**ty, bounds[]) {\n                     Ok(trait_ref) => {\n+                        let trait_ref = trait_ref.remove_rc();\n                         trait_ref_to_object_type(this, rscope, ast_ty.span,\n                                                  trait_ref, bounds[])\n                     }\n@@ -1000,13 +1093,16 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     def::DefTrait(trait_def_id) => {\n                         // N.B. this case overlaps somewhat with\n                         // TyObjectSum, see that fn for details\n-                        let result = ty::Binder(ast_path_to_trait_ref(this,\n-                                                                      rscope,\n-                                                                      trait_def_id,\n-                                                                      None,\n-                                                                      path,\n-                                                                      AllowEqConstraints::Allow));\n-                        trait_ref_to_object_type(this, rscope, path.span, result, &[])\n+                        let mut projections = Vec::new(); // TODO\n+                        let trait_ref = ast_path_to_trait_ref(this,\n+                                                              rscope,\n+                                                              trait_def_id,\n+                                                              None,\n+                                                              path,\n+                                                              Some(&mut projections));\n+                        let trait_ref = (*trait_ref).clone();\n+                        let trait_ref = ty::Binder(trait_ref);\n+                        trait_ref_to_object_type(this, rscope, path.span, trait_ref, &[])\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n                         ast_path_to_ty(this, rscope, did, path).ty\n@@ -1048,44 +1144,9 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                   .get())[]);\n                         this.tcx().types.err\n                     }\n-                    def::DefAssociatedPath(typ, assoc_ident) => {\n-                        // FIXME(#19541): in both branches we should consider\n-                        // associated types in super-traits.\n-                        let (assoc_tys, tp_name): (Vec<_>, _) = match typ {\n-                            def::TyParamProvenance::FromParam(did) |\n-                            def::TyParamProvenance::FromSelf(did) => {\n-                                let ty_param_defs = tcx.ty_param_defs.borrow();\n-                                let tp_def = &(*ty_param_defs)[did.node];\n-                                let assoc_tys = tp_def.bounds.trait_bounds.iter()\n-                                    .filter_map(|b| find_assoc_ty(this, &b.0, assoc_ident))\n-                                    .collect();\n-                                (assoc_tys, token::get_name(tp_def.name).to_string())\n-                            }\n-                        };\n-\n-                        if assoc_tys.len() == 0 {\n-                            tcx.sess.span_err(ast_ty.span,\n-                                              format!(\"associated type `{}` not \\\n-                                                       found for type parameter `{}`\",\n-                                                      token::get_ident(assoc_ident),\n-                                                      tp_name).as_slice());\n-                            return ty::mk_err()\n-                        }\n-\n-                        if assoc_tys.len() > 1 {\n-                            tcx.sess.span_err(ast_ty.span,\n-                                              format!(\"ambiguous associated type \\\n-                                                       `{}` in bounds of `{}`\",\n-                                                      token::get_ident(assoc_ident),\n-                                                      tp_name).as_slice());\n-                        }\n-\n-                        let mut result_ty = assoc_tys[0];\n-                        if let Some(substs) = this.get_free_substs() {\n-                            result_ty = result_ty.subst(tcx, substs);\n-                        }\n-\n-                        result_ty\n+                    def::DefAssociatedPath(provenance, assoc_ident) => {\n+                        // TODO update DefAssociatedPath to use name\n+                        associated_path_def_to_ty(this, ast_ty, provenance, assoc_ident.name)\n                     }\n                     _ => {\n                         tcx.sess.span_fatal(ast_ty.span,\n@@ -1440,7 +1501,7 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>, // None for boxed closures\n+    principal_trait_ref: Option<&ty::Binder<ty::TraitRef<'tcx>>>, // None for boxed closures\n     ast_bounds: &[ast::TyParamBound])\n     -> ty::ExistentialBounds\n {\n@@ -1461,13 +1522,15 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n {\n     let mut partitioned_bounds = partition_bounds(this.tcx(), span, ast_bounds[]);\n \n+    let mut projections = Vec::new();\n     let main_trait_bound = match partitioned_bounds.trait_bounds.remove(0) {\n         Some(trait_bound) => {\n-            Some(instantiate_poly_trait_ref(this,\n-                                            rscope,\n-                                            trait_bound,\n-                                            None,\n-                                            AllowEqConstraints::Allow))\n+            let ptr = instantiate_poly_trait_ref(this,\n+                                                 rscope,\n+                                                 trait_bound,\n+                                                 None,\n+                                                 &mut projections);\n+            Some(ptr.remove_rc())\n         }\n         None => {\n             this.tcx().sess.span_err(\n@@ -1477,11 +1540,13 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n         }\n     };\n \n+    // TODO use projections somewhere\n+\n     let bounds =\n         conv_existential_bounds_from_partitioned_bounds(this,\n                                                         rscope,\n                                                         span,\n-                                                        main_trait_bound.as_ref().map(|tr| &**tr),\n+                                                        main_trait_bound.as_ref(),\n                                                         partitioned_bounds);\n \n     match main_trait_bound {\n@@ -1494,7 +1559,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>, // None for boxed closures\n+    principal_trait_ref: Option<&ty::Binder<ty::TraitRef<'tcx>>>, // None for boxed closures\n     partitioned_bounds: PartitionedBounds)\n     -> ty::ExistentialBounds\n     where AC: AstConv<'tcx>, RS:RegionScope\n@@ -1532,7 +1597,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   span: Span,\n                                   explicit_region_bounds: &[&ast::Lifetime],\n-                                  principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>,\n+                                  principal_trait_ref: Option<&ty::Binder<ty::TraitRef<'tcx>>>,\n                                   builtin_bounds: ty::BuiltinBounds)\n                                   -> Option<ty::Region>\n {\n@@ -1592,7 +1657,7 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     rscope: &RS,\n     span: Span,\n     region_bounds: &[&ast::Lifetime],\n-    principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>, // None for closures\n+    principal_trait_ref: Option<&ty::Binder<ty::TraitRef<'tcx>>>, // None for closures\n     builtin_bounds: ty::BuiltinBounds)\n     -> ty::Region\n {\n@@ -1660,6 +1725,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n                         if ty::try_add_builtin_trait(tcx,\n                                                      trait_did,\n                                                      &mut builtin_bounds) {\n+                            // TODO Copy<T>?\n                             continue; // success\n                         }\n                     }\n@@ -1683,3 +1749,13 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n         region_bounds: region_bounds,\n     }\n }\n+\n+fn prohibit_projections<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              bindings: &[ConvertedBinding<'tcx>])\n+{\n+    for binding in bindings.iter().take(1) {\n+        tcx.sess.span_err(\n+            binding.span,\n+            \"associated type bindings are not allowed here\");\n+    }\n+}"}, {"sha": "0e8b5b373f14471c4c05b89f93d46474a8ee97a8", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -11,7 +11,7 @@\n use middle::def;\n use middle::infer;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n-use middle::subst::{Subst, Substs};\n+use middle::subst::{Substs};\n use middle::ty::{mod, Ty};\n use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n@@ -410,17 +410,24 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n     demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n     let real_path_ty = fcx.node_ty(pat.id);\n-    let (arg_tys, kind_name) = match real_path_ty.sty {\n+    let (arg_tys, kind_name): (Vec<_>, &'static str) = match real_path_ty.sty {\n         ty::ty_enum(enum_def_id, expected_substs)\n-            if def == def::DefVariant(enum_def_id, def.def_id(), false) => {\n+            if def == def::DefVariant(enum_def_id, def.def_id(), false) =>\n+        {\n             let variant = ty::enum_variant_with_id(tcx, enum_def_id, def.def_id());\n-            (variant.args.iter().map(|t| t.subst(tcx, expected_substs)).collect::<Vec<_>>(),\n-                \"variant\")\n+            (variant.args.iter()\n+                         .map(|t| fcx.instantiate_type_scheme(pat.span, expected_substs, t))\n+                         .collect(),\n+             \"variant\")\n         }\n         ty::ty_struct(struct_def_id, expected_substs) => {\n             let struct_fields = ty::struct_fields(tcx, struct_def_id, expected_substs);\n-            (struct_fields.iter().map(|field| field.mt.ty).collect::<Vec<_>>(),\n-                \"struct\")\n+            (struct_fields.iter()\n+                          .map(|field| fcx.instantiate_type_scheme(pat.span,\n+                                                                   expected_substs,\n+                                                                   &field.mt.ty))\n+                          .collect(),\n+             \"struct\")\n         }\n         _ => {\n             let name = pprust::path_to_string(path);"}, {"sha": "65ade452fa1117ca85afce4e5a6e7bf197141ac7", "filename": "src/librustc_typeck/check/assoc.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::infer::InferCtxt;\n+use middle::traits::{ObligationCause, ObligationCauseCode, FulfillmentContext};\n+use middle::ty::{mod, HasProjectionTypes, Ty};\n+use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use std::rc::Rc;\n+\n+pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n+                                                fulfillment_cx: &mut FulfillmentContext<'tcx>,\n+                                                span: Span,\n+                                                body_id: ast::NodeId,\n+                                                value: &T)\n+                                                -> T\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone\n+{\n+    let value = infcx.resolve_type_vars_if_possible(value);\n+\n+    if !value.has_projection_types() {\n+        return value.clone();\n+    }\n+\n+    let mut normalizer = AssociatedTypeNormalizer { span: span,\n+                                                    body_id: body_id,\n+                                                    infcx: infcx,\n+                                                    fulfillment_cx: fulfillment_cx };\n+    value.fold_with(&mut normalizer)\n+}\n+\n+struct AssociatedTypeNormalizer<'a,'tcx:'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    fulfillment_cx: &'a mut FulfillmentContext<'tcx>,\n+    span: Span,\n+    body_id: ast::NodeId,\n+}\n+\n+impl<'a,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match ty.sty {\n+            ty::ty_projection(ref data) => {\n+                let cause =\n+                    ObligationCause::new(\n+                        self.span,\n+                        self.body_id,\n+                        ObligationCauseCode::MiscObligation);\n+                let trait_ref = Rc::new(data.trait_ref.clone());\n+                self.fulfillment_cx\n+                    .normalize_associated_type(self.infcx,\n+                                               trait_ref,\n+                                               data.item_name,\n+                                               cause)\n+            }\n+            _ => {\n+                ty_fold::super_fold_ty(self, ty)\n+            }\n+        }\n+    }\n+}"}, {"sha": "ec964ab638f14296ed353e5353b5e6a06adb8599", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -15,7 +15,7 @@ use super::{check_fn, Expectation, FnCtxt};\n use astconv;\n use middle::infer;\n use middle::subst;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, ToPolyTraitRef, Ty};\n use rscope::RegionScope;\n use syntax::abi;\n use syntax::ast;\n@@ -168,7 +168,8 @@ fn deduce_unboxed_closure_expectations_from_expected_type<'a,'tcx>(\n {\n     match expected_ty.sty {\n         ty::ty_trait(ref object_type) => {\n-            deduce_unboxed_closure_expectations_from_trait_ref(fcx, &object_type.principal)\n+            let trait_ref = object_type.principal_trait_ref_with_self_ty(fcx.tcx().types.err);\n+            deduce_unboxed_closure_expectations_from_trait_ref(fcx, &trait_ref)\n         }\n         ty::ty_infer(ty::TyVar(vid)) => {\n             deduce_unboxed_closure_expectations_from_obligations(fcx, vid)\n@@ -227,23 +228,21 @@ fn deduce_unboxed_closure_expectations_from_obligations<'a,'tcx>(\n {\n     // Here `expected_ty` is known to be a type inference variable.\n     for obligation in fcx.inh.fulfillment_cx.borrow().pending_obligations().iter() {\n-        match obligation.trait_ref {\n-            ty::Predicate::Trait(ref trait_ref) => {\n+        match obligation.predicate {\n+            ty::Predicate::Trait(ref trait_predicate) => {\n+                let trait_ref = trait_predicate.to_poly_trait_ref();\n                 let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n                 match self_ty.sty {\n                     ty::ty_infer(ty::TyVar(v)) if expected_vid == v => { }\n                     _ => { continue; }\n                 }\n \n-                match deduce_unboxed_closure_expectations_from_trait_ref(fcx, &**trait_ref) {\n+                match deduce_unboxed_closure_expectations_from_trait_ref(fcx, &trait_ref) {\n                     Some(e) => { return Some(e); }\n                     None => { }\n                 }\n             }\n-            ty::Predicate::Equate(..) |\n-            ty::Predicate::RegionOutlives(..) |\n-            ty::Predicate::TypeOutlives(..) => {\n-            }\n+            _ => { }\n         }\n     }\n "}, {"sha": "de6824fa5ddd1e822a5dede46b6fc8ba7c58c0dd", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -11,7 +11,7 @@\n use super::probe;\n \n use check::{mod, FnCtxt, NoPreference, PreferMutLvalue, callee};\n-use middle::subst::{mod, Subst};\n+use middle::subst::{mod};\n use middle::traits;\n use middle::ty::{mod, Ty};\n use middle::ty::{MethodCall, MethodCallee, MethodObject, MethodOrigin,\n@@ -227,14 +227,14 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     let upcast_poly_trait_ref =\n                         this.upcast(original_poly_trait_ref.clone(), trait_def_id);\n                     let upcast_trait_ref =\n-                        this.replace_late_bound_regions_with_fresh_var(&*upcast_poly_trait_ref);\n+                        this.replace_late_bound_regions_with_fresh_var(&upcast_poly_trait_ref);\n                     debug!(\"original_poly_trait_ref={} upcast_trait_ref={} target_trait={}\",\n                            original_poly_trait_ref.repr(this.tcx()),\n                            upcast_trait_ref.repr(this.tcx()),\n                            trait_def_id.repr(this.tcx()));\n                     let substs = upcast_trait_ref.substs.clone();\n                     let origin = MethodTraitObject(MethodObject {\n-                        trait_ref: Rc::new(upcast_trait_ref),\n+                        trait_ref: upcast_trait_ref,\n                         object_trait_id: trait_def_id,\n                         method_num: method_num,\n                         real_index: real_index,\n@@ -254,9 +254,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 // parameters from the trait ([$A,$B]), not those from\n                 // the impl ([$A,$B,$C]) not the receiver type ([$C]).\n                 let impl_polytype = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n-                let impl_trait_ref = ty::impl_trait_ref(self.tcx(), impl_def_id)\n-                                     .unwrap()\n-                                     .subst(self.tcx(), &impl_polytype.substs);\n+                let impl_trait_ref =\n+                    self.fcx.instantiate_type_scheme(\n+                        self.span,\n+                        &impl_polytype.substs,\n+                        &ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap());\n                 let origin = MethodTypeParam(MethodParam { trait_ref: impl_trait_ref.clone(),\n                                                            method_num: method_num });\n                 (impl_trait_ref.substs.clone(), origin)\n@@ -284,9 +286,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             probe::WhereClausePick(ref poly_trait_ref, method_num) => {\n                 // Where clauses can have bound regions in them. We need to instantiate\n                 // those to convert from a poly-trait-ref to a trait-ref.\n-                let trait_ref = self.replace_late_bound_regions_with_fresh_var(&**poly_trait_ref);\n+                let trait_ref = self.replace_late_bound_regions_with_fresh_var(&*poly_trait_ref);\n                 let substs = trait_ref.substs.clone();\n-                let origin = MethodTypeParam(MethodParam { trait_ref: Rc::new(trait_ref),\n+                let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n                                                            method_num: method_num });\n                 (substs, origin)\n             }\n@@ -425,9 +427,13 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // Substitute the type/early-bound-regions into the method\n         // signature. In addition, the method signature may bind\n         // late-bound regions, so instantiate those.\n-        let method_sig = pick.method_ty.fty.sig.subst(self.tcx(), &all_substs);\n-        let method_sig = self.replace_late_bound_regions_with_fresh_var(&method_sig);\n+        let method_sig = self.fcx.instantiate_type_scheme(self.span,\n+                                                          &all_substs,\n+                                                          &pick.method_ty.fty.sig);\n+        debug!(\"late-bound lifetimes from method substituted, method_sig={}\",\n+               method_sig.repr(self.tcx()));\n \n+        let method_sig = self.replace_late_bound_regions_with_fresh_var(&method_sig);\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={}\",\n                method_sig.repr(self.tcx()));\n \n@@ -626,9 +632,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn upcast(&mut self,\n-              source_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n+              source_trait_ref: ty::PolyTraitRef<'tcx>,\n               target_trait_def_id: ast::DefId)\n-              -> Rc<ty::PolyTraitRef<'tcx>>\n+              -> ty::PolyTraitRef<'tcx>\n     {\n         for super_trait_ref in traits::supertraits(self.tcx(), source_trait_ref.clone()) {\n             if super_trait_ref.def_id() == target_trait_def_id {"}, {"sha": "cb71fbce8ac4cf22b179d514981e098da5130503", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -16,7 +16,6 @@ use check::{impl_self_ty};\n use check::vtable;\n use check::vtable::select_new_fcx_obligations;\n use middle::subst;\n-use middle::subst::{Subst};\n use middle::traits;\n use middle::ty::*;\n use middle::ty;\n@@ -167,7 +166,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, fcx.tcx().mk_substs(substs)));\n \n     // Construct an obligation\n-    let poly_trait_ref = Rc::new(ty::Binder((*trait_ref).clone()));\n+    let poly_trait_ref = trait_ref.to_poly_trait_ref();\n     let obligation = traits::Obligation::misc(span,\n                                               fcx.body_id,\n                                               poly_trait_ref.as_predicate());\n@@ -193,11 +192,12 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n     // Substitute the trait parameters into the method type and\n     // instantiate late-bound regions to get the actual method type.\n-    let ref bare_fn_ty = method_ty.fty;\n-    let fn_sig = bare_fn_ty.sig.subst(tcx, trait_ref.substs);\n+    let bare_fn_ty = fcx.instantiate_type_scheme(span,\n+                                                 &trait_ref.substs,\n+                                                 &method_ty.fty);\n     let fn_sig = fcx.infcx().replace_late_bound_regions_with_fresh_var(span,\n                                                                        infer::FnCall,\n-                                                                       &fn_sig).0;\n+                                                                       &bare_fn_ty.sig).0;\n     let transformed_self_ty = fn_sig.inputs[0];\n     let fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(ty::BareFnTy {\n         sig: ty::Binder(fn_sig),"}, {"sha": "1a9e124521e0f4d9f78c9a5a24b6339adcf9ba10", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -18,7 +18,7 @@ use middle::fast_reject;\n use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, Ty, ToPolyTraitRef};\n use middle::ty_fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n@@ -61,7 +61,7 @@ enum CandidateKind<'tcx> {\n     ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n                            subst::Substs<'tcx>, MethodIndex),\n     UnboxedClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClauseCandidate(Rc<ty::PolyTraitRef<'tcx>>, MethodIndex),\n+    WhereClauseCandidate(ty::PolyTraitRef<'tcx>, MethodIndex),\n }\n \n pub struct Pick<'tcx> {\n@@ -76,7 +76,7 @@ pub enum PickKind<'tcx> {\n     ObjectPick(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n     ExtensionImplPick(/* Impl */ ast::DefId, MethodIndex),\n     TraitPick(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClausePick(/* Trait */ Rc<ty::PolyTraitRef<'tcx>>, MethodIndex),\n+    WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>, MethodIndex),\n }\n \n pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError>;\n@@ -235,7 +235,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         match self_ty.sty {\n             ty::ty_trait(box ref data) => {\n                 self.assemble_inherent_candidates_from_object(self_ty, data);\n-                self.assemble_inherent_impl_candidates_for_type(data.principal.def_id());\n+                self.assemble_inherent_impl_candidates_for_type(data.principal_def_id());\n             }\n             ty::ty_enum(did, _) |\n             ty::ty_struct(did, _) |\n@@ -308,7 +308,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n         self.elaborate_bounds(&[trait_ref.clone()], false, |this, new_trait_ref, m, method_num| {\n             let vtable_index =\n-                get_method_index(tcx, &*new_trait_ref, trait_ref.clone(), method_num);\n+                get_method_index(tcx, &new_trait_ref, trait_ref.clone(), method_num);\n \n             let xform_self_ty = this.xform_self_ty(&m, new_trait_ref.substs());\n \n@@ -330,13 +330,16 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             .iter()\n             .filter_map(|predicate| {\n                 match *predicate {\n-                    ty::Predicate::Trait(ref trait_ref) => {\n-                        match trait_ref.self_ty().sty {\n-                            ty::ty_param(ref p) if *p == param_ty => Some(trait_ref.clone()),\n+                    ty::Predicate::Trait(ref trait_predicate) => {\n+                        match trait_predicate.0.trait_ref.self_ty().sty {\n+                            ty::ty_param(ref p) if *p == param_ty => {\n+                                Some(trait_predicate.to_poly_trait_ref())\n+                            }\n                             _ => None\n                         }\n                     }\n                     ty::Predicate::Equate(..) |\n+                    ty::Predicate::Projection(..) |\n                     ty::Predicate::RegionOutlives(..) |\n                     ty::Predicate::TypeOutlives(..) => {\n                         None\n@@ -381,10 +384,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     // create the candidates.\n     fn elaborate_bounds(\n         &mut self,\n-        bounds: &[Rc<ty::PolyTraitRef<'tcx>>],\n+        bounds: &[ty::PolyTraitRef<'tcx>],\n         num_includes_types: bool,\n         mk_cand: for<'b> |this: &mut ProbeContext<'b, 'tcx>,\n-                          tr: Rc<ty::PolyTraitRef<'tcx>>,\n+                          tr: ty::PolyTraitRef<'tcx>,\n                           m: Rc<ty::Method<'tcx>>,\n                           method_num: uint|)\n     {\n@@ -996,7 +999,7 @@ fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n // to a trait and its supertraits.\n fn get_method_index<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           trait_ref: &ty::PolyTraitRef<'tcx>,\n-                          subtrait: Rc<ty::PolyTraitRef<'tcx>>,\n+                          subtrait: ty::PolyTraitRef<'tcx>,\n                           n_method: uint) -> uint {\n     // We need to figure the \"real index\" of the method in a\n     // listing of all the methods of an object. We do this by"}, {"sha": "be8fa21cf0ee8b15e3635ba4b46c4fc5d5ce75b6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 130, "deletions": 60, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -93,10 +93,10 @@ use middle::subst::{mod, Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::traits;\n use middle::ty::{FnSig, VariantInfo, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, HasProjectionTypes, Ty};\n use middle::ty::liberate_late_bound_regions;\n use middle::ty::{MethodCall, MethodCallee, MethodMap, ObjectCastMap};\n-use middle::ty_fold::TypeFolder;\n+use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rscope::RegionScope;\n use session::Session;\n use {CrateCtxt, lookup_def_ccx, no_params, require_same_types};\n@@ -120,6 +120,7 @@ use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::visit::{mod, Visitor};\n \n+mod assoc;\n pub mod _match;\n pub mod vtable;\n pub mod writeback;\n@@ -348,6 +349,17 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n         }\n     }\n+\n+    fn normalize_associated_types_in<T>(&self, span: Span, body_id: ast::NodeId, value: &T) -> T\n+        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes\n+    {\n+        let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n+        assoc::normalize_associated_types_in(&self.infcx,\n+                                             &mut *fulfillment_cx, span,\n+                                             body_id,\n+                                             value)\n+    }\n+\n }\n \n // Used by check_const and check_enum_variants\n@@ -414,15 +426,18 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            decl: &ast::FnDecl,\n                            body: &ast::Block,\n                            id: ast::NodeId,\n-                           fty: Ty<'tcx>,\n+                           raw_fty: Ty<'tcx>,\n                            param_env: ty::ParameterEnvironment<'tcx>) {\n-    // Compute the fty from point of view of inside fn\n-    // (replace any type-scheme with a type)\n-    let fty = fty.subst(ccx.tcx, &param_env.free_substs);\n-\n-    match fty.sty {\n+    match raw_fty.sty {\n         ty::ty_bare_fn(_, ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);\n+\n+            // Compute the fty from point of view of inside fn\n+            // (replace any type-scheme with a type, and normalize\n+            // associated types appearing in the fn signature).\n+            let fn_ty = fn_ty.subst(ccx.tcx, &inh.param_env.free_substs);\n+            let fn_ty = inh.normalize_associated_types_in(body.span, body.id, &fn_ty);\n+\n             let fcx = check_fn(ccx, fn_ty.unsafety, id, &fn_ty.sig,\n                                decl, id, body, &inh);\n \n@@ -532,7 +547,8 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                       fn_id: ast::NodeId,\n                       body: &ast::Block,\n                       inherited: &'a Inherited<'a, 'tcx>)\n-                      -> FnCtxt<'a, 'tcx> {\n+                      -> FnCtxt<'a, 'tcx>\n+{\n     let tcx = ccx.tcx;\n     let err_count_on_creation = tcx.sess.err_count();\n \n@@ -771,9 +787,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 // corresponding method definition in the trait.\n                 let opt_trait_method_ty =\n                     trait_items.iter()\n-                               .find(|ti| {\n-                                   ti.name() == impl_item_ty.name()\n-                               });\n+                               .find(|ti| ti.name() == impl_item_ty.name());\n                 match opt_trait_method_ty {\n                     Some(trait_method_ty) => {\n                         match (trait_method_ty, &impl_item_ty) {\n@@ -917,6 +931,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n            impl_trait_ref.repr(tcx));\n \n     let infcx = infer::new_infer_ctxt(tcx);\n+    let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n     let trait_to_impl_substs = &impl_trait_ref.substs;\n \n@@ -1034,21 +1049,15 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // this kind of equivalency just fine.\n \n     // Create mapping from impl to skolemized.\n-    let skol_tps =\n-        impl_m.generics.types.map(\n-            |d| ty::mk_param_from_def(tcx, d));\n-    let skol_regions =\n-        impl_m.generics.regions.map(\n-            |l| ty::free_region_from_def(impl_m_body_id, l));\n-    let impl_to_skol_substs =\n-        subst::Substs::new(skol_tps.clone(), skol_regions.clone());\n+    let impl_param_env = ty::construct_parameter_environment(tcx, &impl_m.generics, impl_m_body_id);\n+    let impl_to_skol_substs = &impl_param_env.free_substs;\n \n     // Create mapping from trait to skolemized.\n     let trait_to_skol_substs =\n         trait_to_impl_substs\n-        .subst(tcx, &impl_to_skol_substs)\n-        .with_method(skol_tps.get_slice(subst::FnSpace).to_vec(),\n-                     skol_regions.get_slice(subst::FnSpace).to_vec());\n+        .subst(tcx, impl_to_skol_substs)\n+        .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n+                     impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n \n     // Check region bounds.\n     if !check_region_bounds_on_impl_method(tcx,\n@@ -1057,7 +1066,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                            &trait_m.generics,\n                                            &impl_m.generics,\n                                            &trait_to_skol_substs,\n-                                           &impl_to_skol_substs) {\n+                                           impl_to_skol_substs) {\n         return;\n     }\n \n@@ -1120,7 +1129,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         for impl_trait_bound in impl_param_bounds.trait_bounds.iter() {\n             debug!(\"compare_impl_method(): impl-trait-bound subst\");\n             let impl_trait_bound =\n-                impl_trait_bound.subst(tcx, &impl_to_skol_substs);\n+                impl_trait_bound.subst(tcx, impl_to_skol_substs);\n \n             // There may be late-bound regions from the impl in the\n             // impl's bound, so \"liberate\" those. Note that the\n@@ -1134,7 +1143,6 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     debug!(\"compare_impl_method(): trait-bound subst\");\n                     let trait_bound =\n                         trait_bound.subst(tcx, &trait_to_skol_substs);\n-                    let infcx = infer::new_infer_ctxt(tcx);\n                     infer::mk_sub_poly_trait_refs(&infcx,\n                                                   true,\n                                                   infer::Misc(impl_m_span),\n@@ -1155,9 +1163,15 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // Compute skolemized form of impl and trait method tys.\n     let impl_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(impl_m.fty.clone()));\n-    let impl_fty = impl_fty.subst(tcx, &impl_to_skol_substs);\n+    let impl_fty = impl_fty.subst(tcx, impl_to_skol_substs);\n     let trait_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(trait_m.fty.clone()));\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n+    let trait_fty =\n+        assoc::normalize_associated_types_in(&infcx,\n+                                             &mut fulfillment_cx,\n+                                             impl_m_span,\n+                                             impl_m_body_id,\n+                                             &trait_fty);\n \n     // Check the impl method type IM is a subtype of the trait method\n     // type TM. To see why this makes sense, think of a vtable. The\n@@ -1183,6 +1197,15 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n     }\n \n+    // Run the fulfillment context to completion to accommodate any\n+    // associated type normalizations that may have occurred.\n+    match fulfillment_cx.select_all_or_error(&infcx, &impl_param_env, tcx) {\n+        Ok(()) => { }\n+        Err(errors) => {\n+            traits::report_fulfillment_errors(&infcx, &errors);\n+        }\n+    }\n+\n     // Finally, resolve all regions. This catches wily misuses of lifetime\n     // parameters.\n     infcx.resolve_regions_and_report_errors(impl_m_body_id);\n@@ -1526,19 +1549,28 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         self.infcx().next_ty_var()\n     }\n \n-    fn associated_types_of_trait_are_valid(&self, _: Ty, _: ast::DefId)\n-                                           -> bool {\n-        false\n+    fn projected_ty_from_poly_trait_ref(&self,\n+                                        span: Span,\n+                                        poly_trait_ref: ty::PolyTraitRef<'tcx>,\n+                                        item_name: ast::Name)\n+                                        -> Ty<'tcx>\n+    {\n+        let (trait_ref, _) =\n+            self.infcx().replace_late_bound_regions_with_fresh_var(\n+                span,\n+                infer::LateBoundRegionConversionTime::AssocTypeProjection(item_name),\n+                &poly_trait_ref);\n+\n+        self.normalize_associated_type(span, trait_ref, item_name)\n     }\n \n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               _: Option<Ty<'tcx>>,\n-                               _: ast::DefId,\n-                               _: ast::DefId)\n-                               -> Option<Ty<'tcx>> {\n-        self.tcx().sess.span_err(span, \"unsupported associated type binding\");\n-        Some(ty::mk_err())\n+    fn projected_ty(&self,\n+                    span: Span,\n+                    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                    item_name: ast::Name)\n+                    -> Ty<'tcx>\n+    {\n+        self.normalize_associated_type(span, trait_ref, item_name)\n     }\n }\n \n@@ -1560,22 +1592,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn err_count_since_creation(&self) -> uint {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n-}\n-\n-impl<'a, 'tcx> RegionScope for infer::InferCtxt<'a, 'tcx> {\n-    fn default_region_bound(&self, span: Span) -> Option<ty::Region> {\n-        Some(self.next_region_var(infer::MiscVariable(span)))\n-    }\n \n-    fn anon_regions(&self, span: Span, count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n-        Ok(Vec::from_fn(count, |_| {\n-            self.next_region_var(infer::MiscVariable(span))\n-        }))\n-    }\n-}\n-\n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn tag(&self) -> String {\n         format!(\"{}\", self as *const FnCtxt)\n     }\n@@ -1609,7 +1626,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn write_object_cast(&self,\n                              key: ast::NodeId,\n-                             trait_ref: Rc<ty::PolyTraitRef<'tcx>>) {\n+                             trait_ref: ty::PolyTraitRef<'tcx>) {\n         debug!(\"write_object_cast key={} trait_ref={}\",\n                key, trait_ref.repr(self.tcx()));\n         self.inh.object_cast_map.borrow_mut().insert(key, trait_ref);\n@@ -1660,6 +1677,48 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.inh.adjustments.borrow_mut().insert(node_id, adj);\n     }\n \n+    /// Basically whenever we are converting from a type scheme into\n+    /// the fn body space, we always want to normalize associated\n+    /// types as well. This function combines the two.\n+    fn instantiate_type_scheme<T>(&self,\n+                                  span: Span,\n+                                  substs: &Substs<'tcx>,\n+                                  value: &T)\n+                                  -> T\n+        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr<'tcx>\n+    {\n+        let value = value.subst(self.tcx(), substs);\n+        let result = self.normalize_associated_types_in(span, &value);\n+        debug!(\"instantiate_type_scheme(value={}, substs={}) = {}\",\n+               value.repr(self.tcx()),\n+               substs.repr(self.tcx()),\n+               result.repr(self.tcx()));\n+        result\n+    }\n+\n+    fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n+        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes\n+    {\n+        self.inh.normalize_associated_types_in(span, self.body_id, value)\n+    }\n+\n+    fn normalize_associated_type(&self,\n+                                 span: Span,\n+                                 trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                                 item_name: ast::Name)\n+                                 -> Ty<'tcx>\n+    {\n+        let cause = traits::ObligationCause::new(span,\n+                                                 self.body_id,\n+                                                 traits::ObligationCauseCode::MiscObligation);\n+        self.inh.fulfillment_cx\n+            .borrow_mut()\n+            .normalize_associated_type(self.infcx(),\n+                                       trait_ref,\n+                                       item_name,\n+                                       cause)\n+    }\n+\n     fn register_adjustment_obligations(&self,\n                                        span: Span,\n                                        adj: &ty::AutoAdjustment<'tcx>) {\n@@ -1754,7 +1813,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 traits::ItemObligation(def_id)),\n             &bounds);\n         let monotype =\n-            type_scheme.ty.subst(self.tcx(), &substs);\n+            self.instantiate_type_scheme(span, &substs, &type_scheme.ty);\n \n         TypeAndSubsts {\n             ty: monotype,\n@@ -2017,7 +2076,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-#[deriving(Copy, Show,PartialEq,Eq)]\n+//impl<'a, 'tcx> RegionScope for infer::InferCtxt<'a, 'tcx> {\n+//    fn default_region_bound(&self, span: Span) -> Option<ty::Region> {\n+//        Some(self.next_region_var(infer::MiscVariable(span)))\n+//    }\n+//\n+//    fn anon_regions(&self, span: Span, count: uint)\n+//                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n+//        Ok(Vec::from_fn(count, |_| {\n+//            self.next_region_var(infer::MiscVariable(span))\n+//        }))\n+//    }\n+//}\n+\n+#[deriving(Copy, Show, PartialEq, Eq)]\n pub enum LvaluePreference {\n     PreferMutLvalue,\n     NoPreference\n@@ -2879,7 +2951,7 @@ pub fn impl_self_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let rps = fcx.inh.infcx.region_vars_for_defs(span, rps);\n     let tps = fcx.inh.infcx.next_ty_vars(n_tps);\n     let substs = subst::Substs::new_type(tps, rps);\n-    let substd_ty = raw_ty.subst(tcx, &substs);\n+    let substd_ty = fcx.instantiate_type_scheme(span, &substs, &raw_ty);\n \n     TypeAndSubsts { substs: substs, ty: substd_ty }\n }\n@@ -5219,9 +5291,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Substitute the values for the type parameters into the type of\n     // the referenced item.\n-    let ty_substituted = ty_late_bound.subst(fcx.tcx(), &substs);\n-\n-    debug!(\"ty_substituted: ty_substituted={}\", ty_substituted.repr(fcx.tcx()));\n+    let ty_substituted = fcx.instantiate_type_scheme(span, &substs, &ty_late_bound);\n \n     fcx.write_ty(node_id, ty_substituted);\n     fcx.write_substs(node_id, ty::ItemSubsts { substs: substs });"}, {"sha": "14405b9a92b59c0d199406e3120fde12a3e1a300", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -121,6 +121,15 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                 self.push_param_constraint_from_top(p);\n             }\n \n+            ty::ty_projection(ref data) => {\n+                // `<T as TraitRef<..>>::Name`\n+\n+                // TODO What region constraints are necessary here, if any??\n+\n+                // this seems like a minimal requirement:\n+                self.accumulate_from_ty(data.trait_ref.self_ty());\n+            }\n+\n             ty::ty_tup(ref tuptys) => {\n                 for &tupty in tuptys.iter() {\n                     self.accumulate_from_ty(tupty);"}, {"sha": "98badf9c049963f7a7d2b9c8af17711280b3a470", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -13,7 +13,7 @@ use middle::subst::{FnSpace};\n use middle::traits;\n use middle::traits::{Obligation, ObligationCause};\n use middle::traits::report_fulfillment_errors;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, Ty, AsPredicate, ToPolyTraitRef};\n use middle::infer;\n use std::rc::Rc;\n use syntax::ast;\n@@ -136,7 +136,7 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let object_trait_ref =\n         object_trait.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n     for tr in traits::supertraits(tcx, object_trait_ref) {\n-        check_object_safety_inner(tcx, &*tr, span);\n+        check_object_safety_inner(tcx, &tr, span);\n     }\n }\n \n@@ -231,7 +231,7 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   span: Span,\n                                                   object_trait: &ty::TyTrait<'tcx>,\n                                                   referent_ty: Ty<'tcx>)\n-                                                  -> Rc<ty::PolyTraitRef<'tcx>>\n+                                                  -> ty::PolyTraitRef<'tcx>\n {\n     // We can only make objects from sized types.\n     fcx.register_builtin_bound(\n@@ -258,7 +258,7 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             ObligationCause::new(span,\n                                  fcx.body_id,\n                                  traits::ObjectCastObligation(object_trait_ty)),\n-            ty::Predicate::Trait(object_trait_ref.clone()));\n+            object_trait_ref.as_predicate());\n     fcx.register_predicate(object_obligation);\n \n     // Create additional obligations for all the various builtin\n@@ -314,3 +314,4 @@ pub fn select_new_fcx_obligations(fcx: &FnCtxt) {\n         Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n     }\n }\n+"}, {"sha": "21c81c7be9bfac65c5706f1b852ae76be4cd0120", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -13,7 +13,6 @@ use check::{FnCtxt, Inherited, blank_fn_ctxt, vtable, regionck};\n use CrateCtxt;\n use middle::region;\n use middle::subst;\n-use middle::subst::{Subst};\n use middle::traits;\n use middle::ty::{mod, Ty};\n use middle::ty::liberate_late_bound_regions;\n@@ -148,7 +147,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                         region::CodeExtent::from_node_id(item.id),\n                                                         Some(&mut this.cache));\n             let type_scheme = ty::lookup_item_type(fcx.tcx(), local_def(item.id));\n-            let item_ty = type_scheme.ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            let item_ty = fcx.instantiate_type_scheme(item.span,\n+                                                      &fcx.inh.param_env.free_substs,\n+                                                      &type_scheme.ty);\n             bounds_checker.check_traits_in_ty(item_ty);\n         });\n     }\n@@ -168,7 +169,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // that is, with all type parameters converted from bound\n             // to free.\n             let self_ty = ty::node_id_to_type(fcx.tcx(), item.id);\n-            let self_ty = self_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            let self_ty = fcx.instantiate_type_scheme(item.span,\n+                                                      &fcx.inh.param_env.free_substs,\n+                                                      &self_ty);\n \n             bounds_checker.check_traits_in_ty(self_ty);\n \n@@ -178,7 +181,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 None => { return; }\n                 Some(t) => { t }\n             };\n-            let trait_ref = (*trait_ref).subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            let trait_ref = fcx.instantiate_type_scheme(item.span,\n+                                                        &fcx.inh.param_env.free_substs,\n+                                                        &trait_ref);\n \n             // There are special rules that apply to drop.\n             if\n@@ -209,7 +214,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // trait reference. Instead, this is done at the impl site.\n             // Arguably this is wrong and we should treat the trait-reference\n             // the same way as we treat the self-type.\n-            bounds_checker.check_trait_ref(&trait_ref);\n+            bounds_checker.check_trait_ref(&*trait_ref);\n \n             let cause =\n                 traits::ObligationCause::new(\n@@ -344,7 +349,8 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                     //\n                     // (I believe we should do the same for traits, but\n                     // that will require an RFC. -nmatsakis)\n-                    let bounds = type_scheme.generics.to_bounds(self.tcx(), substs);\n+                    let bounds = type_scheme\n+.generics.to_bounds(self.tcx(), substs);\n                     let bounds = filter_to_trait_obligations(bounds);\n                     self.fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(self.span,\n@@ -397,7 +403,9 @@ fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         .iter()\n         .map(|field| {\n             let field_ty = ty::node_id_to_type(fcx.tcx(), field.node.id);\n-            let field_ty = field_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            let field_ty = fcx.instantiate_type_scheme(field.span,\n+                                                       &fcx.inh.param_env.free_substs,\n+                                                       &field_ty);\n             AdtField { ty: field_ty, span: field.span }\n         })\n         .collect();\n@@ -416,7 +424,10 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     AdtVariant {\n                         fields: args.iter().enumerate().map(|(index, arg)| {\n                             let arg_ty = arg_tys[index];\n-                            let arg_ty = arg_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+                            let arg_ty =\n+                                fcx.instantiate_type_scheme(variant.span,\n+                                                            &fcx.inh.param_env.free_substs,\n+                                                            &arg_ty);\n                             AdtField {\n                                 ty: arg_ty,\n                                 span: arg.ty.span\n@@ -443,7 +454,8 @@ fn filter_to_trait_obligations<'tcx>(bounds: ty::GenericBounds<'tcx>)\n     let mut result = ty::GenericBounds::empty();\n     for (space, _, predicate) in bounds.predicates.iter_enumerated() {\n         match *predicate {\n-            ty::Predicate::Trait(..) => {\n+            ty::Predicate::Trait(..) |\n+            ty::Predicate::Projection(..) => {\n                 result.predicates.push(space, predicate.clone())\n             }\n             ty::Predicate::Equate(..) |"}, {"sha": "79e1efa618f536430aafc9652e39101d312751c2", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -27,6 +27,7 @@ use middle::ty::{ty_param, TypeScheme, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_open};\n use middle::ty::{ty_uint, ty_unboxed_closure, ty_uniq, ty_bare_fn};\n+use middle::ty::{ty_projection};\n use middle::ty;\n use CrateCtxt;\n use middle::infer::combine::Combine;\n@@ -64,13 +65,13 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n         }\n \n         ty_trait(ref t) => {\n-            Some(t.principal.def_id())\n+            Some(t.principal_def_id())\n         }\n \n         ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n         ty_param(..) | ty_err | ty_open(..) | ty_uniq(_) |\n-        ty_ptr(_) | ty_rptr(_, _) => {\n+        ty_ptr(_) | ty_rptr(_, _) | ty_projection(..) => {\n             None\n         }\n "}, {"sha": "79443200ddf0e10eef6f2ec00174b4155c904c19", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -54,8 +54,8 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                     ty::ty_struct(def_id, _) => {\n                         self.check_def_id(item.span, def_id);\n                     }\n-                    ty::ty_trait(box ty::TyTrait{ ref principal, ..}) => {\n-                        self.check_def_id(item.span, principal.def_id());\n+                    ty::ty_trait(ref data) => {\n+                        self.check_def_id(item.span, data.principal_def_id());\n                     }\n                     _ => {\n                         span_err!(self.tcx.sess, item.span, E0118,"}, {"sha": "35599a989c106a83e542344426e4c7f6651b1c00", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 87, "deletions": 793, "changes": 880, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -29,14 +29,8 @@ bounds for each parameter.  Type parameters themselves are represented\n as `ty_param()` instances.\n \n */\n-use self::ConvertMethodContext::*;\n-use self::CreateTypeParametersForAssociatedTypesFlag::*;\n-\n-use astconv::{AstConv, ty_of_arg, AllowEqConstraints};\n-use astconv::{ast_ty_to_ty, ast_region_to_region};\n-use astconv;\n+use astconv::{mod, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n use metadata::csearch;\n-use middle::def;\n use middle::lang_items::SizedTraitLangItem;\n use middle::region;\n use middle::resolve_lifetime;\n@@ -47,7 +41,7 @@ use middle::ty::{mod, RegionEscape, Ty, TypeScheme};\n use middle::ty_fold::{mod, TypeFolder, TypeFoldable};\n use middle::infer;\n use rscope::*;\n-use {CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n+use {CrateCtxt, no_params, write_ty_to_tcx};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux;\n use util::ppaux::{Repr,UserString};\n@@ -139,12 +133,6 @@ pub trait ToTy<'tcx> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx>;\n }\n \n-impl<'a,'tcx> ToTy<'tcx> for ImplCtxt<'a,'tcx> {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx> {\n-        ast_ty_to_ty(self, rs, ast_ty)\n-    }\n-}\n-\n impl<'a,'tcx> ToTy<'tcx> for CrateCtxt<'a,'tcx> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx> {\n         ast_ty_to_ty(self, rs, ast_ty)\n@@ -165,9 +153,6 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n                 let abi = self.tcx.map.get_foreign_abi(id.node);\n                 ty_of_foreign_item(self, &*foreign_item, abi)\n             }\n-            Some(ast_map::NodeTraitItem(trait_item)) => {\n-                ty_of_trait_item(self, &*trait_item)\n-            }\n             x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of node \\\n                                            in get_item_type_scheme(): {}\",\n@@ -186,20 +171,13 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n         self.tcx().types.err\n     }\n \n-    fn associated_types_of_trait_are_valid(&self, _: Ty<'tcx>, _: ast::DefId)\n-                                           -> bool {\n-        false\n-    }\n-\n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               _: Option<Ty<'tcx>>,\n-                               _: ast::DefId,\n-                               _: ast::DefId)\n-                               -> Option<Ty<'tcx>> {\n-        self.tcx().sess.span_err(span, \"associated types may not be \\\n-                                        referenced here\");\n-        Some(ty::mk_err())\n+    fn projected_ty(&self,\n+                    _span: Span,\n+                    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                    item_name: ast::Name)\n+                    -> Ty<'tcx>\n+    {\n+        ty::mk_projection(self.tcx, (*trait_ref).clone(), item_name)\n     }\n }\n \n@@ -228,10 +206,7 @@ pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n             ast::StructVariantKind(ref struct_def) => {\n                 let scheme = TypeScheme {\n-                    generics: ty_generics_for_type_or_impl(\n-                        ccx,\n-                        generics,\n-                        DontCreateTypeParametersForAssociatedTypes),\n+                    generics: ty_generics_for_type_or_impl(ccx, generics),\n                     ty: enum_ty\n                 };\n \n@@ -241,10 +216,7 @@ pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         };\n \n         let scheme = TypeScheme {\n-            generics: ty_generics_for_type_or_impl(\n-                          ccx,\n-                          generics,\n-                          DontCreateTypeParametersForAssociatedTypes),\n+            generics: ty_generics_for_type_or_impl(ccx, generics),\n             ty: result_ty\n         };\n \n@@ -361,7 +333,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            trait_id: ast::NodeId,\n                                            trait_generics: &ty::Generics<'tcx>,\n-                                           trait_items: &[ast::TraitItem],\n+                                           _trait_items: &[ast::TraitItem],\n                                            m_id: &ast::NodeId,\n                                            m_name: &ast::Name,\n                                            m_explicit_self: &ast::ExplicitSelf,\n@@ -374,19 +346,11 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty_generics_for_fn_or_method(\n                 ccx,\n                 m_generics,\n-                (*trait_generics).clone(),\n-                DontCreateTypeParametersForAssociatedTypes);\n+                (*trait_generics).clone());\n \n         let (fty, explicit_self_category) = {\n-            let tmcx = TraitMethodCtxt {\n-                ccx: ccx,\n-                trait_id: local_def(trait_id),\n-                trait_items: trait_items[],\n-                method_generics: &ty_generics,\n-            };\n-            let trait_self_ty = ty::mk_self_type(tmcx.tcx(),\n-                                                 local_def(trait_id));\n-            astconv::ty_of_method(&tmcx,\n+            let trait_self_ty = ty::mk_self_type(ccx.tcx, local_def(trait_id));\n+            astconv::ty_of_method(ccx,\n                                   *m_unsafety,\n                                   trait_self_ty,\n                                   m_explicit_self,\n@@ -444,36 +408,7 @@ pub fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      trait_def: &ty::TraitDef<'tcx>,\n                                      associated_type: &ast::AssociatedType)\n-                                     -> ty::Polytype<'tcx> {\n-    // Find the type parameter ID corresponding to this\n-    // associated type.\n-    let type_parameter_def = trait_def.generics\n-                                      .types\n-                                      .get_slice(subst::AssocSpace)\n-                                      .iter()\n-                                      .find(|def| {\n-        def.def_id == local_def(associated_type.ty_param.id)\n-    });\n-    let type_parameter_def = match type_parameter_def {\n-        Some(type_parameter_def) => type_parameter_def,\n-        None => {\n-            ccx.tcx().sess.span_bug(associated_type.ty_param.span,\n-                                    \"`convert_associated_type()` didn't find \\\n-                                     a type parameter ID corresponding to \\\n-                                     this type\")\n-        }\n-    };\n-    let param_type = ty::mk_param(ccx.tcx,\n-                                  type_parameter_def.space,\n-                                  type_parameter_def.index,\n-                                  local_def(associated_type.ty_param.id));\n-    ccx.tcx.tcache.borrow_mut().insert(local_def(associated_type.ty_param.id),\n-                                       Polytype {\n-                                        generics: ty::Generics::empty(),\n-                                        ty: param_type,\n-                                       });\n-    write_ty_to_tcx(ccx.tcx, associated_type.ty_param.id, param_type);\n-\n+{\n     let associated_type = Rc::new(ty::AssociatedType {\n         name: associated_type.ty_param.ident.name,\n         vis: ast::Public,\n@@ -485,32 +420,16 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n        .borrow_mut()\n        .insert(associated_type.def_id,\n                ty::TypeTraitItem(associated_type));\n-\n-    Polytype {\n-        generics: ty::Generics::empty(),\n-        ty: param_type,\n-    }\n-}\n-\n-#[deriving(Copy)]\n-enum ConvertMethodContext<'a> {\n-    /// Used when converting implementation methods.\n-    ImplConvertMethodContext,\n-    /// Used when converting method signatures. The def ID is the def ID of\n-    /// the trait we're translating.\n-    TraitConvertMethodContext(ast::DefId, &'a [ast::TraitItem]),\n }\n \n fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                 convert_method_context: ConvertMethodContext,\n                                  container: ImplOrTraitItemContainer,\n                                  mut ms: I,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n                                  rcvr_ty_generics: &ty::Generics<'tcx>,\n                                  rcvr_visibility: ast::Visibility)\n                                  where I: Iterator<&'i ast::Method> {\n-    debug!(\"convert_methods(untransformed_rcvr_ty={}, \\\n-            rcvr_ty_generics={})\",\n+    debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n            rcvr_ty_generics.repr(ccx.tcx));\n \n@@ -523,7 +442,6 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         let m_def_id = local_def(m.id);\n         let mty = Rc::new(ty_of_method(ccx,\n-                                       convert_method_context,\n                                        container,\n                                        m,\n                                        untransformed_rcvr_ty,\n@@ -552,7 +470,6 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n \n     fn ty_of_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                    convert_method_context: ConvertMethodContext,\n                               container: ImplOrTraitItemContainer,\n                               m: &ast::Method,\n                               untransformed_rcvr_ty: Ty<'tcx>,\n@@ -563,37 +480,14 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty_generics_for_fn_or_method(\n                 ccx,\n                 m.pe_generics(),\n-                (*rcvr_ty_generics).clone(),\n-                CreateTypeParametersForAssociatedTypes);\n-\n-        let (fty, explicit_self_category) = match convert_method_context {\n-            ImplConvertMethodContext => {\n-                let imcx = ImplMethodCtxt {\n-                    ccx: ccx,\n-                    method_generics: &m_ty_generics,\n-                };\n-                astconv::ty_of_method(&imcx,\n-                                      m.pe_unsafety(),\n-                                      untransformed_rcvr_ty,\n-                                      m.pe_explicit_self(),\n-                                      &*m.pe_fn_decl(),\n-                                      m.pe_abi())\n-            }\n-            TraitConvertMethodContext(trait_id, trait_items) => {\n-                let tmcx = TraitMethodCtxt {\n-                    ccx: ccx,\n-                    trait_id: trait_id,\n-                    trait_items: trait_items,\n-                    method_generics: &m_ty_generics,\n-                };\n-                astconv::ty_of_method(&tmcx,\n-                                      m.pe_unsafety(),\n-                                      untransformed_rcvr_ty,\n-                                      m.pe_explicit_self(),\n-                                      &*m.pe_fn_decl(),\n-                                      m.pe_abi())\n-            }\n-        };\n+                (*rcvr_ty_generics).clone());\n+\n+        let (fty, explicit_self_category) = astconv::ty_of_method(ccx,\n+                                                                  m.pe_unsafety(),\n+                                                                  untransformed_rcvr_ty,\n+                                                                  m.pe_explicit_self(),\n+                                                                  &*m.pe_fn_decl(),\n+                                                                  m.pe_abi());\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n@@ -641,392 +535,6 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n     }\n }\n \n-fn is_associated_type_valid_for_param(ty: Ty,\n-                                      trait_id: ast::DefId,\n-                                      generics: &ty::Generics)\n-                                      -> bool {\n-    if let ty::ty_param(param_ty) = ty.sty {\n-        let type_parameter = generics.types.get(param_ty.space, param_ty.idx as uint);\n-        for trait_bound in type_parameter.bounds.trait_bounds.iter() {\n-            if trait_bound.def_id() == trait_id {\n-                return true\n-            }\n-        }\n-    }\n-\n-    false\n-}\n-\n-fn find_associated_type_in_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                          span: Span,\n-                                          self_ty: Option<Ty<'tcx>>,\n-                                          associated_type_id: ast::DefId,\n-                                          generics: &ty::Generics<'tcx>)\n-                                          -> Option<Ty<'tcx>>\n-{\n-    debug!(\"find_associated_type_in_generics(ty={}, associated_type_id={}, generics={}\",\n-           self_ty.repr(tcx), associated_type_id.repr(tcx), generics.repr(tcx));\n-\n-    let self_ty = match self_ty {\n-        None => {\n-            return None;\n-        }\n-        Some(ty) => ty,\n-    };\n-\n-    match self_ty.sty {\n-        ty::ty_param(ref param_ty) => {\n-            let param_id = param_ty.def_id;\n-            for type_parameter in generics.types.iter() {\n-                if type_parameter.def_id == associated_type_id\n-                    && type_parameter.associated_with == Some(param_id) {\n-                    return Some(ty::mk_param_from_def(tcx, type_parameter));\n-                }\n-            }\n-\n-            tcx.sess.span_err(\n-                span,\n-                format!(\"no suitable bound on `{}`\",\n-                        self_ty.user_string(tcx))[]);\n-            Some(ty::mk_err())\n-        }\n-        _ => {\n-            tcx.sess.span_err(\n-                span,\n-                \"it is currently unsupported to access associated types except \\\n-                 through a type parameter; this restriction will be lifted in time\");\n-            Some(ty::mk_err())\n-        }\n-    }\n-}\n-\n-fn type_is_self(ty: Ty) -> bool {\n-    match ty.sty {\n-        ty::ty_param(ref param_ty) if param_ty.is_self() => true,\n-        _ => false,\n-    }\n-}\n-\n-struct ImplCtxt<'a,'tcx:'a> {\n-    ccx: &'a CrateCtxt<'a,'tcx>,\n-    opt_trait_ref_id: Option<ast::DefId>,\n-    impl_items: &'a [ast::ImplItem],\n-    impl_generics: &'a ty::Generics<'tcx>,\n-}\n-\n-impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.ccx.tcx\n-    }\n-\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n-        self.ccx.get_item_ty(id)\n-    }\n-\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        self.ccx.get_trait_def(id)\n-    }\n-\n-    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.ccx.ty_infer(span)\n-    }\n-\n-    fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty<'tcx>,\n-                                           trait_id: ast::DefId)\n-                                           -> bool {\n-        // OK if the trait with the associated type is the trait we're\n-        // implementing.\n-        match self.opt_trait_ref_id {\n-            Some(trait_ref_id) if trait_ref_id == trait_id => {\n-                if type_is_self(ty) {\n-                    return true\n-                }\n-            }\n-            Some(_) | None => {}\n-        }\n-\n-        // OK if the trait with the associated type is one of the traits in\n-        // our bounds.\n-        is_associated_type_valid_for_param(ty, trait_id, self.impl_generics)\n-    }\n-\n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               self_ty: Option<Ty<'tcx>>,\n-                               trait_id: ast::DefId,\n-                               associated_type_id: ast::DefId)\n-                               -> Option<Ty<'tcx>>\n-    {\n-        match self.opt_trait_ref_id {\n-            // It's an associated type on the trait that we're\n-            // implementing.\n-            Some(trait_ref_id) if trait_ref_id == trait_id => {\n-                let trait_def = ty::lookup_trait_def(self.tcx(), trait_id);\n-                assert!(trait_def.generics.types\n-                        .get_slice(subst::AssocSpace)\n-                        .iter()\n-                        .any(|type_param_def| type_param_def.def_id == associated_type_id));\n-                let associated_type = ty::impl_or_trait_item(self.ccx.tcx, associated_type_id);\n-                for impl_item in self.impl_items.iter() {\n-                    match *impl_item {\n-                        ast::MethodImplItem(_) => {}\n-                        ast::TypeImplItem(ref typedef) => {\n-                            if associated_type.name() == typedef.ident.name {\n-                                return Some(self.ccx.to_ty(&ExplicitRscope, &*typedef.typ))\n-                            }\n-                        }\n-                    }\n-                }\n-                self.ccx\n-                    .tcx\n-                    .sess\n-                    .span_bug(span,\n-                              \"ImplCtxt::associated_type_binding(): didn't \\\n-                               find associated type\")\n-            }\n-            Some(_) | None => {}\n-        }\n-\n-        // OK then, it should be an associated type on one of the traits in\n-        // our bounds.\n-        find_associated_type_in_generics(self.ccx.tcx,\n-                                         span,\n-                                         self_ty,\n-                                         associated_type_id,\n-                                         self.impl_generics)\n-    }\n-}\n-\n-struct FnCtxt<'a,'tcx:'a> {\n-    ccx: &'a CrateCtxt<'a,'tcx>,\n-    generics: &'a ty::Generics<'tcx>,\n-}\n-\n-impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.ccx.tcx\n-    }\n-\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n-        self.ccx.get_item_ty(id)\n-    }\n-\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        self.ccx.get_trait_def(id)\n-    }\n-\n-    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.ccx.ty_infer(span)\n-    }\n-\n-    fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty<'tcx>,\n-                                           trait_id: ast::DefId)\n-                                           -> bool {\n-        // OK if the trait with the associated type is one of the traits in\n-        // our bounds.\n-        is_associated_type_valid_for_param(ty, trait_id, self.generics)\n-    }\n-\n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               self_ty: Option<Ty<'tcx>>,\n-                               _: ast::DefId,\n-                               associated_type_id: ast::DefId)\n-                               -> Option<Ty<'tcx>> {\n-        debug!(\"collect::FnCtxt::associated_type_binding()\");\n-\n-        // The ID should map to an associated type on one of the traits in\n-        // our bounds.\n-        find_associated_type_in_generics(self.ccx.tcx,\n-                                         span,\n-                                         self_ty,\n-                                         associated_type_id,\n-                                         self.generics)\n-    }\n-}\n-\n-struct ImplMethodCtxt<'a,'tcx:'a> {\n-    ccx: &'a CrateCtxt<'a,'tcx>,\n-    method_generics: &'a ty::Generics<'tcx>,\n-}\n-\n-impl<'a,'tcx> AstConv<'tcx> for ImplMethodCtxt<'a,'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.ccx.tcx\n-    }\n-\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n-        self.ccx.get_item_ty(id)\n-    }\n-\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        self.ccx.get_trait_def(id)\n-    }\n-\n-    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.ccx.ty_infer(span)\n-    }\n-\n-    fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty<'tcx>,\n-                                           trait_id: ast::DefId)\n-                                           -> bool {\n-        is_associated_type_valid_for_param(ty, trait_id, self.method_generics)\n-    }\n-\n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               self_ty: Option<Ty<'tcx>>,\n-                               _: ast::DefId,\n-                               associated_type_id: ast::DefId)\n-                               -> Option<Ty<'tcx>> {\n-        debug!(\"collect::ImplMethodCtxt::associated_type_binding()\");\n-\n-        // The ID should map to an associated type on one of the traits in\n-        // our bounds.\n-        find_associated_type_in_generics(self.ccx.tcx,\n-                                         span,\n-                                         self_ty,\n-                                         associated_type_id,\n-                                         self.method_generics)\n-    }\n-}\n-\n-struct TraitMethodCtxt<'a,'tcx:'a> {\n-    ccx: &'a CrateCtxt<'a,'tcx>,\n-    trait_id: ast::DefId,\n-    trait_items: &'a [ast::TraitItem],\n-    method_generics: &'a ty::Generics<'tcx>,\n-}\n-\n-impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.ccx.tcx\n-    }\n-\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n-        self.ccx.get_item_ty(id)\n-    }\n-\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        self.ccx.get_trait_def(id)\n-    }\n-\n-    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.ccx.ty_infer(span)\n-    }\n-\n-    fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty<'tcx>,\n-                                           trait_id: ast::DefId)\n-                                           -> bool {\n-        // OK if the trait with the associated type is this trait.\n-        if self.trait_id == trait_id && type_is_self(ty) {\n-            return true\n-        }\n-\n-        // OK if the trait with the associated type is one of the traits in\n-        // our bounds.\n-        is_associated_type_valid_for_param(ty, trait_id, self.method_generics)\n-    }\n-\n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               self_ty: Option<Ty<'tcx>>,\n-                               trait_id: ast::DefId,\n-                               associated_type_id: ast::DefId)\n-                               -> Option<Ty<'tcx>> {\n-        debug!(\"collect::TraitMethodCtxt::associated_type_binding()\");\n-\n-        // If this is one of our own associated types, return it.\n-        if trait_id == self.trait_id {\n-            let mut index = 0;\n-            for item in self.trait_items.iter() {\n-                match *item {\n-                    ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n-                    ast::TypeTraitItem(ref item) => {\n-                        if local_def(item.ty_param.id) == associated_type_id {\n-                            return Some(ty::mk_param(self.tcx(),\n-                                                     subst::AssocSpace,\n-                                                     index,\n-                                                     associated_type_id))\n-                        }\n-                        index += 1;\n-                    }\n-                }\n-            }\n-            self.ccx\n-                .tcx\n-                .sess\n-                .span_bug(span,\n-                          \"TraitMethodCtxt::associated_type_binding(): \\\n-                           didn't find associated type anywhere in the item \\\n-                           list\")\n-        }\n-\n-        // The ID should map to an associated type on one of the traits in\n-        // our bounds.\n-        find_associated_type_in_generics(self.ccx.tcx,\n-                                         span,\n-                                         self_ty,\n-                                         associated_type_id,\n-                                         self.method_generics)\n-    }\n-}\n-\n-struct GenericsCtxt<'a,'tcx:'a,AC:'a> {\n-    chain: &'a AC,\n-    associated_types_generics: &'a ty::Generics<'tcx>,\n-}\n-\n-impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,'tcx,AC> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.chain.tcx()\n-    }\n-\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n-        self.chain.get_item_ty(id)\n-    }\n-\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        self.chain.get_trait_def(id)\n-    }\n-\n-    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.chain.ty_infer(span)\n-    }\n-\n-    fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty<'tcx>,\n-                                           trait_id: ast::DefId)\n-                                           -> bool {\n-        // OK if the trait with the associated type is one of the traits in\n-        // our bounds.\n-        is_associated_type_valid_for_param(ty,\n-                                           trait_id,\n-                                           self.associated_types_generics)\n-    }\n-\n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               self_ty: Option<Ty<'tcx>>,\n-                               _: ast::DefId,\n-                               associated_type_id: ast::DefId)\n-                               -> Option<Ty<'tcx>> {\n-        debug!(\"collect::GenericsCtxt::associated_type_binding()\");\n-\n-        // The ID should map to an associated type on one of the traits in\n-        // our bounds.\n-        find_associated_type_in_generics(self.chain.tcx(),\n-                                         span,\n-                                         self_ty,\n-                                         associated_type_id,\n-                                         self.associated_types_generics)\n-    }\n-}\n-\n pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", token::get_ident(it.ident), it.id);\n@@ -1047,10 +555,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                       ref selfty,\n                       ref impl_items) => {\n             // Create generics from the generics specified in the impl head.\n-            let ty_generics = ty_generics_for_type_or_impl(\n-                    ccx,\n-                    generics,\n-                    CreateTypeParametersForAssociatedTypes);\n+            let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n \n             let selfty = ccx.to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n@@ -1074,20 +579,6 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                 it.vis\n             };\n \n-            let icx = ImplCtxt {\n-                ccx: ccx,\n-                opt_trait_ref_id: match *opt_trait_ref {\n-                    None => None,\n-                    Some(ref ast_trait_ref) => {\n-                        Some(lookup_def_tcx(tcx,\n-                                            ast_trait_ref.path.span,\n-                                            ast_trait_ref.ref_id).def_id())\n-                    }\n-                },\n-                impl_items: impl_items[],\n-                impl_generics: &ty_generics,\n-            };\n-\n             let mut methods = Vec::new();\n             for impl_item in impl_items.iter() {\n                 match *impl_item {\n@@ -1101,7 +592,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                         methods.push(&**method);\n                     }\n                     ast::TypeImplItem(ref typedef) => {\n-                        let typ = icx.to_ty(&ExplicitRscope, &*typedef.typ);\n+                        let typ = ccx.to_ty(&ExplicitRscope, &*typedef.typ);\n                         tcx.tcache\n                            .borrow_mut()\n                            .insert(local_def(typedef.id),\n@@ -1126,19 +617,18 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             }\n \n             convert_methods(ccx,\n-                            ImplConvertMethodContext,\n                             ImplContainer(local_def(it.id)),\n                             methods.into_iter(),\n                             selfty,\n                             &ty_generics,\n                             parent_visibility);\n \n             for trait_ref in opt_trait_ref.iter() {\n-                astconv::instantiate_trait_ref(&icx,\n+                astconv::instantiate_trait_ref(ccx,\n                                                &ExplicitRscope,\n                                                trait_ref,\n                                                Some(selfty),\n-                                               AllowEqConstraints::DontAllow);\n+                                               None);\n             }\n         },\n         ast::ItemTrait(_, _, _, ref trait_methods) => {\n@@ -1180,11 +670,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             // Run convert_methods on the provided methods.\n             let untransformed_rcvr_ty = ty::mk_self_type(tcx,\n                                                          local_def(it.id));\n-            let convert_method_context =\n-                TraitConvertMethodContext(local_def(it.id),\n-                                          trait_methods[]);\n             convert_methods(ccx,\n-                            convert_method_context,\n                             TraitContainer(local_def(it.id)),\n                             trait_methods.iter().filter_map(|m| match *m {\n                                 ast::RequiredMethod(_) => None,\n@@ -1326,7 +812,8 @@ fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    it: &ast::Item)\n-                                   -> Rc<ty::TraitDef<'tcx>> {\n+                                   -> Rc<ty::TraitDef<'tcx>>\n+{\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     if let Some(def) = tcx.trait_defs.borrow().get(&def_id) {\n@@ -1347,7 +834,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     };\n \n-    let substs = ccx.tcx.mk_substs(mk_trait_substs(ccx, it.id, generics, items));\n+    let substs = ccx.tcx.mk_substs(mk_trait_substs(ccx, it.id, generics));\n \n     let ty_generics = ty_generics_for_trait(ccx,\n                                             it.id,\n@@ -1363,24 +850,35 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 bounds.as_slice(),\n                                 it.span);\n \n-    let substs = mk_item_substs(ccx, &ty_generics);\n+    let substs = ccx.tcx.mk_substs(mk_item_substs(ccx, &ty_generics));\n+\n+    let associated_type_names: Vec<_> =\n+        items.iter()\n+             .filter_map(|item| {\n+                 match *item {\n+                     ast::RequiredMethod(_) | ast::ProvidedMethod(_) => None,\n+                     ast::TypeTraitItem(ref data) => Some(data.ty_param.ident.name),\n+                 }\n+             })\n+            .collect();\n+\n     let trait_def = Rc::new(ty::TraitDef {\n         unsafety: unsafety,\n         generics: ty_generics,\n         bounds: bounds,\n         trait_ref: Rc::new(ty::TraitRef {\n             def_id: def_id,\n-            substs: ccx.tcx.mk_substs(substs)\n-        })\n+            substs: substs\n+        }),\n+        associated_type_names: associated_type_names,\n     });\n     tcx.trait_defs.borrow_mut().insert(def_id, trait_def.clone());\n \n     return trait_def;\n \n     fn mk_trait_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  trait_id: ast::NodeId,\n-                                 generics: &ast::Generics,\n-                                 items: &[ast::TraitItem])\n+                                 generics: &ast::Generics)\n                                  -> subst::Substs<'tcx>\n     {\n         // Creates a no-op substitution for the trait's type parameters.\n@@ -1403,28 +901,11 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  i as u32, local_def(def.id)))\n                     .collect();\n \n-        // ...and also create generics synthesized from the associated types.\n-        let mut index = 0;\n-        let assoc_types: Vec<_> =\n-            items.iter()\n-            .flat_map(|item| match *item {\n-                ast::TypeTraitItem(ref trait_item) => {\n-                    index += 1;\n-                    Some(ty::mk_param(ccx.tcx,\n-                                      subst::AssocSpace,\n-                                      index - 1,\n-                                      local_def(trait_item.ty_param.id))).into_iter()\n-                }\n-                ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {\n-                    None.into_iter()\n-                }\n-            })\n-            .collect();\n-\n+        // ...and also create the `Self` parameter.\n         let self_ty =\n             ty::mk_param(ccx.tcx, subst::SelfSpace, 0, local_def(trait_id));\n \n-        subst::Substs::new_trait(types, regions, assoc_types, self_ty)\n+        subst::Substs::new_trait(types, regions, Vec::new(), self_ty)\n     }\n }\n \n@@ -1444,18 +925,10 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n             return scheme;\n         }\n         ast::ItemFn(ref decl, unsafety, abi, ref generics, _) => {\n-            let ty_generics = ty_generics_for_fn_or_method(\n-                ccx,\n-                generics,\n-                ty::Generics::empty(),\n-                CreateTypeParametersForAssociatedTypes);\n-            let tofd = {\n-                let fcx = FnCtxt {\n-                    ccx: ccx,\n-                    generics: &ty_generics,\n-                };\n-                astconv::ty_of_bare_fn(&fcx, unsafety, abi, &**decl)\n-            };\n+            let ty_generics = ty_generics_for_fn_or_method(ccx,\n+                                                           generics,\n+                                                           ty::Generics::empty());\n+            let tofd = astconv::ty_of_bare_fn(ccx, unsafety, abi, &**decl);\n             let scheme = TypeScheme {\n                 generics: ty_generics,\n                 ty: ty::mk_bare_fn(ccx.tcx, Some(local_def(it.id)), ccx.tcx.mk_bare_fn(tofd))\n@@ -1477,10 +950,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n             let scheme = {\n                 let ty = ccx.to_ty(&ExplicitRscope, &**t);\n                 TypeScheme {\n-                    generics: ty_generics_for_type_or_impl(\n-                                  ccx,\n-                                  generics,\n-                                  DontCreateTypeParametersForAssociatedTypes),\n+                    generics: ty_generics_for_type_or_impl(ccx, generics),\n                     ty: ty\n                 }\n             };\n@@ -1490,10 +960,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n         }\n         ast::ItemEnum(_, ref generics) => {\n             // Create a new generic polytype.\n-            let ty_generics = ty_generics_for_type_or_impl(\n-                ccx,\n-                generics,\n-                DontCreateTypeParametersForAssociatedTypes);\n+            let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_enum(tcx, local_def(it.id), tcx.mk_substs(substs));\n             let scheme = TypeScheme {\n@@ -1508,10 +975,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n             tcx.sess.span_bug(it.span, \"invoked ty_of_item on trait\");\n         }\n         ast::ItemStruct(_, ref generics) => {\n-            let ty_generics = ty_generics_for_type_or_impl(\n-                ccx,\n-                generics,\n-                DontCreateTypeParametersForAssociatedTypes);\n+            let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_struct(tcx, local_def(it.id), tcx.mk_substs(substs));\n             let scheme = TypeScheme {\n@@ -1548,52 +1012,22 @@ pub fn ty_of_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn ty_of_trait_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                              trait_item: &ast::TraitItem)\n-                              -> ty::Polytype<'tcx> {\n-    match *trait_item {\n-        ast::RequiredMethod(ref m) => {\n-            ccx.tcx.sess.span_bug(m.span,\n-                                  \"ty_of_trait_item() on required method\")\n-        }\n-        ast::ProvidedMethod(ref m) => {\n-            ccx.tcx.sess.span_bug(m.span,\n-                                  \"ty_of_trait_item() on provided method\")\n-        }\n-        ast::TypeTraitItem(ref associated_type) => {\n-            let parent = ccx.tcx.map.get_parent(associated_type.ty_param.id);\n-            let trait_def = match ccx.tcx.map.get(parent) {\n-                ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n-                _ => {\n-                    ccx.tcx.sess.span_bug(associated_type.ty_param.span,\n-                                          \"associated type's parent wasn't \\\n-                                           an item?!\")\n-                }\n-            };\n-            convert_associated_type(ccx, &*trait_def, &**associated_type)\n-        }\n-    }\n-}\n-\n fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                          generics: &ast::Generics,\n-                                          create_type_parameters_for_associated_types:\n-                                          CreateTypeParametersForAssociatedTypesFlag)\n+                                          generics: &ast::Generics)\n                                           -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n                 generics.lifetimes[],\n                 generics.ty_params[],\n                 ty::Generics::empty(),\n-                &generics.where_clause,\n-                create_type_parameters_for_associated_types)\n+                &generics.where_clause)\n }\n \n fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n                                    substs: &'tcx subst::Substs<'tcx>,\n                                    ast_generics: &ast::Generics,\n-                                   items: &[ast::TraitItem])\n+                                   _items: &[ast::TraitItem])\n                                    -> ty::Generics<'tcx>\n {\n     let mut generics =\n@@ -1602,27 +1036,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     ast_generics.lifetimes[],\n                     ast_generics.ty_params[],\n                     ty::Generics::empty(),\n-                    &ast_generics.where_clause,\n-                    DontCreateTypeParametersForAssociatedTypes);\n-\n-    // Add in type parameters for any associated types.\n-    for item in items.iter() {\n-        match *item {\n-            ast::TypeTraitItem(ref associated_type) => {\n-                let def =\n-                    get_or_create_type_parameter_def(\n-                        ccx,\n-                        subst::AssocSpace,\n-                        &associated_type.ty_param,\n-                        generics.types.len(subst::AssocSpace) as u32,\n-                        Some(local_def(trait_id)));\n-                ccx.tcx.ty_param_defs.borrow_mut().insert(associated_type.ty_param.id,\n-                                                          def.clone());\n-                generics.types.push(subst::AssocSpace, def);\n-            }\n-            ast::ProvidedMethod(_) | ast::RequiredMethod(_) => {}\n-        }\n-    }\n+                    &ast_generics.where_clause);\n \n     // Add in the self type parameter.\n     //\n@@ -1631,7 +1045,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let param_id = trait_id;\n \n     let self_trait_ref =\n-        Rc::new(ty::Binder(ty::TraitRef { def_id: local_def(trait_id),\n+        ty::Binder(Rc::new(ty::TraitRef { def_id: local_def(trait_id),\n                                           substs: substs }));\n \n     let def = ty::TypeParameterDef {\n@@ -1643,27 +1057,24 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             region_bounds: vec!(),\n             builtin_bounds: ty::empty_builtin_bounds(),\n             trait_bounds: vec!(self_trait_ref.clone()),\n+            projection_bounds: vec!(),\n         },\n-        associated_with: None,\n         default: None\n     };\n \n     ccx.tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n \n     generics.types.push(subst::SelfSpace, def);\n \n-    generics.predicates.push(subst::SelfSpace,\n-                             ty::Predicate::Trait(self_trait_ref));\n+    generics.predicates.push(subst::SelfSpace, self_trait_ref.as_predicate());\n \n     generics\n }\n \n fn ty_generics_for_fn_or_method<'tcx,AC>(\n         this: &AC,\n         generics: &ast::Generics,\n-        base_generics: ty::Generics<'tcx>,\n-        create_type_parameters_for_associated_types:\n-        CreateTypeParametersForAssociatedTypesFlag)\n+        base_generics: ty::Generics<'tcx>)\n         -> ty::Generics<'tcx>\n         where AC: AstConv<'tcx> {\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n@@ -1672,8 +1083,7 @@ fn ty_generics_for_fn_or_method<'tcx,AC>(\n                 early_lifetimes[],\n                 generics.ty_params[],\n                 base_generics,\n-                &generics.where_clause,\n-                create_type_parameters_for_associated_types)\n+                &generics.where_clause)\n }\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n@@ -1722,20 +1132,12 @@ fn add_unsized_bound<'tcx,AC>(this: &AC,\n     }\n }\n \n-#[deriving(Clone, PartialEq, Eq)]\n-enum CreateTypeParametersForAssociatedTypesFlag {\n-    DontCreateTypeParametersForAssociatedTypes,\n-    CreateTypeParametersForAssociatedTypes,\n-}\n-\n fn ty_generics<'tcx,AC>(this: &AC,\n                         space: subst::ParamSpace,\n                         lifetime_defs: &[ast::LifetimeDef],\n                         types: &[ast::TyParam],\n                         base_generics: ty::Generics<'tcx>,\n-                        where_clause: &ast::WhereClause,\n-                        create_type_parameters_for_associated_types_flag:\n-                        CreateTypeParametersForAssociatedTypesFlag)\n+                        where_clause: &ast::WhereClause)\n                         -> ty::Generics<'tcx>\n                         where AC: AstConv<'tcx>\n {\n@@ -1756,46 +1158,18 @@ fn ty_generics<'tcx,AC>(this: &AC,\n \n     assert!(result.types.is_empty_in(space));\n \n-    // First, create the virtual type parameters for associated types if\n-    // necessary.\n-    let mut associated_types_generics = ty::Generics::empty();\n-    match create_type_parameters_for_associated_types_flag {\n-        DontCreateTypeParametersForAssociatedTypes => {}\n-        CreateTypeParametersForAssociatedTypes => {\n-            create_type_parameters_for_associated_types(this, space, types,\n-                                                        &mut associated_types_generics);\n-        }\n-    }\n-\n     // Now create the real type parameters.\n-    let gcx = GenericsCtxt {\n-        chain: this,\n-        associated_types_generics: &associated_types_generics,\n-    };\n     for (i, param) in types.iter().enumerate() {\n-        let def = get_or_create_type_parameter_def(&gcx,\n+        let def = get_or_create_type_parameter_def(this,\n                                                    space,\n                                                    param,\n-                                                   i as u32,\n-                                                   None);\n+                                                   i as u32);\n         debug!(\"ty_generics: def for type param: {}, {}\",\n                def.repr(this.tcx()),\n                space);\n         result.types.push(space, def);\n     }\n \n-    // Append the associated types to the result.\n-    for associated_type_param in associated_types_generics.types\n-                                                          .get_slice(space)\n-                                                          .iter() {\n-        assert!(result.types.get_slice(space).len() ==\n-                associated_type_param.index as uint);\n-        debug!(\"ty_generics: def for associated type: {}, {}\",\n-               associated_type_param.repr(this.tcx()),\n-               space);\n-        result.types.push(space, (*associated_type_param).clone());\n-    }\n-\n     // Just for fun, also push the bounds from the type parameters\n     // into the predicates list. This is currently kind of non-DRY.\n     create_predicates(this.tcx(), &mut result, space);\n@@ -1809,16 +1183,21 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                 for bound in bound_pred.bounds.iter() {\n                     match bound {\n                         &ast::TyParamBound::TraitTyParamBound(ref poly_trait_ref, _) => {\n+                            let mut projections = Vec::new();\n+\n                             let trait_ref = astconv::instantiate_poly_trait_ref(\n                                 this,\n                                 &ExplicitRscope,\n-                                //@jroesch: for now trait_ref, poly_trait_ref?\n                                 poly_trait_ref,\n                                 Some(ty),\n-                                AllowEqConstraints::Allow\n+                                &mut projections,\n                             );\n \n-                            result.predicates.push(space, ty::Predicate::Trait(trait_ref));\n+                            result.predicates.push(space, trait_ref.as_predicate());\n+\n+                            for projection in projections.iter() {\n+                                result.predicates.push(space, projection.as_predicate());\n+                            }\n                         }\n \n                         &ast::TyParamBound::RegionTyParamBound(ref lifetime) => {\n@@ -1850,91 +1229,6 @@ fn ty_generics<'tcx,AC>(this: &AC,\n \n     return result;\n \n-    fn create_type_parameters_for_associated_types<'tcx, AC>(\n-        this: &AC,\n-        space: subst::ParamSpace,\n-        types: &[ast::TyParam],\n-        associated_types_generics: &mut ty::Generics<'tcx>)\n-        where AC: AstConv<'tcx>\n-    {\n-        // The idea here is roughly as follows. We start with\n-        // an item that is paramerized by various type parameters\n-        // with bounds:\n-        //\n-        //    fn foo<T:Iterator>(t: T) { ... }\n-        //\n-        // The traits in those bounds declare associated types:\n-        //\n-        //    trait Iterator { type Elem; ... }\n-        //\n-        // And we rewrite the original function so that every associated\n-        // type is bound to some fresh type parameter:\n-        //\n-        //    fn foo<A,T:Iterator<Elem=A>>(t: T) { ... }\n-\n-        // Number of synthetic type parameters created thus far\n-        let mut index = 0;\n-\n-        // Iterate over the each type parameter `T` (from the example)\n-        for param in types.iter() {\n-            // Iterate over the bound `Iterator`\n-            for bound in param.bounds.iter() {\n-                // In the above example, `ast_trait_ref` is `Iterator`.\n-                let ast_trait_ref = match *bound {\n-                    ast::TraitTyParamBound(ref r, _) => r,\n-                    ast::RegionTyParamBound(..) => { continue; }\n-                };\n-\n-                let trait_def_id =\n-                    match lookup_def_tcx(this.tcx(),\n-                                         ast_trait_ref.trait_ref.path.span,\n-                                         ast_trait_ref.trait_ref.ref_id) {\n-                        def::DefTrait(trait_def_id) => trait_def_id,\n-                        _ => {\n-                            this.tcx().sess.span_bug(ast_trait_ref.trait_ref.path.span,\n-                                                     \"not a trait?!\")\n-                        }\n-                    };\n-\n-                // trait_def_id is def-id of `Iterator`\n-                let trait_def = ty::lookup_trait_def(this.tcx(), trait_def_id);\n-                let associated_type_defs = trait_def.generics.types.get_slice(subst::AssocSpace);\n-\n-                // Find any associated type bindings in the bound.\n-                let ref segments = ast_trait_ref.trait_ref.path.segments;\n-                let bindings = segments[segments.len() -1].parameters.bindings();\n-\n-                // Iterate over each associated type `Elem`\n-                for associated_type_def in associated_type_defs.iter() {\n-                    if bindings.iter().any(|b| associated_type_def.name.ident() == b.ident) {\n-                        // Don't add a variable for a bound associated type.\n-                        continue;\n-                    }\n-\n-                    // Create the fresh type parameter `A`\n-                    let def = ty::TypeParameterDef {\n-                        name: associated_type_def.name,\n-                        def_id: associated_type_def.def_id,\n-                        space: space,\n-                        index: types.len() as u32 + index,\n-                        bounds: ty::ParamBounds {\n-                            builtin_bounds: associated_type_def.bounds.builtin_bounds,\n-\n-                            // FIXME(#18178) -- we should add the other bounds, but\n-                            // that requires subst and more logic\n-                            trait_bounds: Vec::new(),\n-                            region_bounds: Vec::new(),\n-                        },\n-                        associated_with: Some(local_def(param.id)),\n-                        default: None,\n-                    };\n-                    associated_types_generics.types.push(space, def);\n-                    index += 1;\n-                }\n-            }\n-        }\n-    }\n-\n     fn create_predicates<'tcx>(\n         tcx: &ty::ctxt<'tcx>,\n         result: &mut ty::Generics<'tcx>,\n@@ -1964,8 +1258,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n                                              space: subst::ParamSpace,\n                                              param: &ast::TyParam,\n-                                             index: u32,\n-                                             associated_with: Option<ast::DefId>)\n+                                             index: u32)\n                                              -> ty::TypeParameterDef<'tcx>\n     where AC: AstConv<'tcx>\n {\n@@ -2006,7 +1299,6 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n         index: index,\n         name: param.ident.name,\n         def_id: local_def(param.id),\n-        associated_with: associated_with,\n         bounds: bounds,\n         default: default\n     };\n@@ -2081,14 +1373,17 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n                                      trait_bounds,\n                                      region_bounds } =\n         astconv::partition_bounds(this.tcx(), span, ast_bounds.as_slice());\n-    let trait_bounds: Vec<Rc<ty::PolyTraitRef>> =\n+\n+    let mut projection_bounds = Vec::new();\n+\n+    let trait_bounds: Vec<ty::PolyTraitRef> =\n         trait_bounds.into_iter()\n         .map(|bound| {\n             astconv::instantiate_poly_trait_ref(this,\n                                                 &ExplicitRscope,\n                                                 bound,\n                                                 Some(param_ty.to_ty(this.tcx())),\n-                                                AllowEqConstraints::Allow)\n+                                                &mut projection_bounds)\n         })\n         .collect();\n     let region_bounds: Vec<ty::Region> =\n@@ -2099,6 +1394,7 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n         region_bounds: region_bounds,\n         builtin_bounds: builtin_bounds,\n         trait_bounds: trait_bounds,\n+        projection_bounds: projection_bounds,\n     }\n }\n \n@@ -2119,11 +1415,9 @@ pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     }\n \n-    let ty_generics_for_fn_or_method = ty_generics_for_fn_or_method(\n-            ccx,\n-            ast_generics,\n-            ty::Generics::empty(),\n-            DontCreateTypeParametersForAssociatedTypes);\n+    let ty_generics_for_fn_or_method = ty_generics_for_fn_or_method(ccx,\n+                                                                    ast_generics,\n+                                                                    ty::Generics::empty());\n     let rb = BindingRscope::new();\n     let input_tys = decl.inputs\n                         .iter()"}, {"sha": "c3a3993b66b76eeb04b925d8c1ee267ed77a060b", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -770,33 +770,38 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     variance);\n             }\n \n-            ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n-                let trait_def = ty::lookup_trait_def(self.tcx(), principal.def_id());\n+            ty::ty_projection(ref data) => {\n+                let trait_ref = &data.trait_ref;\n+                let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id);\n                 let generics = &trait_def.generics;\n+                self.add_constraints_from_substs(\n+                    trait_ref.def_id,\n+                    generics.types.as_slice(),\n+                    generics.regions.as_slice(),\n+                    &trait_ref.substs,\n+                    variance);\n+            }\n \n-                // Traits DO have a Self type parameter, but it is\n-                // erased from object types.\n-                assert!(!generics.types.is_empty_in(subst::SelfSpace) &&\n-                        principal.substs().types.is_empty_in(subst::SelfSpace));\n+            ty::ty_trait(ref data) => {\n+                let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx().types.err);\n+                let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id());\n+                let generics = &trait_def.generics;\n \n                 // Traits never declare region parameters in the self\n-                // space.\n+                // space nor anything in the fn space.\n                 assert!(generics.regions.is_empty_in(subst::SelfSpace));\n-\n-                // Traits never declare type/region parameters in the\n-                // fn space.\n                 assert!(generics.types.is_empty_in(subst::FnSpace));\n                 assert!(generics.regions.is_empty_in(subst::FnSpace));\n \n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(bounds.region_bound, contra);\n+                self.add_constraints_from_region(data.bounds.region_bound, contra);\n \n                 self.add_constraints_from_substs(\n-                    principal.def_id(),\n+                    trait_ref.def_id(),\n                     generics.types.get_slice(subst::TypeSpace),\n                     generics.regions.get_slice(subst::TypeSpace),\n-                    principal.substs(),\n+                    trait_ref.substs(),\n                     variance);\n             }\n "}, {"sha": "d5ffce8db78f890de988896bec7bd87411ad46e0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -1466,6 +1466,18 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             }\n             ty::ty_tup(ref t) => Tuple(t.clean(cx)),\n \n+            ty::ty_projection(ref data) => {\n+                let trait_ref = match data.trait_ref.clean(cx) {\n+                    TyParamBound::TraitBound(t) => t,\n+                    TyParamBound::RegionBound(_) => panic!(\"cleaning a trait got a region??\"),\n+                };\n+                Type::QPath {\n+                    name: data.item_name.clean(cx),\n+                    self_type: box data.trait_ref.self_ty().clean(cx),\n+                    trait_: box trait_ref,\n+                }\n+            }\n+\n             ty::ty_param(ref p) => {\n                 if p.space == subst::SelfSpace {\n                     Self(p.def_id)"}, {"sha": "e93d9db28cf4b18eb6e59168281a4e88cfe5f7df", "filename": "src/test/compile-fail/associated-types-eq-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-1.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "previous_filename": "src/test/compile-fail/assoc-eq-1.rs"}, {"sha": "652bf4fb57753bf38a6ea1a626e450724539cdbe", "filename": "src/test/compile-fail/associated-types-eq-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-2.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "previous_filename": "src/test/compile-fail/assoc-eq-2.rs"}, {"sha": "880b2e9cc4a77ebf7813e317bd2bc0f4582f27e2", "filename": "src/test/compile-fail/associated-types-eq-3.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "previous_filename": "src/test/compile-fail/assoc-eq-3.rs"}, {"sha": "1a96b0ca6812e357b507e1daea4e8ffd69b5f8b8", "filename": "src/test/compile-fail/associated-types-eq-expr-path.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "previous_filename": "src/test/compile-fail/assoc-eq-expr-path.rs"}, {"sha": "2c6ee502fca3ed115cb5bc34330825e3b5a18806", "filename": "src/test/compile-fail/associated-types-for-unimpl-trait.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-for-unimpl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-for-unimpl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-for-unimpl-trait.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Get {\n+    type Value;\n+    fn get(&self) -> <Self as Get>::Value;\n+}\n+\n+trait Other {\n+    fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n+    //~^ ERROR the trait `Get` is not implemented for the type `Self`\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "28a4ad01e23a9b9a870a343393094c33fc4cdc75", "filename": "src/test/compile-fail/associated-types-in-wrong-context.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-wrong-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-wrong-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-wrong-context.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -15,9 +15,6 @@ trait Get {\n     fn get(&self) -> <Self as Get>::Value;\n }\n \n-fn get(x: int) -> <int as Get>::Value {}\n-//~^ ERROR unsupported\n-\n struct Struct {\n     x: int,\n }"}, {"sha": "41f5bc17b561bb9ee378a3405ff3fc6f4c2fcb18", "filename": "src/test/compile-fail/associated-types-path-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-1.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "previous_filename": "src/test/compile-fail/assoc-path-1.rs"}, {"sha": "caf8ab3695d1c38905eef27735b55ec50e3f3702", "filename": "src/test/compile-fail/associated-types-path-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "previous_filename": "src/test/compile-fail/assoc-path-2.rs"}, {"sha": "fcfcce3ff1b78d879d9925ccf327e26907b7fc6c", "filename": "src/test/run-pass/associated-types-basic.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Foo {\n+    type T;\n+}\n+\n+impl Foo for i32 {\n+    type T = int;\n+}\n+\n+fn main() {\n+    let x: <i32 as Foo>::T = 22;\n+    let y: int = 44;\n+    assert_eq!(x * 2, y);\n+}\n+"}, {"sha": "c3300c529357526e36d31763335eab41910ebee2", "filename": "src/test/run-pass/associated-types-binding-in-where-clause.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Frun-pass%2Fassociated-types-binding-in-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Frun-pass%2Fassociated-types-binding-in-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-binding-in-where-clause.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints on associated types in a where clause.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+#[deriving(PartialEq)]\n+struct Bar;\n+\n+impl Foo for int {\n+    type A = uint;\n+    fn boo(&self) -> uint { 42 }\n+}\n+\n+impl Foo for char {\n+    type A = Bar;\n+    fn boo(&self) -> Bar { Bar }\n+}\n+\n+fn foo_bar<I: Foo<A=Bar>>(x: I) -> Bar {\n+    x.boo()\n+}\n+\n+fn foo_uint<I: Foo<A=uint>>(x: I) -> uint {\n+    x.boo()\n+}\n+\n+pub fn main() {\n+    let a = 42i;\n+    foo_uint(a);\n+\n+    let a = 'a';\n+    foo_bar(a);\n+}"}, {"sha": "ea2cf84b757c3b84a867bfcba7476e72a31b02ca", "filename": "src/test/run-pass/associated-types-constant-type.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Frun-pass%2Fassociated-types-constant-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Frun-pass%2Fassociated-types-constant-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-constant-type.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait SignedUnsigned {\n+    type Opposite;\n+    fn convert(self) -> Self::Opposite;\n+}\n+\n+impl SignedUnsigned for int {\n+    type Opposite = uint;\n+\n+    fn convert(self) -> uint {\n+        self as uint\n+    }\n+}\n+\n+impl SignedUnsigned for uint {\n+    type Opposite = int;\n+\n+    fn convert(self) -> int {\n+        self as int\n+    }\n+}\n+\n+fn get(x: int) -> <int as SignedUnsigned>::Opposite {\n+    x.convert()\n+}\n+\n+fn main() {\n+    let x = get(22);\n+    assert_eq!(22u, x);\n+}\n+"}, {"sha": "f0343a743cb5025b1fb926e12f1619ff4cd891ee", "filename": "src/test/run-pass/associated-types-eq-obj.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Frun-pass%2Fassociated-types-eq-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Frun-pass%2Fassociated-types-eq-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-eq-obj.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints on associated types inside of an object type\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+struct Bar;\n+\n+impl Foo for char {\n+    type A = Bar;\n+    fn boo(&self) -> Bar { Bar }\n+}\n+\n+fn baz(x: &Foo<A=Bar>) -> Bar {\n+    x.boo()\n+}\n+\n+pub fn main() {\n+    let a = 'a';\n+    baz(&a);\n+}"}, {"sha": "d8e277510ed106867b25182ce80af0c38358c49d", "filename": "src/test/run-pass/associated-types-return.rs", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Frun-pass%2Fassociated-types-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Frun-pass%2Fassociated-types-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-return.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test equality constraints on associated types.\n+// Test equality constraints on associated types in a where clause.\n \n #![feature(associated_types)]\n \n@@ -17,16 +17,19 @@ pub trait Foo {\n     fn boo(&self) -> <Self as Foo>::A;\n }\n \n+#[deriving(PartialEq)]\n struct Bar;\n \n impl Foo for int {\n     type A = uint;\n     fn boo(&self) -> uint { 42 }\n }\n+\n impl Foo for Bar {\n     type A = int;\n     fn boo(&self) -> int { 43 }\n }\n+\n impl Foo for char {\n     type A = Bar;\n     fn boo(&self) -> Bar { Bar }\n@@ -35,12 +38,10 @@ impl Foo for char {\n fn foo1<I: Foo<A=Bar>>(x: I) -> Bar {\n     x.boo()\n }\n+\n fn foo2<I: Foo>(x: I) -> <I as Foo>::A {\n     x.boo()\n }\n-fn baz(x: &Foo<A=Bar>) -> Bar {\n-    x.boo()\n-}\n \n pub fn main() {\n     let a = 42i;\n@@ -51,5 +52,5 @@ pub fn main() {\n \n     let a = 'a';\n     foo1(a);\n-    baz(&a);\n+    assert!(foo2(a) == Bar);\n }", "previous_filename": "src/test/run-pass/assoc-eq.rs"}, {"sha": "28c06f51cebc25d2ba7075a8d5448f9dd896325e", "filename": "src/test/run-pass/associated-types-sugar-path.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4404592f3631233c2f160c3f9a315764a4fcfba9/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs?ref=4404592f3631233c2f160c3f9a315764a4fcfba9", "previous_filename": "src/test/run-pass/assoc-sugar-path.rs"}]}