{"sha": "42c0236ed0071ed9f8734c346341f0bf54732b8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYzAyMzZlZDAwNzFlZDlmODczNGMzNDYzNDFmMGJmNTQ3MzJiOGU=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-06-13T21:14:44Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-10-17T02:58:10Z"}, "message": "Use a sharded dep node to dep node index map", "tree": {"sha": "dbb79312d4ba27597e8c8b472509a41bd1caa843", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbb79312d4ba27597e8c8b472509a41bd1caa843"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42c0236ed0071ed9f8734c346341f0bf54732b8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42c0236ed0071ed9f8734c346341f0bf54732b8e", "html_url": "https://github.com/rust-lang/rust/commit/42c0236ed0071ed9f8734c346341f0bf54732b8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42c0236ed0071ed9f8734c346341f0bf54732b8e/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8fa82c482f1b6bb0159df87df6678f15122cdd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8fa82c482f1b6bb0159df87df6678f15122cdd3", "html_url": "https://github.com/rust-lang/rust/commit/c8fa82c482f1b6bb0159df87df6678f15122cdd3"}], "stats": {"total": 59, "additions": 44, "deletions": 15}, "files": [{"sha": "337cdddc432c4640ed1c8321f5e9d554a373bef2", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/42c0236ed0071ed9f8734c346341f0bf54732b8e/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c0236ed0071ed9f8734c346341f0bf54732b8e/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=42c0236ed0071ed9f8734c346341f0bf54732b8e", "patch": "@@ -4,6 +4,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::{Idx, IndexVec};\n use smallvec::SmallVec;\n use rustc_data_structures::sync::{Lrc, Lock, AtomicU32, AtomicU64, Ordering};\n+use rustc_data_structures::sharded::{self, Sharded};\n use std::sync::atomic::Ordering::SeqCst;\n use std::env;\n use std::hash::Hash;\n@@ -381,7 +382,7 @@ impl DepGraph {\n     #[inline]\n     pub fn read(&self, v: DepNode) {\n         if let Some(ref data) = self.data {\n-            let map = data.current.node_to_node_index.lock();\n+            let map = data.current.node_to_node_index.get_shard_by_value(&v).lock();\n             if let Some(dep_node_index) = map.get(&v).copied() {\n                 std::mem::drop(map);\n                 data.read_index(dep_node_index);\n@@ -405,6 +406,7 @@ impl DepGraph {\n             .unwrap()\n             .current\n             .node_to_node_index\n+            .get_shard_by_value(dep_node)\n             .lock()\n             .get(dep_node)\n             .cloned()\n@@ -414,7 +416,11 @@ impl DepGraph {\n     #[inline]\n     pub fn dep_node_exists(&self, dep_node: &DepNode) -> bool {\n         if let Some(ref data) = self.data {\n-            data.current.node_to_node_index.lock().contains_key(dep_node)\n+            data.current\n+                .node_to_node_index\n+                .get_shard_by_value(&dep_node)\n+                .lock()\n+                .contains_key(dep_node)\n         } else {\n             false\n         }\n@@ -595,7 +601,11 @@ impl DepGraph {\n \n         #[cfg(not(parallel_compiler))]\n         {\n-            debug_assert!(!data.current.node_to_node_index.lock().contains_key(dep_node));\n+            debug_assert!(!data.current\n+                               .node_to_node_index\n+                               .get_shard_by_value(dep_node)\n+                               .lock()\n+                               .contains_key(dep_node));\n             debug_assert!(data.colors.get(prev_dep_node_index).is_none());\n         }\n \n@@ -927,7 +937,7 @@ struct DepNodeData {\n /// acquire the lock on `data.`\n pub(super) struct CurrentDepGraph {\n     data: Lock<IndexVec<DepNodeIndex, DepNodeData>>,\n-    node_to_node_index: Lock<FxHashMap<DepNode, DepNodeIndex>>,\n+    node_to_node_index: Sharded<FxHashMap<DepNode, DepNodeIndex>>,\n \n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n@@ -985,8 +995,8 @@ impl CurrentDepGraph {\n \n         CurrentDepGraph {\n             data: Lock::new(IndexVec::with_capacity(new_node_count_estimate)),\n-            node_to_node_index: Lock::new(FxHashMap::with_capacity_and_hasher(\n-                new_node_count_estimate,\n+            node_to_node_index: Sharded::new(|| FxHashMap::with_capacity_and_hasher(\n+                new_node_count_estimate / sharded::SHARDS,\n                 Default::default(),\n             )),\n             anon_id_seed: stable_hasher.finish(),\n@@ -1035,7 +1045,10 @@ impl CurrentDepGraph {\n         edges: SmallVec<[DepNodeIndex; 8]>,\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n-        debug_assert!(!self.node_to_node_index.lock().contains_key(&dep_node));\n+        debug_assert!(!self.node_to_node_index\n+                           .get_shard_by_value(&dep_node)\n+                           .lock()\n+                           .contains_key(&dep_node));\n         self.intern_node(dep_node, edges, fingerprint)\n     }\n \n@@ -1045,7 +1058,7 @@ impl CurrentDepGraph {\n         edges: SmallVec<[DepNodeIndex; 8]>,\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n-        match self.node_to_node_index.lock().entry(dep_node) {\n+        match self.node_to_node_index.get_shard_by_value(&dep_node).lock().entry(dep_node) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n                 let mut data = self.data.lock();"}, {"sha": "d0ff6108d6ea6183fc3d035198b588585ac206e2", "filename": "src/librustc_data_structures/sharded.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/42c0236ed0071ed9f8734c346341f0bf54732b8e/src%2Flibrustc_data_structures%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c0236ed0071ed9f8734c346341f0bf54732b8e/src%2Flibrustc_data_structures%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsharded.rs?ref=42c0236ed0071ed9f8734c346341f0bf54732b8e", "patch": "@@ -2,6 +2,7 @@ use std::hash::{Hasher, Hash};\n use std::mem;\n use std::borrow::Borrow;\n use std::collections::hash_map::RawEntryMut;\n+use smallvec::SmallVec;\n use crate::fx::{FxHasher, FxHashMap};\n use crate::sync::{Lock, LockGuard};\n \n@@ -18,7 +19,7 @@ const SHARD_BITS: usize = 5;\n #[cfg(not(parallel_compiler))]\n const SHARD_BITS: usize = 0;\n \n-const SHARDS: usize = 1 << SHARD_BITS;\n+pub const SHARDS: usize = 1 << SHARD_BITS;\n \n /// An array of cache-line aligned inner locked structures with convenience methods.\n #[derive(Clone)]\n@@ -29,21 +30,36 @@ pub struct Sharded<T> {\n impl<T: Default> Default for Sharded<T> {\n     #[inline]\n     fn default() -> Self {\n+        Self::new(|| T::default())\n+    }\n+}\n+\n+impl<T> Sharded<T> {\n+    #[inline]\n+    pub fn new(mut value: impl FnMut() -> T) -> Self {\n+        // Create a vector of the values we want\n+        let mut values: SmallVec<[_; SHARDS]> = (0..SHARDS).map(|_| {\n+            CacheAligned(Lock::new(value()))\n+        }).collect();\n+\n+        // Create an unintialized array\n         let mut shards: mem::MaybeUninit<[CacheAligned<Lock<T>>; SHARDS]> =\n             mem::MaybeUninit::uninit();\n-        let first = shards.as_mut_ptr() as *mut CacheAligned<Lock<T>>;\n+\n         unsafe {\n-            for i in 0..SHARDS {\n-                first.add(i).write(CacheAligned(Lock::new(T::default())));\n-            }\n+            // Copy the values into our array\n+            let first = shards.as_mut_ptr() as *mut CacheAligned<Lock<T>>;\n+            values.as_ptr().copy_to_nonoverlapping(first, SHARDS);\n+\n+            // Ignore the content of the vector\n+            values.set_len(0);\n+\n             Sharded {\n                 shards: shards.assume_init(),\n             }\n         }\n     }\n-}\n \n-impl<T> Sharded<T> {\n     #[inline]\n     pub fn get_shard_by_value<K: Hash + ?Sized>(&self, val: &K) -> &Lock<T> {\n         if SHARDS == 1 {"}]}