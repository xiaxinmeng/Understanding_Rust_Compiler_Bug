{"sha": "109f887bf54718cea89b9b9c51ada1f06956b335", "node_id": "C_kwDOAAsO6NoAKDEwOWY4ODdiZjU0NzE4Y2VhODliOWI5YzUxYWRhMWYwNjk1NmIzMzU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-11-02T17:02:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-02T17:02:03Z"}, "message": "Rollup merge of #103703 - Nilstrieb:flag-recovery-1, r=compiler-errors\n\nGate some parser recovery behind the check\n\nMainly in `expr.rs`. `may_recover` doesn't do anything useful yet until I implement that on top of #103439.\n\nr? `@compiler-errors`", "tree": {"sha": "855f1ea0e243130854d5283597be9c067ec431f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/855f1ea0e243130854d5283597be9c067ec431f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/109f887bf54718cea89b9b9c51ada1f06956b335", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjYqKLCRBK7hj4Ov3rIwAA7ygIAGzNkWZKSjAUCqa/6xcqKdJN\nvSmwWxN96ThrcQx7m+lDrm0pz9yybdb5Y/jaZTpF2zaFlVNHwa3fIYInxyA1Pfe/\nT5jqMk8wnbTlDCBVADqvN2yP1YiI5Ga0vIeaPOn9drU/PI7QOIJX+YMI95Hvv/nG\nyRBVuPlkM40B/e1F0Ok2mKHZn3qT1c2GGG4zBlyWGnTM+8Ov2IDDJgGKv3yCuT2R\nAxdEnBj8YRCQmZT3e2ZsHA6hFNseAgFL+cADGbAJNhgyiuQFsiBr99028tB+LFLo\ngx2KLV6tzlLWYKSFxKKh0G81PilekGYh4U9fmraMvFIW9qPUGAH7eWElMmOfDg8=\n=rAVc\n-----END PGP SIGNATURE-----\n", "payload": "tree 855f1ea0e243130854d5283597be9c067ec431f0\nparent f7110e14b88b5e39f783c9fcdfc761f9cff6f5d0\nparent 29e50e8d35c8ab2795db3ed8c81fa3363b533c94\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1667408523 +0530\ncommitter GitHub <noreply@github.com> 1667408523 +0530\n\nRollup merge of #103703 - Nilstrieb:flag-recovery-1, r=compiler-errors\n\nGate some parser recovery behind the check\n\nMainly in `expr.rs`. `may_recover` doesn't do anything useful yet until I implement that on top of #103439.\n\nr? `@compiler-errors`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/109f887bf54718cea89b9b9c51ada1f06956b335", "html_url": "https://github.com/rust-lang/rust/commit/109f887bf54718cea89b9b9c51ada1f06956b335", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/109f887bf54718cea89b9b9c51ada1f06956b335/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7110e14b88b5e39f783c9fcdfc761f9cff6f5d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7110e14b88b5e39f783c9fcdfc761f9cff6f5d0", "html_url": "https://github.com/rust-lang/rust/commit/f7110e14b88b5e39f783c9fcdfc761f9cff6f5d0"}, {"sha": "29e50e8d35c8ab2795db3ed8c81fa3363b533c94", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e50e8d35c8ab2795db3ed8c81fa3363b533c94", "html_url": "https://github.com/rust-lang/rust/commit/29e50e8d35c8ab2795db3ed8c81fa3363b533c94"}], "stats": {"total": 38, "additions": 32, "deletions": 6}, "files": [{"sha": "7dc4fd0044f1ff5d3487fd8d2648e932b8e0df8c", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/109f887bf54718cea89b9b9c51ada1f06956b335/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/109f887bf54718cea89b9b9c51ada1f06956b335/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=109f887bf54718cea89b9b9c51ada1f06956b335", "patch": "@@ -769,6 +769,10 @@ impl<'a> Parser<'a> {\n         segment: &PathSegment,\n         end: &[&TokenKind],\n     ) -> bool {\n+        if !self.may_recover() {\n+            return false;\n+        }\n+\n         // This function is intended to be invoked after parsing a path segment where there are two\n         // cases:\n         //\n@@ -863,6 +867,10 @@ impl<'a> Parser<'a> {\n     /// Check if a method call with an intended turbofish has been written without surrounding\n     /// angle brackets.\n     pub(super) fn check_turbofish_missing_angle_brackets(&mut self, segment: &mut PathSegment) {\n+        if !self.may_recover() {\n+            return;\n+        }\n+\n         if token::ModSep == self.token.kind && segment.args.is_none() {\n             let snapshot = self.create_snapshot_for_diagnostic();\n             self.bump();\n@@ -1396,6 +1404,10 @@ impl<'a> Parser<'a> {\n         &mut self,\n         base: P<T>,\n     ) -> PResult<'a, P<T>> {\n+        if !self.may_recover() {\n+            return Ok(base);\n+        }\n+\n         // Do not add `::` to expected tokens.\n         if self.token == token::ModSep {\n             if let Some(ty) = base.to_ty() {"}, {"sha": "0eb633f64168711bef38b86a901bfb207ec04e02", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/109f887bf54718cea89b9b9c51ada1f06956b335/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/109f887bf54718cea89b9b9c51ada1f06956b335/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=109f887bf54718cea89b9b9c51ada1f06956b335", "patch": "@@ -132,7 +132,7 @@ impl<'a> Parser<'a> {\n             Ok(expr) => Ok(expr),\n             Err(mut err) => match self.token.ident() {\n                 Some((Ident { name: kw::Underscore, .. }, false))\n-                    if self.look_ahead(1, |t| t == &token::Comma) =>\n+                    if self.may_recover() && self.look_ahead(1, |t| t == &token::Comma) =>\n                 {\n                     // Special-case handling of `foo(_, _, _)`\n                     err.emit();\n@@ -456,15 +456,15 @@ impl<'a> Parser<'a> {\n                 return None;\n             }\n             (Some(op), _) => (op, self.token.span),\n-            (None, Some((Ident { name: sym::and, span }, false))) => {\n+            (None, Some((Ident { name: sym::and, span }, false))) if self.may_recover() => {\n                 self.sess.emit_err(InvalidLogicalOperator {\n                     span: self.token.span,\n                     incorrect: \"and\".into(),\n                     sub: InvalidLogicalOperatorSub::Conjunction(self.token.span),\n                 });\n                 (AssocOp::LAnd, span)\n             }\n-            (None, Some((Ident { name: sym::or, span }, false))) => {\n+            (None, Some((Ident { name: sym::or, span }, false))) if self.may_recover() => {\n                 self.sess.emit_err(InvalidLogicalOperator {\n                     span: self.token.span,\n                     incorrect: \"or\".into(),\n@@ -615,7 +615,7 @@ impl<'a> Parser<'a> {\n             token::Ident(..) if this.token.is_keyword(kw::Box) => {\n                 make_it!(this, attrs, |this, _| this.parse_box_expr(lo))\n             }\n-            token::Ident(..) if this.is_mistaken_not_ident_negation() => {\n+            token::Ident(..) if this.may_recover() && this.is_mistaken_not_ident_negation() => {\n                 make_it!(this, attrs, |this, _| this.recover_not_expr(lo))\n             }\n             _ => return this.parse_dot_or_call_expr(Some(attrs)),\n@@ -718,6 +718,10 @@ impl<'a> Parser<'a> {\n         let cast_expr = match self.parse_as_cast_ty() {\n             Ok(rhs) => mk_expr(self, lhs, rhs),\n             Err(type_err) => {\n+                if !self.may_recover() {\n+                    return Err(type_err);\n+                }\n+\n                 // Rewind to before attempting to parse the type with generics, to recover\n                 // from situations like `x as usize < y` in which we first tried to parse\n                 // `usize < y` as a type with generic arguments.\n@@ -1197,6 +1201,10 @@ impl<'a> Parser<'a> {\n         seq: &mut PResult<'a, P<Expr>>,\n         snapshot: Option<(SnapshotParser<'a>, ExprKind)>,\n     ) -> Option<P<Expr>> {\n+        if !self.may_recover() {\n+            return None;\n+        }\n+\n         match (seq.as_mut(), snapshot) {\n             (Err(err), Some((mut snapshot, ExprKind::Path(None, path)))) => {\n                 snapshot.bump(); // `(`\n@@ -1360,7 +1368,7 @@ impl<'a> Parser<'a> {\n             )\n         } else if self.check_inline_const(0) {\n             self.parse_const_block(lo.to(self.token.span), false)\n-        } else if self.is_do_catch_block() {\n+        } else if self.may_recover() && self.is_do_catch_block() {\n             self.recover_do_catch()\n         } else if self.is_try_block() {\n             self.expect_keyword(kw::Try)?;\n@@ -1532,6 +1540,7 @@ impl<'a> Parser<'a> {\n         {\n             self.parse_block_expr(label, lo, BlockCheckMode::Default)\n         } else if !ate_colon\n+            && self.may_recover()\n             && (matches!(self.token.kind, token::CloseDelim(_) | token::Comma)\n                 || self.token.is_op())\n         {\n@@ -1999,6 +2008,10 @@ impl<'a> Parser<'a> {\n         prev_span: Span,\n         open_delim_span: Span,\n     ) -> PResult<'a, ()> {\n+        if !self.may_recover() {\n+            return Ok(());\n+        }\n+\n         if self.token.kind == token::Comma {\n             if !self.sess.source_map().is_multiline(prev_span.until(self.token.span)) {\n                 return Ok(());\n@@ -2039,7 +2052,7 @@ impl<'a> Parser<'a> {\n         lo: Span,\n         blk_mode: BlockCheckMode,\n     ) -> PResult<'a, P<Expr>> {\n-        if self.is_array_like_block() {\n+        if self.may_recover() && self.is_array_like_block() {\n             if let Some(arr) = self.maybe_suggest_brackets_instead_of_braces(lo) {\n                 return Ok(arr);\n             }"}, {"sha": "2e59c005e315ae21e5bfa0510fe11545a20cfa6f", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/109f887bf54718cea89b9b9c51ada1f06956b335/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/109f887bf54718cea89b9b9c51ada1f06956b335/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=109f887bf54718cea89b9b9c51ada1f06956b335", "patch": "@@ -104,6 +104,7 @@ macro_rules! maybe_whole {\n macro_rules! maybe_recover_from_interpolated_ty_qpath {\n     ($self: expr, $allow_qpath_recovery: expr) => {\n         if $allow_qpath_recovery\n+                    && $self.may_recover()\n                     && $self.look_ahead(1, |t| t == &token::ModSep)\n                     && let token::Interpolated(nt) = &$self.token.kind\n                     && let token::NtTy(ty) = &**nt"}]}