{"sha": "f857199073753956db92e6710f9178e34de4122e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NTcxOTkwNzM3NTM5NTZkYjkyZTY3MTBmOTE3OGUzNGRlNDEyMmU=", "commit": {"author": {"name": "Patrick McCarter", "email": "p.mccarter@gmail.com", "date": "2019-02-06T23:10:08Z"}, "committer": {"name": "Patrick McCarter", "email": "p.mccarter@gmail.com", "date": "2019-02-06T23:10:08Z"}, "message": "fix saturating_sub() underflow for unsigned ints #58030", "tree": {"sha": "02d5dad50868015a72709966368667a62d02a9e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02d5dad50868015a72709966368667a62d02a9e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f857199073753956db92e6710f9178e34de4122e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f857199073753956db92e6710f9178e34de4122e", "html_url": "https://github.com/rust-lang/rust/commit/f857199073753956db92e6710f9178e34de4122e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f857199073753956db92e6710f9178e34de4122e/comments", "author": {"login": "pmccarter", "id": 1185163, "node_id": "MDQ6VXNlcjExODUxNjM=", "avatar_url": "https://avatars.githubusercontent.com/u/1185163?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmccarter", "html_url": "https://github.com/pmccarter", "followers_url": "https://api.github.com/users/pmccarter/followers", "following_url": "https://api.github.com/users/pmccarter/following{/other_user}", "gists_url": "https://api.github.com/users/pmccarter/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmccarter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmccarter/subscriptions", "organizations_url": "https://api.github.com/users/pmccarter/orgs", "repos_url": "https://api.github.com/users/pmccarter/repos", "events_url": "https://api.github.com/users/pmccarter/events{/privacy}", "received_events_url": "https://api.github.com/users/pmccarter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmccarter", "id": 1185163, "node_id": "MDQ6VXNlcjExODUxNjM=", "avatar_url": "https://avatars.githubusercontent.com/u/1185163?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmccarter", "html_url": "https://github.com/pmccarter", "followers_url": "https://api.github.com/users/pmccarter/followers", "following_url": "https://api.github.com/users/pmccarter/following{/other_user}", "gists_url": "https://api.github.com/users/pmccarter/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmccarter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmccarter/subscriptions", "organizations_url": "https://api.github.com/users/pmccarter/orgs", "repos_url": "https://api.github.com/users/pmccarter/repos", "events_url": "https://api.github.com/users/pmccarter/events{/privacy}", "received_events_url": "https://api.github.com/users/pmccarter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5586ebe26eae41db94549903aa597cb0247e217", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5586ebe26eae41db94549903aa597cb0247e217", "html_url": "https://github.com/rust-lang/rust/commit/c5586ebe26eae41db94549903aa597cb0247e217"}], "stats": {"total": 26, "additions": 15, "deletions": 11}, "files": [{"sha": "827c4e62ecdacaece3dbd1b61dd2aad970473abe", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f857199073753956db92e6710f9178e34de4122e/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f857199073753956db92e6710f9178e34de4122e/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=f857199073753956db92e6710f9178e34de4122e", "patch": "@@ -139,12 +139,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             Scalar::from_uint(1u128 << (num_bits - 1), Size::from_bits(num_bits))\n                         }\n                     } else {\n-                        if num_bits == 128 {\n-                            Scalar::from_uint(u128::max_value(), Size::from_bits(128))\n-                        } else {\n-                            Scalar::from_uint(u128::max_value() & ((1 << num_bits) - 1),\n-                                Size::from_bits(num_bits))\n-                        }\n+                        Scalar::from_uint(u128::max_value() >> (128 - num_bits), Size::from_bits(num_bits))\n                     };\n                     self.write_scalar(val, dest)?;\n                 } else {\n@@ -158,12 +153,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 if overflowed {\n                     let first_term: u128 = l.to_scalar()?.to_bits(l.layout.size)?;\n                     let num_bits = l.layout.size.bits();\n-                    let val = if first_term & (1 << (num_bits-1)) == 0 {  // first term is positive\n-                        // so overflow is positive\n-                        Scalar::from_uint((1u128 << (num_bits - 1)) - 1, Size::from_bits(num_bits))\n+                    let val = if l.layout.abi.is_signed() {\n+                        if first_term & (1 << (num_bits-1)) == 0 {  // first term is positive\n+                            // so overflow is positive\n+                            Scalar::from_uint((1u128 << (num_bits - 1)) - 1, Size::from_bits(num_bits))\n+                        } else {\n+                            // if first term negative, overflow must be negative\n+                            Scalar::from_uint(1u128 << (num_bits - 1), Size::from_bits(num_bits))\n+                        }\n                     } else {\n-                        // if first term negative, overflow must be negative\n-                        Scalar::from_uint(1u128 << (num_bits - 1), Size::from_bits(num_bits))\n+                        // unsigned underflow saturates to 0\n+                        Scalar::from_uint(0u128, Size::from_bits(num_bits))\n                     };\n                     self.write_scalar(val, dest)?;\n                 } else {"}, {"sha": "92372e073cf2e0eb418dca206372b353dbaba0f8", "filename": "src/test/run-pass/const-int-saturating-arith.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f857199073753956db92e6710f9178e34de4122e/src%2Ftest%2Frun-pass%2Fconst-int-saturating-arith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f857199073753956db92e6710f9178e34de4122e/src%2Ftest%2Frun-pass%2Fconst-int-saturating-arith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-int-saturating-arith.rs?ref=f857199073753956db92e6710f9178e34de4122e", "patch": "@@ -5,9 +5,11 @@ const INT_I128: i128 = i128::max_value().saturating_add(1);\n const INT_I128_NEG: i128 = i128::min_value().saturating_add(-1);\n \n const INT_U32_NO_SUB: u32 = (42 as u32).saturating_sub(2);\n+const INT_U32_SUB: u32 = (1 as u32).saturating_sub(2);\n const INT_I32_NO_SUB: i32 = (-42 as i32).saturating_sub(2);\n const INT_I32_NEG_SUB: i32 = i32::min_value().saturating_sub(1);\n const INT_I32_POS_SUB: i32 = i32::max_value().saturating_sub(-1);\n+const INT_U128_SUB: u128 = (0 as u128).saturating_sub(1);\n const INT_I128_NEG_SUB: i128 = i128::min_value().saturating_sub(1);\n const INT_I128_POS_SUB: i128 = i128::max_value().saturating_sub(-1);\n \n@@ -19,9 +21,11 @@ fn main() {\n     assert_eq!(INT_I128_NEG, i128::min_value());\n \n     assert_eq!(INT_U32_NO_SUB, 40);\n+    assert_eq!(INT_U32_SUB, 0);\n     assert_eq!(INT_I32_NO_SUB, -44);\n     assert_eq!(INT_I32_NEG_SUB, i32::min_value());\n     assert_eq!(INT_I32_POS_SUB, i32::max_value());\n+    assert_eq!(INT_U128_SUB, 0);\n     assert_eq!(INT_I128_NEG_SUB, i128::min_value());\n     assert_eq!(INT_I128_POS_SUB, i128::max_value());\n }"}]}