{"sha": "f6fa5b91e25fb24397d1e2eaf26e476b4041c65c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZmE1YjkxZTI1ZmIyNDM5N2QxZTJlYWYyNmU0NzZiNDA0MWM2NWM=", "commit": {"author": {"name": "Tom Lee", "email": "github@tomlee.co", "date": "2013-06-01T09:54:39Z"}, "committer": {"name": "Tom Lee", "email": "github@tomlee.co", "date": "2013-06-01T11:14:58Z"}, "message": "Reexport static methods on structs & enums.", "tree": {"sha": "afa7b0e3aba21d0e78418834193a25d58adb7214", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afa7b0e3aba21d0e78418834193a25d58adb7214"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6fa5b91e25fb24397d1e2eaf26e476b4041c65c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6fa5b91e25fb24397d1e2eaf26e476b4041c65c", "html_url": "https://github.com/rust-lang/rust/commit/f6fa5b91e25fb24397d1e2eaf26e476b4041c65c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6fa5b91e25fb24397d1e2eaf26e476b4041c65c/comments", "author": {"login": "thomaslee", "id": 93216, "node_id": "MDQ6VXNlcjkzMjE2", "avatar_url": "https://avatars.githubusercontent.com/u/93216?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomaslee", "html_url": "https://github.com/thomaslee", "followers_url": "https://api.github.com/users/thomaslee/followers", "following_url": "https://api.github.com/users/thomaslee/following{/other_user}", "gists_url": "https://api.github.com/users/thomaslee/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomaslee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomaslee/subscriptions", "organizations_url": "https://api.github.com/users/thomaslee/orgs", "repos_url": "https://api.github.com/users/thomaslee/repos", "events_url": "https://api.github.com/users/thomaslee/events{/privacy}", "received_events_url": "https://api.github.com/users/thomaslee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomaslee", "id": 93216, "node_id": "MDQ6VXNlcjkzMjE2", "avatar_url": "https://avatars.githubusercontent.com/u/93216?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomaslee", "html_url": "https://github.com/thomaslee", "followers_url": "https://api.github.com/users/thomaslee/followers", "following_url": "https://api.github.com/users/thomaslee/following{/other_user}", "gists_url": "https://api.github.com/users/thomaslee/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomaslee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomaslee/subscriptions", "organizations_url": "https://api.github.com/users/thomaslee/orgs", "repos_url": "https://api.github.com/users/thomaslee/repos", "events_url": "https://api.github.com/users/thomaslee/events{/privacy}", "received_events_url": "https://api.github.com/users/thomaslee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bf053c0a349a5968820780314c942ef4555b47e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bf053c0a349a5968820780314c942ef4555b47e", "html_url": "https://github.com/rust-lang/rust/commit/2bf053c0a349a5968820780314c942ef4555b47e"}], "stats": {"total": 158, "additions": 123, "deletions": 35}, "files": [{"sha": "eb9d0d0f937e0e32c8a46a47bbc1eafe3eeaf540", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 70, "deletions": 30, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f6fa5b91e25fb24397d1e2eaf26e476b4041c65c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fa5b91e25fb24397d1e2eaf26e476b4041c65c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f6fa5b91e25fb24397d1e2eaf26e476b4041c65c", "patch": "@@ -374,50 +374,90 @@ fn encode_path(ecx: @EncodeContext,\n fn encode_reexported_static_method(ecx: @EncodeContext,\n                                    ebml_w: &mut writer::Encoder,\n                                    exp: &middle::resolve::Export2,\n-                                   m: @ty::Method) {\n-    debug!(\"(encode static trait method) reexport '%s::%s'\",\n-            *exp.name, *ecx.tcx.sess.str_of(m.ident));\n+                                   method_def_id: def_id,\n+                                   method_ident: ident) {\n+    debug!(\"(encode reexported static method) %s::%s\",\n+            *exp.name, *ecx.tcx.sess.str_of(method_ident));\n     ebml_w.start_tag(tag_items_data_item_reexport);\n     ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    ebml_w.wr_str(def_to_str(m.def_id));\n+    ebml_w.wr_str(def_to_str(method_def_id));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_items_data_item_reexport_name);\n-    ebml_w.wr_str(*exp.name + \"::\" + *ecx.tcx.sess.str_of(m.ident));\n+    ebml_w.wr_str(*exp.name + \"::\" + *ecx.tcx.sess.str_of(method_ident));\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n \n+fn encode_reexported_static_base_methods(ecx: @EncodeContext,\n+                                         ebml_w: &mut writer::Encoder,\n+                                         exp: &middle::resolve::Export2)\n+                                         -> bool {\n+    match ecx.tcx.base_impls.find(&exp.def_id) {\n+        Some(implementations) => {\n+            for implementations.each |&base_impl| {\n+                for base_impl.methods.each |&m| {\n+                    if m.explicit_self == ast::sty_static {\n+                        encode_reexported_static_method(ecx, ebml_w, exp,\n+                                                        m.did, m.ident);\n+                    }\n+                }\n+            }\n+\n+            true\n+        }\n+        None => { false }\n+    }\n+}\n+\n+fn encode_reexported_static_trait_methods(ecx: @EncodeContext,\n+                                          ebml_w: &mut writer::Encoder,\n+                                          exp: &middle::resolve::Export2)\n+                                          -> bool {\n+    match ecx.tcx.trait_methods_cache.find(&exp.def_id) {\n+        Some(methods) => {\n+            for methods.each |&m| {\n+                if m.explicit_self == ast::sty_static {\n+                    encode_reexported_static_method(ecx, ebml_w, exp,\n+                                                    m.def_id, m.ident);\n+                }\n+            }\n+\n+            true\n+        }\n+        None => { false }\n+    }\n+}\n+\n fn encode_reexported_static_methods(ecx: @EncodeContext,\n                                     ebml_w: &mut writer::Encoder,\n                                     mod_path: &[ast_map::path_elt],\n                                     exp: &middle::resolve::Export2) {\n-    match ecx.tcx.trait_methods_cache.find(&exp.def_id) {\n-        Some(methods) => {\n-            match ecx.tcx.items.find(&exp.def_id.node) {\n-                Some(&ast_map::node_item(item, path)) => {\n-                    let original_name = ecx.tcx.sess.str_of(item.ident);\n-\n-                    //\n-                    // We don't need to reexport static methods on traits\n-                    // declared in the same module as our `pub use ...` since\n-                    // that's done when we encode the trait item.\n-                    //\n-                    // The only exception is when the reexport *changes* the\n-                    // name e.g. `pub use Foo = self::Bar` -- we have\n-                    // encoded metadata for static methods relative to Bar,\n-                    // but not yet for Foo.\n-                    //\n-                    if mod_path != *path || *exp.name != *original_name {\n-                        for methods.each |&m| {\n-                            if m.explicit_self == ast::sty_static {\n-                                encode_reexported_static_method(ecx,\n-                                                                ebml_w,\n-                                                                exp, m);\n-                            }\n-                        }\n+    match ecx.tcx.items.find(&exp.def_id.node) {\n+        Some(&ast_map::node_item(item, path)) => {\n+            let original_name = ecx.tcx.sess.str_of(item.ident);\n+\n+            //\n+            // We don't need to reexport static methods on items\n+            // declared in the same module as our `pub use ...` since\n+            // that's done when we encode the trait item.\n+            //\n+            // The only exception is when the reexport *changes* the\n+            // name e.g. `pub use Foo = self::Bar` -- we have\n+            // encoded metadata for static methods relative to Bar,\n+            // but not yet for Foo.\n+            //\n+            if mod_path != *path || *exp.name != *original_name {\n+                if !encode_reexported_static_base_methods(ecx, ebml_w, exp) {\n+                    if encode_reexported_static_trait_methods(ecx, ebml_w, exp) {\n+                        debug!(fmt!(\"(encode reexported static methods) %s \\\n+                                    [trait]\",\n+                                    *original_name));\n                     }\n                 }\n-                _ => {}\n+                else {\n+                    debug!(fmt!(\"(encode reexported static methods) %s [base]\",\n+                                *original_name));\n+                }\n             }\n         }\n         _ => {}"}, {"sha": "e46a19d88c679027923c7edfd194b9effb096c2f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f6fa5b91e25fb24397d1e2eaf26e476b4041c65c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fa5b91e25fb24397d1e2eaf26e476b4041c65c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f6fa5b91e25fb24397d1e2eaf26e476b4041c65c", "patch": "@@ -306,6 +306,9 @@ struct ctxt_ {\n     // Maps a trait onto a mapping from self-ty to impl\n     trait_impls: @mut HashMap<ast::def_id, @mut HashMap<t, @Impl>>,\n \n+    // Maps a base type to its impl\n+    base_impls: @mut HashMap<ast::def_id, @mut ~[@Impl]>,\n+\n     // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     // present in this set can be warned about.\n     used_unsafe: @mut HashSet<ast::node_id>,\n@@ -971,6 +974,7 @@ pub fn mk_ctxt(s: session::Session,\n         destructor_for_type: @mut HashMap::new(),\n         destructors: @mut HashSet::new(),\n         trait_impls: @mut HashMap::new(),\n+        base_impls:  @mut HashMap::new(),\n         used_unsafe: @mut HashSet::new(),\n         used_mut_nodes: @mut HashSet::new(),\n      }\n@@ -3699,6 +3703,21 @@ pub fn trait_method(cx: ctxt, trait_did: ast::def_id, idx: uint) -> @Method {\n     ty::method(cx, method_def_id)\n }\n \n+\n+pub fn add_base_impl(cx: ctxt, base_def_id: def_id, implementation: @Impl) {\n+    let implementations;\n+    match cx.base_impls.find(&base_def_id) {\n+        None => {\n+            implementations = @mut ~[];\n+            cx.base_impls.insert(base_def_id, implementations);\n+        }\n+        Some(&existing) => {\n+            implementations = existing;\n+        }\n+    }\n+    implementations.push(implementation);\n+}\n+\n pub fn trait_methods(cx: ctxt, trait_did: ast::def_id) -> @~[@Method] {\n     match cx.trait_methods_cache.find(&trait_did) {\n         Some(&methods) => methods,"}, {"sha": "01260a097d754cec46c9a7fe2155e29cbe371957", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6fa5b91e25fb24397d1e2eaf26e476b4041c65c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fa5b91e25fb24397d1e2eaf26e476b4041c65c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=f6fa5b91e25fb24397d1e2eaf26e476b4041c65c", "patch": "@@ -146,7 +146,7 @@ pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n                 }\n                 _ => {\n                     fail!(\"get_base_type() returned a type that wasn't an \\\n-                           enum, class, or trait\");\n+                           enum, struct, or trait\");\n                 }\n             }\n         }\n@@ -312,6 +312,7 @@ pub impl CoherenceChecker {\n                             implementation = existing_implementation;\n                         }\n                     }\n+\n                     self.add_inherent_method(base_type_def_id,\n                                              implementation);\n                 }\n@@ -432,6 +433,8 @@ pub impl CoherenceChecker {\n         }\n \n         implementation_list.push(implementation);\n+\n+        ty::add_base_impl(self.crate_context.tcx, base_def_id, implementation);\n     }\n \n     fn add_trait_method(&self, trait_id: def_id, implementation: @Impl) {"}, {"sha": "88e746585c923a50fc613537e1589723258345f2", "filename": "src/test/auxiliary/reexported_static_methods.rs", "status": "renamed", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6fa5b91e25fb24397d1e2eaf26e476b4041c65c/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fa5b91e25fb24397d1e2eaf26e476b4041c65c/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs?ref=f6fa5b91e25fb24397d1e2eaf26e476b4041c65c", "patch": "@@ -10,6 +10,8 @@\n \n pub use sub_foo::Foo;\n pub use Baz = self::Bar;\n+pub use sub_foo::Boz;\n+pub use sub_foo::Bort;\n \n pub trait Bar {\n     pub fn bar() -> Self;\n@@ -28,4 +30,24 @@ pub mod sub_foo {\n         pub fn foo() -> int { 42 }\n     }\n \n+    pub struct Boz {\n+        unused_str: ~str\n+    }\n+\n+    pub impl Boz {\n+        pub fn boz(i: int) -> bool {\n+            i > 0\n+        }\n+    }\n+\n+    pub enum Bort {\n+        Bort1,\n+        Bort2\n+    }\n+\n+    pub impl Bort {\n+        pub fn bort() -> ~str {\n+            ~\"bort()\"\n+        }\n+    }\n }", "previous_filename": "src/test/auxiliary/mod_trait_with_static_methods_lib.rs"}, {"sha": "e8e58d78e9515809b565485922ffefe4281b15c9", "filename": "src/test/run-pass/reexported-static-methods-cross-crate.rs", "status": "renamed", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6fa5b91e25fb24397d1e2eaf26e476b4041c65c/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fa5b91e25fb24397d1e2eaf26e476b4041c65c/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freexported-static-methods-cross-crate.rs?ref=f6fa5b91e25fb24397d1e2eaf26e476b4041c65c", "patch": "@@ -9,13 +9,17 @@\n // except according to those terms.\n \n // xfail-fast\n-// aux-build:mod_trait_with_static_methods_lib.rs\n-extern mod mod_trait_with_static_methods_lib;\n+// aux-build:reexported_static_methods.rs\n+extern mod reexported_static_methods;\n \n-use mod_trait_with_static_methods_lib::Foo;\n-use mod_trait_with_static_methods_lib::Baz;\n+use reexported_static_methods::Foo;\n+use reexported_static_methods::Baz;\n+use reexported_static_methods::Boz;\n+use reexported_static_methods::Bort;\n \n pub fn main() {\n     assert_eq!(42, Foo::foo());\n     assert_eq!(84, Baz::bar());\n+    assert!(Boz::boz(1));\n+    assert_eq!(~\"bort()\", Bort::bort());\n }", "previous_filename": "src/test/run-pass/trait_with_static_methods_cross_crate.rs"}]}