{"sha": "7aded2adb6782d8188a631250ab8d72c82bd070c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhZGVkMmFkYjY3ODJkODE4OGE2MzEyNTBhYjhkNzJjODJiZDA3MGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-20T06:21:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-20T06:21:49Z"}, "message": "auto merge of #12772 : thestinger/rust/slice, r=alexcrichton\n\nCloses #12702", "tree": {"sha": "e8b2187211cc16ac15dd6a53334dbb8429f666e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8b2187211cc16ac15dd6a53334dbb8429f666e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7aded2adb6782d8188a631250ab8d72c82bd070c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7aded2adb6782d8188a631250ab8d72c82bd070c", "html_url": "https://github.com/rust-lang/rust/commit/7aded2adb6782d8188a631250ab8d72c82bd070c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7aded2adb6782d8188a631250ab8d72c82bd070c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8590e2c9ce7fd48df03d347f591d6892c6e1599", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8590e2c9ce7fd48df03d347f591d6892c6e1599", "html_url": "https://github.com/rust-lang/rust/commit/d8590e2c9ce7fd48df03d347f591d6892c6e1599"}, {"sha": "ce620320a20baa1428e679c751b1b4a8d8556ca1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce620320a20baa1428e679c751b1b4a8d8556ca1", "html_url": "https://github.com/rust-lang/rust/commit/ce620320a20baa1428e679c751b1b4a8d8556ca1"}], "stats": {"total": 725, "additions": 360, "deletions": 365}, "files": [{"sha": "796fc2c802b58ce6ad199ed5bf09a495cf0a6fdf", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -32,7 +32,7 @@ use std::io;\n use std::os;\n use std::str;\n use std::task;\n-use std::vec;\n+use std::slice;\n \n use test::MetricMap;\n \n@@ -500,7 +500,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n                          proc_res: &ProcRes) {\n \n     // true if we found the error in question\n-    let mut found_flags = vec::from_elem(\n+    let mut found_flags = slice::from_elem(\n         expected_errors.len(), false);\n \n     if proc_res.status.success() {"}, {"sha": "ee7c4064dd4d47f5895afe425f0cadfccbe740d0", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -71,7 +71,7 @@ The raw C API needs to be wrapped to provide memory safety and make use of highe\n like vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe\n internal details.\n \n-Wrapping the functions which expect buffers involves using the `vec::raw` module to manipulate Rust\n+Wrapping the functions which expect buffers involves using the `slice::raw` module to manipulate Rust\n vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous block of memory. The\n length is number of elements currently contained, and the capacity is the total size in elements of\n the allocated memory. The length is less than or equal to the capacity.\n@@ -103,7 +103,7 @@ pub fn compress(src: &[u8]) -> ~[u8] {\n         let psrc = src.as_ptr();\n \n         let mut dstlen = snappy_max_compressed_length(srclen);\n-        let mut dst = vec::with_capacity(dstlen as uint);\n+        let mut dst = slice::with_capacity(dstlen as uint);\n         let pdst = dst.as_mut_ptr();\n \n         snappy_compress(psrc, srclen, pdst, &mut dstlen);\n@@ -125,7 +125,7 @@ pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\n         let mut dstlen: size_t = 0;\n         snappy_uncompressed_length(psrc, srclen, &mut dstlen);\n \n-        let mut dst = vec::with_capacity(dstlen as uint);\n+        let mut dst = slice::with_capacity(dstlen as uint);\n         let pdst = dst.as_mut_ptr();\n \n         if snappy_uncompress(psrc, srclen, pdst, &mut dstlen) == 0 {"}, {"sha": "969ade289d394e1f91c4da99dbc82a90e425606c", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -255,10 +255,10 @@ might look like the example below.\n \n ~~~\n # use std::task::spawn;\n-# use std::vec;\n+# use std::slice;\n \n // Create a vector of ports, one for each child task\n-let rxs = vec::from_fn(3, |init_val| {\n+let rxs = slice::from_fn(3, |init_val| {\n     let (tx, rx) = channel();\n     spawn(proc() {\n         tx.send(some_expensive_computation(init_val));\n@@ -304,7 +304,7 @@ be distributed on the available cores.\n \n ~~~\n # extern crate sync;\n-# use std::vec;\n+# use std::slice;\n fn partial_sum(start: uint) -> f64 {\n     let mut local_sum = 0f64;\n     for num in range(start*100000, (start+1)*100000) {\n@@ -314,7 +314,7 @@ fn partial_sum(start: uint) -> f64 {\n }\n \n fn main() {\n-    let mut futures = vec::from_fn(1000, |ind| sync::Future::spawn( proc() { partial_sum(ind) }));\n+    let mut futures = slice::from_fn(1000, |ind| sync::Future::spawn( proc() { partial_sum(ind) }));\n \n     let mut final_res = 0f64;\n     for ft in futures.mut_iter()  {\n@@ -342,15 +342,15 @@ a single large vector of floats. Each task needs the full vector to perform its\n extern crate rand;\n extern crate sync;\n \n-use std::vec;\n+use std::slice;\n use sync::Arc;\n \n fn pnorm(nums: &~[f64], p: uint) -> f64 {\n     nums.iter().fold(0.0, |a,b| a+(*b).powf(&(p as f64)) ).powf(&(1.0 / (p as f64)))\n }\n \n fn main() {\n-    let numbers = vec::from_fn(1000000, |_| rand::random::<f64>());\n+    let numbers = slice::from_fn(1000000, |_| rand::random::<f64>());\n     let numbers_arc = Arc::new(numbers);\n \n     for num in range(1u, 10) {\n@@ -374,9 +374,9 @@ created by the line\n # extern crate sync;\n # extern crate rand;\n # use sync::Arc;\n-# use std::vec;\n+# use std::slice;\n # fn main() {\n-# let numbers = vec::from_fn(1000000, |_| rand::random::<f64>());\n+# let numbers = slice::from_fn(1000000, |_| rand::random::<f64>());\n let numbers_arc=Arc::new(numbers);\n # }\n ~~~\n@@ -387,9 +387,9 @@ and a clone of it is sent to each task\n # extern crate sync;\n # extern crate rand;\n # use sync::Arc;\n-# use std::vec;\n+# use std::slice;\n # fn main() {\n-# let numbers=vec::from_fn(1000000, |_| rand::random::<f64>());\n+# let numbers=slice::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc = Arc::new(numbers);\n # let (tx, rx) = channel();\n tx.send(numbers_arc.clone());\n@@ -404,9 +404,9 @@ Each task recovers the underlying data by\n # extern crate sync;\n # extern crate rand;\n # use sync::Arc;\n-# use std::vec;\n+# use std::slice;\n # fn main() {\n-# let numbers=vec::from_fn(1000000, |_| rand::random::<f64>());\n+# let numbers=slice::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc=Arc::new(numbers);\n # let (tx, rx) = channel();\n # tx.send(numbers_arc.clone());"}, {"sha": "3efed4a215b5181572e6cfe0a71595cf3412dd12", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -188,18 +188,18 @@ For example:\n # #[allow(unused_imports)];\n extern crate test;\n \n-use std::vec;\n+use std::slice;\n use test::BenchHarness;\n \n #[bench]\n fn bench_sum_1024_ints(b: &mut BenchHarness) {\n-    let v = vec::from_fn(1024, |n| n);\n+    let v = slice::from_fn(1024, |n| n);\n     b.iter(|| {v.iter().fold(0, |old, new| old + *new);} );\n }\n \n #[bench]\n fn initialise_a_vector(b: &mut BenchHarness) {\n-    b.iter(|| {vec::from_elem(1024, 0u64);} );\n+    b.iter(|| {slice::from_elem(1024, 0u64);} );\n     b.bytes = 1024 * 8;\n }\n "}, {"sha": "1ab705d7eced6d0eca1e1bce96973741d4cc6d5e", "filename": "src/etc/unicode.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -162,7 +162,7 @@ def emit_bsearch_range_table(f):\n     f.write(\"\"\"\n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use cmp::{Equal, Less, Greater};\n-    use vec::ImmutableVector;\n+    use slice::ImmutableVector;\n     use option::None;\n     r.bsearch(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n@@ -200,7 +200,7 @@ def emit_conversions_module(f, lowerupper, upperlower):\n     f.write(\"pub mod conversions {\\n\")\n     f.write(\"\"\"\n     use cmp::{Equal, Less, Greater};\n-    use vec::ImmutableVector;\n+    use slice::ImmutableVector;\n     use tuple::Tuple2;\n     use option::{Option, Some, None};\n \n@@ -264,7 +264,7 @@ def emit_decomp_module(f, canon, compat, combine):\n     f.write(\"pub mod decompose {\\n\");\n     f.write(\"    use option::Option;\\n\");\n     f.write(\"    use option::{Some, None};\\n\");\n-    f.write(\"    use vec::ImmutableVector;\\n\");\n+    f.write(\"    use slice::ImmutableVector;\\n\");\n     f.write(\"\"\"\n     fn bsearch_table(c: char, r: &'static [(char, &'static [char])]) -> Option<&'static [char]> {\n         use cmp::{Equal, Less, Greater};"}, {"sha": "8d6e0386526c55669d369d77bcc1ce63a04fbc4f", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -42,7 +42,7 @@ use std::rc::Rc;\n use std::rt::global_heap;\n use std::intrinsics::{TyDesc, get_tydesc};\n use std::intrinsics;\n-use std::vec;\n+use std::slice;\n \n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n@@ -111,7 +111,7 @@ impl Arena {\n \n fn chunk(size: uint, is_pod: bool) -> Chunk {\n     Chunk {\n-        data: Rc::new(RefCell::new(vec::with_capacity(size))),\n+        data: Rc::new(RefCell::new(slice::with_capacity(size))),\n         fill: Cell::new(0u),\n         is_pod: Cell::new(is_pod),\n     }"}, {"sha": "7075e47bddf7b05ef8682eacb8c2acc83e97a521", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -16,7 +16,7 @@ use std::iter::RandomAccessIterator;\n use std::iter::{Rev, Enumerate, Repeat, Map, Zip};\n use std::ops;\n use std::uint;\n-use std::vec;\n+use std::slice;\n \n #[deriving(Clone)]\n struct SmallBitv {\n@@ -278,13 +278,13 @@ impl Bitv {\n             let s =\n                 if init {\n                     if exact {\n-                        vec::from_elem(nelems, !0u)\n+                        slice::from_elem(nelems, !0u)\n                     } else {\n-                        let mut v = vec::from_elem(nelems-1, !0u);\n+                        let mut v = slice::from_elem(nelems-1, !0u);\n                         v.push((1<<nbits % uint::BITS)-1);\n                         v\n                     }\n-                } else { vec::from_elem(nelems, 0u)};\n+                } else { slice::from_elem(nelems, 0u)};\n             Big(BigBitv::new(s))\n         };\n         Bitv {rep: rep, nbits: nbits}\n@@ -452,7 +452,7 @@ impl Bitv {\n      * Each `uint` in the resulting vector has either value `0u` or `1u`.\n      */\n     pub fn to_vec(&self) -> ~[uint] {\n-        vec::from_fn(self.nbits, |x| self.init_to_vec(x))\n+        slice::from_fn(self.nbits, |x| self.init_to_vec(x))\n     }\n \n     /**\n@@ -473,7 +473,7 @@ impl Bitv {\n \n         let len = self.nbits/8 +\n                   if self.nbits % 8 == 0 { 0 } else { 1 };\n-        vec::from_fn(len, |i|\n+        slice::from_fn(len, |i|\n             bit(self, i, 0) |\n             bit(self, i, 1) |\n             bit(self, i, 2) |\n@@ -489,7 +489,7 @@ impl Bitv {\n      * Transform `self` into a `[bool]` by turning each bit into a `bool`.\n      */\n     pub fn to_bools(&self) -> ~[bool] {\n-        vec::from_fn(self.nbits, |i| self[i])\n+        slice::from_fn(self.nbits, |i| self[i])\n     }\n \n     /**\n@@ -879,7 +879,7 @@ impl BitvSet {\n     /// and w1/w2 are the words coming from the two vectors self, other.\n     fn commons<'a>(&'a self, other: &'a BitvSet)\n         -> Map<'static, ((uint, &'a uint), &'a ~[uint]), (uint, uint, uint),\n-               Zip<Enumerate<vec::Items<'a, uint>>, Repeat<&'a ~[uint]>>> {\n+               Zip<Enumerate<slice::Items<'a, uint>>, Repeat<&'a ~[uint]>>> {\n         let min = cmp::min(self.bitv.storage.len(), other.bitv.storage.len());\n         self.bitv.storage.slice(0, min).iter().enumerate()\n             .zip(Repeat::new(&other.bitv.storage))\n@@ -895,7 +895,7 @@ impl BitvSet {\n     /// `other`.\n     fn outliers<'a>(&'a self, other: &'a BitvSet)\n         -> Map<'static, ((uint, &'a uint), uint), (bool, uint, uint),\n-               Zip<Enumerate<vec::Items<'a, uint>>, Repeat<uint>>> {\n+               Zip<Enumerate<slice::Items<'a, uint>>, Repeat<uint>>> {\n         let slen = self.bitv.storage.len();\n         let olen = other.bitv.storage.len();\n \n@@ -946,7 +946,7 @@ mod tests {\n     use bitv;\n \n     use std::uint;\n-    use std::vec;\n+    use std::slice;\n     use rand;\n     use rand::Rng;\n \n@@ -964,7 +964,7 @@ mod tests {\n     #[test]\n     fn test_0_elements() {\n         let act = Bitv::new(0u, false);\n-        let exp = vec::from_elem::<bool>(0u, false);\n+        let exp = slice::from_elem::<bool>(0u, false);\n         assert!(act.eq_vec(exp));\n     }\n "}, {"sha": "05df04d293f719ec1c5ff27cb1329e93debbb4dd", "filename": "src/libcollections/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibcollections%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibcollections%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdeque.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -44,7 +44,7 @@ pub mod bench {\n     extern crate test;\n     use self::test::BenchHarness;\n     use std::container::MutableMap;\n-    use std::vec;\n+    use std::slice;\n     use rand;\n     use rand::Rng;\n \n@@ -90,7 +90,7 @@ pub mod bench {\n                                                 bh: &mut BenchHarness) {\n         // setup\n         let mut rng = rand::XorShiftRng::new();\n-        let mut keys = vec::from_fn(n, |_| rng.gen::<uint>() % n);\n+        let mut keys = slice::from_fn(n, |_| rng.gen::<uint>() % n);\n \n         for k in keys.iter() {\n             map.insert(*k, 1);"}, {"sha": "ba87e2106e4e8bfcca658d7bbf2bd8191ca10087", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -27,7 +27,7 @@ use std::option::{Option, Some, None};\n use rand;\n use rand::Rng;\n use std::result::{Ok, Err};\n-use std::vec::{ImmutableVector};\n+use std::slice::ImmutableVector;\n \n mod table {\n     use std::clone::Clone;\n@@ -1958,7 +1958,7 @@ mod test_map {\n mod test_set {\n     use super::HashSet;\n     use std::container::Container;\n-    use std::vec::ImmutableEqVector;\n+    use std::slice::ImmutableEqVector;\n \n     #[test]\n     fn test_disjoint() {"}, {"sha": "dc9e5a9700d1585a66ba557610e3d57a59d640d3", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -14,7 +14,7 @@\n \n use std::clone::Clone;\n use std::mem::{move_val_init, init, replace, swap};\n-use std::vec;\n+use std::slice;\n \n /// A priority queue implemented with a binary heap\n #[deriving(Clone)]\n@@ -181,7 +181,7 @@ impl<T:Ord> PriorityQueue<T> {\n \n /// PriorityQueue iterator\n pub struct Items <'a, T> {\n-    priv iter: vec::Items<'a, T>,\n+    priv iter: slice::Items<'a, T>,\n }\n \n impl<'a, T> Iterator<&'a T> for Items<'a, T> {"}, {"sha": "e083f3f600fcc654633e437616e18305b85b44ca", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -14,7 +14,7 @@\n //! extra::container::Deque`.\n \n use std::cmp;\n-use std::vec;\n+use std::slice;\n use std::iter::{Rev, RandomAccessIterator};\n \n use deque::Deque;\n@@ -118,7 +118,7 @@ impl<T> RingBuf<T> {\n     /// Create an empty RingBuf with space for at least `n` elements.\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n         RingBuf{nelts: 0, lo: 0,\n-              elts: vec::from_fn(cmp::max(MINIMUM_CAPACITY, n), |_| None)}\n+              elts: slice::from_fn(cmp::max(MINIMUM_CAPACITY, n), |_| None)}\n     }\n \n     /// Retrieve an element in the RingBuf by index"}, {"sha": "64be1b92e262f341a856393b532e0fbb283839fc", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -17,7 +17,7 @@\n \n use std::iter::{Enumerate, FilterMap, Rev};\n use std::mem::replace;\n-use std::vec;\n+use std::slice;\n \n #[allow(missing_doc)]\n pub struct SmallIntMap<T> {\n@@ -153,7 +153,7 @@ impl<V> SmallIntMap<V> {\n     /// Empties the hash map, moving all values into the specified closure\n     pub fn move_iter(&mut self)\n         -> FilterMap<(uint, Option<V>), (uint, V),\n-                Enumerate<vec::MoveItems<Option<V>>>>\n+                Enumerate<slice::MoveItems<Option<V>>>>\n     {\n         let values = replace(&mut self.v, ~[]);\n         values.move_iter().enumerate().filter_map(|(i, v)| {\n@@ -236,7 +236,7 @@ macro_rules! double_ended_iterator {\n pub struct Entries<'a, T> {\n     priv front: uint,\n     priv back: uint,\n-    priv iter: vec::Items<'a, Option<T>>\n+    priv iter: slice::Items<'a, Option<T>>\n }\n \n iterator!(impl Entries -> (uint, &'a T), get_ref)\n@@ -246,7 +246,7 @@ pub type RevEntries<'a, T> = Rev<Entries<'a, T>>;\n pub struct MutEntries<'a, T> {\n     priv front: uint,\n     priv back: uint,\n-    priv iter: vec::MutItems<'a, Option<T>>\n+    priv iter: slice::MutItems<'a, Option<T>>\n }\n \n iterator!(impl MutEntries -> (uint, &'a mut T), get_mut_ref)"}, {"sha": "66bcd3cbdda43cfb21a708f96be18d2edd23423b", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -13,8 +13,8 @@\n use std::mem;\n use std::uint;\n use std::mem::init;\n-use std::vec;\n-use std::vec::{Items, MutItems};\n+use std::slice;\n+use std::slice::{Items, MutItems};\n \n // FIXME: #5244: need to manually update the TrieNode constructor\n static SHIFT: uint = 4;\n@@ -474,7 +474,7 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n \n /// Forward iterator over a map\n pub struct Entries<'a, T> {\n-    priv stack: [vec::Items<'a, Child<T>>, .. NUM_CHUNKS],\n+    priv stack: [slice::Items<'a, Child<T>>, .. NUM_CHUNKS],\n     priv length: uint,\n     priv remaining_min: uint,\n     priv remaining_max: uint\n@@ -483,7 +483,7 @@ pub struct Entries<'a, T> {\n /// Forward iterator over the key-value pairs of a map, with the\n /// values being mutable.\n pub struct MutEntries<'a, T> {\n-    priv stack: [vec::MutItems<'a, Child<T>>, .. NUM_CHUNKS],\n+    priv stack: [slice::MutItems<'a, Child<T>>, .. NUM_CHUNKS],\n     priv length: uint,\n     priv remaining_min: uint,\n     priv remaining_max: uint"}, {"sha": "c25e38fe055c77fe1bd09c4d900091fbe99d1a60", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -94,7 +94,7 @@ use std::cmp::Eq;\n use std::result::{Err, Ok};\n use std::result;\n use std::option::{Some, None};\n-use std::vec;\n+use std::slice;\n \n /// Name of an option. Either a string or a single char.\n #[deriving(Clone, Eq)]\n@@ -525,7 +525,7 @@ pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n \n     fn f(_x: uint) -> ~[Optval] { return ~[]; }\n \n-    let mut vals = vec::from_fn(n_opts, f);\n+    let mut vals = slice::from_fn(n_opts, f);\n     let mut free: ~[~str] = ~[];\n     let l = args.len();\n     let mut i = 0;"}, {"sha": "1895717374bdb4b8651ca67b8a3927bdd835104f", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -188,7 +188,7 @@ use std::rt;\n use std::sync::atomics::{SeqCst, AtomicUint, INIT_ATOMIC_UINT};\n use std::sync::deque;\n use std::task::TaskOpts;\n-use std::vec;\n+use std::slice;\n use std::sync::arc::UnsafeArc;\n \n use sched::{Shutdown, Scheduler, SchedHandle, TaskFromFriend, NewNeighbor};\n@@ -356,8 +356,8 @@ impl SchedPool {\n \n         // Create a work queue for each scheduler, ntimes. Create an extra\n         // for the main thread if that flag is set. We won't steal from it.\n-        let arr = vec::from_fn(nscheds, |_| pool.deque_pool.deque());\n-        let (workers, stealers) = vec::unzip(arr.move_iter());\n+        let arr = slice::from_fn(nscheds, |_| pool.deque_pool.deque());\n+        let (workers, stealers) = slice::unzip(arr.move_iter());\n         pool.stealers = stealers;\n \n         // Now that we've got all our work queues, create one scheduler per"}, {"sha": "7d635b80dada21e215d68b32440f09b279d837e0", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -125,7 +125,7 @@ use std::io;\n use std::local_data;\n use std::os;\n use std::rt;\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n \n use sync::one::{Once, ONCE_INIT};\n@@ -247,7 +247,7 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n }\n \n fn enabled(level: u32, module: &str,\n-           iter: vec::Items<directive::LogDirective>) -> bool {\n+           iter: slice::Items<directive::LogDirective>) -> bool {\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {\n         match directive.name {"}, {"sha": "123a0414c9ca415f2942ca1987b4791992e2a7ee", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -18,7 +18,7 @@ use std::libc::{c_int, c_void};\n use std::libc;\n use std::mem;\n use std::rt::rtio;\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n \n use io::{IoResult, retry, keep_going};\n@@ -417,7 +417,7 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n     if len == -1 {\n         len = 1024; // FIXME: read PATH_MAX from C ffi?\n     }\n-    let mut buf = vec::with_capacity::<u8>(len as uint);\n+    let mut buf = slice::with_capacity::<u8>(len as uint);\n     match retry(|| unsafe {\n         libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n                        len as libc::size_t) as libc::c_int"}, {"sha": "28b963ab3485000c44b71394ae33153d496daf38", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -22,7 +22,7 @@ use std::ptr;\n use std::rt::rtio;\n use std::str;\n use std::sync::arc::UnsafeArc;\n-use std::vec;\n+use std::slice;\n \n use io::IoResult;\n \n@@ -353,8 +353,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n                 if fp_buf as uint == 0 {\n                     fail!(\"os::list_dir() failure: got null ptr from wfd\");\n                 } else {\n-                    let fp_vec = vec::from_buf(fp_buf,\n-                                               libc::wcslen(fp_buf) as uint);\n+                    let fp_vec = slice::from_buf(fp_buf, libc::wcslen(fp_buf) as uint);\n                     let fp_trimmed = str::truncate_utf16_at_nul(fp_vec);\n                     let fp_str = str::from_utf16(fp_trimmed)\n                             .expect(\"rust_list_dir_wfd_fp_buf returned invalid UTF-16\");"}, {"sha": "591c34e9be5514f56a299a1471a325eb2d07809c", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -572,12 +572,12 @@ fn spawn_process_os(config: p::ProcessConfig,\n \n #[cfg(unix)]\n fn with_argv<T>(prog: &str, args: &[~str], cb: |**libc::c_char| -> T) -> T {\n-    use std::vec;\n+    use std::slice;\n \n     // We can't directly convert `str`s into `*char`s, as someone needs to hold\n     // a reference to the intermediary byte buffers. So first build an array to\n     // hold all the ~[u8] byte strings.\n-    let mut tmps = vec::with_capacity(args.len() + 1);\n+    let mut tmps = slice::with_capacity(args.len() + 1);\n \n     tmps.push(prog.to_c_str());\n \n@@ -598,14 +598,14 @@ fn with_argv<T>(prog: &str, args: &[~str], cb: |**libc::c_char| -> T) -> T {\n \n #[cfg(unix)]\n fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*c_void| -> T) -> T {\n-    use std::vec;\n+    use std::slice;\n \n     // On posixy systems we can pass a char** for envp, which is a\n     // null-terminated array of \"k=v\\n\" strings. Like `with_argv`, we have to\n     // have a temporary buffer to hold the intermediary `~[u8]` byte strings.\n     match env {\n         Some(env) => {\n-            let mut tmps = vec::with_capacity(env.len());\n+            let mut tmps = slice::with_capacity(env.len());\n \n             for pair in env.iter() {\n                 let kv = format!(\"{}={}\", *pair.ref0(), *pair.ref1());"}, {"sha": "d0dc5b90867ff42198accd6813df2c372a656619", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -12,7 +12,7 @@\n \n use {Rng, SeedableRng, OSRng};\n use std::iter::{range_step, Repeat};\n-use std::vec::raw;\n+use std::slice::raw;\n use std::mem;\n \n static RAND_SIZE_LEN: u32 = 8;\n@@ -431,7 +431,7 @@ impl<'a> SeedableRng<&'a [u64]> for Isaac64Rng {\n mod test {\n     use super::{IsaacRng, Isaac64Rng};\n     use {Rng, SeedableRng, OSRng};\n-    use std::vec;\n+    use std::slice;\n \n     #[test]\n     fn test_rng_32_rand_seeded() {\n@@ -491,7 +491,7 @@ mod test {\n         let seed = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n-        let v = vec::from_fn(10, |_| ra.next_u32());\n+        let v = slice::from_fn(10, |_| ra.next_u32());\n         assert_eq!(v,\n                    ~[2558573138, 873787463, 263499565, 2103644246, 3595684709,\n                      4203127393, 264982119, 2765226902, 2737944514, 3900253796]);\n@@ -501,7 +501,7 @@ mod test {\n         // skip forward to the 10000th number\n         for _ in range(0, 10000) { rb.next_u32(); }\n \n-        let v = vec::from_fn(10, |_| rb.next_u32());\n+        let v = slice::from_fn(10, |_| rb.next_u32());\n         assert_eq!(v,\n                    ~[3676831399, 3183332890, 2834741178, 3854698763, 2717568474,\n                      1576568959, 3507990155, 179069555, 141456972, 2478885421]);\n@@ -511,7 +511,7 @@ mod test {\n         let seed = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n-        let v = vec::from_fn(10, |_| ra.next_u64());\n+        let v = slice::from_fn(10, |_| ra.next_u64());\n         assert_eq!(v,\n                    ~[547121783600835980, 14377643087320773276, 17351601304698403469,\n                      1238879483818134882, 11952566807690396487, 13970131091560099343,\n@@ -523,7 +523,7 @@ mod test {\n         // skip forward to the 10000th number\n         for _ in range(0, 10000) { rb.next_u64(); }\n \n-        let v = vec::from_fn(10, |_| rb.next_u64());\n+        let v = slice::from_fn(10, |_| rb.next_u64());\n         assert_eq!(v,\n                    ~[18143823860592706164, 8491801882678285927, 2699425367717515619,\n                      17196852593171130876, 2606123525235546165, 15790932315217671084,"}, {"sha": "0086b385b79c81484da9b3d231e1adf1d1a12e7f", "filename": "src/librand/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -80,7 +80,7 @@ use std::cast;\n use std::kinds::marker;\n use std::local_data;\n use std::str;\n-use std::vec;\n+use std::slice;\n \n pub use isaac::{IsaacRng, Isaac64Rng};\n pub use os::OSRng;\n@@ -202,7 +202,7 @@ pub trait Rng {\n     /// println!(\"{:?}\", rng.gen_vec::<(f64, bool)>(5));\n     /// ```\n     fn gen_vec<T: Rand>(&mut self, len: uint) -> ~[T] {\n-        vec::from_fn(len, |_| self.gen())\n+        slice::from_fn(len, |_| self.gen())\n     }\n \n     /// Generate a random value in the range [`low`, `high`). Fails if\n@@ -342,7 +342,7 @@ pub trait Rng {\n     /// println!(\"{:?}\", sample);\n     /// ```\n     fn sample<A, T: Iterator<A>>(&mut self, iter: T, n: uint) -> ~[A] {\n-        let mut reservoir : ~[A] = vec::with_capacity(n);\n+        let mut reservoir : ~[A] = slice::with_capacity(n);\n         for (i, elem) in iter.enumerate() {\n             if i < n {\n                 reservoir.push(elem);\n@@ -677,7 +677,7 @@ pub struct Closed01<F>(F);\n \n #[cfg(test)]\n mod test {\n-    use std::vec;\n+    use std::slice;\n     use super::{Rng, task_rng, random, OSRng, SeedableRng, StdRng};\n \n     struct ConstRng { i: u64 }\n@@ -696,7 +696,7 @@ mod test {\n         let lengths = [0, 1, 2, 3, 4, 5, 6, 7,\n                        80, 81, 82, 83, 84, 85, 86, 87];\n         for &n in lengths.iter() {\n-            let mut v = vec::from_elem(n, 0u8);\n+            let mut v = slice::from_elem(n, 0u8);\n             r.fill_bytes(v);\n \n             // use this to get nicer error messages."}, {"sha": "1d5448cea044f947c5135de094dbec1be635d64c", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -14,7 +14,7 @@ use metadata::cstore;\n use metadata::filesearch;\n \n use collections::HashSet;\n-use std::{os, vec};\n+use std::{os, slice};\n use std::vec_ng::Vec;\n use syntax::abi;\n \n@@ -46,7 +46,7 @@ pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<~str> {\n     let libs = libs.move_iter().filter_map(|(_, l)| l.map(|p| p.clone())).collect();\n     // We don't currently rpath extern libraries, but we know\n     // where rustrt is and we know every rust program needs it\n-    let libs = vec::append_one(libs, get_sysroot_absolute_rt_lib(sess));\n+    let libs = slice::append_one(libs, get_sysroot_absolute_rt_lib(sess));\n \n     let rpaths = get_rpaths(os, sysroot, output, libs,\n                             sess.opts.target_triple);"}, {"sha": "27aba271127eb417ebe87cdc4b73a9a36b8f35fb", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -19,7 +19,7 @@ use front::std_inject::with_version;\n use metadata::creader::Loader;\n \n use std::cell::RefCell;\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n use std::vec_ng;\n use syntax::ast_util::*;"}, {"sha": "1181f0d092859751ab5571bc1e2119ea06268b9a", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -30,7 +30,7 @@ use std::cmp;\n use std::io;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n use std::str;\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n \n use collections::{HashMap, HashSet};\n@@ -443,15 +443,15 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, ~st\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);\n                 let minsz = cmp::min(vlen, csz);\n-                let version_ok = vec::raw::buf_as_slice(cvbuf, minsz,\n+                let version_ok = slice::raw::buf_as_slice(cvbuf, minsz,\n                     |buf0| buf0 == encoder::metadata_encoding_version);\n                 if !version_ok { return Err(format!(\"incompatible metadata version found: '{}'\",\n                                                     filename.display()));}\n \n                 let cvbuf1 = cvbuf.offset(vlen as int);\n                 debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n-                vec::raw::buf_as_slice(cvbuf1, csz-vlen, |bytes| {\n+                slice::raw::buf_as_slice(cvbuf1, csz-vlen, |bytes| {\n                     let inflated = flate::inflate_bytes(bytes);\n                     found = Ok(MetadataVec(inflated));\n                 });"}, {"sha": "ac188557463f46254e4d3d0cd970d3f450af631a", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -19,7 +19,7 @@\n \n use std::io;\n use std::uint;\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n@@ -332,7 +332,7 @@ impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n                 changed: true\n             };\n \n-            let mut temp = vec::from_elem(self.words_per_id, 0u);\n+            let mut temp = slice::from_elem(self.words_per_id, 0u);\n             let mut loop_scopes = Vec::new();\n \n             while propcx.changed {"}, {"sha": "3b322d027876219187d2df84d4561188825e3799", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -32,7 +32,7 @@ use syntax::visit;\n \n use collections::HashMap;\n use std::iter::Enumerate;\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n \n // The actual lang items defined come at the end of this file in one handy table.\n@@ -60,7 +60,7 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn items<'a>(&'a self) -> Enumerate<vec::Items<'a, Option<ast::DefId>>> {\n+    pub fn items<'a>(&'a self) -> Enumerate<slice::Items<'a, Option<ast::DefId>>> {\n         self.items.iter().enumerate()\n     }\n "}, {"sha": "c29f1082a113d3fbffb41dab3a73ac3bc3076bd3", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -16,7 +16,7 @@\n  * closure.\n  */\n \n-use std::vec;\n+use std::slice;\n \n use back::abi;\n use driver::session;\n@@ -230,7 +230,7 @@ fn resolve_default_method_vtables(bcx: &Block,\n                 vtables.len() - num_method_vtables;\n             vtables.tailn(num_impl_type_parameters).to_owned()\n         },\n-        None => vec::from_elem(num_method_vtables, @Vec::new())\n+        None => slice::from_elem(num_method_vtables, @Vec::new())\n     };\n \n     let param_vtables = @(vec_ng::append((*trait_vtables_fixed).clone(),"}, {"sha": "61d6cac5250f15c9994085017f397ec239431509", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -33,7 +33,7 @@ use util::ppaux::{Repr, ty_to_str};\n \n use std::c_str::ToCStr;\n use std::libc::c_uint;\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n use std::vec_ng;\n use syntax::{ast, ast_util};\n@@ -95,7 +95,7 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n     let vec_ty = ty::expr_ty(cx.tcx(), e);\n     let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n-    let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, *e, is_local)));\n+    let (vs, inlineable) = slice::unzip(es.iter().map(|e| const_expr(cx, *e, is_local)));\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n         C_struct(cx, vs, false)\n@@ -563,7 +563,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                           }\n                       }\n                   }).to_owned_vec();\n-                  let (cs, inlineable) = vec::unzip(cs.move_iter());\n+                  let (cs, inlineable) = slice::unzip(cs.move_iter());\n                   (adt::trans_const(cx, repr, discr, cs),\n                    inlineable.iter().fold(true, |a, &b| a && b))\n               })\n@@ -612,7 +612,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = vec::from_elem(n, const_expr(cx, elem, is_local).val0());\n+            let vs = slice::from_elem(n, const_expr(cx, elem, is_local).val0());\n             let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(cx, vs, false)\n             } else {"}, {"sha": "d507d6d2db4933832939d9ea2b0aa8bfa57915d1", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -148,7 +148,7 @@ use collections::HashSet;\n use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n use std::sync::atomics;\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n use syntax::codemap::{Span, Pos};\n use syntax::{abi, ast, codemap, ast_util, ast_map, opt_vec};\n@@ -709,7 +709,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             return create_DIArray(DIB(cx), []);\n         }\n \n-        let mut signature = vec::with_capacity(fn_decl.inputs.len() + 1);\n+        let mut signature = slice::with_capacity(fn_decl.inputs.len() + 1);\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n         match fn_decl.output.node {"}, {"sha": "6e74b82f85c4cea96ac1d450d989b3da86e50ad9", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -70,7 +70,7 @@ use util::nodemap::NodeMap;\n use middle::trans::machine::llsize_of;\n use middle::trans::type_::Type;\n \n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::codemap;\n@@ -1010,7 +1010,7 @@ fn trans_rec_or_struct<'a>(\n     let ty = node_id_type(bcx, id);\n     let tcx = bcx.tcx();\n     with_field_tys(tcx, ty, Some(id), |discr, field_tys| {\n-        let mut need_base = vec::from_elem(field_tys.len(), true);\n+        let mut need_base = slice::from_elem(field_tys.len(), true);\n \n         let numbered_fields = fields.map(|field| {\n             let opt_pos ="}, {"sha": "cf64e6048b36b1055cc373c6418949e48d0b6719", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -20,7 +20,7 @@ use syntax::abi::{X86, X86_64, Arm, Mips};\n \n use std::c_str::ToCStr;\n use std::cast;\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n \n use std::libc::{c_uint};\n@@ -263,7 +263,7 @@ impl Type {\n     pub fn get_field(&self, idx: uint) -> Type {\n         unsafe {\n             let num_fields = llvm::LLVMCountStructElementTypes(self.to_ref()) as uint;\n-            let mut elems = vec::from_elem(num_fields, 0 as TypeRef);\n+            let mut elems = slice::from_elem(num_fields, 0 as TypeRef);\n \n             llvm::LLVMGetStructElementTypes(self.to_ref(), elems.as_mut_ptr());\n "}, {"sha": "4cf8f139d5a54ec30978d89341900672b535ea8c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -118,7 +118,7 @@ use std::cell::{Cell, RefCell};\n use collections::HashMap;\n use std::mem::replace;\n use std::result;\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n use std::vec_ng;\n use syntax::abi::AbiSet;\n@@ -3978,7 +3978,7 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n \n     // make a vector of booleans initially false, set to true when used\n     if tps.len() == 0u { return; }\n-    let mut tps_used = vec::from_elem(tps.len(), false);\n+    let mut tps_used = slice::from_elem(tps.len(), false);\n \n     ty::walk_ty(ty, |t| {\n             match ty::get(t).sty {"}, {"sha": "4e570edcaefe9d8e8d318c5d3b4658d5f43f6ebb", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -26,7 +26,7 @@ use util::ppaux::{Repr};\n \n use std::cell::{Cell, RefCell};\n use std::uint;\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n use syntax::ast;\n@@ -1049,7 +1049,7 @@ impl<'a> RegionVarBindings<'a> {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec = vec::from_elem(self.num_vars(), uint::MAX);\n+        let mut dup_vec = slice::from_elem(self.num_vars(), uint::MAX);\n \n         let mut opt_graph = None;\n "}, {"sha": "8518b11ecf1978966b4c10fef11d9bfb95f72483", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -14,7 +14,7 @@\n \n use std::iter::range_step;\n use std::num::Zero;\n-use std::vec::bytes::{MutableByteVector, copy_memory};\n+use std::slice::bytes::{MutableByteVector, copy_memory};\n use std::vec_ng::Vec;\n use serialize::hex::ToHex;\n \n@@ -528,7 +528,7 @@ mod tests {\n \n     use super::{Digest, Sha256, FixedBuffer};\n     use std::num::Bounded;\n-    use std::vec;\n+    use std::slice;\n     use std::vec_ng::Vec;\n     use self::rand::isaac::IsaacRng;\n     use self::rand::Rng;\n@@ -604,7 +604,7 @@ mod tests {\n     /// correct.\n     fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n         let total_size = 1000000;\n-        let buffer = vec::from_elem(blocksize * 2, 'a' as u8);\n+        let buffer = slice::from_elem(blocksize * 2, 'a' as u8);\n         let mut rng = IsaacRng::new_unseeded();\n         let mut count = 0;\n "}, {"sha": "a045d042dcd88db7ec13eedd721e5b510c93693d", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -33,7 +33,7 @@ use std::libc;\n use std::local_data;\n use std::mem;\n use std::str;\n-use std::vec;\n+use std::slice;\n use collections::HashMap;\n \n use html::toc::TocBuilder;\n@@ -130,7 +130,7 @@ pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n     extern fn block(ob: *buf, text: *buf, lang: *buf, opaque: *libc::c_void) {\n         unsafe {\n             let my_opaque: &my_opaque = cast::transmute(opaque);\n-            vec::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n+            slice::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n                 let text = str::from_utf8(text).unwrap();\n                 let mut lines = text.lines().filter(|l| stripped_filtered_line(*l).is_none());\n                 let text = lines.to_owned_vec().connect(\"\\n\");\n@@ -144,7 +144,7 @@ pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n                 let rendered = if lang.is_null() {\n                     false\n                 } else {\n-                    vec::raw::buf_as_slice((*lang).data,\n+                    slice::raw::buf_as_slice((*lang).data,\n                                            (*lang).size as uint, |rlang| {\n                         let rlang = str::from_utf8(rlang).unwrap();\n                         if rlang.contains(\"notrust\") {\n@@ -255,7 +255,7 @@ pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n         };\n \n         if ret.is_ok() {\n-            ret = vec::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {\n+            ret = slice::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {\n                 w.write(buf)\n             });\n         }\n@@ -271,7 +271,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n             let (should_fail, no_run, ignore) = if lang.is_null() {\n                 (false, false, false)\n             } else {\n-                vec::raw::buf_as_slice((*lang).data,\n+                slice::raw::buf_as_slice((*lang).data,\n                                        (*lang).size as uint, |lang| {\n                     let s = str::from_utf8(lang).unwrap();\n                     (s.contains(\"should_fail\"),\n@@ -280,7 +280,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n                 })\n             };\n             if ignore { return }\n-            vec::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n+            slice::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n                 let tests = &mut *(opaque as *mut ::test::Collector);\n                 let text = str::from_utf8(text).unwrap();\n                 let mut lines = text.lines().map(|l| stripped_filtered_line(l).unwrap_or(l));\n@@ -295,7 +295,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n             if text.is_null() {\n                 tests.register_header(\"\", level as u32);\n             } else {\n-                vec::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n+                slice::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n                     let text = str::from_utf8(text).unwrap();\n                     tests.register_header(text, level as u32);\n                 })"}, {"sha": "c77c666e3c06eb58bb8153b8e979442fb116c557", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -38,7 +38,7 @@ use std::local_data;\n use std::io;\n use std::io::{fs, File, BufferedWriter, MemWriter, BufferedReader};\n use std::str;\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n \n@@ -1026,7 +1026,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n     try!(document(w, item));\n     debug!(\"{:?}\", items);\n-    let mut indices = vec::from_fn(items.len(), |i| i);\n+    let mut indices = slice::from_fn(items.len(), |i| i);\n \n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n         if shortty(i1) == shortty(i2) {"}, {"sha": "45e7ba4d21faf278f45b2e55deb258ecf58c1c88", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -448,7 +448,7 @@ mod test {\n     use std::libc::{O_CREAT, O_RDWR, O_RDONLY, S_IWUSR, S_IRUSR};\n     use std::io;\n     use std::str;\n-    use std::vec;\n+    use std::slice;\n     use super::FsRequest;\n     use super::super::Loop;\n     use super::super::local_loop;\n@@ -484,7 +484,7 @@ mod test {\n             let fd = result.fd;\n \n             // read\n-            let mut read_mem = vec::from_elem(1000, 0u8);\n+            let mut read_mem = slice::from_elem(1000, 0u8);\n             let result = FsRequest::read(l(), fd, read_mem, 0);\n             assert!(result.is_ok());\n "}, {"sha": "bd07bf18a72d06b7d03c4729601b847eb75a46b3", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -15,7 +15,7 @@ use std::libc;\n use std::ptr;\n use std::rt::rtio::RtioProcess;\n use std::rt::task::BlockedTask;\n-use std::vec;\n+use std::slice;\n \n use homing::{HomingIO, HomeHandle};\n use pipe::PipeWatcher;\n@@ -48,8 +48,8 @@ impl Process {\n         for slot in config.extra_io.iter() {\n             io.push(*slot);\n         }\n-        let mut stdio = vec::with_capacity::<uvll::uv_stdio_container_t>(io.len());\n-        let mut ret_io = vec::with_capacity(io.len());\n+        let mut stdio = slice::with_capacity::<uvll::uv_stdio_container_t>(io.len());\n+        let mut ret_io = slice::with_capacity(io.len());\n         unsafe {\n             stdio.set_len(io.len());\n             for (slot, other) in stdio.iter().zip(io.iter()) {\n@@ -167,14 +167,14 @@ unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n fn with_argv<T>(prog: &str, args: &[~str], f: |**libc::c_char| -> T) -> T {\n     // First, allocation space to put all the C-strings (we need to have\n     // ownership of them somewhere\n-    let mut c_strs = vec::with_capacity(args.len() + 1);\n+    let mut c_strs = slice::with_capacity(args.len() + 1);\n     c_strs.push(prog.to_c_str());\n     for arg in args.iter() {\n         c_strs.push(arg.to_c_str());\n     }\n \n     // Next, create the char** array\n-    let mut c_args = vec::with_capacity(c_strs.len() + 1);\n+    let mut c_args = slice::with_capacity(c_strs.len() + 1);\n     for s in c_strs.iter() {\n         c_args.push(s.with_ref(|p| p));\n     }\n@@ -189,11 +189,11 @@ fn with_env<T>(env: Option<&[(~str, ~str)]>, f: |**libc::c_char| -> T) -> T {\n         None => { return f(ptr::null()); }\n     };\n     // As with argv, create some temporary storage and then the actual array\n-    let mut envp = vec::with_capacity(env.len());\n+    let mut envp = slice::with_capacity(env.len());\n     for &(ref key, ref value) in env.iter() {\n         envp.push(format!(\"{}={}\", *key, *value).to_c_str());\n     }\n-    let mut c_envp = vec::with_capacity(envp.len() + 1);\n+    let mut c_envp = slice::with_capacity(envp.len() + 1);\n     for s in envp.iter() {\n         c_envp.push(s.with_ref(|p| p));\n     }"}, {"sha": "62e078e26c1cb5320cf0568ba9ee43b7e0c02dcc", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -337,11 +337,11 @@ mod tests {\n     #[test]\n     fn test_base64_random() {\n         use self::rand::{task_rng, random, Rng};\n-        use std::vec;\n+        use std::slice;\n \n         for _ in range(0, 1000) {\n             let times = task_rng().gen_range(1u, 100);\n-            let v = vec::from_fn(times, |_| random::<u8>());\n+            let v = slice::from_fn(times, |_| random::<u8>());\n             assert_eq!(v.to_base64(STANDARD).from_base64().unwrap(), v);\n         }\n     }"}, {"sha": "2b416f263c26a8b706976fd62cd8ffe9094ffeb7", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -1041,8 +1041,8 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_A_aligned(bh: &mut BenchHarness) {\n-        use std::vec;\n-        let data = vec::from_fn(4*100, |i| {\n+        use std::slice;\n+        let data = slice::from_fn(4*100, |i| {\n             match i % 2 {\n               0 => 0x80u8,\n               _ => i as u8,\n@@ -1060,8 +1060,8 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_A_unaligned(bh: &mut BenchHarness) {\n-        use std::vec;\n-        let data = vec::from_fn(4*100+1, |i| {\n+        use std::slice;\n+        let data = slice::from_fn(4*100+1, |i| {\n             match i % 2 {\n               1 => 0x80u8,\n               _ => i as u8\n@@ -1079,8 +1079,8 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_D_aligned(bh: &mut BenchHarness) {\n-        use std::vec;\n-        let data = vec::from_fn(4*100, |i| {\n+        use std::slice;\n+        let data = slice::from_fn(4*100, |i| {\n             match i % 4 {\n               0 => 0x10u8,\n               3 => i as u8,\n@@ -1099,8 +1099,8 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_D_unaligned(bh: &mut BenchHarness) {\n-        use std::vec;\n-        let data = vec::from_fn(4*100+1, |i| {\n+        use std::slice;\n+        let data = slice::from_fn(4*100+1, |i| {\n             match i % 4 {\n               1 => 0x10u8,\n               0 => i as u8,"}, {"sha": "a95c77c7c1314eb8c0f94aa68d2924e9cdddd8bd", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -10,7 +10,7 @@\n \n //! Hex binary-to-text encoding\n use std::str;\n-use std::vec;\n+use std::slice;\n use std::fmt;\n \n /// A trait for converting a value to hexadecimal encoding\n@@ -39,7 +39,7 @@ impl<'a> ToHex for &'a [u8] {\n      * ```\n      */\n     fn to_hex(&self) -> ~str {\n-        let mut v = vec::with_capacity(self.len() * 2);\n+        let mut v = slice::with_capacity(self.len() * 2);\n         for &byte in self.iter() {\n             v.push(CHARS[byte >> 4]);\n             v.push(CHARS[byte & 0xf]);\n@@ -106,7 +106,7 @@ impl<'a> FromHex for &'a str {\n      */\n     fn from_hex(&self) -> Result<~[u8], FromHexError> {\n         // This may be an overestimate if there is any whitespace\n-        let mut b = vec::with_capacity(self.len() / 2);\n+        let mut b = slice::with_capacity(self.len() / 2);\n         let mut modulus = 0;\n         let mut buf = 0u8;\n "}, {"sha": "a103d0f496476afed5667e15d575e8e84d7372d3", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -16,7 +16,7 @@ Core encoding and decoding interfaces.\n \n use std::path;\n use std::rc::Rc;\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n \n pub trait Encoder {\n@@ -428,7 +428,7 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n     fn decode(d: &mut D) -> ~[T] {\n         d.read_seq(|d, len| {\n-            vec::from_fn(len, |i| {\n+            slice::from_fn(len, |i| {\n                 d.read_seq_elt(i, |d| Decodable::decode(d))\n             })\n         })\n@@ -680,7 +680,7 @@ pub trait DecoderHelpers {\n impl<D:Decoder> DecoderHelpers for D {\n     fn read_to_vec<T>(&mut self, f: |&mut D| -> T) -> ~[T] {\n         self.read_seq(|this, len| {\n-            vec::from_fn(len, |i| {\n+            slice::from_fn(len, |i| {\n                 this.read_seq_elt(i, |this| f(this))\n             })\n         })"}, {"sha": "33638fffc6d96740196657b9469a72568db28fff", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -19,7 +19,7 @@ use container::Container;\n use cast;\n use fmt;\n use iter::Iterator;\n-use vec::{ImmutableVector, MutableVector, Vector};\n+use slice::{ImmutableVector, MutableVector, Vector};\n use vec_ng::Vec;\n use option::{Option, Some, None};\n "}, {"sha": "96c7c218127205e3c2fbd469361a215d8bd022c1", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -76,8 +76,8 @@ use ptr::RawPtr;\n use ptr;\n use str::StrSlice;\n use str;\n-use vec::{ImmutableVector, MutableVector};\n-use vec;\n+use slice::{ImmutableVector, MutableVector};\n+use slice;\n use rt::global_heap::malloc_raw;\n use raw::Slice;\n \n@@ -343,7 +343,7 @@ impl<'a> ToCStr for &'a [u8] {\n unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: |*libc::c_char| -> T) -> T {\n     if v.len() < BUF_LEN {\n         let mut buf: [u8, .. BUF_LEN] = mem::uninit();\n-        vec::bytes::copy_memory(buf, v);\n+        slice::bytes::copy_memory(buf, v);\n         buf[v.len()] = 0;\n \n         let buf = buf.as_mut_ptr();"}, {"sha": "8c8ae85e4ea20d1f4db78857f24fcdeae7d24821", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -30,7 +30,7 @@ use rt::task::{Task, BlockedTask};\n use rt::thread::Thread;\n use sync::atomics;\n use unstable::mutex::NativeMutex;\n-use vec::OwnedVector;\n+use slice::OwnedVector;\n \n use mpsc = sync::mpsc_queue;\n "}, {"sha": "5820b13a35f4672eb59110b7b86db1f45d89bf48", "filename": "src/libstd/comm/stream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fstream.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -30,7 +30,7 @@ use rt::task::{Task, BlockedTask};\n use rt::thread::Thread;\n use spsc = sync::spsc_queue;\n use sync::atomics;\n-use vec::OwnedVector;\n+use slice::OwnedVector;\n \n static DISCONNECTED: int = int::MIN;\n #[cfg(test)]"}, {"sha": "d3ceba025ea90c4557f9f22966079eb0fe6f8eba", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -490,8 +490,8 @@ use repr;\n use result::{Ok, Err};\n use str::StrSlice;\n use str;\n-use vec::ImmutableVector;\n-use vec;\n+use slice::ImmutableVector;\n+use slice;\n \n pub use self::num::radix;\n pub use self::num::Radix;\n@@ -520,7 +520,7 @@ pub struct Formatter<'a> {\n \n     /// Output buffer.\n     buf: &'a mut io::Writer,\n-    priv curarg: vec::Items<'a, Argument<'a>>,\n+    priv curarg: slice::Items<'a, Argument<'a>>,\n     priv args: &'a [Argument<'a>],\n }\n "}, {"sha": "4b35a7596c96874353ff3dd10dbff78ca5b5a083", "filename": "src/libstd/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fnum.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -17,7 +17,7 @@ use fmt;\n use iter::{Iterator, DoubleEndedIterator};\n use num::{Int, cast, zero};\n use option::{Some, None};\n-use vec::{ImmutableVector, MutableVector};\n+use slice::{ImmutableVector, MutableVector};\n \n /// A type that represents a specific radix\n trait GenericRadix {"}, {"sha": "d329c15a7d78c7facccecc1d657c64d3cb30a2d5", "filename": "src/libstd/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fmod.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -70,7 +70,7 @@ use ops::Deref;\n use option::{Option, Some, None};\n use rc::Rc;\n use str::{Str, StrSlice};\n-use vec::{Vector, ImmutableVector};\n+use slice::{Vector, ImmutableVector};\n use vec_ng::Vec;\n \n /// Reexport the `sip::hash` function as our default hasher.\n@@ -293,7 +293,7 @@ mod tests {\n     use iter::{Iterator};\n     use option::{Some, None};\n     use result::Ok;\n-    use vec::ImmutableVector;\n+    use slice::ImmutableVector;\n \n     use super::{Hash, Hasher};\n "}, {"sha": "d448f4eeb37f665cec4f221548aa2288281d1643", "filename": "src/libstd/hash/sip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fsip.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -30,7 +30,7 @@ use default::Default;\n use io::{IoResult, Writer};\n use iter::Iterator;\n use result::Ok;\n-use vec::ImmutableVector;\n+use slice::ImmutableVector;\n \n use super::{Hash, Hasher};\n \n@@ -292,7 +292,7 @@ mod tests {\n     use num::ToStrRadix;\n     use option::{Some, None};\n     use str::{Str, OwnedStr};\n-    use vec::{Vector, ImmutableVector, OwnedVector};\n+    use slice::{Vector, ImmutableVector, OwnedVector};\n     use self::test::BenchHarness;\n \n     use super::super::Hash;"}, {"sha": "ab9a837713630dbe5ecd5f6c01be97b0479d3de3", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -17,8 +17,8 @@ use iter::ExactSize;\n use ops::Drop;\n use option::{Some, None, Option};\n use result::{Ok, Err};\n-use vec::{OwnedVector, ImmutableVector, MutableVector};\n-use vec;\n+use slice::{OwnedVector, ImmutableVector, MutableVector};\n+use slice;\n \n /// Wraps a Reader and buffers input from it\n ///\n@@ -58,7 +58,7 @@ impl<R: Reader> BufferedReader<R> {\n         // everything up-front. This allows creation of BufferedReader instances\n         // to be very cheap (large mallocs are not nearly as expensive as large\n         // callocs).\n-        let mut buf = vec::with_capacity(cap);\n+        let mut buf = slice::with_capacity(cap);\n         unsafe { buf.set_len(cap); }\n         BufferedReader {\n             inner: inner,\n@@ -106,7 +106,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n         let nread = {\n             let available = try!(self.fill());\n             let nread = cmp::min(available.len(), buf.len());\n-            vec::bytes::copy_memory(buf, available.slice_to(nread));\n+            slice::bytes::copy_memory(buf, available.slice_to(nread));\n             nread\n         };\n         self.pos += nread;\n@@ -140,7 +140,7 @@ impl<W: Writer> BufferedWriter<W> {\n     /// Creates a new `BufferedWriter` with the specified buffer capacity\n     pub fn with_capacity(cap: uint, inner: W) -> BufferedWriter<W> {\n         // See comments in BufferedReader for why this uses unsafe code.\n-        let mut buf = vec::with_capacity(cap);\n+        let mut buf = slice::with_capacity(cap);\n         unsafe { buf.set_len(cap); }\n         BufferedWriter {\n             inner: Some(inner),\n@@ -190,7 +190,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n             self.inner.get_mut_ref().write(buf)\n         } else {\n             let dst = self.buf.mut_slice_from(self.pos);\n-            vec::bytes::copy_memory(dst, buf);\n+            slice::bytes::copy_memory(dst, buf);\n             self.pos += buf.len();\n             Ok(())\n         }"}, {"sha": "075c65e04be1520d7b28d287f2805aa5cb143a56", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -16,7 +16,7 @@ use io;\n use option::{None, Option, Some};\n use result::{Ok, Err};\n use super::{Reader, Writer, IoResult};\n-use vec::{bytes, CloneableVector, MutableVector, ImmutableVector};\n+use slice::{bytes, CloneableVector, MutableVector, ImmutableVector};\n \n /// Allows reading from a rx.\n ///"}, {"sha": "070cbd569e674a09377bda8ad2addf6a84441047", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -21,7 +21,7 @@ use option::{Option, Some, None};\n use result::{Ok, Err};\n use io;\n use io::{IoError, IoResult, Reader};\n-use vec::{OwnedVector, ImmutableVector};\n+use slice::{OwnedVector, ImmutableVector};\n use ptr::RawPtr;\n \n /// An iterator that reads a single byte on each iteration,\n@@ -114,7 +114,7 @@ pub fn u64_from_be_bytes(data: &[u8],\n                       -> u64 {\n     use ptr::{copy_nonoverlapping_memory};\n     use mem::from_be64;\n-    use vec::MutableVector;\n+    use slice::MutableVector;\n \n     assert!(size <= 8u);\n \n@@ -470,10 +470,10 @@ mod bench {\n     macro_rules! u64_from_be_bytes_bench_impl(\n         ($size:expr, $stride:expr, $start_index:expr) =>\n         ({\n-            use vec;\n+            use slice;\n             use super::u64_from_be_bytes;\n \n-            let data = vec::from_fn($stride*100+$start_index, |i| i as u8);\n+            let data = slice::from_fn($stride*100+$start_index, |i| i as u8);\n             let mut sum = 0u64;\n             bh.iter(|| {\n                 let mut i = $start_index;"}, {"sha": "aab2f8c887c9aa869c046726c245a165e01fa848", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -62,7 +62,7 @@ use option::{Some, None, Option};\n use result::{Ok, Err};\n use path;\n use path::{Path, GenericPath};\n-use vec::{OwnedVector, ImmutableVector};\n+use slice::{OwnedVector, ImmutableVector};\n use vec_ng::Vec;\n \n /// Unconstrained file access type that exposes read and write operations"}, {"sha": "d0c4ef308b3174949d580d85b920447ace322c95", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -16,8 +16,8 @@ use option::None;\n use result::{Err, Ok};\n use io;\n use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n-use vec;\n-use vec::{Vector, ImmutableVector, MutableVector, OwnedCloneableVector};\n+use slice;\n+use slice::{Vector, ImmutableVector, MutableVector, OwnedCloneableVector};\n \n fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n     // compute offset as signed and clamp to prevent overflow\n@@ -64,7 +64,7 @@ impl MemWriter {\n     /// Create a new `MemWriter`, allocating at least `n` bytes for\n     /// the internal buffer.\n     pub fn with_capacity(n: uint) -> MemWriter {\n-        MemWriter { buf: vec::with_capacity(n), pos: 0 }\n+        MemWriter { buf: slice::with_capacity(n), pos: 0 }\n     }\n \n     /// Acquires an immutable reference to the underlying buffer of this\n@@ -98,7 +98,7 @@ impl Writer for MemWriter {\n \n         // Do the necessary writes\n         if left.len() > 0 {\n-            vec::bytes::copy_memory(self.buf.mut_slice_from(self.pos), left);\n+            slice::bytes::copy_memory(self.buf.mut_slice_from(self.pos), left);\n         }\n         if right.len() > 0 {\n             self.buf.push_all(right);\n@@ -171,7 +171,7 @@ impl Reader for MemReader {\n             let input = self.buf.slice(self.pos, self.pos + write_len);\n             let output = buf.mut_slice(0, write_len);\n             assert_eq!(input.len(), output.len());\n-            vec::bytes::copy_memory(output, input);\n+            slice::bytes::copy_memory(output, input);\n         }\n         self.pos += write_len;\n         assert!(self.pos <= self.buf.len());\n@@ -246,7 +246,7 @@ impl<'a> Writer for BufWriter<'a> {\n             })\n         }\n \n-        vec::bytes::copy_memory(self.buf.mut_slice_from(self.pos), buf);\n+        slice::bytes::copy_memory(self.buf.mut_slice_from(self.pos), buf);\n         self.pos += buf.len();\n         Ok(())\n     }\n@@ -303,7 +303,7 @@ impl<'a> Reader for BufReader<'a> {\n             let input = self.buf.slice(self.pos, self.pos + write_len);\n             let output = buf.mut_slice(0, write_len);\n             assert_eq!(input.len(), output.len());\n-            vec::bytes::copy_memory(output, input);\n+            slice::bytes::copy_memory(output, input);\n         }\n         self.pos += write_len;\n         assert!(self.pos <= self.buf.len());"}, {"sha": "cbced77d0149c6b5642f1999a50e91933cded00e", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -223,8 +223,8 @@ use str::{StrSlice, OwnedStr};\n use str;\n use uint;\n use unstable::finally::try_finally;\n-use vec::{OwnedVector, MutableVector, ImmutableVector, OwnedCloneableVector};\n-use vec;\n+use slice::{OwnedVector, MutableVector, ImmutableVector, OwnedCloneableVector};\n+use slice;\n \n // Reexports\n pub use self::stdio::stdin;\n@@ -406,7 +406,7 @@ pub trait Reader {\n     /// (not returned as part of the error). If this is unacceptable, then it is\n     /// recommended to use the `push_bytes` or `read` methods.\n     fn read_bytes(&mut self, len: uint) -> IoResult<~[u8]> {\n-        let mut buf = vec::with_capacity(len);\n+        let mut buf = slice::with_capacity(len);\n         match self.push_bytes(&mut buf, len) {\n             Ok(()) => Ok(buf),\n             Err(e) => Err(e),\n@@ -422,7 +422,7 @@ pub trait Reader {\n     ///\n     /// When EOF is encountered, all bytes read up to that point are returned.\n     fn read_to_end(&mut self) -> IoResult<~[u8]> {\n-        let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n+        let mut buf = slice::with_capacity(DEFAULT_BUF_SIZE);\n         loop {\n             match self.push_bytes(&mut buf, DEFAULT_BUF_SIZE) {\n                 Ok(()) => {}"}, {"sha": "6e0b766a5877eb249ca0a7fc917739eb0b182f58", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -23,7 +23,7 @@ use io::IoResult;\n use io::net::ip::{SocketAddr, IpAddr};\n use option::{Option, Some, None};\n use rt::rtio::{IoFactory, LocalIo};\n-use vec::ImmutableVector;\n+use slice::ImmutableVector;\n \n /// Hints to the types of sockets that are desired when looking up hosts\n pub enum SocketType {"}, {"sha": "dc24ead625898d2da1f1eafbb481013949c49486", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -16,7 +16,7 @@ use from_str::FromStr;\n use iter::Iterator;\n use option::{Option, None, Some};\n use str::StrSlice;\n-use vec::{MutableCloneableVector, ImmutableVector, MutableVector};\n+use slice::{MutableCloneableVector, ImmutableVector, MutableVector};\n \n pub type Port = u16;\n "}, {"sha": "d6700fda23d0c2e643b40880e788899e21584655", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -27,7 +27,7 @@ use mem::drop;\n use option::{Some, None};\n use result::{Ok, Err};\n use rt::rtio::{IoFactory, LocalIo, RtioSignal};\n-use vec::{ImmutableVector, OwnedVector};\n+use slice::{ImmutableVector, OwnedVector};\n \n /// Signals that can be sent and received\n #[repr(int)]"}, {"sha": "2389a8655f31769220189c4f103f0633dd29318a", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -40,7 +40,7 @@ use rt::local::Local;\n use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n use rt::task::Task;\n use str::StrSlice;\n-use vec::ImmutableVector;\n+use slice::ImmutableVector;\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n // platforms in all situations. Our story begins by splitting the world into two"}, {"sha": "2df0dec2d134a3a3557e87127e577957d8fe4058", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -13,7 +13,7 @@\n use prelude::*;\n use cmp;\n use io;\n-use vec::bytes::MutableByteVector;\n+use slice::bytes::MutableByteVector;\n \n /// Wraps a `Reader`, limiting the number of bytes that can be read from it.\n pub struct LimitReader<R> {"}, {"sha": "320383d4f81c2484f941b55bcfdae4501d467fd5", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -2293,7 +2293,7 @@ pub mod order {\n \n     #[test]\n     fn test_lt() {\n-        use vec::ImmutableVector;\n+        use slice::ImmutableVector;\n \n         let empty: [int, ..0] = [];\n         let xs = [1,2,3];"}, {"sha": "c6a1d710a528a54b4c18d566f568e630dd71b50d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -119,7 +119,7 @@ pub mod bool;\n pub mod char;\n pub mod tuple;\n \n-pub mod vec;\n+pub mod slice;\n pub mod vec_ng;\n pub mod str;\n "}, {"sha": "f1f1977462f8263fd5490e95a76094909e4ab23c", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -42,7 +42,7 @@ local_data::get(key_vector, |opt| assert_eq!(*opt.unwrap(), ~[4]));\n \n use cast;\n use option::{None, Option, Some};\n-use vec::{ImmutableVector, MutableVector, OwnedVector};\n+use slice::{ImmutableVector, MutableVector, OwnedVector};\n use iter::{Iterator};\n use rt::task::{Task, LocalStorage};\n use mem::replace;"}, {"sha": "98379b5e5fb30626c932e6081855cc0c9c897a6d", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -1727,12 +1727,12 @@ mod bench {\n     extern crate test;\n     use self::test::BenchHarness;\n     use num;\n-    use vec;\n+    use slice;\n     use prelude::*;\n \n     #[bench]\n     fn bench_pow_function(b: &mut BenchHarness) {\n-        let v = vec::from_fn(1024, |n| n);\n+        let v = slice::from_fn(1024, |n| n);\n         b.iter(|| {v.iter().fold(0, |old, new| num::pow(old, *new));});\n     }\n }"}, {"sha": "9d3d012bae7b5d75d59c9da367ccc6c2341a52d0", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -18,8 +18,8 @@ use option::{None, Option, Some};\n use char;\n use str::{StrSlice};\n use str;\n-use vec::{CloneableVector, ImmutableVector, MutableVector};\n-use vec::OwnedVector;\n+use slice::{CloneableVector, ImmutableVector, MutableVector};\n+use slice::OwnedVector;\n use num;\n use num::{NumCast, Zero, One, cast, Int};\n use num::{Round, Float, FPNaN, FPInfinite, ToPrimitive};"}, {"sha": "5f733302d6f93a9ef32f9c703c9591ccc35cc345", "filename": "src/libstd/option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -145,7 +145,7 @@ use default::Default;\n use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};\n use kinds::Send;\n use mem;\n-use vec;\n+use slice;\n \n /// The `Option`\n #[deriving(Clone, Eq, Ord, TotalEq, TotalOrd, Show)]\n@@ -215,7 +215,7 @@ impl<T> Option<T> {\n     #[inline]\n     pub fn as_slice<'r>(&'r self) -> &'r [T] {\n         match *self {\n-            Some(ref x) => vec::ref_slice(x),\n+            Some(ref x) => slice::ref_slice(x),\n             None => &[]\n         }\n     }\n@@ -224,7 +224,7 @@ impl<T> Option<T> {\n     #[inline]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n         match *self {\n-            Some(ref mut x) => vec::mut_ref_slice(x),\n+            Some(ref mut x) => slice::mut_ref_slice(x),\n             None => &mut []\n         }\n     }\n@@ -614,7 +614,7 @@ mod tests {\n     use iter::range;\n     use str::StrSlice;\n     use kinds::marker;\n-    use vec::ImmutableVector;\n+    use slice::ImmutableVector;\n \n     #[test]\n     fn test_get_ptr() {"}, {"sha": "d03757c1e6905b67c8ad741923214c0f840dbe3a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -47,7 +47,7 @@ use fmt;\n use sync::atomics::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use path::{Path, GenericPath};\n use iter::Iterator;\n-use vec::{Vector, CloneableVector, ImmutableVector, MutableVector, OwnedVector};\n+use slice::{Vector, CloneableVector, ImmutableVector, MutableVector, OwnedVector};\n use ptr::RawPtr;\n \n #[cfg(unix)]\n@@ -101,8 +101,8 @@ pub mod win32 {\n     use os::TMPBUF_SZ;\n     use str::StrSlice;\n     use str;\n-    use vec::{MutableVector, ImmutableVector, OwnedVector};\n-    use vec;\n+    use slice::{MutableVector, ImmutableVector, OwnedVector};\n+    use slice;\n \n     pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD)\n         -> Option<~str> {\n@@ -112,7 +112,7 @@ pub mod win32 {\n             let mut res = None;\n             let mut done = false;\n             while !done {\n-                let mut buf = vec::from_elem(n as uint, 0u16);\n+                let mut buf = slice::from_elem(n as uint, 0u16);\n                 let k = f(buf.as_mut_ptr(), n);\n                 if k == (0 as DWORD) {\n                     done = true;\n@@ -412,7 +412,7 @@ pub fn self_exe_name() -> Option<Path> {\n         unsafe {\n             use libc::funcs::bsd44::*;\n             use libc::consts::os::extra::*;\n-            use vec;\n+            use slice;\n             let mib = ~[CTL_KERN as c_int,\n                         KERN_PROC as c_int,\n                         KERN_PROC_PATHNAME as c_int, -1 as c_int];\n@@ -422,7 +422,7 @@ pub fn self_exe_name() -> Option<Path> {\n                              0u as libc::size_t);\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n-            let mut v: ~[u8] = vec::with_capacity(sz as uint);\n+            let mut v: ~[u8] = slice::with_capacity(sz as uint);\n             let err = sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n                              v.as_mut_ptr() as *mut c_void, &mut sz, ptr::null(),\n                              0u as libc::size_t);\n@@ -448,11 +448,11 @@ pub fn self_exe_name() -> Option<Path> {\n     fn load_self() -> Option<~[u8]> {\n         unsafe {\n             use libc::funcs::extra::_NSGetExecutablePath;\n-            use vec;\n+            use slice;\n             let mut sz: u32 = 0;\n             _NSGetExecutablePath(ptr::mut_null(), &mut sz);\n             if sz == 0 { return None; }\n-            let mut v: ~[u8] = vec::with_capacity(sz as uint);\n+            let mut v: ~[u8] = slice::with_capacity(sz as uint);\n             let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n             if err != 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n@@ -817,7 +817,7 @@ fn real_args() -> ~[~str] {\n \n #[cfg(windows)]\n fn real_args() -> ~[~str] {\n-    use vec;\n+    use slice;\n \n     let mut nArgs: c_int = 0;\n     let lpArgCount: *mut c_int = &mut nArgs;\n@@ -833,7 +833,7 @@ fn real_args() -> ~[~str] {\n             while *ptr.offset(len as int) != 0 { len += 1; }\n \n             // Push it onto the list.\n-            let opt_s = vec::raw::buf_as_slice(ptr, len, |buf| {\n+            let opt_s = slice::raw::buf_as_slice(ptr, len, |buf| {\n                     str::from_utf16(str::truncate_utf16_at_nul(buf))\n                 });\n             args.push(opt_s.expect(\"CommandLineToArgvW returned invalid UTF-16\"));"}, {"sha": "c8465eb039f6ec84e55d89a6451bec1b4b835023", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -71,9 +71,9 @@ use iter::Iterator;\n use option::{Option, None, Some};\n use str;\n use str::{MaybeOwned, OwnedStr, Str, StrSlice, from_utf8_lossy};\n-use vec;\n-use vec::{CloneableVector, OwnedCloneableVector, OwnedVector, Vector};\n-use vec::{ImmutableEqVector, ImmutableVector};\n+use slice;\n+use slice::{CloneableVector, OwnedCloneableVector, OwnedVector, Vector};\n+use slice::{ImmutableEqVector, ImmutableVector};\n \n /// Typedef for POSIX file paths.\n /// See `posix::Path` for more info.\n@@ -300,7 +300,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                             } else {\n                                 let mut v;\n                                 let extension = extension.container_as_bytes();\n-                                v = vec::with_capacity(name.len() + extension.len() + 1);\n+                                v = slice::with_capacity(name.len() + extension.len() + 1);\n                                 v.push_all(name);\n                                 v.push(dot);\n                                 v.push_all(extension);\n@@ -313,7 +313,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                             } else {\n                                 let mut v;\n                                 let extension = extension.container_as_bytes();\n-                                v = vec::with_capacity(idx + extension.len() + 1);\n+                                v = slice::with_capacity(idx + extension.len() + 1);\n                                 v.push_all(name.slice_to(idx+1));\n                                 v.push_all(extension);\n                                 Some(v)"}, {"sha": "f654f59266aaf1f02f1db3d81bfe6fb61ea724f6", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -20,9 +20,9 @@ use iter::{AdditiveIterator, Extendable, Iterator, Map};\n use option::{Option, None, Some};\n use str;\n use str::Str;\n-use vec;\n-use vec::{CloneableVector, RevSplits, Splits, Vector, VectorVector,\n-          ImmutableEqVector, OwnedVector, ImmutableVector, OwnedCloneableVector};\n+use slice;\n+use slice::{CloneableVector, RevSplits, Splits, Vector, VectorVector,\n+            ImmutableEqVector, OwnedVector, ImmutableVector, OwnedCloneableVector};\n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n \n /// Iterator that yields successive components of a Path as &[u8]\n@@ -125,7 +125,7 @@ impl GenericPathUnsafe for Path {\n         let filename = filename.container_as_bytes();\n         match self.sepidx {\n             None if bytes!(\"..\") == self.repr => {\n-                let mut v = vec::with_capacity(3 + filename.len());\n+                let mut v = slice::with_capacity(3 + filename.len());\n                 v.push_all(dot_dot_static);\n                 v.push(SEP_BYTE);\n                 v.push_all(filename);\n@@ -135,14 +135,14 @@ impl GenericPathUnsafe for Path {\n                 self.repr = Path::normalize(filename);\n             }\n             Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n-                let mut v = vec::with_capacity(self.repr.len() + 1 + filename.len());\n+                let mut v = slice::with_capacity(self.repr.len() + 1 + filename.len());\n                 v.push_all(self.repr);\n                 v.push(SEP_BYTE);\n                 v.push_all(filename);\n                 self.repr = Path::normalize(v);\n             }\n             Some(idx) => {\n-                let mut v = vec::with_capacity(idx + 1 + filename.len());\n+                let mut v = slice::with_capacity(idx + 1 + filename.len());\n                 v.push_all(self.repr.slice_to(idx+1));\n                 v.push_all(filename);\n                 self.repr = Path::normalize(v);\n@@ -157,7 +157,7 @@ impl GenericPathUnsafe for Path {\n             if path[0] == SEP_BYTE {\n                 self.repr = Path::normalize(path);\n             }  else {\n-                let mut v = vec::with_capacity(self.repr.len() + path.len() + 1);\n+                let mut v = slice::with_capacity(self.repr.len() + path.len() + 1);\n                 v.push_all(self.repr);\n                 v.push(SEP_BYTE);\n                 v.push_all(path);\n@@ -346,7 +346,7 @@ impl Path {\n                     } else {\n                         let n = if is_abs { comps.len() } else { comps.len() - 1} +\n                                 comps.iter().map(|v| v.len()).sum();\n-                        let mut v = vec::with_capacity(n);\n+                        let mut v = slice::with_capacity(n);\n                         let mut it = comps.move_iter();\n                         if !is_abs {\n                             match it.next() {"}, {"sha": "dba8af4128ba29675dd08c321858d5e576857dfb", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -22,7 +22,7 @@ use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Rev, Iterator, Map\n use option::{Option, Some, None};\n use str;\n use str::{CharSplits, OwnedStr, Str, StrVector, StrSlice};\n-use vec::{Vector, OwnedVector, ImmutableVector};\n+use slice::{Vector, OwnedVector, ImmutableVector};\n use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n \n /// Iterator that yields successive components of a Path as &str"}, {"sha": "0b1de74330d14c2cf68d7cef856283acdc1fc72b", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -55,10 +55,10 @@ pub use to_str::{ToStr, IntoStr};\n pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n-pub use vec::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCloneableVector};\n-pub use vec::{OwnedVector, OwnedCloneableVector, OwnedEqVector};\n-pub use vec::{MutableVector, MutableTotalOrdVector};\n-pub use vec::{Vector, VectorVector, CloneableVector, ImmutableVector};\n+pub use slice::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCloneableVector};\n+pub use slice::{OwnedVector, OwnedCloneableVector, OwnedEqVector};\n+pub use slice::{MutableVector, MutableTotalOrdVector};\n+pub use slice::{Vector, VectorVector, CloneableVector, ImmutableVector};\n \n // Reexported runtime types\n pub use comm::{channel, Sender, Receiver};"}, {"sha": "179100255c4fa6c32b3f762276d41783db0a5042", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -388,7 +388,7 @@ pub mod ptr_tests {\n     use cast;\n     use libc;\n     use str;\n-    use vec::{ImmutableVector, MutableVector};\n+    use slice::{ImmutableVector, MutableVector};\n \n     #[test]\n     fn test() {"}, {"sha": "f623dd472fd52f636b3586e255d919e0b01dce3a", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -28,7 +28,7 @@ use reflect::{MovePtr, align};\n use result::{Ok, Err};\n use str::StrSlice;\n use to_str::ToStr;\n-use vec::OwnedVector;\n+use slice::OwnedVector;\n use intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n use raw;\n "}, {"sha": "53b8db8499d8dff248393b05259f04e72745597a", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -124,10 +124,10 @@ mod imp {\n     #[cfg(not(test))]\n     unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> ~[~[u8]] {\n         use c_str::CString;\n-        use {vec, libc};\n-        use vec::CloneableVector;\n+        use {slice, libc};\n+        use slice::CloneableVector;\n \n-        vec::from_fn(argc as uint, |i| {\n+        slice::from_fn(argc as uint, |i| {\n             let cs = CString::new(*(argv as **libc::c_char).offset(i as int), false);\n             cs.as_bytes_no_nul().to_owned()\n         })"}, {"sha": "96dcc5244c0a1717f39e0b2af467c3f1c060e377", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -18,7 +18,7 @@ use mem;\n use option::{Some, None};\n use ptr::RawPtr;\n use unstable::sync::Exclusive;\n-use vec::OwnedVector;\n+use slice::OwnedVector;\n \n type Queue = Exclusive<~[proc()]>;\n "}, {"sha": "7ae2521c42352ce61e1425c4e59f58b8a247e2de", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -349,7 +349,7 @@ mod imp {\n         use path::GenericPath;\n         use ptr::RawPtr;\n         use ptr;\n-        use vec::{ImmutableVector, MutableVector};\n+        use slice::{ImmutableVector, MutableVector};\n \n         ////////////////////////////////////////////////////////////////////////\n         // libbacktrace.h API\n@@ -510,7 +510,7 @@ mod imp {\n     use unstable::dynamic_lib::DynamicLibrary;\n     use intrinsics;\n     use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    use vec::ImmutableVector;\n+    use slice::ImmutableVector;\n \n     extern \"system\" {\n         fn GetCurrentProcess() -> libc::HANDLE;"}, {"sha": "52cced26254fbf889b9ef6842a00338edb72ff21", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -16,7 +16,7 @@ use rt::rtio::EventLoop;\n #[cfg(stage0)] use cmp::TotalOrd;\n #[cfg(stage0)] use container::MutableSet;\n #[cfg(stage0)] use iter::Iterator;\n-#[cfg(stage0)] use vec::{ImmutableVector, OwnedVector};\n+#[cfg(stage0)] use slice::{ImmutableVector, OwnedVector};\n \n // Need to tell the linker on OS X to not barf on undefined symbols\n // and instead look them up at runtime, which we need to resolve"}, {"sha": "91452f5aa0de3d875e872de1280caa6caf708965", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -21,7 +21,7 @@ use rt::global_heap;\n use rt::local::Local;\n use rt::task::Task;\n use raw;\n-use vec::ImmutableVector;\n+use slice::ImmutableVector;\n use vec_ng::Vec;\n \n // This has no meaning with out rtdebug also turned on."}, {"sha": "4c208a64ddfcc147e5774bd49fd6c39ec75be47a", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -20,7 +20,7 @@ use os;\n use result::Ok;\n use str::StrSlice;\n use unstable::running_on_valgrind;\n-use vec::ImmutableVector;\n+use slice::ImmutableVector;\n \n // Indicates whether we should perform expensive sanity checks, including rtassert!\n // FIXME: Once the runtime matures remove the `true` below to turn off rtassert, etc."}, {"sha": "12718c559235c6824f94935470054ad9ff740a73", "filename": "src/libstd/slice.rs", "status": "renamed", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -158,7 +158,7 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n     // FIXME (#7136): manually inline from_fn for 2x plus speedup (sadly very\n     // important, from_elem is a bottleneck in borrowck!). Unfortunately it\n     // still is substantially slower than using the unsafe\n-    // vec::with_capacity/ptr::set_memory for primitive types.\n+    // slice::with_capacity/ptr::set_memory for primitive types.\n     unsafe {\n         let mut v = with_capacity(n_elts);\n         let p = v.as_mut_ptr();\n@@ -1464,7 +1464,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     fn reserve_additional(&mut self, n: uint) {\n         if self.capacity() - self.len() < n {\n             match self.len().checked_add(&n) {\n-                None => fail!(\"vec::reserve_additional: `uint` overflow\"),\n+                None => fail!(\"slice::reserve_additional: `uint` overflow\"),\n                 Some(new_cap) => self.reserve(new_cap)\n             }\n         }\n@@ -2430,7 +2430,7 @@ pub trait MutableCloneableVector<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::vec::MutableCloneableVector;\n+    /// use std::slice::MutableCloneableVector;\n     ///\n     /// let mut dst = [0, 0, 0];\n     /// let src = [1, 2];\n@@ -2497,7 +2497,7 @@ pub mod raw {\n     use cast::transmute;\n     use ptr;\n     use ptr::RawPtr;\n-    use vec::{with_capacity, MutableVector, OwnedVector};\n+    use slice::{with_capacity, MutableVector, OwnedVector};\n     use raw::Slice;\n \n     /**\n@@ -2576,7 +2576,7 @@ pub mod raw {\n /// Operations on `[u8]`.\n pub mod bytes {\n     use container::Container;\n-    use vec::{MutableVector, OwnedVector, ImmutableVector};\n+    use slice::{MutableVector, OwnedVector, ImmutableVector};\n     use ptr;\n     use ptr::RawPtr;\n \n@@ -2952,7 +2952,7 @@ impl<A> Extendable<A> for ~[A] {\n mod tests {\n     use prelude::*;\n     use mem;\n-    use vec::*;\n+    use slice::*;\n     use cmp::*;\n     use rand::{Rng, task_rng};\n \n@@ -4105,7 +4105,7 @@ mod tests {\n \n     #[test]\n     fn test_bytes_set_memory() {\n-        use vec::bytes::MutableByteVector;\n+        use slice::bytes::MutableByteVector;\n         let mut values = [1u8,2,3,4,5];\n         values.mut_slice(0,5).set_memory(0xAB);\n         assert!(values == [0xAB, 0xAB, 0xAB, 0xAB, 0xAB]);\n@@ -4185,11 +4185,11 @@ mod tests {\n \n         let xs = ~[Foo, Foo, Foo];\n         assert_eq!(format!(\"{:?}\", xs.slice(0, 2).to_owned()),\n-                   ~\"~[vec::tests::Foo, vec::tests::Foo]\");\n+                   ~\"~[slice::tests::Foo, slice::tests::Foo]\");\n \n         let xs: [Foo, ..3] = [Foo, Foo, Foo];\n         assert_eq!(format!(\"{:?}\", xs.slice(0, 2).to_owned()),\n-                   ~\"~[vec::tests::Foo, vec::tests::Foo]\");\n+                   ~\"~[slice::tests::Foo, slice::tests::Foo]\");\n         cnt = 0;\n         for f in xs.iter() {\n             assert!(*f == Foo);\n@@ -4365,13 +4365,13 @@ mod bench {\n     use prelude::*;\n     use ptr;\n     use rand::{weak_rng, Rng};\n-    use vec;\n+    use slice;\n \n     #[bench]\n     fn iterator(bh: &mut BenchHarness) {\n         // peculiar numbers to stop LLVM from optimising the summation\n         // out.\n-        let v = vec::from_fn(100, |i| i ^ (i << 1) ^ (i >> 1));\n+        let v = slice::from_fn(100, |i| i ^ (i << 1) ^ (i >> 1));\n \n         bh.iter(|| {\n             let mut sum = 0;\n@@ -4385,7 +4385,7 @@ mod bench {\n \n     #[bench]\n     fn mut_iterator(bh: &mut BenchHarness) {\n-        let mut v = vec::from_elem(100, 0);\n+        let mut v = slice::from_elem(100, 0);\n \n         bh.iter(|| {\n             let mut i = 0;\n@@ -4407,15 +4407,15 @@ mod bench {\n \n     #[bench]\n     fn concat(bh: &mut BenchHarness) {\n-        let xss: &[~[uint]] = vec::from_fn(100, |i| range(0, i).collect());\n+        let xss: &[~[uint]] = slice::from_fn(100, |i| range(0, i).collect());\n         bh.iter(|| {\n             let _ = xss.concat_vec();\n         });\n     }\n \n     #[bench]\n     fn connect(bh: &mut BenchHarness) {\n-        let xss: &[~[uint]] = vec::from_fn(100, |i| range(0, i).collect());\n+        let xss: &[~[uint]] = slice::from_fn(100, |i| range(0, i).collect());\n         bh.iter(|| {\n             let _ = xss.connect_vec(&0);\n         });\n@@ -4432,7 +4432,7 @@ mod bench {\n \n     #[bench]\n     fn starts_with_same_vector(bh: &mut BenchHarness) {\n-        let vec: ~[uint] = vec::from_fn(100, |i| i);\n+        let vec: ~[uint] = slice::from_fn(100, |i| i);\n         bh.iter(|| {\n             vec.starts_with(vec)\n         })\n@@ -4448,8 +4448,8 @@ mod bench {\n \n     #[bench]\n     fn starts_with_diff_one_element_at_end(bh: &mut BenchHarness) {\n-        let vec: ~[uint] = vec::from_fn(100, |i| i);\n-        let mut match_vec: ~[uint] = vec::from_fn(99, |i| i);\n+        let vec: ~[uint] = slice::from_fn(100, |i| i);\n+        let mut match_vec: ~[uint] = slice::from_fn(99, |i| i);\n         match_vec.push(0);\n         bh.iter(|| {\n             vec.starts_with(match_vec)\n@@ -4458,7 +4458,7 @@ mod bench {\n \n     #[bench]\n     fn ends_with_same_vector(bh: &mut BenchHarness) {\n-        let vec: ~[uint] = vec::from_fn(100, |i| i);\n+        let vec: ~[uint] = slice::from_fn(100, |i| i);\n         bh.iter(|| {\n             vec.ends_with(vec)\n         })\n@@ -4474,8 +4474,8 @@ mod bench {\n \n     #[bench]\n     fn ends_with_diff_one_element_at_beginning(bh: &mut BenchHarness) {\n-        let vec: ~[uint] = vec::from_fn(100, |i| i);\n-        let mut match_vec: ~[uint] = vec::from_fn(100, |i| i);\n+        let vec: ~[uint] = slice::from_fn(100, |i| i);\n+        let mut match_vec: ~[uint] = slice::from_fn(100, |i| i);\n         match_vec[0] = 200;\n         bh.iter(|| {\n             vec.starts_with(match_vec)\n@@ -4484,7 +4484,7 @@ mod bench {\n \n     #[bench]\n     fn contains_last_element(bh: &mut BenchHarness) {\n-        let vec: ~[uint] = vec::from_fn(100, |i| i);\n+        let vec: ~[uint] = slice::from_fn(100, |i| i);\n         bh.iter(|| {\n             vec.contains(&99u)\n         })\n@@ -4493,14 +4493,14 @@ mod bench {\n     #[bench]\n     fn zero_1kb_from_elem(bh: &mut BenchHarness) {\n         bh.iter(|| {\n-            let _v: ~[u8] = vec::from_elem(1024, 0u8);\n+            let _v: ~[u8] = slice::from_elem(1024, 0u8);\n         });\n     }\n \n     #[bench]\n     fn zero_1kb_set_memory(bh: &mut BenchHarness) {\n         bh.iter(|| {\n-            let mut v: ~[u8] = vec::with_capacity(1024);\n+            let mut v: ~[u8] = slice::with_capacity(1024);\n             unsafe {\n                 let vp = v.as_mut_ptr();\n                 ptr::set_memory(vp, 0, 1024);\n@@ -4522,7 +4522,7 @@ mod bench {\n         // Slower because the { len, cap, [0 x T] }* repr allows a pointer to the length\n         // field to be aliased (in theory) and prevents LLVM from optimizing loads away.\n         bh.iter(|| {\n-            let mut v: ~[u8] = vec::with_capacity(1024);\n+            let mut v: ~[u8] = slice::with_capacity(1024);\n             unsafe {\n                 v.set_len(1024);\n             }\n@@ -4535,7 +4535,7 @@ mod bench {\n     #[bench]\n     fn zero_1kb_mut_iter(bh: &mut BenchHarness) {\n         bh.iter(|| {\n-            let mut v: ~[u8] = vec::with_capacity(1024);\n+            let mut v: ~[u8] = slice::with_capacity(1024);\n             unsafe {\n                 v.set_len(1024);\n             }\n@@ -4550,7 +4550,7 @@ mod bench {\n     fn random_inserts(bh: &mut BenchHarness) {\n         let mut rng = weak_rng();\n         bh.iter(|| {\n-                let mut v = vec::from_elem(30, (0u, 0u));\n+                let mut v = slice::from_elem(30, (0u, 0u));\n                 for _ in range(0, 100) {\n                     let l = v.len();\n                     v.insert(rng.gen::<uint>() % (l + 1),\n@@ -4562,7 +4562,7 @@ mod bench {\n     fn random_removes(bh: &mut BenchHarness) {\n         let mut rng = weak_rng();\n         bh.iter(|| {\n-                let mut v = vec::from_elem(130, (0u, 0u));\n+                let mut v = slice::from_elem(130, (0u, 0u));\n                 for _ in range(0, 100) {\n                     let l = v.len();\n                     v.remove(rng.gen::<uint>() % l);\n@@ -4602,7 +4602,7 @@ mod bench {\n \n     #[bench]\n     fn sort_sorted(bh: &mut BenchHarness) {\n-        let mut v = vec::from_fn(10000, |i| i);\n+        let mut v = slice::from_fn(10000, |i| i);\n         bh.iter(|| {\n             v.sort();\n         });\n@@ -4643,7 +4643,7 @@ mod bench {\n \n     #[bench]\n     fn sort_big_sorted(bh: &mut BenchHarness) {\n-        let mut v = vec::from_fn(10000u, |i| (i, i, i, i));\n+        let mut v = slice::from_fn(10000u, |i| (i, i, i, i));\n         bh.iter(|| {\n             v.sort();\n         });", "previous_filename": "src/libstd/vec.rs"}, {"sha": "92e86a5cccb6151e48e5b2514320940a32bafeeb", "filename": "src/libstd/str.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -99,8 +99,8 @@ use option::{None, Option, Some};\n use ptr;\n use ptr::RawPtr;\n use from_str::FromStr;\n-use vec;\n-use vec::{OwnedVector, OwnedCloneableVector, ImmutableVector, MutableVector};\n+use slice;\n+use slice::{OwnedVector, OwnedCloneableVector, ImmutableVector, MutableVector};\n use vec_ng::Vec;\n use default::Default;\n use raw::Repr;\n@@ -360,7 +360,7 @@ pub type RevCharOffsets<'a> = Rev<CharOffsets<'a>>;\n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n pub type Bytes<'a> =\n-    Map<'a, &'a u8, u8, vec::Items<'a, u8>>;\n+    Map<'a, &'a u8, u8, slice::Items<'a, u8>>;\n \n /// External iterator for a string's bytes in reverse order.\n /// Use with the `std::iter` module.\n@@ -738,7 +738,7 @@ Section: Misc\n /// `iter` reset such that it is pointing at the first byte in the\n /// invalid sequence.\n #[inline(always)]\n-fn run_utf8_validation_iterator(iter: &mut vec::Items<u8>) -> bool {\n+fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool {\n     loop {\n         // save the current thing we're pointing at.\n         let old = *iter;\n@@ -855,7 +855,7 @@ pub fn is_utf16(v: &[u16]) -> bool {\n /// of `u16`s.\n #[deriving(Clone)]\n pub struct UTF16Items<'a> {\n-    priv iter: vec::Items<'a, u16>\n+    priv iter: slice::Items<'a, u16>\n }\n /// The possibilities for values decoded from a `u16` stream.\n #[deriving(Eq, TotalEq, Clone, Show)]\n@@ -1025,7 +1025,7 @@ pub fn from_utf16_lossy(v: &[u16]) -> ~str {\n #[inline]\n pub fn with_capacity(capacity: uint) -> ~str {\n     unsafe {\n-        cast::transmute(vec::with_capacity::<~[u8]>(capacity))\n+        cast::transmute(slice::with_capacity::<~[u8]>(capacity))\n     }\n }\n \n@@ -1360,13 +1360,13 @@ pub mod raw {\n     use ptr::RawPtr;\n     use option::{Option, Some, None};\n     use str::{is_utf8, OwnedStr, StrSlice};\n-    use vec;\n-    use vec::{MutableVector, ImmutableVector, OwnedVector};\n+    use slice;\n+    use slice::{MutableVector, ImmutableVector, OwnedVector};\n     use raw::Slice;\n \n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n-        let mut v: ~[u8] = vec::with_capacity(len);\n+        let mut v: ~[u8] = slice::with_capacity(len);\n         ptr::copy_memory(v.as_mut_ptr(), buf, len);\n         v.set_len(len);\n \n@@ -1463,7 +1463,7 @@ pub mod raw {\n     /// The caller must preserve the valid UTF-8 property.\n     #[inline]\n     pub unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) {\n-        vec::bytes::push_bytes(as_owned_vec(s), bytes);\n+        slice::bytes::push_bytes(as_owned_vec(s), bytes);\n     }\n \n     /// Removes the last byte from a string and returns it.\n@@ -2603,7 +2603,7 @@ impl<'a> StrSlice<'a> for &'a str {\n     fn to_owned(&self) -> ~str {\n         let len = self.len();\n         unsafe {\n-            let mut v = vec::with_capacity(len);\n+            let mut v = slice::with_capacity(len);\n \n             ptr::copy_memory(v.as_mut_ptr(), self.as_ptr(), len);\n             v.set_len(len);\n@@ -2766,7 +2766,7 @@ impl<'a> StrSlice<'a> for &'a str {\n         if slen == 0 { return tlen; }\n         if tlen == 0 { return slen; }\n \n-        let mut dcol = vec::from_fn(tlen + 1, |x| x);\n+        let mut dcol = slice::from_fn(tlen + 1, |x| x);\n \n         for (i, sc) in self.chars().enumerate() {\n \n@@ -2921,7 +2921,7 @@ impl OwnedStr for ~str {\n             // Attempt to not use an intermediate buffer by just pushing bytes\n             // directly onto this string.\n             let write_ptr = v.as_mut_ptr().offset(cur_len as int);\n-            let used = vec::raw::mut_buf_as_slice(write_ptr, 4, |slc| c.encode_utf8(slc));\n+            let used = slice::raw::mut_buf_as_slice(write_ptr, 4, |slc| c.encode_utf8(slc));\n \n             v.set_len(cur_len + used);\n         }\n@@ -4667,7 +4667,7 @@ mod bench {\n \n     #[bench]\n     fn from_utf8_lossy_100_invalid(bh: &mut BenchHarness) {\n-        let s = ::vec::from_elem(100, 0xF5u8);\n+        let s = ::slice::from_elem(100, 0xF5u8);\n         bh.iter(|| {\n             let _ = from_utf8_lossy(s);\n         });"}, {"sha": "883e81355e1efef597a75b3ca47a68e2de4390bc", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -27,7 +27,7 @@ use kinds::Send;\n use ops::Drop;\n use ptr::RawPtr;\n use sync::atomics::{fence, AtomicUint, Relaxed, Acquire, Release};\n-use vec;\n+use slice;\n \n /// An atomically reference counted pointer.\n ///\n@@ -69,7 +69,7 @@ impl<T: Send> UnsafeArc<T> {\n                 ~[] // need to free data here\n             } else {\n                 let ptr = new_inner(data, num_handles);\n-                vec::from_fn(num_handles, |_| UnsafeArc { data: ptr })\n+                slice::from_fn(num_handles, |_| UnsafeArc { data: ptr })\n             }\n         }\n     }"}, {"sha": "658ee48af1a96ebd42b219cff75b09ed39cc7015", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -61,7 +61,7 @@ use ptr::RawPtr;\n use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicInt, AtomicPtr, SeqCst};\n use unstable::sync::Exclusive;\n-use vec::{OwnedVector, ImmutableVector};\n+use slice::{OwnedVector, ImmutableVector};\n \n // Once the queue is less than 1/K full, then it will be downsized. Note that\n // the deque requires that this number be less than 2.\n@@ -404,7 +404,7 @@ mod tests {\n     use rand::Rng;\n     use sync::atomics::{AtomicBool, INIT_ATOMIC_BOOL, SeqCst,\n                         AtomicUint, INIT_ATOMIC_UINT};\n-    use vec;\n+    use slice;\n \n     #[test]\n     fn smoke() {\n@@ -600,7 +600,7 @@ mod tests {\n         let mut pool = BufferPool::<(int, uint)>::new();\n         let (mut w, s) = pool.deque();\n \n-        let (threads, hits) = vec::unzip(range(0, NTHREADS).map(|_| {\n+        let (threads, hits) = slice::unzip(range(0, NTHREADS).map(|_| {\n             let s = s.clone();\n             let unique_box = ~AtomicUint::new(0);\n             let thread_box = unsafe {"}, {"sha": "95f592baff0b95c1f233c121f6be0c1febc83f82", "filename": "src/libstd/sync/mpmc_bounded_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -35,7 +35,7 @@ use num::next_power_of_two;\n use option::{Option, Some, None};\n use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicUint,Relaxed,Release,Acquire};\n-use vec;\n+use slice;\n \n struct Node<T> {\n     sequence: AtomicUint,\n@@ -69,8 +69,8 @@ impl<T: Send> State<T> {\n         } else {\n             capacity\n         };\n-        let buffer = vec::from_fn(capacity, |i:uint| {\n-            Node{sequence:AtomicUint::new(i),value:None}\n+        let buffer = slice::from_fn(capacity, |i| {\n+            Node { sequence:AtomicUint::new(i), value: None }\n         });\n         State{\n             pad0: [0, ..64],"}, {"sha": "645db8e040b85a3134e1adafb9cdc89544950dd3", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -13,10 +13,9 @@\n #[allow(missing_doc)];\n #[allow(non_uppercase_statics)];\n \n-\n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use cmp::{Equal, Less, Greater};\n-    use vec::ImmutableVector;\n+    use slice::ImmutableVector;\n     use option::None;\n     r.bsearch(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n@@ -25,7 +24,6 @@ fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     }) != None\n }\n \n-\n pub mod general_category {\n     static Cc_table : &'static [(char,char)] = &[\n         ('\\x00', '\\x1f'), ('\\x7f', '\\x9f')\n@@ -108,7 +106,7 @@ pub mod general_category {\n pub mod decompose {\n     use option::Option;\n     use option::{Some, None};\n-    use vec::ImmutableVector;\n+    use slice::ImmutableVector;\n \n     fn bsearch_table(c: char, r: &'static [(char, &'static [char])]) -> Option<&'static [char]> {\n         use cmp::{Equal, Less, Greater};\n@@ -4136,8 +4134,8 @@ pub mod derived_property {\n     pub fn XID_Start(c: char) -> bool {\n         super::bsearch_range_table(c, XID_Start_table)\n     }\n-\n }\n+\n pub mod property {\n     static White_Space_table : &'static [(char,char)] = &[\n         ('\\x09', '\\x0d'), ('\\x20', '\\x20'),\n@@ -4151,12 +4149,11 @@ pub mod property {\n     pub fn White_Space(c: char) -> bool {\n         super::bsearch_range_table(c, White_Space_table)\n     }\n-\n }\n-pub mod conversions {\n \n+pub mod conversions {\n     use cmp::{Equal, Less, Greater};\n-    use vec::ImmutableVector;\n+    use slice::ImmutableVector;\n     use tuple::Tuple2;\n     use option::{Option, Some, None};\n \n@@ -4181,7 +4178,8 @@ pub mod conversions {\n             else { Greater }\n         })\n     }\n-   static LuLl_table : &'static [(char, char)] = &[\n+\n+    static LuLl_table : &'static [(char, char)] = &[\n         ('\\x41', '\\x61'), ('\\x42', '\\x62'),\n         ('\\x43', '\\x63'), ('\\x44', '\\x64'),\n         ('\\x45', '\\x65'), ('\\x46', '\\x66'),"}, {"sha": "553f528745b2a870c9df979848a940c4b6f64188", "filename": "src/libstd/vec_ng.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fvec_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibstd%2Fvec_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec_ng.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -27,8 +27,8 @@ use ptr::RawPtr;\n use ptr;\n use rt::global_heap::{malloc_raw, realloc_raw};\n use raw::Slice;\n-use vec::{ImmutableEqVector, ImmutableVector, Items, MutItems, MutableVector};\n-use vec::{MutableTotalOrdVector};\n+use slice::{ImmutableEqVector, ImmutableVector, Items, MutItems, MutableVector};\n+use slice::{MutableTotalOrdVector};\n \n /// An owned, growable vector\n ///"}, {"sha": "1d49771ed386aab895da7ecfa196685062f100f2", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -21,11 +21,11 @@\n  * extern crate sync;\n  * extern crate rand;\n  *\n- * use std::vec;\n+ * use std::slice;\n  * use sync::Arc;\n  *\n  * fn main() {\n- *     let numbers = vec::from_fn(100, |i| (i as f32) * rand::random());\n+ *     let numbers = slice::from_fn(100, |i| (i as f32) * rand::random());\n  *     let shared_numbers = Arc::new(numbers);\n  *\n  *     for _ in range(0, 10) {"}, {"sha": "7670e9cf50aa22d5d64e7623bb5691733488fc04", "filename": "src/libsync/task_pool.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Ftask_pool.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -13,9 +13,8 @@\n /// A task pool abstraction. Useful for achieving predictable CPU\n /// parallelism.\n \n-\n use std::task;\n-use std::vec;\n+use std::slice;\n \n enum Msg<T> {\n     Execute(proc(&T)),\n@@ -47,7 +46,7 @@ impl<T> TaskPool<T> {\n                -> TaskPool<T> {\n         assert!(n_tasks >= 1);\n \n-        let channels = vec::from_fn(n_tasks, |i| {\n+        let channels = slice::from_fn(n_tasks, |i| {\n             let (tx, rx) = channel::<Msg<T>>();\n             let init_fn = init_fn_factory();\n "}, {"sha": "77b0d4b5c9da5f425d8fcc584b0c0930d3175a46", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -520,7 +520,7 @@ pub enum Expr_ {\n     ExprIndex(@Expr, @Expr),\n \n     /// Expression that looks like a \"name\". For example,\n-    /// `std::vec::from_elem::<uint>` is an ExprPath that's the \"name\" part\n+    /// `std::slice::from_elem::<uint>` is an ExprPath that's the \"name\" part\n     /// of a function call.\n     ExprPath(Path),\n "}, {"sha": "bfe3f83369537ffbc8294b8dbadb6f646a0d2206", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -20,7 +20,7 @@ use util::small_vector::SmallVector;\n \n use std::cell::RefCell;\n use std::iter;\n-use std::vec;\n+use std::slice;\n use std::fmt;\n use std::vec_ng::Vec;\n \n@@ -65,9 +65,9 @@ impl<'a> Iterator<PathElem> for LinkedPath<'a> {\n     }\n }\n \n-// HACK(eddyb) move this into libstd (value wrapper for vec::Items).\n+// HACK(eddyb) move this into libstd (value wrapper for slice::Items).\n #[deriving(Clone)]\n-pub struct Values<'a, T>(vec::Items<'a, T>);\n+pub struct Values<'a, T>(slice::Items<'a, T>);\n \n impl<'a, T: Pod> Iterator<T> for Values<'a, T> {\n     fn next(&mut self) -> Option<T> {"}, {"sha": "3bfc4f6e51d467c7244de903b398ab6f3344c913", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -20,7 +20,7 @@ use rsparse = parse;\n \n use std::fmt::parse;\n use collections::{HashMap, HashSet};\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n \n #[deriving(Eq)]\n@@ -610,7 +610,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn to_expr(&self, extra: @ast::Expr) -> @ast::Expr {\n         let mut lets = Vec::new();\n         let mut locals = Vec::new();\n-        let mut names = vec::from_fn(self.name_positions.len(), |_| None);\n+        let mut names = slice::from_fn(self.name_positions.len(), |_| None);\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n "}, {"sha": "aee387d6d962c23ecb86376e17bfc53f5feb9a15", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -16,7 +16,7 @@\n  */\n \n use std::default::Default;\n-use std::vec;\n+use std::slice;\n use std::vec_ng::Vec;\n \n #[deriving(Clone, Encodable, Decodable, Hash)]\n@@ -176,7 +176,7 @@ impl<T> Default for OptVec<T> {\n }\n \n pub struct Items<'a, T> {\n-    priv iter: Option<vec::Items<'a, T>>\n+    priv iter: Option<slice::Items<'a, T>>\n }\n \n impl<'a, T> Iterator<&'a T> for Items<'a, T> {"}, {"sha": "ee14b90fbfdf9bb3c59b4cd5c890cb976a8bb75b", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -10,7 +10,7 @@\n \n //! Parameterized string expansion\n \n-use std::{char, vec};\n+use std::{char, slice};\n use std::mem::replace;\n \n #[deriving(Eq)]\n@@ -93,7 +93,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n     let mut state = Nothing;\n \n     // expanded cap will only rarely be larger than the cap itself\n-    let mut output = vec::with_capacity(cap.len());\n+    let mut output = slice::with_capacity(cap.len());\n \n     let mut stack: ~[Param] = ~[];\n \n@@ -488,7 +488,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n                 (FormatString, _)    => return Err(~\"non-number on stack with %s\"),\n             };\n             if flags.precision > s.len() {\n-                let mut s_ = vec::with_capacity(flags.precision);\n+                let mut s_ = slice::with_capacity(flags.precision);\n                 let n = flags.precision - s.len();\n                 s_.grow(n, &('0' as u8));\n                 s_.push_all_move(s);\n@@ -543,7 +543,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n         if flags.left {\n             s.grow(n, &(' ' as u8));\n         } else {\n-            let mut s_ = vec::with_capacity(flags.width);\n+            let mut s_ = slice::with_capacity(flags.width);\n             s_.grow(n, &(' ' as u8));\n             s_.push_all_move(s);\n             s = s_;"}, {"sha": "cc97e54709c81e70d835c06e533aa9e8c3fa2a72", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -13,7 +13,7 @@\n /// ncurses-compatible compiled terminfo format parsing (term(5))\n \n \n-use std::{vec, str};\n+use std::{slice, str};\n use std::io;\n use collections::HashMap;\n use super::super::TermInfo;\n@@ -246,7 +246,7 @@ pub fn parse(file: &mut io::Reader,\n     let mut string_map = HashMap::new();\n \n     if string_offsets_count != 0 {\n-        let mut string_offsets = vec::with_capacity(10);\n+        let mut string_offsets = slice::with_capacity(10);\n         for _ in range(0, string_offsets_count) {\n             string_offsets.push(try!(file.read_le_u16()));\n         }"}, {"sha": "120b790d46753234ed31fcd52b43bb5678a5e53b", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -1035,7 +1035,7 @@ mod tests {\n #[cfg(test)]\n mod bench {\n     use BenchHarness;\n-    use std::vec;\n+    use std::slice;\n     use stats::Stats;\n \n     #[bench]\n@@ -1047,7 +1047,7 @@ mod bench {\n     #[bench]\n     pub fn sum_many_f64(bh: &mut BenchHarness) {\n         let nums = [-1e30, 1e60, 1e30, 1.0, -1e60];\n-        let v = vec::from_fn(500, |i| nums[i%5]);\n+        let v = slice::from_fn(500, |i| nums[i%5]);\n \n         bh.iter(|| {\n             v.sum();"}, {"sha": "7aed4cd3d9b32cf40f4b6e28fb7c99ec8ecfc603", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -85,7 +85,7 @@ use std::from_str::FromStr;\n use std::hash::Hash;\n use std::num::FromStrRadix;\n use std::str;\n-use std::vec;\n+use std::slice;\n \n use rand::Rng;\n \n@@ -202,7 +202,7 @@ impl Uuid {\n     pub fn new_v4() -> Uuid {\n         let ub = rand::task_rng().gen_vec(16);\n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n-        vec::bytes::copy_memory(uuid.bytes, ub);\n+        slice::bytes::copy_memory(uuid.bytes, ub);\n         uuid.set_variant(VariantRFC4122);\n         uuid.set_version(Version4Random);\n         uuid\n@@ -229,7 +229,7 @@ impl Uuid {\n         fields.data1 = to_be32(d1 as i32) as u32;\n         fields.data2 = to_be16(d2 as i16) as u16;\n         fields.data3 = to_be16(d3 as i16) as u16;\n-        vec::bytes::copy_memory(fields.data4, d4);\n+        slice::bytes::copy_memory(fields.data4, d4);\n \n         unsafe {\n             transmute(fields)\n@@ -246,7 +246,7 @@ impl Uuid {\n         }\n \n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n-        vec::bytes::copy_memory(uuid.bytes, b);\n+        slice::bytes::copy_memory(uuid.bytes, b);\n         Some(uuid)\n     }\n \n@@ -329,7 +329,7 @@ impl Uuid {\n     ///\n     /// Example: `936DA01F9ABD4d9d80C702AF85C822A8`\n     pub fn to_simple_str(&self) -> ~str {\n-        let mut s: ~[u8] = vec::from_elem(32, 0u8);\n+        let mut s: ~[u8] = slice::from_elem(32, 0u8);\n         for i in range(0u, 16u) {\n             let digit = format!(\"{:02x}\", self.bytes[i] as uint);\n             s[i*2+0] = digit[0];\n@@ -523,7 +523,7 @@ impl rand::Rand for Uuid {\n     fn rand<R: rand::Rng>(rng: &mut R) -> Uuid {\n         let ub = rng.gen_vec(16);\n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n-        vec::bytes::copy_memory(uuid.bytes, ub);\n+        slice::bytes::copy_memory(uuid.bytes, ub);\n         uuid.set_variant(VariantRFC4122);\n         uuid.set_version(Version4Random);\n         uuid"}, {"sha": "9f91284a413815108f799812a8c1488b7fb40db0", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -16,7 +16,7 @@ use collections::{TrieMap, TreeMap, HashMap, HashSet};\n use std::os;\n use rand::{Rng, IsaacRng, SeedableRng};\n use std::uint;\n-use std::vec;\n+use std::slice;\n \n fn timed(label: &str, f: ||) {\n     let start = time::precise_time_s();\n@@ -99,7 +99,7 @@ fn main() {\n         }\n     };\n \n-    let mut rand = vec::with_capacity(n_keys);\n+    let mut rand = slice::with_capacity(n_keys);\n \n     {\n         let mut rng: IsaacRng = SeedableRng::from_seed(&[1, 1, 1, 1, 1, 1, 1]);"}, {"sha": "6bf145e7976bcb42da676fdf8fd13912fe05eae8", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -20,7 +20,7 @@ use rand::Rng;\n use std::mem::swap;\n use std::os;\n use std::str;\n-use std::vec;\n+use std::slice;\n use std::io::File;\n \n macro_rules! bench (\n@@ -61,7 +61,7 @@ fn maybe_run_test(argv: &[~str], name: ~str, test: ||) {\n }\n \n fn shift_push() {\n-    let mut v1 = vec::from_elem(30000, 1);\n+    let mut v1 = slice::from_elem(30000, 1);\n     let mut v2 = ~[];\n \n     while v1.len() > 0 {\n@@ -88,7 +88,7 @@ fn vec_plus() {\n     let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = vec::from_elem(r.gen_range(0u, i + 1), i);\n+        let rv = slice::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n             v.push_all_move(rv);\n         } else {\n@@ -104,12 +104,12 @@ fn vec_append() {\n     let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = vec::from_elem(r.gen_range(0u, i + 1), i);\n+        let rv = slice::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n-            v = vec::append(v, rv);\n+            v = slice::append(v, rv);\n         }\n         else {\n-            v = vec::append(rv, v);\n+            v = slice::append(rv, v);\n         }\n         i += 1;\n     }\n@@ -120,7 +120,7 @@ fn vec_push_all() {\n \n     let mut v = ~[];\n     for i in range(0u, 1500) {\n-        let mut rv = vec::from_elem(r.gen_range(0u, i + 1), i);\n+        let mut rv = slice::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n             v.push_all(rv);\n         }"}, {"sha": "8d860206d0cd43b02beeeb5758962ffcec0b7b3f", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::os;\n-use std::vec;\n+use std::slice;\n \n fn max(a: i32, b: i32) -> i32 {\n     if a > b {\n@@ -20,9 +20,9 @@ fn max(a: i32, b: i32) -> i32 {\n }\n \n fn fannkuch_redux(n: i32) -> i32 {\n-    let mut perm = vec::from_elem(n as uint, 0i32);\n-    let mut perm1 = vec::from_fn(n as uint, |i| i as i32);\n-    let mut count = vec::from_elem(n as uint, 0i32);\n+    let mut perm = slice::from_elem(n as uint, 0i32);\n+    let mut perm1 = slice::from_fn(n as uint, |i| i as i32);\n+    let mut count = slice::from_elem(n as uint, 0i32);\n     let mut max_flips_count = 0i32;\n     let mut perm_count = 0i32;\n     let mut checksum = 0i32;"}, {"sha": "fead298bc8624eb36321e1985d127ef0ad1e6169", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -11,8 +11,8 @@\n use std::cmp::min;\n use std::io::{stdout, IoResult};\n use std::os;\n-use std::vec::bytes::copy_memory;\n-use std::vec;\n+use std::slice::bytes::copy_memory;\n+use std::slice;\n \n static LINE_LEN: uint = 60;\n static LOOKUP_SIZE: uint = 4 * 1024;\n@@ -89,7 +89,7 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n \n     fn make(&mut self, n: uint) -> IoResult<()> {\n         let alu_len = self.alu.len();\n-        let mut buf = vec::from_elem(alu_len + LINE_LEN, 0u8);\n+        let mut buf = slice::from_elem(alu_len + LINE_LEN, 0u8);\n         let alu: &[u8] = self.alu.as_bytes();\n \n         copy_memory(buf, alu);"}, {"sha": "0b5a19aaec87c30f8af325c732b871113531a20e", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -24,7 +24,7 @@ use std::os;\n use std::io;\n use std::str;\n use std::task;\n-use std::vec;\n+use std::slice;\n \n fn f64_cmp(x: f64, y: f64) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n@@ -157,7 +157,7 @@ fn main() {\n \n     // initialize each sequence sorter\n     let sizes = ~[1u,2,3,4,6,12,18];\n-    let mut streams = vec::from_fn(sizes.len(), |_| Some(channel::<~str>()));\n+    let mut streams = slice::from_fn(sizes.len(), |_| Some(channel::<~str>()));\n     let mut from_child = ~[];\n     let to_child  = sizes.iter().zip(streams.mut_iter()).map(|(sz, stream_ref)| {\n         let sz = *sz;"}, {"sha": "1a981480ebe535b2c95f81ba7edef48a4da7070f", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -11,7 +11,7 @@\n // ignore-pretty\n \n use std::str;\n-use std::vec;\n+use std::slice;\n \n static TABLE: [u8, ..4] = [ 'A' as u8, 'C' as u8, 'G' as u8, 'T' as u8 ];\n static TABLE_SIZE: uint = 2 << 16;\n@@ -97,14 +97,14 @@ struct Table {\n \n struct Items<'a> {\n     cur: Option<&'a Entry>,\n-    items: vec::Items<'a, Option<~Entry>>,\n+    items: slice::Items<'a, Option<~Entry>>,\n }\n \n impl Table {\n     fn new() -> Table {\n         Table {\n             count: 0,\n-            items: vec::from_fn(TABLE_SIZE, |_| None),\n+            items: slice::from_fn(TABLE_SIZE, |_| None),\n         }\n     }\n "}, {"sha": "97f2c88751595fe85da5bcc546fdfd5c3f081218", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -180,7 +180,7 @@ fn get_id(m: u64) -> u8 {\n \n // Converts a list of mask to a ~str.\n fn to_utf8(raw_sol: &List<u64>) -> ~str {\n-    let mut sol: ~[u8] = std::vec::from_elem(50, '.' as u8);\n+    let mut sol: ~[u8] = std::slice::from_elem(50, '.' as u8);\n     for &m in raw_sol.iter() {\n         let id = get_id(m);\n         for i in range(0, 50) {"}, {"sha": "ea8253f6e42373d2169378ab748192e08681f8f2", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -14,7 +14,7 @@ use std::from_str::FromStr;\n use std::iter::count;\n use std::cmp::min;\n use std::os;\n-use std::vec::from_elem;\n+use std::slice::from_elem;\n use sync::RWArc;\n \n fn A(i: uint, j: uint) -> f64 {"}, {"sha": "ba94290bd03c9f7ad3a7779fe0bcabcd91c24943", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -17,7 +17,7 @@ use std::io::stdio::StdReader;\n use std::io::BufferedReader;\n use std::os;\n use std::intrinsics::cttz16;\n-use std::vec;\n+use std::slice;\n \n // Computes a single solution to a given 9x9 sudoku\n //\n@@ -48,8 +48,8 @@ impl Sudoku {\n     }\n \n     pub fn from_vec(vec: &[[u8, ..9], ..9]) -> Sudoku {\n-        let g = vec::from_fn(9u, |i| {\n-            vec::from_fn(9u, |j| { vec[i][j] })\n+        let g = slice::from_fn(9u, |i| {\n+            slice::from_fn(9u, |j| { vec[i][j] })\n         });\n         return Sudoku::new(g)\n     }\n@@ -68,7 +68,7 @@ impl Sudoku {\n     pub fn read(mut reader: BufferedReader<StdReader>) -> Sudoku {\n         assert!(reader.read_line().unwrap() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n \n-        let mut g = vec::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n+        let mut g = slice::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n         for line in reader.lines() {\n             let comps: ~[&str] = line.unwrap().trim().split(',').collect();\n "}, {"sha": "75975b76ecbd22b2e3e7ccfd678ae767a58d8df0", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -15,11 +15,11 @@\n use std::os;\n use std::task;\n use std::uint;\n-use std::vec;\n+use std::slice;\n \n fn calc(children: uint, parent_wait_chan: &Sender<Sender<Sender<int>>>) {\n \n-    let wait_ports: ~[Receiver<Sender<Sender<int>>>] = vec::from_fn(children, |_| {\n+    let wait_ports: ~[Receiver<Sender<Sender<int>>>] = slice::from_fn(children, |_| {\n         let (wait_port, wait_chan) = stream::<Sender<Sender<int>>>();\n         task::spawn(proc() {\n             calc(children / 2, &wait_chan);"}, {"sha": "e73e1eacc7ce80823ac5522e1fdb75476e267aca", "filename": "src/test/compile-fail/lint-deprecated-owned-vector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fcompile-fail%2Flint-deprecated-owned-vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fcompile-fail%2Flint-deprecated-owned-vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-deprecated-owned-vector.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -13,5 +13,5 @@\n fn main() {\n     ~[1]; //~ ERROR use of deprecated `~[]`\n     //~^ ERROR use of deprecated `~[]`\n-    std::vec::with_capacity::<int>(10); //~ ERROR use of deprecated `~[]`\n+    std::slice::with_capacity::<int>(10); //~ ERROR use of deprecated `~[]`\n }"}, {"sha": "e4d9048ca8d51923b5f1767727291e1cea35d77f", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -29,7 +29,7 @@ use test::B;\n \n // Make sure this import is warned about when at least one of its imported names\n // is unused\n-use std::vec::{from_fn, from_elem};   //~ ERROR unused import\n+use std::slice::{from_fn, from_elem};   //~ ERROR unused import\n \n mod test {\n     pub trait A { fn a(&self) {} }"}, {"sha": "05a6c0f6bbd26caf1157ee971131a8d64a671a44", "filename": "src/test/compile-fail/liveness-issue-2163.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n+use std::slice;\n \n fn main() {\n     let a: ~[int] = ~[];"}, {"sha": "dc66c888402272810136c5ec8a0a2749fbf6e511", "filename": "src/test/run-pass/import-glob-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -13,7 +13,7 @@\n #[feature(globs)];\n #[allow(dead_assignment)];\n \n-use std::vec::*;\n+use std::slice::*;\n \n pub fn main() {\n     let mut v = from_elem(0u, 0);"}, {"sha": "bfb9f54b9672db228cd5e3c43d7b0a43ffb87959", "filename": "src/test/run-pass/issue-2989.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Frun-pass%2Fissue-2989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Frun-pass%2Fissue-2989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2989.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -8,22 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n+use std::slice;\n \n trait methods {\n     fn to_bytes(&self) -> ~[u8];\n }\n \n impl methods for () {\n     fn to_bytes(&self) -> ~[u8] {\n-        vec::from_elem(0, 0u8)\n+        slice::from_elem(0, 0u8)\n     }\n }\n \n // the position of this function is significant! - if it comes before methods\n // then it works, if it comes after it then it doesn't!\n fn to_bools(bitv: Storage) -> ~[bool] {\n-    vec::from_fn(8, |i| {\n+    slice::from_fn(8, |i| {\n         let w = i / 64;\n         let b = i % 64;\n         let x = 1u64 & (bitv.storage[w] >> b);"}, {"sha": "d06d00a130eba77e1459ef63dce378f5763bb3f3", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -20,7 +20,7 @@\n // Extern mod controls linkage. Use controls the visibility of names to modules that are\n // already linked in. Using WriterUtil allows us to use the write_line method.\n use std::str;\n-use std::vec;\n+use std::slice;\n use std::fmt;\n \n // Represents a position on a canvas.\n@@ -62,8 +62,8 @@ impl Drop for AsciiArt {\n fn AsciiArt(width: uint, height: uint, fill: char) -> AsciiArt {\n     // Use an anonymous function to build a vector of vectors containing\n     // blank characters for each position in our canvas.\n-    let lines = vec::build(Some(height), |push| {\n-        for _ in range(0, height) { push(vec::from_elem(width, '.')); }\n+    let lines = slice::build(Some(height), |push| {\n+        for _ in range(0, height) { push(slice::from_elem(width, '.')); }\n     });\n \n     // Rust code often returns values by omitting the trailing semi-colon"}, {"sha": "e9fb74b4e6e7b13379f4308affed0e5ddebfd71b", "filename": "src/test/run-pass/mod-view-items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Frun-pass%2Fmod-view-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Frun-pass%2Fmod-view-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod-view-items.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -17,8 +17,8 @@\n // begin failing.\n \n mod m {\n-    use std::vec;\n-    pub fn f() -> ~[int] { vec::from_elem(1u, 0) }\n+    use std::slice;\n+    pub fn f() -> ~[int] { slice::from_elem(1u, 0) }\n }\n \n pub fn main() { let _x = m::f(); }"}, {"sha": "54791ddd4192e7a774fa456409f290f71d9f5151", "filename": "src/test/run-pass/uninit-empty-types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Frun-pass%2Funinit-empty-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aded2adb6782d8188a631250ab8d72c82bd070c/src%2Ftest%2Frun-pass%2Funinit-empty-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funinit-empty-types.rs?ref=7aded2adb6782d8188a631250ab8d72c82bd070c", "patch": "@@ -10,7 +10,6 @@\n \n // Test the uninit() construct returning various empty types.\n \n-use std::vec;\n use std::mem;\n \n #[deriving(Clone)]"}]}