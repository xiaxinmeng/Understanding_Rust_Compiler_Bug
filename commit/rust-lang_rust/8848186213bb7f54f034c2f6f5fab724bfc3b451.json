{"sha": "8848186213bb7f54f034c2f6f5fab724bfc3b451", "node_id": "C_kwDOAAsO6NoAKDg4NDgxODYyMTNiYjdmNTRmMDM0YzJmNmY1ZmFiNzI0YmZjM2I0NTE", "commit": {"author": {"name": "Moritz Vetter", "email": "mv@3yourmind.com", "date": "2022-02-24T17:56:08Z"}, "committer": {"name": "Moritz Vetter", "email": "mv@3yourmind.com", "date": "2022-02-24T18:00:08Z"}, "message": "fix(11422): have two different funuctions - one for iterating breaks, one for iteraating breaks and continues", "tree": {"sha": "a2714df030c96f77bf8ca9e9d26bef3c02f61a35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2714df030c96f77bf8ca9e9d26bef3c02f61a35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8848186213bb7f54f034c2f6f5fab724bfc3b451", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8848186213bb7f54f034c2f6f5fab724bfc3b451", "html_url": "https://github.com/rust-lang/rust/commit/8848186213bb7f54f034c2f6f5fab724bfc3b451", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8848186213bb7f54f034c2f6f5fab724bfc3b451/comments", "author": null, "committer": null, "parents": [{"sha": "3da08071ce13da084acdbb99272e6b85d7fd116d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3da08071ce13da084acdbb99272e6b85d7fd116d", "html_url": "https://github.com/rust-lang/rust/commit/3da08071ce13da084acdbb99272e6b85d7fd116d"}], "stats": {"total": 153, "additions": 104, "deletions": 49}, "files": [{"sha": "944b69c1acf4ad6e01d4dafb357fb0a12933c051", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 100, "deletions": 46, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/8848186213bb7f54f034c2f6f5fab724bfc3b451/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8848186213bb7f54f034c2f6f5fab724bfc3b451/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=8848186213bb7f54f034c2f6f5fab724bfc3b451", "patch": "@@ -16,7 +16,8 @@ use hir::{ItemInNs, MacroDef, ModuleDef, Name, Semantics};\n use itertools::Itertools;\n use syntax::{\n     ast::{self, make, HasLoopBody},\n-    AstNode, AstToken, SyntaxKind, SyntaxToken, TokenAtOffset, WalkEvent, T,\n+    AstNode, AstToken, Preorder, RustLanguage, SyntaxKind, SyntaxToken, TokenAtOffset, WalkEvent,\n+    T,\n };\n \n use crate::{defs::Definition, RootDatabase};\n@@ -120,7 +121,9 @@ pub fn for_each_tail_expr(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n                 ) => return cb(expr),\n \n                 Some(ast::BlockModifier::Label(label)) => {\n-                    for_each_break_and_continue_expr(Some(label), b.stmt_list(), &mut |b| cb(&b));\n+                    for_each_break_expr(Some(label), b.stmt_list(), &mut |b| {\n+                        cb(&ast::Expr::BreakExpr(b))\n+                    });\n                 }\n                 Some(ast::BlockModifier::Unsafe(_)) => (),\n                 None => (),\n@@ -147,16 +150,14 @@ pub fn for_each_tail_expr(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n                 }\n             }\n         }\n-        ast::Expr::LoopExpr(l) => for_each_break_and_continue_expr(\n-            l.label(),\n-            l.loop_body().and_then(|it| it.stmt_list()),\n-            &mut |b| cb(&b),\n-        ),\n+        ast::Expr::LoopExpr(l) => {\n+            for_each_break_expr(l.label(), l.loop_body().and_then(|it| it.stmt_list()), &mut |b| {\n+                cb(&ast::Expr::BreakExpr(b))\n+            })\n+        }\n         ast::Expr::MatchExpr(m) => {\n             if let Some(arms) = m.match_arm_list() {\n-                arms.arms()\n-                    .filter_map(|arm| arm.expr())\n-                    .for_each(|e| for_each_tail_expr(&e, &mut |b| cb(&b)));\n+                arms.arms().filter_map(|arm| arm.expr()).for_each(|e| for_each_tail_expr(&e, cb));\n             }\n         }\n         ast::Expr::ArrayExpr(_)\n@@ -190,51 +191,104 @@ pub fn for_each_tail_expr(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n     }\n }\n \n-/// Calls `cb` on each break expr and continue expr inside of `body` that is applicable for the given label.\n pub fn for_each_break_and_continue_expr(\n     label: Option<ast::Label>,\n     body: Option<ast::StmtList>,\n     cb: &mut dyn FnMut(ast::Expr),\n ) {\n     let label = label.and_then(|lbl| lbl.lifetime());\n-    let mut depth = 0;\n     if let Some(b) = body {\n-        let preorder = &mut b.syntax().preorder();\n-        let ev_as_expr = |ev| match ev {\n-            WalkEvent::Enter(it) => Some(WalkEvent::Enter(ast::Expr::cast(it)?)),\n-            WalkEvent::Leave(it) => Some(WalkEvent::Leave(ast::Expr::cast(it)?)),\n-        };\n-        let eq_label = |lt: Option<ast::Lifetime>| {\n-            lt.zip(label.as_ref()).map_or(false, |(lt, lbl)| lt.text() == lbl.text())\n-        };\n-        while let Some(node) = preorder.find_map(ev_as_expr) {\n-            match node {\n-                WalkEvent::Enter(expr) => match expr {\n-                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_) => {\n-                        depth += 1\n-                    }\n-                    ast::Expr::BlockExpr(e) if e.label().is_some() => depth += 1,\n-                    ast::Expr::BreakExpr(b)\n-                        if (depth == 0 && b.lifetime().is_none()) || eq_label(b.lifetime()) =>\n-                    {\n-                        cb(ast::Expr::BreakExpr(b));\n-                    }\n-                    ast::Expr::ContinueExpr(c)\n-                        if (depth == 0 && c.lifetime().is_none()) || eq_label(c.lifetime()) =>\n-                    {\n-                        cb(ast::Expr::ContinueExpr(c))\n-                    }\n-                    _ => (),\n-                },\n-                WalkEvent::Leave(expr) => match expr {\n-                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_) => {\n-                        depth -= 1\n-                    }\n-                    ast::Expr::BlockExpr(e) if e.label().is_some() => depth -= 1,\n-                    _ => (),\n-                },\n+        let tree_depth_iterator = TreeWithDepthIterator::new(b);\n+        for (expr, depth) in tree_depth_iterator {\n+            match expr {\n+                ast::Expr::BreakExpr(b)\n+                    if (depth == 0 && b.lifetime().is_none())\n+                        || eq_label_lt(&label, &b.lifetime()) =>\n+                {\n+                    cb(ast::Expr::BreakExpr(b));\n+                }\n+                ast::Expr::ContinueExpr(c)\n+                    if (depth == 0 && c.lifetime().is_none())\n+                        || eq_label_lt(&label, &c.lifetime()) =>\n+                {\n+                    cb(ast::Expr::ContinueExpr(c));\n+                }\n+                _ => (),\n+            }\n+        }\n+    }\n+}\n+\n+fn for_each_break_expr(\n+    label: Option<ast::Label>,\n+    body: Option<ast::StmtList>,\n+    cb: &mut dyn FnMut(ast::BreakExpr),\n+) {\n+    let label = label.and_then(|lbl| lbl.lifetime());\n+    if let Some(b) = body {\n+        let tree_depth_iterator = TreeWithDepthIterator::new(b);\n+        for (expr, depth) in tree_depth_iterator {\n+            match expr {\n+                ast::Expr::BreakExpr(b)\n+                    if (depth == 0 && b.lifetime().is_none())\n+                        || eq_label_lt(&label, &b.lifetime()) =>\n+                {\n+                    cb(b);\n+                }\n+                _ => (),\n+            }\n+        }\n+    }\n+}\n+\n+fn eq_label_lt(lt1: &Option<ast::Lifetime>, lt2: &Option<ast::Lifetime>) -> bool {\n+    lt1.as_ref().zip(lt2.as_ref()).map_or(false, |(lt, lbl)| lt.text() == lbl.text())\n+}\n+\n+struct TreeWithDepthIterator {\n+    preorder: Preorder<RustLanguage>,\n+    depth: i32,\n+}\n+\n+impl TreeWithDepthIterator {\n+    fn new(body: ast::StmtList) -> Self {\n+        let preorder = body.syntax().preorder();\n+        Self { preorder, depth: 0 }\n+    }\n+}\n+\n+impl<'a> Iterator for TreeWithDepthIterator {\n+    type Item = (ast::Expr, i32);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        while let Some((event, expr)) = self.preorder.find_map(|ev| match ev {\n+            WalkEvent::Enter(it) => Some(WalkEvent::Enter(())).zip(ast::Expr::cast(it)),\n+            WalkEvent::Leave(it) => Some(WalkEvent::Leave(())).zip(ast::Expr::cast(it)),\n+        }) {\n+            match (event, expr) {\n+                (\n+                    WalkEvent::Enter(_),\n+                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_),\n+                ) => {\n+                    self.depth += 1;\n+                }\n+                (\n+                    WalkEvent::Leave(_),\n+                    ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_),\n+                ) => {\n+                    self.depth -= 1;\n+                }\n+                (WalkEvent::Enter(_), ast::Expr::BlockExpr(e)) if e.label().is_some() => {\n+                    self.depth += 1;\n+                }\n+                (WalkEvent::Leave(_), ast::Expr::BlockExpr(e)) if e.label().is_some() => {\n+                    self.depth -= 1;\n+                }\n+                (WalkEvent::Enter(_), expr) => return Some((expr, self.depth)),\n+                _ => (),\n             }\n         }\n+        None\n     }\n }\n "}, {"sha": "e30f6cd79c3edadd5fb31eb86216c8b7932a3912", "filename": "crates/syntax/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8848186213bb7f54f034c2f6f5fab724bfc3b451/crates%2Fsyntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8848186213bb7f54f034c2f6f5fab724bfc3b451/crates%2Fsyntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Flib.rs?ref=8848186213bb7f54f034c2f6f5fab724bfc3b451", "patch": "@@ -52,14 +52,15 @@ pub use crate::{\n     ptr::{AstPtr, SyntaxNodePtr},\n     syntax_error::SyntaxError,\n     syntax_node::{\n-        PreorderWithTokens, SyntaxElement, SyntaxElementChildren, SyntaxNode, SyntaxNodeChildren,\n-        SyntaxToken, SyntaxTreeBuilder,\n+        PreorderWithTokens, RustLanguage, SyntaxElement, SyntaxElementChildren, SyntaxNode,\n+        SyntaxNodeChildren, SyntaxToken, SyntaxTreeBuilder,\n     },\n     token_text::TokenText,\n };\n pub use parser::{SyntaxKind, T};\n pub use rowan::{\n-    Direction, GreenNode, NodeOrToken, SyntaxText, TextRange, TextSize, TokenAtOffset, WalkEvent,\n+    api::Preorder, Direction, GreenNode, NodeOrToken, SyntaxText, TextRange, TextSize,\n+    TokenAtOffset, WalkEvent,\n };\n pub use smol_str::SmolStr;\n "}]}