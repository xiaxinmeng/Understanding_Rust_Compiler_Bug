{"sha": "92d63ffa65b801e43b91927f8b23f0767bc42cd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZDYzZmZhNjViODAxZTQzYjkxOTI3ZjhiMjNmMDc2N2JjNDJjZDI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-27T10:02:01Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-27T15:31:15Z"}, "message": "Make trans_rec and trans_tup understand overwrite dests\n\nIssue #667", "tree": {"sha": "2ecbade3daca1f76f4187e47026063fcba6f2af1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ecbade3daca1f76f4187e47026063fcba6f2af1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92d63ffa65b801e43b91927f8b23f0767bc42cd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92d63ffa65b801e43b91927f8b23f0767bc42cd2", "html_url": "https://github.com/rust-lang/rust/commit/92d63ffa65b801e43b91927f8b23f0767bc42cd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92d63ffa65b801e43b91927f8b23f0767bc42cd2/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8282f7fe805087f26ed60a6a5cba0abe50637d39", "url": "https://api.github.com/repos/rust-lang/rust/commits/8282f7fe805087f26ed60a6a5cba0abe50637d39", "html_url": "https://github.com/rust-lang/rust/commit/8282f7fe805087f26ed60a6a5cba0abe50637d39"}], "stats": {"total": 99, "additions": 54, "deletions": 45}, "files": [{"sha": "d9b635276f8a1ddcf89b1d9c273dda86c96a2992", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 54, "deletions": 45, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/92d63ffa65b801e43b91927f8b23f0767bc42cd2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d63ffa65b801e43b91927f8b23f0767bc42cd2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=92d63ffa65b801e43b91927f8b23f0767bc42cd2", "patch": "@@ -4029,30 +4029,56 @@ fn trans_landing_pad(bcx: @block_ctxt,\n fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n     let t = node_id_type(bcx.fcx.lcx.ccx, id);\n+    let (addr, overwrite) = alt dest {\n+      ignore. {\n+        for ex in elts { bcx = trans_expr_dps(bcx, ex, ignore); }\n+        ret bcx;\n+      }\n+      save_in(pos) { (pos, none) }\n+      overwrite(pos, _) {\n+        let scratch = alloca(bcx, val_ty(pos));\n+        (scratch, some(pos))\n+      }\n+    };\n     let temp_cleanups = [], i = 0;\n     for e in elts {\n-        alt dest {\n-          save_in(addr) {\n-            let dst = GEP_tup_like_1(bcx, t, addr, [0, i]);\n-            let e_ty = ty::expr_ty(bcx_tcx(bcx), e);\n-            bcx = trans_expr_save_in(dst.bcx, e, dst.val);\n-            add_clean_temp_mem(bcx, dst.val, e_ty);\n-            temp_cleanups += [dst.val];\n-          }\n-          ignore. {\n-            bcx = trans_expr_dps(bcx, e, ignore);\n-          }\n-        }\n+        let dst = GEP_tup_like_1(bcx, t, addr, [0, i]);\n+        let e_ty = ty::expr_ty(bcx_tcx(bcx), e);\n+        bcx = trans_expr_save_in(dst.bcx, e, dst.val);\n+        add_clean_temp_mem(bcx, dst.val, e_ty);\n+        temp_cleanups += [dst.val];\n         i += 1;\n     }\n     for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n+    alt overwrite {\n+      some(pos) {\n+        bcx = drop_ty(bcx, pos, t);\n+        bcx = memmove_ty(bcx, pos, addr, t);\n+      }\n+      none. {}\n+    }\n     ret bcx;\n }\n \n fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n              base: option::t<@ast::expr>, id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n     let t = node_id_type(bcx_ccx(bcx), id);\n+    let (addr, overwrite) = alt dest {\n+      ignore. {\n+        for fld in fields {\n+            bcx = trans_expr_dps(bcx, fld.node.expr, ignore);\n+        }\n+        ret bcx;\n+      }\n+      save_in(pos) { (pos, none) }\n+      // The expressions that populate the fields might still use the old\n+      // record, so we build the new on in a scratch area\n+      overwrite(pos, _) {\n+        let scratch = alloca(bcx, val_ty(pos));\n+        (scratch, some(pos))\n+      }\n+    };\n \n     let base_val = alt base {\n       some(bexp) {\n@@ -4063,55 +4089,38 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n       none. { C_nil() }\n     };\n \n-    let ty_fields = alt ty::struct(bcx_tcx(bcx), t) {\n-        ty::ty_rec(f) { f }\n-        ty::ty_bot. {\n-          bcx_ccx(bcx).sess.bug(\"https://github.com/graydon/rust/issues/924\")\n-        }\n-    };\n+    let ty_fields = alt ty::struct(bcx_tcx(bcx), t) { ty::ty_rec(f) { f } };\n     let temp_cleanups = [], i = 0;\n     for tf in ty_fields {\n-        let fdest = alt dest {\n-          save_in(addr) {\n-            let gep = GEP_tup_like_1(bcx, t, addr, [0, i]);\n-            bcx = gep.bcx;\n-            some(gep.val)\n-          }\n-          ignore. { none }\n-        };\n+        let gep = GEP_tup_like_1(bcx, t, addr, [0, i]);\n+        bcx = gep.bcx;\n         // FIXME make this {|f| str::eq(f.node.ident, tf.ident)} again when\n         // bug #913 is fixed\n         fn test(n: str, f: ast::field) -> bool { str::eq(f.node.ident, n) }\n         alt vec::find(bind test(tf.ident, _), fields) {\n           some(f) {\n-            alt fdest {\n-              some(x) { bcx = trans_expr_save_in(bcx, f.node.expr, x); }\n-              none. { bcx = trans_expr_dps(bcx, f.node.expr, ignore); }\n-            }\n+            bcx = trans_expr_save_in(bcx, f.node.expr, gep.val);\n           }\n           none. {\n-            alt fdest {\n-              some(addr) {\n-                let gep = GEP_tup_like_1(bcx, t, base_val, [0, i]);\n-                let val = load_if_immediate(gep.bcx, gep.val, tf.mt.ty);\n-                bcx = copy_val(gep.bcx, INIT, addr, val, tf.mt.ty);\n-              }\n-              none. {}\n-            }\n-          }\n-        }\n-        alt fdest {\n-          some(addr) {\n-            add_clean_temp_mem(bcx, addr, tf.mt.ty);\n-            temp_cleanups += [addr];\n+            let base = GEP_tup_like_1(bcx, t, base_val, [0, i]);\n+            let val = load_if_immediate(base.bcx, base.val, tf.mt.ty);\n+            bcx = copy_val(base.bcx, INIT, gep.val, val, tf.mt.ty);\n           }\n-          none. {}\n         }\n+        add_clean_temp_mem(bcx, addr, tf.mt.ty);\n+        temp_cleanups += [addr];\n         i += 1;\n     }\n     // Now revoke the cleanups as we pass responsibility for the data\n     // structure on to the caller\n     for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n+    alt overwrite {\n+      some(pos) {\n+        bcx = drop_ty(bcx, pos, t);\n+        bcx = memmove_ty(bcx, pos, addr, t);\n+      }\n+      none. {}\n+    }\n     ret bcx;\n }\n "}]}