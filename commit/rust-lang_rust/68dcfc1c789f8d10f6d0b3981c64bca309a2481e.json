{"sha": "68dcfc1c789f8d10f6d0b3981c64bca309a2481e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZGNmYzFjNzg5ZjhkMTBmNmQwYjM5ODFjNjRiY2EzMDlhMjQ4MWU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-30T09:58:52Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-30T09:58:52Z"}, "message": "Move pass mode handling to abi/pass_mode.rs", "tree": {"sha": "3933276806ab7de3dc21332d66539c3958559454", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3933276806ab7de3dc21332d66539c3958559454"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68dcfc1c789f8d10f6d0b3981c64bca309a2481e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68dcfc1c789f8d10f6d0b3981c64bca309a2481e", "html_url": "https://github.com/rust-lang/rust/commit/68dcfc1c789f8d10f6d0b3981c64bca309a2481e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68dcfc1c789f8d10f6d0b3981c64bca309a2481e/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6427eaf68b5cb9f20b981c393dfd779dd6372cd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6427eaf68b5cb9f20b981c393dfd779dd6372cd5", "html_url": "https://github.com/rust-lang/rust/commit/6427eaf68b5cb9f20b981c393dfd779dd6372cd5"}], "stats": {"total": 374, "additions": 189, "deletions": 185}, "files": [{"sha": "f359145f563e78a5d334f05a94039c44f98d93f8", "filename": "src/abi/mod.rs", "status": "modified", "additions": 3, "deletions": 185, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/68dcfc1c789f8d10f6d0b3981c64bca309a2481e/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68dcfc1c789f8d10f6d0b3981c64bca309a2481e/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=68dcfc1c789f8d10f6d0b3981c64bca309a2481e", "patch": "@@ -1,152 +1,11 @@\n+mod pass_mode;\n+\n use std::borrow::Cow;\n \n-use rustc::ty::layout::{FloatTy, Integer, Primitive, Scalar};\n use rustc_target::spec::abi::Abi;\n \n use crate::prelude::*;\n-\n-#[derive(Copy, Clone, Debug)]\n-enum PassMode {\n-    NoPass,\n-    ByVal(Type),\n-    ByValPair(Type, Type),\n-    ByRef,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-enum EmptySinglePair<T> {\n-    Empty,\n-    Single(T),\n-    Pair(T, T),\n-}\n-\n-impl<T> EmptySinglePair<T> {\n-    fn into_iter(self) -> EmptySinglePairIter<T> {\n-        EmptySinglePairIter(self)\n-    }\n-\n-    fn map<U>(self, mut f: impl FnMut(T) -> U) -> EmptySinglePair<U> {\n-        match self {\n-            Empty => Empty,\n-            Single(v) => Single(f(v)),\n-            Pair(a, b) => Pair(f(a), f(b)),\n-        }\n-    }\n-}\n-\n-struct EmptySinglePairIter<T>(EmptySinglePair<T>);\n-\n-impl<T> Iterator for EmptySinglePairIter<T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        match std::mem::replace(&mut self.0, Empty) {\n-            Empty => None,\n-            Single(v) => Some(v),\n-            Pair(a, b) => {\n-                self.0 = Single(b);\n-                Some(a)\n-            }\n-        }\n-    }\n-}\n-\n-impl<T: std::fmt::Debug> EmptySinglePair<T> {\n-    fn assert_single(self) -> T {\n-        match self {\n-            Single(v) => v,\n-            _ => panic!(\"Called assert_single on {:?}\", self)\n-        }\n-    }\n-\n-    fn assert_pair(self) -> (T, T) {\n-        match self {\n-            Pair(a, b) => (a, b),\n-            _ => panic!(\"Called assert_pair on {:?}\", self)\n-        }\n-    }\n-}\n-\n-use EmptySinglePair::*;\n-\n-impl PassMode {\n-    fn get_param_ty(self, fx: &FunctionCx<impl Backend>) -> EmptySinglePair<Type> {\n-        match self {\n-            PassMode::NoPass => Empty,\n-            PassMode::ByVal(clif_type) => Single(clif_type),\n-            PassMode::ByValPair(a, b) => Pair(a, b),\n-            PassMode::ByRef => Single(fx.pointer_type),\n-        }\n-    }\n-}\n-\n-pub fn scalar_to_clif_type(tcx: TyCtxt, scalar: Scalar) -> Type {\n-    match scalar.value {\n-        Primitive::Int(int, _sign) => match int {\n-            Integer::I8 => types::I8,\n-            Integer::I16 => types::I16,\n-            Integer::I32 => types::I32,\n-            Integer::I64 => types::I64,\n-            Integer::I128 => types::I128,\n-        },\n-        Primitive::Float(flt) => match flt {\n-            FloatTy::F32 => types::F32,\n-            FloatTy::F64 => types::F64,\n-        },\n-        Primitive::Pointer => pointer_ty(tcx),\n-    }\n-}\n-\n-fn get_pass_mode<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    layout: TyLayout<'tcx>,\n-) -> PassMode {\n-    assert!(!layout.is_unsized());\n-\n-    if layout.is_zst() {\n-        // WARNING zst arguments must never be passed, as that will break CastKind::ClosureFnPointer\n-        PassMode::NoPass\n-    } else {\n-        match &layout.abi {\n-            layout::Abi::Uninhabited => PassMode::NoPass,\n-            layout::Abi::Scalar(scalar) => {\n-                PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone()))\n-            }\n-            layout::Abi::ScalarPair(a, b) => {\n-                let a = scalar_to_clif_type(tcx, a.clone());\n-                let b = scalar_to_clif_type(tcx, b.clone());\n-                if a == types::I128 && b == types::I128 {\n-                    // Returning (i128, i128) by-val-pair would take 4 regs, while only 3 are\n-                    // available on x86_64. Cranelift gets confused when too many return params\n-                    // are used.\n-                    PassMode::ByRef\n-                } else {\n-                    PassMode::ByValPair(a, b)\n-                }\n-            }\n-\n-            // FIXME implement Vector Abi in a cg_llvm compatible way\n-            layout::Abi::Vector { .. } => PassMode::ByRef,\n-\n-            layout::Abi::Aggregate { .. } => PassMode::ByRef,\n-        }\n-    }\n-}\n-\n-fn adjust_arg_for_abi<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    arg: CValue<'tcx>,\n-) -> EmptySinglePair<Value> {\n-    match get_pass_mode(fx.tcx, arg.layout()) {\n-        PassMode::NoPass => Empty,\n-        PassMode::ByVal(_) => Single(arg.load_scalar(fx)),\n-        PassMode::ByValPair(_, _) => {\n-            let (a, b) = arg.load_scalar_pair(fx);\n-            Pair(a, b)\n-        }\n-        PassMode::ByRef => Single(arg.force_stack(fx)),\n-    }\n-}\n+use self::pass_mode::*;\n \n fn clif_sig_from_fn_sig<'tcx>(tcx: TyCtxt<'tcx>, sig: FnSig<'tcx>, is_vtable_fn: bool) -> Signature {\n     let abi = match sig.abi {\n@@ -431,47 +290,6 @@ fn local_place<'tcx>(\n     fx.local_map[&local]\n }\n \n-fn cvalue_for_param<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    start_ebb: Ebb,\n-    local: mir::Local,\n-    local_field: Option<usize>,\n-    arg_ty: Ty<'tcx>,\n-    ssa_flags: crate::analyze::Flags,\n-) -> Option<CValue<'tcx>> {\n-    let layout = fx.layout_of(arg_ty);\n-    let pass_mode = get_pass_mode(fx.tcx, fx.layout_of(arg_ty));\n-\n-    if let PassMode::NoPass = pass_mode {\n-        return None;\n-    }\n-\n-    let clif_types = pass_mode.get_param_ty(fx);\n-    let ebb_params = clif_types.map(|t| fx.bcx.append_ebb_param(start_ebb, t));\n-\n-    #[cfg(debug_assertions)]\n-    add_arg_comment(\n-        fx,\n-        \"arg\",\n-        local,\n-        local_field,\n-        ebb_params,\n-        pass_mode,\n-        ssa_flags,\n-        arg_ty,\n-    );\n-\n-    match pass_mode {\n-        PassMode::NoPass => unreachable!(),\n-        PassMode::ByVal(_) => Some(CValue::by_val(ebb_params.assert_single(), layout)),\n-        PassMode::ByValPair(_, _) => {\n-            let (a, b) = ebb_params.assert_pair();\n-            Some(CValue::by_val_pair(a, b, layout))\n-        }\n-        PassMode::ByRef => Some(CValue::by_ref(ebb_params.assert_single(), layout)),\n-    }\n-}\n-\n pub fn codegen_fn_prelude(\n     fx: &mut FunctionCx<'_, '_, impl Backend>,\n     start_ebb: Ebb,"}, {"sha": "c3a479578bccd8c8f5cb0a9728499cf2fcf56a9c", "filename": "src/abi/pass_mode.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/68dcfc1c789f8d10f6d0b3981c64bca309a2481e/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68dcfc1c789f8d10f6d0b3981c64bca309a2481e/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=68dcfc1c789f8d10f6d0b3981c64bca309a2481e", "patch": "@@ -0,0 +1,168 @@\n+use crate::prelude::*;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum PassMode {\n+    NoPass,\n+    ByVal(Type),\n+    ByValPair(Type, Type),\n+    ByRef,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum EmptySinglePair<T> {\n+    Empty,\n+    Single(T),\n+    Pair(T, T),\n+}\n+\n+impl<T> EmptySinglePair<T> {\n+    pub fn into_iter(self) -> EmptySinglePairIter<T> {\n+        EmptySinglePairIter(self)\n+    }\n+\n+    pub fn map<U>(self, mut f: impl FnMut(T) -> U) -> EmptySinglePair<U> {\n+        match self {\n+            Empty => Empty,\n+            Single(v) => Single(f(v)),\n+            Pair(a, b) => Pair(f(a), f(b)),\n+        }\n+    }\n+}\n+\n+pub struct EmptySinglePairIter<T>(EmptySinglePair<T>);\n+\n+impl<T> Iterator for EmptySinglePairIter<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        match std::mem::replace(&mut self.0, Empty) {\n+            Empty => None,\n+            Single(v) => Some(v),\n+            Pair(a, b) => {\n+                self.0 = Single(b);\n+                Some(a)\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: std::fmt::Debug> EmptySinglePair<T> {\n+    pub fn assert_single(self) -> T {\n+        match self {\n+            Single(v) => v,\n+            _ => panic!(\"Called assert_single on {:?}\", self)\n+        }\n+    }\n+\n+    pub fn assert_pair(self) -> (T, T) {\n+        match self {\n+            Pair(a, b) => (a, b),\n+            _ => panic!(\"Called assert_pair on {:?}\", self)\n+        }\n+    }\n+}\n+\n+pub use EmptySinglePair::*;\n+\n+impl PassMode {\n+    pub fn get_param_ty(self, fx: &FunctionCx<impl Backend>) -> EmptySinglePair<Type> {\n+        match self {\n+            PassMode::NoPass => Empty,\n+            PassMode::ByVal(clif_type) => Single(clif_type),\n+            PassMode::ByValPair(a, b) => Pair(a, b),\n+            PassMode::ByRef => Single(fx.pointer_type),\n+        }\n+    }\n+}\n+\n+pub fn get_pass_mode<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    layout: TyLayout<'tcx>,\n+) -> PassMode {\n+    assert!(!layout.is_unsized());\n+\n+    if layout.is_zst() {\n+        // WARNING zst arguments must never be passed, as that will break CastKind::ClosureFnPointer\n+        PassMode::NoPass\n+    } else {\n+        match &layout.abi {\n+            layout::Abi::Uninhabited => PassMode::NoPass,\n+            layout::Abi::Scalar(scalar) => {\n+                PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone()))\n+            }\n+            layout::Abi::ScalarPair(a, b) => {\n+                let a = scalar_to_clif_type(tcx, a.clone());\n+                let b = scalar_to_clif_type(tcx, b.clone());\n+                if a == types::I128 && b == types::I128 {\n+                    // Returning (i128, i128) by-val-pair would take 4 regs, while only 3 are\n+                    // available on x86_64. Cranelift gets confused when too many return params\n+                    // are used.\n+                    PassMode::ByRef\n+                } else {\n+                    PassMode::ByValPair(a, b)\n+                }\n+            }\n+\n+            // FIXME implement Vector Abi in a cg_llvm compatible way\n+            layout::Abi::Vector { .. } => PassMode::ByRef,\n+\n+            layout::Abi::Aggregate { .. } => PassMode::ByRef,\n+        }\n+    }\n+}\n+\n+pub fn adjust_arg_for_abi<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    arg: CValue<'tcx>,\n+) -> EmptySinglePair<Value> {\n+    match get_pass_mode(fx.tcx, arg.layout()) {\n+        PassMode::NoPass => Empty,\n+        PassMode::ByVal(_) => Single(arg.load_scalar(fx)),\n+        PassMode::ByValPair(_, _) => {\n+            let (a, b) = arg.load_scalar_pair(fx);\n+            Pair(a, b)\n+        }\n+        PassMode::ByRef => Single(arg.force_stack(fx)),\n+    }\n+}\n+\n+pub fn cvalue_for_param<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    start_ebb: Ebb,\n+    local: mir::Local,\n+    local_field: Option<usize>,\n+    arg_ty: Ty<'tcx>,\n+    ssa_flags: crate::analyze::Flags,\n+) -> Option<CValue<'tcx>> {\n+    let layout = fx.layout_of(arg_ty);\n+    let pass_mode = get_pass_mode(fx.tcx, fx.layout_of(arg_ty));\n+\n+    if let PassMode::NoPass = pass_mode {\n+        return None;\n+    }\n+\n+    let clif_types = pass_mode.get_param_ty(fx);\n+    let ebb_params = clif_types.map(|t| fx.bcx.append_ebb_param(start_ebb, t));\n+\n+    #[cfg(debug_assertions)]\n+    super::add_arg_comment(\n+        fx,\n+        \"arg\",\n+        local,\n+        local_field,\n+        ebb_params,\n+        pass_mode,\n+        ssa_flags,\n+        arg_ty,\n+    );\n+\n+    match pass_mode {\n+        PassMode::NoPass => unreachable!(),\n+        PassMode::ByVal(_) => Some(CValue::by_val(ebb_params.assert_single(), layout)),\n+        PassMode::ByValPair(_, _) => {\n+            let (a, b) = ebb_params.assert_pair();\n+            Some(CValue::by_val_pair(a, b, layout))\n+        }\n+        PassMode::ByRef => Some(CValue::by_ref(ebb_params.assert_single(), layout)),\n+    }\n+}"}, {"sha": "6ed979449fe63d8390376e11938399530f8dc562", "filename": "src/common.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/68dcfc1c789f8d10f6d0b3981c64bca309a2481e/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68dcfc1c789f8d10f6d0b3981c64bca309a2481e/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=68dcfc1c789f8d10f6d0b3981c64bca309a2481e", "patch": "@@ -1,3 +1,4 @@\n+use rustc::ty::layout::{FloatTy, Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n use cranelift::codegen::ir::{Opcode, InstructionData, ValueDef};\n@@ -17,6 +18,23 @@ pub fn pointer_ty(tcx: TyCtxt) -> types::Type {\n     }\n }\n \n+pub fn scalar_to_clif_type(tcx: TyCtxt, scalar: Scalar) -> Type {\n+    match scalar.value {\n+        Primitive::Int(int, _sign) => match int {\n+            Integer::I8 => types::I8,\n+            Integer::I16 => types::I16,\n+            Integer::I32 => types::I32,\n+            Integer::I64 => types::I64,\n+            Integer::I128 => types::I128,\n+        },\n+        Primitive::Float(flt) => match flt {\n+            FloatTy::F32 => types::F32,\n+            FloatTy::F64 => types::F64,\n+        },\n+        Primitive::Pointer => pointer_ty(tcx),\n+    }\n+}\n+\n pub fn clif_type_from_ty<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,"}]}