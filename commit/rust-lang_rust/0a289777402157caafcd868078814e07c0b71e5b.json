{"sha": "0a289777402157caafcd868078814e07c0b71e5b", "node_id": "C_kwDOAAsO6NoAKDBhMjg5Nzc3NDAyMTU3Y2FhZmNkODY4MDc4ODE0ZTA3YzBiNzFlNWI", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2023-04-24T12:01:19Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2023-04-24T14:16:14Z"}, "message": "Restructure std::fmt::rt a bit.\n\nThis moves more of the internal/lang items into the private rt module.", "tree": {"sha": "b45617ac94d36a847c5792ea8ba4f5b66c40b9ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b45617ac94d36a847c5792ea8ba4f5b66c40b9ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a289777402157caafcd868078814e07c0b71e5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a289777402157caafcd868078814e07c0b71e5b", "html_url": "https://github.com/rust-lang/rust/commit/0a289777402157caafcd868078814e07c0b71e5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a289777402157caafcd868078814e07c0b71e5b/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cf3cbf3b7383f0d4b5ba6524856445a7d7aab2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cf3cbf3b7383f0d4b5ba6524856445a7d7aab2c", "html_url": "https://github.com/rust-lang/rust/commit/5cf3cbf3b7383f0d4b5ba6524856445a7d7aab2c"}], "stats": {"total": 402, "additions": 201, "deletions": 201}, "files": [{"sha": "c081162ea1467eb5b46425ffc1433e354c57aba2", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a289777402157caafcd868078814e07c0b71e5b/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a289777402157caafcd868078814e07c0b71e5b/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=0a289777402157caafcd868078814e07c0b71e5b", "patch": "@@ -327,7 +327,7 @@ fn make_format_spec<'hir>(\n             None => sym::Unknown,\n         },\n     );\n-    // This needs to match `Flag` in library/core/src/fmt/mod.rs.\n+    // This needs to match `Flag` in library/core/src/fmt/rt.rs.\n     let flags: u32 = ((sign == Some(FormatSign::Plus)) as u32)\n         | ((sign == Some(FormatSign::Minus)) as u32) << 1\n         | (alternate as u32) << 2"}, {"sha": "f4f3223257047a888e1d8b7d436d8d11582b08ec", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 52, "deletions": 194, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/0a289777402157caafcd868078814e07c0b71e5b/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a289777402157caafcd868078814e07c0b71e5b/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=0a289777402157caafcd868078814e07c0b71e5b", "patch": "@@ -251,145 +251,48 @@ impl<'a> Formatter<'a> {\n     }\n }\n \n-// NB. Argument is essentially an optimized partially applied formatting function,\n-// equivalent to `exists T.(&T, fn(&T, &mut Formatter<'_>) -> Result`.\n-\n-extern \"C\" {\n-    type Opaque;\n-}\n-\n-/// This struct represents the generic \"argument\" which is taken by the Xprintf\n-/// family of functions. It contains a function to format the given value. At\n-/// compile time it is ensured that the function and the value have the correct\n-/// types, and then this struct is used to canonicalize arguments to one type.\n-#[lang = \"format_argument\"]\n+/// This structure represents a safely precompiled version of a format string\n+/// and its arguments. This cannot be generated at runtime because it cannot\n+/// safely be done, so no constructors are given and the fields are private\n+/// to prevent modification.\n+///\n+/// The [`format_args!`] macro will safely create an instance of this structure.\n+/// The macro validates the format string at compile-time so usage of the\n+/// [`write()`] and [`format()`] functions can be safely performed.\n+///\n+/// You can use the `Arguments<'a>` that [`format_args!`] returns in `Debug`\n+/// and `Display` contexts as seen below. The example also shows that `Debug`\n+/// and `Display` format to the same thing: the interpolated format string\n+/// in `format_args!`.\n+///\n+/// ```rust\n+/// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n+/// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n+/// assert_eq!(\"1 foo 2\", display);\n+/// assert_eq!(display, debug);\n+/// ```\n+///\n+/// [`format()`]: ../../std/fmt/fn.format.html\n+#[lang = \"format_arguments\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone)]\n-#[allow(missing_debug_implementations)]\n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-#[doc(hidden)]\n-pub struct Argument<'a> {\n-    value: &'a Opaque,\n-    formatter: fn(&Opaque, &mut Formatter<'_>) -> Result,\n-}\n-\n-/// This struct represents the unsafety of constructing an `Arguments`.\n-/// It exists, rather than an unsafe function, in order to simplify the expansion\n-/// of `format_args!(..)` and reduce the scope of the `unsafe` block.\n-#[lang = \"format_unsafe_arg\"]\n-#[allow(missing_debug_implementations)]\n-#[doc(hidden)]\n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-pub struct UnsafeArg {\n-    _private: (),\n-}\n-\n-impl UnsafeArg {\n-    /// See documentation where `UnsafeArg` is required to know when it is safe to\n-    /// create and use `UnsafeArg`.\n-    #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    #[inline(always)]\n-    pub unsafe fn new() -> Self {\n-        Self { _private: () }\n-    }\n-}\n-\n-// This guarantees a single stable value for the function pointer associated with\n-// indices/counts in the formatting infrastructure.\n-//\n-// Note that a function defined as such would not be correct as functions are\n-// always tagged unnamed_addr with the current lowering to LLVM IR, so their\n-// address is not considered important to LLVM and as such the as_usize cast\n-// could have been miscompiled. In practice, we never call as_usize on non-usize\n-// containing data (as a matter of static generation of the formatting\n-// arguments), so this is merely an additional check.\n-//\n-// We primarily want to ensure that the function pointer at `USIZE_MARKER` has\n-// an address corresponding *only* to functions that also take `&usize` as their\n-// first argument. The read_volatile here ensures that we can safely ready out a\n-// usize from the passed reference and that this address does not point at a\n-// non-usize taking function.\n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-static USIZE_MARKER: fn(&usize, &mut Formatter<'_>) -> Result = |ptr, _| {\n-    // SAFETY: ptr is a reference\n-    let _v: usize = unsafe { crate::ptr::read_volatile(ptr) };\n-    loop {}\n-};\n-\n-macro_rules! arg_new {\n-    ($f: ident, $t: ident) => {\n-        #[doc(hidden)]\n-        #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-        #[inline]\n-        pub fn $f<'b, T: $t>(x: &'b T) -> Argument<'_> {\n-            Self::new(x, $t::fmt)\n-        }\n-    };\n-}\n-\n-#[rustc_diagnostic_item = \"ArgumentMethods\"]\n-impl<'a> Argument<'a> {\n-    #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    #[inline]\n-    pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> Argument<'b> {\n-        // SAFETY: `mem::transmute(x)` is safe because\n-        //     1. `&'b T` keeps the lifetime it originated with `'b`\n-        //              (so as to not have an unbounded lifetime)\n-        //     2. `&'b T` and `&'b Opaque` have the same memory layout\n-        //              (when `T` is `Sized`, as it is here)\n-        // `mem::transmute(f)` is safe since `fn(&T, &mut Formatter<'_>) -> Result`\n-        // and `fn(&Opaque, &mut Formatter<'_>) -> Result` have the same ABI\n-        // (as long as `T` is `Sized`)\n-        unsafe { Argument { formatter: mem::transmute(f), value: mem::transmute(x) } }\n-    }\n-\n-    arg_new!(new_display, Display);\n-    arg_new!(new_debug, Debug);\n-    arg_new!(new_octal, Octal);\n-    arg_new!(new_lower_hex, LowerHex);\n-    arg_new!(new_upper_hex, UpperHex);\n-    arg_new!(new_pointer, Pointer);\n-    arg_new!(new_binary, Binary);\n-    arg_new!(new_lower_exp, LowerExp);\n-    arg_new!(new_upper_exp, UpperExp);\n+pub struct Arguments<'a> {\n+    // Format string pieces to print.\n+    pieces: &'a [&'static str],\n \n-    #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    pub fn from_usize(x: &usize) -> Argument<'_> {\n-        Argument::new(x, USIZE_MARKER)\n-    }\n-\n-    fn as_usize(&self) -> Option<usize> {\n-        // We are type punning a bit here: USIZE_MARKER only takes an &usize but\n-        // formatter takes an &Opaque. Rust understandably doesn't think we should compare\n-        // the function pointers if they don't have the same signature, so we cast to\n-        // usizes to tell it that we just want to compare addresses.\n-        if self.formatter as usize == USIZE_MARKER as usize {\n-            // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n-            // the value is a usize, so this is safe\n-            Some(unsafe { *(self.value as *const _ as *const usize) })\n-        } else {\n-            None\n-        }\n-    }\n-}\n+    // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n+    fmt: Option<&'a [rt::Placeholder]>,\n \n-// flags available in the v1 format of format_args\n-#[derive(Copy, Clone)]\n-enum Flag {\n-    SignPlus,\n-    SignMinus,\n-    Alternate,\n-    SignAwareZeroPad,\n-    DebugLowerHex,\n-    DebugUpperHex,\n+    // Dynamic arguments for interpolation, to be interleaved with string\n+    // pieces. (Every argument is preceded by a string piece.)\n+    args: &'a [rt::Argument<'a>],\n }\n \n+/// Used by the format_args!() macro to create a fmt::Arguments object.\n+#[doc(hidden)]\n+#[unstable(feature = \"fmt_internals\", issue = \"none\")]\n impl<'a> Arguments<'a> {\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", issue = \"none\")]\n     #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n     pub const fn new_const(pieces: &'a [&'static str]) -> Self {\n         if pieces.len() > 1 {\n@@ -401,22 +304,18 @@ impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n     #[cfg(not(bootstrap))]\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    pub fn new_v1(pieces: &'a [&'static str], args: &'a [Argument<'a>]) -> Arguments<'a> {\n+    pub fn new_v1(pieces: &'a [&'static str], args: &'a [rt::Argument<'a>]) -> Arguments<'a> {\n         if pieces.len() < args.len() || pieces.len() > args.len() + 1 {\n             panic!(\"invalid args\");\n         }\n         Arguments { pieces, fmt: None, args }\n     }\n \n     #[cfg(bootstrap)]\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n-    pub const fn new_v1(pieces: &'a [&'static str], args: &'a [Argument<'a>]) -> Arguments<'a> {\n+    pub const fn new_v1(pieces: &'a [&'static str], args: &'a [rt::Argument<'a>]) -> Arguments<'a> {\n         if pieces.len() < args.len() || pieces.len() > args.len() + 1 {\n             panic!(\"invalid args\");\n         }\n@@ -425,19 +324,17 @@ impl<'a> Arguments<'a> {\n \n     /// This function is used to specify nonstandard formatting parameters.\n     ///\n-    /// An `UnsafeArg` is required because the following invariants must be held\n+    /// An `rt::UnsafeArg` is required because the following invariants must be held\n     /// in order for this function to be safe:\n     /// 1. The `pieces` slice must be at least as long as `fmt`.\n     /// 2. Every `rt::Placeholder::position` value within `fmt` must be a valid index of `args`.\n     /// 3. Every `rt::Count::Param` within `fmt` must contain a valid index of `args`.\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn new_v1_formatted(\n         pieces: &'a [&'static str],\n-        args: &'a [Argument<'a>],\n+        args: &'a [rt::Argument<'a>],\n         fmt: &'a [rt::Placeholder],\n-        _unsafe_arg: UnsafeArg,\n+        _unsafe_arg: rt::UnsafeArg,\n     ) -> Arguments<'a> {\n         Arguments { pieces, fmt: Some(fmt), args }\n     }\n@@ -446,9 +343,7 @@ impl<'a> Arguments<'a> {\n     ///\n     /// This is intended to be used for setting initial `String` capacity\n     /// when using `format!`. Note: this is neither the lower nor upper bound.\n-    #[doc(hidden)]\n     #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn estimated_capacity(&self) -> usize {\n         let pieces_length: usize = self.pieces.iter().map(|x| x.len()).sum();\n \n@@ -468,43 +363,6 @@ impl<'a> Arguments<'a> {\n     }\n }\n \n-/// This structure represents a safely precompiled version of a format string\n-/// and its arguments. This cannot be generated at runtime because it cannot\n-/// safely be done, so no constructors are given and the fields are private\n-/// to prevent modification.\n-///\n-/// The [`format_args!`] macro will safely create an instance of this structure.\n-/// The macro validates the format string at compile-time so usage of the\n-/// [`write()`] and [`format()`] functions can be safely performed.\n-///\n-/// You can use the `Arguments<'a>` that [`format_args!`] returns in `Debug`\n-/// and `Display` contexts as seen below. The example also shows that `Debug`\n-/// and `Display` format to the same thing: the interpolated format string\n-/// in `format_args!`.\n-///\n-/// ```rust\n-/// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n-/// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n-/// assert_eq!(\"1 foo 2\", display);\n-/// assert_eq!(display, debug);\n-/// ```\n-///\n-/// [`format()`]: ../../std/fmt/fn.format.html\n-#[lang = \"format_arguments\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Copy, Clone)]\n-pub struct Arguments<'a> {\n-    // Format string pieces to print.\n-    pieces: &'a [&'static str],\n-\n-    // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n-    fmt: Option<&'a [rt::Placeholder]>,\n-\n-    // Dynamic arguments for interpolation, to be interleaved with string\n-    // pieces. (Every argument is preceded by a string piece.)\n-    args: &'a [Argument<'a>],\n-}\n-\n impl<'a> Arguments<'a> {\n     /// Get the formatted string, if it has no arguments to be formatted at runtime.\n     ///\n@@ -1244,7 +1102,7 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n                 if !piece.is_empty() {\n                     formatter.buf.write_str(*piece)?;\n                 }\n-                (arg.formatter)(arg.value, &mut formatter)?;\n+                arg.fmt(&mut formatter)?;\n                 idx += 1;\n             }\n         }\n@@ -1274,7 +1132,7 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n     Ok(())\n }\n \n-unsafe fn run(fmt: &mut Formatter<'_>, arg: &rt::Placeholder, args: &[Argument<'_>]) -> Result {\n+unsafe fn run(fmt: &mut Formatter<'_>, arg: &rt::Placeholder, args: &[rt::Argument<'_>]) -> Result {\n     fmt.fill = arg.fill;\n     fmt.align = arg.align;\n     fmt.flags = arg.flags;\n@@ -1292,10 +1150,10 @@ unsafe fn run(fmt: &mut Formatter<'_>, arg: &rt::Placeholder, args: &[Argument<'\n     let value = unsafe { args.get_unchecked(arg.position) };\n \n     // Then actually do some printing\n-    (value.formatter)(value.value, fmt)\n+    value.fmt(fmt)\n }\n \n-unsafe fn getcount(args: &[Argument<'_>], cnt: &rt::Count) -> Option<usize> {\n+unsafe fn getcount(args: &[rt::Argument<'_>], cnt: &rt::Count) -> Option<usize> {\n     match *cnt {\n         rt::Count::Is(n) => Some(n),\n         rt::Count::Implied => None,\n@@ -1878,7 +1736,7 @@ impl<'a> Formatter<'a> {\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_plus(&self) -> bool {\n-        self.flags & (1 << Flag::SignPlus as u32) != 0\n+        self.flags & (1 << rt::Flag::SignPlus as u32) != 0\n     }\n \n     /// Determines if the `-` flag was specified.\n@@ -1907,7 +1765,7 @@ impl<'a> Formatter<'a> {\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_minus(&self) -> bool {\n-        self.flags & (1 << Flag::SignMinus as u32) != 0\n+        self.flags & (1 << rt::Flag::SignMinus as u32) != 0\n     }\n \n     /// Determines if the `#` flag was specified.\n@@ -1935,7 +1793,7 @@ impl<'a> Formatter<'a> {\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn alternate(&self) -> bool {\n-        self.flags & (1 << Flag::Alternate as u32) != 0\n+        self.flags & (1 << rt::Flag::Alternate as u32) != 0\n     }\n \n     /// Determines if the `0` flag was specified.\n@@ -1961,17 +1819,17 @@ impl<'a> Formatter<'a> {\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_aware_zero_pad(&self) -> bool {\n-        self.flags & (1 << Flag::SignAwareZeroPad as u32) != 0\n+        self.flags & (1 << rt::Flag::SignAwareZeroPad as u32) != 0\n     }\n \n     // FIXME: Decide what public API we want for these two flags.\n     // https://github.com/rust-lang/rust/issues/48584\n     fn debug_lower_hex(&self) -> bool {\n-        self.flags & (1 << Flag::DebugLowerHex as u32) != 0\n+        self.flags & (1 << rt::Flag::DebugLowerHex as u32) != 0\n     }\n \n     fn debug_upper_hex(&self) -> bool {\n-        self.flags & (1 << Flag::DebugUpperHex as u32) != 0\n+        self.flags & (1 << rt::Flag::DebugUpperHex as u32) != 0\n     }\n \n     /// Creates a [`DebugStruct`] builder designed to assist with creation of\n@@ -2531,13 +2389,13 @@ pub(crate) fn pointer_fmt_inner(ptr_addr: usize, f: &mut Formatter<'_>) -> Resul\n     // or not to zero extend, and then unconditionally set it to get the\n     // prefix.\n     if f.alternate() {\n-        f.flags |= 1 << (Flag::SignAwareZeroPad as u32);\n+        f.flags |= 1 << (rt::Flag::SignAwareZeroPad as u32);\n \n         if f.width.is_none() {\n             f.width = Some((usize::BITS / 4) as usize + 2);\n         }\n     }\n-    f.flags |= 1 << (Flag::Alternate as u32);\n+    f.flags |= 1 << (rt::Flag::Alternate as u32);\n \n     let ret = LowerHex::fmt(&ptr_addr, f);\n "}, {"sha": "8498f5f5a7ce4d46eb46e5b17762a935ea77bfe5", "filename": "library/core/src/fmt/rt.rs", "status": "modified", "additions": 148, "deletions": 6, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/0a289777402157caafcd868078814e07c0b71e5b/library%2Fcore%2Fsrc%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a289777402157caafcd868078814e07c0b71e5b/library%2Fcore%2Fsrc%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Frt.rs?ref=0a289777402157caafcd868078814e07c0b71e5b", "patch": "@@ -3,6 +3,8 @@\n \n //! These are the lang items used by format_args!().\n \n+use super::*;\n+\n #[lang = \"format_placeholder\"]\n #[derive(Copy, Clone)]\n pub struct Placeholder {\n@@ -28,21 +30,17 @@ impl Placeholder {\n     }\n }\n \n-/// Possible alignments that can be requested as part of a formatting directive.\n #[lang = \"format_alignment\"]\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum Alignment {\n-    /// Indication that contents should be left-aligned.\n     Left,\n-    /// Indication that contents should be right-aligned.\n     Right,\n-    /// Indication that contents should be center-aligned.\n     Center,\n-    /// No alignment was requested.\n     Unknown,\n }\n \n-/// Used by [width](https://doc.rust-lang.org/std/fmt/#width) and [precision](https://doc.rust-lang.org/std/fmt/#precision) specifiers.\n+/// Used by [width](https://doc.rust-lang.org/std/fmt/#width)\n+/// and [precision](https://doc.rust-lang.org/std/fmt/#precision) specifiers.\n #[lang = \"format_count\"]\n #[derive(Copy, Clone)]\n pub enum Count {\n@@ -53,3 +51,147 @@ pub enum Count {\n     /// Not specified\n     Implied,\n }\n+\n+// This needs to match the order of flags in compiler/rustc_ast_lowering/src/format.rs.\n+#[derive(Copy, Clone)]\n+pub enum Flag {\n+    SignPlus,\n+    SignMinus,\n+    Alternate,\n+    SignAwareZeroPad,\n+    DebugLowerHex,\n+    DebugUpperHex,\n+}\n+\n+/// This struct represents the generic \"argument\" which is taken by format_args!().\n+/// It contains a function to format the given value. At compile time it is ensured that the\n+/// function and the value have the correct types, and then this struct is used to canonicalize\n+/// arguments to one type.\n+///\n+/// Argument is essentially an optimized partially applied formatting function,\n+/// equivalent to `exists T.(&T, fn(&T, &mut Formatter<'_>) -> Result`.\n+#[lang = \"format_argument\"]\n+#[derive(Copy, Clone)]\n+pub struct Argument<'a> {\n+    value: &'a Opaque,\n+    formatter: fn(&Opaque, &mut Formatter<'_>) -> Result,\n+}\n+\n+#[rustc_diagnostic_item = \"ArgumentMethods\"]\n+impl<'a> Argument<'a> {\n+    #[inline(always)]\n+    fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> Argument<'b> {\n+        // SAFETY: `mem::transmute(x)` is safe because\n+        //     1. `&'b T` keeps the lifetime it originated with `'b`\n+        //              (so as to not have an unbounded lifetime)\n+        //     2. `&'b T` and `&'b Opaque` have the same memory layout\n+        //              (when `T` is `Sized`, as it is here)\n+        // `mem::transmute(f)` is safe since `fn(&T, &mut Formatter<'_>) -> Result`\n+        // and `fn(&Opaque, &mut Formatter<'_>) -> Result` have the same ABI\n+        // (as long as `T` is `Sized`)\n+        unsafe { Argument { formatter: mem::transmute(f), value: mem::transmute(x) } }\n+    }\n+\n+    #[inline(always)]\n+    pub fn new_display<'b, T: Display>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Display::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_debug<'b, T: Debug>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Debug::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_octal<'b, T: Octal>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Octal::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_lower_hex<'b, T: LowerHex>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, LowerHex::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_upper_hex<'b, T: UpperHex>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, UpperHex::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_pointer<'b, T: Pointer>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Pointer::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_binary<'b, T: Binary>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, Binary::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_lower_exp<'b, T: LowerExp>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, LowerExp::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn new_upper_exp<'b, T: UpperExp>(x: &'b T) -> Argument<'_> {\n+        Self::new(x, UpperExp::fmt)\n+    }\n+    #[inline(always)]\n+    pub fn from_usize(x: &usize) -> Argument<'_> {\n+        Self::new(x, USIZE_MARKER)\n+    }\n+\n+    #[inline(always)]\n+    pub(super) fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+        (self.formatter)(self.value, f)\n+    }\n+\n+    #[inline(always)]\n+    pub(super) fn as_usize(&self) -> Option<usize> {\n+        // We are type punning a bit here: USIZE_MARKER only takes an &usize but\n+        // formatter takes an &Opaque. Rust understandably doesn't think we should compare\n+        // the function pointers if they don't have the same signature, so we cast to\n+        // usizes to tell it that we just want to compare addresses.\n+        if self.formatter as usize == USIZE_MARKER as usize {\n+            // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n+            // the value is a usize, so this is safe\n+            Some(unsafe { *(self.value as *const _ as *const usize) })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// This struct represents the unsafety of constructing an `Arguments`.\n+/// It exists, rather than an unsafe function, in order to simplify the expansion\n+/// of `format_args!(..)` and reduce the scope of the `unsafe` block.\n+#[lang = \"format_unsafe_arg\"]\n+pub struct UnsafeArg {\n+    _private: (),\n+}\n+\n+impl UnsafeArg {\n+    /// See documentation where `UnsafeArg` is required to know when it is safe to\n+    /// create and use `UnsafeArg`.\n+    #[inline(always)]\n+    pub unsafe fn new() -> Self {\n+        Self { _private: () }\n+    }\n+}\n+\n+extern \"C\" {\n+    type Opaque;\n+}\n+\n+// This guarantees a single stable value for the function pointer associated with\n+// indices/counts in the formatting infrastructure.\n+//\n+// Note that a function defined as such would not be correct as functions are\n+// always tagged unnamed_addr with the current lowering to LLVM IR, so their\n+// address is not considered important to LLVM and as such the as_usize cast\n+// could have been miscompiled. In practice, we never call as_usize on non-usize\n+// containing data (as a matter of static generation of the formatting\n+// arguments), so this is merely an additional check.\n+//\n+// We primarily want to ensure that the function pointer at `USIZE_MARKER` has\n+// an address corresponding *only* to functions that also take `&usize` as their\n+// first argument. The read_volatile here ensures that we can safely ready out a\n+// usize from the passed reference and that this address does not point at a\n+// non-usize taking function.\n+static USIZE_MARKER: fn(&usize, &mut Formatter<'_>) -> Result = |ptr, _| {\n+    // SAFETY: ptr is a reference\n+    let _v: usize = unsafe { crate::ptr::read_volatile(ptr) };\n+    loop {}\n+};"}]}