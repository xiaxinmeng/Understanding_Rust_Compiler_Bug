{"sha": "e37327bfee6217e46921a294f1a321e2d71300ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNzMyN2JmZWU2MjE3ZTQ2OTIxYTI5NGYxYTMyMWUyZDcxMzAwY2E=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-02-21T16:52:32Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-02-21T16:56:16Z"}, "message": "Decouple integer formatting from std::num::strconv\n\nThis works towards a complete rewrite and ultimate removal of the `std::num::strconv` module (see #6220), and the removal of the `ToStrRadix` trait in favour of using the `std::fmt` functionality directly. This should make for a cleaner API, encourage less allocation, and make the implementation far more comprehensible.\n\nThe `Formatter::pad_integral` method has also been refactored make it easier to understand.\n\nThe formatting tests for integers have been moved out of `run-pass/ifmt.rs` in order to provide more immediate feedback when building using `make check-stage2-std NO_REBUILD=1`.\n\nThe benchmarks have been standardised between std::num::strconv and std::num::fmt to make it easier to compare the performance of the different implementations.\n\nArbitrary radixes are now easier to use in format strings. For example:\n\n~~~\nassert_eq!(format!(\"{:04}\", radix(3, 2)), ~\"0011\");\n~~~", "tree": {"sha": "bf179a6d7d458f18e4a78becd67a70cf6fe9079b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf179a6d7d458f18e4a78becd67a70cf6fe9079b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e37327bfee6217e46921a294f1a321e2d71300ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e37327bfee6217e46921a294f1a321e2d71300ca", "html_url": "https://github.com/rust-lang/rust/commit/e37327bfee6217e46921a294f1a321e2d71300ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e37327bfee6217e46921a294f1a321e2d71300ca/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9abff54d61babab8050c108f7cb6b957b1636337", "url": "https://api.github.com/repos/rust-lang/rust/commits/9abff54d61babab8050c108f7cb6b957b1636337", "html_url": "https://github.com/rust-lang/rust/commit/9abff54d61babab8050c108f7cb6b957b1636337"}], "stats": {"total": 847, "additions": 609, "deletions": 238}, "files": [{"sha": "38fae798d5dde252fc0a82b1a696c0f48857fe9c", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 54, "deletions": 121, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/e37327bfee6217e46921a294f1a321e2d71300ca/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37327bfee6217e46921a294f1a321e2d71300ca/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=e37327bfee6217e46921a294f1a321e2d71300ca", "patch": "@@ -215,7 +215,7 @@ impl fmt::Binary for Vector2D {\n         // for details, and the function `pad` can be used to pad strings.\n         let decimals = f.precision.unwrap_or(3);\n         let string = f64::to_str_exact(magnitude, decimals);\n-        f.pad_integral(string.as_bytes(), \"\", true)\n+        f.pad_integral(true, \"\", string.as_bytes())\n     }\n }\n \n@@ -493,6 +493,11 @@ use str;\n use vec::ImmutableVector;\n use vec;\n \n+pub use self::num::radix;\n+pub use self::num::Radix;\n+pub use self::num::RadixFmt;\n+\n+mod num;\n pub mod parse;\n pub mod rt;\n \n@@ -891,58 +896,60 @@ impl<'a> Formatter<'a> {\n     ///\n     /// # Arguments\n     ///\n-    ///     * s - the byte array that the number has been formatted into\n-    ///     * alternate_prefix - if the '#' character (FlagAlternate) is\n-    ///       provided, this is the prefix to put in front of the number.\n-    ///       Currently this is 0x/0o/0b/etc.\n-    ///     * positive - whether the original integer was positive or not.\n+    ///     * is_positive - whether the original integer was positive or not.\n+    ///     * prefix - if the '#' character (FlagAlternate) is provided, this\n+    ///       is the prefix to put in front of the number.\n+    ///     * buf - the byte array that the number has been formatted into\n     ///\n     /// This function will correctly account for the flags provided as well as\n     /// the minimum width. It will not take precision into account.\n-    pub fn pad_integral(&mut self, s: &[u8], alternate_prefix: &str,\n-                        positive: bool) -> Result {\n+    pub fn pad_integral(&mut self, is_positive: bool, prefix: &str, buf: &[u8]) -> Result {\n         use fmt::parse::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n \n-        let mut actual_len = s.len();\n-        if self.flags & 1 << (FlagAlternate as uint) != 0 {\n-            actual_len += alternate_prefix.len();\n-        }\n-        if self.flags & 1 << (FlagSignPlus as uint) != 0 {\n-            actual_len += 1;\n-        } else if !positive {\n-            actual_len += 1;\n+        let mut width = buf.len();\n+\n+        let mut sign = None;\n+        if !is_positive {\n+            sign = Some('-'); width += 1;\n+        } else if self.flags & (1 << (FlagSignPlus as uint)) != 0 {\n+            sign = Some('+'); width += 1;\n         }\n \n-        let mut signprinted = false;\n-        let sign = |this: &mut Formatter| {\n-            if !signprinted {\n-                if this.flags & 1 << (FlagSignPlus as uint) != 0 && positive {\n-                    try!(this.buf.write(['+' as u8]));\n-                } else if !positive {\n-                    try!(this.buf.write(['-' as u8]));\n-                }\n-                if this.flags & 1 << (FlagAlternate as uint) != 0 {\n-                    try!(this.buf.write(alternate_prefix.as_bytes()));\n-                }\n-                signprinted = true;\n-            }\n-            Ok(())\n-        };\n+        let mut prefixed = false;\n+        if self.flags & (1 << (FlagAlternate as uint)) != 0 {\n+            prefixed = true; width += prefix.len();\n+        }\n \n-        let emit = |this: &mut Formatter| {\n-            sign(this).and_then(|()| this.buf.write(s))\n+        // Writes the sign if it exists, and then the prefix if it was requested\n+        let write_prefix = |f: &mut Formatter| {\n+            for c in sign.move_iter() { try!(f.buf.write_char(c)); }\n+            if prefixed { f.buf.write_str(prefix) }\n+            else { Ok(()) }\n         };\n \n+        // The `width` field is more of a `min-width` parameter at this point.\n         match self.width {\n-            None => emit(self),\n-            Some(min) if actual_len >= min => emit(self),\n+            // If there's no minimum length requirements then we can just\n+            // write the bytes.\n+            None => {\n+                try!(write_prefix(self)); self.buf.write(buf)\n+            }\n+            // Check if we're over the minimum width, if so then we can also\n+            // just write the bytes.\n+            Some(min) if width >= min => {\n+                try!(write_prefix(self)); self.buf.write(buf)\n+            }\n+            // The sign and prefix goes before the padding if the fill character\n+            // is zero\n+            Some(min) if self.flags & (1 << (FlagSignAwareZeroPad as uint)) != 0 => {\n+                self.fill = '0';\n+                try!(write_prefix(self));\n+                self.with_padding(min - width, parse::AlignRight, |f| f.buf.write(buf))\n+            }\n+            // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {\n-                if self.flags & 1 << (FlagSignAwareZeroPad as uint) != 0 {\n-                    self.fill = '0';\n-                    try!(sign(self));\n-                }\n-                self.with_padding(min - actual_len, parse::AlignRight, |me| {\n-                    emit(me)\n+                self.with_padding(min - width, parse::AlignRight, |f| {\n+                    try!(write_prefix(f)); f.buf.write(buf)\n                 })\n             }\n         }\n@@ -979,19 +986,16 @@ impl<'a> Formatter<'a> {\n             }\n             None => {}\n         }\n-\n         // The `width` field is more of a `min-width` parameter at this point.\n         match self.width {\n             // If we're under the maximum length, and there's no minimum length\n             // requirements, then we can just emit the string\n             None => self.buf.write(s.as_bytes()),\n-\n             // If we're under the maximum width, check if we're over the minimum\n             // width, if so it's as easy as just emitting the string.\n             Some(width) if s.char_len() >= width => {\n                 self.buf.write(s.as_bytes())\n             }\n-\n             // If we're under both the maximum and the minimum width, then fill\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n@@ -1002,6 +1006,8 @@ impl<'a> Formatter<'a> {\n         }\n     }\n \n+    /// Runs a callback, emitting the correct padding either before or\n+    /// afterwards depending on whether right or left alingment is requested.\n     fn with_padding(&mut self,\n                     padding: uint,\n                     default: parse::Alignment,\n@@ -1075,67 +1081,6 @@ impl Char for char {\n     }\n }\n \n-macro_rules! int_base(($ty:ident, $into:ident, $base:expr,\n-                       $name:ident, $prefix:expr) => {\n-    impl $name for $ty {\n-        fn fmt(&self, f: &mut Formatter) -> Result {\n-            ::$into::to_str_bytes(*self as $into, $base, |buf| {\n-                f.pad_integral(buf, $prefix, true)\n-            })\n-        }\n-    }\n-})\n-macro_rules! upper_hex(($ty:ident, $into:ident) => {\n-    impl UpperHex for $ty {\n-        fn fmt(&self, f: &mut Formatter) -> Result {\n-            ::$into::to_str_bytes(*self as $into, 16, |buf| {\n-                upperhex(buf, f)\n-            })\n-        }\n-    }\n-})\n-// Not sure why, but this causes an \"unresolved enum variant, struct or const\"\n-// when inlined into the above macro...\n-#[doc(hidden)]\n-pub fn upperhex(buf: &[u8], f: &mut Formatter) -> Result {\n-    let mut local = [0u8, ..16];\n-    for i in ::iter::range(0, buf.len()) {\n-        local[i] = match buf[i] as char {\n-            'a' .. 'f' => (buf[i] - 'a' as u8) + 'A' as u8,\n-            c => c as u8,\n-        }\n-    }\n-    f.pad_integral(local.slice_to(buf.len()), \"0x\", true)\n-}\n-\n-macro_rules! integer(($signed:ident, $unsigned:ident) => {\n-    // Signed is special because it actuall emits the negative sign,\n-    // nothing else should do that, however.\n-    impl Signed for $signed {\n-        fn fmt(&self, f: &mut Formatter) -> Result {\n-            ::$unsigned::to_str_bytes(self.abs() as $unsigned, 10, |buf| {\n-                f.pad_integral(buf, \"\", *self >= 0)\n-            })\n-        }\n-    }\n-    int_base!($signed, $unsigned, 2, Binary, \"0b\")\n-    int_base!($signed, $unsigned, 8, Octal, \"0o\")\n-    int_base!($signed, $unsigned, 16, LowerHex, \"0x\")\n-    upper_hex!($signed, $unsigned)\n-\n-    int_base!($unsigned, $unsigned, 2, Binary, \"0b\")\n-    int_base!($unsigned, $unsigned, 8, Octal, \"0o\")\n-    int_base!($unsigned, $unsigned, 10, Unsigned, \"\")\n-    int_base!($unsigned, $unsigned, 16, LowerHex, \"0x\")\n-    upper_hex!($unsigned, $unsigned)\n-})\n-\n-integer!(int, uint)\n-integer!(i8, u8)\n-integer!(i16, u16)\n-integer!(i32, u32)\n-integer!(i64, u64)\n-\n macro_rules! floating(($ty:ident) => {\n     impl Float for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n@@ -1144,7 +1089,7 @@ macro_rules! floating(($ty:ident) => {\n                 Some(i) => ::$ty::to_str_exact(self.abs(), i),\n                 None => ::$ty::to_str_digits(self.abs(), 6)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *self >= 0.0)\n+            fmt.pad_integral(*self >= 0.0, \"\", s.as_bytes())\n         }\n     }\n \n@@ -1155,7 +1100,7 @@ macro_rules! floating(($ty:ident) => {\n                 Some(i) => ::$ty::to_str_exp_exact(self.abs(), i, false),\n                 None => ::$ty::to_str_exp_digits(self.abs(), 6, false)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *self >= 0.0)\n+            fmt.pad_integral(*self >= 0.0, \"\", s.as_bytes())\n         }\n     }\n \n@@ -1166,7 +1111,7 @@ macro_rules! floating(($ty:ident) => {\n                 Some(i) => ::$ty::to_str_exp_exact(self.abs(), i, true),\n                 None => ::$ty::to_str_exp_digits(self.abs(), 6, true)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *self >= 0.0)\n+            fmt.pad_integral(*self >= 0.0, \"\", s.as_bytes())\n         }\n     }\n })\n@@ -1193,9 +1138,7 @@ impl<T> Poly for T {\n impl<T> Pointer for *T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (parse::FlagAlternate as uint);\n-        ::uint::to_str_bytes(*self as uint, 16, |buf| {\n-            f.pad_integral(buf, \"0x\", true)\n-        })\n+        secret_lower_hex::<uint>(&(*self as uint), f)\n     }\n }\n impl<T> Pointer for *mut T {\n@@ -1223,16 +1166,6 @@ macro_rules! delegate(($ty:ty to $other:ident) => {\n         }\n     }\n })\n-delegate!(int to signed)\n-delegate!( i8 to signed)\n-delegate!(i16 to signed)\n-delegate!(i32 to signed)\n-delegate!(i64 to signed)\n-delegate!(uint to unsigned)\n-delegate!(  u8 to unsigned)\n-delegate!( u16 to unsigned)\n-delegate!( u32 to unsigned)\n-delegate!( u64 to unsigned)\n delegate!(~str to string)\n delegate!(&'a str to string)\n delegate!(bool to bool)"}, {"sha": "681d0678ed4953380cb2ed0aa15ebde601c05e9c", "filename": "src/libstd/fmt/num.rs", "status": "added", "additions": 467, "deletions": 0, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/e37327bfee6217e46921a294f1a321e2d71300ca/src%2Flibstd%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37327bfee6217e46921a294f1a321e2d71300ca/src%2Flibstd%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fnum.rs?ref=e37327bfee6217e46921a294f1a321e2d71300ca", "patch": "@@ -0,0 +1,467 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Integer and floating-point number formatting\n+\n+// FIXME: #6220 Implement floating point formatting\n+\n+use container::Container;\n+use fmt;\n+use iter::{Iterator, DoubleEndedIterator};\n+use num::{Int, cast, zero};\n+use option::{Some, None};\n+use vec::{ImmutableVector, MutableVector};\n+\n+/// A type that represents a specific radix\n+trait GenericRadix {\n+    /// The number of digits.\n+    fn base(&self) -> u8;\n+\n+    /// A radix-specific prefix string.\n+    fn prefix(&self) -> &'static str { \"\" }\n+\n+    /// Converts an integer to corresponding radix digit.\n+    fn digit(&self, x: u8) -> u8;\n+\n+    /// Format an integer using the radix using a formatter.\n+    fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result {\n+        // The radix can be as low as 2, so we need a buffer of at least 64\n+        // characters for a base 2 number.\n+        let mut buf = [0u8, ..64];\n+        let base = cast(self.base()).unwrap();\n+        let mut curr = buf.len();\n+        let is_positive = x >= zero();\n+        if is_positive {\n+            // Accumulate each digit of the number from the least significant\n+            // to the most significant figure.\n+            for byte in buf.mut_iter().rev() {\n+                let n = x % base;                         // Get the current place value.\n+                x = x / base;                             // Deaccumulate the number.\n+                *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n+                curr -= 1;\n+                if x == zero() { break; }                 // No more digits left to accumulate.\n+            }\n+        } else {\n+            // Do the same as above, but accounting for two's complement.\n+            for byte in buf.mut_iter().rev() {\n+                let n = -(x % base);                      // Get the current place value.\n+                x = x / base;                             // Deaccumulate the number.\n+                *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n+                curr -= 1;\n+                if x == zero() { break; }                 // No more digits left to accumulate.\n+            }\n+        }\n+        f.pad_integral(is_positive, self.prefix(), buf.slice_from(curr))\n+    }\n+}\n+\n+/// A binary (base 2) radix\n+#[deriving(Clone, Eq)]\n+struct Binary;\n+\n+/// An octal (base 8) radix\n+#[deriving(Clone, Eq)]\n+struct Octal;\n+\n+/// A decimal (base 10) radix\n+#[deriving(Clone, Eq)]\n+struct Decimal;\n+\n+/// A hexidecimal (base 16) radix, formatted with lower-case characters\n+#[deriving(Clone, Eq)]\n+struct LowerHex;\n+\n+/// A hexidecimal (base 16) radix, formatted with upper-case characters\n+#[deriving(Clone, Eq)]\n+pub struct UpperHex;\n+\n+macro_rules! radix {\n+    ($T:ident, $base:expr, $prefix:expr, $($x:pat => $conv:expr),+) => {\n+        impl GenericRadix for $T {\n+            fn base(&self) -> u8 { $base }\n+            fn prefix(&self) -> &'static str { $prefix }\n+            fn digit(&self, x: u8) -> u8 {\n+                match x {\n+                    $($x => $conv,)+\n+                    x => fail!(\"number not in the range 0..{}: {}\", self.base() - 1, x),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+radix!(Binary,    2, \"0b\", x @  0 .. 2 => '0' as u8 + x)\n+radix!(Octal,     8, \"0o\", x @  0 .. 7 => '0' as u8 + x)\n+radix!(Decimal,  10, \"\",   x @  0 .. 9 => '0' as u8 + x)\n+radix!(LowerHex, 16, \"0x\", x @  0 .. 9 => '0' as u8 + x,\n+                           x @ 10 ..15 => 'a' as u8 + (x - 10))\n+radix!(UpperHex, 16, \"0x\", x @  0 .. 9 => '0' as u8 + x,\n+                           x @ 10 ..15 => 'A' as u8 + (x - 10))\n+\n+/// A radix with in the range of `2..36`.\n+#[deriving(Clone, Eq)]\n+pub struct Radix {\n+    priv base: u8,\n+}\n+\n+impl Radix {\n+    fn new(base: u8) -> Radix {\n+        assert!(2 <= base && base <= 36, \"the base must be in the range of 0..36: {}\", base);\n+        Radix { base: base }\n+    }\n+}\n+\n+impl GenericRadix for Radix {\n+    fn base(&self) -> u8 { self.base }\n+    fn digit(&self, x: u8) -> u8 {\n+        match x {\n+            x @  0 ..9 => '0' as u8 + x,\n+            x if x < self.base() => 'a' as u8 + (x - 10),\n+            x => fail!(\"number not in the range 0..{}: {}\", self.base() - 1, x),\n+        }\n+    }\n+}\n+\n+/// A helper type for formatting radixes.\n+pub struct RadixFmt<T, R>(T, R);\n+\n+/// Constructs a radix formatter in the range of `2..36`.\n+///\n+/// # Example\n+///\n+/// ~~~\n+/// use std::fmt::radix;\n+/// assert_eq!(format!(\"{}\", radix(55, 36)), ~\"1j\");\n+/// ~~~\n+pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n+    RadixFmt(x, Radix::new(base))\n+}\n+\n+macro_rules! radix_fmt {\n+    ($T:ty as $U:ty, $fmt:ident) => {\n+        impl fmt::Show for RadixFmt<$T, Radix> {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                match *self { RadixFmt(ref x, radix) => radix.$fmt(*x as $U, f) }\n+            }\n+        }\n+    }\n+}\n+macro_rules! int_base {\n+    ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n+        impl fmt::$Trait for $T {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                $Radix.fmt_int(*self as $U, f)\n+            }\n+        }\n+    }\n+}\n+macro_rules! integer {\n+    ($Int:ident, $Uint:ident) => {\n+        int_base!(Show     for $Int as $Int   -> Decimal)\n+        int_base!(Signed   for $Int as $Int   -> Decimal)\n+        int_base!(Binary   for $Int as $Uint  -> Binary)\n+        int_base!(Octal    for $Int as $Uint  -> Octal)\n+        int_base!(LowerHex for $Int as $Uint  -> LowerHex)\n+        int_base!(UpperHex for $Int as $Uint  -> UpperHex)\n+        radix_fmt!($Int as $Uint, fmt_int)\n+\n+        int_base!(Show     for $Uint as $Uint -> Decimal)\n+        int_base!(Unsigned for $Uint as $Uint -> Decimal)\n+        int_base!(Binary   for $Uint as $Uint -> Binary)\n+        int_base!(Octal    for $Uint as $Uint -> Octal)\n+        int_base!(LowerHex for $Uint as $Uint -> LowerHex)\n+        int_base!(UpperHex for $Uint as $Uint -> UpperHex)\n+        radix_fmt!($Uint as $Uint, fmt_int)\n+    }\n+}\n+integer!(int, uint)\n+integer!(i8, u8)\n+integer!(i16, u16)\n+integer!(i32, u32)\n+integer!(i64, u64)\n+\n+#[cfg(test)]\n+mod tests {\n+    use fmt::radix;\n+    use super::{Binary, Octal, Decimal, LowerHex, UpperHex};\n+    use super::{GenericRadix, Radix};\n+\n+    #[test]\n+    fn test_radix_base() {\n+        assert_eq!(Binary.base(), 2);\n+        assert_eq!(Octal.base(), 8);\n+        assert_eq!(Decimal.base(), 10);\n+        assert_eq!(LowerHex.base(), 16);\n+        assert_eq!(UpperHex.base(), 16);\n+        assert_eq!(Radix { base: 36 }.base(), 36);\n+    }\n+\n+    #[test]\n+    fn test_radix_prefix() {\n+        assert_eq!(Binary.prefix(), \"0b\");\n+        assert_eq!(Octal.prefix(), \"0o\");\n+        assert_eq!(Decimal.prefix(), \"\");\n+        assert_eq!(LowerHex.prefix(), \"0x\");\n+        assert_eq!(UpperHex.prefix(), \"0x\");\n+        assert_eq!(Radix { base: 36 }.prefix(), \"\");\n+    }\n+\n+    #[test]\n+    fn test_radix_digit() {\n+        assert_eq!(Binary.digit(0), '0' as u8);\n+        assert_eq!(Binary.digit(2), '2' as u8);\n+        assert_eq!(Octal.digit(0), '0' as u8);\n+        assert_eq!(Octal.digit(7), '7' as u8);\n+        assert_eq!(Decimal.digit(0), '0' as u8);\n+        assert_eq!(Decimal.digit(9), '9' as u8);\n+        assert_eq!(LowerHex.digit(0), '0' as u8);\n+        assert_eq!(LowerHex.digit(10), 'a' as u8);\n+        assert_eq!(LowerHex.digit(15), 'f' as u8);\n+        assert_eq!(UpperHex.digit(0), '0' as u8);\n+        assert_eq!(UpperHex.digit(10), 'A' as u8);\n+        assert_eq!(UpperHex.digit(15), 'F' as u8);\n+        assert_eq!(Radix { base: 36 }.digit(0), '0' as u8);\n+        assert_eq!(Radix { base: 36 }.digit(15), 'f' as u8);\n+        assert_eq!(Radix { base: 36 }.digit(35), 'z' as u8);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_hex_radix_digit_overflow() {\n+        let _ = LowerHex.digit(16);\n+    }\n+\n+    #[test]\n+    fn test_format_int() {\n+        // Formatting integers should select the right implementation based off\n+        // the type of the argument. Also, hex/octal/binary should be defined\n+        // for integers, but they shouldn't emit the negative sign.\n+        assert_eq!(format!(\"{}\", 1i), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1i8), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1i16), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1i32), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1i64), ~\"1\");\n+        assert_eq!(format!(\"{:d}\", -1i), ~\"-1\");\n+        assert_eq!(format!(\"{:d}\", -1i8), ~\"-1\");\n+        assert_eq!(format!(\"{:d}\", -1i16), ~\"-1\");\n+        assert_eq!(format!(\"{:d}\", -1i32), ~\"-1\");\n+        assert_eq!(format!(\"{:d}\", -1i64), ~\"-1\");\n+        assert_eq!(format!(\"{:t}\", 1i), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1i8), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1i16), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1i32), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1i64), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1i), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1i8), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1i16), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1i32), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1i64), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1i), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1i8), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1i16), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1i32), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1i64), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1i), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1i8), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1i16), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1i32), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1i64), ~\"1\");\n+\n+        assert_eq!(format!(\"{}\", 1u), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1u8), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1u16), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1u32), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1u64), ~\"1\");\n+        assert_eq!(format!(\"{:u}\", 1u), ~\"1\");\n+        assert_eq!(format!(\"{:u}\", 1u8), ~\"1\");\n+        assert_eq!(format!(\"{:u}\", 1u16), ~\"1\");\n+        assert_eq!(format!(\"{:u}\", 1u32), ~\"1\");\n+        assert_eq!(format!(\"{:u}\", 1u64), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1u), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1u8), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1u16), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1u32), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1u64), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1u), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1u8), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1u16), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1u32), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1u64), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1u), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1u8), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1u16), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1u32), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1u64), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1u), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1u8), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1u16), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1u32), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1u64), ~\"1\");\n+\n+        // Test a larger number\n+        assert_eq!(format!(\"{:t}\", 55), ~\"110111\");\n+        assert_eq!(format!(\"{:o}\", 55), ~\"67\");\n+        assert_eq!(format!(\"{:d}\", 55), ~\"55\");\n+        assert_eq!(format!(\"{:x}\", 55), ~\"37\");\n+        assert_eq!(format!(\"{:X}\", 55), ~\"37\");\n+    }\n+\n+    #[test]\n+    fn test_format_int_zero() {\n+        assert_eq!(format!(\"{}\", 0i), ~\"0\");\n+        assert_eq!(format!(\"{:d}\", 0i), ~\"0\");\n+        assert_eq!(format!(\"{:t}\", 0i), ~\"0\");\n+        assert_eq!(format!(\"{:o}\", 0i), ~\"0\");\n+        assert_eq!(format!(\"{:x}\", 0i), ~\"0\");\n+        assert_eq!(format!(\"{:X}\", 0i), ~\"0\");\n+\n+        assert_eq!(format!(\"{}\", 0u), ~\"0\");\n+        assert_eq!(format!(\"{:u}\", 0u), ~\"0\");\n+        assert_eq!(format!(\"{:t}\", 0u), ~\"0\");\n+        assert_eq!(format!(\"{:o}\", 0u), ~\"0\");\n+        assert_eq!(format!(\"{:x}\", 0u), ~\"0\");\n+        assert_eq!(format!(\"{:X}\", 0u), ~\"0\");\n+    }\n+\n+    #[test]\n+    fn test_format_int_flags() {\n+        assert_eq!(format!(\"{:3d}\", 1), ~\"  1\");\n+        assert_eq!(format!(\"{:>3d}\", 1), ~\"  1\");\n+        assert_eq!(format!(\"{:>+3d}\", 1), ~\" +1\");\n+        assert_eq!(format!(\"{:<3d}\", 1), ~\"1  \");\n+        assert_eq!(format!(\"{:#d}\", 1), ~\"1\");\n+        assert_eq!(format!(\"{:#x}\", 10), ~\"0xa\");\n+        assert_eq!(format!(\"{:#X}\", 10), ~\"0xA\");\n+        assert_eq!(format!(\"{:#5x}\", 10), ~\"  0xa\");\n+        assert_eq!(format!(\"{:#o}\", 10), ~\"0o12\");\n+        assert_eq!(format!(\"{:08x}\", 10), ~\"0000000a\");\n+        assert_eq!(format!(\"{:8x}\", 10), ~\"       a\");\n+        assert_eq!(format!(\"{:<8x}\", 10), ~\"a       \");\n+        assert_eq!(format!(\"{:>8x}\", 10), ~\"       a\");\n+        assert_eq!(format!(\"{:#08x}\", 10), ~\"0x00000a\");\n+        assert_eq!(format!(\"{:08d}\", -10), ~\"-0000010\");\n+        assert_eq!(format!(\"{:x}\", -1u8), ~\"ff\");\n+        assert_eq!(format!(\"{:X}\", -1u8), ~\"FF\");\n+        assert_eq!(format!(\"{:t}\", -1u8), ~\"11111111\");\n+        assert_eq!(format!(\"{:o}\", -1u8), ~\"377\");\n+        assert_eq!(format!(\"{:#x}\", -1u8), ~\"0xff\");\n+        assert_eq!(format!(\"{:#X}\", -1u8), ~\"0xFF\");\n+        assert_eq!(format!(\"{:#t}\", -1u8), ~\"0b11111111\");\n+        assert_eq!(format!(\"{:#o}\", -1u8), ~\"0o377\");\n+    }\n+\n+    #[test]\n+    fn test_format_int_sign_padding() {\n+        assert_eq!(format!(\"{:+5d}\", 1), ~\"   +1\");\n+        assert_eq!(format!(\"{:+5d}\", -1), ~\"   -1\");\n+        assert_eq!(format!(\"{:05d}\", 1), ~\"00001\");\n+        assert_eq!(format!(\"{:05d}\", -1), ~\"-0001\");\n+        assert_eq!(format!(\"{:+05d}\", 1), ~\"+0001\");\n+        assert_eq!(format!(\"{:+05d}\", -1), ~\"-0001\");\n+    }\n+\n+    #[test]\n+    fn test_format_int_twos_complement() {\n+        use {i8, i16, i32, i64};\n+        assert_eq!(format!(\"{}\", i8::MIN), ~\"-128\");\n+        assert_eq!(format!(\"{}\", i16::MIN), ~\"-32768\");\n+        assert_eq!(format!(\"{}\", i32::MIN), ~\"-2147483648\");\n+        assert_eq!(format!(\"{}\", i64::MIN), ~\"-9223372036854775808\");\n+    }\n+\n+    #[test]\n+    fn test_format_radix() {\n+        assert_eq!(format!(\"{:04}\", radix(3, 2)), ~\"0011\");\n+        assert_eq!(format!(\"{}\", radix(55, 36)), ~\"1j\");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_radix_base_too_large() {\n+        let _ = radix(55, 37);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    extern crate test;\n+\n+    mod uint {\n+        use super::test::BenchHarness;\n+        use fmt::radix;\n+        use rand::{XorShiftRng, Rng};\n+\n+        #[bench]\n+        fn format_bin(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:t}\", rng.gen::<uint>()); })\n+        }\n+\n+        #[bench]\n+        fn format_oct(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:o}\", rng.gen::<uint>()); })\n+        }\n+\n+        #[bench]\n+        fn format_dec(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:u}\", rng.gen::<uint>()); })\n+        }\n+\n+        #[bench]\n+        fn format_hex(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:x}\", rng.gen::<uint>()); })\n+        }\n+\n+        #[bench]\n+        fn format_base_36(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{}\", radix(rng.gen::<uint>(), 36)); })\n+        }\n+    }\n+\n+    mod int {\n+        use super::test::BenchHarness;\n+        use fmt::radix;\n+        use rand::{XorShiftRng, Rng};\n+\n+        #[bench]\n+        fn format_bin(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:t}\", rng.gen::<int>()); })\n+        }\n+\n+        #[bench]\n+        fn format_oct(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:o}\", rng.gen::<int>()); })\n+        }\n+\n+        #[bench]\n+        fn format_dec(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:d}\", rng.gen::<int>()); })\n+        }\n+\n+        #[bench]\n+        fn format_hex(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:x}\", rng.gen::<int>()); })\n+        }\n+\n+        #[bench]\n+        fn format_base_36(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{}\", radix(rng.gen::<int>(), 36)); })\n+        }\n+    }\n+}"}, {"sha": "150c7bdab29b89cd95dc33aad7c7582a54875825", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e37327bfee6217e46921a294f1a321e2d71300ca/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37327bfee6217e46921a294f1a321e2d71300ca/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=e37327bfee6217e46921a294f1a321e2d71300ca", "patch": "@@ -22,6 +22,7 @@ use mem::size_of;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::{Option, Some, None};\n+use fmt::{Show, Binary, Octal, LowerHex, UpperHex};\n \n pub mod strconv;\n \n@@ -278,7 +279,12 @@ pub trait Int: Integer\n              + CheckedAdd\n              + CheckedSub\n              + CheckedMul\n-             + CheckedDiv {}\n+             + CheckedDiv\n+             + Show\n+             + Binary\n+             + Octal\n+             + LowerHex\n+             + UpperHex {}\n \n /// Returns the smallest power of 2 greater than or equal to `n`.\n #[inline]"}, {"sha": "c0c3074be634dcf6afd1386169a7136c68e3e6a8", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 81, "deletions": 17, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e37327bfee6217e46921a294f1a321e2d71300ca/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37327bfee6217e46921a294f1a321e2d71300ca/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=e37327bfee6217e46921a294f1a321e2d71300ca", "patch": "@@ -804,24 +804,88 @@ mod test {\n #[cfg(test)]\n mod bench {\n     extern crate test;\n-    use self::test::BenchHarness;\n-    use rand::{XorShiftRng, Rng};\n-    use to_str::ToStr;\n-    use f64;\n-\n-    #[bench]\n-    fn uint_to_str_rand(bh: &mut BenchHarness) {\n-        let mut rng = XorShiftRng::new();\n-        bh.iter(|| {\n-            rng.gen::<uint>().to_str();\n-        })\n+\n+    mod uint {\n+        use super::test::BenchHarness;\n+        use rand::{XorShiftRng, Rng};\n+        use num::ToStrRadix;\n+\n+        #[bench]\n+        fn to_str_bin(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<uint>().to_str_radix(2); })\n+        }\n+\n+        #[bench]\n+        fn to_str_oct(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<uint>().to_str_radix(8); })\n+        }\n+\n+        #[bench]\n+        fn to_str_dec(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<uint>().to_str_radix(10); })\n+        }\n+\n+        #[bench]\n+        fn to_str_hex(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<uint>().to_str_radix(16); })\n+        }\n+\n+        #[bench]\n+        fn to_str_base_36(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<uint>().to_str_radix(36); })\n+        }\n     }\n \n-    #[bench]\n-    fn float_to_str_rand(bh: &mut BenchHarness) {\n-        let mut rng = XorShiftRng::new();\n-        bh.iter(|| {\n-            f64::to_str(rng.gen());\n-        })\n+    mod int {\n+        use super::test::BenchHarness;\n+        use rand::{XorShiftRng, Rng};\n+        use num::ToStrRadix;\n+\n+        #[bench]\n+        fn to_str_bin(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<int>().to_str_radix(2); })\n+        }\n+\n+        #[bench]\n+        fn to_str_oct(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<int>().to_str_radix(8); })\n+        }\n+\n+        #[bench]\n+        fn to_str_dec(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<int>().to_str_radix(10); })\n+        }\n+\n+        #[bench]\n+        fn to_str_hex(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<int>().to_str_radix(16); })\n+        }\n+\n+        #[bench]\n+        fn to_str_base_36(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<int>().to_str_radix(36); })\n+        }\n+    }\n+\n+    mod f64 {\n+        use super::test::BenchHarness;\n+        use rand::{XorShiftRng, Rng};\n+        use f64;\n+\n+        #[bench]\n+        fn float_to_str(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { f64::to_str(rng.gen()); })\n+        }\n     }\n }"}, {"sha": "ca798a77a4fd12387e1eb9f891b05300e69603f0", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e37327bfee6217e46921a294f1a321e2d71300ca/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e37327bfee6217e46921a294f1a321e2d71300ca/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=e37327bfee6217e46921a294f1a321e2d71300ca", "patch": "@@ -36,7 +36,6 @@ impl fmt::Signed for B {\n macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a, $b.to_owned()) })\n \n pub fn main() {\n-\n     // Make sure there's a poly formatter that takes anything\n     t!(format!(\"{:?}\", 1), \"1\");\n     t!(format!(\"{:?}\", A), \"A\");\n@@ -49,16 +48,6 @@ pub fn main() {\n     t!(format!(\"hello \\\\{\"), \"hello {\");\n \n     // default formatters should work\n-    t!(format!(\"{}\", 1i), \"1\");\n-    t!(format!(\"{}\", 1i8), \"1\");\n-    t!(format!(\"{}\", 1i16), \"1\");\n-    t!(format!(\"{}\", 1i32), \"1\");\n-    t!(format!(\"{}\", 1i64), \"1\");\n-    t!(format!(\"{}\", 1u), \"1\");\n-    t!(format!(\"{}\", 1u8), \"1\");\n-    t!(format!(\"{}\", 1u16), \"1\");\n-    t!(format!(\"{}\", 1u32), \"1\");\n-    t!(format!(\"{}\", 1u64), \"1\");\n     t!(format!(\"{}\", 1.0f32), \"1\");\n     t!(format!(\"{}\", 1.0f64), \"1\");\n     t!(format!(\"{}\", \"a\"), \"a\");\n@@ -126,94 +115,6 @@ pub fn main() {\n     t!(format!(\"{:-#s}\", \"a\"), \"a\");\n     t!(format!(\"{:+#s}\", \"a\"), \"a\");\n \n-    // Formatting integers should select the right implementation based off the\n-    // type of the argument. Also, hex/octal/binary should be defined for\n-    // integers, but they shouldn't emit the negative sign.\n-    t!(format!(\"{:d}\", -1i), \"-1\");\n-    t!(format!(\"{:d}\", -1i8), \"-1\");\n-    t!(format!(\"{:d}\", -1i16), \"-1\");\n-    t!(format!(\"{:d}\", -1i32), \"-1\");\n-    t!(format!(\"{:d}\", -1i64), \"-1\");\n-    t!(format!(\"{:t}\", 1i), \"1\");\n-    t!(format!(\"{:t}\", 1i8), \"1\");\n-    t!(format!(\"{:t}\", 1i16), \"1\");\n-    t!(format!(\"{:t}\", 1i32), \"1\");\n-    t!(format!(\"{:t}\", 1i64), \"1\");\n-    t!(format!(\"{:x}\", 1i), \"1\");\n-    t!(format!(\"{:x}\", 1i8), \"1\");\n-    t!(format!(\"{:x}\", 1i16), \"1\");\n-    t!(format!(\"{:x}\", 1i32), \"1\");\n-    t!(format!(\"{:x}\", 1i64), \"1\");\n-    t!(format!(\"{:X}\", 1i), \"1\");\n-    t!(format!(\"{:X}\", 1i8), \"1\");\n-    t!(format!(\"{:X}\", 1i16), \"1\");\n-    t!(format!(\"{:X}\", 1i32), \"1\");\n-    t!(format!(\"{:X}\", 1i64), \"1\");\n-    t!(format!(\"{:o}\", 1i), \"1\");\n-    t!(format!(\"{:o}\", 1i8), \"1\");\n-    t!(format!(\"{:o}\", 1i16), \"1\");\n-    t!(format!(\"{:o}\", 1i32), \"1\");\n-    t!(format!(\"{:o}\", 1i64), \"1\");\n-\n-    t!(format!(\"{:u}\", 1u), \"1\");\n-    t!(format!(\"{:u}\", 1u8), \"1\");\n-    t!(format!(\"{:u}\", 1u16), \"1\");\n-    t!(format!(\"{:u}\", 1u32), \"1\");\n-    t!(format!(\"{:u}\", 1u64), \"1\");\n-    t!(format!(\"{:t}\", 1u), \"1\");\n-    t!(format!(\"{:t}\", 1u8), \"1\");\n-    t!(format!(\"{:t}\", 1u16), \"1\");\n-    t!(format!(\"{:t}\", 1u32), \"1\");\n-    t!(format!(\"{:t}\", 1u64), \"1\");\n-    t!(format!(\"{:x}\", 1u), \"1\");\n-    t!(format!(\"{:x}\", 1u8), \"1\");\n-    t!(format!(\"{:x}\", 1u16), \"1\");\n-    t!(format!(\"{:x}\", 1u32), \"1\");\n-    t!(format!(\"{:x}\", 1u64), \"1\");\n-    t!(format!(\"{:X}\", 1u), \"1\");\n-    t!(format!(\"{:X}\", 1u8), \"1\");\n-    t!(format!(\"{:X}\", 1u16), \"1\");\n-    t!(format!(\"{:X}\", 1u32), \"1\");\n-    t!(format!(\"{:X}\", 1u64), \"1\");\n-    t!(format!(\"{:o}\", 1u), \"1\");\n-    t!(format!(\"{:o}\", 1u8), \"1\");\n-    t!(format!(\"{:o}\", 1u16), \"1\");\n-    t!(format!(\"{:o}\", 1u32), \"1\");\n-    t!(format!(\"{:o}\", 1u64), \"1\");\n-\n-    // Test the flags for formatting integers\n-    t!(format!(\"{:3d}\", 1),  \"  1\");\n-    t!(format!(\"{:>3d}\", 1),  \"  1\");\n-    t!(format!(\"{:>+3d}\", 1), \" +1\");\n-    t!(format!(\"{:<3d}\", 1), \"1  \");\n-    t!(format!(\"{:#d}\", 1), \"1\");\n-    t!(format!(\"{:#x}\", 10), \"0xa\");\n-    t!(format!(\"{:#X}\", 10), \"0xA\");\n-    t!(format!(\"{:#5x}\", 10), \"  0xa\");\n-    t!(format!(\"{:#o}\", 10), \"0o12\");\n-    t!(format!(\"{:08x}\", 10),  \"0000000a\");\n-    t!(format!(\"{:8x}\", 10),   \"       a\");\n-    t!(format!(\"{:<8x}\", 10),  \"a       \");\n-    t!(format!(\"{:>8x}\", 10),  \"       a\");\n-    t!(format!(\"{:#08x}\", 10), \"0x00000a\");\n-    t!(format!(\"{:08d}\", -10), \"-0000010\");\n-    t!(format!(\"{:x}\", -1u8), \"ff\");\n-    t!(format!(\"{:X}\", -1u8), \"FF\");\n-    t!(format!(\"{:t}\", -1u8), \"11111111\");\n-    t!(format!(\"{:o}\", -1u8), \"377\");\n-    t!(format!(\"{:#x}\", -1u8), \"0xff\");\n-    t!(format!(\"{:#X}\", -1u8), \"0xFF\");\n-    t!(format!(\"{:#t}\", -1u8), \"0b11111111\");\n-    t!(format!(\"{:#o}\", -1u8), \"0o377\");\n-\n-    // Signed combinations\n-    t!(format!(\"{:+5d}\", 1),  \"   +1\");\n-    t!(format!(\"{:+5d}\", -1), \"   -1\");\n-    t!(format!(\"{:05d}\", 1),   \"00001\");\n-    t!(format!(\"{:05d}\", -1),  \"-0001\");\n-    t!(format!(\"{:+05d}\", 1),  \"+0001\");\n-    t!(format!(\"{:+05d}\", -1), \"-0001\");\n-\n     // Some float stuff\n     t!(format!(\"{:f}\", 1.0f32), \"1\");\n     t!(format!(\"{:f}\", 1.0f64), \"1\");"}]}