{"sha": "cf32b9de1e8f66526c36ad2927458558d2e81093", "node_id": "C_kwDOAAsO6NoAKGNmMzJiOWRlMWU4ZjY2NTI2YzM2YWQyOTI3NDU4NTU4ZDJlODEwOTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-29T09:45:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-29T09:45:26Z"}, "message": "Auto merge of #109720 - Dylan-DPC:rollup-u564m8s, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #108335 (rustdoc + rustdoc-json support for `feature(non_lifetime_binders)`)\n - #109534 (rustdoc: Unsupport importing `doc(primitive)` and `doc(keyword)` modules)\n - #109659 (llvm-wrapper: adapt for LLVM API change)\n - #109664 (Use span of placeholders in format_args!() expansion.)\n - #109683 (Check for overflow in `assemble_candidates_after_normalizing_self_ty`)\n - #109713 (Fix mismatched punctuation in Debug impl of AttrId)\n - #109718 (Rename `IndexVec::last` \u2192 `last_index`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "d2791bbd10641fa720e0cff4ef053e74d519e3bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2791bbd10641fa720e0cff4ef053e74d519e3bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf32b9de1e8f66526c36ad2927458558d2e81093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf32b9de1e8f66526c36ad2927458558d2e81093", "html_url": "https://github.com/rust-lang/rust/commit/cf32b9de1e8f66526c36ad2927458558d2e81093", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf32b9de1e8f66526c36ad2927458558d2e81093/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f346fb0bc655acf72e71f1f16065c271447bdbd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f346fb0bc655acf72e71f1f16065c271447bdbd9", "html_url": "https://github.com/rust-lang/rust/commit/f346fb0bc655acf72e71f1f16065c271447bdbd9"}, {"sha": "14157561fb6ac5937deb1de37eb9cb6fb8cd802f", "url": "https://api.github.com/repos/rust-lang/rust/commits/14157561fb6ac5937deb1de37eb9cb6fb8cd802f", "html_url": "https://github.com/rust-lang/rust/commit/14157561fb6ac5937deb1de37eb9cb6fb8cd802f"}], "stats": {"total": 486, "additions": 348, "deletions": 138}, "files": [{"sha": "cc0fc7b8358fbcbe669dede2748dcb35172aaa1b", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -2570,7 +2570,7 @@ pub enum AttrStyle {\n \n rustc_index::newtype_index! {\n     #[custom_encodable]\n-    #[debug_format = \"AttrId({})]\"]\n+    #[debug_format = \"AttrId({})\"]\n     pub struct AttrId {}\n }\n "}, {"sha": "c41bdc440935c9969508db9a95a378e44574205a", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "modified", "additions": 43, "deletions": 23, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -2,7 +2,7 @@ use super::LoweringContext;\n use rustc_ast as ast;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::*;\n-use rustc_data_structures::fx::FxIndexSet;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_span::{\n     sym,\n@@ -238,7 +238,7 @@ fn make_count<'hir>(\n     ctx: &mut LoweringContext<'_, 'hir>,\n     sp: Span,\n     count: &Option<FormatCount>,\n-    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+    argmap: &mut FxIndexMap<(usize, ArgumentType), Option<Span>>,\n ) -> hir::Expr<'hir> {\n     match count {\n         Some(FormatCount::Literal(n)) => {\n@@ -252,7 +252,7 @@ fn make_count<'hir>(\n         }\n         Some(FormatCount::Argument(arg)) => {\n             if let Ok(arg_index) = arg.index {\n-                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize));\n+                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize), arg.span);\n                 let count_param = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n                     sp,\n                     hir::LangItem::FormatCount,\n@@ -291,12 +291,14 @@ fn make_format_spec<'hir>(\n     ctx: &mut LoweringContext<'_, 'hir>,\n     sp: Span,\n     placeholder: &FormatPlaceholder,\n-    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+    argmap: &mut FxIndexMap<(usize, ArgumentType), Option<Span>>,\n ) -> hir::Expr<'hir> {\n     let position = match placeholder.argument.index {\n         Ok(arg_index) => {\n-            let (i, _) =\n-                argmap.insert_full((arg_index, ArgumentType::Format(placeholder.format_trait)));\n+            let (i, _) = argmap.insert_full(\n+                (arg_index, ArgumentType::Format(placeholder.format_trait)),\n+                placeholder.span,\n+            );\n             ctx.expr_usize(sp, i)\n         }\n         Err(_) => ctx.expr(\n@@ -386,15 +388,18 @@ fn expand_format_args<'hir>(\n \n     // Create a list of all _unique_ (argument, format trait) combinations.\n     // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (1, Display)]\n-    let mut argmap = FxIndexSet::default();\n+    let mut argmap = FxIndexMap::default();\n     for piece in &fmt.template {\n         let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n         if placeholder.format_options != Default::default() {\n             // Can't use basic form if there's any formatting options.\n             use_format_options = true;\n         }\n         if let Ok(index) = placeholder.argument.index {\n-            if !argmap.insert((index, ArgumentType::Format(placeholder.format_trait))) {\n+            if argmap\n+                .insert((index, ArgumentType::Format(placeholder.format_trait)), placeholder.span)\n+                .is_some()\n+            {\n                 // Duplicate (argument, format trait) combination,\n                 // which we'll only put once in the args array.\n                 use_format_options = true;\n@@ -438,7 +443,7 @@ fn expand_format_args<'hir>(\n     // This is an optimization, speeding up compilation about 1-2% in some cases.\n     // See https://github.com/rust-lang/rust/pull/106770#issuecomment-1380790609\n     let use_simple_array = argmap.len() == arguments.len()\n-        && argmap.iter().enumerate().all(|(i, &(j, _))| i == j)\n+        && argmap.iter().enumerate().all(|(i, (&(j, _), _))| i == j)\n         && arguments.iter().skip(1).all(|arg| !may_contain_yield_point(&arg.expr));\n \n     let args = if use_simple_array {\n@@ -452,14 +457,19 @@ fn expand_format_args<'hir>(\n         let elements: Vec<_> = arguments\n             .iter()\n             .zip(argmap)\n-            .map(|(arg, (_, ty))| {\n-                let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+            .map(|(arg, ((_, ty), placeholder_span))| {\n+                let placeholder_span =\n+                    placeholder_span.unwrap_or(arg.expr.span).with_ctxt(macsp.ctxt());\n+                let arg_span = match arg.kind {\n+                    FormatArgumentKind::Captured(_) => placeholder_span,\n+                    _ => arg.expr.span.with_ctxt(macsp.ctxt()),\n+                };\n                 let arg = ctx.lower_expr(&arg.expr);\n                 let ref_arg = ctx.arena.alloc(ctx.expr(\n-                    sp,\n+                    arg_span,\n                     hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, arg),\n                 ));\n-                make_argument(ctx, sp, ref_arg, ty)\n+                make_argument(ctx, placeholder_span, ref_arg, ty)\n             })\n             .collect();\n         ctx.expr_array_ref(macsp, ctx.arena.alloc_from_iter(elements))\n@@ -475,16 +485,26 @@ fn expand_format_args<'hir>(\n         //     }\n         let args_ident = Ident::new(sym::args, macsp);\n         let (args_pat, args_hir_id) = ctx.pat_ident(macsp, args_ident);\n-        let args = ctx.arena.alloc_from_iter(argmap.iter().map(|&(arg_index, ty)| {\n-            let arg = &arguments[arg_index];\n-            let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n-            let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n-            let arg = ctx.arena.alloc(ctx.expr(\n-                sp,\n-                hir::ExprKind::Field(args_ident_expr, Ident::new(sym::integer(arg_index), macsp)),\n-            ));\n-            make_argument(ctx, sp, arg, ty)\n-        }));\n+        let args = ctx.arena.alloc_from_iter(argmap.iter().map(\n+            |(&(arg_index, ty), &placeholder_span)| {\n+                let arg = &arguments[arg_index];\n+                let placeholder_span =\n+                    placeholder_span.unwrap_or(arg.expr.span).with_ctxt(macsp.ctxt());\n+                let arg_span = match arg.kind {\n+                    FormatArgumentKind::Captured(_) => placeholder_span,\n+                    _ => arg.expr.span.with_ctxt(macsp.ctxt()),\n+                };\n+                let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n+                let arg = ctx.arena.alloc(ctx.expr(\n+                    arg_span,\n+                    hir::ExprKind::Field(\n+                        args_ident_expr,\n+                        Ident::new(sym::integer(arg_index), macsp),\n+                    ),\n+                ));\n+                make_argument(ctx, placeholder_span, arg, ty)\n+            },\n+        ));\n         let elements: Vec<_> = arguments\n             .iter()\n             .map(|arg| {"}, {"sha": "40c848de2beedc23a39d1e4ab60fdcf04897f1b9", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -707,7 +707,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn assign(&mut self, dest: Local, rvalue: Rvalue<'tcx>, span: Span) {\n-        let last = self.promoted.basic_blocks.last().unwrap();\n+        let last = self.promoted.basic_blocks.last_index().unwrap();\n         let data = &mut self.promoted[last];\n         data.statements.push(Statement {\n             source_info: SourceInfo::outermost(span),\n@@ -800,7 +800,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         self.visit_operand(arg, loc);\n                     }\n \n-                    let last = self.promoted.basic_blocks.last().unwrap();\n+                    let last = self.promoted.basic_blocks.last_index().unwrap();\n                     let new_target = self.new_block();\n \n                     *self.promoted[last].terminator_mut() = Terminator {"}, {"sha": "acf883fe90cecabc0d58c9b28d44ecee44eff93e", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -216,7 +216,7 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     #[inline]\n-    pub fn last(&self) -> Option<I> {\n+    pub fn last_index(&self) -> Option<I> {\n         self.len().checked_sub(1).map(I::new)\n     }\n "}, {"sha": "736766e35bcc3f996b2ab3fb7a9cf39ac0a2df53", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -1163,13 +1163,6 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n   // Otherwise, we sometimes lose `static` values -- see #60184.\n   computeDeadSymbolsWithConstProp(Ret->Index, Ret->GUIDPreservedSymbols,\n                                   deadIsPrevailing, /* ImportEnabled = */ false);\n-  ComputeCrossModuleImport(\n-    Ret->Index,\n-    Ret->ModuleToDefinedGVSummaries,\n-    Ret->ImportLists,\n-    Ret->ExportLists\n-  );\n-\n   // Resolve LinkOnce/Weak symbols, this has to be computed early be cause it\n   // impacts the caching.\n   //\n@@ -1186,6 +1179,16 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n       return true;\n     return Prevailing->second == S;\n   };\n+  ComputeCrossModuleImport(\n+    Ret->Index,\n+    Ret->ModuleToDefinedGVSummaries,\n+#if LLVM_VERSION_GE(17, 0)\n+    isPrevailing,\n+#endif\n+    Ret->ImportLists,\n+    Ret->ExportLists\n+  );\n+\n   auto recordNewLinkage = [&](StringRef ModuleIdentifier,\n                               GlobalValue::GUID GUID,\n                               GlobalValue::LinkageTypes NewLinkage) {"}, {"sha": "59b506e7345537ed738a00b7a7f02dfa3bf3bc53", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -65,7 +65,7 @@ impl<'tcx> MockBlocks<'tcx> {\n     }\n \n     fn push(&mut self, kind: TerminatorKind<'tcx>) -> BasicBlock {\n-        let next_lo = if let Some(last) = self.blocks.last() {\n+        let next_lo = if let Some(last) = self.blocks.last_index() {\n             self.blocks[last].terminator().source_info.span.hi()\n         } else {\n             BytePos(1)"}, {"sha": "0f7a0eb337ba6a51aaf767cff5b94dadd9b42fff", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -1,5 +1,6 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n+use super::search_graph::OverflowHandler;\n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n use super::{EvalCtxt, SolverMode};\n@@ -279,25 +280,38 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             return\n         };\n \n-        self.probe(|ecx| {\n-            let normalized_ty = ecx.next_ty_infer();\n-            let normalizes_to_goal = goal.with(\n-                tcx,\n-                ty::Binder::dummy(ty::ProjectionPredicate {\n-                    projection_ty,\n-                    term: normalized_ty.into(),\n-                }),\n-            );\n-            ecx.add_goal(normalizes_to_goal);\n-            if let Ok(_) = ecx.try_evaluate_added_goals() {\n-                let normalized_ty = ecx.resolve_vars_if_possible(normalized_ty);\n-\n-                // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n-                // This doesn't work as long as we use `CandidateSource` in winnowing.\n-                let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-                candidates.extend(ecx.assemble_and_evaluate_candidates(goal));\n-            }\n+        let normalized_self_candidates: Result<_, NoSolution> = self.probe(|ecx| {\n+            ecx.with_incremented_depth(\n+                |ecx| {\n+                    let result = ecx.evaluate_added_goals_and_make_canonical_response(\n+                        Certainty::Maybe(MaybeCause::Overflow),\n+                    )?;\n+                    Ok(vec![Candidate { source: CandidateSource::BuiltinImpl, result }])\n+                },\n+                |ecx| {\n+                    let normalized_ty = ecx.next_ty_infer();\n+                    let normalizes_to_goal = goal.with(\n+                        tcx,\n+                        ty::Binder::dummy(ty::ProjectionPredicate {\n+                            projection_ty,\n+                            term: normalized_ty.into(),\n+                        }),\n+                    );\n+                    ecx.add_goal(normalizes_to_goal);\n+                    let _ = ecx.try_evaluate_added_goals()?;\n+                    let normalized_ty = ecx.resolve_vars_if_possible(normalized_ty);\n+                    // NOTE: Alternatively we could call `evaluate_goal` here and only\n+                    // have a `Normalized` candidate. This doesn't work as long as we\n+                    // use `CandidateSource` in winnowing.\n+                    let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n+                    Ok(ecx.assemble_and_evaluate_candidates(goal))\n+                },\n+            )\n         });\n+\n+        if let Ok(normalized_self_candidates) = normalized_self_candidates {\n+            candidates.extend(normalized_self_candidates);\n+        }\n     }\n \n     fn assemble_impl_candidates<G: GoalKind<'tcx>>("}, {"sha": "aeb67666035289679051e979da86fbfadd07f216", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -70,7 +70,7 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// Whether we're currently in a cycle. This should only be used\n     /// for debug assertions.\n     pub(super) fn in_cycle(&self) -> bool {\n-        if let Some(stack_depth) = self.stack.last() {\n+        if let Some(stack_depth) = self.stack.last_index() {\n             // Either the current goal on the stack is the root of a cycle...\n             if self.stack[stack_depth].has_been_used {\n                 return true;"}, {"sha": "574f3e9a5772d3cc406b601aa60b16f775202b49", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/overflow.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -73,6 +73,27 @@ pub(in crate::solve) trait OverflowHandler<'tcx> {\n         self.search_graph().overflow_data.deal_with_overflow();\n         on_overflow(self)\n     }\n+\n+    // Increment the `additional_depth` by one and evaluate `body`, or `on_overflow`\n+    // if the depth is overflown.\n+    fn with_incremented_depth<T>(\n+        &mut self,\n+        on_overflow: impl FnOnce(&mut Self) -> T,\n+        body: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n+        let depth = self.search_graph().stack.len();\n+        self.search_graph().overflow_data.additional_depth += 1;\n+\n+        let result = if self.search_graph().overflow_data.has_overflow(depth) {\n+            self.search_graph().overflow_data.deal_with_overflow();\n+            on_overflow(self)\n+        } else {\n+            body(self)\n+        };\n+\n+        self.search_graph().overflow_data.additional_depth -= 1;\n+        result\n+    }\n }\n \n impl<'tcx> OverflowHandler<'tcx> for EvalCtxt<'_, 'tcx> {"}, {"sha": "2d247bd537bdf15ceabff3b3d2e1a2a430e76ba2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -31,7 +31,6 @@ use rustc_span::hygiene::{AstPass, MacroKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{self, ExpnKind};\n \n-use std::assert_matches::assert_matches;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::collections::BTreeMap;\n@@ -270,15 +269,7 @@ fn clean_where_predicate<'tcx>(\n             let bound_params = wbp\n                 .bound_generic_params\n                 .iter()\n-                .map(|param| {\n-                    // Higher-ranked params must be lifetimes.\n-                    // Higher-ranked lifetimes can't have bounds.\n-                    assert_matches!(\n-                        param,\n-                        hir::GenericParam { kind: hir::GenericParamKind::Lifetime { .. }, .. }\n-                    );\n-                    Lifetime(param.name.ident().name)\n-                })\n+                .map(|param| clean_generic_param(cx, None, param))\n                 .collect();\n             WherePredicate::BoundPredicate {\n                 ty: clean_ty(wbp.bounded_ty, cx),\n@@ -410,7 +401,7 @@ fn clean_projection_predicate<'tcx>(\n         .collect_referenced_late_bound_regions(&pred)\n         .into_iter()\n         .filter_map(|br| match br {\n-            ty::BrNamed(_, name) if br.is_named() => Some(Lifetime(name)),\n+            ty::BrNamed(_, name) if br.is_named() => Some(GenericParamDef::lifetime(name)),\n             _ => None,\n         })\n         .collect();\n@@ -508,7 +499,6 @@ fn clean_generic_param_def<'tcx>(\n         ty::GenericParamDefKind::Const { has_default } => (\n             def.name,\n             GenericParamDefKind::Const {\n-                did: def.def_id,\n                 ty: Box::new(clean_middle_ty(\n                     ty::Binder::dummy(\n                         cx.tcx\n@@ -578,7 +568,6 @@ fn clean_generic_param<'tcx>(\n         hir::GenericParamKind::Const { ty, default } => (\n             param.name.ident().name,\n             GenericParamDefKind::Const {\n-                did: param.def_id.to_def_id(),\n                 ty: Box::new(clean_ty(ty, cx)),\n                 default: default\n                     .map(|ct| Box::new(ty::Const::from_anon_const(cx.tcx, ct.def_id).to_string())),\n@@ -831,7 +820,7 @@ fn clean_ty_generics<'tcx>(\n                         p.get_bound_params()\n                             .into_iter()\n                             .flatten()\n-                            .map(|param| GenericParamDef::lifetime(param.0))\n+                            .cloned()\n                             .collect(),\n                     ));\n                 }"}, {"sha": "3c72b0bf9f2f6192fe50902ed8ce20a42b6ea1cb", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -49,11 +49,7 @@ pub(crate) fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> ThinVec<WP\n     equalities.retain(|(lhs, rhs, bound_params)| {\n         let Some((ty, trait_did, name)) = lhs.projection() else { return true; };\n         let Some((bounds, _)) = tybounds.get_mut(ty) else { return true };\n-        let bound_params = bound_params\n-            .into_iter()\n-            .map(|param| clean::GenericParamDef::lifetime(param.0))\n-            .collect();\n-        merge_bounds(cx, bounds, bound_params, trait_did, name, rhs)\n+        merge_bounds(cx, bounds, bound_params.clone(), trait_did, name, rhs)\n     });\n \n     // And finally, let's reassemble everything"}, {"sha": "909e0a07e4cb2992440da02d7d813637e6189153", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -232,14 +232,6 @@ impl ExternalCrate {\n                         hir::ItemKind::Mod(_) => {\n                             as_keyword(Res::Def(DefKind::Mod, id.owner_id.to_def_id()))\n                         }\n-                        hir::ItemKind::Use(path, hir::UseKind::Single)\n-                            if tcx.visibility(id.owner_id).is_public() =>\n-                        {\n-                            path.res\n-                                .iter()\n-                                .find_map(|res| as_keyword(res.expect_non_local()))\n-                                .map(|(_, prim)| (id.owner_id.to_def_id(), prim))\n-                        }\n                         _ => None,\n                     }\n                 })\n@@ -302,15 +294,6 @@ impl ExternalCrate {\n                         hir::ItemKind::Mod(_) => {\n                             as_primitive(Res::Def(DefKind::Mod, id.owner_id.to_def_id()))\n                         }\n-                        hir::ItemKind::Use(path, hir::UseKind::Single)\n-                            if tcx.visibility(id.owner_id).is_public() =>\n-                        {\n-                            path.res\n-                                .iter()\n-                                .find_map(|res| as_primitive(res.expect_non_local()))\n-                                // Pretend the primitive is local.\n-                                .map(|(_, prim)| (id.owner_id.to_def_id(), prim))\n-                        }\n                         _ => None,\n                     }\n                 })\n@@ -1236,9 +1219,9 @@ impl Lifetime {\n \n #[derive(Clone, Debug)]\n pub(crate) enum WherePredicate {\n-    BoundPredicate { ty: Type, bounds: Vec<GenericBound>, bound_params: Vec<Lifetime> },\n+    BoundPredicate { ty: Type, bounds: Vec<GenericBound>, bound_params: Vec<GenericParamDef> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<GenericBound> },\n-    EqPredicate { lhs: Box<Type>, rhs: Box<Term>, bound_params: Vec<Lifetime> },\n+    EqPredicate { lhs: Box<Type>, rhs: Box<Term>, bound_params: Vec<GenericParamDef> },\n }\n \n impl WherePredicate {\n@@ -1250,7 +1233,7 @@ impl WherePredicate {\n         }\n     }\n \n-    pub(crate) fn get_bound_params(&self) -> Option<&[Lifetime]> {\n+    pub(crate) fn get_bound_params(&self) -> Option<&[GenericParamDef]> {\n         match self {\n             Self::BoundPredicate { bound_params, .. } | Self::EqPredicate { bound_params, .. } => {\n                 Some(bound_params)\n@@ -1264,7 +1247,7 @@ impl WherePredicate {\n pub(crate) enum GenericParamDefKind {\n     Lifetime { outlives: Vec<Lifetime> },\n     Type { did: DefId, bounds: Vec<GenericBound>, default: Option<Box<Type>>, synthetic: bool },\n-    Const { did: DefId, ty: Box<Type>, default: Option<Box<String>> },\n+    Const { ty: Box<Type>, default: Option<Box<String>> },\n }\n \n impl GenericParamDefKind {"}, {"sha": "0895bb510d481f084e4c8c3de2d9ffb90ecfc299", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -307,13 +307,13 @@ pub(crate) fn print_where_clause<'a, 'tcx: 'a>(\n                                 write!(\n                                     f,\n                                     \"for<{:#}> {ty_cx:#}: {generic_bounds:#}\",\n-                                    comma_sep(bound_params.iter().map(|lt| lt.print()), true)\n+                                    comma_sep(bound_params.iter().map(|lt| lt.print(cx)), true)\n                                 )\n                             } else {\n                                 write!(\n                                     f,\n                                     \"for&lt;{}&gt; {ty_cx}: {generic_bounds}\",\n-                                    comma_sep(bound_params.iter().map(|lt| lt.print()), true)\n+                                    comma_sep(bound_params.iter().map(|lt| lt.print(cx)), true)\n                                 )\n                             }\n                         }"}, {"sha": "59d67f27b3006a600a68804bde363f394fdb835c", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -456,7 +456,7 @@ impl FromWithTcx<clean::GenericParamDefKind> for GenericParamDefKind {\n                 default: default.map(|x| (*x).into_tcx(tcx)),\n                 synthetic,\n             },\n-            Const { did: _, ty, default } => GenericParamDefKind::Const {\n+            Const { ty, default } => GenericParamDefKind::Const {\n                 type_: (*ty).into_tcx(tcx),\n                 default: default.map(|x| *x),\n             },\n@@ -473,9 +473,35 @@ impl FromWithTcx<clean::WherePredicate> for WherePredicate {\n                 bounds: bounds.into_tcx(tcx),\n                 generic_params: bound_params\n                     .into_iter()\n-                    .map(|x| GenericParamDef {\n-                        name: x.0.to_string(),\n-                        kind: GenericParamDefKind::Lifetime { outlives: vec![] },\n+                    .map(|x| {\n+                        let name = x.name.to_string();\n+                        let kind = match x.kind {\n+                            clean::GenericParamDefKind::Lifetime { outlives } => {\n+                                GenericParamDefKind::Lifetime {\n+                                    outlives: outlives.iter().map(|lt| lt.0.to_string()).collect(),\n+                                }\n+                            }\n+                            clean::GenericParamDefKind::Type {\n+                                did: _,\n+                                bounds,\n+                                default,\n+                                synthetic,\n+                            } => GenericParamDefKind::Type {\n+                                bounds: bounds\n+                                    .into_iter()\n+                                    .map(|bound| bound.into_tcx(tcx))\n+                                    .collect(),\n+                                default: default.map(|ty| (*ty).into_tcx(tcx)),\n+                                synthetic,\n+                            },\n+                            clean::GenericParamDefKind::Const { ty, default } => {\n+                                GenericParamDefKind::Const {\n+                                    type_: (*ty).into_tcx(tcx),\n+                                    default: default.map(|d| *d),\n+                                }\n+                            }\n+                        };\n+                        GenericParamDef { name, kind }\n                     })\n                     .collect(),\n             },"}, {"sha": "f6f2344e82fac492b829d95991e3f9a31b392c96", "filename": "tests/mir-opt/sroa/lifetimes.foo.ScalarReplacementOfAggregates.diff", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fmir-opt%2Fsroa%2Flifetimes.foo.ScalarReplacementOfAggregates.diff", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fmir-opt%2Fsroa%2Flifetimes.foo.ScalarReplacementOfAggregates.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsroa%2Flifetimes.foo.ScalarReplacementOfAggregates.diff?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -19,12 +19,12 @@\n       let mut _17: &[core::fmt::ArgumentV1<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n       let _18: &[core::fmt::ArgumentV1<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n       let _19: [core::fmt::ArgumentV1<'_>; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _20: core::fmt::ArgumentV1<'_>; // in scope 0 at $DIR/lifetimes.rs:+10:21: +10:22\n-      let mut _21: &std::boxed::Box<dyn std::fmt::Display>; // in scope 0 at $DIR/lifetimes.rs:+10:21: +10:22\n-      let _22: &std::boxed::Box<dyn std::fmt::Display>; // in scope 0 at $DIR/lifetimes.rs:+10:21: +10:22\n-      let mut _23: core::fmt::ArgumentV1<'_>; // in scope 0 at $DIR/lifetimes.rs:+10:25: +10:26\n-      let mut _24: &u32;                   // in scope 0 at $DIR/lifetimes.rs:+10:25: +10:26\n-      let _25: &u32;                       // in scope 0 at $DIR/lifetimes.rs:+10:25: +10:26\n+      let mut _20: core::fmt::ArgumentV1<'_>; // in scope 0 at $DIR/lifetimes.rs:+10:20: +10:23\n+      let mut _21: &std::boxed::Box<dyn std::fmt::Display>; // in scope 0 at $DIR/lifetimes.rs:+10:20: +10:23\n+      let _22: &std::boxed::Box<dyn std::fmt::Display>; // in scope 0 at $DIR/lifetimes.rs:+10:20: +10:23\n+      let mut _23: core::fmt::ArgumentV1<'_>; // in scope 0 at $DIR/lifetimes.rs:+10:24: +10:27\n+      let mut _24: &u32;                   // in scope 0 at $DIR/lifetimes.rs:+10:24: +10:27\n+      let _25: &u32;                       // in scope 0 at $DIR/lifetimes.rs:+10:24: +10:27\n       let mut _27: bool;                   // in scope 0 at $DIR/lifetimes.rs:+12:1: +12:2\n       let mut _28: isize;                  // in scope 0 at $DIR/lifetimes.rs:+12:1: +12:2\n       let mut _29: isize;                  // in scope 0 at $DIR/lifetimes.rs:+12:1: +12:2\n@@ -108,34 +108,34 @@\n           StorageLive(_17);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n           StorageLive(_18);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n           StorageLive(_19);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageLive(_20);                // scope 4 at $DIR/lifetimes.rs:+10:21: +10:22\n-          StorageLive(_21);                // scope 4 at $DIR/lifetimes.rs:+10:21: +10:22\n-          StorageLive(_22);                // scope 4 at $DIR/lifetimes.rs:+10:21: +10:22\n-          _22 = &_8;                       // scope 4 at $DIR/lifetimes.rs:+10:21: +10:22\n-          _21 = &(*_22);                   // scope 4 at $DIR/lifetimes.rs:+10:21: +10:22\n-          _20 = core::fmt::ArgumentV1::<'_>::new_display::<Box<dyn std::fmt::Display>>(move _21) -> bb3; // scope 4 at $DIR/lifetimes.rs:+10:21: +10:22\n+          StorageLive(_20);                // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n+          StorageLive(_21);                // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n+          StorageLive(_22);                // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n+          _22 = &_8;                       // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n+          _21 = &(*_22);                   // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n+          _20 = core::fmt::ArgumentV1::<'_>::new_display::<Box<dyn std::fmt::Display>>(move _21) -> bb3; // scope 4 at $DIR/lifetimes.rs:+10:20: +10:23\n                                            // mir::Constant\n-                                           // + span: $DIR/lifetimes.rs:27:21: 27:22\n+                                           // + span: $DIR/lifetimes.rs:27:20: 27:23\n                                            // + user_ty: UserType(4)\n                                            // + literal: Const { ty: for<'b> fn(&'b Box<dyn std::fmt::Display>) -> core::fmt::ArgumentV1<'b> {core::fmt::ArgumentV1::<'_>::new_display::<Box<dyn std::fmt::Display>>}, val: Value(<ZST>) }\n       }\n   \n       bb3: {\n-          StorageDead(_21);                // scope 4 at $DIR/lifetimes.rs:+10:21: +10:22\n-          StorageLive(_23);                // scope 4 at $DIR/lifetimes.rs:+10:25: +10:26\n-          StorageLive(_24);                // scope 4 at $DIR/lifetimes.rs:+10:25: +10:26\n-          StorageLive(_25);                // scope 4 at $DIR/lifetimes.rs:+10:25: +10:26\n-          _25 = &_6;                       // scope 4 at $DIR/lifetimes.rs:+10:25: +10:26\n-          _24 = &(*_25);                   // scope 4 at $DIR/lifetimes.rs:+10:25: +10:26\n-          _23 = core::fmt::ArgumentV1::<'_>::new_display::<u32>(move _24) -> bb4; // scope 4 at $DIR/lifetimes.rs:+10:25: +10:26\n+          StorageDead(_21);                // scope 4 at $DIR/lifetimes.rs:+10:22: +10:23\n+          StorageLive(_23);                // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n+          StorageLive(_24);                // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n+          StorageLive(_25);                // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n+          _25 = &_6;                       // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n+          _24 = &(*_25);                   // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n+          _23 = core::fmt::ArgumentV1::<'_>::new_display::<u32>(move _24) -> bb4; // scope 4 at $DIR/lifetimes.rs:+10:24: +10:27\n                                            // mir::Constant\n-                                           // + span: $DIR/lifetimes.rs:27:25: 27:26\n+                                           // + span: $DIR/lifetimes.rs:27:24: 27:27\n                                            // + user_ty: UserType(5)\n                                            // + literal: Const { ty: for<'b> fn(&'b u32) -> core::fmt::ArgumentV1<'b> {core::fmt::ArgumentV1::<'_>::new_display::<u32>}, val: Value(<ZST>) }\n       }\n   \n       bb4: {\n-          StorageDead(_24);                // scope 4 at $DIR/lifetimes.rs:+10:25: +10:26\n+          StorageDead(_24);                // scope 4 at $DIR/lifetimes.rs:+10:26: +10:27\n           _19 = [move _20, move _23];      // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n           StorageDead(_23);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n           StorageDead(_20);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL"}, {"sha": "ca5a008344af22a2b537f5f4e03fe8873ca4594e", "filename": "tests/rustdoc-json/non_lifetime_binders.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Frustdoc-json%2Fnon_lifetime_binders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Frustdoc-json%2Fnon_lifetime_binders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-json%2Fnon_lifetime_binders.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -0,0 +1,24 @@\n+// ignore-tidy-linelength\n+\n+#![feature(non_lifetime_binders)]\n+#![allow(incomplete_features)]\n+\n+#![no_core]\n+#![feature(lang_items, no_core)]\n+\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+pub trait Trait {}\n+\n+#[lang = \"phantom_data\"]\n+struct PhantomData<T_>;\n+\n+pub struct Wrapper<T_>(PhantomData<T_>);\n+\n+// @count \"$.index[*][?(@.name=='foo')].inner.generics.where_predicates[0].bound_predicate.generic_params[*]\" 2\n+// @is \"$.index[*][?(@.name=='foo')].inner.generics.where_predicates[0].bound_predicate.generic_params[0].name\" \\\"\\'a\\\"\n+// @is \"$.index[*][?(@.name=='foo')].inner.generics.where_predicates[0].bound_predicate.generic_params[0].kind\" '{ \"lifetime\": { \"outlives\": [] } }'\n+// @is \"$.index[*][?(@.name=='foo')].inner.generics.where_predicates[0].bound_predicate.generic_params[1].name\" \\\"T\\\"\n+// @is \"$.index[*][?(@.name=='foo')].inner.generics.where_predicates[0].bound_predicate.generic_params[1].kind\" '{ \"type\": { \"bounds\": [], \"default\": null, \"synthetic\": false } }'\n+pub fn foo() where for<'a, T> &'a Wrapper<T>: Trait {}"}, {"sha": "614f2c1c08e87a4af95c4353b573b12d845383a2", "filename": "tests/rustdoc/issue-15318-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Frustdoc%2Fissue-15318-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Frustdoc%2Fissue-15318-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-15318-2.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -6,7 +6,7 @@ extern crate issue_15318;\n \n pub use issue_15318::ptr;\n \n-// @has issue_15318_2/fn.bar.html \\\n+// @!has issue_15318_2/fn.bar.html \\\n //          '//*[@href=\"primitive.pointer.html\"]' \\\n //          '*mut T'\n pub fn bar<T>(ptr: *mut T) {}"}, {"sha": "da9a4e6a84d5a4664dde104be5879f6d2b209453", "filename": "tests/rustdoc/non_lifetime_binders.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Frustdoc%2Fnon_lifetime_binders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Frustdoc%2Fnon_lifetime_binders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnon_lifetime_binders.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -0,0 +1,9 @@\n+#![feature(non_lifetime_binders)]\n+#![allow(incomplete_features)]\n+\n+pub trait Trait {}\n+\n+pub struct Wrapper<T: ?Sized>(Box<T>);\n+\n+// @has non_lifetime_binders/fn.foo.html '//pre' \"fn foo()where for<'a, T> &'a Wrapper<T>: Trait\"\n+pub fn foo() where for<'a, T> &'a Wrapper<T>: Trait {}"}, {"sha": "70a1abb0a95552866b28d4c69fafda6f376cf5dc", "filename": "tests/ui/consts/const-eval/format.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.stderr?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -1,8 +1,8 @@\n error[E0015]: cannot call non-const formatting macro in constant functions\n-  --> $DIR/format.rs:2:20\n+  --> $DIR/format.rs:2:13\n    |\n LL |     panic!(\"{:?}\", 0);\n-   |                    ^\n+   |             ^^^^\n    |\n    = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n    = note: this error originates in the macro `$crate::const_format_args` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n@@ -17,10 +17,10 @@ LL |     panic!(\"{:?}\", 0);\n    = note: this error originates in the macro `$crate::const_format_args` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0015]: cannot call non-const formatting macro in constant functions\n-  --> $DIR/format.rs:8:22\n+  --> $DIR/format.rs:8:15\n    |\n LL |     println!(\"{:?}\", 0);\n-   |                      ^\n+   |               ^^^^\n    |\n    = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)"}, {"sha": "c7acb08f84b6cdb7130e3d9f1369bca27b9451f9", "filename": "tests/ui/fmt/format-args-argument-span.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ffmt%2Fformat-args-argument-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ffmt%2Fformat-args-argument-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fformat-args-argument-span.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -0,0 +1,22 @@\n+// check-compile\n+\n+struct DisplayOnly;\n+\n+impl std::fmt::Display for DisplayOnly {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {\n+    let x = Some(1);\n+    println!(\"{x:?} {x} {x:?}\");\n+    //~^ ERROR: `Option<{integer}>` doesn't implement `std::fmt::Display`\n+    println!(\"{x:?} {x} {x:?}\", x = Some(1));\n+    //~^ ERROR: `Option<{integer}>` doesn't implement `std::fmt::Display`\n+    let x = DisplayOnly;\n+    println!(\"{x} {x:?} {x}\");\n+    //~^ ERROR: `DisplayOnly` doesn't implement `Debug`\n+    println!(\"{x} {x:?} {x}\", x = DisplayOnly);\n+    //~^ ERROR: `DisplayOnly` doesn't implement `Debug`\n+}"}, {"sha": "b060b2cd33930dc9262bbd9e47327a1f023dc74b", "filename": "tests/ui/fmt/format-args-argument-span.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ffmt%2Fformat-args-argument-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ffmt%2Fformat-args-argument-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fformat-args-argument-span.stderr?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -0,0 +1,51 @@\n+error[E0277]: `Option<{integer}>` doesn't implement `std::fmt::Display`\n+  --> $DIR/format-args-argument-span.rs:13:21\n+   |\n+LL |     println!(\"{x:?} {x} {x:?}\");\n+   |                     ^^^ `Option<{integer}>` cannot be formatted with the default formatter\n+   |\n+   = help: the trait `std::fmt::Display` is not implemented for `Option<{integer}>`\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: `Option<{integer}>` doesn't implement `std::fmt::Display`\n+  --> $DIR/format-args-argument-span.rs:15:37\n+   |\n+LL |     println!(\"{x:?} {x} {x:?}\", x = Some(1));\n+   |                                     ^^^^^^^ `Option<{integer}>` cannot be formatted with the default formatter\n+   |\n+   = help: the trait `std::fmt::Display` is not implemented for `Option<{integer}>`\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: `DisplayOnly` doesn't implement `Debug`\n+  --> $DIR/format-args-argument-span.rs:18:19\n+   |\n+LL |     println!(\"{x} {x:?} {x}\");\n+   |                   ^^^^^ `DisplayOnly` cannot be formatted using `{:?}`\n+   |\n+   = help: the trait `Debug` is not implemented for `DisplayOnly`\n+   = note: add `#[derive(Debug)]` to `DisplayOnly` or manually `impl Debug for DisplayOnly`\n+   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `DisplayOnly` with `#[derive(Debug)]`\n+   |\n+LL | #[derive(Debug)]\n+   |\n+\n+error[E0277]: `DisplayOnly` doesn't implement `Debug`\n+  --> $DIR/format-args-argument-span.rs:20:35\n+   |\n+LL |     println!(\"{x} {x:?} {x}\", x = DisplayOnly);\n+   |                                   ^^^^^^^^^^^ `DisplayOnly` cannot be formatted using `{:?}`\n+   |\n+   = help: the trait `Debug` is not implemented for `DisplayOnly`\n+   = note: add `#[derive(Debug)]` to `DisplayOnly` or manually `impl Debug for DisplayOnly`\n+   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `DisplayOnly` with `#[derive(Debug)]`\n+   |\n+LL | #[derive(Debug)]\n+   |\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "bf18fb315c94d977f87313bfd0b4e57c9369075d", "filename": "tests/ui/fmt/ifmt-bad-arg.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ffmt%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ffmt%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fifmt-bad-arg.stderr?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -300,10 +300,9 @@ error[E0308]: mismatched types\n   --> $DIR/ifmt-bad-arg.rs:78:32\n    |\n LL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n-   |                                ^^^\n-   |                                |\n-   |                                expected `&usize`, found `&{float}`\n-   |                                arguments to this function are incorrect\n+   |                    --          ^^^ expected `&usize`, found `&{float}`\n+   |                    |\n+   |                    arguments to this function are incorrect\n    |\n    = note: expected reference `&usize`\n               found reference `&{float}`\n@@ -315,10 +314,9 @@ error[E0308]: mismatched types\n   --> $DIR/ifmt-bad-arg.rs:81:35\n    |\n LL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n-   |                                   ^^^\n-   |                                   |\n-   |                                   expected `&usize`, found `&{float}`\n-   |                                   arguments to this function are incorrect\n+   |                       --          ^^^ expected `&usize`, found `&{float}`\n+   |                       |\n+   |                       arguments to this function are incorrect\n    |\n    = note: expected reference `&usize`\n               found reference `&{float}`"}, {"sha": "dc2dee3f3415c984e37b846ff5eb7ff176e9a7e4", "filename": "tests/ui/fmt/ifmt-unimpl.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -2,7 +2,9 @@ error[E0277]: the trait bound `str: UpperHex` is not satisfied\n   --> $DIR/ifmt-unimpl.rs:2:21\n    |\n LL |     format!(\"{:X}\", \"3\");\n-   |                     ^^^ the trait `UpperHex` is not implemented for `str`\n+   |              ----   ^^^ the trait `UpperHex` is not implemented for `str`\n+   |              |\n+   |              required by a bound introduced by this call\n    |\n    = help: the following other types implement trait `UpperHex`:\n              &T"}, {"sha": "5415c247c8fff269dd6e3795315dd31e0092396c", "filename": "tests/ui/suggestions/issue-97760.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Fsuggestions%2Fissue-97760.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Fsuggestions%2Fissue-97760.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-97760.stderr?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: `<impl IntoIterator as IntoIterator>::Item` doesn't implement `std::fmt::Display`\n-  --> $DIR/issue-97760.rs:4:20\n+  --> $DIR/issue-97760.rs:4:19\n    |\n LL |         println!(\"{x}\");\n-   |                    ^ `<impl IntoIterator as IntoIterator>::Item` cannot be formatted with the default formatter\n+   |                   ^^^ `<impl IntoIterator as IntoIterator>::Item` cannot be formatted with the default formatter\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `<impl IntoIterator as IntoIterator>::Item`\n    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead"}, {"sha": "7417d6018a131e881359100bba62cd9d32ec2455", "filename": "tests/ui/traits/new-solver/recursive-self-normalization-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+trait Foo1 {\n+    type Assoc1;\n+}\n+\n+trait Foo2 {\n+    type Assoc2;\n+}\n+\n+trait Bar {}\n+fn needs_bar<S: Bar>() {}\n+\n+fn test<T: Foo1<Assoc1 = <T as Foo2>::Assoc2> + Foo2<Assoc2 = <T as Foo1>::Assoc1>>() {\n+    needs_bar::<T::Assoc1>();\n+    //~^ ERROR type annotations needed\n+}\n+\n+fn main() {}"}, {"sha": "29cfa47a1050a38133a7b7c13744cdc316f681e1", "filename": "tests/ui/traits/new-solver/recursive-self-normalization-2.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/recursive-self-normalization-2.rs:15:5\n+   |\n+LL |     needs_bar::<T::Assoc1>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `S` declared on the function `needs_bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "f3e3d71d813e4da2f2c534a0b5c59d5b32171dd3", "filename": "tests/ui/traits/new-solver/recursive-self-normalization.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.rs?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+trait Foo {\n+    type Assoc;\n+}\n+\n+trait Bar {}\n+fn needs_bar<S: Bar>() {}\n+\n+fn test<T: Foo<Assoc = <T as Foo>::Assoc>>() {\n+    needs_bar::<T::Assoc>();\n+    //~^ ERROR type annotations needed\n+}\n+\n+fn main() {}"}, {"sha": "ba39981893d447134c8955cfaf40e04c478ccbb1", "filename": "tests/ui/traits/new-solver/recursive-self-normalization.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf32b9de1e8f66526c36ad2927458558d2e81093/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr?ref=cf32b9de1e8f66526c36ad2927458558d2e81093", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/recursive-self-normalization.rs:11:5\n+   |\n+LL |     needs_bar::<T::Assoc>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `S` declared on the function `needs_bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}]}