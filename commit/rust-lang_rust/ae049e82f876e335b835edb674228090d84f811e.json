{"sha": "ae049e82f876e335b835edb674228090d84f811e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMDQ5ZTgyZjg3NmUzMzViODM1ZWRiNjc0MjI4MDkwZDg0ZjgxMWU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-22T07:50:19Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-23T16:45:20Z"}, "message": "sync: Rewrite the base primitives\n\nThis commit rewrites the core primitives of the sync library: Mutex, RWLock, and\nSemaphore. These primitives now have updated, more modernized apis:\n\n* Guards are returned instead of locking with closures. All condition variables\n  have moved inside the guards and extraneous methods have been removed.\n* Downgrading on an rwlock is now done through the guard instead of the rwlock\n  itself.\n\nThese types are meant to be general locks, not locks of an internal type (for\nexternal usage). New types will be introduced for locking shared data.", "tree": {"sha": "5af86032aed2022aa2402e1e50e52f832e08cbfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5af86032aed2022aa2402e1e50e52f832e08cbfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae049e82f876e335b835edb674228090d84f811e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae049e82f876e335b835edb674228090d84f811e", "html_url": "https://github.com/rust-lang/rust/commit/ae049e82f876e335b835edb674228090d84f811e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae049e82f876e335b835edb674228090d84f811e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53e451f4106c0eb6614b4c534744e81c6100cbbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/53e451f4106c0eb6614b4c534744e81c6100cbbd", "html_url": "https://github.com/rust-lang/rust/commit/53e451f4106c0eb6614b4c534744e81c6100cbbd"}], "stats": {"total": 1023, "additions": 406, "deletions": 617}, "files": [{"sha": "36f0748fe717f80b667c243401d2e2f70cb3ada2", "filename": "src/libsync/raw.rs", "status": "renamed", "additions": 406, "deletions": 617, "changes": 1023, "blob_url": "https://github.com/rust-lang/rust/blob/ae049e82f876e335b835edb674228090d84f811e/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae049e82f876e335b835edb674228090d84f811e/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=ae049e82f876e335b835edb674228090d84f811e", "patch": "@@ -8,42 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(missing_doc)];\n-\n-/**\n- * The concurrency primitives you know and love.\n- *\n- * Maybe once we have a \"core exports x only to std\" mechanism, these can be\n- * in std.\n- */\n+//! Raw concurrency primitives you know and love.\n+//!\n+//! These primitives are not recommended for general use, but are provided for\n+//! flavorful use-cases. It is recommended to use the types at the top of the\n+//! `sync` crate which wrap values directly and provide safer abstractions for\n+//! containing data.\n \n use std::cast;\n use std::comm;\n use std::kinds::marker;\n use std::mem::replace;\n-use std::sync::arc::UnsafeArc;\n use std::sync::atomics;\n use std::unstable::finally::Finally;\n \n-use arc::MutexArc;\n+use mutex;\n \n /****************************************************************************\n  * Internals\n  ****************************************************************************/\n \n-pub mod mutex;\n-pub mod one;\n-mod mpsc_intrusive;\n-\n // Each waiting task receives on one of these.\n-#[doc(hidden)]\n type WaitEnd = Receiver<()>;\n-#[doc(hidden)]\n type SignalEnd = Sender<()>;\n // A doubly-ended queue of waiting tasks.\n-#[doc(hidden)]\n-struct WaitQueue { head: Receiver<SignalEnd>,\n-                   tail: Sender<SignalEnd> }\n+struct WaitQueue {\n+    head: Receiver<SignalEnd>,\n+    tail: Sender<SignalEnd>,\n+}\n \n impl WaitQueue {\n     fn new() -> WaitQueue {\n@@ -90,33 +82,49 @@ impl WaitQueue {\n }\n \n // The building-block used to make semaphores, mutexes, and rwlocks.\n-struct SemInner<Q> {\n+struct Sem<Q> {\n     lock: mutex::Mutex,\n+    // n.b, we need Sem to be `Share`, but the WaitQueue type is not send/share\n+    //      (for good reason). We have an internal invariant on this semaphore,\n+    //      however, that the queue is never accessed outside of a locked\n+    //      context. For this reason, we shove these behind a pointer which will\n+    //      be inferred to be `Share`.\n+    //\n+    // FIXME: this requires an extra allocation, which is bad.\n+    inner: *()\n+}\n+\n+struct SemInner<Q> {\n     count: int,\n-    waiters:   WaitQueue,\n+    waiters: WaitQueue,\n     // Can be either unit or another waitqueue. Some sems shouldn't come with\n     // a condition variable attached, others should.\n-    blocked:   Q\n+    blocked: Q,\n }\n \n-struct Sem<Q>(UnsafeArc<SemInner<Q>>);\n+#[must_use]\n+struct SemGuard<'a, Q> {\n+    sem: &'a Sem<Q>,\n+}\n \n-#[doc(hidden)]\n-impl<Q:Send> Sem<Q> {\n+impl<Q: Send> Sem<Q> {\n     fn new(count: int, q: Q) -> Sem<Q> {\n-        Sem(UnsafeArc::new(SemInner {\n-            count: count,\n-            waiters: WaitQueue::new(),\n-            blocked: q,\n+        let inner = unsafe {\n+            cast::transmute(~SemInner {\n+                waiters: WaitQueue::new(),\n+                count: count,\n+                blocked: q,\n+            })\n+        };\n+        Sem {\n             lock: mutex::Mutex::new(),\n-        }))\n+            inner: inner,\n+        }\n     }\n \n     unsafe fn with(&self, f: |&mut SemInner<Q>|) {\n-        let Sem(ref arc) = *self;\n-        let state = arc.get();\n-        let _g = (*state).lock.lock();\n-        f(cast::transmute(state));\n+        let _g = self.lock.lock();\n+        f(&mut *(self.inner as *mut SemInner<Q>))\n     }\n \n     pub fn acquire(&self) {\n@@ -130,7 +138,8 @@ impl<Q:Send> Sem<Q> {\n                     waiter_nobe = Some(state.waiters.wait_end());\n                 }\n             });\n-            // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n+            // Uncomment if you wish to test for sem races. Not\n+            // valgrind-friendly.\n             /* for _ in range(0, 1000) { task::deschedule(); } */\n             // Need to wait outside the exclusive.\n             if waiter_nobe.is_some() {\n@@ -150,24 +159,42 @@ impl<Q:Send> Sem<Q> {\n         }\n     }\n \n-    pub fn access<U>(&self, blk: || -> U) -> U {\n-        (|| {\n-            self.acquire();\n-            blk()\n-        }).finally(|| {\n-            self.release();\n-        })\n+    pub fn access<'a>(&'a self) -> SemGuard<'a, Q> {\n+        self.acquire();\n+        SemGuard { sem: self }\n     }\n }\n \n-#[doc(hidden)]\n-impl Sem<Vec<WaitQueue> > {\n-    fn new_and_signal(count: int, num_condvars: uint)\n-        -> Sem<Vec<WaitQueue> > {\n+#[unsafe_destructor]\n+impl<Q: Send> Drop for Sem<Q> {\n+    fn drop(&mut self) {\n+        let _waiters: ~SemInner<Q> = unsafe { cast::transmute(self.inner) };\n+        self.inner = 0 as *();\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a, Q: Send> Drop for SemGuard<'a, Q> {\n+    fn drop(&mut self) {\n+        self.sem.release();\n+    }\n+}\n+\n+impl Sem<Vec<WaitQueue>> {\n+    fn new_and_signal(count: int, num_condvars: uint) -> Sem<Vec<WaitQueue>> {\n         let mut queues = Vec::new();\n         for _ in range(0, num_condvars) { queues.push(WaitQueue::new()); }\n         Sem::new(count, queues)\n     }\n+\n+    // The only other places that condvars get built are rwlock.write_cond()\n+    // and rwlock_write_mode.\n+    pub fn access_cond<'a>(&'a self) -> SemCondGuard<'a> {\n+        SemCondGuard {\n+            guard: self.access(),\n+            cvar: Condvar { sem: self, order: Nothing, nopod: marker::NoPod },\n+        }\n+    }\n }\n \n // FIXME(#3598): Want to use an Option down below, but we need a custom enum\n@@ -195,27 +222,23 @@ pub struct Condvar<'a> {\n }\n \n impl<'a> Condvar<'a> {\n-    /**\n-     * Atomically drop the associated lock, and block until a signal is sent.\n-     *\n-     * # Failure\n-     * A task which is killed (i.e., by linked failure with another task)\n-     * while waiting on a condition variable will wake up, fail, and unlock\n-     * the associated lock as it unwinds.\n-     */\n+    /// Atomically drop the associated lock, and block until a signal is sent.\n+    ///\n+    /// # Failure\n+    ///\n+    /// A task which is killed while waiting on a condition variable will wake\n+    /// up, fail, and unlock the associated lock as it unwinds.\n     pub fn wait(&self) { self.wait_on(0) }\n \n-    /**\n-     * As wait(), but can specify which of multiple condition variables to\n-     * wait on. Only a signal_on() or broadcast_on() with the same condvar_id\n-     * will wake this thread.\n-     *\n-     * The associated lock must have been initialised with an appropriate\n-     * number of condvars. The condvar_id must be between 0 and num_condvars-1\n-     * or else this call will fail.\n-     *\n-     * wait() is equivalent to wait_on(0).\n-     */\n+    /// As wait(), but can specify which of multiple condition variables to\n+    /// wait on. Only a signal_on() or broadcast_on() with the same condvar_id\n+    /// will wake this thread.\n+    ///\n+    /// The associated lock must have been initialised with an appropriate\n+    /// number of condvars. The condvar_id must be between 0 and num_condvars-1\n+    /// or else this call will fail.\n+    ///\n+    /// wait() is equivalent to wait_on(0).\n     pub fn wait_on(&self, condvar_id: uint) {\n         let mut wait_end = None;\n         let mut out_of_bounds = None;\n@@ -248,7 +271,10 @@ impl<'a> Condvar<'a> {\n             }).finally(|| {\n                 // Reacquire the condvar.\n                 match self.order {\n-                    Just(lock) => lock.access(|| self.sem.acquire()),\n+                    Just(lock) => {\n+                        let _g = lock.access();\n+                        self.sem.acquire();\n+                    }\n                     Nothing => self.sem.acquire(),\n                 }\n             })\n@@ -309,7 +335,6 @@ impl<'a> Condvar<'a> {\n // Checks whether a condvar ID was out of bounds, and fails if so, or does\n // something else next on success.\n #[inline]\n-#[doc(hidden)]\n fn check_cvar_bounds<U>(\n                      out_of_bounds: Option<uint>,\n                      id: uint,\n@@ -325,35 +350,26 @@ fn check_cvar_bounds<U>(\n     }\n }\n \n-#[doc(hidden)]\n-impl Sem<Vec<WaitQueue> > {\n-    // The only other places that condvars get built are rwlock.write_cond()\n-    // and rwlock_write_mode.\n-    pub fn access_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n-        self.access(|| {\n-            blk(&Condvar {\n-                sem: self,\n-                order: Nothing,\n-                nopod: marker::NoPod\n-            })\n-        })\n-    }\n+#[must_use]\n+struct SemCondGuard<'a> {\n+    guard: SemGuard<'a, Vec<WaitQueue>>,\n+    cvar: Condvar<'a>,\n }\n \n /****************************************************************************\n  * Semaphores\n  ****************************************************************************/\n \n /// A counting, blocking, bounded-waiting semaphore.\n-pub struct Semaphore { priv sem: Sem<()> }\n-\n+pub struct Semaphore {\n+    priv sem: Sem<()>,\n+}\n \n-impl Clone for Semaphore {\n-    /// Create a new handle to the semaphore.\n-    fn clone(&self) -> Semaphore {\n-        let Sem(ref lock) = self.sem;\n-        Semaphore { sem: Sem(lock.clone()) }\n-    }\n+/// An RAII guard used to represent an acquired resource to a semaphore. When\n+/// dropped, this value will release the resource back to the semaphore.\n+#[must_use]\n+pub struct SemaphoreGuard<'a> {\n+    priv guard: SemGuard<'a, ()>,\n }\n \n impl Semaphore {\n@@ -362,66 +378,64 @@ impl Semaphore {\n         Semaphore { sem: Sem::new(count, ()) }\n     }\n \n-    /**\n-     * Acquire a resource represented by the semaphore. Blocks if necessary\n-     * until resource(s) become available.\n-     */\n-    pub fn acquire(&self) { (&self.sem).acquire() }\n+    /// Acquire a resource represented by the semaphore. Blocks if necessary\n+    /// until resource(s) become available.\n+    pub fn acquire(&self) { self.sem.acquire() }\n \n-    /**\n-     * Release a held resource represented by the semaphore. Wakes a blocked\n-     * contending task, if any exist. Won't block the caller.\n-     */\n-    pub fn release(&self) { (&self.sem).release() }\n+    /// Release a held resource represented by the semaphore. Wakes a blocked\n+    /// contending task, if any exist. Won't block the caller.\n+    pub fn release(&self) { self.sem.release() }\n \n-    /// Run a function with ownership of one of the semaphore's resources.\n-    pub fn access<U>(&self, blk: || -> U) -> U { (&self.sem).access(blk) }\n+    /// Acquire a resource of this semaphore, returning an RAII guard which will\n+    /// release the resource when dropped.\n+    pub fn access<'a>(&'a self) -> SemaphoreGuard<'a> {\n+        SemaphoreGuard { guard: self.sem.access() }\n+    }\n }\n \n /****************************************************************************\n  * Mutexes\n  ****************************************************************************/\n \n-/**\n- * A blocking, bounded-waiting, mutual exclusion lock with an associated\n- * FIFO condition variable.\n- *\n- * # Failure\n- * A task which fails while holding a mutex will unlock the mutex as it\n- * unwinds.\n- */\n-\n-pub struct Mutex { priv sem: Sem<Vec<WaitQueue> > }\n-impl Clone for Mutex {\n-    /// Create a new handle to the mutex.\n-    fn clone(&self) -> Mutex {\n-        let Sem(ref queue) = self.sem;\n-        Mutex { sem: Sem(queue.clone()) } }\n+/// A blocking, bounded-waiting, mutual exclusion lock with an associated\n+/// FIFO condition variable.\n+///\n+/// # Failure\n+/// A task which fails while holding a mutex will unlock the mutex as it\n+/// unwinds.\n+pub struct Mutex {\n+    priv sem: Sem<Vec<WaitQueue>>,\n+}\n+\n+/// An RAII structure which is used to gain access to a mutex's condition\n+/// variable. Additionally, when a value of this type is dropped, the\n+/// corresponding mutex is also unlocked.\n+#[must_use]\n+pub struct MutexGuard<'a> {\n+    priv guard: SemGuard<'a, Vec<WaitQueue>>,\n+    /// Inner condition variable which is connected to the outer mutex, and can\n+    /// be used for atomic-unlock-and-deschedule.\n+    cond: Condvar<'a>,\n }\n \n impl Mutex {\n     /// Create a new mutex, with one associated condvar.\n     pub fn new() -> Mutex { Mutex::new_with_condvars(1) }\n \n-    /**\n-    * Create a new mutex, with a specified number of associated condvars. This\n-    * will allow calling wait_on/signal_on/broadcast_on with condvar IDs between\n-    * 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be allowed but\n-    * any operations on the condvar will fail.)\n-    */\n+    /// Create a new mutex, with a specified number of associated condvars. This\n+    /// will allow calling wait_on/signal_on/broadcast_on with condvar IDs\n+    /// between 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be\n+    /// allowed but any operations on the condvar will fail.)\n     pub fn new_with_condvars(num_condvars: uint) -> Mutex {\n         Mutex { sem: Sem::new_and_signal(1, num_condvars) }\n     }\n \n-\n-    /// Run a function with ownership of the mutex.\n-    pub fn lock<U>(&self, blk: || -> U) -> U {\n-        (&self.sem).access(blk)\n-    }\n-\n-    /// Run a function with ownership of the mutex and a handle to a condvar.\n-    pub fn lock_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n-        (&self.sem).access_cond(blk)\n+    /// Acquires ownership of this mutex, returning an RAII guard which will\n+    /// unlock the mutex when dropped. The associated condition variable can\n+    /// also be accessed through the returned guard.\n+    pub fn lock<'a>(&'a self) -> MutexGuard<'a> {\n+        let SemCondGuard { guard, cvar } = self.sem.access_cond();\n+        MutexGuard { guard: guard, cond: cvar }\n     }\n }\n \n@@ -431,118 +445,95 @@ impl Mutex {\n \n // NB: Wikipedia - Readers-writers_problem#The_third_readers-writers_problem\n \n-#[doc(hidden)]\n-struct RWLockInner {\n-    // You might ask, \"Why don't you need to use an atomic for the mode flag?\"\n-    // This flag affects the behaviour of readers (for plain readers, they\n-    // assert on it; for downgraders, they use it to decide which mode to\n-    // unlock for). Consider that the flag is only unset when the very last\n-    // reader exits; therefore, it can never be unset during a reader/reader\n-    // (or reader/downgrader) race.\n-    // By the way, if we didn't care about the assert in the read unlock path,\n-    // we could instead store the mode flag in write_downgrade's stack frame,\n-    // and have the downgrade tokens store a reference to it.\n-    read_mode:  bool,\n+/// A blocking, no-starvation, reader-writer lock with an associated condvar.\n+///\n+/// # Failure\n+///\n+/// A task which fails while holding an rwlock will unlock the rwlock as it\n+/// unwinds.\n+pub struct RWLock {\n+    priv order_lock:  Semaphore,\n+    priv access_lock: Sem<Vec<WaitQueue>>,\n+\n     // The only way the count flag is ever accessed is with xadd. Since it is\n     // a read-modify-write operation, multiple xadds on different cores will\n     // always be consistent with respect to each other, so a monotonic/relaxed\n     // consistency ordering suffices (i.e., no extra barriers are needed).\n+    //\n     // FIXME(#6598): The atomics module has no relaxed ordering flag, so I use\n     // acquire/release orderings superfluously. Change these someday.\n-    read_count: atomics::AtomicUint,\n+    priv read_count: atomics::AtomicUint,\n }\n \n-/**\n- * A blocking, no-starvation, reader-writer lock with an associated condvar.\n- *\n- * # Failure\n- * A task which fails while holding an rwlock will unlock the rwlock as it\n- * unwinds.\n- */\n-pub struct RWLock {\n-    priv order_lock:  Semaphore,\n-    priv access_lock: Sem<Vec<WaitQueue> >,\n-    priv state:       UnsafeArc<RWLockInner>,\n+/// An RAII helper which is created by acquiring a read lock on an RWLock. When\n+/// dropped, this will unlock the RWLock.\n+#[must_use]\n+pub struct RWLockReadGuard<'a> {\n+    priv lock: &'a RWLock,\n+}\n+\n+/// An RAII helper which is created by acquiring a write lock on an RWLock. When\n+/// dropped, this will unlock the RWLock.\n+///\n+/// A value of this type can also be consumed to downgrade to a read-only lock.\n+#[must_use]\n+pub struct RWLockWriteGuard<'a> {\n+    priv lock: &'a RWLock,\n+    /// Inner condition variable that is connected to the write-mode of the\n+    /// outer rwlock.\n+    cond: Condvar<'a>,\n }\n \n impl RWLock {\n     /// Create a new rwlock, with one associated condvar.\n     pub fn new() -> RWLock { RWLock::new_with_condvars(1) }\n \n-    /**\n-    * Create a new rwlock, with a specified number of associated condvars.\n-    * Similar to mutex_with_condvars.\n-    */\n+    /// Create a new rwlock, with a specified number of associated condvars.\n+    /// Similar to mutex_with_condvars.\n     pub fn new_with_condvars(num_condvars: uint) -> RWLock {\n-        let state = UnsafeArc::new(RWLockInner {\n-            read_mode:  false,\n+        RWLock {\n+            order_lock: Semaphore::new(1),\n+            access_lock: Sem::new_and_signal(1, num_condvars),\n             read_count: atomics::AtomicUint::new(0),\n-        });\n-        RWLock { order_lock:  Semaphore::new(1),\n-                access_lock: Sem::new_and_signal(1, num_condvars),\n-                state:       state, }\n-    }\n-\n-    /// Create a new handle to the rwlock.\n-    pub fn clone(&self) -> RWLock {\n-        let Sem(ref access_lock_queue) = self.access_lock;\n-        RWLock { order_lock:  (&(self.order_lock)).clone(),\n-                 access_lock: Sem(access_lock_queue.clone()),\n-                 state:       self.state.clone() }\n-    }\n-\n-    /**\n-     * Run a function with the rwlock in read mode. Calls to 'read' from other\n-     * tasks may run concurrently with this one.\n-     */\n-    pub fn read<U>(&self, blk: || -> U) -> U {\n-        unsafe {\n-            (&self.order_lock).access(|| {\n-                let state = &mut *self.state.get();\n-                let old_count = state.read_count.fetch_add(1, atomics::Acquire);\n-                if old_count == 0 {\n-                    (&self.access_lock).acquire();\n-                    state.read_mode = true;\n-                }\n-            });\n-            (|| {\n-                blk()\n-            }).finally(|| {\n-                let state = &mut *self.state.get();\n-                assert!(state.read_mode);\n-                let old_count = state.read_count.fetch_sub(1, atomics::Release);\n-                assert!(old_count > 0);\n-                if old_count == 1 {\n-                    state.read_mode = false;\n-                    // Note: this release used to be outside of a locked access\n-                    // to exclusive-protected state. If this code is ever\n-                    // converted back to such (instead of using atomic ops),\n-                    // this access MUST NOT go inside the exclusive access.\n-                    (&self.access_lock).release();\n-                }\n-            })\n         }\n     }\n \n-    /**\n-     * Run a function with the rwlock in write mode. No calls to 'read' or\n-     * 'write' from other tasks will run concurrently with this one.\n-     */\n-    pub fn write<U>(&self, blk: || -> U) -> U {\n-        (&self.order_lock).acquire();\n-        (&self.access_lock).access(|| {\n-            (&self.order_lock).release();\n-            blk()\n-        })\n-    }\n+    /// Acquires a read-lock, returning an RAII guard that will unlock the lock\n+    /// when dropped. Calls to 'read' from other tasks may run concurrently with\n+    /// this one.\n+    pub fn read<'a>(&'a self) -> RWLockReadGuard<'a> {\n+        let _guard = self.order_lock.access();\n+        let old_count = self.read_count.fetch_add(1, atomics::Acquire);\n+        if old_count == 0 {\n+            self.access_lock.acquire();\n+        }\n+        RWLockReadGuard { lock: self }\n+    }\n+\n+    /// Acquire a write-lock, returning an RAII guard that will unlock the lock\n+    /// when dropped. No calls to 'read' or 'write' from other tasks will run\n+    /// concurrently with this one.\n+    ///\n+    /// You can also downgrade a write to a read by calling the `downgrade`\n+    /// method on the returned guard. Additionally, the guard will contain a\n+    /// `Condvar` attached to this lock.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use sync::raw::RWLock;\n+    ///\n+    /// let lock = RWLock::new();\n+    /// let write = lock.write();\n+    /// // ... exclusive access ...\n+    /// let read = write.downgrade();\n+    /// // ... shared access ...\n+    /// drop(read);\n+    /// ```\n+    pub fn write<'a>(&'a self) -> RWLockWriteGuard<'a> {\n+        let _g = self.order_lock.access();\n+        self.access_lock.acquire();\n \n-    /**\n-     * As write(), but also with a handle to a condvar. Waiting on this\n-     * condvar will allow readers and writers alike to take the rwlock before\n-     * the waiting task is signalled. (Note: a writer that waited and then\n-     * was signalled might reacquire the lock before other waiting writers.)\n-     */\n-    pub fn write_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n         // It's important to thread our order lock into the condvar, so that\n         // when a cond.wait() wakes up, it uses it while reacquiring the\n         // access lock. If we permitted a waking-up writer to \"cut in line\",\n@@ -569,188 +560,60 @@ impl RWLock {\n         // which can't happen until T2 finishes the downgrade-read entirely.\n         // The astute reader will also note that making waking writers use the\n         // order_lock is better for not starving readers.\n-        (&self.order_lock).acquire();\n-        (&self.access_lock).access_cond(|cond| {\n-            (&self.order_lock).release();\n-            let opt_lock = Just(&self.order_lock);\n-            blk(&Condvar { sem: cond.sem, order: opt_lock,\n-                           nopod: marker::NoPod })\n-        })\n-    }\n-\n-    /**\n-     * As write(), but with the ability to atomically 'downgrade' the lock;\n-     * i.e., to become a reader without letting other writers get the lock in\n-     * the meantime (such as unlocking and then re-locking as a reader would\n-     * do). The block takes a \"write mode token\" argument, which can be\n-     * transformed into a \"read mode token\" by calling downgrade(). Example:\n-     *\n-     * # Example\n-     *\n-     * ```rust\n-     * use sync::RWLock;\n-     *\n-     * let lock = RWLock::new();\n-     * lock.write_downgrade(|mut write_token| {\n-     *     write_token.write_cond(|condvar| {\n-     *         // ... exclusive access ...\n-     *     });\n-     *     let read_token = lock.downgrade(write_token);\n-     *     read_token.read(|| {\n-     *         // ... shared access ...\n-     *     })\n-     * })\n-     * ```\n-     */\n-    pub fn write_downgrade<U>(&self, blk: |v: RWLockWriteMode| -> U) -> U {\n-        // Implementation slightly different from the slicker 'write's above.\n-        // The exit path is conditional on whether the caller downgrades.\n-        (&self.order_lock).acquire();\n-        (&self.access_lock).acquire();\n-        (&self.order_lock).release();\n-        (|| {\n-            blk(RWLockWriteMode { lock: self, nopod: marker::NoPod })\n-        }).finally(|| {\n-            let writer_or_last_reader;\n-            // Check if we're releasing from read mode or from write mode.\n-            let state = unsafe { &mut *self.state.get() };\n-            if state.read_mode {\n-                // Releasing from read mode.\n-                let old_count = state.read_count.fetch_sub(1, atomics::Release);\n-                assert!(old_count > 0);\n-                // Check if other readers remain.\n-                if old_count == 1 {\n-                    // Case 1: Writer downgraded & was the last reader\n-                    writer_or_last_reader = true;\n-                    state.read_mode = false;\n-                } else {\n-                    // Case 2: Writer downgraded & was not the last reader\n-                    writer_or_last_reader = false;\n-                }\n-            } else {\n-                // Case 3: Writer did not downgrade\n-                writer_or_last_reader = true;\n-            }\n-            if writer_or_last_reader {\n-                // Nobody left inside; release the \"reader cloud\" lock.\n-                (&self.access_lock).release();\n-            }\n-        })\n-    }\n-\n-    /// To be called inside of the write_downgrade block.\n-    pub fn downgrade<'a>(&self, token: RWLockWriteMode<'a>)\n-                         -> RWLockReadMode<'a> {\n-        if !((self as *RWLock) == (token.lock as *RWLock)) {\n-            fail!(\"Can't downgrade() with a different rwlock's write_mode!\");\n-        }\n-        unsafe {\n-            let state = &mut *self.state.get();\n-            assert!(!state.read_mode);\n-            state.read_mode = true;\n-            // If a reader attempts to enter at this point, both the\n-            // downgrader and reader will set the mode flag. This is fine.\n-            let old_count = state.read_count.fetch_add(1, atomics::Release);\n-            // If another reader was already blocking, we need to hand-off\n-            // the \"reader cloud\" access lock to them.\n-            if old_count != 0 {\n-                // Guaranteed not to let another writer in, because\n-                // another reader was holding the order_lock. Hence they\n-                // must be the one to get the access_lock (because all\n-                // access_locks are acquired with order_lock held). See\n-                // the comment in write_cond for more justification.\n-                (&self.access_lock).release();\n+        RWLockWriteGuard {\n+            lock: self,\n+            cond: Condvar {\n+                sem: &self.access_lock,\n+                order: Just(&self.order_lock),\n+                nopod: marker::NoPod,\n             }\n         }\n-        RWLockReadMode { lock: token.lock, nopod: marker::NoPod }\n     }\n }\n \n-/// The \"write permission\" token used for rwlock.write_downgrade().\n-\n-pub struct RWLockWriteMode<'a> { priv lock: &'a RWLock, priv nopod: marker::NoPod }\n-/// The \"read permission\" token used for rwlock.write_downgrade().\n-pub struct RWLockReadMode<'a> { priv lock: &'a RWLock,\n-                                   priv nopod: marker::NoPod }\n-\n-impl<'a> RWLockWriteMode<'a> {\n-    /// Access the pre-downgrade rwlock in write mode.\n-    pub fn write<U>(&self, blk: || -> U) -> U { blk() }\n-    /// Access the pre-downgrade rwlock in write mode with a condvar.\n-    pub fn write_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n-        // Need to make the condvar use the order lock when reacquiring the\n-        // access lock. See comment in RWLock::write_cond for why.\n-        blk(&Condvar { sem:        &self.lock.access_lock,\n-                       order: Just(&self.lock.order_lock),\n-                       nopod: marker::NoPod })\n+impl<'a> RWLockWriteGuard<'a> {\n+    /// Consumes this write lock and converts it into a read lock.\n+    pub fn downgrade(self) -> RWLockReadGuard<'a> {\n+        let lock = self.lock;\n+        // Don't run the destructor of the write guard, we're in charge of\n+        // things from now on\n+        unsafe { cast::forget(self) }\n+\n+        let old_count = lock.read_count.fetch_add(1, atomics::Release);\n+        // If another reader was already blocking, we need to hand-off\n+        // the \"reader cloud\" access lock to them.\n+        if old_count != 0 {\n+            // Guaranteed not to let another writer in, because\n+            // another reader was holding the order_lock. Hence they\n+            // must be the one to get the access_lock (because all\n+            // access_locks are acquired with order_lock held). See\n+            // the comment in write_cond for more justification.\n+            lock.access_lock.release();\n+        }\n+        RWLockReadGuard { lock: lock }\n     }\n }\n \n-impl<'a> RWLockReadMode<'a> {\n-    /// Access the post-downgrade rwlock in read mode.\n-    pub fn read<U>(&self, blk: || -> U) -> U { blk() }\n-}\n-\n-/// A barrier enables multiple tasks to synchronize the beginning\n-/// of some computation.\n-///\n-/// ```rust\n-/// use sync::Barrier;\n-///\n-/// let barrier = Barrier::new(10);\n-/// for _ in range(0, 10) {\n-///     let c = barrier.clone();\n-///     // The same messages will be printed together.\n-///     // You will NOT see any interleaving.\n-///     spawn(proc() {\n-///         println!(\"before wait\");\n-///         c.wait();\n-///         println!(\"after wait\");\n-///     });\n-/// }\n-/// ```\n-#[deriving(Clone)]\n-pub struct Barrier {\n-    priv arc: MutexArc<BarrierState>,\n-    priv num_tasks: uint,\n-}\n-\n-// The inner state of a double barrier\n-struct BarrierState {\n-    count: uint,\n-    generation_id: uint,\n+#[unsafe_destructor]\n+impl<'a> Drop for RWLockWriteGuard<'a> {\n+    fn drop(&mut self) {\n+        self.lock.access_lock.release();\n+    }\n }\n \n-impl Barrier {\n-    /// Create a new barrier that can block a given number of tasks.\n-    pub fn new(num_tasks: uint) -> Barrier {\n-        Barrier {\n-            arc: MutexArc::new(BarrierState {\n-                count: 0,\n-                generation_id: 0,\n-            }),\n-            num_tasks: num_tasks,\n+#[unsafe_destructor]\n+impl<'a> Drop for RWLockReadGuard<'a> {\n+    fn drop(&mut self) {\n+        let old_count = self.lock.read_count.fetch_sub(1, atomics::Release);\n+        assert!(old_count > 0);\n+        if old_count == 1 {\n+            // Note: this release used to be outside of a locked access\n+            // to exclusive-protected state. If this code is ever\n+            // converted back to such (instead of using atomic ops),\n+            // this access MUST NOT go inside the exclusive access.\n+            self.lock.access_lock.release();\n         }\n     }\n-\n-    /// Block the current task until a certain number of tasks is waiting.\n-    pub fn wait(&self) {\n-        self.arc.access_cond(|state, cond| {\n-            let local_gen = state.generation_id;\n-            state.count += 1;\n-            if state.count < self.num_tasks {\n-                // We need a while loop to guard against spurious wakeups.\n-                // http://en.wikipedia.org/wiki/Spurious_wakeup\n-                while local_gen == state.generation_id && state.count < self.num_tasks {\n-                    cond.wait();\n-                }\n-            } else {\n-                state.count = 0;\n-                state.generation_id += 1;\n-                cond.broadcast();\n-            }\n-        });\n-    }\n }\n \n /****************************************************************************\n@@ -759,12 +622,12 @@ impl Barrier {\n \n #[cfg(test)]\n mod tests {\n-    use sync::{Semaphore, Mutex, RWLock, Barrier, Condvar};\n+    use arc::Arc;\n+    use super::{Semaphore, Mutex, RWLock, Condvar};\n \n     use std::cast;\n     use std::result;\n     use std::task;\n-    use std::comm::Empty;\n \n     /************************************************************************\n      * Semaphore tests\n@@ -779,26 +642,24 @@ mod tests {\n     #[test]\n     fn test_sem_basic() {\n         let s = Semaphore::new(1);\n-        s.access(|| { })\n+        let _g = s.access();\n     }\n     #[test]\n     fn test_sem_as_mutex() {\n-        let s = Semaphore::new(1);\n+        let s = Arc::new(Semaphore::new(1));\n         let s2 = s.clone();\n         task::spawn(proc() {\n-            s2.access(|| {\n-                for _ in range(0, 5) { task::deschedule(); }\n-            })\n-        });\n-        s.access(|| {\n+            let _g = s2.access();\n             for _ in range(0, 5) { task::deschedule(); }\n-        })\n+        });\n+        let _g = s.access();\n+        for _ in range(0, 5) { task::deschedule(); }\n     }\n     #[test]\n     fn test_sem_as_cvar() {\n         /* Child waits and parent signals */\n         let (tx, rx) = channel();\n-        let s = Semaphore::new(0);\n+        let s = Arc::new(Semaphore::new(0));\n         let s2 = s.clone();\n         task::spawn(proc() {\n             s2.acquire();\n@@ -810,7 +671,7 @@ mod tests {\n \n         /* Parent waits and child signals */\n         let (tx, rx) = channel();\n-        let s = Semaphore::new(0);\n+        let s = Arc::new(Semaphore::new(0));\n         let s2 = s.clone();\n         task::spawn(proc() {\n             for _ in range(0, 5) { task::deschedule(); }\n@@ -824,40 +685,37 @@ mod tests {\n     fn test_sem_multi_resource() {\n         // Parent and child both get in the critical section at the same\n         // time, and shake hands.\n-        let s = Semaphore::new(2);\n+        let s = Arc::new(Semaphore::new(2));\n         let s2 = s.clone();\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n         task::spawn(proc() {\n-            s2.access(|| {\n-                let _ = rx2.recv();\n-                tx1.send(());\n-            })\n+            let _g = s2.access();\n+            let _ = rx2.recv();\n+            tx1.send(());\n         });\n-        s.access(|| {\n-            tx2.send(());\n-            let _ = rx1.recv();\n-        })\n+        let _g = s.access();\n+        tx2.send(());\n+        let _ = rx1.recv();\n     }\n     #[test]\n     fn test_sem_runtime_friendly_blocking() {\n         // Force the runtime to schedule two threads on the same sched_loop.\n         // When one blocks, it should schedule the other one.\n-        let s = Semaphore::new(1);\n+        let s = Arc::new(Semaphore::new(1));\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n-        let mut child_data = Some((s2, tx));\n-        s.access(|| {\n-            let (s2, tx) = child_data.take_unwrap();\n+        {\n+            let _g = s.access();\n             task::spawn(proc() {\n                 tx.send(());\n-                s2.access(|| { });\n+                drop(s2.access());\n                 tx.send(());\n             });\n-            let _ = rx.recv(); // wait for child to come alive\n+            rx.recv(); // wait for child to come alive\n             for _ in range(0, 5) { task::deschedule(); } // let the child contend\n-        });\n-        let _ = rx.recv(); // wait for child to be done\n+        }\n+        rx.recv(); // wait for child to be done\n     }\n     /************************************************************************\n      * Mutex tests\n@@ -867,93 +725,90 @@ mod tests {\n         // Unsafely achieve shared state, and do the textbook\n         // \"load tmp = move ptr; inc tmp; store ptr <- tmp\" dance.\n         let (tx, rx) = channel();\n-        let m = Mutex::new();\n+        let m = Arc::new(Mutex::new());\n         let m2 = m.clone();\n         let mut sharedstate = ~0;\n         {\n-            let ptr: *int = &*sharedstate;\n+            let ptr: *mut int = &mut *sharedstate;\n             task::spawn(proc() {\n-                let sharedstate: &mut int =\n-                    unsafe { cast::transmute(ptr) };\n-                access_shared(sharedstate, &m2, 10);\n+                access_shared(ptr, &m2, 10);\n                 tx.send(());\n             });\n         }\n         {\n-            access_shared(sharedstate, &m, 10);\n+            access_shared(&mut *sharedstate, &m, 10);\n             let _ = rx.recv();\n \n             assert_eq!(*sharedstate, 20);\n         }\n \n-        fn access_shared(sharedstate: &mut int, m: &Mutex, n: uint) {\n+        fn access_shared(sharedstate: *mut int, m: &Arc<Mutex>, n: uint) {\n             for _ in range(0, n) {\n-                m.lock(|| {\n-                    let oldval = *sharedstate;\n-                    task::deschedule();\n-                    *sharedstate = oldval + 1;\n-                })\n+                let _g = m.lock();\n+                let oldval = unsafe { *sharedstate };\n+                task::deschedule();\n+                unsafe { *sharedstate = oldval + 1; }\n             }\n         }\n     }\n     #[test]\n     fn test_mutex_cond_wait() {\n-        let m = Mutex::new();\n+        let m = Arc::new(Mutex::new());\n \n         // Child wakes up parent\n-        m.lock_cond(|cond| {\n+        {\n+            let lock = m.lock();\n             let m2 = m.clone();\n             task::spawn(proc() {\n-                m2.lock_cond(|cond| {\n-                    let woken = cond.signal();\n-                    assert!(woken);\n-                })\n+                let lock = m2.lock();\n+                let woken = lock.cond.signal();\n+                assert!(woken);\n             });\n-            cond.wait();\n-        });\n+            lock.cond.wait();\n+        }\n         // Parent wakes up child\n         let (tx, rx) = channel();\n         let m3 = m.clone();\n         task::spawn(proc() {\n-            m3.lock_cond(|cond| {\n-                tx.send(());\n-                cond.wait();\n-                tx.send(());\n-            })\n+            let lock = m3.lock();\n+            tx.send(());\n+            lock.cond.wait();\n+            tx.send(());\n         });\n-        let _ = rx.recv(); // Wait until child gets in the mutex\n-        m.lock_cond(|cond| {\n-            let woken = cond.signal();\n+        rx.recv(); // Wait until child gets in the mutex\n+        {\n+            let lock = m.lock();\n+            let woken = lock.cond.signal();\n             assert!(woken);\n-        });\n-        let _ = rx.recv(); // Wait until child wakes up\n+        }\n+        rx.recv(); // Wait until child wakes up\n     }\n-    #[cfg(test)]\n+\n     fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n-        let m = Mutex::new();\n-        let mut rxs = vec!();\n+        let m = Arc::new(Mutex::new());\n+        let mut rxs = Vec::new();\n \n         for _ in range(0, num_waiters) {\n             let mi = m.clone();\n             let (tx, rx) = channel();\n             rxs.push(rx);\n             task::spawn(proc() {\n-                mi.lock_cond(|cond| {\n-                    tx.send(());\n-                    cond.wait();\n-                    tx.send(());\n-                })\n+                let lock = mi.lock();\n+                tx.send(());\n+                lock.cond.wait();\n+                tx.send(());\n             });\n         }\n \n         // wait until all children get in the mutex\n-        for rx in rxs.mut_iter() { let _ = rx.recv(); }\n-        m.lock_cond(|cond| {\n-            let num_woken = cond.broadcast();\n+        for rx in rxs.mut_iter() { rx.recv(); }\n+        {\n+            let lock = m.lock();\n+            let num_woken = lock.cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n-        });\n+        }\n         // wait until all children wake up\n-        for rx in rxs.mut_iter() { let _ = rx.recv(); }\n+        for rx in rxs.mut_iter() { rx.recv(); }\n     }\n     #[test]\n     fn test_mutex_cond_broadcast() {\n@@ -965,61 +820,57 @@ mod tests {\n     }\n     #[test]\n     fn test_mutex_cond_no_waiter() {\n-        let m = Mutex::new();\n+        let m = Arc::new(Mutex::new());\n         let m2 = m.clone();\n         let _ = task::try(proc() {\n-            m.lock_cond(|_x| { })\n+            drop(m.lock());\n         });\n-        m2.lock_cond(|cond| {\n-            assert!(!cond.signal());\n-        })\n+        let lock = m2.lock();\n+        assert!(!lock.cond.signal());\n     }\n     #[test]\n     fn test_mutex_killed_simple() {\n         use std::any::Any;\n \n         // Mutex must get automatically unlocked if failed/killed within.\n-        let m = Mutex::new();\n+        let m = Arc::new(Mutex::new());\n         let m2 = m.clone();\n \n         let result: result::Result<(), ~Any> = task::try(proc() {\n-            m2.lock(|| {\n-                fail!();\n-            })\n+            let _lock = m2.lock();\n+            fail!();\n         });\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n-        m.lock(|| { })\n+        drop(m.lock());\n     }\n     #[test]\n     fn test_mutex_cond_signal_on_0() {\n         // Tests that signal_on(0) is equivalent to signal().\n-        let m = Mutex::new();\n-        m.lock_cond(|cond| {\n-            let m2 = m.clone();\n-            task::spawn(proc() {\n-                m2.lock_cond(|cond| {\n-                    cond.signal_on(0);\n-                })\n-            });\n-            cond.wait();\n-        })\n+        let m = Arc::new(Mutex::new());\n+        let lock = m.lock();\n+        let m2 = m.clone();\n+        task::spawn(proc() {\n+            let lock = m2.lock();\n+            lock.cond.signal_on(0);\n+        });\n+        lock.cond.wait();\n     }\n     #[test]\n     fn test_mutex_no_condvars() {\n         let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(0);\n-            m.lock_cond(|cond| { cond.wait(); })\n+            m.lock().cond.wait();\n         });\n         assert!(result.is_err());\n         let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(0);\n-            m.lock_cond(|cond| { cond.signal(); })\n+            m.lock().cond.signal();\n         });\n         assert!(result.is_err());\n         let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(0);\n-            m.lock_cond(|cond| { cond.broadcast(); })\n+            m.lock().cond.broadcast();\n         });\n         assert!(result.is_err());\n     }\n@@ -1029,23 +880,16 @@ mod tests {\n     #[cfg(test)]\n     pub enum RWLockMode { Read, Write, Downgrade, DowngradeRead }\n     #[cfg(test)]\n-    fn lock_rwlock_in_mode(x: &RWLock, mode: RWLockMode, blk: ||) {\n+    fn lock_rwlock_in_mode(x: &Arc<RWLock>, mode: RWLockMode, blk: ||) {\n         match mode {\n-            Read => x.read(blk),\n-            Write => x.write(blk),\n-            Downgrade =>\n-                x.write_downgrade(|mode| {\n-                    mode.write(|| { blk() });\n-                }),\n-            DowngradeRead =>\n-                x.write_downgrade(|mode| {\n-                    let mode = x.downgrade(mode);\n-                    mode.read(|| { blk() });\n-                }),\n+            Read => { let _g = x.read(); blk() }\n+            Write => { let _g = x.write(); blk() }\n+            Downgrade => { let _g = x.write(); blk() }\n+            DowngradeRead => { let _g = x.write().downgrade(); blk() }\n         }\n     }\n     #[cfg(test)]\n-    fn test_rwlock_exclusion(x: &RWLock,\n+    fn test_rwlock_exclusion(x: Arc<RWLock>,\n                              mode1: RWLockMode,\n                              mode2: RWLockMode) {\n         // Test mutual exclusion between readers and writers. Just like the\n@@ -1063,14 +907,14 @@ mod tests {\n             });\n         }\n         {\n-            access_shared(sharedstate, x, mode2, 10);\n+            access_shared(sharedstate, &x, mode2, 10);\n             let _ = rx.recv();\n \n             assert_eq!(*sharedstate, 20);\n         }\n \n-        fn access_shared(sharedstate: &mut int, x: &RWLock, mode: RWLockMode,\n-                         n: uint) {\n+        fn access_shared(sharedstate: &mut int, x: &Arc<RWLock>,\n+                         mode: RWLockMode, n: uint) {\n             for _ in range(0, n) {\n                 lock_rwlock_in_mode(x, mode, || {\n                     let oldval = *sharedstate;\n@@ -1082,132 +926,127 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_readers_wont_modify_the_data() {\n-        test_rwlock_exclusion(&RWLock::new(), Read, Write);\n-        test_rwlock_exclusion(&RWLock::new(), Write, Read);\n-        test_rwlock_exclusion(&RWLock::new(), Read, Downgrade);\n-        test_rwlock_exclusion(&RWLock::new(), Downgrade, Read);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Read, Write);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Write, Read);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Read, Downgrade);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Downgrade, Read);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Write, DowngradeRead);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), DowngradeRead, Write);\n     }\n     #[test]\n     fn test_rwlock_writers_and_writers() {\n-        test_rwlock_exclusion(&RWLock::new(), Write, Write);\n-        test_rwlock_exclusion(&RWLock::new(), Write, Downgrade);\n-        test_rwlock_exclusion(&RWLock::new(), Downgrade, Write);\n-        test_rwlock_exclusion(&RWLock::new(), Downgrade, Downgrade);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Write, Write);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Write, Downgrade);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Downgrade, Write);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Downgrade, Downgrade);\n     }\n     #[cfg(test)]\n-    fn test_rwlock_handshake(x: &RWLock,\n-                                 mode1: RWLockMode,\n-                                 mode2: RWLockMode,\n-                                 make_mode2_go_first: bool) {\n+    fn test_rwlock_handshake(x: Arc<RWLock>,\n+                             mode1: RWLockMode,\n+                             mode2: RWLockMode,\n+                             make_mode2_go_first: bool) {\n         // Much like sem_multi_resource.\n         let x2 = x.clone();\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n         task::spawn(proc() {\n             if !make_mode2_go_first {\n-                let _ = rx2.recv(); // parent sends to us once it locks, or ...\n+                rx2.recv(); // parent sends to us once it locks, or ...\n             }\n             lock_rwlock_in_mode(&x2, mode2, || {\n                 if make_mode2_go_first {\n                     tx1.send(()); // ... we send to it once we lock\n                 }\n-                let _ = rx2.recv();\n+                rx2.recv();\n                 tx1.send(());\n             })\n         });\n         if make_mode2_go_first {\n-            let _ = rx1.recv(); // child sends to us once it locks, or ...\n+            rx1.recv(); // child sends to us once it locks, or ...\n         }\n-        lock_rwlock_in_mode(x, mode1, || {\n+        lock_rwlock_in_mode(&x, mode1, || {\n             if !make_mode2_go_first {\n                 tx2.send(()); // ... we send to it once we lock\n             }\n             tx2.send(());\n-            let _ = rx1.recv();\n+            rx1.recv();\n         })\n     }\n     #[test]\n     fn test_rwlock_readers_and_readers() {\n-        test_rwlock_handshake(&RWLock::new(), Read, Read, false);\n+        test_rwlock_handshake(Arc::new(RWLock::new()), Read, Read, false);\n         // The downgrader needs to get in before the reader gets in, otherwise\n         // they cannot end up reading at the same time.\n-        test_rwlock_handshake(&RWLock::new(), DowngradeRead, Read, false);\n-        test_rwlock_handshake(&RWLock::new(), Read, DowngradeRead, true);\n+        test_rwlock_handshake(Arc::new(RWLock::new()), DowngradeRead, Read, false);\n+        test_rwlock_handshake(Arc::new(RWLock::new()), Read, DowngradeRead, true);\n         // Two downgrade_reads can never both end up reading at the same time.\n     }\n     #[test]\n     fn test_rwlock_downgrade_unlock() {\n         // Tests that downgrade can unlock the lock in both modes\n-        let x = RWLock::new();\n+        let x = Arc::new(RWLock::new());\n         lock_rwlock_in_mode(&x, Downgrade, || { });\n-        test_rwlock_handshake(&x, Read, Read, false);\n-        let y = RWLock::new();\n+        test_rwlock_handshake(x, Read, Read, false);\n+        let y = Arc::new(RWLock::new());\n         lock_rwlock_in_mode(&y, DowngradeRead, || { });\n-        test_rwlock_exclusion(&y, Write, Write);\n+        test_rwlock_exclusion(y, Write, Write);\n     }\n     #[test]\n     fn test_rwlock_read_recursive() {\n         let x = RWLock::new();\n-        x.read(|| { x.read(|| { }) })\n+        let _g1 = x.read();\n+        let _g2 = x.read();\n     }\n     #[test]\n     fn test_rwlock_cond_wait() {\n         // As test_mutex_cond_wait above.\n-        let x = RWLock::new();\n+        let x = Arc::new(RWLock::new());\n \n         // Child wakes up parent\n-        x.write_cond(|cond| {\n+        {\n+            let lock = x.write();\n             let x2 = x.clone();\n             task::spawn(proc() {\n-                x2.write_cond(|cond| {\n-                    let woken = cond.signal();\n-                    assert!(woken);\n-                })\n+                let lock = x2.write();\n+                assert!(lock.cond.signal());\n             });\n-            cond.wait();\n-        });\n+            lock.cond.wait();\n+        }\n         // Parent wakes up child\n         let (tx, rx) = channel();\n         let x3 = x.clone();\n         task::spawn(proc() {\n-            x3.write_cond(|cond| {\n-                tx.send(());\n-                cond.wait();\n-                tx.send(());\n-            })\n-        });\n-        let _ = rx.recv(); // Wait until child gets in the rwlock\n-        x.read(|| { }); // Must be able to get in as a reader in the meantime\n-        x.write_cond(|cond| { // Or as another writer\n-            let woken = cond.signal();\n-            assert!(woken);\n+            let lock = x3.write();\n+            tx.send(());\n+            lock.cond.wait();\n+            tx.send(());\n         });\n-        let _ = rx.recv(); // Wait until child wakes up\n-        x.read(|| { }); // Just for good measure\n+        rx.recv(); // Wait until child gets in the rwlock\n+        drop(x.read()); // Must be able to get in as a reader\n+        {\n+            let x = x.write();\n+            assert!(x.cond.signal());\n+        }\n+        rx.recv(); // Wait until child wakes up\n+        drop(x.read()); // Just for good measure\n     }\n     #[cfg(test)]\n-    fn test_rwlock_cond_broadcast_helper(num_waiters: uint,\n-                                             dg1: bool,\n-                                             dg2: bool) {\n+    fn test_rwlock_cond_broadcast_helper(num_waiters: uint) {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n-        fn lock_cond(x: &RWLock, downgrade: bool, blk: |c: &Condvar|) {\n-            if downgrade {\n-                x.write_downgrade(|mode| {\n-                    mode.write_cond(|c| { blk(c) });\n-                });\n-            } else {\n-                x.write_cond(|c| { blk(c) });\n-            }\n+        fn lock_cond(x: &Arc<RWLock>, blk: |c: &Condvar|) {\n+            let lock = x.write();\n+            blk(&lock.cond);\n         }\n-        let x = RWLock::new();\n-        let mut rxs = vec!();\n+\n+        let x = Arc::new(RWLock::new());\n+        let mut rxs = Vec::new();\n \n         for _ in range(0, num_waiters) {\n             let xi = x.clone();\n             let (tx, rx) = channel();\n             rxs.push(rx);\n             task::spawn(proc() {\n-                lock_cond(&xi, dg1, |cond| {\n+                lock_cond(&xi, |cond| {\n                     tx.send(());\n                     cond.wait();\n                     tx.send(());\n@@ -1217,7 +1056,7 @@ mod tests {\n \n         // wait until all children get in the mutex\n         for rx in rxs.mut_iter() { let _ = rx.recv(); }\n-        lock_cond(&x, dg2, |cond| {\n+        lock_cond(&x, |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         });\n@@ -1226,21 +1065,15 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_cond_broadcast() {\n-        test_rwlock_cond_broadcast_helper(0, true, true);\n-        test_rwlock_cond_broadcast_helper(0, true, false);\n-        test_rwlock_cond_broadcast_helper(0, false, true);\n-        test_rwlock_cond_broadcast_helper(0, false, false);\n-        test_rwlock_cond_broadcast_helper(12, true, true);\n-        test_rwlock_cond_broadcast_helper(12, true, false);\n-        test_rwlock_cond_broadcast_helper(12, false, true);\n-        test_rwlock_cond_broadcast_helper(12, false, false);\n+        test_rwlock_cond_broadcast_helper(0);\n+        test_rwlock_cond_broadcast_helper(12);\n     }\n     #[cfg(test)]\n     fn rwlock_kill_helper(mode1: RWLockMode, mode2: RWLockMode) {\n         use std::any::Any;\n \n         // Mutex must get automatically unlocked if failed/killed within.\n-        let x = RWLock::new();\n+        let x = Arc::new(RWLock::new());\n         let x2 = x.clone();\n \n         let result: result::Result<(), ~Any> = task::try(proc() {\n@@ -1283,48 +1116,4 @@ mod tests {\n         rwlock_kill_helper(Downgrade, DowngradeRead);\n         rwlock_kill_helper(Downgrade, DowngradeRead);\n     }\n-    #[test] #[should_fail]\n-    fn test_rwlock_downgrade_cant_swap() {\n-        // Tests that you can't downgrade with a different rwlock's token.\n-        let x = RWLock::new();\n-        let y = RWLock::new();\n-        x.write_downgrade(|xwrite| {\n-            let mut xopt = Some(xwrite);\n-            y.write_downgrade(|_ywrite| {\n-                y.downgrade(xopt.take_unwrap());\n-                error!(\"oops, y.downgrade(x) should have failed!\");\n-            })\n-        })\n-    }\n-\n-    /************************************************************************\n-     * Barrier tests\n-     ************************************************************************/\n-    #[test]\n-    fn test_barrier() {\n-        let barrier = Barrier::new(10);\n-        let (tx, rx) = channel();\n-\n-        for _ in range(0, 9) {\n-            let c = barrier.clone();\n-            let tx = tx.clone();\n-            spawn(proc() {\n-                c.wait();\n-                tx.send(true);\n-            });\n-        }\n-\n-        // At this point, all spawned tasks should be blocked,\n-        // so we shouldn't get anything from the port\n-        assert!(match rx.try_recv() {\n-            Empty => true,\n-            _ => false,\n-        });\n-\n-        barrier.wait();\n-        // Now, the barrier is cleared and we should get data.\n-        for _ in range(0, 9) {\n-            rx.recv();\n-        }\n-    }\n }", "previous_filename": "src/libsync/sync/mod.rs"}]}