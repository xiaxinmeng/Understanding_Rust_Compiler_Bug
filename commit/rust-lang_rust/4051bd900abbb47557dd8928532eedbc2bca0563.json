{"sha": "4051bd900abbb47557dd8928532eedbc2bca0563", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNTFiZDkwMGFiYmI0NzU1N2RkODkyODUzMmVlZGJjMmJjYTA1NjM=", "commit": {"author": {"name": "Benjamin Herr", "email": "ben@0x539.de", "date": "2014-04-07T12:47:04Z"}, "committer": {"name": "Benjamin Herr", "email": "ben@0x539.de", "date": "2014-04-07T23:21:28Z"}, "message": "libglob: allow \".\" and \"..\" to be matched\n\n... also don't read the whole directory if the glob for that path\ncomponent doesn't contain any metacharacters.\n\nPatterns like `../*.jpg` will work now, and `.*` will match both `.` and\n`..` to be consistent with shell expansion.\n\nAs before: Just `*` still won't match `.` and `..`, while it will still\nmatch dotfiles like `.git` by default.", "tree": {"sha": "d9b598f7054e3b24a27e4d24573c837c10143e45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9b598f7054e3b24a27e4d24573c837c10143e45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4051bd900abbb47557dd8928532eedbc2bca0563", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4051bd900abbb47557dd8928532eedbc2bca0563", "html_url": "https://github.com/rust-lang/rust/commit/4051bd900abbb47557dd8928532eedbc2bca0563", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4051bd900abbb47557dd8928532eedbc2bca0563/comments", "author": {"login": "ben0x539", "id": 24142, "node_id": "MDQ6VXNlcjI0MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/24142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ben0x539", "html_url": "https://github.com/ben0x539", "followers_url": "https://api.github.com/users/ben0x539/followers", "following_url": "https://api.github.com/users/ben0x539/following{/other_user}", "gists_url": "https://api.github.com/users/ben0x539/gists{/gist_id}", "starred_url": "https://api.github.com/users/ben0x539/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ben0x539/subscriptions", "organizations_url": "https://api.github.com/users/ben0x539/orgs", "repos_url": "https://api.github.com/users/ben0x539/repos", "events_url": "https://api.github.com/users/ben0x539/events{/privacy}", "received_events_url": "https://api.github.com/users/ben0x539/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ben0x539", "id": 24142, "node_id": "MDQ6VXNlcjI0MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/24142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ben0x539", "html_url": "https://github.com/ben0x539", "followers_url": "https://api.github.com/users/ben0x539/followers", "following_url": "https://api.github.com/users/ben0x539/following{/other_user}", "gists_url": "https://api.github.com/users/ben0x539/gists{/gist_id}", "starred_url": "https://api.github.com/users/ben0x539/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ben0x539/subscriptions", "organizations_url": "https://api.github.com/users/ben0x539/orgs", "repos_url": "https://api.github.com/users/ben0x539/repos", "events_url": "https://api.github.com/users/ben0x539/events{/privacy}", "received_events_url": "https://api.github.com/users/ben0x539/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1f50565a1fda0dfd60d89fea65e2328f42cc5e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f50565a1fda0dfd60d89fea65e2328f42cc5e0", "html_url": "https://github.com/rust-lang/rust/commit/f1f50565a1fda0dfd60d89fea65e2328f42cc5e0"}], "stats": {"total": 114, "additions": 98, "deletions": 16}, "files": [{"sha": "07b7c6604e76d27db4d5ea609f5b1dc2d5f37eaf", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 85, "deletions": 9, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4051bd900abbb47557dd8928532eedbc2bca0563/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4051bd900abbb47557dd8928532eedbc2bca0563/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=4051bd900abbb47557dd8928532eedbc2bca0563", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -51,7 +51,7 @@ pub struct Paths {\n /// Return an iterator that produces all the Paths that match the given pattern,\n /// which may be absolute or relative to the current working directory.\n ///\n-/// is method uses the default match options and is equivalent to calling\n+/// This method uses the default match options and is equivalent to calling\n /// `glob_with(pattern, MatchOptions::new())`. Use `glob_with` directly if you\n /// want to use non-default match options.\n ///\n@@ -117,9 +117,15 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> Paths {\n     let dir_patterns = pattern.slice_from(cmp::min(root_len, pattern.len()))\n                        .split_terminator(is_sep)\n                        .map(|s| Pattern::new(s))\n-                       .collect();\n+                       .collect::<Vec<Pattern>>();\n \n-    let todo = list_dir_sorted(&root).move_iter().map(|x|(x,0u)).collect();\n+    let mut todo = Vec::new();\n+    if dir_patterns.len() > 0 {\n+        // Shouldn't happen, but we're using -1 as a special index.\n+        assert!(dir_patterns.len() < -1 as uint);\n+\n+        fill_todo(&mut todo, dir_patterns.as_slice(), 0, &root, options);\n+    }\n \n     Paths {\n         root: root,\n@@ -138,6 +144,9 @@ impl Iterator<Path> for Paths {\n             }\n \n             let (path,idx) = self.todo.pop().unwrap();\n+            // idx -1: was already checked by fill_todo, maybe path was '.' or\n+            // '..' that we can't match here because of normalization.\n+            if idx == -1 as uint { return Some(path); }\n             let ref pattern = *self.dir_patterns.get(idx);\n \n             if pattern.matches_with(match path.filename_str() {\n@@ -154,21 +163,22 @@ impl Iterator<Path> for Paths {\n                     // so we don't need to check the children\n                     return Some(path);\n                 } else {\n-                    self.todo.extend(list_dir_sorted(&path).move_iter().map(|x|(x,idx+1)));\n+                    fill_todo(&mut self.todo, self.dir_patterns.as_slice(),\n+                              idx + 1, &path, self.options);\n                 }\n             }\n         }\n     }\n \n }\n \n-fn list_dir_sorted(path: &Path) -> Vec<Path> {\n+fn list_dir_sorted(path: &Path) -> Option<Vec<Path>> {\n     match fs::readdir(path) {\n         Ok(mut children) => {\n             children.sort_by(|p1, p2| p2.filename().cmp(&p1.filename()));\n-            children.move_iter().collect()\n+            Some(children.move_iter().collect())\n         }\n-        Err(..) => Vec::new()\n+        Err(..) => None\n     }\n }\n \n@@ -435,6 +445,72 @@ impl Pattern {\n \n }\n \n+// Fills `todo` with paths under `path` to be matched by `patterns[idx]`,\n+// special-casing patterns to match `.` and `..`, and avoiding `readdir()`\n+// calls when there are no metacharacters in the pattern.\n+fn fill_todo(todo: &mut Vec<(Path, uint)>, patterns: &[Pattern], idx: uint, path: &Path,\n+             options: MatchOptions) {\n+    // convert a pattern that's just many Char(_) to a string\n+    fn pattern_as_str(pattern: &Pattern) -> Option<~str> {\n+        let mut s = ~\"\";\n+        for token in pattern.tokens.iter() {\n+            match *token {\n+                Char(c) => s.push_char(c),\n+                _ => return None\n+            }\n+        }\n+        return Some(s);\n+    }\n+\n+    let add = |todo: &mut Vec<_>, next_path: Path| {\n+        if idx + 1 == patterns.len() {\n+            // We know it's good, so don't make the iterator match this path\n+            // against the pattern again. In particular, it can't match\n+            // . or .. globs since these never show up as path components.\n+            todo.push((next_path, -1 as uint));\n+        } else {\n+            fill_todo(todo, patterns, idx + 1, &next_path, options);\n+        }\n+    };\n+\n+    let pattern = &patterns[idx];\n+\n+    match pattern_as_str(pattern) {\n+        Some(s) => {\n+            // This pattern component doesn't have any metacharacters, so we\n+            // don't need to read the current directory to know where to\n+            // continue. So instead of passing control back to the iterator,\n+            // we can just check for that one entry and potentially recurse\n+            // right away.\n+            let special = \".\" == s || \"..\" == s;\n+            let next_path = path.join(s);\n+            if (special && path.is_dir()) || (!special && next_path.exists()) {\n+                add(todo, next_path);\n+            }\n+        },\n+        None => {\n+            match list_dir_sorted(path) {\n+                Some(entries) => {\n+                    todo.extend(entries.move_iter().map(|x|(x, idx)));\n+\n+                    // Matching the special directory entries . and .. that refer to\n+                    // the current and parent directory respectively requires that\n+                    // the pattern has a leading dot, even if the `MatchOptions` field\n+                    // `require_literal_leading_dot` is not set.\n+                    if pattern.tokens.len() > 0 && pattern.tokens.get(0) == &Char('.') {\n+                        for &special in [\".\", \"..\"].iter() {\n+                            if pattern.matches_with(special, options) {\n+                                add(todo, path.join(special));\n+                            }\n+                        }\n+                    }\n+                }\n+                None => {}\n+            }\n+        }\n+    }\n+}\n+\n fn parse_char_specifiers(s: &[char]) -> Vec<CharSpecifier> {\n     let mut cs = Vec::new();\n     let mut i = 0;\n@@ -567,7 +643,7 @@ mod test {\n     fn test_absolute_pattern() {\n         // assume that the filesystem is not empty!\n         assert!(glob(\"/*\").next().is_some());\n-        assert!(glob(\"//\").next().is_none());\n+        assert!(glob(\"//\").next().is_some());\n \n         // check windows absolute paths with host/device components\n         let root_with_device = os::getcwd().root_path().unwrap().join(\"*\");"}, {"sha": "eec6d675295744e5c87647e5d6504104d1497191", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4051bd900abbb47557dd8928532eedbc2bca0563/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4051bd900abbb47557dd8928532eedbc2bca0563/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=4051bd900abbb47557dd8928532eedbc2bca0563", "patch": "@@ -11,13 +11,12 @@\n // ignore-fast check-fast doesn't like 'extern crate extra'\n // ignore-win32 TempDir may cause IoError on windows: #10462\n \n-#[feature(macro_rules)];\n+#![feature(macro_rules)]\n \n extern crate glob;\n \n use glob::glob;\n-use std::unstable::finally::Finally;\n-use std::{os, unstable};\n+use std::os;\n use std::io;\n use std::io::TempDir;\n \n@@ -30,9 +29,9 @@ macro_rules! assert_eq ( ($e1:expr, $e2:expr) => (\n pub fn main() {\n     fn mk_file(path: &str, directory: bool) {\n         if directory {\n-            io::fs::mkdir(&Path::new(path), io::UserRWX);\n+            io::fs::mkdir(&Path::new(path), io::UserRWX).unwrap();\n         } else {\n-            io::File::create(&Path::new(path));\n+            io::File::create(&Path::new(path)).unwrap();\n         }\n     }\n \n@@ -73,8 +72,8 @@ pub fn main() {\n     mk_file(\"xyz/z\", false);\n \n     assert_eq!(glob_vec(\"\"), Vec::new());\n-    assert_eq!(glob_vec(\".\"), Vec::new());\n-    assert_eq!(glob_vec(\"..\"), Vec::new());\n+    assert_eq!(glob_vec(\".\"), vec!(os::getcwd()));\n+    assert_eq!(glob_vec(\"..\"), vec!(os::getcwd().join(\"..\")));\n \n     assert_eq!(glob_vec(\"aaa\"), vec!(abs_path(\"aaa\")));\n     assert_eq!(glob_vec(\"aaa/\"), vec!(abs_path(\"aaa\")));\n@@ -132,6 +131,13 @@ pub fn main() {\n         abs_path(\"aaa/tomato/tomato.txt\"),\n         abs_path(\"aaa/tomato/tomoto.txt\")));\n \n+    assert_eq!(glob_vec(\"./aaa\"), vec!(abs_path(\"aaa\")));\n+    assert_eq!(glob_vec(\"./*\"), glob_vec(\"*\"));\n+    assert_eq!(glob_vec(\"*/..\").pop().unwrap(), abs_path(\".\"));\n+    assert_eq!(glob_vec(\"aaa/../bbb\"), vec!(abs_path(\"bbb\")));\n+    assert_eq!(glob_vec(\"nonexistent/../bbb\"), Vec::new());\n+    assert_eq!(glob_vec(\"aaa/tomato/tomato.txt/..\"), Vec::new());\n+\n     assert_eq!(glob_vec(\"aa[a]\"), vec!(abs_path(\"aaa\")));\n     assert_eq!(glob_vec(\"aa[abc]\"), vec!(abs_path(\"aaa\")));\n     assert_eq!(glob_vec(\"a[bca]a\"), vec!(abs_path(\"aaa\")));"}]}