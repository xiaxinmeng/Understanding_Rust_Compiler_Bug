{"sha": "8dbbd81f7ed83943b870407ef44aecf6664e7679", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYmJkODFmN2VkODM5NDNiODcwNDA3ZWY0NGFlY2Y2NjY0ZTc2Nzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-23T17:45:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-23T17:45:34Z"}, "message": "Auto merge of #52566 - pnkfelix:buffer-nll-errors-for-z-borrowck-migrate, r=nikomatsakis\n\nBuffer NLL errors\n\nBuffer the errors generated during MIR-borrowck (aka NLL).\n\nThis is the first big step towards resolving issue #46908.", "tree": {"sha": "5ff041273ba33b8777c74c9631ab98434410715c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ff041273ba33b8777c74c9631ab98434410715c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dbbd81f7ed83943b870407ef44aecf6664e7679", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dbbd81f7ed83943b870407ef44aecf6664e7679", "html_url": "https://github.com/rust-lang/rust/commit/8dbbd81f7ed83943b870407ef44aecf6664e7679", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dbbd81f7ed83943b870407ef44aecf6664e7679/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bb50f569dd4da5fd29717177138665e86e59eb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bb50f569dd4da5fd29717177138665e86e59eb0", "html_url": "https://github.com/rust-lang/rust/commit/6bb50f569dd4da5fd29717177138665e86e59eb0"}, {"sha": "1a0294bb84d2b4aaf66634f61279bca5e132d1dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a0294bb84d2b4aaf66634f61279bca5e132d1dc", "html_url": "https://github.com/rust-lang/rust/commit/1a0294bb84d2b4aaf66634f61279bca5e132d1dc"}], "stats": {"total": 242, "additions": 161, "deletions": 81}, "files": [{"sha": "4ad60f2f85e2cf4c67829bc3a18d0f862056f776", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -1086,6 +1086,23 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n     ) {\n+        self.construct_generic_bound_failure(region_scope_tree,\n+                                             span,\n+                                             origin,\n+                                             bound_kind,\n+                                             sub)\n+            .emit()\n+    }\n+\n+    pub fn construct_generic_bound_failure(\n+        &self,\n+        region_scope_tree: &region::ScopeTree,\n+        span: Span,\n+        origin: Option<SubregionOrigin<'tcx>>,\n+        bound_kind: GenericKind<'tcx>,\n+        sub: Region<'tcx>,\n+    ) -> DiagnosticBuilder<'a>\n+    {\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n         let type_param_span = match (self.in_progress_tables, bound_kind) {\n@@ -1139,14 +1156,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             trait_item_def_id,\n         }) = origin\n         {\n-            self.report_extra_impl_obligation(\n+            return self.report_extra_impl_obligation(\n                 span,\n                 item_name,\n                 impl_item_def_id,\n                 trait_item_def_id,\n                 &format!(\"`{}: {}`\", bound_kind, sub),\n-            ).emit();\n-            return;\n+            );\n         }\n \n         fn binding_suggestion<'tcx, S: fmt::Display>(\n@@ -1229,7 +1245,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         if let Some(origin) = origin {\n             self.note_region_origin(&mut err, &origin);\n         }\n-        err.emit();\n+        err\n     }\n \n     fn report_sub_sup_conflict("}, {"sha": "41007508c506010c2e73c1e012300073ab758c0f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -849,7 +849,7 @@ impl<'tcx> CommonTypes<'tcx> {\n ///\n /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/ty.html\n #[derive(Copy, Clone)]\n-pub struct TyCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct TyCtxt<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     gcx: &'a GlobalCtxt<'gcx>,\n     interners: &'a CtxtInterners<'tcx>\n }"}, {"sha": "8f99ad87cb8e023699640a6d49f5d056d93f167c", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -88,6 +88,18 @@ impl<'a> DiagnosticBuilder<'a> {\n         self.cancel();\n     }\n \n+    /// Buffers the diagnostic for later emission.\n+    pub fn buffer(self, buffered_diagnostics: &mut Vec<Diagnostic>) {\n+        // We need to use `ptr::read` because `DiagnosticBuilder`\n+        // implements `Drop`.\n+        let diagnostic;\n+        unsafe {\n+            diagnostic = ::std::ptr::read(&self.diagnostic);\n+            ::std::mem::forget(self);\n+        };\n+        buffered_diagnostics.push(diagnostic);\n+    }\n+\n     pub fn is_error(&self) -> bool {\n         match self.level {\n             Level::Bug |"}, {"sha": "9e822d28056de25425dfd0e845ef7c6f8cdc8a8d", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -58,17 +58,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n             };\n-            self.tcx\n+            let mut err = self.tcx\n                 .cannot_act_on_uninitialized_variable(\n                     span,\n                     desired_action.as_noun(),\n                     &self\n                         .describe_place_with_options(place, IncludingDowncast(true))\n                         .unwrap_or(\"_\".to_owned()),\n                     Origin::Mir,\n-                )\n-                .span_label(span, format!(\"use of possibly uninitialized {}\", item_msg))\n-                .emit();\n+                );\n+            err.span_label(span, format!(\"use of possibly uninitialized {}\", item_msg));\n+            err.buffer(&mut self.errors_buffer);\n         } else {\n             let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n \n@@ -143,7 +143,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            err.emit();\n+            err.buffer(&mut self.errors_buffer);\n         }\n     }\n \n@@ -173,7 +173,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n         err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n         self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n-        err.emit();\n+        err.buffer(&mut self.errors_buffer);\n     }\n \n     pub(super) fn report_use_while_mutably_borrowed(\n@@ -194,8 +194,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n-\n-        err.emit();\n+        err.buffer(&mut self.errors_buffer);\n     }\n \n     /// Finds the span of arguments of a closure (within `maybe_closure_span`) and its usage of\n@@ -391,7 +390,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         self.explain_why_borrow_contains_point(context, issued_borrow, None, &mut err);\n \n-        err.emit();\n+        err.buffer(&mut self.errors_buffer);\n     }\n \n     pub(super) fn report_borrowed_value_does_not_live_long_enough(\n@@ -513,7 +512,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             format!(\"`{}` dropped here while still borrowed\", name),\n         );\n         self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n-        err.emit();\n+        err.buffer(&mut self.errors_buffer);\n     }\n \n     fn report_scoped_temporary_value_does_not_live_long_enough(\n@@ -535,7 +534,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n         err.note(\"consider using a `let` binding to increase its lifetime\");\n         self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n-        err.emit();\n+        err.buffer(&mut self.errors_buffer);\n     }\n \n     fn report_unscoped_local_value_does_not_live_long_enough(\n@@ -563,7 +562,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.span_label(drop_span, \"borrowed value only lives until here\");\n \n         self.explain_why_borrow_contains_point(context, borrow, kind_place, &mut err);\n-        err.emit();\n+        err.buffer(&mut self.errors_buffer);\n     }\n \n     fn report_unscoped_temporary_value_does_not_live_long_enough(\n@@ -589,7 +588,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.span_label(drop_span, \"temporary value only lives until here\");\n \n         self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n-        err.emit();\n+        err.buffer(&mut self.errors_buffer);\n     }\n \n     pub(super) fn report_illegal_mutation_of_borrowed(\n@@ -608,7 +607,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         self.explain_why_borrow_contains_point(context, loan, None, &mut err);\n \n-        err.emit();\n+        err.buffer(&mut self.errors_buffer);\n     }\n \n     /// Reports an illegal reassignment; for example, an assignment to\n@@ -679,7 +678,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n         err.span_label(span, msg);\n-        err.emit();\n+        err.buffer(&mut self.errors_buffer);\n     }\n }\n "}, {"sha": "08500efe8efed55025c44acc62e8f49876a221d9", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -23,6 +23,7 @@ use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n use rustc::ty::{self, ParamEnv, TyCtxt};\n \n+use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n@@ -148,6 +149,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let mir = &mir; // no further changes\n     let location_table = &LocationTable::new(mir);\n \n+    let mut errors_buffer = Vec::new();\n     let (move_data, move_errors): (MoveData<'tcx>, Option<Vec<MoveError<'tcx>>>) =\n         match MoveData::gather_moves(mir, tcx) {\n             Ok(move_data) => (move_data, None),\n@@ -214,6 +216,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         &mut flow_inits,\n         &mdpe.move_data,\n         &borrow_set,\n+        &mut errors_buffer,\n     );\n     let regioncx = Rc::new(regioncx);\n \n@@ -252,6 +255,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         access_place_error_reported: FxHashSet(),\n         reservation_error_reported: FxHashSet(),\n         moved_error_reported: FxHashSet(),\n+        errors_buffer,\n         nonlexical_regioncx: regioncx,\n         used_mut: FxHashSet(),\n         used_mut_upvars: SmallVec::new(),\n@@ -287,10 +291,12 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n \n     debug!(\"mbcx.used_mut: {:?}\", mbcx.used_mut);\n \n+    let used_mut = mbcx.used_mut;\n+\n     for local in mbcx\n         .mir\n         .mut_vars_and_args_iter()\n-        .filter(|local| !mbcx.used_mut.contains(local))\n+        .filter(|local| !used_mut.contains(local))\n     {\n         if let ClearCrossCrate::Set(ref vsi) = mbcx.mir.source_scope_local_data {\n             let local_decl = &mbcx.mir.local_decls[local];\n@@ -311,16 +317,22 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n             let span = local_decl.source_info.span;\n             let mut_span = tcx.sess.codemap().span_until_non_whitespace(span);\n \n-            tcx.struct_span_lint_node(\n+            let mut err = tcx.struct_span_lint_node(\n                 UNUSED_MUT,\n                 vsi[local_decl.source_info.scope].lint_root,\n                 span,\n                 \"variable does not need to be mutable\",\n-            ).span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned())\n-                .emit();\n+            );\n+            err.span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned());\n+\n+            err.buffer(&mut mbcx.errors_buffer);\n         }\n     }\n \n+    for diag in mbcx.errors_buffer.drain(..) {\n+        DiagnosticBuilder::new_diagnostic(mbcx.tcx.sess.diagnostic(), diag).emit();\n+    }\n+\n     let result = BorrowCheckResult {\n         closure_requirements: opt_closure_req,\n         used_mut_upvars: mbcx.used_mut_upvars,\n@@ -331,7 +343,6 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     result\n }\n \n-#[allow(dead_code)]\n pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     mir: &'cx Mir<'tcx>,\n@@ -366,8 +377,10 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// at the time we detect and report a reservation error.\n     reservation_error_reported: FxHashSet<Place<'tcx>>,\n     /// This field keeps track of errors reported in the checking of moved variables,\n-    /// so that we don't report report seemingly duplicate errors.\n+    /// so that we don't report seemingly duplicate errors.\n     moved_error_reported: FxHashSet<Place<'tcx>>,\n+    /// Errors to be reported buffer\n+    errors_buffer: Vec<Diagnostic>,\n     /// This field keeps track of all the local variables that are declared mut and are mutated.\n     /// Used for the warning issued by an unused mutable local variable.\n     used_mut: FxHashSet<Local>,\n@@ -1354,13 +1367,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         debug!(\"check_for_local_borrow({:?})\", borrow);\n \n         if borrow_of_local_data(&borrow.borrowed_place) {\n-            self.tcx\n+            let err = self.tcx\n                 .cannot_borrow_across_generator_yield(\n                     self.retrieve_borrow_span(borrow),\n                     yield_span,\n                     Origin::Mir,\n-                )\n-                .emit();\n+                );\n+\n+            err.buffer(&mut self.errors_buffer);\n         }\n     }\n "}, {"sha": "eacdbe8e9455ea6473422abbdf2e7b8681709f98", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -59,7 +59,7 @@ enum GroupedMoveError<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n-    pub(crate) fn report_move_errors(&self, move_errors: Vec<MoveError<'tcx>>) {\n+    pub(crate) fn report_move_errors(&mut self, move_errors: Vec<MoveError<'tcx>>) {\n         let grouped_errors = self.group_move_errors(move_errors);\n         for error in grouped_errors {\n             self.report(error);\n@@ -218,7 +218,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         };\n     }\n \n-    fn report(&self, error: GroupedMoveError<'tcx>) {\n+    fn report(&mut self, error: GroupedMoveError<'tcx>) {\n         let (mut err, err_span) = {\n             let (span, kind): (Span, &IllegalMoveOriginKind) = match error {\n                 GroupedMoveError::MovesFromMatchPlace { span, ref kind, .. }\n@@ -286,7 +286,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         self.add_move_hints(error, &mut err, err_span);\n-        err.emit();\n+        err.buffer(&mut self.errors_buffer);\n     }\n \n     fn add_move_hints("}, {"sha": "760d0a91b795c910a34770fec591052d9c55a21f", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -378,7 +378,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        err.emit();\n+        err.buffer(&mut self.errors_buffer);\n     }\n \n     // Does this place refer to what the user sees as an upvar"}, {"sha": "aa88fa11174b1d078fae1e6ae4e5be48d1efafb0", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -19,10 +19,10 @@ use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use util::liveness::{self, DefUse, LivenessMode};\n \n-crate fn find<'cx, 'gcx: 'tcx, 'tcx: 'cx>(\n-    mir: &'cx Mir<'tcx>,\n-    regioncx: &'cx Rc<RegionInferenceContext<'tcx>>,\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+crate fn find<'tcx>(\n+    mir: &Mir<'tcx>,\n+    regioncx: &Rc<RegionInferenceContext<'tcx>>,\n+    tcx: TyCtxt<'_, '_, 'tcx>,\n     region_vid: RegionVid,\n     start_point: Location,\n ) -> Option<Cause> {"}, {"sha": "edc701bad1eb3a28bc88350cf7f915a118ffd6e0", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -23,6 +23,7 @@ use rustc::infer::InferCtxt;\n use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Mir};\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc::util::nodemap::FxHashMap;\n+use rustc_errors::Diagnostic;\n use std::collections::BTreeSet;\n use std::fmt::Debug;\n use std::env;\n@@ -91,6 +92,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n+    errors_buffer: &mut Vec<Diagnostic>,\n ) -> (\n     RegionInferenceContext<'tcx>,\n     Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex>>>,\n@@ -120,6 +122,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         flow_inits,\n         move_data,\n         elements,\n+        errors_buffer,\n     );\n \n     if let Some(all_facts) = &mut all_facts {\n@@ -190,7 +193,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     });\n \n     // Solve the region constraints.\n-    let closure_region_requirements = regioncx.solve(infcx, &mir, def_id);\n+    let closure_region_requirements = regioncx.solve(infcx, &mir, def_id, errors_buffer);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n@@ -205,7 +208,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n \n     // We also have a `#[rustc_nll]` annotation that causes us to dump\n     // information\n-    dump_annotation(infcx, &mir, def_id, &regioncx, &closure_region_requirements);\n+    dump_annotation(infcx, &mir, def_id, &regioncx, &closure_region_requirements, errors_buffer);\n \n     (regioncx, polonius_output, closure_region_requirements)\n }\n@@ -323,6 +326,7 @@ fn dump_annotation<'a, 'gcx, 'tcx>(\n     mir_def_id: DefId,\n     regioncx: &RegionInferenceContext,\n     closure_region_requirements: &Option<ClosureRegionRequirements>,\n+    errors_buffer: &mut Vec<Diagnostic>,\n ) {\n     let tcx = infcx.tcx;\n     let base_def_id = tcx.closure_base_def_id(mir_def_id);\n@@ -357,14 +361,15 @@ fn dump_annotation<'a, 'gcx, 'tcx>(\n             Ok(())\n         }).unwrap();\n \n-        err.emit();\n+        err.buffer(errors_buffer);\n     } else {\n         let mut err = tcx\n             .sess\n             .diagnostic()\n             .span_note_diag(mir.span, \"No external requirements\");\n         regioncx.annotate(&mut err);\n-        err.emit();\n+\n+        err.buffer(errors_buffer);\n     }\n }\n "}, {"sha": "7cde06be0c23b416ac40d5994249de23d253d986", "filename": "src/librustc_mir/borrow_check/nll/region_infer/annotation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -19,7 +19,7 @@ use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::universal_regions::DefiningTy;\n use rustc_errors::DiagnosticBuilder;\n \n-impl<'gcx, 'tcx> RegionInferenceContext<'tcx> {\n+impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Write out our state into the `.mir` files.\n     pub(crate) fn annotate(&self, err: &mut DiagnosticBuilder<'_>) {\n         match self.universal_regions.defining_ty {"}, {"sha": "131e1defc1f9e47fd35bca7591e99b1062b82259", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -18,6 +18,7 @@ use rustc::mir::{self, Location, Mir, Place, Rvalue, StatementKind, TerminatorKi\n use rustc::ty::RegionVid;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_errors::Diagnostic;\n use std::fmt;\n use syntax_pos::Span;\n \n@@ -199,6 +200,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr: RegionVid,\n         outlived_fr: RegionVid,\n         blame_span: Span,\n+        errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n@@ -247,9 +249,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         match category {\n             ConstraintCategory::AssignmentToUpvar |\n             ConstraintCategory::CallArgumentToUpvar =>\n-                self.report_closure_error(mir, infcx, mir_def_id, fr, outlived_fr, category, span),\n+                self.report_closure_error(\n+                    mir, infcx, mir_def_id, fr, outlived_fr, category, span, errors_buffer),\n             _ =>\n-                self.report_general_error(mir, infcx, mir_def_id, fr, outlived_fr, category, span),\n+                self.report_general_error(\n+                    mir, infcx, mir_def_id, fr, outlived_fr, category, span, errors_buffer),\n         }\n     }\n \n@@ -262,18 +266,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         outlived_fr: RegionVid,\n         category: &ConstraintCategory,\n         span: &Span,\n+        errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n         let fr_name_and_span  = self.get_var_name_and_span_for_region(\n             infcx.tcx, mir, fr);\n         let outlived_fr_name_and_span = self.get_var_name_and_span_for_region(\n             infcx.tcx, mir,outlived_fr);\n \n         if fr_name_and_span.is_none() && outlived_fr_name_and_span.is_none() {\n-            return self.report_general_error(mir, infcx, mir_def_id, fr, outlived_fr, category,\n-                                             span);\n+            return self.report_general_error(\n+                mir, infcx, mir_def_id, fr, outlived_fr, category, span, errors_buffer);\n         }\n \n-        let diag = &mut infcx.tcx.sess.struct_span_err(\n+        let mut diag = infcx.tcx.sess.struct_span_err(\n             *span, &format!(\"borrowed data escapes outside of closure\"),\n         );\n \n@@ -297,7 +302,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        diag.emit();\n+        diag.buffer(errors_buffer);\n     }\n \n     fn report_general_error(\n@@ -309,23 +314,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         outlived_fr: RegionVid,\n         category: &ConstraintCategory,\n         span: &Span,\n+        errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n-        let diag = &mut infcx.tcx.sess.struct_span_err(\n+        let mut diag = infcx.tcx.sess.struct_span_err(\n             *span, &format!(\"unsatisfied lifetime constraints\"), // FIXME\n         );\n \n         let counter = &mut 1;\n         let fr_name = self.give_region_a_name(\n-            infcx.tcx, mir, mir_def_id, fr, counter, diag);\n+            infcx.tcx, mir, mir_def_id, fr, counter, &mut diag);\n         let outlived_fr_name = self.give_region_a_name(\n-            infcx.tcx, mir, mir_def_id, outlived_fr, counter, diag);\n+            infcx.tcx, mir, mir_def_id, outlived_fr, counter, &mut diag);\n \n         diag.span_label(*span, format!(\n             \"{} requires that `{}` must outlive `{}`\",\n             category, fr_name, outlived_fr_name,\n         ));\n \n-        diag.emit();\n+        diag.buffer(errors_buffer);\n     }\n \n     // Find some constraint `X: Y` where:"}, {"sha": "52f596f61c2e803beba22d2ff46402d28fcf9212", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -30,6 +30,7 @@ use rustc::util::common;\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_data_structures::indexed_set::{IdxSet, IdxSetBuf};\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_errors::Diagnostic;\n \n use std::rc::Rc;\n \n@@ -360,11 +361,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n+        errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n         common::time(\n             infcx.tcx.sess,\n             &format!(\"solve_nll_region_constraints({:?})\", mir_def_id),\n-            || self.solve_inner(infcx, mir, mir_def_id),\n+            || self.solve_inner(infcx, mir, mir_def_id, errors_buffer),\n         )\n     }\n \n@@ -373,6 +375,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n+        errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n         self.propagate_constraints(mir);\n \n@@ -387,9 +390,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             None\n         };\n \n-        self.check_type_tests(infcx, mir, mir_def_id, outlives_requirements.as_mut());\n+        self.check_type_tests(\n+            infcx, mir, mir_def_id, outlives_requirements.as_mut(), errors_buffer);\n \n-        self.check_universal_regions(infcx, mir, mir_def_id, outlives_requirements.as_mut());\n+        self.check_universal_regions(\n+            infcx, mir, mir_def_id, outlives_requirements.as_mut(), errors_buffer);\n \n         let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n@@ -476,6 +481,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n+        errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n         let tcx = infcx.tcx;\n \n@@ -502,13 +508,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let Some(lower_bound_region) = lower_bound_region {\n                 let region_scope_tree = &tcx.region_scope_tree(mir_def_id);\n                 let type_test_span = type_test.locations.span(mir);\n-                infcx.report_generic_bound_failure(\n+                infcx.construct_generic_bound_failure(\n                     region_scope_tree,\n                     type_test_span,\n                     None,\n                     type_test.generic_kind,\n                     lower_bound_region,\n-                );\n+                ).buffer(errors_buffer);\n             } else {\n                 // FIXME. We should handle this case better. It\n                 // indicates that we have e.g. some region variable\n@@ -520,10 +526,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // iterating over the universal regions and reporting\n                 // an error that multiple bounds are required.\n                 let type_test_span = type_test.locations.span(mir);\n-                tcx.sess.span_err(\n+                tcx.sess.struct_span_err(\n                     type_test_span,\n                     &format!(\"`{}` does not live long enough\", type_test.generic_kind,),\n-                );\n+                ).buffer(errors_buffer);\n             }\n         }\n     }\n@@ -834,6 +840,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n+        errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n         // The universal regions are always found in a prefix of the\n         // full list.\n@@ -851,6 +858,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 mir_def_id,\n                 fr,\n                 &mut propagated_outlives_requirements,\n+                errors_buffer,\n             );\n         }\n     }\n@@ -870,6 +878,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n+        errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n         debug!(\"check_universal_region(fr={:?})\", longer_fr);\n \n@@ -924,7 +933,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Note: in this case, we use the unapproximated regions\n             // to report the error. This gives better error messages\n             // in some cases.\n-            self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, blame_span);\n+            self.report_error(\n+                mir, infcx, mir_def_id, longer_fr, shorter_fr, blame_span, errors_buffer);\n         }\n     }\n }"}, {"sha": "a80cd9ff1a4be9aed233df69eaadd24649186b00", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -41,6 +41,7 @@ use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n use util::liveness::LivenessResults;\n+use rustc_errors::Diagnostic;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -102,6 +103,7 @@ mod liveness;\n ///   constraints for the regions in the types of variables\n /// - `flow_inits` -- results of a maybe-init dataflow analysis\n /// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n+/// - `errors_buffer` -- errors are sent here for future reporting\n pub(crate) fn type_check<'gcx, 'tcx>(\n     infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n@@ -115,6 +117,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n+    errors_buffer: &mut Vec<Diagnostic>,\n ) -> MirTypeckRegionConstraints<'tcx> {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n@@ -140,14 +143,13 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n             &universal_regions.region_bound_pairs,\n             Some(implicit_region_bound),\n             Some(&mut borrowck_context),\n+            Some(errors_buffer),\n             |cx| {\n                 liveness::generate(cx, mir, liveness, flow_inits, move_data);\n-\n                 cx.equate_inputs_and_outputs(mir, mir_def_id, universal_regions);\n             },\n         );\n     }\n-\n     constraints\n }\n \n@@ -159,6 +161,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, F>(\n     region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n+    errors_buffer: Option<&mut Vec<Diagnostic>>,\n     mut extra: F,\n )\n     where F: FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>)\n@@ -180,7 +183,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, F>(\n \n     if !errors_reported {\n         // if verifier failed, don't do further checks to avoid ICEs\n-        checker.typeck_mir(mir);\n+        checker.typeck_mir(mir, errors_buffer);\n     }\n \n     extra(&mut checker);\n@@ -202,7 +205,7 @@ enum FieldAccessError {\n /// The sanitize_XYZ methods here take an MIR object and compute its\n /// type, calling `span_mirbug` and returning an error type if there\n /// is a problem.\n-struct TypeVerifier<'a, 'b: 'a, 'gcx: 'b + 'tcx, 'tcx: 'b> {\n+struct TypeVerifier<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     last_span: Span,\n@@ -611,7 +614,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n /// constraints needed for it to be valid and well-typed. Along the\n /// way, it accrues region constraints -- these can later be used by\n /// NLL region checking.\n-struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n     last_span: Span,\n@@ -1227,7 +1230,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_local(&mut self, mir: &Mir<'tcx>, local: Local, local_decl: &LocalDecl<'tcx>) {\n+    fn check_local(&mut self,\n+                   mir: &Mir<'tcx>,\n+                   local: Local,\n+                   local_decl: &LocalDecl<'tcx>,\n+                   errors_buffer: &mut Option<&mut Vec<Diagnostic>>)\n+    {\n         match mir.local_kind(local) {\n             LocalKind::ReturnPointer | LocalKind::Arg => {\n                 // return values of normal functions are required to be\n@@ -1255,14 +1263,21 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             // slot or local, so to find all unsized rvalues it is enough\n             // to check all temps, return slots and locals.\n             if let None = self.reported_errors.replace((ty, span)) {\n-                span_err!(\n-                    self.tcx().sess,\n-                    span,\n-                    E0161,\n-                    \"cannot move a value of type {0}: the size of {0} \\\n-                     cannot be statically determined\",\n-                    ty\n-                );\n+                let mut diag = struct_span_err!(self.tcx().sess,\n+                                                span,\n+                                                E0161,\n+                                                \"cannot move a value of type {0}: the size of {0} \\\n+                                                 cannot be statically determined\",\n+                                                ty);\n+                if let Some(ref mut errors_buffer) = *errors_buffer {\n+                    diag.buffer(errors_buffer);\n+                } else {\n+                    // we're allowed to use emit() here because the\n+                    // NLL migration will be turned on (and thus\n+                    // errors will need to be buffered) *only if*\n+                    // errors_buffer is Some.\n+                    diag.emit();\n+                }\n             }\n         }\n     }\n@@ -1742,12 +1757,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n+    fn typeck_mir(&mut self,\n+                  mir: &Mir<'tcx>,\n+                  mut errors_buffer: Option<&mut Vec<Diagnostic>>)\n+    {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);\n \n         for (local, local_decl) in mir.local_decls.iter_enumerated() {\n-            self.check_local(mir, local, local_decl);\n+            self.check_local(mir, local, local_decl, &mut errors_buffer);\n         }\n \n         for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n@@ -1812,7 +1830,7 @@ impl MirPass for TypeckMir {\n \n         let param_env = tcx.param_env(def_id);\n         tcx.infer_ctxt().enter(|infcx| {\n-            type_check_internal(&infcx, def_id, param_env, mir, &[], None, None, |_| ());\n+            type_check_internal(&infcx, def_id, param_env, mir, &[], None, None, None, |_| ());\n \n             // For verification purposes, we just ignore the resulting\n             // region constraint sets. Not our problem. =)"}, {"sha": "f8dc7d2a2a8d1828e5fae183ee76a38efc51b673", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -34,8 +34,8 @@ pub trait MirWithFlowState<'tcx> {\n     fn flow_state(&self) -> &DataflowState<Self::BD>;\n }\n \n-impl<'a, 'tcx: 'a, BD> MirWithFlowState<'tcx> for DataflowBuilder<'a, 'tcx, BD>\n-    where 'tcx: 'a, BD: BitDenotation\n+impl<'a, 'tcx, BD> MirWithFlowState<'tcx> for DataflowBuilder<'a, 'tcx, BD>\n+    where BD: BitDenotation\n {\n     type BD = BD;\n     fn node_id(&self) -> NodeId { self.node_id }"}, {"sha": "995d1340acaf605d0092f5a68e482125b762105e", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbd81f7ed83943b870407ef44aecf6664e7679/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=8dbbd81f7ed83943b870407ef44aecf6664e7679", "patch": "@@ -53,8 +53,8 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     _nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n }\n \n-fn precompute_borrows_out_of_scope<'a, 'tcx>(\n-    mir: &'a Mir<'tcx>,\n+fn precompute_borrows_out_of_scope<'tcx>(\n+    mir: &Mir<'tcx>,\n     regioncx: &Rc<RegionInferenceContext<'tcx>>,\n     borrows_out_of_scope_at_location: &mut FxHashMap<Location, Vec<BorrowIndex>>,\n     borrow_index: BorrowIndex,"}]}