{"sha": "ae09c5e36e3f6da1d20a9764e87ff2a18b3a2985", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMDljNWUzNmUzZjZkYTFkMjBhOTc2NGU4N2ZmMmExOGIzYTI5ODU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-24T11:26:54Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-24T11:26:54Z"}, "message": "Moved the four impls of `BitDenotation` to their own module, `mod impls`.", "tree": {"sha": "ffd2e0fba2bb7eda787a8671c00147631fda7511", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffd2e0fba2bb7eda787a8671c00147631fda7511"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae09c5e36e3f6da1d20a9764e87ff2a18b3a2985", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae09c5e36e3f6da1d20a9764e87ff2a18b3a2985", "html_url": "https://github.com/rust-lang/rust/commit/ae09c5e36e3f6da1d20a9764e87ff2a18b3a2985", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae09c5e36e3f6da1d20a9764e87ff2a18b3a2985/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ede29581d2eb856dfae5c37deee396235f3cf6a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ede29581d2eb856dfae5c37deee396235f3cf6a0", "html_url": "https://github.com/rust-lang/rust/commit/ede29581d2eb856dfae5c37deee396235f3cf6a0"}], "stats": {"total": 1157, "additions": 588, "deletions": 569}, "files": [{"sha": "c9a23e3f288b5ab9f7dc623ff3d462b23b8f2670", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "added", "additions": 584, "deletions": 0, "changes": 584, "blob_url": "https://github.com/rust-lang/rust/blob/ae09c5e36e3f6da1d20a9764e87ff2a18b3a2985/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae09c5e36e3f6da1d20a9764e87ff2a18b3a2985/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=ae09c5e36e3f6da1d20a9764e87ff2a18b3a2985", "patch": "@@ -0,0 +1,584 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::TyCtxt;\n+use rustc::mir::repr::{self, Mir};\n+\n+use super::super::gather_moves::{Location};\n+use super::super::gather_moves::{MoveData, MoveOut, MoveOutIndex, MovePath, MovePathIndex};\n+use super::super::DropFlagState;\n+use super::super::drop_flag_effects_for_function_entry;\n+use super::super::drop_flag_effects_for_location;\n+use super::super::on_all_children_bits;\n+\n+use super::{BitDenotation, BlockSets, DataflowOperator};\n+\n+use bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n+use bitslice::{BitwiseOperator};\n+use indexed_set::{Idx, IdxSet};\n+\n+use std::marker::PhantomData;\n+\n+// Dataflow analyses are built upon some interpretation of the\n+// bitvectors attached to each basic block, represented via a\n+// zero-sized structure.\n+//\n+// Note on PhantomData: Each interpretation will need to instantiate\n+// the `Bit` and `Ctxt` associated types, and in this case, those\n+// associated types need an associated lifetime `'tcx`. The\n+// interpretive structures are zero-sized, so they all need to carry a\n+// `PhantomData` representing how the structures relate to the `'tcx`\n+// lifetime.\n+//\n+// But, since all of the uses of `'tcx` are solely via instances of\n+// `Ctxt` that are passed into the `BitDenotation` methods, we can\n+// consistently use a `PhantomData` that is just a function over a\n+// `&Ctxt` (== `&MoveData<'tcx>).\n+\n+/// `MaybeInitializedLvals` tracks all l-values that might be\n+/// initialized upon reaching a particular point in the control flow\n+/// for a function.\n+///\n+/// For example, in code like the following, we have corresponding\n+/// dataflow information shown in the right-hand comments.\n+///\n+/// ```rust\n+/// struct S;\n+/// fn foo(pred: bool) {                       // maybe-init:\n+///                                            // {}\n+///     let a = S; let b = S; let c; let d;    // {a, b}\n+///\n+///     if pred {\n+///         drop(a);                           // {   b}\n+///         b = S;                             // {   b}\n+///\n+///     } else {\n+///         drop(b);                           // {a}\n+///         d = S;                             // {a,       d}\n+///\n+///     }                                      // {a, b,    d}\n+///\n+///     c = S;                                 // {a, b, c, d}\n+/// }\n+/// ```\n+///\n+/// To determine whether an l-value *must* be initialized at a\n+/// particular control-flow point, one can take the set-difference\n+/// between this data and the data from `MaybeUninitializedLvals` at the\n+/// corresponding control-flow point.\n+///\n+/// Similarly, at a given `drop` statement, the set-intersection\n+/// between this data and `MaybeUninitializedLvals` yields the set of\n+/// l-values that would require a dynamic drop-flag at that statement.\n+#[derive(Debug, Default)]\n+pub struct MaybeInitializedLvals<'a, 'tcx: 'a> {\n+    // See \"Note on PhantomData\" above.\n+    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n+}\n+\n+/// `MaybeUninitializedLvals` tracks all l-values that might be\n+/// uninitialized upon reaching a particular point in the control flow\n+/// for a function.\n+///\n+/// For example, in code like the following, we have corresponding\n+/// dataflow information shown in the right-hand comments.\n+///\n+/// ```rust\n+/// struct S;\n+/// fn foo(pred: bool) {                       // maybe-uninit:\n+///                                            // {a, b, c, d}\n+///     let a = S; let b = S; let c; let d;    // {      c, d}\n+///\n+///     if pred {\n+///         drop(a);                           // {a,    c, d}\n+///         b = S;                             // {a,    c, d}\n+///\n+///     } else {\n+///         drop(b);                           // {   b, c, d}\n+///         d = S;                             // {   b, c   }\n+///\n+///     }                                      // {a, b, c, d}\n+///\n+///     c = S;                                 // {a, b,    d}\n+/// }\n+/// ```\n+///\n+/// To determine whether an l-value *must* be uninitialized at a\n+/// particular control-flow point, one can take the set-difference\n+/// between this data and the data from `MaybeInitializedLvals` at the\n+/// corresponding control-flow point.\n+///\n+/// Similarly, at a given `drop` statement, the set-intersection\n+/// between this data and `MaybeInitializedLvals` yields the set of\n+/// l-values that would require a dynamic drop-flag at that statement.\n+#[derive(Debug, Default)]\n+pub struct MaybeUninitializedLvals<'a, 'tcx: 'a> {\n+    // See \"Note on PhantomData\" above.\n+    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n+}\n+\n+/// `DefinitelyInitializedLvals` tracks all l-values that are definitely\n+/// initialized upon reaching a particular point in the control flow\n+/// for a function.\n+///\n+/// FIXME: Note that once flow-analysis is complete, this should be\n+/// the set-complement of MaybeUninitializedLvals; thus we can get rid\n+/// of one or the other of these two. I'm inclined to get rid of\n+/// MaybeUninitializedLvals, simply because the sets will tend to be\n+/// smaller in this analysis and thus easier for humans to process\n+/// when debugging.\n+///\n+/// For example, in code like the following, we have corresponding\n+/// dataflow information shown in the right-hand comments.\n+///\n+/// ```rust\n+/// struct S;\n+/// fn foo(pred: bool) {                       // definite-init:\n+///                                            // {          }\n+///     let a = S; let b = S; let c; let d;    // {a, b      }\n+///\n+///     if pred {\n+///         drop(a);                           // {   b,     }\n+///         b = S;                             // {   b,     }\n+///\n+///     } else {\n+///         drop(b);                           // {a,        }\n+///         d = S;                             // {a,       d}\n+///\n+///     }                                      // {          }\n+///\n+///     c = S;                                 // {       c  }\n+/// }\n+/// ```\n+///\n+/// To determine whether an l-value *may* be uninitialized at a\n+/// particular control-flow point, one can take the set-complement\n+/// of this data.\n+///\n+/// Similarly, at a given `drop` statement, the set-difference between\n+/// this data and `MaybeInitializedLvals` yields the set of l-values\n+/// that would require a dynamic drop-flag at that statement.\n+#[derive(Debug, Default)]\n+pub struct DefinitelyInitializedLvals<'a, 'tcx: 'a> {\n+    // See \"Note on PhantomData\" above.\n+    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n+}\n+\n+/// `MovingOutStatements` tracks the statements that perform moves out\n+/// of particular l-values. More precisely, it tracks whether the\n+/// *effect* of such moves (namely, the uninitialization of the\n+/// l-value in question) can reach some point in the control-flow of\n+/// the function, or if that effect is \"killed\" by some intervening\n+/// operation reinitializing that l-value.\n+///\n+/// The resulting dataflow is a more enriched version of\n+/// `MaybeUninitializedLvals`. Both structures on their own only tell\n+/// you if an l-value *might* be uninitialized at a given point in the\n+/// control flow. But `MovingOutStatements` also includes the added\n+/// data of *which* particular statement causing the deinitialization\n+/// that the borrow checker's error meessage may need to report.\n+#[derive(Debug, Default)]\n+pub struct MovingOutStatements<'a, 'tcx: 'a> {\n+    // See \"Note on PhantomData\" above.\n+    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n+}\n+\n+impl<'a, 'tcx> MaybeInitializedLvals<'a, 'tcx> {\n+    fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n+                   state: DropFlagState)\n+    {\n+        match state {\n+            DropFlagState::Absent => sets.kill(&path),\n+            DropFlagState::Present => sets.gen(&path),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> MaybeUninitializedLvals<'a, 'tcx> {\n+    fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n+                   state: DropFlagState)\n+    {\n+        match state {\n+            DropFlagState::Absent => sets.gen(&path),\n+            DropFlagState::Present => sets.kill(&path),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> DefinitelyInitializedLvals<'a, 'tcx> {\n+    fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n+                   state: DropFlagState)\n+    {\n+        match state {\n+            DropFlagState::Absent => sets.kill(&path),\n+            DropFlagState::Present => sets.gen(&path),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n+    type Idx = MovePathIndex;\n+    type Bit = MovePath<'tcx>;\n+    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n+    fn name() -> &'static str { \"maybe_init\" }\n+    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n+        ctxt.2.move_paths.len()\n+    }\n+    fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n+        &ctxt.2.move_paths[MovePathIndex::new(idx)]\n+    }\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>)\n+    {\n+        drop_flag_effects_for_function_entry(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            |path, s| {\n+                assert!(s == DropFlagState::Present);\n+                sets.on_entry.add(&path);\n+            });\n+    }\n+\n+    fn statement_effect(&self,\n+                        ctxt: &Self::Ctxt,\n+                        sets: &mut BlockSets<MovePathIndex>,\n+                        bb: repr::BasicBlock,\n+                        idx: usize)\n+    {\n+        drop_flag_effects_for_location(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            Location { block: bb, index: idx },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn terminator_effect(&self,\n+                         ctxt: &Self::Ctxt,\n+                         sets: &mut BlockSets<MovePathIndex>,\n+                         bb: repr::BasicBlock,\n+                         statements_len: usize)\n+    {\n+        drop_flag_effects_for_location(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            Location { block: bb, index: statements_len },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             ctxt: &Self::Ctxt,\n+                             in_out: &mut IdxSet<MovePathIndex>,\n+                             _call_bb: repr::BasicBlock,\n+                             _dest_bb: repr::BasicBlock,\n+                             dest_lval: &repr::Lvalue) {\n+        // when a call returns successfully, that means we need to set\n+        // the bits for that dest_lval to 1 (initialized).\n+        let move_data = &ctxt.2;\n+        let move_path_index = move_data.rev_lookup.find(dest_lval);\n+        on_all_children_bits(ctxt.0, ctxt.1, &ctxt.2,\n+                             move_path_index,\n+                             |mpi| { in_out.add(&mpi); });\n+    }\n+}\n+\n+impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n+    type Idx = MovePathIndex;\n+    type Bit = MovePath<'tcx>;\n+    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n+    fn name() -> &'static str { \"maybe_uninit\" }\n+    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n+        ctxt.2.move_paths.len()\n+    }\n+    fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n+        &ctxt.2.move_paths[MovePathIndex::new(idx)]\n+    }\n+\n+    // sets on_entry bits for Arg lvalues\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>) {\n+        // set all bits to 1 (uninit) before gathering counterevidence\n+        for e in sets.on_entry.words_mut() { *e = !0; }\n+\n+        drop_flag_effects_for_function_entry(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            |path, s| {\n+                assert!(s == DropFlagState::Present);\n+                sets.on_entry.remove(&path);\n+            });\n+    }\n+\n+    fn statement_effect(&self,\n+                        ctxt: &Self::Ctxt,\n+                        sets: &mut BlockSets<MovePathIndex>,\n+                        bb: repr::BasicBlock,\n+                        idx: usize)\n+    {\n+        drop_flag_effects_for_location(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            Location { block: bb, index: idx },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn terminator_effect(&self,\n+                         ctxt: &Self::Ctxt,\n+                         sets: &mut BlockSets<MovePathIndex>,\n+                         bb: repr::BasicBlock,\n+                         statements_len: usize)\n+    {\n+        drop_flag_effects_for_location(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            Location { block: bb, index: statements_len },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             ctxt: &Self::Ctxt,\n+                             in_out: &mut IdxSet<MovePathIndex>,\n+                             _call_bb: repr::BasicBlock,\n+                             _dest_bb: repr::BasicBlock,\n+                             dest_lval: &repr::Lvalue) {\n+        // when a call returns successfully, that means we need to set\n+        // the bits for that dest_lval to 1 (initialized).\n+        let move_path_index = ctxt.2.rev_lookup.find(dest_lval);\n+        on_all_children_bits(ctxt.0, ctxt.1, &ctxt.2,\n+                             move_path_index,\n+                             |mpi| { in_out.remove(&mpi); });\n+    }\n+}\n+\n+impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n+    type Idx = MovePathIndex;\n+    type Bit = MovePath<'tcx>;\n+    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n+    fn name() -> &'static str { \"definite_init\" }\n+    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n+        ctxt.2.move_paths.len()\n+    }\n+    fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n+        &ctxt.2.move_paths[MovePathIndex::new(idx)]\n+    }\n+\n+    // sets on_entry bits for Arg lvalues\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>) {\n+        for e in sets.on_entry.words_mut() { *e = 0; }\n+\n+        drop_flag_effects_for_function_entry(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            |path, s| {\n+                assert!(s == DropFlagState::Present);\n+                sets.on_entry.add(&path);\n+            });\n+    }\n+\n+    fn statement_effect(&self,\n+                        ctxt: &Self::Ctxt,\n+                        sets: &mut BlockSets<MovePathIndex>,\n+                        bb: repr::BasicBlock,\n+                        idx: usize)\n+    {\n+        drop_flag_effects_for_location(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            Location { block: bb, index: idx },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn terminator_effect(&self,\n+                         ctxt: &Self::Ctxt,\n+                         sets: &mut BlockSets<MovePathIndex>,\n+                         bb: repr::BasicBlock,\n+                         statements_len: usize)\n+    {\n+        drop_flag_effects_for_location(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            Location { block: bb, index: statements_len },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             ctxt: &Self::Ctxt,\n+                             in_out: &mut IdxSet<MovePathIndex>,\n+                             _call_bb: repr::BasicBlock,\n+                             _dest_bb: repr::BasicBlock,\n+                             dest_lval: &repr::Lvalue) {\n+        // when a call returns successfully, that means we need to set\n+        // the bits for that dest_lval to 1 (initialized).\n+        let move_path_index = ctxt.2.rev_lookup.find(dest_lval);\n+        on_all_children_bits(ctxt.0, ctxt.1, &ctxt.2,\n+                             move_path_index,\n+                             |mpi| { in_out.add(&mpi); });\n+    }\n+}\n+\n+impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n+    type Idx = MoveOutIndex;\n+    type Bit = MoveOut;\n+    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n+    fn name() -> &'static str { \"moving_out\" }\n+    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n+        ctxt.2.moves.len()\n+    }\n+    fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n+        &ctxt.2.moves[idx]\n+    }\n+    fn start_block_effect(&self,_move_data: &Self::Ctxt, _sets: &mut BlockSets<MoveOutIndex>) {\n+        // no move-statements have been executed prior to function\n+        // execution, so this method has no effect on `_sets`.\n+    }\n+    fn statement_effect(&self,\n+                        ctxt: &Self::Ctxt,\n+                        sets: &mut BlockSets<MoveOutIndex>,\n+                        bb: repr::BasicBlock,\n+                        idx: usize) {\n+        let &(tcx, mir, ref move_data) = ctxt;\n+        let stmt = &mir.basic_block_data(bb).statements[idx];\n+        let loc_map = &move_data.loc_map;\n+        let path_map = &move_data.path_map;\n+        let rev_lookup = &move_data.rev_lookup;\n+\n+        let loc = Location { block: bb, index: idx };\n+        debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n+               stmt, loc, &loc_map[loc]);\n+        for move_index in &loc_map[loc] {\n+            // Every path deinitialized by a *particular move*\n+            // has corresponding bit, \"gen'ed\" (i.e. set)\n+            // here, in dataflow vector\n+            zero_to_one(sets.gen_set.words_mut(), *move_index);\n+        }\n+        let bits_per_block = self.bits_per_block(ctxt);\n+        match stmt.kind {\n+            repr::StatementKind::Assign(ref lvalue, _) => {\n+                // assigning into this `lvalue` kills all\n+                // MoveOuts from it, and *also* all MoveOuts\n+                // for children and associated fragment sets.\n+                let move_path_index = rev_lookup.find(lvalue);\n+                on_all_children_bits(tcx,\n+                                     mir,\n+                                     move_data,\n+                                     move_path_index,\n+                                     |mpi| for moi in &path_map[mpi] {\n+                                         assert!(moi.idx() < bits_per_block);\n+                                         sets.kill_set.add(&moi);\n+                                     });\n+            }\n+        }\n+    }\n+\n+    fn terminator_effect(&self,\n+                         ctxt: &Self::Ctxt,\n+                         sets: &mut BlockSets<MoveOutIndex>,\n+                         bb: repr::BasicBlock,\n+                         statements_len: usize)\n+    {\n+        let &(_tcx, mir, ref move_data) = ctxt;\n+        let term = mir.basic_block_data(bb).terminator.as_ref().unwrap();\n+        let loc_map = &move_data.loc_map;\n+        let loc = Location { block: bb, index: statements_len };\n+        debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n+               term, loc, &loc_map[loc]);\n+        let bits_per_block = self.bits_per_block(ctxt);\n+        for move_index in &loc_map[loc] {\n+            assert!(move_index.idx() < bits_per_block);\n+            zero_to_one(sets.gen_set.words_mut(), *move_index);\n+        }\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             ctxt: &Self::Ctxt,\n+                             in_out: &mut IdxSet<MoveOutIndex>,\n+                             _call_bb: repr::BasicBlock,\n+                             _dest_bb: repr::BasicBlock,\n+                             dest_lval: &repr::Lvalue) {\n+        let move_data = &ctxt.2;\n+        let move_path_index = move_data.rev_lookup.find(dest_lval);\n+        let bits_per_block = self.bits_per_block(ctxt);\n+\n+        let path_map = &move_data.path_map;\n+        on_all_children_bits(ctxt.0,\n+                             ctxt.1,\n+                             move_data,\n+                             move_path_index,\n+                             |mpi| for moi in &path_map[mpi] {\n+                                 assert!(moi.idx() < bits_per_block);\n+                                 in_out.remove(&moi);\n+                             });\n+    }\n+}\n+\n+fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n+    let retval = bitvec.set_bit(move_index.idx());\n+    assert!(retval);\n+}\n+\n+impl<'a, 'tcx> BitwiseOperator for MovingOutStatements<'a, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // moves from both preds are in scope\n+    }\n+}\n+\n+impl<'a, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // \"maybe\" means we union effects of both preds\n+    }\n+}\n+\n+impl<'a, 'tcx> BitwiseOperator for MaybeUninitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // \"maybe\" means we union effects of both preds\n+    }\n+}\n+\n+impl<'a, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 & pred2 // \"definitely\" means we intersect effects of both preds\n+    }\n+}\n+\n+// The way that dataflow fixed point iteration works, you want to\n+// start at bottom and work your way to a fixed point. Control-flow\n+// merges will apply the `join` operator to each block entry's current\n+// state (which starts at that bottom value).\n+//\n+// This means, for propagation across the graph, that you either want\n+// to start at all-zeroes and then use Union as your merge when\n+// propagating, or you start at all-ones and then use Intersect as\n+// your merge when propagating.\n+\n+impl<'a, 'tcx> DataflowOperator for MovingOutStatements<'a, 'tcx> {\n+    #[inline]\n+    fn bottom_value() -> bool {\n+        false // bottom = no loans in scope by default\n+    }\n+}\n+\n+impl<'a, 'tcx> DataflowOperator for MaybeInitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn bottom_value() -> bool {\n+        false // bottom = uninitialized\n+    }\n+}\n+\n+impl<'a, 'tcx> DataflowOperator for MaybeUninitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn bottom_value() -> bool {\n+        false // bottom = initialized (start_block_effect counters this at outset)\n+    }\n+}\n+\n+impl<'a, 'tcx> DataflowOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn bottom_value() -> bool {\n+        true // bottom = initialized (start_block_effect counters this at outset)\n+    }\n+}"}, {"sha": "97e29fe064febd64a8f35c9fa72e6d49f70e7c87", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 4, "deletions": 569, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/ae09c5e36e3f6da1d20a9764e87ff2a18b3a2985/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae09c5e36e3f6da1d20a9764e87ff2a18b3a2985/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=ae09c5e36e3f6da1d20a9764e87ff2a18b3a2985", "patch": "@@ -13,24 +13,23 @@ use rustc::mir::repr::{self, Mir};\n \n use std::fmt::Debug;\n use std::io;\n-use std::marker::PhantomData;\n use std::mem;\n use std::path::PathBuf;\n use std::usize;\n \n use super::MirBorrowckCtxtPreDataflow;\n-use super::gather_moves::{Location, MoveData, MovePathIndex, MoveOutIndex};\n-use super::gather_moves::{MoveOut, MovePath};\n-use super::DropFlagState;\n+use super::gather_moves::{MoveData};\n \n-use bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n use bitslice::{bitwise, BitwiseOperator};\n use indexed_set::{Idx, IdxSet, OwnIdxSet};\n \n pub use self::sanity_check::sanity_check_via_rustc_peek;\n+pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n \n mod graphviz;\n mod sanity_check;\n+mod impls;\n \n pub trait Dataflow {\n     fn dataflow(&mut self);\n@@ -550,567 +549,3 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n         }\n     }\n }\n-\n-// Dataflow analyses are built upon some interpretation of the\n-// bitvectors attached to each basic block, represented via a\n-// zero-sized structure.\n-//\n-// Note on PhantomData: Each interpretation will need to instantiate\n-// the `Bit` and `Ctxt` associated types, and in this case, those\n-// associated types need an associated lifetime `'tcx`. The\n-// interpretive structures are zero-sized, so they all need to carry a\n-// `PhantomData` representing how the structures relate to the `'tcx`\n-// lifetime.\n-//\n-// But, since all of the uses of `'tcx` are solely via instances of\n-// `Ctxt` that are passed into the `BitDenotation` methods, we can\n-// consistently use a `PhantomData` that is just a function over a\n-// `&Ctxt` (== `&MoveData<'tcx>).\n-\n-/// `MaybeInitializedLvals` tracks all l-values that might be\n-/// initialized upon reaching a particular point in the control flow\n-/// for a function.\n-///\n-/// For example, in code like the following, we have corresponding\n-/// dataflow information shown in the right-hand comments.\n-///\n-/// ```rust\n-/// struct S;\n-/// fn foo(pred: bool) {                       // maybe-init:\n-///                                            // {}\n-///     let a = S; let b = S; let c; let d;    // {a, b}\n-///\n-///     if pred {\n-///         drop(a);                           // {   b}\n-///         b = S;                             // {   b}\n-///\n-///     } else {\n-///         drop(b);                           // {a}\n-///         d = S;                             // {a,       d}\n-///\n-///     }                                      // {a, b,    d}\n-///\n-///     c = S;                                 // {a, b, c, d}\n-/// }\n-/// ```\n-///\n-/// To determine whether an l-value *must* be initialized at a\n-/// particular control-flow point, one can take the set-difference\n-/// between this data and the data from `MaybeUninitializedLvals` at the\n-/// corresponding control-flow point.\n-///\n-/// Similarly, at a given `drop` statement, the set-intersection\n-/// between this data and `MaybeUninitializedLvals` yields the set of\n-/// l-values that would require a dynamic drop-flag at that statement.\n-#[derive(Debug, Default)]\n-pub struct MaybeInitializedLvals<'a, 'tcx: 'a> {\n-    // See \"Note on PhantomData\" above.\n-    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n-}\n-\n-/// `MaybeUninitializedLvals` tracks all l-values that might be\n-/// uninitialized upon reaching a particular point in the control flow\n-/// for a function.\n-///\n-/// For example, in code like the following, we have corresponding\n-/// dataflow information shown in the right-hand comments.\n-///\n-/// ```rust\n-/// struct S;\n-/// fn foo(pred: bool) {                       // maybe-uninit:\n-///                                            // {a, b, c, d}\n-///     let a = S; let b = S; let c; let d;    // {      c, d}\n-///\n-///     if pred {\n-///         drop(a);                           // {a,    c, d}\n-///         b = S;                             // {a,    c, d}\n-///\n-///     } else {\n-///         drop(b);                           // {   b, c, d}\n-///         d = S;                             // {   b, c   }\n-///\n-///     }                                      // {a, b, c, d}\n-///\n-///     c = S;                                 // {a, b,    d}\n-/// }\n-/// ```\n-///\n-/// To determine whether an l-value *must* be uninitialized at a\n-/// particular control-flow point, one can take the set-difference\n-/// between this data and the data from `MaybeInitializedLvals` at the\n-/// corresponding control-flow point.\n-///\n-/// Similarly, at a given `drop` statement, the set-intersection\n-/// between this data and `MaybeInitializedLvals` yields the set of\n-/// l-values that would require a dynamic drop-flag at that statement.\n-#[derive(Debug, Default)]\n-pub struct MaybeUninitializedLvals<'a, 'tcx: 'a> {\n-    // See \"Note on PhantomData\" above.\n-    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n-}\n-\n-/// `DefinitelyInitializedLvals` tracks all l-values that are definitely\n-/// initialized upon reaching a particular point in the control flow\n-/// for a function.\n-///\n-/// FIXME: Note that once flow-analysis is complete, this should be\n-/// the set-complement of MaybeUninitializedLvals; thus we can get rid\n-/// of one or the other of these two. I'm inclined to get rid of\n-/// MaybeUninitializedLvals, simply because the sets will tend to be\n-/// smaller in this analysis and thus easier for humans to process\n-/// when debugging.\n-///\n-/// For example, in code like the following, we have corresponding\n-/// dataflow information shown in the right-hand comments.\n-///\n-/// ```rust\n-/// struct S;\n-/// fn foo(pred: bool) {                       // definite-init:\n-///                                            // {          }\n-///     let a = S; let b = S; let c; let d;    // {a, b      }\n-///\n-///     if pred {\n-///         drop(a);                           // {   b,     }\n-///         b = S;                             // {   b,     }\n-///\n-///     } else {\n-///         drop(b);                           // {a,        }\n-///         d = S;                             // {a,       d}\n-///\n-///     }                                      // {          }\n-///\n-///     c = S;                                 // {       c  }\n-/// }\n-/// ```\n-///\n-/// To determine whether an l-value *may* be uninitialized at a\n-/// particular control-flow point, one can take the set-complement\n-/// of this data.\n-///\n-/// Similarly, at a given `drop` statement, the set-difference between\n-/// this data and `MaybeInitializedLvals` yields the set of l-values\n-/// that would require a dynamic drop-flag at that statement.\n-#[derive(Debug, Default)]\n-pub struct DefinitelyInitializedLvals<'a, 'tcx: 'a> {\n-    // See \"Note on PhantomData\" above.\n-    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n-}\n-\n-/// `MovingOutStatements` tracks the statements that perform moves out\n-/// of particular l-values. More precisely, it tracks whether the\n-/// *effect* of such moves (namely, the uninitialization of the\n-/// l-value in question) can reach some point in the control-flow of\n-/// the function, or if that effect is \"killed\" by some intervening\n-/// operation reinitializing that l-value.\n-///\n-/// The resulting dataflow is a more enriched version of\n-/// `MaybeUninitializedLvals`. Both structures on their own only tell\n-/// you if an l-value *might* be uninitialized at a given point in the\n-/// control flow. But `MovingOutStatements` also includes the added\n-/// data of *which* particular statement causing the deinitialization\n-/// that the borrow checker's error meessage may need to report.\n-#[derive(Debug, Default)]\n-pub struct MovingOutStatements<'a, 'tcx: 'a> {\n-    // See \"Note on PhantomData\" above.\n-    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n-}\n-\n-impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n-    type Idx = MoveOutIndex;\n-    type Bit = MoveOut;\n-    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n-    fn name() -> &'static str { \"moving_out\" }\n-    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n-        ctxt.2.moves.len()\n-    }\n-    fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n-        &ctxt.2.moves[idx]\n-    }\n-    fn start_block_effect(&self,_move_data: &Self::Ctxt, _sets: &mut BlockSets<MoveOutIndex>) {\n-        // no move-statements have been executed prior to function\n-        // execution, so this method has no effect on `_sets`.\n-    }\n-    fn statement_effect(&self,\n-                        ctxt: &Self::Ctxt,\n-                        sets: &mut BlockSets<MoveOutIndex>,\n-                        bb: repr::BasicBlock,\n-                        idx: usize) {\n-        let &(tcx, mir, ref move_data) = ctxt;\n-        let stmt = &mir.basic_block_data(bb).statements[idx];\n-        let loc_map = &move_data.loc_map;\n-        let path_map = &move_data.path_map;\n-        let rev_lookup = &move_data.rev_lookup;\n-\n-        let loc = Location { block: bb, index: idx };\n-        debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n-               stmt, loc, &loc_map[loc]);\n-        for move_index in &loc_map[loc] {\n-            // Every path deinitialized by a *particular move*\n-            // has corresponding bit, \"gen'ed\" (i.e. set)\n-            // here, in dataflow vector\n-            zero_to_one(sets.gen_set.words_mut(), *move_index);\n-        }\n-        let bits_per_block = self.bits_per_block(ctxt);\n-        match stmt.kind {\n-            repr::StatementKind::Assign(ref lvalue, _) => {\n-                // assigning into this `lvalue` kills all\n-                // MoveOuts from it, and *also* all MoveOuts\n-                // for children and associated fragment sets.\n-                let move_path_index = rev_lookup.find(lvalue);\n-                super::on_all_children_bits(tcx,\n-                                            mir,\n-                                            move_data,\n-                                            move_path_index,\n-                                            |mpi| for moi in &path_map[mpi] {\n-                                                assert!(moi.idx() < bits_per_block);\n-                                                sets.kill_set.add(&moi);\n-                                            });\n-            }\n-        }\n-    }\n-\n-    fn terminator_effect(&self,\n-                         ctxt: &Self::Ctxt,\n-                         sets: &mut BlockSets<MoveOutIndex>,\n-                         bb: repr::BasicBlock,\n-                         statements_len: usize)\n-    {\n-        let &(_tcx, mir, ref move_data) = ctxt;\n-        let term = mir.basic_block_data(bb).terminator.as_ref().unwrap();\n-        let loc_map = &move_data.loc_map;\n-        let loc = Location { block: bb, index: statements_len };\n-        debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n-               term, loc, &loc_map[loc]);\n-        let bits_per_block = self.bits_per_block(ctxt);\n-        for move_index in &loc_map[loc] {\n-            assert!(move_index.idx() < bits_per_block);\n-            zero_to_one(sets.gen_set.words_mut(), *move_index);\n-        }\n-    }\n-\n-    fn propagate_call_return(&self,\n-                             ctxt: &Self::Ctxt,\n-                             in_out: &mut IdxSet<MoveOutIndex>,\n-                             _call_bb: repr::BasicBlock,\n-                             _dest_bb: repr::BasicBlock,\n-                             dest_lval: &repr::Lvalue) {\n-        let move_data = &ctxt.2;\n-        let move_path_index = move_data.rev_lookup.find(dest_lval);\n-        let bits_per_block = self.bits_per_block(ctxt);\n-\n-        let path_map = &move_data.path_map;\n-        super::on_all_children_bits(ctxt.0,\n-                                    ctxt.1,\n-                                    move_data,\n-                                    move_path_index,\n-                                    |mpi| for moi in &path_map[mpi] {\n-                                        assert!(moi.idx() < bits_per_block);\n-                                        in_out.remove(&moi);\n-                                    });\n-    }\n-}\n-\n-impl<'a, 'tcx> MaybeInitializedLvals<'a, 'tcx> {\n-    fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n-                   state: super::DropFlagState)\n-    {\n-        match state {\n-            DropFlagState::Absent => sets.kill(&path),\n-            DropFlagState::Present => sets.gen(&path),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> MaybeUninitializedLvals<'a, 'tcx> {\n-    fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n-                   state: super::DropFlagState)\n-    {\n-        match state {\n-            DropFlagState::Absent => sets.gen(&path),\n-            DropFlagState::Present => sets.kill(&path),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> DefinitelyInitializedLvals<'a, 'tcx> {\n-    fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n-                   state: super::DropFlagState)\n-    {\n-        match state {\n-            DropFlagState::Absent => sets.kill(&path),\n-            DropFlagState::Present => sets.gen(&path),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n-    type Idx = MovePathIndex;\n-    type Bit = MovePath<'tcx>;\n-    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n-    fn name() -> &'static str { \"maybe_init\" }\n-    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n-        ctxt.2.move_paths.len()\n-    }\n-    fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n-        &ctxt.2.move_paths[MovePathIndex::new(idx)]\n-    }\n-    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>)\n-    {\n-        super::drop_flag_effects_for_function_entry(\n-            ctxt.0, ctxt.1, &ctxt.2,\n-            |path, s| {\n-                assert!(s == DropFlagState::Present);\n-                sets.on_entry.add(&path);\n-            });\n-    }\n-\n-    fn statement_effect(&self,\n-                        ctxt: &Self::Ctxt,\n-                        sets: &mut BlockSets<MovePathIndex>,\n-                        bb: repr::BasicBlock,\n-                        idx: usize)\n-    {\n-        super::drop_flag_effects_for_location(\n-            ctxt.0, ctxt.1, &ctxt.2,\n-            Location { block: bb, index: idx },\n-            |path, s| Self::update_bits(sets, path, s)\n-        )\n-    }\n-\n-    fn terminator_effect(&self,\n-                         ctxt: &Self::Ctxt,\n-                         sets: &mut BlockSets<MovePathIndex>,\n-                         bb: repr::BasicBlock,\n-                         statements_len: usize)\n-    {\n-        super::drop_flag_effects_for_location(\n-            ctxt.0, ctxt.1, &ctxt.2,\n-            Location { block: bb, index: statements_len },\n-            |path, s| Self::update_bits(sets, path, s)\n-        )\n-    }\n-\n-    fn propagate_call_return(&self,\n-                             ctxt: &Self::Ctxt,\n-                             in_out: &mut IdxSet<MovePathIndex>,\n-                             _call_bb: repr::BasicBlock,\n-                             _dest_bb: repr::BasicBlock,\n-                             dest_lval: &repr::Lvalue) {\n-        // when a call returns successfully, that means we need to set\n-        // the bits for that dest_lval to 1 (initialized).\n-        let move_data = &ctxt.2;\n-        let move_path_index = move_data.rev_lookup.find(dest_lval);\n-        super::on_all_children_bits(\n-            ctxt.0, ctxt.1, &ctxt.2,\n-            move_path_index,\n-            |mpi| { in_out.add(&mpi); }\n-        );\n-    }\n-}\n-\n-impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n-    type Idx = MovePathIndex;\n-    type Bit = MovePath<'tcx>;\n-    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n-    fn name() -> &'static str { \"maybe_uninit\" }\n-    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n-        ctxt.2.move_paths.len()\n-    }\n-    fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n-        &ctxt.2.move_paths[MovePathIndex::new(idx)]\n-    }\n-\n-    // sets on_entry bits for Arg lvalues\n-    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>) {\n-        // set all bits to 1 (uninit) before gathering counterevidence\n-        for e in sets.on_entry.words_mut() { *e = !0; }\n-\n-        super::drop_flag_effects_for_function_entry(\n-            ctxt.0, ctxt.1, &ctxt.2,\n-            |path, s| {\n-                assert!(s == DropFlagState::Present);\n-                sets.on_entry.remove(&path);\n-            });\n-    }\n-\n-    fn statement_effect(&self,\n-                        ctxt: &Self::Ctxt,\n-                        sets: &mut BlockSets<MovePathIndex>,\n-                        bb: repr::BasicBlock,\n-                        idx: usize)\n-    {\n-        super::drop_flag_effects_for_location(\n-            ctxt.0, ctxt.1, &ctxt.2,\n-            Location { block: bb, index: idx },\n-            |path, s| Self::update_bits(sets, path, s)\n-        )\n-    }\n-\n-    fn terminator_effect(&self,\n-                         ctxt: &Self::Ctxt,\n-                         sets: &mut BlockSets<MovePathIndex>,\n-                         bb: repr::BasicBlock,\n-                         statements_len: usize)\n-    {\n-        super::drop_flag_effects_for_location(\n-            ctxt.0, ctxt.1, &ctxt.2,\n-            Location { block: bb, index: statements_len },\n-            |path, s| Self::update_bits(sets, path, s)\n-        )\n-    }\n-\n-    fn propagate_call_return(&self,\n-                             ctxt: &Self::Ctxt,\n-                             in_out: &mut IdxSet<MovePathIndex>,\n-                             _call_bb: repr::BasicBlock,\n-                             _dest_bb: repr::BasicBlock,\n-                             dest_lval: &repr::Lvalue) {\n-        // when a call returns successfully, that means we need to set\n-        // the bits for that dest_lval to 1 (initialized).\n-        let move_path_index = ctxt.2.rev_lookup.find(dest_lval);\n-        super::on_all_children_bits(\n-            ctxt.0, ctxt.1, &ctxt.2,\n-            move_path_index,\n-            |mpi| { in_out.remove(&mpi); }\n-        );\n-    }\n-}\n-\n-impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n-    type Idx = MovePathIndex;\n-    type Bit = MovePath<'tcx>;\n-    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n-    fn name() -> &'static str { \"definite_init\" }\n-    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n-        ctxt.2.move_paths.len()\n-    }\n-    fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n-        &ctxt.2.move_paths[MovePathIndex::new(idx)]\n-    }\n-\n-    // sets on_entry bits for Arg lvalues\n-    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>) {\n-        for e in sets.on_entry.words_mut() { *e = 0; }\n-\n-        super::drop_flag_effects_for_function_entry(\n-            ctxt.0, ctxt.1, &ctxt.2,\n-            |path, s| {\n-                assert!(s == DropFlagState::Present);\n-                sets.on_entry.add(&path);\n-            });\n-    }\n-\n-    fn statement_effect(&self,\n-                        ctxt: &Self::Ctxt,\n-                        sets: &mut BlockSets<MovePathIndex>,\n-                        bb: repr::BasicBlock,\n-                        idx: usize)\n-    {\n-        super::drop_flag_effects_for_location(\n-            ctxt.0, ctxt.1, &ctxt.2,\n-            Location { block: bb, index: idx },\n-            |path, s| Self::update_bits(sets, path, s)\n-        )\n-    }\n-\n-    fn terminator_effect(&self,\n-                         ctxt: &Self::Ctxt,\n-                         sets: &mut BlockSets<MovePathIndex>,\n-                         bb: repr::BasicBlock,\n-                         statements_len: usize)\n-    {\n-        super::drop_flag_effects_for_location(\n-            ctxt.0, ctxt.1, &ctxt.2,\n-            Location { block: bb, index: statements_len },\n-            |path, s| Self::update_bits(sets, path, s)\n-        )\n-    }\n-\n-    fn propagate_call_return(&self,\n-                             ctxt: &Self::Ctxt,\n-                             in_out: &mut IdxSet<MovePathIndex>,\n-                             _call_bb: repr::BasicBlock,\n-                             _dest_bb: repr::BasicBlock,\n-                             dest_lval: &repr::Lvalue) {\n-        // when a call returns successfully, that means we need to set\n-        // the bits for that dest_lval to 1 (initialized).\n-        let move_path_index = ctxt.2.rev_lookup.find(dest_lval);\n-        super::on_all_children_bits(\n-            ctxt.0, ctxt.1, &ctxt.2,\n-            move_path_index,\n-            |mpi| { in_out.add(&mpi); }\n-        );\n-    }\n-}\n-\n-fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n-    let retval = bitvec.set_bit(move_index.idx());\n-    assert!(retval);\n-}\n-\n-impl<'a, 'tcx> BitwiseOperator for MovingOutStatements<'a, 'tcx> {\n-    #[inline]\n-    fn join(&self, pred1: usize, pred2: usize) -> usize {\n-        pred1 | pred2 // moves from both preds are in scope\n-    }\n-}\n-\n-impl<'a, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'tcx> {\n-    #[inline]\n-    fn join(&self, pred1: usize, pred2: usize) -> usize {\n-        pred1 | pred2 // \"maybe\" means we union effects of both preds\n-    }\n-}\n-\n-impl<'a, 'tcx> BitwiseOperator for MaybeUninitializedLvals<'a, 'tcx> {\n-    #[inline]\n-    fn join(&self, pred1: usize, pred2: usize) -> usize {\n-        pred1 | pred2 // \"maybe\" means we union effects of both preds\n-    }\n-}\n-\n-impl<'a, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n-    #[inline]\n-    fn join(&self, pred1: usize, pred2: usize) -> usize {\n-        pred1 & pred2 // \"definitely\" means we intersect effects of both preds\n-    }\n-}\n-\n-// The way that dataflow fixed point iteration works, you want to\n-// start at bottom and work your way to a fixed point. Control-flow\n-// merges will apply the `join` operator to each block entry's current\n-// state (which starts at that bottom value).\n-//\n-// This means, for propagation across the graph, that you either want\n-// to start at all-zeroes and then use Union as your merge when\n-// propagating, or you start at all-ones and then use Intersect as\n-// your merge when propagating.\n-\n-impl<'a, 'tcx> DataflowOperator for MovingOutStatements<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = no loans in scope by default\n-    }\n-}\n-\n-impl<'a, 'tcx> DataflowOperator for MaybeInitializedLvals<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = uninitialized\n-    }\n-}\n-\n-impl<'a, 'tcx> DataflowOperator for MaybeUninitializedLvals<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = initialized (start_block_effect counters this at outset)\n-    }\n-}\n-\n-impl<'a, 'tcx> DataflowOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        true // bottom = initialized\n-    }\n-}\n-"}]}