{"sha": "88d8baa76b0c03f6aceeb1f92120af664047ac02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ZDhiYWE3NmIwYzAzZjZhY2VlYjFmOTIxMjBhZjY2NDA0N2FjMDI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-16T05:48:35Z"}, "committer": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-08-16T23:37:09Z"}, "message": "std::rt: Fix a race in UvRemoteCallback's dtor that misses callbacks\n\nFull description in comments.", "tree": {"sha": "cae4a61500c6a1fd54f857325cc11aec7747586f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cae4a61500c6a1fd54f857325cc11aec7747586f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88d8baa76b0c03f6aceeb1f92120af664047ac02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88d8baa76b0c03f6aceeb1f92120af664047ac02", "html_url": "https://github.com/rust-lang/rust/commit/88d8baa76b0c03f6aceeb1f92120af664047ac02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88d8baa76b0c03f6aceeb1f92120af664047ac02/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd382ee6434e995153302135816685cc9cc80441", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd382ee6434e995153302135816685cc9cc80441", "html_url": "https://github.com/rust-lang/rust/commit/bd382ee6434e995153302135816685cc9cc80441"}], "stats": {"total": 81, "additions": 74, "deletions": 7}, "files": [{"sha": "b07591183b740db129eda44bc43fc8ee0e666dfa", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/88d8baa76b0c03f6aceeb1f92120af664047ac02/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d8baa76b0c03f6aceeb1f92120af664047ac02/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=88d8baa76b0c03f6aceeb1f92120af664047ac02", "patch": "@@ -440,6 +440,7 @@ impl Scheduler {\n //                return Some(this);\n             }\n             Some(Shutdown) => {\n+                rtdebug!(\"shutting down\");\n //                this.event_loop.callback(Scheduler::run_sched_once);\n                 if this.sleepy {\n                     // There may be an outstanding handle on the\n@@ -1166,6 +1167,51 @@ mod test {\n         }\n     }\n \n+    // A regression test that the final message is always handled.\n+    // Used to deadlock because Shutdown was never recvd.\n+    #[test]\n+    fn no_missed_messages() {\n+        use rt::work_queue::WorkQueue;\n+        use rt::sleeper_list::SleeperList;\n+        use rt::stack::StackPool;\n+        use rt::uv::uvio::UvEventLoop;\n+        use rt::sched::{Shutdown, TaskFromFriend};\n+        use util;\n+\n+        do run_in_bare_thread {\n+            do stress_factor().times {\n+                let sleepers = SleeperList::new();\n+                let queue = WorkQueue::new();\n+                let queues = ~[queue.clone()];\n+\n+                let mut sched = ~Scheduler::new(\n+                    ~UvEventLoop::new(),\n+                    queue,\n+                    queues.clone(),\n+                    sleepers.clone());\n+\n+                let mut handle = sched.make_handle();\n+\n+                let sched = Cell::new(sched);\n+\n+                let thread = do Thread::start {\n+                    let mut sched = sched.take();\n+                    let bootstrap_task = ~Task::new_root(&mut sched.stack_pool, None, ||());\n+                    sched.bootstrap(bootstrap_task);\n+                };\n+\n+                let mut stack_pool = StackPool::new();\n+                let task = ~Task::new_root(&mut stack_pool, None, ||());\n+                handle.send(TaskFromFriend(task));\n+\n+                handle.send(Shutdown);\n+                util::ignore(handle);\n+\n+                thread.join();\n+            }\n+        }\n+    }\n+\n     #[test]\n     fn multithreading() {\n         use rt::comm::*;"}, {"sha": "1ad295641a74d124388cab368da82c45d4118970", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/88d8baa76b0c03f6aceeb1f92120af664047ac02/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d8baa76b0c03f6aceeb1f92120af664047ac02/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=88d8baa76b0c03f6aceeb1f92120af664047ac02", "patch": "@@ -162,14 +162,32 @@ impl UvRemoteCallback {\n         let exit_flag_clone = exit_flag.clone();\n         let async = do AsyncWatcher::new(loop_) |watcher, status| {\n             assert!(status.is_none());\n+\n+            // The synchronization logic here is subtle. To review, the uv async handle\n+            // type promises that, after it is triggered the remote callback is definitely\n+            // called at least once. UvRemoteCallback needs to maintain those semantics\n+            // while also shutting down cleanly from the dtor. In our case that means that,\n+            // when the UvRemoteCallback dtor calls `async.send()`, here `f` is always called\n+            // later.\n+\n+            // In the dtor both the exit flag is set and the async callback fired under a lock.\n+            // Here, before calling `f`, we take the lock and check the flag. Because we are\n+            // checking the flag before calling `f`, and the flag is set under the same lock\n+            // as the send, then if the flag is set then we're guaranteed to call `f` after\n+            // the final send.\n+\n+            // If the check was done after `f()` then there would be a period between that call\n+            // and the check where the dtor could be called in the other thread, missing the\n+            // final callback while still destroying the handle.\n+\n+            let should_exit = unsafe { exit_flag_clone.with_imm(|&should_exit| should_exit) };\n+\n             f();\n-            unsafe {\n-                do exit_flag_clone.with_imm |&should_exit| {\n-                    if should_exit {\n-                        watcher.close(||());\n-                    }\n-                }\n+\n+            if should_exit {\n+                watcher.close(||());\n             }\n+\n         };\n         UvRemoteCallback {\n             async: async,\n@@ -218,7 +236,10 @@ mod test_remote {\n                 let tube_clone = tube_clone.clone();\n                 let tube_clone_cell = Cell::new(tube_clone);\n                 let remote = do sched.event_loop.remote_callback {\n-                    tube_clone_cell.take().send(1);\n+                    // This could be called multiple times\n+                    if !tube_clone_cell.is_empty() {\n+                        tube_clone_cell.take().send(1);\n+                    }\n                 };\n                 remote_cell.put_back(remote);\n             }"}]}