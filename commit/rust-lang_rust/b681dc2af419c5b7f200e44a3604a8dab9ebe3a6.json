{"sha": "b681dc2af419c5b7f200e44a3604a8dab9ebe3a6", "node_id": "C_kwDOAAsO6NoAKGI2ODFkYzJhZjQxOWM1YjdmMjAwZTQ0YTM2MDRhOGRhYjllYmUzYTY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-09T12:38:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-09T12:38:31Z"}, "message": "Rollup merge of #92573 - petrochenkov:ltrattr3, r=Aaron1011\n\nexpand: Refactor InvocationCollector visitor for better code reuse\n\nThe refactoring part of https://github.com/rust-lang/rust/pull/92473.\n\nInvocation collector visitor logic now lives in two main functions:\n- `fn flat_map_node`, corresponding to \"one to many\" expansions\n- `fn visit_node`, corresponding to \"one to one\" expansions\n\nAll specific mut visitor methods now use one of these functions.\n\nThe new `InvocationCollectorNode` trait implemented for all `AstFragment` nodes provides the necessary small pieces of functionality required to implement the `(flat_map,visit)_node` functions.\nr? `@Aaron1011`", "tree": {"sha": "1787805d723e4f60c0a3b7dd69dc4424219b0680", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1787805d723e4f60c0a3b7dd69dc4424219b0680"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh2tdHCRBK7hj4Ov3rIwAALTEIAGnPknQVzzDpgzebtJTN6ZPO\nnwlz6SaxFEZlzg9YtBD6AQObTItfBcWNkkTmftEoBRlXjnUuPNQP4sv9ZGGLJFcI\nhvdqM7/EVl3+wokP5MDLvLszMn5hCM9MoLLTi049re5fnjD4qdUKEFqmnQc7JYKE\n4X0fyDo73zXp8ldI3KlHobKllPDk8kkEDi91fW3+LkTvlVhhkHWRnYJvY/37M9pb\ndmMclo11RuORv1UFAWqhrov8ZATL7vGftwFsBDfN/+saV2ZVDyKvK3wC9FZiCb2t\nbOr5Yfmf18IOjZhYejjfLnqbVsfdvlq3fUXHRt0r5kha7n/oAijPv1HtdXofzy8=\n=ZE4B\n-----END PGP SIGNATURE-----\n", "payload": "tree 1787805d723e4f60c0a3b7dd69dc4424219b0680\nparent 464a0813d122a43fdafd99a396d2d9b8482d7891\nparent 452346677084a954b78636f222788b8f072b8572\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1641731911 +0100\ncommitter GitHub <noreply@github.com> 1641731911 +0100\n\nRollup merge of #92573 - petrochenkov:ltrattr3, r=Aaron1011\n\nexpand: Refactor InvocationCollector visitor for better code reuse\n\nThe refactoring part of https://github.com/rust-lang/rust/pull/92473.\n\nInvocation collector visitor logic now lives in two main functions:\n- `fn flat_map_node`, corresponding to \"one to many\" expansions\n- `fn visit_node`, corresponding to \"one to one\" expansions\n\nAll specific mut visitor methods now use one of these functions.\n\nThe new `InvocationCollectorNode` trait implemented for all `AstFragment` nodes provides the necessary small pieces of functionality required to implement the `(flat_map,visit)_node` functions.\nr? `@Aaron1011`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6", "html_url": "https://github.com/rust-lang/rust/commit/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "464a0813d122a43fdafd99a396d2d9b8482d7891", "url": "https://api.github.com/repos/rust-lang/rust/commits/464a0813d122a43fdafd99a396d2d9b8482d7891", "html_url": "https://github.com/rust-lang/rust/commit/464a0813d122a43fdafd99a396d2d9b8482d7891"}, {"sha": "452346677084a954b78636f222788b8f072b8572", "url": "https://api.github.com/repos/rust-lang/rust/commits/452346677084a954b78636f222788b8f072b8572", "html_url": "https://github.com/rust-lang/rust/commit/452346677084a954b78636f222788b8f072b8572"}], "stats": {"total": 1301, "additions": 761, "deletions": 540}, "files": [{"sha": "9a24158ba35d9e76a8c0e700cfb914737eb440eb", "filename": "compiler/rustc_ast/src/ast_like.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs?ref=b681dc2af419c5b7f200e44a3604a8dab9ebe3a6", "patch": "@@ -6,12 +6,13 @@ use super::{AssocItem, Expr, ForeignItem, Item, Local, MacCallStmt};\n use super::{AttrItem, AttrKind, Block, Pat, Path, Ty, Visibility};\n use super::{AttrVec, Attribute, Stmt, StmtKind};\n \n-use std::fmt::Debug;\n+use std::fmt;\n+use std::marker::PhantomData;\n \n /// An `AstLike` represents an AST node (or some wrapper around\n /// and AST node) which stores some combination of attributes\n /// and tokens.\n-pub trait AstLike: Sized + Debug {\n+pub trait AstLike: Sized + fmt::Debug {\n     /// This is `true` if this `AstLike` might support 'custom' (proc-macro) inner\n     /// attributes. Attributes like `#![cfg]` and `#![cfg_attr]` are not\n     /// considered 'custom' attributes\n@@ -285,3 +286,37 @@ derive_has_attrs_no_tokens! {\n derive_has_tokens_no_attrs! {\n     Ty, Block, AttrItem, Pat, Path, Visibility\n }\n+\n+/// A newtype around an `AstLike` node that implements `AstLike` itself.\n+pub struct AstLikeWrapper<Wrapped, Tag> {\n+    pub wrapped: Wrapped,\n+    pub tag: PhantomData<Tag>,\n+}\n+\n+impl<Wrapped, Tag> AstLikeWrapper<Wrapped, Tag> {\n+    pub fn new(wrapped: Wrapped, _tag: Tag) -> AstLikeWrapper<Wrapped, Tag> {\n+        AstLikeWrapper { wrapped, tag: Default::default() }\n+    }\n+}\n+\n+impl<Wrapped: fmt::Debug, Tag> fmt::Debug for AstLikeWrapper<Wrapped, Tag> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"AstLikeWrapper\")\n+            .field(\"wrapped\", &self.wrapped)\n+            .field(\"tag\", &self.tag)\n+            .finish()\n+    }\n+}\n+\n+impl<Wrapped: AstLike, Tag> AstLike for AstLikeWrapper<Wrapped, Tag> {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = Wrapped::SUPPORTS_CUSTOM_INNER_ATTRS;\n+    fn attrs(&self) -> &[Attribute] {\n+        self.wrapped.attrs()\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        self.wrapped.visit_attrs(f)\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        self.wrapped.tokens_mut()\n+    }\n+}"}, {"sha": "84fe9ad26720ee9ad459fe725cdebf46735833e8", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=b681dc2af419c5b7f200e44a3604a8dab9ebe3a6", "patch": "@@ -41,7 +41,7 @@ pub mod tokenstream;\n pub mod visit;\n \n pub use self::ast::*;\n-pub use self::ast_like::AstLike;\n+pub use self::ast_like::{AstLike, AstLikeWrapper};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n "}, {"sha": "e0bdeb30dc84bcfe70436b7bf9007fb4242db1e0", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=b681dc2af419c5b7f200e44a3604a8dab9ebe3a6", "patch": "@@ -238,7 +238,7 @@ macro_rules! configure {\n }\n \n impl<'a> StripUnconfigured<'a> {\n-    pub fn configure<T: AstLike>(&mut self, mut node: T) -> Option<T> {\n+    pub fn configure<T: AstLike>(&self, mut node: T) -> Option<T> {\n         self.process_cfg_attrs(&mut node);\n         if self.in_cfg(node.attrs()) {\n             self.try_configure_tokens(&mut node);\n@@ -248,7 +248,7 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    fn try_configure_tokens<T: AstLike>(&mut self, node: &mut T) {\n+    fn try_configure_tokens<T: AstLike>(&self, node: &mut T) {\n         if self.config_tokens {\n             if let Some(Some(tokens)) = node.tokens_mut() {\n                 let attr_annotated_tokens = tokens.create_token_stream();\n@@ -257,10 +257,7 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    fn configure_krate_attrs(\n-        &mut self,\n-        mut attrs: Vec<ast::Attribute>,\n-    ) -> Option<Vec<ast::Attribute>> {\n+    fn configure_krate_attrs(&self, mut attrs: Vec<ast::Attribute>) -> Option<Vec<ast::Attribute>> {\n         attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n         if self.in_cfg(&attrs) { Some(attrs) } else { None }\n     }\n@@ -269,7 +266,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// This is only used during the invocation of `derive` proc-macros,\n     /// which require that we cfg-expand their entire input.\n     /// Normal cfg-expansion operates on parsed AST nodes via the `configure` method\n-    fn configure_tokens(&mut self, stream: &AttrAnnotatedTokenStream) -> AttrAnnotatedTokenStream {\n+    fn configure_tokens(&self, stream: &AttrAnnotatedTokenStream) -> AttrAnnotatedTokenStream {\n         fn can_skip(stream: &AttrAnnotatedTokenStream) -> bool {\n             stream.0.iter().all(|(tree, _spacing)| match tree {\n                 AttrAnnotatedTokenTree::Attributes(_) => false,\n@@ -325,7 +322,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// Gives compiler warnings if any `cfg_attr` does not contain any\n     /// attributes and is in the original source code. Gives compiler errors if\n     /// the syntax of any `cfg_attr` is incorrect.\n-    fn process_cfg_attrs<T: AstLike>(&mut self, node: &mut T) {\n+    fn process_cfg_attrs<T: AstLike>(&self, node: &mut T) {\n         node.visit_attrs(|attrs| {\n             attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n         });\n@@ -338,7 +335,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// Gives a compiler warning when the `cfg_attr` contains no attributes and\n     /// is in the original source file. Gives a compiler error if the syntax of\n     /// the attribute is incorrect.\n-    fn process_cfg_attr(&mut self, attr: Attribute) -> Vec<Attribute> {\n+    fn process_cfg_attr(&self, attr: Attribute) -> Vec<Attribute> {\n         if !attr.has_name(sym::cfg_attr) {\n             return vec![attr];\n         }\n@@ -461,7 +458,7 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    pub fn configure_expr(&mut self, expr: &mut P<ast::Expr>) {\n+    pub fn configure_expr(&self, expr: &mut P<ast::Expr>) {\n         for attr in expr.attrs.iter() {\n             self.maybe_emit_expr_attr_err(attr);\n         }"}, {"sha": "07ce901fb417aa2b1c1fe47da35c4d9123c14622", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 711, "deletions": 524, "changes": 1235, "blob_url": "https://github.com/rust-lang/rust/blob/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=b681dc2af419c5b7f200e44a3604a8dab9ebe3a6", "patch": "@@ -1,6 +1,5 @@\n use crate::base::*;\n use crate::config::StripUnconfigured;\n-use crate::configure;\n use crate::hygiene::SyntaxContext;\n use crate::mbe::macro_rules::annotate_err_with_kind;\n use crate::module::{mod_dir_path, parse_external_mod, DirOwnership, ParsedExternalMod};\n@@ -12,13 +11,12 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AstLike, Block, Inline, ItemKind, MacArgs, MacCall};\n-use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n-use rustc_ast::{NodeId, PatKind, Path, StmtKind};\n+use rustc_ast::{AssocItemKind, AstLike, AstLikeWrapper, AttrStyle, ExprKind, ForeignItemKind};\n+use rustc_ast::{Inline, ItemKind, MacArgs, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n+use rustc_ast::{NodeId, PatKind, StmtKind, TyKind};\n use rustc_ast_pretty::pprust;\n use rustc_attr::is_builtin_attr;\n use rustc_data_structures::map_in_place::MapInPlace;\n-use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, PResult};\n use rustc_feature::Features;\n@@ -34,7 +32,7 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::{FileName, LocalExpnId, Span};\n \n use smallvec::SmallVec;\n-use std::ops::DerefMut;\n+use std::ops::Deref;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::{iter, mem};\n@@ -109,6 +107,10 @@ macro_rules! ast_fragments {\n                 }\n             })*\n \n+            fn make_ast<T: InvocationCollectorNode>(self) -> T::OutputTy {\n+                T::fragment_to_output(self)\n+            }\n+\n             pub fn mut_visit_with<F: MutVisitor>(&mut self, vis: &mut F) {\n                 match self {\n                     AstFragment::OptExpr(opt_expr) => {\n@@ -178,10 +180,10 @@ ast_fragments! {\n     Arms(SmallVec<[ast::Arm; 1]>) {\n         \"match arm\"; many fn flat_map_arm; fn visit_arm(); fn make_arms;\n     }\n-    Fields(SmallVec<[ast::ExprField; 1]>) {\n+    ExprFields(SmallVec<[ast::ExprField; 1]>) {\n         \"field expression\"; many fn flat_map_expr_field; fn visit_expr_field(); fn make_expr_fields;\n     }\n-    FieldPats(SmallVec<[ast::PatField; 1]>) {\n+    PatFields(SmallVec<[ast::PatField; 1]>) {\n         \"field pattern\";\n         many fn flat_map_pat_field;\n         fn visit_pat_field();\n@@ -196,7 +198,7 @@ ast_fragments! {\n     Params(SmallVec<[ast::Param; 1]>) {\n         \"function parameter\"; many fn flat_map_param; fn visit_param(); fn make_params;\n     }\n-    StructFields(SmallVec<[ast::FieldDef; 1]>) {\n+    FieldDefs(SmallVec<[ast::FieldDef; 1]>) {\n         \"field\";\n         many fn flat_map_field_def;\n         fn visit_field_def();\n@@ -231,11 +233,11 @@ impl AstFragmentKind {\n             | AstFragmentKind::ForeignItems\n             | AstFragmentKind::Crate => SupportsMacroExpansion::Yes { supports_inner_attrs: true },\n             AstFragmentKind::Arms\n-            | AstFragmentKind::Fields\n-            | AstFragmentKind::FieldPats\n+            | AstFragmentKind::ExprFields\n+            | AstFragmentKind::PatFields\n             | AstFragmentKind::GenericParams\n             | AstFragmentKind::Params\n-            | AstFragmentKind::StructFields\n+            | AstFragmentKind::FieldDefs\n             | AstFragmentKind::Variants => SupportsMacroExpansion::No,\n         }\n     }\n@@ -249,20 +251,20 @@ impl AstFragmentKind {\n             AstFragmentKind::Arms => {\n                 AstFragment::Arms(items.map(Annotatable::expect_arm).collect())\n             }\n-            AstFragmentKind::Fields => {\n-                AstFragment::Fields(items.map(Annotatable::expect_expr_field).collect())\n+            AstFragmentKind::ExprFields => {\n+                AstFragment::ExprFields(items.map(Annotatable::expect_expr_field).collect())\n             }\n-            AstFragmentKind::FieldPats => {\n-                AstFragment::FieldPats(items.map(Annotatable::expect_pat_field).collect())\n+            AstFragmentKind::PatFields => {\n+                AstFragment::PatFields(items.map(Annotatable::expect_pat_field).collect())\n             }\n             AstFragmentKind::GenericParams => {\n                 AstFragment::GenericParams(items.map(Annotatable::expect_generic_param).collect())\n             }\n             AstFragmentKind::Params => {\n                 AstFragment::Params(items.map(Annotatable::expect_param).collect())\n             }\n-            AstFragmentKind::StructFields => {\n-                AstFragment::StructFields(items.map(Annotatable::expect_field_def).collect())\n+            AstFragmentKind::FieldDefs => {\n+                AstFragment::FieldDefs(items.map(Annotatable::expect_field_def).collect())\n             }\n             AstFragmentKind::Variants => {\n                 AstFragment::Variants(items.map(Annotatable::expect_variant).collect())\n@@ -315,10 +317,10 @@ pub enum InvocationKind {\n         pos: usize,\n         item: Annotatable,\n         // Required for resolving derive helper attributes.\n-        derives: Vec<Path>,\n+        derives: Vec<ast::Path>,\n     },\n     Derive {\n-        path: Path,\n+        path: ast::Path,\n         item: Annotatable,\n     },\n }\n@@ -676,7 +678,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                             krate,\n                         ),\n                         Annotatable::Item(item_inner)\n-                            if matches!(attr.style, ast::AttrStyle::Inner)\n+                            if matches!(attr.style, AttrStyle::Inner)\n                                 && matches!(\n                                     item_inner.kind,\n                                     ItemKind::Mod(\n@@ -744,7 +746,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     if let SyntaxExtensionKind::Derive(..) = ext {\n                         self.gate_proc_macro_input(&item);\n                     }\n-                    let meta = ast::MetaItem { kind: ast::MetaItemKind::Word, span, path };\n+                    let meta = ast::MetaItem { kind: MetaItemKind::Word, span, path };\n                     let items = match expander.expand(self.cx, span, &meta, item) {\n                         ExpandResult::Ready(items) => items,\n                         ExpandResult::Retry(item) => {\n@@ -806,7 +808,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         impl<'ast, 'a> Visitor<'ast> for GateProcMacroInput<'a> {\n             fn visit_item(&mut self, item: &'ast ast::Item) {\n                 match &item.kind {\n-                    ast::ItemKind::Mod(_, mod_kind)\n+                    ItemKind::Mod(_, mod_kind)\n                         if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _)) =>\n                     {\n                         feature_err(\n@@ -834,7 +836,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         &mut self,\n         toks: TokenStream,\n         kind: AstFragmentKind,\n-        path: &Path,\n+        path: &ast::Path,\n         span: Span,\n     ) -> AstFragment {\n         let mut parser = self.cx.new_parser_from_tts(toks);\n@@ -915,18 +917,18 @@ pub fn parse_ast_fragment<'a>(\n         )?),\n         AstFragmentKind::Crate => AstFragment::Crate(this.parse_crate_mod()?),\n         AstFragmentKind::Arms\n-        | AstFragmentKind::Fields\n-        | AstFragmentKind::FieldPats\n+        | AstFragmentKind::ExprFields\n+        | AstFragmentKind::PatFields\n         | AstFragmentKind::GenericParams\n         | AstFragmentKind::Params\n-        | AstFragmentKind::StructFields\n+        | AstFragmentKind::FieldDefs\n         | AstFragmentKind::Variants => panic!(\"unexpected AST fragment kind\"),\n     })\n }\n \n pub fn ensure_complete_parse<'a>(\n     this: &mut Parser<'a>,\n-    macro_path: &Path,\n+    macro_path: &ast::Path,\n     kind_name: &str,\n     span: Span,\n ) {\n@@ -961,6 +963,568 @@ pub fn ensure_complete_parse<'a>(\n     }\n }\n \n+/// Wraps a call to `noop_visit_*` / `noop_flat_map_*`\n+/// for an AST node that supports attributes\n+/// (see the `Annotatable` enum)\n+/// This method assigns a `NodeId`, and sets that `NodeId`\n+/// as our current 'lint node id'. If a macro call is found\n+/// inside this AST node, we will use this AST node's `NodeId`\n+/// to emit lints associated with that macro (allowing\n+/// `#[allow]` / `#[deny]` to be applied close to\n+/// the macro invocation).\n+///\n+/// Do *not* call this for a macro AST node\n+/// (e.g. `ExprKind::MacCall`) - we cannot emit lints\n+/// at these AST nodes, since they are removed and\n+/// replaced with the result of macro expansion.\n+///\n+/// All other `NodeId`s are assigned by `visit_id`.\n+/// * `self` is the 'self' parameter for the current method,\n+/// * `id` is a mutable reference to the `NodeId` field\n+///    of the current AST node.\n+/// * `closure` is a closure that executes the\n+///   `noop_visit_*` / `noop_flat_map_*` method\n+///   for the current AST node.\n+macro_rules! assign_id {\n+    ($self:ident, $id:expr, $closure:expr) => {{\n+        let old_id = $self.cx.current_expansion.lint_node_id;\n+        if $self.monotonic {\n+            debug_assert_eq!(*$id, ast::DUMMY_NODE_ID);\n+            let new_id = $self.cx.resolver.next_node_id();\n+            *$id = new_id;\n+            $self.cx.current_expansion.lint_node_id = new_id;\n+        }\n+        let ret = ($closure)();\n+        $self.cx.current_expansion.lint_node_id = old_id;\n+        ret\n+    }};\n+}\n+\n+enum AddSemicolon {\n+    Yes,\n+    No,\n+}\n+\n+/// A trait implemented for all `AstFragment` nodes and providing all pieces\n+/// of functionality used by `InvocationCollector`.\n+trait InvocationCollectorNode: AstLike {\n+    type OutputTy = SmallVec<[Self; 1]>;\n+    type AttrsTy: Deref<Target = [ast::Attribute]> = Vec<ast::Attribute>;\n+    const KIND: AstFragmentKind;\n+    fn to_annotatable(self) -> Annotatable;\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy;\n+    fn id(&mut self) -> &mut NodeId;\n+    fn noop_flat_map<V: MutVisitor>(self, _visitor: &mut V) -> Self::OutputTy {\n+        unreachable!()\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, _visitor: &mut V) {\n+        unreachable!()\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        false\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        unreachable!()\n+    }\n+    fn pre_flat_map_node_collect_attr(_cfg: &StripUnconfigured<'_>, _attr: &ast::Attribute) {}\n+    fn post_flat_map_node_collect_bang(_output: &mut Self::OutputTy, _add_semicolon: AddSemicolon) {\n+    }\n+    fn wrap_flat_map_node_noop_flat_map(\n+        node: Self,\n+        collector: &mut InvocationCollector<'_, '_>,\n+        noop_flat_map: impl FnOnce(Self, &mut InvocationCollector<'_, '_>) -> Self::OutputTy,\n+    ) -> Result<Self::OutputTy, Self> {\n+        Ok(noop_flat_map(node, collector))\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::Item> {\n+    const KIND: AstFragmentKind = AstFragmentKind::Items;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Item(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_items()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_item(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, ItemKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            ItemKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+    fn wrap_flat_map_node_noop_flat_map(\n+        mut node: Self,\n+        collector: &mut InvocationCollector<'_, '_>,\n+        noop_flat_map: impl FnOnce(Self, &mut InvocationCollector<'_, '_>) -> Self::OutputTy,\n+    ) -> Result<Self::OutputTy, Self> {\n+        if !matches!(node.kind, ItemKind::Mod(..)) {\n+            return Ok(noop_flat_map(node, collector));\n+        }\n+\n+        // Work around borrow checker not seeing through `P`'s deref.\n+        let (ident, span, mut attrs) = (node.ident, node.span, mem::take(&mut node.attrs));\n+        let ItemKind::Mod(_, mod_kind) = &mut node.kind else {\n+            unreachable!()\n+        };\n+\n+        let ecx = &mut collector.cx;\n+        let (file_path, dir_path, dir_ownership) = match mod_kind {\n+            ModKind::Loaded(_, inline, _) => {\n+                // Inline `mod foo { ... }`, but we still need to push directories.\n+                let (dir_path, dir_ownership) = mod_dir_path(\n+                    &ecx.sess,\n+                    ident,\n+                    &attrs,\n+                    &ecx.current_expansion.module,\n+                    ecx.current_expansion.dir_ownership,\n+                    *inline,\n+                );\n+                node.attrs = attrs;\n+                (None, dir_path, dir_ownership)\n+            }\n+            ModKind::Unloaded => {\n+                // We have an outline `mod foo;` so we need to parse the file.\n+                let old_attrs_len = attrs.len();\n+                let ParsedExternalMod { mut items, inner_span, file_path, dir_path, dir_ownership } =\n+                    parse_external_mod(\n+                        &ecx.sess,\n+                        ident,\n+                        span,\n+                        &ecx.current_expansion.module,\n+                        ecx.current_expansion.dir_ownership,\n+                        &mut attrs,\n+                    );\n+\n+                if let Some(extern_mod_loaded) = ecx.extern_mod_loaded {\n+                    (attrs, items) = extern_mod_loaded(ident, attrs, items, inner_span);\n+                }\n+\n+                *mod_kind = ModKind::Loaded(items, Inline::No, inner_span);\n+                node.attrs = attrs;\n+                if node.attrs.len() > old_attrs_len {\n+                    // If we loaded an out-of-line module and added some inner attributes,\n+                    // then we need to re-configure it and re-collect attributes for\n+                    // resolution and expansion.\n+                    return Err(node);\n+                }\n+                (Some(file_path), dir_path, dir_ownership)\n+            }\n+        };\n+\n+        // Set the module info before we flat map.\n+        let mut module = ecx.current_expansion.module.with_dir_path(dir_path);\n+        module.mod_path.push(ident);\n+        if let Some(file_path) = file_path {\n+            module.file_path_stack.push(file_path);\n+        }\n+\n+        let orig_module = mem::replace(&mut ecx.current_expansion.module, Rc::new(module));\n+        let orig_dir_ownership =\n+            mem::replace(&mut ecx.current_expansion.dir_ownership, dir_ownership);\n+\n+        let res = Ok(noop_flat_map(node, collector));\n+\n+        collector.cx.current_expansion.dir_ownership = orig_dir_ownership;\n+        collector.cx.current_expansion.module = orig_module;\n+        res\n+    }\n+}\n+\n+struct TraitItemTag;\n+impl InvocationCollectorNode for AstLikeWrapper<P<ast::AssocItem>, TraitItemTag> {\n+    type OutputTy = SmallVec<[P<ast::AssocItem>; 1]>;\n+    const KIND: AstFragmentKind = AstFragmentKind::TraitItems;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::TraitItem(self.wrapped)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_trait_items()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.wrapped.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_assoc_item(self.wrapped, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.wrapped.kind, AssocItemKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let item = self.wrapped.into_inner();\n+        match item.kind {\n+            AssocItemKind::MacCall(mac) => (mac, item.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+struct ImplItemTag;\n+impl InvocationCollectorNode for AstLikeWrapper<P<ast::AssocItem>, ImplItemTag> {\n+    type OutputTy = SmallVec<[P<ast::AssocItem>; 1]>;\n+    const KIND: AstFragmentKind = AstFragmentKind::ImplItems;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::ImplItem(self.wrapped)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_impl_items()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.wrapped.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_assoc_item(self.wrapped, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.wrapped.kind, AssocItemKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let item = self.wrapped.into_inner();\n+        match item.kind {\n+            AssocItemKind::MacCall(mac) => (mac, item.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::ForeignItem> {\n+    const KIND: AstFragmentKind = AstFragmentKind::ForeignItems;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::ForeignItem(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_foreign_items()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_foreign_item(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, ForeignItemKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            ForeignItemKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Variant {\n+    const KIND: AstFragmentKind = AstFragmentKind::Variants;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Variant(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_variants()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_variant(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::FieldDef {\n+    const KIND: AstFragmentKind = AstFragmentKind::FieldDefs;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::FieldDef(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_field_defs()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_field_def(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::PatField {\n+    const KIND: AstFragmentKind = AstFragmentKind::PatFields;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::PatField(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_pat_fields()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_pat_field(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::ExprField {\n+    const KIND: AstFragmentKind = AstFragmentKind::ExprFields;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::ExprField(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_expr_fields()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_expr_field(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Param {\n+    const KIND: AstFragmentKind = AstFragmentKind::Params;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Param(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_params()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_param(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::GenericParam {\n+    const KIND: AstFragmentKind = AstFragmentKind::GenericParams;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::GenericParam(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_generic_params()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_generic_param(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Arm {\n+    const KIND: AstFragmentKind = AstFragmentKind::Arms;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Arm(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_arms()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_arm(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Stmt {\n+    type AttrsTy = ast::AttrVec;\n+    const KIND: AstFragmentKind = AstFragmentKind::Stmts;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Stmt(P(self))\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_stmts()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_stmt(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        match &self.kind {\n+            StmtKind::MacCall(..) => true,\n+            StmtKind::Item(item) => matches!(item.kind, ItemKind::MacCall(..)),\n+            StmtKind::Semi(expr) => matches!(expr.kind, ExprKind::MacCall(..)),\n+            StmtKind::Expr(..) => unreachable!(),\n+            StmtKind::Local(..) | StmtKind::Empty => false,\n+        }\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        // We pull macro invocations (both attributes and fn-like macro calls) out of their\n+        // `StmtKind`s and treat them as statement macro invocations, not as items or expressions.\n+        let (add_semicolon, mac, attrs) = match self.kind {\n+            StmtKind::MacCall(mac) => {\n+                let ast::MacCallStmt { mac, style, attrs, .. } = mac.into_inner();\n+                (style == MacStmtStyle::Semicolon, mac, attrs)\n+            }\n+            StmtKind::Item(item) => match item.into_inner() {\n+                ast::Item { kind: ItemKind::MacCall(mac), attrs, .. } => {\n+                    (mac.args.need_semicolon(), mac, attrs.into())\n+                }\n+                _ => unreachable!(),\n+            },\n+            StmtKind::Semi(expr) => match expr.into_inner() {\n+                ast::Expr { kind: ExprKind::MacCall(mac), attrs, .. } => {\n+                    (mac.args.need_semicolon(), mac, attrs)\n+                }\n+                _ => unreachable!(),\n+            },\n+            _ => unreachable!(),\n+        };\n+        (mac, attrs, if add_semicolon { AddSemicolon::Yes } else { AddSemicolon::No })\n+    }\n+    fn post_flat_map_node_collect_bang(stmts: &mut Self::OutputTy, add_semicolon: AddSemicolon) {\n+        // If this is a macro invocation with a semicolon, then apply that\n+        // semicolon to the final statement produced by expansion.\n+        if matches!(add_semicolon, AddSemicolon::Yes) {\n+            if let Some(stmt) = stmts.pop() {\n+                stmts.push(stmt.add_trailing_semicolon());\n+            }\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Crate {\n+    type OutputTy = ast::Crate;\n+    const KIND: AstFragmentKind = AstFragmentKind::Crate;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Crate(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_crate()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_crate(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::Ty> {\n+    type OutputTy = P<ast::Ty>;\n+    const KIND: AstFragmentKind = AstFragmentKind::Ty;\n+    fn to_annotatable(self) -> Annotatable {\n+        unreachable!()\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_ty()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_ty(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, ast::TyKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            TyKind::MacCall(mac) => (mac, Vec::new(), AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::Pat> {\n+    type OutputTy = P<ast::Pat>;\n+    const KIND: AstFragmentKind = AstFragmentKind::Pat;\n+    fn to_annotatable(self) -> Annotatable {\n+        unreachable!()\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_pat()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_pat(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, PatKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            PatKind::MacCall(mac) => (mac, Vec::new(), AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::Expr> {\n+    type OutputTy = P<ast::Expr>;\n+    type AttrsTy = ast::AttrVec;\n+    const KIND: AstFragmentKind = AstFragmentKind::Expr;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Expr(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_expr()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_expr(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, ExprKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+struct OptExprTag;\n+impl InvocationCollectorNode for AstLikeWrapper<P<ast::Expr>, OptExprTag> {\n+    type OutputTy = Option<P<ast::Expr>>;\n+    type AttrsTy = ast::AttrVec;\n+    const KIND: AstFragmentKind = AstFragmentKind::OptExpr;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Expr(self.wrapped)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_opt_expr()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.wrapped.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(mut self, visitor: &mut V) -> Self::OutputTy {\n+        noop_visit_expr(&mut self.wrapped, visitor);\n+        Some(self.wrapped)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.wrapped.kind, ast::ExprKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.wrapped.into_inner();\n+        match node.kind {\n+            ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+    fn pre_flat_map_node_collect_attr(cfg: &StripUnconfigured<'_>, attr: &ast::Attribute) {\n+        cfg.maybe_emit_expr_attr_err(&attr);\n+    }\n+}\n+\n struct InvocationCollector<'a, 'b> {\n     cx: &'a mut ExtCtxt<'b>,\n     cfg: StripUnconfigured<'a>,\n@@ -996,7 +1560,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(\n         &mut self,\n-        (attr, pos, derives): (ast::Attribute, usize, Vec<Path>),\n+        (attr, pos, derives): (ast::Attribute, usize, Vec<ast::Path>),\n         item: Annotatable,\n         kind: AstFragmentKind,\n     ) -> AstFragment {\n@@ -1007,9 +1571,9 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     /// its position and derives following it. We have to collect the derives in order to resolve\n     /// legacy derive helpers (helpers written before derives that introduce them).\n     fn take_first_attr(\n-        &mut self,\n+        &self,\n         item: &mut impl AstLike,\n-    ) -> Option<(ast::Attribute, usize, Vec<Path>)> {\n+    ) -> Option<(ast::Attribute, usize, Vec<ast::Path>)> {\n         let mut attr = None;\n \n         item.visit_attrs(|attrs| {\n@@ -1039,45 +1603,13 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         attr\n     }\n \n-    fn take_stmt_bang(\n-        &mut self,\n-        stmt: ast::Stmt,\n-    ) -> Result<(bool, MacCall, Vec<ast::Attribute>), ast::Stmt> {\n-        match stmt.kind {\n-            StmtKind::MacCall(mac) => {\n-                let MacCallStmt { mac, style, attrs, .. } = mac.into_inner();\n-                Ok((style == MacStmtStyle::Semicolon, mac, attrs.into()))\n-            }\n-            StmtKind::Item(item) if matches!(item.kind, ItemKind::MacCall(..)) => {\n-                match item.into_inner() {\n-                    ast::Item { kind: ItemKind::MacCall(mac), attrs, .. } => {\n-                        Ok((mac.args.need_semicolon(), mac, attrs))\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            }\n-            StmtKind::Semi(expr) if matches!(expr.kind, ast::ExprKind::MacCall(..)) => {\n-                match expr.into_inner() {\n-                    ast::Expr { kind: ast::ExprKind::MacCall(mac), attrs, .. } => {\n-                        Ok((mac.args.need_semicolon(), mac, attrs.into()))\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            }\n-            StmtKind::Local(..) | StmtKind::Empty | StmtKind::Item(..) | StmtKind::Semi(..) => {\n-                Err(stmt)\n-            }\n-            StmtKind::Expr(..) => unreachable!(),\n-        }\n-    }\n-\n     fn configure<T: AstLike>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n \n     // Detect use of feature-gated or invalid attributes on macro invocations\n     // since they will not be detected after macro expansion.\n-    fn check_attributes(&self, attrs: &[ast::Attribute], call: &MacCall) {\n+    fn check_attributes(&self, attrs: &[ast::Attribute], call: &ast::MacCall) {\n         let features = self.cx.ecfg.features.unwrap();\n         let mut attrs = attrs.iter().peekable();\n         let mut span: Option<Span> = None;\n@@ -1120,510 +1652,165 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             }\n         }\n     }\n-}\n \n-/// Wraps a call to `noop_visit_*` / `noop_flat_map_*`\n-/// for an AST node that supports attributes\n-/// (see the `Annotatable` enum)\n-/// This method assigns a `NodeId`, and sets that `NodeId`\n-/// as our current 'lint node id'. If a macro call is found\n-/// inside this AST node, we will use this AST node's `NodeId`\n-/// to emit lints associated with that macro (allowing\n-/// `#[allow]` / `#[deny]` to be applied close to\n-/// the macro invocation).\n-///\n-/// Do *not* call this for a macro AST node\n-/// (e.g. `ExprKind::MacCall`) - we cannot emit lints\n-/// at these AST nodes, since they are removed and\n-/// replaced with the result of macro expansion.\n-///\n-/// All other `NodeId`s are assigned by `visit_id`.\n-/// * `self` is the 'self' parameter for the current method,\n-/// * `id` is a mutable reference to the `NodeId` field\n-///    of the current AST node.\n-/// * `closure` is a closure that executes the\n-///   `noop_visit_*` / `noop_flat_map_*` method\n-///   for the current AST node.\n-macro_rules! assign_id {\n-    ($self:ident, $id:expr, $closure:expr) => {{\n-        let old_id = $self.cx.current_expansion.lint_node_id;\n-        if $self.monotonic {\n-            debug_assert_eq!(*$id, ast::DUMMY_NODE_ID);\n-            let new_id = $self.cx.resolver.next_node_id();\n-            *$id = new_id;\n-            $self.cx.current_expansion.lint_node_id = new_id;\n+    fn flat_map_node<Node: InvocationCollectorNode<OutputTy: Default>>(\n+        &mut self,\n+        node: Node,\n+    ) -> Node::OutputTy {\n+        let mut node = configure!(self, node);\n+\n+        if let Some(attr) = self.take_first_attr(&mut node) {\n+            Node::pre_flat_map_node_collect_attr(&self.cfg, &attr.0);\n+            self.collect_attr(attr, node.to_annotatable(), Node::KIND).make_ast::<Node>()\n+        } else if node.is_mac_call() {\n+            let (mac, attrs, add_semicolon) = node.take_mac_call();\n+            self.check_attributes(&attrs, &mac);\n+            let mut res = self.collect_bang(mac, Node::KIND).make_ast::<Node>();\n+            Node::post_flat_map_node_collect_bang(&mut res, add_semicolon);\n+            res\n+        } else {\n+            match Node::wrap_flat_map_node_noop_flat_map(node, self, |mut node, this| {\n+                assign_id!(this, node.id(), || node.noop_flat_map(this))\n+            }) {\n+                Ok(output) => output,\n+                Err(node) => self.flat_map_node(node),\n+            }\n         }\n-        let ret = ($closure)();\n-        $self.cx.current_expansion.lint_node_id = old_id;\n-        ret\n-    }};\n+    }\n+\n+    fn visit_node<Node: InvocationCollectorNode<OutputTy = Node> + DummyAstNode>(\n+        &mut self,\n+        node: &mut Node,\n+    ) {\n+        if let Some(attr) = self.take_first_attr(node) {\n+            visit_clobber(node, |node| {\n+                self.collect_attr(attr, node.to_annotatable(), Node::KIND).make_ast::<Node>()\n+            })\n+        } else if node.is_mac_call() {\n+            visit_clobber(node, |node| {\n+                // Do not clobber unless it's actually a macro (uncommon case).\n+                let (mac, attrs, _) = node.take_mac_call();\n+                self.check_attributes(&attrs, &mac);\n+                self.collect_bang(mac, Node::KIND).make_ast::<Node>()\n+            })\n+        } else {\n+            assign_id!(self, node.id(), || node.noop_visit(self))\n+        }\n+    }\n }\n \n impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n-    fn visit_crate(&mut self, krate: &mut ast::Crate) {\n-        visit_clobber(krate, |krate| {\n-            let span = krate.span;\n-            let mut krate = match self.configure(krate) {\n-                Some(krate) => krate,\n-                None => {\n-                    return ast::Crate {\n-                        attrs: Vec::new(),\n-                        items: Vec::new(),\n-                        span,\n-                        id: self.cx.resolver.next_node_id(),\n-                        is_placeholder: false,\n-                    };\n-                }\n-            };\n-\n-            if let Some(attr) = self.take_first_attr(&mut krate) {\n-                return self\n-                    .collect_attr(attr, Annotatable::Crate(krate), AstFragmentKind::Crate)\n-                    .make_crate();\n-            }\n-\n-            assign_id!(self, &mut krate.id, || noop_visit_crate(&mut krate, self));\n-            krate\n-        })\n+    fn flat_map_item(&mut self, node: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        self.cfg.configure_expr(expr);\n-        visit_clobber(expr.deref_mut(), |mut expr| {\n-            if let Some(attr) = self.take_first_attr(&mut expr) {\n-                // Collect the invoc regardless of whether or not attributes are permitted here\n-                // expansion will eat the attribute so it won't error later.\n-                self.cfg.maybe_emit_expr_attr_err(&attr.0);\n-\n-                // AstFragmentKind::Expr requires the macro to emit an expression.\n-                return self\n-                    .collect_attr(attr, Annotatable::Expr(P(expr)), AstFragmentKind::Expr)\n-                    .make_expr()\n-                    .into_inner();\n-            }\n-\n-            if let ast::ExprKind::MacCall(mac) = expr.kind {\n-                self.check_attributes(&expr.attrs, &mac);\n-                self.collect_bang(mac, AstFragmentKind::Expr).make_expr().into_inner()\n-            } else {\n-                assign_id!(self, &mut expr.id, || {\n-                    ensure_sufficient_stack(|| noop_visit_expr(&mut expr, self));\n-                });\n-                expr\n-            }\n-        });\n+    fn flat_map_trait_item(&mut self, node: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        self.flat_map_node(AstLikeWrapper::new(node, TraitItemTag))\n     }\n \n-    fn flat_map_arm(&mut self, arm: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n-        let mut arm = configure!(self, arm);\n-\n-        if let Some(attr) = self.take_first_attr(&mut arm) {\n-            return self\n-                .collect_attr(attr, Annotatable::Arm(arm), AstFragmentKind::Arms)\n-                .make_arms();\n-        }\n-\n-        assign_id!(self, &mut arm.id, || noop_flat_map_arm(arm, self))\n+    fn flat_map_impl_item(&mut self, node: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        self.flat_map_node(AstLikeWrapper::new(node, ImplItemTag))\n     }\n \n-    fn flat_map_expr_field(&mut self, field: ast::ExprField) -> SmallVec<[ast::ExprField; 1]> {\n-        let mut field = configure!(self, field);\n-\n-        if let Some(attr) = self.take_first_attr(&mut field) {\n-            return self\n-                .collect_attr(attr, Annotatable::ExprField(field), AstFragmentKind::Fields)\n-                .make_expr_fields();\n-        }\n-\n-        assign_id!(self, &mut field.id, || noop_flat_map_expr_field(field, self))\n+    fn flat_map_foreign_item(\n+        &mut self,\n+        node: P<ast::ForeignItem>,\n+    ) -> SmallVec<[P<ast::ForeignItem>; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_pat_field(&mut self, fp: ast::PatField) -> SmallVec<[ast::PatField; 1]> {\n-        let mut fp = configure!(self, fp);\n-\n-        if let Some(attr) = self.take_first_attr(&mut fp) {\n-            return self\n-                .collect_attr(attr, Annotatable::PatField(fp), AstFragmentKind::FieldPats)\n-                .make_pat_fields();\n-        }\n-\n-        assign_id!(self, &mut fp.id, || noop_flat_map_pat_field(fp, self))\n+    fn flat_map_variant(&mut self, node: ast::Variant) -> SmallVec<[ast::Variant; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_param(&mut self, p: ast::Param) -> SmallVec<[ast::Param; 1]> {\n-        let mut p = configure!(self, p);\n-\n-        if let Some(attr) = self.take_first_attr(&mut p) {\n-            return self\n-                .collect_attr(attr, Annotatable::Param(p), AstFragmentKind::Params)\n-                .make_params();\n-        }\n-\n-        assign_id!(self, &mut p.id, || noop_flat_map_param(p, self))\n+    fn flat_map_field_def(&mut self, node: ast::FieldDef) -> SmallVec<[ast::FieldDef; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_field_def(&mut self, sf: ast::FieldDef) -> SmallVec<[ast::FieldDef; 1]> {\n-        let mut sf = configure!(self, sf);\n-\n-        if let Some(attr) = self.take_first_attr(&mut sf) {\n-            return self\n-                .collect_attr(attr, Annotatable::FieldDef(sf), AstFragmentKind::StructFields)\n-                .make_field_defs();\n-        }\n-\n-        assign_id!(self, &mut sf.id, || noop_flat_map_field_def(sf, self))\n+    fn flat_map_pat_field(&mut self, node: ast::PatField) -> SmallVec<[ast::PatField; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_variant(&mut self, variant: ast::Variant) -> SmallVec<[ast::Variant; 1]> {\n-        let mut variant = configure!(self, variant);\n-\n-        if let Some(attr) = self.take_first_attr(&mut variant) {\n-            return self\n-                .collect_attr(attr, Annotatable::Variant(variant), AstFragmentKind::Variants)\n-                .make_variants();\n-        }\n-\n-        assign_id!(self, &mut variant.id, || noop_flat_map_variant(variant, self))\n+    fn flat_map_expr_field(&mut self, node: ast::ExprField) -> SmallVec<[ast::ExprField; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        let expr = configure!(self, expr);\n-        expr.filter_map(|mut expr| {\n-            if let Some(attr) = self.take_first_attr(&mut expr) {\n-                self.cfg.maybe_emit_expr_attr_err(&attr.0);\n-\n-                return self\n-                    .collect_attr(attr, Annotatable::Expr(P(expr)), AstFragmentKind::OptExpr)\n-                    .make_opt_expr()\n-                    .map(|expr| expr.into_inner());\n-            }\n-\n-            if let ast::ExprKind::MacCall(mac) = expr.kind {\n-                self.check_attributes(&expr.attrs, &mac);\n-                self.collect_bang(mac, AstFragmentKind::OptExpr)\n-                    .make_opt_expr()\n-                    .map(|expr| expr.into_inner())\n-            } else {\n-                assign_id!(self, &mut expr.id, || {\n-                    Some({\n-                        noop_visit_expr(&mut expr, self);\n-                        expr\n-                    })\n-                })\n-            }\n-        })\n+    fn flat_map_param(&mut self, node: ast::Param) -> SmallVec<[ast::Param; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        match pat.kind {\n-            PatKind::MacCall(_) => {}\n-            _ => return noop_visit_pat(pat, self),\n-        }\n-\n-        visit_clobber(pat, |mut pat| match mem::replace(&mut pat.kind, PatKind::Wild) {\n-            PatKind::MacCall(mac) => self.collect_bang(mac, AstFragmentKind::Pat).make_pat(),\n-            _ => unreachable!(),\n-        });\n+    fn flat_map_generic_param(\n+        &mut self,\n+        node: ast::GenericParam,\n+    ) -> SmallVec<[ast::GenericParam; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n-        let mut stmt = configure!(self, stmt);\n+    fn flat_map_arm(&mut self, node: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n+        self.flat_map_node(node)\n+    }\n \n-        // We pull macro invocations (both attributes and fn-like macro calls) out of their\n-        // `StmtKind`s and treat them as statement macro invocations, not as items or expressions.\n+    fn flat_map_stmt(&mut self, node: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n         // FIXME: invocations in semicolon-less expressions positions are expanded as expressions,\n         // changing that requires some compatibility measures.\n-        let mut stmt = if !stmt.is_expr() {\n-            if let Some(attr) = self.take_first_attr(&mut stmt) {\n-                return self\n-                    .collect_attr(attr, Annotatable::Stmt(P(stmt)), AstFragmentKind::Stmts)\n-                    .make_stmts();\n-            }\n-\n-            match self.take_stmt_bang(stmt) {\n-                Ok((add_semicolon, mac, attrs)) => {\n-                    self.check_attributes(&attrs, &mac);\n-                    let mut stmts = self.collect_bang(mac, AstFragmentKind::Stmts).make_stmts();\n-\n-                    // If this is a macro invocation with a semicolon, then apply that\n-                    // semicolon to the final statement produced by expansion.\n-                    if add_semicolon {\n-                        if let Some(stmt) = stmts.pop() {\n-                            stmts.push(stmt.add_trailing_semicolon());\n-                        }\n-                    }\n-\n-                    return stmts;\n+        if node.is_expr() {\n+            // The only way that we can end up with a `MacCall` expression statement,\n+            // (as opposed to a `StmtKind::MacCall`) is if we have a macro as the\n+            // traiing expression in a block (e.g. `fn foo() { my_macro!() }`).\n+            // Record this information, so that we can report a more specific\n+            // `SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` lint if needed.\n+            // See #78991 for an investigation of treating macros in this position\n+            // as statements, rather than expressions, during parsing.\n+            let mut node = configure!(self, node);\n+            return match &node.kind {\n+                StmtKind::Expr(expr)\n+                    if matches!(**expr, ast::Expr { kind: ExprKind::MacCall(..), .. }) =>\n+                {\n+                    self.cx.current_expansion.is_trailing_mac = true;\n+                    // Don't use `assign_id` for this statement - it may get removed\n+                    // entirely due to a `#[cfg]` on the contained expression\n+                    let res = noop_flat_map_stmt(node, self);\n+                    self.cx.current_expansion.is_trailing_mac = false;\n+                    res\n                 }\n-                Err(stmt) => stmt,\n-            }\n-        } else {\n-            stmt\n-        };\n-\n-        // The only way that we can end up with a `MacCall` expression statement,\n-        // (as opposed to a `StmtKind::MacCall`) is if we have a macro as the\n-        // traiing expression in a block (e.g. `fn foo() { my_macro!() }`).\n-        // Record this information, so that we can report a more specific\n-        // `SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` lint if needed.\n-        // See #78991 for an investigation of treating macros in this position\n-        // as statements, rather than expressions, during parsing.\n-        let res = match &stmt.kind {\n-            StmtKind::Expr(expr)\n-                if matches!(**expr, ast::Expr { kind: ast::ExprKind::MacCall(..), .. }) =>\n-            {\n-                self.cx.current_expansion.is_trailing_mac = true;\n-                // Don't use `assign_id` for this statement - it may get removed\n-                // entirely due to a `#[cfg]` on the contained expression\n-                noop_flat_map_stmt(stmt, self)\n-            }\n-            _ => assign_id!(self, &mut stmt.id, || noop_flat_map_stmt(stmt, self)),\n-        };\n-        self.cx.current_expansion.is_trailing_mac = false;\n-        res\n-    }\n-\n-    fn visit_block(&mut self, block: &mut P<Block>) {\n-        let orig_dir_ownership = mem::replace(\n-            &mut self.cx.current_expansion.dir_ownership,\n-            DirOwnership::UnownedViaBlock,\n-        );\n-        noop_visit_block(block, self);\n-        self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n-    }\n-\n-    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n-        let mut item = configure!(self, item);\n-\n-        if let Some(attr) = self.take_first_attr(&mut item) {\n-            return self\n-                .collect_attr(attr, Annotatable::Item(item), AstFragmentKind::Items)\n-                .make_items();\n+                _ => assign_id!(self, &mut node.id, || noop_flat_map_stmt(node, self)),\n+            };\n         }\n \n-        let mut attrs = mem::take(&mut item.attrs); // We do this to please borrowck.\n-        let ident = item.ident;\n-        let span = item.span;\n-\n-        match item.kind {\n-            ast::ItemKind::MacCall(ref mac) => {\n-                self.check_attributes(&attrs, &mac);\n-                item.attrs = attrs;\n-                item.and_then(|item| match item.kind {\n-                    ItemKind::MacCall(mac) => {\n-                        self.collect_bang(mac, AstFragmentKind::Items).make_items()\n-                    }\n-                    _ => unreachable!(),\n-                })\n-            }\n-            ast::ItemKind::Mod(_, ref mut mod_kind) if ident != Ident::empty() => {\n-                let (file_path, dir_path, dir_ownership) = match mod_kind {\n-                    ModKind::Loaded(_, inline, _) => {\n-                        // Inline `mod foo { ... }`, but we still need to push directories.\n-                        let (dir_path, dir_ownership) = mod_dir_path(\n-                            &self.cx.sess,\n-                            ident,\n-                            &attrs,\n-                            &self.cx.current_expansion.module,\n-                            self.cx.current_expansion.dir_ownership,\n-                            *inline,\n-                        );\n-                        item.attrs = attrs;\n-                        (None, dir_path, dir_ownership)\n-                    }\n-                    ModKind::Unloaded => {\n-                        // We have an outline `mod foo;` so we need to parse the file.\n-                        let old_attrs_len = attrs.len();\n-                        let ParsedExternalMod {\n-                            mut items,\n-                            inner_span,\n-                            file_path,\n-                            dir_path,\n-                            dir_ownership,\n-                        } = parse_external_mod(\n-                            &self.cx.sess,\n-                            ident,\n-                            span,\n-                            &self.cx.current_expansion.module,\n-                            self.cx.current_expansion.dir_ownership,\n-                            &mut attrs,\n-                        );\n-\n-                        if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n-                            (attrs, items) = extern_mod_loaded(ident, attrs, items, inner_span);\n-                        }\n-\n-                        *mod_kind = ModKind::Loaded(items, Inline::No, inner_span);\n-                        item.attrs = attrs;\n-                        if item.attrs.len() > old_attrs_len {\n-                            // If we loaded an out-of-line module and added some inner attributes,\n-                            // then we need to re-configure it and re-collect attributes for\n-                            // resolution and expansion.\n-                            item = configure!(self, item);\n-\n-                            if let Some(attr) = self.take_first_attr(&mut item) {\n-                                return self\n-                                    .collect_attr(\n-                                        attr,\n-                                        Annotatable::Item(item),\n-                                        AstFragmentKind::Items,\n-                                    )\n-                                    .make_items();\n-                            }\n-                        }\n-                        (Some(file_path), dir_path, dir_ownership)\n-                    }\n-                };\n-\n-                // Set the module info before we flat map.\n-                let mut module = self.cx.current_expansion.module.with_dir_path(dir_path);\n-                module.mod_path.push(ident);\n-                if let Some(file_path) = file_path {\n-                    module.file_path_stack.push(file_path);\n-                }\n-\n-                let orig_module =\n-                    mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n-                let orig_dir_ownership =\n-                    mem::replace(&mut self.cx.current_expansion.dir_ownership, dir_ownership);\n-\n-                let result = assign_id!(self, &mut item.id, || noop_flat_map_item(item, self));\n-\n-                // Restore the module info.\n-                self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n-                self.cx.current_expansion.module = orig_module;\n-\n-                result\n-            }\n-            _ => {\n-                item.attrs = attrs;\n-                // The crate root is special - don't assign an ID to it.\n-                if !(matches!(item.kind, ast::ItemKind::Mod(..)) && ident == Ident::empty()) {\n-                    assign_id!(self, &mut item.id, || noop_flat_map_item(item, self))\n-                } else {\n-                    noop_flat_map_item(item, self)\n-                }\n-            }\n-        }\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        let mut item = configure!(self, item);\n-\n-        if let Some(attr) = self.take_first_attr(&mut item) {\n-            return self\n-                .collect_attr(attr, Annotatable::TraitItem(item), AstFragmentKind::TraitItems)\n-                .make_trait_items();\n-        }\n-\n-        match item.kind {\n-            ast::AssocItemKind::MacCall(ref mac) => {\n-                self.check_attributes(&item.attrs, &mac);\n-                item.and_then(|item| match item.kind {\n-                    ast::AssocItemKind::MacCall(mac) => {\n-                        self.collect_bang(mac, AstFragmentKind::TraitItems).make_trait_items()\n-                    }\n-                    _ => unreachable!(),\n-                })\n-            }\n-            _ => {\n-                assign_id!(self, &mut item.id, || noop_flat_map_assoc_item(item, self))\n-            }\n-        }\n+    fn visit_crate(&mut self, node: &mut ast::Crate) {\n+        self.visit_node(node)\n     }\n \n-    fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        let mut item = configure!(self, item);\n-\n-        if let Some(attr) = self.take_first_attr(&mut item) {\n-            return self\n-                .collect_attr(attr, Annotatable::ImplItem(item), AstFragmentKind::ImplItems)\n-                .make_impl_items();\n-        }\n-\n-        match item.kind {\n-            ast::AssocItemKind::MacCall(ref mac) => {\n-                self.check_attributes(&item.attrs, &mac);\n-                item.and_then(|item| match item.kind {\n-                    ast::AssocItemKind::MacCall(mac) => {\n-                        self.collect_bang(mac, AstFragmentKind::ImplItems).make_impl_items()\n-                    }\n-                    _ => unreachable!(),\n-                })\n-            }\n-            _ => {\n-                assign_id!(self, &mut item.id, || noop_flat_map_assoc_item(item, self))\n-            }\n-        }\n+    fn visit_ty(&mut self, node: &mut P<ast::Ty>) {\n+        self.visit_node(node)\n     }\n \n-    fn visit_ty(&mut self, ty: &mut P<ast::Ty>) {\n-        match ty.kind {\n-            ast::TyKind::MacCall(_) => {}\n-            _ => return noop_visit_ty(ty, self),\n-        };\n-\n-        visit_clobber(ty, |mut ty| match mem::replace(&mut ty.kind, ast::TyKind::Err) {\n-            ast::TyKind::MacCall(mac) => self.collect_bang(mac, AstFragmentKind::Ty).make_ty(),\n-            _ => unreachable!(),\n-        });\n+    fn visit_pat(&mut self, node: &mut P<ast::Pat>) {\n+        self.visit_node(node)\n     }\n \n-    fn flat_map_foreign_item(\n-        &mut self,\n-        foreign_item: P<ast::ForeignItem>,\n-    ) -> SmallVec<[P<ast::ForeignItem>; 1]> {\n-        let mut foreign_item = configure!(self, foreign_item);\n-\n-        if let Some(attr) = self.take_first_attr(&mut foreign_item) {\n-            return self\n-                .collect_attr(\n-                    attr,\n-                    Annotatable::ForeignItem(foreign_item),\n-                    AstFragmentKind::ForeignItems,\n-                )\n-                .make_foreign_items();\n-        }\n-\n-        match foreign_item.kind {\n-            ast::ForeignItemKind::MacCall(ref mac) => {\n-                self.check_attributes(&foreign_item.attrs, &mac);\n-                foreign_item.and_then(|item| match item.kind {\n-                    ast::ForeignItemKind::MacCall(mac) => {\n-                        self.collect_bang(mac, AstFragmentKind::ForeignItems).make_foreign_items()\n-                    }\n-                    _ => unreachable!(),\n-                })\n-            }\n-            _ => {\n-                assign_id!(self, &mut foreign_item.id, || noop_flat_map_foreign_item(\n-                    foreign_item,\n-                    self\n-                ))\n-            }\n-        }\n+    fn visit_expr(&mut self, node: &mut P<ast::Expr>) {\n+        self.cfg.configure_expr(node);\n+        self.visit_node(node)\n     }\n \n-    fn flat_map_generic_param(\n-        &mut self,\n-        param: ast::GenericParam,\n-    ) -> SmallVec<[ast::GenericParam; 1]> {\n-        let mut param = configure!(self, param);\n-\n-        if let Some(attr) = self.take_first_attr(&mut param) {\n-            return self\n-                .collect_attr(\n-                    attr,\n-                    Annotatable::GenericParam(param),\n-                    AstFragmentKind::GenericParams,\n-                )\n-                .make_generic_params();\n-        }\n+    fn filter_map_expr(&mut self, node: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        self.flat_map_node(AstLikeWrapper::new(node, OptExprTag))\n+    }\n \n-        assign_id!(self, &mut param.id, || noop_flat_map_generic_param(param, self))\n+    fn visit_block(&mut self, node: &mut P<ast::Block>) {\n+        let orig_dir_ownership = mem::replace(\n+            &mut self.cx.current_expansion.dir_ownership,\n+            DirOwnership::UnownedViaBlock,\n+        );\n+        noop_visit_block(node, self);\n+        self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n     }\n \n-    fn visit_id(&mut self, id: &mut ast::NodeId) {\n+    fn visit_id(&mut self, id: &mut NodeId) {\n         // We may have already assigned a `NodeId`\n         // by calling `assign_id`\n         if self.monotonic && *id == ast::DUMMY_NODE_ID {"}, {"sha": "5599c1df6d9de3c0011d353075a39d8b4f252412", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=b681dc2af419c5b7f200e44a3604a8dab9ebe3a6", "patch": "@@ -1,3 +1,5 @@\n+#![feature(associated_type_bounds)]\n+#![feature(associated_type_defaults)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![cfg_attr(bootstrap, feature(destructuring_assignment))]"}, {"sha": "af593e92634b034be962b944d9038b036bf2568c", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=b681dc2af419c5b7f200e44a3604a8dab9ebe3a6", "patch": "@@ -123,7 +123,7 @@ pub fn placeholder(\n             span,\n             is_placeholder: true,\n         }]),\n-        AstFragmentKind::Fields => AstFragment::Fields(smallvec![ast::ExprField {\n+        AstFragmentKind::ExprFields => AstFragment::ExprFields(smallvec![ast::ExprField {\n             attrs: Default::default(),\n             expr: expr_placeholder(),\n             id,\n@@ -132,7 +132,7 @@ pub fn placeholder(\n             span,\n             is_placeholder: true,\n         }]),\n-        AstFragmentKind::FieldPats => AstFragment::FieldPats(smallvec![ast::PatField {\n+        AstFragmentKind::PatFields => AstFragment::PatFields(smallvec![ast::PatField {\n             attrs: Default::default(),\n             id,\n             ident,\n@@ -159,7 +159,7 @@ pub fn placeholder(\n             ty: ty(),\n             is_placeholder: true,\n         }]),\n-        AstFragmentKind::StructFields => AstFragment::StructFields(smallvec![ast::FieldDef {\n+        AstFragmentKind::FieldDefs => AstFragment::FieldDefs(smallvec![ast::FieldDef {\n             attrs: Default::default(),\n             id,\n             ident: None,"}]}