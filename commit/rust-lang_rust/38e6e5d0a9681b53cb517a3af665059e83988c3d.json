{"sha": "38e6e5d0a9681b53cb517a3af665059e83988c3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZTZlNWQwYTk2ODFiNTNjYjUxN2EzYWY2NjUwNTllODM5ODhjM2Q=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-04-26T21:30:01Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-05-10T00:28:48Z"}, "message": "rustc: Use C++ personalities on MSVC\n\nCurrently the compiler has two relatively critical bugs in the implementation of\nMSVC unwinding:\n\n* #33112 - faults like segfaults and illegal instructions will run destructors\n           in Rust, meaning we keep running code after a super-fatal exception\n           has happened.\n\n* #33116 - When compiling with LTO plus `-Z no-landing-pads` (or `-C\n           panic=abort` with the previous commit) LLVM won't remove all `invoke`\n           instructions, meaning that some landing pads stick around and\n           cleanups may be run due to the previous bug.\n\nThese both stem from the flavor of \"personality function\" that Rust uses for\nunwinding on MSVC. On 32-bit this is `_except_handler3` and on 64-bit this is\n`__C_specific_handler`, but they both essentially are the \"most generic\"\npersonality functions for catching exceptions and running cleanups. That is,\nthse two personalities will run cleanups for all exceptions unconditionally, so\nwhen we use them we run cleanups for **all SEH exceptions** (include things like\nsegfaults).\n\nNote that this also explains why LLVM won't optimize away `invoke` instructions.\nThese functions can legitimately still unwind (the `nounwind` attribute only\nseems to apply to \"C++ exception-like unwining\"). Also note that the standard\nlibrary only *catches* Rust exceptions, not others like segfaults and illegal\ninstructions.\n\nLLVM has support for another personality, `__CxxFrameHandler3`, which does not\nrun cleanups for general exceptions, only C++ exceptions thrown by\n`_CxxThrowException`. This essentially ideally matches our use case, so this\ncommit moves us over to using this well-known personality function as well as\nexception-throwing function.\n\nThis doesn't *seem* to pull in any extra runtime dependencies just yet, but if\nit does we can perhaps try to work out how to implement more of it in Rust\nrather than relying on MSVCRT runtime bits.\n\nMore details about how this is actually implemented can be found in the changes\nitself, but this...\n\nCloses #33112\nCloses #33116", "tree": {"sha": "69ae16a49bfaa23613593534466e813a999b3781", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69ae16a49bfaa23613593534466e813a999b3781"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38e6e5d0a9681b53cb517a3af665059e83988c3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38e6e5d0a9681b53cb517a3af665059e83988c3d", "html_url": "https://github.com/rust-lang/rust/commit/38e6e5d0a9681b53cb517a3af665059e83988c3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38e6e5d0a9681b53cb517a3af665059e83988c3d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ec321f7b541fcbfbf20286beb497e6d9d3352b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ec321f7b541fcbfbf20286beb497e6d9d3352b2", "html_url": "https://github.com/rust-lang/rust/commit/0ec321f7b541fcbfbf20286beb497e6d9d3352b2"}], "stats": {"total": 538, "additions": 337, "deletions": 201}, "files": [{"sha": "c085ddeb75b97f407ab552f825c4b66a381b45b7", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/38e6e5d0a9681b53cb517a3af665059e83988c3d/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38e6e5d0a9681b53cb517a3af665059e83988c3d/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=38e6e5d0a9681b53cb517a3af665059e83988c3d", "patch": "@@ -93,20 +93,43 @@ pub unsafe extern fn __rust_start_panic(_data: usize, _vtable: usize) -> u32 {\n // Essentially this symbol is just defined to get wired up to libcore/libstd\n // binaries, but it should never be called as we don't link in an unwinding\n // runtime at all.\n-#[no_mangle]\n #[cfg(not(stage0))]\n-pub extern fn rust_eh_personality() {}\n+pub mod personalities {\n \n-// Similar to above, this corresponds to the `eh_unwind_resume` lang item that's\n-// only used on Windows currently.\n-#[no_mangle]\n-#[cfg(all(not(stage0), target_os = \"windows\", target_env = \"gnu\"))]\n-pub extern fn rust_eh_unwind_resume() {}\n+    #[no_mangle]\n+    #[cfg(not(all(target_os = \"windows\",\n+                  target_env = \"gnu\",\n+                  target_arch = \"x86_64\")))]\n+    pub extern fn rust_eh_personality() {}\n \n-#[no_mangle]\n-#[cfg(all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86\"))]\n-pub extern fn rust_eh_register_frames() {}\n+    // On x86_64-pc-windows-gnu we use our own personality function that needs\n+    // to return `ExceptionContinueSearch` as we're passing on all our frames.\n+    #[no_mangle]\n+    #[cfg(all(target_os = \"windows\",\n+              target_env = \"gnu\",\n+              target_arch = \"x86_64\"))]\n+    pub extern fn rust_eh_personality(_record: usize,\n+                                      _frame: usize,\n+                                      _context: usize,\n+                                      _dispatcher: usize) -> u32 {\n+        1 // `ExceptionContinueSearch`\n+    }\n \n-#[no_mangle]\n-#[cfg(all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86\"))]\n-pub extern fn rust_eh_unregister_frames() {}\n+    // Similar to above, this corresponds to the `eh_unwind_resume` lang item\n+    // that's only used on Windows currently.\n+    //\n+    // Note that we don't execute landing pads, so this is never called, so it's\n+    // body is empty.\n+    #[no_mangle]\n+    #[cfg(all(target_os = \"windows\", target_env = \"gnu\"))]\n+    pub extern fn rust_eh_unwind_resume() {}\n+\n+    // These two are called by our startup objects on i686-pc-windows-gnu, but\n+    // they don't need to do anything so the bodies are nops.\n+    #[no_mangle]\n+    #[cfg(all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86\"))]\n+    pub extern fn rust_eh_register_frames() {}\n+    #[no_mangle]\n+    #[cfg(all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86\"))]\n+    pub extern fn rust_eh_unregister_frames() {}\n+}"}, {"sha": "04a3f7b9663fbe203ad1a87a30f3dc34329b7077", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 253, "deletions": 74, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/38e6e5d0a9681b53cb517a3af665059e83988c3d/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38e6e5d0a9681b53cb517a3af665059e83988c3d/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=38e6e5d0a9681b53cb517a3af665059e83988c3d", "patch": "@@ -18,122 +18,301 @@\n //!\n //! In a nutshell, what happens here is:\n //!\n-//! 1. The `panic` function calls the standard Windows function `RaiseException`\n-//!    with a Rust-specific code, triggering the unwinding process.\n+//! 1. The `panic` function calls the standard Windows function\n+//!    `_CxxThrowException` to throw a C++-like exception, triggering the\n+//!    unwinding process.\n //! 2. All landing pads generated by the compiler use the personality function\n-//!    `__C_specific_handler` on 64-bit and `__except_handler3` on 32-bit,\n-//!    functions in the CRT, and the unwinding code in Windows will use this\n-//!    personality function to execute all cleanup code on the stack.\n+//!    `__CxxFrameHandler3`, a function in the CRT, and the unwinding code in\n+//!    Windows will use this personality function to execute all cleanup code on\n+//!    the stack.\n //! 3. All compiler-generated calls to `invoke` have a landing pad set as a\n //!    `cleanuppad` LLVM instruction, which indicates the start of the cleanup\n //!    routine. The personality (in step 2, defined in the CRT) is responsible\n //!    for running the cleanup routines.\n //! 4. Eventually the \"catch\" code in the `try` intrinsic (generated by the\n-//!    compiler) is executed, which will ensure that the exception being caught\n-//!    is indeed a Rust exception, indicating that control should come back to\n+//!    compiler) is executed and indicates that control should come back to\n //!    Rust. This is done via a `catchswitch` plus a `catchpad` instruction in\n //!    LLVM IR terms, finally returning normal control to the program with a\n-//!    `catchret` instruction. The `try` intrinsic uses a filter function to\n-//!    detect what kind of exception is being thrown, and this detection is\n-//!    implemented as the msvc_try_filter language item below.\n+//!    `catchret` instruction.\n //!\n //! Some specific differences from the gcc-based exception handling are:\n //!\n //! * Rust has no custom personality function, it is instead *always*\n-//!   __C_specific_handler or __except_handler3, so the filtering is done in a\n-//!   C++-like manner instead of in the personality function itself. Note that\n-//!   the precise codegen for this was lifted from an LLVM test case for SEH\n-//!   (this is the `__rust_try_filter` function below).\n+//!   `__CxxFrameHandler3`. Additionally, no extra filtering is performed, so we\n+//!   end up catching any C++ exceptions that happen to look like the kind we're\n+//!   throwing. Note that throwing an exception into Rust is undefined behavior\n+//!   anyway, so this should be fine.\n //! * We've got some data to transmit across the unwinding boundary,\n //!   specifically a `Box<Any + Send>`. Like with Dwarf exceptions\n //!   these two pointers are stored as a payload in the exception itself. On\n-//!   MSVC, however, there's no need for an extra allocation because the call\n-//!   stack is preserved while filter functions are being executed. This means\n-//!   that the pointers are passed directly to `RaiseException` which are then\n-//!   recovered in the filter function to be written to the stack frame of the\n-//!   `try` intrinsic.\n+//!   MSVC, however, there's no need for an extra heap allocation because the\n+//!   call stack is preserved while filter functions are being executed. This\n+//!   means that the pointers are passed directly to `_CxxThrowException` which\n+//!   are then recovered in the filter function to be written to the stack frame\n+//!   of the `try` intrinsic.\n //!\n //! [win64]: http://msdn.microsoft.com/en-us/library/1eyas8tf.aspx\n //! [llvm]: http://llvm.org/docs/ExceptionHandling.html#background-on-windows-exceptions\n \n+#![allow(bad_style)]\n+#![allow(private_no_mangle_fns)]\n+\n use alloc::boxed::Box;\n use core::any::Any;\n-use core::intrinsics;\n use core::mem;\n use core::raw;\n \n use windows as c;\n+use libc::{c_int, c_uint};\n+\n+// First up, a whole bunch of type definitions. There's a few platform-specific\n+// oddities here, and a lot that's just blatantly copied from LLVM. The purpose\n+// of all this is to implement the `panic` function below through a call to\n+// `_CxxThrowException`.\n+//\n+// This function takes two arguments. The first is a pointer to the data we're\n+// passing in, which in this case is our trait object. Pretty easy to find! The\n+// next, however, is more complicated. This is a pointer to a `_ThrowInfo`\n+// structure, and it generally is just intended to just describe the exception\n+// being thrown.\n+//\n+// Currently the definition of this type [1] is a little hairy, and the main\n+// oddity (and difference from the online article) is that on 32-bit the\n+// pointers are pointers but on 64-bit the pointers are expressed as 32-bit\n+// offsets from the `__ImageBase` symbol. The `ptr_t` and `ptr!` macro in the\n+// modules below are used to express this.\n+//\n+// The maze of type definitions also closely follows what LLVM emits for this\n+// sort of operation. For example, if you compile this C++ code on MSVC and emit\n+// the LLVM IR:\n+//\n+//      #include <stdin.h>\n+//\n+//      void foo() {\n+//          uint64_t a[2] = {0, 1};\n+//          throw a;\n+//      }\n+//\n+// That's essentially what we're trying to emulate. Most of the constant values\n+// below were just copied from LLVM, I'm at least not 100% sure what's going on\n+// everywhere. For example the `.PA_K\\0` and `.PEA_K\\0` strings below (stuck in\n+// the names of a few of these) I'm not actually sure what they do, but it seems\n+// to mirror what LLVM does!\n+//\n+// In any case, these structures are all constructed in a similar manner, and\n+// it's just somewhat verbose for us.\n+//\n+// [1]: http://www.geoffchappell.com/studies/msvc/language/predefined/\n+\n+#[cfg(target_arch = \"x86\")]\n+#[macro_use]\n+mod imp {\n+    pub type ptr_t = *mut u8;\n+    pub const OFFSET: i32 = 4;\n+\n+    pub const NAME1: [u8; 7] = [b'.', b'P', b'A', b'_', b'K', 0, 0];\n+    pub const NAME2: [u8; 7] = [b'.', b'P', b'A', b'X', 0, 0, 0];\n+\n+    macro_rules! ptr {\n+        (0) => (0 as *mut u8);\n+        ($e:expr) => ($e as *mut u8);\n+    }\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[macro_use]\n+mod imp {\n+    pub type ptr_t = u32;\n+    pub const OFFSET: i32 = 8;\n+\n+    pub const NAME1: [u8; 7] = [b'.', b'P', b'E', b'A', b'_', b'K', 0];\n+    pub const NAME2: [u8; 7] = [b'.', b'P', b'E', b'A', b'X', 0, 0];\n+\n+    extern {\n+        pub static __ImageBase: u8;\n+    }\n+\n+    macro_rules! ptr {\n+        (0) => (0);\n+        ($e:expr) => {\n+            (($e as usize) - (&imp::__ImageBase as *const _ as usize)) as u32\n+        }\n+    }\n+}\n+\n+#[repr(C)]\n+pub struct _ThrowInfo {\n+    pub attribues: c_uint,\n+    pub pnfnUnwind: imp::ptr_t,\n+    pub pForwardCompat: imp::ptr_t,\n+    pub pCatchableTypeArray: imp::ptr_t,\n+}\n+\n+#[repr(C)]\n+pub struct _CatchableTypeArray {\n+    pub nCatchableTypes: c_int,\n+    pub arrayOfCatchableTypes: [imp::ptr_t; 2],\n+}\n \n-// A code which indicates panics that originate from Rust. Note that some of the\n-// upper bits are used by the system so we just set them to 0 and ignore them.\n-//                           0x 0 R S T\n-const RUST_PANIC: c::DWORD = 0x00525354;\n+#[repr(C)]\n+pub struct _CatchableType {\n+    pub properties: c_uint,\n+    pub pType: imp::ptr_t,\n+    pub thisDisplacement: _PMD,\n+    pub sizeOrOffset: c_int,\n+    pub copy_function: imp::ptr_t,\n+}\n+\n+#[repr(C)]\n+pub struct _PMD {\n+    pub mdisp: c_int,\n+    pub pdisp: c_int,\n+    pub vdisp: c_int,\n+}\n+\n+#[repr(C)]\n+pub struct _TypeDescriptor {\n+    pub pVFTable: *const u8,\n+    pub spare: *mut u8,\n+    pub name: [u8; 7],\n+}\n+\n+static mut THROW_INFO: _ThrowInfo = _ThrowInfo {\n+    attribues: 0,\n+    pnfnUnwind: ptr!(0),\n+    pForwardCompat: ptr!(0),\n+    pCatchableTypeArray: ptr!(0),\n+};\n+\n+static mut CATCHABLE_TYPE_ARRAY: _CatchableTypeArray = _CatchableTypeArray {\n+    nCatchableTypes: 2,\n+    arrayOfCatchableTypes: [\n+        ptr!(0),\n+        ptr!(0),\n+    ],\n+};\n+\n+static mut CATCHABLE_TYPE1: _CatchableType = _CatchableType {\n+    properties: 1,\n+    pType: ptr!(0),\n+    thisDisplacement: _PMD {\n+        mdisp: 0,\n+        pdisp: -1,\n+        vdisp: 0,\n+    },\n+    sizeOrOffset: imp::OFFSET,\n+    copy_function: ptr!(0),\n+};\n+\n+static mut CATCHABLE_TYPE2: _CatchableType = _CatchableType {\n+    properties: 1,\n+    pType: ptr!(0),\n+    thisDisplacement: _PMD {\n+        mdisp: 0,\n+        pdisp: -1,\n+        vdisp: 0,\n+    },\n+    sizeOrOffset: imp::OFFSET,\n+    copy_function: ptr!(0),\n+};\n+\n+extern {\n+    // The leading `\\x01` byte here is actually a magical signal to LLVM to\n+    // *not* apply any other mangling like prefixing with a `_` character.\n+    //\n+    // This symbol is the vtable used by C++'s `std::type_info`. Objects of type\n+    // `std::type_info`, type descriptors, have a pointer to this table. Type\n+    // descriptors are referenced by the C++ EH structures defined above and\n+    // that we construct below.\n+    #[link_name = \"\\x01??_7type_info@@6B@\"]\n+    static TYPE_INFO_VTABLE: *const u8;\n+}\n+\n+// We use #[lang = \"msvc_try_filter\"] here as this is the type descriptor which\n+// we'll use in LLVM's `catchpad` instruction which ends up also being passed as\n+// an argument to the C++ personality function.\n+//\n+// Again, I'm not entirely sure what this is describing, it just seems to work.\n+#[cfg_attr(all(not(test), not(stage0)),\n+           lang = \"msvc_try_filter\")]\n+static mut TYPE_DESCRIPTOR1: _TypeDescriptor = _TypeDescriptor {\n+    pVFTable: &TYPE_INFO_VTABLE as *const _ as *const _,\n+    spare: 0 as *mut _,\n+    name: imp::NAME1,\n+};\n+\n+static mut TYPE_DESCRIPTOR2: _TypeDescriptor = _TypeDescriptor {\n+    pVFTable: &TYPE_INFO_VTABLE as *const _ as *const _,\n+    spare: 0 as *mut _,\n+    name: imp::NAME2,\n+};\n \n pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n-    // As mentioned above, the call stack here is preserved while the filter\n-    // functions are running, so it's ok to pass stack-local arrays into\n-    // `RaiseException`.\n+    use core::intrinsics::atomic_store;\n+\n+    // _CxxThrowException executes entirely on this stack frame, so there's no\n+    // need to otherwise transfer `data` to the heap. We just pass a stack\n+    // pointer to this function.\n     //\n-    // The two pointers of the `data` trait object are written to the stack,\n-    // passed to `RaiseException`, and they're later extracted by the filter\n-    // function below in the \"custom exception information\" section of the\n-    // `EXCEPTION_RECORD` type.\n+    // The first argument is the payload being thrown (our two pointers), and\n+    // the second argument is the type information object describing the\n+    // exception (constructed above).\n     let ptrs = mem::transmute::<_, raw::TraitObject>(data);\n-    let ptrs = [ptrs.data, ptrs.vtable];\n-    c::RaiseException(RUST_PANIC, 0, 2, ptrs.as_ptr() as *mut _);\n+    let mut ptrs = [ptrs.data as u64, ptrs.vtable as u64];\n+    let mut ptrs_ptr = ptrs.as_mut_ptr();\n+\n+    // This... may seems surprising, and justifiably so. On 32-bit MSVC the\n+    // pointers between these structure are just that, pointers. On 64-bit MSVC,\n+    // however, the pointers between structures are rather expressed as 32-bit\n+    // offsets from `__ImageBase`.\n+    //\n+    // Consequently, on 32-bit MSVC we can declare all these pointers in the\n+    // `static`s above. On 64-bit MSVC, we would have to express subtraction of\n+    // pointers in statics, which Rust does not currently allow, so we can't\n+    // actually do that.\n+    //\n+    // The next best thing, then is to fill in these structures at runtime\n+    // (panicking is already the \"slow path\" anyway). So here we reinterpret all\n+    // of these pointer fields as 32-bit integers and then store the\n+    // relevant value into it (atomically, as concurrent panics may be\n+    // happening). Technically the runtime will probably do a nonatomic read of\n+    // these fields, but in theory they never read the *wrong* value so it\n+    // shouldn't be too bad...\n+    //\n+    // In any case, we basically need to do something like this until we can\n+    // express more operations in statics (and we may never be able to).\n+    atomic_store(&mut THROW_INFO.pCatchableTypeArray as *mut _ as *mut u32,\n+                 ptr!(&CATCHABLE_TYPE_ARRAY as *const _) as u32);\n+    atomic_store(&mut CATCHABLE_TYPE_ARRAY.arrayOfCatchableTypes[0] as *mut _ as *mut u32,\n+                 ptr!(&CATCHABLE_TYPE1 as *const _) as u32);\n+    atomic_store(&mut CATCHABLE_TYPE_ARRAY.arrayOfCatchableTypes[1] as *mut _ as *mut u32,\n+                 ptr!(&CATCHABLE_TYPE2 as *const _) as u32);\n+    atomic_store(&mut CATCHABLE_TYPE1.pType as *mut _ as *mut u32,\n+                 ptr!(&TYPE_DESCRIPTOR1 as *const _) as u32);\n+    atomic_store(&mut CATCHABLE_TYPE2.pType as *mut _ as *mut u32,\n+                 ptr!(&TYPE_DESCRIPTOR2 as *const _) as u32);\n+\n+    c::_CxxThrowException(&mut ptrs_ptr as *mut _ as *mut _,\n+                          &mut THROW_INFO as *mut _ as *mut _);\n     u32::max_value()\n }\n \n-pub fn payload() -> [usize; 2] {\n+pub fn payload() -> [u64; 2] {\n     [0; 2]\n }\n \n-pub unsafe fn cleanup(payload: [usize; 2]) -> Box<Any + Send> {\n+pub unsafe fn cleanup(payload: [u64; 2]) -> Box<Any + Send> {\n     mem::transmute(raw::TraitObject {\n         data: payload[0] as *mut _,\n         vtable: payload[1] as *mut _,\n     })\n }\n \n-// This is quite a special function, and it's not literally passed in as the\n-// filter function for the `catchpad` of the `try` intrinsic. The compiler\n-// actually generates its own filter function wrapper which will delegate to\n-// this for the actual execution logic for whether the exception should be\n-// caught. The reasons for this are:\n-//\n-// * Each architecture has a slightly different ABI for the filter function\n-//   here. For example on x86 there are no arguments but on x86_64 there are\n-//   two.\n-// * This function needs access to the stack frame of the `try` intrinsic\n-//   which is using this filter as a catch pad. This is because the payload\n-//   of this exception, `Box<Any>`, needs to be transmitted to that\n-//   location.\n-//\n-// Both of these differences end up using a ton of weird llvm-specific\n-// intrinsics, so it's actually pretty difficult to express the entire\n-// filter function in Rust itself. As a compromise, the compiler takes care\n-// of all the weird LLVM-specific and platform-specific stuff, getting to\n-// the point where this function makes the actual decision about what to\n-// catch given two parameters.\n-//\n-// The first parameter is `*mut EXCEPTION_POINTERS` which is some contextual\n-// information about the exception being filtered, and the second pointer is\n-// `*mut *mut [usize; 2]` (the payload here). This value points directly\n-// into the stack frame of the `try` intrinsic itself, and we use it to copy\n-// information from the exception onto the stack.\n #[lang = \"msvc_try_filter\"]\n-#[cfg(not(test))]\n-unsafe extern fn __rust_try_filter(eh_ptrs: *mut u8,\n-                                   payload: *mut u8) -> i32 {\n-    let eh_ptrs = eh_ptrs as *mut c::EXCEPTION_POINTERS;\n-    let payload = payload as *mut *mut [usize; 2];\n-    let record = &*(*eh_ptrs).ExceptionRecord;\n-    if record.ExceptionCode != RUST_PANIC {\n-        return 0\n-    }\n-    (**payload)[0] = record.ExceptionInformation[0] as usize;\n-    (**payload)[1] = record.ExceptionInformation[1] as usize;\n-    return 1\n+#[cfg(stage0)]\n+unsafe extern fn __rust_try_filter(_eh_ptrs: *mut u8,\n+                                   _payload: *mut u8) -> i32 {\n+    return 0\n }\n \n // This is required by the compiler to exist (e.g. it's a lang item), but\n@@ -143,5 +322,5 @@ unsafe extern fn __rust_try_filter(eh_ptrs: *mut u8,\n #[lang = \"eh_personality\"]\n #[cfg(not(test))]\n fn rust_eh_personality() {\n-    unsafe { intrinsics::abort() }\n+    unsafe { ::core::intrinsics::abort() }\n }"}, {"sha": "9cca018ff111a52ba465dd43019891230454e14b", "filename": "src/libpanic_unwind/windows.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38e6e5d0a9681b53cb517a3af665059e83988c3d/src%2Flibpanic_unwind%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38e6e5d0a9681b53cb517a3af665059e83988c3d/src%2Flibpanic_unwind%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fwindows.rs?ref=38e6e5d0a9681b53cb517a3af665059e83988c3d", "patch": "@@ -14,7 +14,6 @@\n \n use libc::{c_void, c_ulong, c_long, c_ulonglong};\n \n-pub use self::EXCEPTION_DISPOSITION::*;\n pub type DWORD = c_ulong;\n pub type LONG = c_long;\n pub type ULONG_PTR = c_ulonglong;\n@@ -72,13 +71,13 @@ pub struct DISPATCHER_CONTEXT {\n }\n \n #[repr(C)]\n-#[allow(dead_code)] // we only use some variants\n pub enum EXCEPTION_DISPOSITION {\n     ExceptionContinueExecution,\n     ExceptionContinueSearch,\n     ExceptionNestedException,\n     ExceptionCollidedUnwind\n }\n+pub use self::EXCEPTION_DISPOSITION::*;\n \n extern \"system\" {\n     #[unwind]\n@@ -93,4 +92,7 @@ extern \"system\" {\n                        ReturnValue: LPVOID,\n                        OriginalContext: *const CONTEXT,\n                        HistoryTable: *const UNWIND_HISTORY_TABLE);\n+    #[unwind]\n+    pub fn _CxxThrowException(pExceptionObject: *mut c_void,\n+                              pThrowInfo: *mut u8);\n }"}, {"sha": "2b7345453d7c415dac74124ed332ce91fbd6d58a", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/38e6e5d0a9681b53cb517a3af665059e83988c3d/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38e6e5d0a9681b53cb517a3af665059e83988c3d/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=38e6e5d0a9681b53cb517a3af665059e83988c3d", "patch": "@@ -463,20 +463,18 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         // landing pads as \"landing pads for SEH\".\n         let ccx = self.ccx;\n         let tcx = ccx.tcx();\n-        let target = &ccx.sess().target.target;\n         match tcx.lang_items.eh_personality() {\n             Some(def_id) if !base::wants_msvc_seh(ccx.sess()) => {\n                 Callee::def(ccx, def_id, tcx.mk_substs(Substs::empty())).reify(ccx).val\n             }\n-            _ => if let Some(llpersonality) = ccx.eh_personality().get() {\n-                llpersonality\n-            } else {\n-                let name = if !base::wants_msvc_seh(ccx.sess()) {\n-                    \"rust_eh_personality\"\n-                } else if target.arch == \"x86\" {\n-                    \"_except_handler3\"\n+            _ => {\n+                if let Some(llpersonality) = ccx.eh_personality().get() {\n+                    return llpersonality\n+                }\n+                let name = if base::wants_msvc_seh(ccx.sess()) {\n+                    \"__CxxFrameHandler3\"\n                 } else {\n-                    \"__C_specific_handler\"\n+                    \"rust_eh_personality\"\n                 };\n                 let fty = Type::variadic_func(&[], &Type::i32(ccx));\n                 let f = declare::declare_cfn(ccx, name, fty);"}, {"sha": "e1d5a3f7ee1577748dae1af6c23211c6fe5e2328", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 34, "deletions": 101, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/38e6e5d0a9681b53cb517a3af665059e83988c3d/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38e6e5d0a9681b53cb517a3af665059e83988c3d/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=38e6e5d0a9681b53cb517a3af665059e83988c3d", "patch": "@@ -1096,9 +1096,7 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // We're generating an IR snippet that looks like:\n         //\n         //   declare i32 @rust_try(%func, %data, %ptr) {\n-        //      %slot = alloca i8*\n-        //      call @llvm.localescape(%slot)\n-        //      store %ptr, %slot\n+        //      %slot = alloca i64*\n         //      invoke %func(%data) to label %normal unwind label %catchswitch\n         //\n         //   normal:\n@@ -1108,36 +1106,54 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         //      %cs = catchswitch within none [%catchpad] unwind to caller\n         //\n         //   catchpad:\n-        //      %tok = catchpad within %cs [%rust_try_filter]\n+        //      %tok = catchpad within %cs [%type_descriptor, 0, %slot]\n+        //      %ptr[0] = %slot[0]\n+        //      %ptr[1] = %slot[1]\n         //      catchret from %tok to label %caught\n         //\n         //   caught:\n         //      ret i32 1\n         //   }\n         //\n-        // This structure follows the basic usage of the instructions in LLVM\n-        // (see their documentation/test cases for examples), but a\n-        // perhaps-surprising part here is the usage of the `localescape`\n-        // intrinsic. This is used to allow the filter function (also generated\n-        // here) to access variables on the stack of this intrinsic. This\n-        // ability enables us to transfer information about the exception being\n-        // thrown to this point, where we're catching the exception.\n+        // This structure follows the basic usage of throw/try/catch in LLVM.\n+        // For example, compile this C++ snippet to see what LLVM generates:\n+        //\n+        //      #include <stdint.h>\n+        //\n+        //      int bar(void (*foo)(void), uint64_t *ret) {\n+        //          try {\n+        //              foo();\n+        //              return 0;\n+        //          } catch(uint64_t a[2]) {\n+        //              ret[0] = a[0];\n+        //              ret[1] = a[1];\n+        //              return 1;\n+        //          }\n+        //      }\n         //\n         // More information can be found in libstd's seh.rs implementation.\n-        let slot = Alloca(bcx, Type::i8p(ccx), \"slot\");\n-        let localescape = ccx.get_intrinsic(&\"llvm.localescape\");\n-        Call(bcx, localescape, &[slot], dloc);\n-        Store(bcx, local_ptr, slot);\n+        let i64p = Type::i64(ccx).ptr_to();\n+        let slot = Alloca(bcx, i64p, \"slot\");\n         Invoke(bcx, func, &[data], normal.llbb, catchswitch.llbb, dloc);\n \n         Ret(normal, C_i32(ccx, 0), dloc);\n \n         let cs = CatchSwitch(catchswitch, None, None, 1);\n         AddHandler(catchswitch, cs, catchpad.llbb);\n \n-        let filter = generate_filter_fn(bcx.fcx, bcx.fcx.llfn);\n-        let filter = BitCast(catchpad, filter, Type::i8p(ccx));\n-        let tok = CatchPad(catchpad, cs, &[filter]);\n+        let tcx = ccx.tcx();\n+        let tydesc = match tcx.lang_items.msvc_try_filter() {\n+            Some(did) => ::consts::get_static(ccx, did).to_llref(),\n+            None => bug!(\"msvc_try_filter not defined\"),\n+        };\n+        let tok = CatchPad(catchpad, cs, &[tydesc, C_i32(ccx, 0), slot]);\n+        let addr = Load(catchpad, slot);\n+        let arg1 = Load(catchpad, addr);\n+        let val1 = C_i32(ccx, 1);\n+        let arg2 = Load(catchpad, InBoundsGEP(catchpad, addr, &[val1]));\n+        let local_ptr = BitCast(catchpad, local_ptr, i64p);\n+        Store(catchpad, arg1, local_ptr);\n+        Store(catchpad, arg2, InBoundsGEP(catchpad, local_ptr, &[val1]));\n         CatchRet(catchpad, tok, caught.llbb);\n \n         Ret(caught, C_i32(ccx, 1), dloc);\n@@ -1289,89 +1305,6 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     return rust_try\n }\n \n-// For MSVC-style exceptions (SEH), the compiler generates a filter function\n-// which is used to determine whether an exception is being caught (e.g. if it's\n-// a Rust exception or some other).\n-//\n-// This function is used to generate said filter function. The shim generated\n-// here is actually just a thin wrapper to call the real implementation in the\n-// standard library itself. For reasons as to why, see seh.rs in the standard\n-// library.\n-fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n-                                rust_try_fn: ValueRef)\n-                                -> ValueRef {\n-    let ccx = fcx.ccx;\n-    let tcx = ccx.tcx();\n-    let dloc = DebugLoc::None;\n-\n-    let rust_try_filter = match tcx.lang_items.msvc_try_filter() {\n-        Some(did) => {\n-            Callee::def(ccx, did, tcx.mk_substs(Substs::empty())).reify(ccx).val\n-        }\n-        None => bug!(\"msvc_try_filter not defined\"),\n-    };\n-\n-    let output = ty::FnOutput::FnConverging(tcx.types.i32);\n-    let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n-\n-    let frameaddress = ccx.get_intrinsic(&\"llvm.frameaddress\");\n-    let recoverfp = ccx.get_intrinsic(&\"llvm.x86.seh.recoverfp\");\n-    let localrecover = ccx.get_intrinsic(&\"llvm.localrecover\");\n-\n-    // On all platforms, once we have the EXCEPTION_POINTERS handle as well as\n-    // the base pointer, we follow the standard layout of:\n-    //\n-    //      block:\n-    //          %parentfp = call i8* llvm.x86.seh.recoverfp(@rust_try_fn, %bp)\n-    //          %arg = call i8* llvm.localrecover(@rust_try_fn, %parentfp, 0)\n-    //          %ret = call i32 @the_real_filter_function(%ehptrs, %arg)\n-    //          ret i32 %ret\n-    //\n-    // The recoverfp intrinsic is used to recover the frame pointer of the\n-    // `rust_try_fn` function, which is then in turn passed to the\n-    // `localrecover` intrinsic (pairing with the `localescape` intrinsic\n-    // mentioned above). Putting all this together means that we now have a\n-    // handle to the arguments passed into the `try` function, allowing writing\n-    // to the stack over there.\n-    //\n-    // For more info, see seh.rs in the standard library.\n-    let do_trans = |bcx: Block, ehptrs, base_pointer| {\n-        let rust_try_fn = BitCast(bcx, rust_try_fn, Type::i8p(ccx));\n-        let parentfp = Call(bcx, recoverfp, &[rust_try_fn, base_pointer], dloc);\n-        let arg = Call(bcx, localrecover,\n-                       &[rust_try_fn, parentfp, C_i32(ccx, 0)], dloc);\n-        let ret = Call(bcx, rust_try_filter, &[ehptrs, arg], dloc);\n-        Ret(bcx, ret, dloc);\n-    };\n-\n-    if ccx.tcx().sess.target.target.arch == \"x86\" {\n-        // On x86 the filter function doesn't actually receive any arguments.\n-        // Instead the %ebp register contains some contextual information.\n-        //\n-        // Unfortunately I don't know of any great documentation as to what's\n-        // going on here, all I can say is that there's a few tests cases in\n-        // LLVM's test suite which follow this pattern of instructions, so we\n-        // just do the same.\n-        gen_fn(fcx, \"__rustc_try_filter\", vec![], output, &mut |bcx| {\n-            let ebp = Call(bcx, frameaddress, &[C_i32(ccx, 1)], dloc);\n-            let exn = InBoundsGEP(bcx, ebp, &[C_i32(ccx, -20)]);\n-            let exn = Load(bcx, BitCast(bcx, exn, Type::i8p(ccx).ptr_to()));\n-            do_trans(bcx, exn, ebp);\n-        })\n-    } else if ccx.tcx().sess.target.target.arch == \"x86_64\" {\n-        // Conveniently on x86_64 the EXCEPTION_POINTERS handle and base pointer\n-        // are passed in as arguments to the filter function, so we just pass\n-        // those along.\n-        gen_fn(fcx, \"__rustc_try_filter\", vec![i8p, i8p], output, &mut |bcx| {\n-            let exn = llvm::get_param(bcx.fcx.llfn, 0);\n-            let rbp = llvm::get_param(bcx.fcx.llfn, 1);\n-            do_trans(bcx, exn, rbp);\n-        })\n-    } else {\n-        bug!(\"unknown target to generate a filter function\")\n-    }\n-}\n-\n fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n     span_err!(a, b, E0511, \"{}\", c);\n }"}, {"sha": "b85d4b330a6e336d9107747d45624b1108eb8d23", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38e6e5d0a9681b53cb517a3af665059e83988c3d/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38e6e5d0a9681b53cb517a3af665059e83988c3d/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=38e6e5d0a9681b53cb517a3af665059e83988c3d", "patch": "@@ -53,6 +53,7 @@ thread_local! { pub static PANIC_COUNT: Cell<usize> = Cell::new(0) }\n //\n // One day this may look a little less ad-hoc with the compiler helping out to\n // hook up these functions, but it is not this day!\n+#[allow(improper_ctypes)]\n extern {\n     fn __rust_maybe_catch_panic(f: fn(*mut u8),\n                                 data: *mut u8,"}, {"sha": "a73c41e7f1c85cd814e9792fc6a6a8f8e31b8dd4", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=38e6e5d0a9681b53cb517a3af665059e83988c3d", "patch": "@@ -1 +1 @@\n-Subproject commit 751345228a0ef03fd147394bb5104359b7a808be\n+Subproject commit a73c41e7f1c85cd814e9792fc6a6a8f8e31b8dd4"}, {"sha": "4017c3856c465a77672945d4f81420dd80f53ad9", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38e6e5d0a9681b53cb517a3af665059e83988c3d/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/38e6e5d0a9681b53cb517a3af665059e83988c3d/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=38e6e5d0a9681b53cb517a3af665059e83988c3d", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2016-04-26\n+2016-04-28"}]}