{"sha": "624421aa3d5d09fd59834c524f1909120685232d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNDQyMWFhM2Q1ZDA5ZmQ1OTgzNGM1MjRmMTkwOTEyMDY4NTIzMmQ=", "commit": {"author": {"name": "gareth", "email": "gareth@gareth-N56VM.(none)", "date": "2012-12-29T18:25:09Z"}, "committer": {"name": "gareth", "email": "gareth@gareth-N56VM.(none)", "date": "2012-12-29T18:25:09Z"}, "message": "Simplify idents_to_str and use it in more places.", "tree": {"sha": "62e3738231df155b490db2d7a69070fe317f7d0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62e3738231df155b490db2d7a69070fe317f7d0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/624421aa3d5d09fd59834c524f1909120685232d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/624421aa3d5d09fd59834c524f1909120685232d", "html_url": "https://github.com/rust-lang/rust/commit/624421aa3d5d09fd59834c524f1909120685232d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/624421aa3d5d09fd59834c524f1909120685232d/comments", "author": null, "committer": null, "parents": [{"sha": "d68954efa09c4cbd16a07d4bd93de688d64074c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d68954efa09c4cbd16a07d4bd93de688d64074c3", "html_url": "https://github.com/rust-lang/rust/commit/d68954efa09c4cbd16a07d4bd93de688d64074c3"}], "stats": {"total": 56, "additions": 10, "deletions": 46}, "files": [{"sha": "ffb696ec4f946a5d99038585d7bf5135705ab01c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 46, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/624421aa3d5d09fd59834c524f1909120685232d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/624421aa3d5d09fd59834c524f1909120685232d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=624421aa3d5d09fd59834c524f1909120685232d", "patch": "@@ -2106,19 +2106,8 @@ impl Resolver {\n     }\n \n     fn idents_to_str(idents: ~[ident]) -> ~str {\n-        // XXX: str::connect should do this.\n-        let mut result = ~\"\";\n-        let mut first = true;\n-        for idents.each() |ident| {\n-            if first {\n-                first = false;\n-            } else {\n-                result += ~\"::\";\n-            }\n-            result += self.session.str_of(*ident);\n-        }\n-        // XXX: Shouldn't copy here. We need string builder functionality.\n-        return result;\n+        let ident_strs = idents.map(|&ident| self.session.str_of(ident));\n+        return str::connect(ident_strs, \"::\");\n     }\n \n     fn import_directive_subclass_to_str(subclass: ImportDirectiveSubclass)\n@@ -4524,17 +4513,14 @@ impl Resolver {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `%s` \\\n                                 (id %d)\",\n-                               connect(path.idents.map(\n-                                   |x| self.session.str_of(*x)), ~\"::\"),\n+                               self.idents_to_str(path.idents),\n                                path_id);\n                         self.record_def(path_id, def);\n                     }\n                     None => {\n                         self.session.span_err\n                             (ty.span, fmt!(\"use of undeclared type name `%s`\",\n-                                           connect(path.idents.map(\n-                                               |x| self.session.str_of(*x)),\n-                                                   ~\"::\")));\n+                                           self.idents_to_str(path.idents)));\n                     }\n                 }\n             }\n@@ -4728,9 +4714,7 @@ impl Resolver {\n                             self.session.span_err(\n                                 path.span,\n                                 fmt!(\"`%s` does not name a structure\",\n-                                     connect(path.idents.map(\n-                                         |x| self.session.str_of(*x)),\n-                                             ~\"::\")));\n+                                     self.idents_to_str(path.idents)));\n                         }\n                     }\n                 }\n@@ -5126,14 +5110,11 @@ impl Resolver {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `%s`\",\n-                               connect(path.idents.map(\n-                                   |x| self.session.str_of(*x)), ~\"::\"));\n+                               self.idents_to_str(path.idents));\n                         self.record_def(expr.id, def);\n                     }\n                     None => {\n-                        let wrong_name =\n-                            connect(path.idents.map(\n-                                |x| self.session.str_of(*x)), ~\"::\") ;\n+                        let wrong_name = self.idents_to_str(path.idents);\n                         if self.name_exists_in_scope_struct(wrong_name) {\n                             self.session.span_err(expr.span,\n                                         fmt!(\"unresolved name: `%s`. \\\n@@ -5193,9 +5174,7 @@ impl Resolver {\n                         self.session.span_err(\n                             path.span,\n                             fmt!(\"`%s` does not name a structure\",\n-                                 connect(path.idents.map(\n-                                     |x| self.session.str_of(*x)),\n-                                         ~\"::\")));\n+                                 self.idents_to_str(path.idents)));\n                     }\n                 }\n \n@@ -5514,7 +5493,7 @@ impl Resolver {\n     // hit.\n     //\n \n-    /// A somewhat inefficient routine to print out the name of a module.\n+    /// A somewhat inefficient routine to obtain the name of a module.\n     fn module_to_str(module_: @Module) -> ~str {\n         let idents = DVec();\n         let mut current_module = module_;\n@@ -5537,22 +5516,7 @@ impl Resolver {\n         if idents.len() == 0 {\n             return ~\"???\";\n         }\n-\n-        let mut string = ~\"\";\n-        let mut i = idents.len() - 1;\n-        loop {\n-            if i < idents.len() - 1 {\n-                string += ~\"::\";\n-            }\n-            string += self.session.str_of(idents.get_elt(i));\n-\n-            if i == 0 {\n-                break;\n-            }\n-            i -= 1;\n-        }\n-\n-        return string;\n+        return self.idents_to_str(vec::reversed(idents.get()));\n     }\n \n     fn dump_module(module_: @Module) {"}]}