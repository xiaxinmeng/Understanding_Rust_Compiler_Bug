{"sha": "e91f8b5db2dbfc8c1e4f835990b9d1f08a661430", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MWY4YjVkYjJkYmZjOGMxZTRmODM1OTkwYjlkMWYwOGE2NjE0MzA=", "commit": {"author": {"name": "Jesse Ruderman", "email": "jruderman@gmail.com", "date": "2011-07-08T09:16:46Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-11T00:05:25Z"}, "message": "Pieces of a fuzzer, WIP", "tree": {"sha": "4e92efcf30aa28c08b155480eede24b9f1cad7be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e92efcf30aa28c08b155480eede24b9f1cad7be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e91f8b5db2dbfc8c1e4f835990b9d1f08a661430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e91f8b5db2dbfc8c1e4f835990b9d1f08a661430", "html_url": "https://github.com/rust-lang/rust/commit/e91f8b5db2dbfc8c1e4f835990b9d1f08a661430", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e91f8b5db2dbfc8c1e4f835990b9d1f08a661430/comments", "author": {"login": "jruderman", "id": 692547, "node_id": "MDQ6VXNlcjY5MjU0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/692547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jruderman", "html_url": "https://github.com/jruderman", "followers_url": "https://api.github.com/users/jruderman/followers", "following_url": "https://api.github.com/users/jruderman/following{/other_user}", "gists_url": "https://api.github.com/users/jruderman/gists{/gist_id}", "starred_url": "https://api.github.com/users/jruderman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jruderman/subscriptions", "organizations_url": "https://api.github.com/users/jruderman/orgs", "repos_url": "https://api.github.com/users/jruderman/repos", "events_url": "https://api.github.com/users/jruderman/events{/privacy}", "received_events_url": "https://api.github.com/users/jruderman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d3513eaee512e0143cd75927b8ff56a5bf98152", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d3513eaee512e0143cd75927b8ff56a5bf98152", "html_url": "https://github.com/rust-lang/rust/commit/6d3513eaee512e0143cd75927b8ff56a5bf98152"}], "stats": {"total": 220, "additions": 180, "deletions": 40}, "files": [{"sha": "e3196c33e2134a3cf1b6d14adb767c84a110e772", "filename": "src/fuzzer/ast_match.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e91f8b5db2dbfc8c1e4f835990b9d1f08a661430/src%2Ffuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91f8b5db2dbfc8c1e4f835990b9d1f08a661430/src%2Ffuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fast_match.rs?ref=e91f8b5db2dbfc8c1e4f835990b9d1f08a661430", "patch": "@@ -0,0 +1,38 @@\n+use std;\n+import std::ivec;\n+\n+fn ivec_equal[T](&T[] v, &T[] u, fn (&T, &T) -> bool element_equality_test) -> bool {\n+    auto Lv = ivec::len(v);\n+    if (Lv != ivec::len(u)) {\n+        ret false;\n+    }\n+    auto i = 0u;\n+    while (i < Lv) {\n+        if (!element_equality_test(v.(i), u.(i))) {\n+            ret false;\n+        }\n+        i += 1u;\n+    }\n+    ret true;\n+}\n+\n+fn builtin_equal[T](&T a, &T b) -> bool {\n+    ret a == b;\n+}\n+\n+fn main() {\n+    // These pass\n+    assert  builtin_equal(5, 5);\n+    assert !builtin_equal(5, 4);\n+\n+    // This passes\n+    assert !ivec_equal(~[5, 5], ~[5], builtin_equal);\n+\n+    // These crash\n+    // https://github.com/graydon/rust/issues/633\n+    assert !ivec_equal(~[5, 5], ~[5, 4], builtin_equal);\n+    assert !ivec_equal(~[5, 5], ~[4, 5], builtin_equal);\n+    assert  ivec_equal(~[5, 5], ~[5, 5], builtin_equal);\n+\n+    log_err \"Pass\";\n+}"}, {"sha": "f7bc514a700a85385c85101e1827946933545bb8", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e91f8b5db2dbfc8c1e4f835990b9d1f08a661430/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91f8b5db2dbfc8c1e4f835990b9d1f08a661430/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=e91f8b5db2dbfc8c1e4f835990b9d1f08a661430", "patch": "@@ -1,60 +1,64 @@\n+use std;\n+use rustc;\n+\n import std::fs;\n import std::getopts;\n import std::getopts::optopt;\n import std::getopts::opt_present;\n import std::getopts::opt_str;\n import std::io;\n import std::vec;\n+import std::ivec;\n+import std::str;\n \n-type src_gen = iter() -> str;\n-\n-iter dir_src_gen(str dir) -> str {\n-}\n-\n-fn usage(str binary) {\n-    io::stdout().write_line(\"usage\");\n-}\n+import rustc::back::link;\n+import rustc::syntax::ast;\n+import driver = rustc::driver::rustc; // see https://github.com/graydon/rust/issues/624\n+import rustc::driver::session;\n \n-type session = rec(str srcdir);\n \n-fn make_session(vec[str] args) -> session {\n-    // Directory of rust source files to use as input\n-    auto opt_src = \"src\";\n-\n-    auto binary = vec::shift[str](args);\n-    auto opts  = [optopt(opt_src)];\n-    auto match;\n-    alt (getopts::getopts(args, opts)) {\n-        case (getopts::failure(?f)) {\n-            log_err #fmt(\"error: %s\", getopts::fail_str(f));\n-            fail;\n+fn find_rust_files(&mutable str[] files, str root) {\n+    for (str filename in fs::list_dir(root)) {\n+        if (str::ends_with(filename, \".rs\")) {\n+           files += ~[filename];\n         }\n-        case (getopts::success(?m)) {\n-            match = m;\n-        }\n-    };\n-\n-    if (!opt_present(match, opt_src)) {\n-        usage(binary);\n-        fail;\n     }\n+}\n \n-    auto srcdir = opt_str(match, opt_src);\n+fn main(vec[str] args) {\n+    auto files = ~[];\n+    auto root = \"/Users/jruderman/code/rust/src/lib/\"; // XXX\n+    find_rust_files(files, root); // not using driver::time here because that currently screws with passing-a-mutable-array\n \n-    ret rec(srcdir = srcdir);\n-}\n+    auto binary = vec::shift[str](args);\n+    auto binary_dir = fs::dirname(binary);\n \n-fn log_session(session sess) {\n-    log #fmt(\"srcdir: %s\", sess.srcdir);\n-}\n+    let @session::options sopts =\n+        @rec(library=false,\n+             static=false,\n+             optimize=0u,\n+             debuginfo=false,\n+             verify=true,\n+             run_typestate=true,\n+             save_temps=false,\n+             stats=false,\n+             time_passes=false,\n+             time_llvm_passes=false,\n+             output_type=link::output_type_bitcode,\n+             library_search_paths=[binary_dir + \"/lib\"],\n+             sysroot=driver::get_default_sysroot(binary),\n+             cfg=~[],\n+             test=false);\n \n-fn run_session(session sess) {\n-}\n+    let session::session sess = driver::build_session(sopts);\n \n-fn main(vec[str] args) {\n-    auto sess = make_session(args);\n-    log_session(sess);\n-    run_session(sess);\n+    log_err ivec::len(files);\n+    for (str file in files) {\n+        log_err file;\n+        // Can't use parse_input here because of https://github.com/graydon/rust/issues/632 :(\n+        //auto crate = driver::parse_input(sess, ~[], file);\n+        //let @ast::crate crate = driver::time(true, \"parsing \" + file, bind driver::parse_input(sess, ~[], file));\n+    }\n }\n \n // Local Variables:"}, {"sha": "af9bb7f4d64acfef369d173666dcca3f8908e26c", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e91f8b5db2dbfc8c1e4f835990b9d1f08a661430/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91f8b5db2dbfc8c1e4f835990b9d1f08a661430/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=e91f8b5db2dbfc8c1e4f835990b9d1f08a661430", "patch": "@@ -0,0 +1,98 @@\n+/*\n+\n+Idea: provide functions for 'exhaustive' and 'random' modification of vecs.\n+\n+  two functions, \"return all edits\" and \"return a random edit\" <-- leaning toward this model\n+    or\n+  two functions, \"return the number of possible edits\" and \"return edit #n\"\n+\n+It would be nice if this could be data-driven, so the two functions could share information:\n+  type vec_modifier = rec(fn (&int[] v, uint i) -> int[] fun, uint lo, uint di);\n+  const vec_modifier[] vec_modifiers = ~[rec(fun=vec_omit, 0u, 1u), ...];\n+But that gives me \"error: internal compiler error unimplemented consts that's not a plain literal\".\n+https://github.com/graydon/rust/issues/570\n+\n+vec_edits is not an iter because iters might go away and:\n+https://github.com/graydon/rust/issues/639\n+\n+vec_omit and friends are not type-parameterized because:\n+https://github.com/graydon/rust/issues/640\n+\n+*/\n+\n+use std;\n+import std::ivec;\n+import std::ivec::slice;\n+import std::ivec::len;\n+import std::int;\n+\n+//fn vec_reverse(&int[] v) -> int[] { ... }\n+\n+fn vec_omit   (&int[] v, uint i) -> int[] { slice(v, 0u, i) +                      slice(v, i+1u, len(v)) }\n+fn vec_dup    (&int[] v, uint i) -> int[] { slice(v, 0u, i) + ~[v.(i)]           + slice(v, i,    len(v)) }\n+fn vec_swadj  (&int[] v, uint i) -> int[] { slice(v, 0u, i) + ~[v.(i+1u), v.(i)] + slice(v, i+2u, len(v)) }\n+fn vec_prefix (&int[] v, uint i) -> int[] { slice(v, 0u, i) }\n+fn vec_suffix (&int[] v, uint i) -> int[] { slice(v, i, len(v)) }\n+\n+fn vec_poke   (&int[] v, uint i, int x) -> int[] { slice(v, 0u, i) + ~[x] + slice(v, i+1u, len(v)) }\n+fn vec_insert (&int[] v, uint i, int x) -> int[] { slice(v, 0u, i) + ~[x] + slice(v, i, len(v)) }\n+\n+// Iterates over 0...length, skipping the specified number on each side.\n+iter ix(uint skip_low, uint skip_high, uint length) -> uint { let uint i = skip_low; while (i + skip_high <= length) { put i; i += 1u; } }\n+\n+// Returns a bunch of modified versions of v, some of which introduce new elements (borrowed from xs).\n+fn vec_edits(&int[] v, &int[] xs) -> int[][] {\n+    let int[][] edits = ~[];\n+    let uint Lv = len(v);\n+\n+    if (Lv != 1u) { edits += ~[~[]]; } // When Lv == 1u, this is redundant with omit\n+    //if (Lv >= 3u) { edits += ~[vec_reverse(v)]; }\n+\n+    for each (uint i in ix(0u, 1u, Lv)) { edits += ~[vec_omit  (v, i)]; }\n+    for each (uint i in ix(0u, 1u, Lv)) { edits += ~[vec_dup   (v, i)]; }\n+    for each (uint i in ix(0u, 2u, Lv)) { edits += ~[vec_swadj (v, i)]; }\n+    for each (uint i in ix(1u, 2u, Lv)) { edits += ~[vec_prefix(v, i)]; }\n+    for each (uint i in ix(2u, 1u, Lv)) { edits += ~[vec_suffix(v, i)]; }\n+\n+    for each (uint j in ix(0u, 1u, len(xs))) {\n+      for each (uint i in ix(0u, 1u, Lv)) { edits += ~[vec_poke  (v, i, xs.(j))]; }\n+      for each (uint i in ix(0u, 0u, Lv)) { edits += ~[vec_insert(v, i, xs.(j))]; }\n+    }\n+\n+    edits\n+}\n+\n+// Would be nice if this were built in: https://github.com/graydon/rust/issues/424\n+fn vec_to_str(&int[] v) -> str {\n+    auto i = 0u;\n+    auto s = \"[\";\n+    while (i < len(v)) {\n+        s += int::str(v.(i));\n+        if (i + 1u < len(v)) {\n+            s += \", \"\n+        }\n+        i += 1u;\n+    }\n+    ret s + \"]\";\n+}\n+\n+fn show_edits(&int[] a, &int[] xs) {\n+    log_err \"=== Edits of \" + vec_to_str(a) + \" ===\";\n+    auto b = vec_edits(a, xs);\n+    for each (uint i in ix(0u, 1u, len(b))) {\n+        log_err vec_to_str(b.(i));\n+    }\n+}\n+\n+fn demo_edits() {\n+    auto xs = ~[7, 8];\n+    show_edits(~[], xs);\n+    show_edits(~[1], xs);\n+    show_edits(~[1,2], xs);\n+    show_edits(~[1,2,3], xs);\n+    show_edits(~[1,2,3,4], xs);\n+}\n+\n+fn main() {\n+    demo_edits();\n+}"}]}