{"sha": "c35b2bd226736925961ca6853b2ef29e8094cd90", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNWIyYmQyMjY3MzY5MjU5NjFjYTY4NTNiMmVmMjllODA5NGNkOTA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-20T20:27:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-21T23:08:11Z"}, "message": "trans: Move rust_try into the compiler\n\nThis commit moves the IR files in the distribution, rust_try.ll,\nrust_try_msvc_64.ll, and rust_try_msvc_32.ll into the compiler from the main\ndistribution. There's a few reasons for this change:\n\n* LLVM changes its IR syntax from time to time, so it's very difficult to\n  have these files build across many LLVM versions simultaneously. We'll likely\n  want to retain this ability for quite some time into the future.\n* The implementation of these files is closely tied to the compiler and runtime\n  itself, so it makes sense to fold it into a location which can do more\n  platform-specific checks for various implementation details (such as MSVC 32\n  vs 64-bit).\n* This removes LLVM as a build-time dependency of the standard library. This may\n  end up becoming very useful if we move towards building the standard library\n  with Cargo.\n\nIn the immediate future, however, this commit should restore compatibility with\nLLVM 3.5 and 3.6.", "tree": {"sha": "5fdbd08fb24f5e4ca71dbc92d9cae1c13f988898", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fdbd08fb24f5e4ca71dbc92d9cae1c13f988898"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c35b2bd226736925961ca6853b2ef29e8094cd90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c35b2bd226736925961ca6853b2ef29e8094cd90", "html_url": "https://github.com/rust-lang/rust/commit/c35b2bd226736925961ca6853b2ef29e8094cd90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c35b2bd226736925961ca6853b2ef29e8094cd90/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39d4faf989cea236e2e1669ab85d060d1c62cd85", "url": "https://api.github.com/repos/rust-lang/rust/commits/39d4faf989cea236e2e1669ab85d060d1c62cd85", "html_url": "https://github.com/rust-lang/rust/commit/39d4faf989cea236e2e1669ab85d060d1c62cd85"}], "stats": {"total": 847, "additions": 519, "deletions": 328}, "files": [{"sha": "69277e774e43bf99e41f767dfd70a4c1608c53d9", "filename": "mk/rt.mk", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -54,15 +54,6 @@ NATIVE_DEPS_miniz_$(1) = miniz.c\n NATIVE_DEPS_rust_builtin_$(1) := rust_builtin.c \\\n \t\t\trust_android_dummy.c\n NATIVE_DEPS_rustrt_native_$(1) := arch/$$(HOST_$(1))/record_sp.S\n-ifeq ($$(findstring msvc,$(1)),msvc)\n-ifeq ($$(findstring i686,$(1)),i686)\n-NATIVE_DEPS_rustrt_native_$(1) += rust_try_msvc_32.ll\n-else\n-NATIVE_DEPS_rustrt_native_$(1) += rust_try_msvc_64.ll\n-endif\n-else\n-NATIVE_DEPS_rustrt_native_$(1) += rust_try.ll\n-endif\n NATIVE_DEPS_rust_test_helpers_$(1) := rust_test_helpers.c\n NATIVE_DEPS_morestack_$(1) := arch/$$(HOST_$(1))/morestack.S\n \n@@ -76,14 +67,6 @@ NATIVE_DEPS_morestack_$(1) := arch/$$(HOST_$(1))/morestack.S\n \n RT_OUTPUT_DIR_$(1) := $(1)/rt\n \n-$$(RT_OUTPUT_DIR_$(1))/%.o: $(S)src/rt/%.ll $$(MKFILE_DEPS) \\\n-\t    $$(LLVM_CONFIG_$$(CFG_BUILD))\n-\t@mkdir -p $$(@D)\n-\t@$$(call E, compile: $$@)\n-\t$$(Q)$$(LLC_$$(CFG_BUILD)) $$(CFG_LLC_FLAGS_$(1)) \\\n-\t    -filetype=obj -mtriple=$$(CFG_LLVM_TARGET_$(1)) \\\n-\t    -relocation-model=pic -o $$@ $$<\n-\n $$(RT_OUTPUT_DIR_$(1))/%.o: $(S)src/rt/%.c $$(MKFILE_DEPS)\n \t@mkdir -p $$(@D)\n \t@$$(call E, compile: $$@)\n@@ -122,7 +105,6 @@ define THIRD_PARTY_LIB\n OBJS_$(2)_$(1) := $$(NATIVE_DEPS_$(2)_$(1):%=$$(RT_OUTPUT_DIR_$(1))/%)\n OBJS_$(2)_$(1) := $$(OBJS_$(2)_$(1):.c=.o)\n OBJS_$(2)_$(1) := $$(OBJS_$(2)_$(1):.cpp=.o)\n-OBJS_$(2)_$(1) := $$(OBJS_$(2)_$(1):.ll=.o)\n OBJS_$(2)_$(1) := $$(OBJS_$(2)_$(1):.S=.o)\n NATIVE_$(2)_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),$(2))\n $$(RT_OUTPUT_DIR_$(1))/$$(NATIVE_$(2)_$(1)): $$(OBJS_$(2)_$(1))"}, {"sha": "ef022179772c4cd4c9a60eb53a143e6d1eca9291", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -602,4 +602,10 @@ extern \"rust-intrinsic\" {\n     /// Returns the value of the discriminant for the variant in 'v',\n     /// cast to a `u64`; if `T` has no discriminant, returns 0.\n     pub fn discriminant_value<T>(v: &T) -> u64;\n+\n+    /// Rust's \"try catch\" construct which invokes the function pointer `f` with\n+    /// the data pointer `data`, returning the exception payload if an exception\n+    /// is thrown (aka the thread panics).\n+    #[cfg(not(stage0))]\n+    pub fn try(f: fn(*mut u8), data: *mut u8) -> *mut u8;\n }"}, {"sha": "f7cd94f30af12e2a30643fbc25df39201109893b", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -326,6 +326,8 @@ lets_do_this! {\n     StartFnLangItem,                 \"start\",                   start_fn;\n \n     EhPersonalityLangItem,           \"eh_personality\",          eh_personality;\n+    EhPersonalityCatchLangItem,      \"eh_personality_catch\",    eh_personality_catch;\n+    MSVCTryFilterLangItem,           \"msvc_try_filter\",         msvc_try_filter;\n \n     ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;\n     OwnedBoxLangItem,                \"owned_box\",               owned_box;"}, {"sha": "72fda9a7ae06ac236f82eda442dc6f2c4bf42f95", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -119,7 +119,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n ) }\n \n weak_lang_items! {\n-    panic_fmt,          PanicFmtLangItem,            rust_begin_unwind;\n+    panic_fmt,          PanicFmtLangItem,           rust_begin_unwind;\n     stack_exhausted,    StackExhaustedLangItem,     rust_stack_exhausted;\n     eh_personality,     EhPersonalityLangItem,      rust_eh_personality;\n }"}, {"sha": "83f8619c5eeabd1e2976b976eae81da9891b3adf", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -134,7 +134,7 @@ pub enum DLLStorageClassTypes {\n }\n \n bitflags! {\n-    flags Attribute : u32 {\n+    flags Attribute : u64 {\n         const ZExt            = 1 << 0,\n         const SExt            = 1 << 1,\n         const NoReturn        = 1 << 2,\n@@ -161,6 +161,7 @@ bitflags! {\n         const ReturnsTwice    = 1 << 29,\n         const UWTable         = 1 << 30,\n         const NonLazyBind     = 1 << 31,\n+        const OptimizeNone    = 1 << 42,\n     }\n }\n \n@@ -2193,7 +2194,8 @@ pub fn ConstFCmp(pred: RealPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n \n pub fn SetFunctionAttribute(fn_: ValueRef, attr: Attribute) {\n     unsafe {\n-        LLVMAddFunctionAttribute(fn_, FunctionIndex as c_uint, attr.bits() as uint64_t)\n+        LLVMAddFunctionAttribute(fn_, FunctionIndex as c_uint,\n+                                 attr.bits() as uint64_t)\n     }\n }\n "}, {"sha": "5a3fcc8d27f3cb8bf422c6d6e8dabc579eb89d66", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -1042,6 +1042,10 @@ pub fn LandingPad(cx: Block, ty: Type, pers_fn: ValueRef,\n     B(cx).landing_pad(ty, pers_fn, num_clauses, cx.fcx.llfn)\n }\n \n+pub fn AddClause(cx: Block, landing_pad: ValueRef, clause: ValueRef) {\n+    B(cx).add_clause(landing_pad, clause)\n+}\n+\n pub fn SetCleanup(cx: Block, landing_pad: ValueRef) {\n     B(cx).set_cleanup(landing_pad)\n }"}, {"sha": "107ae378ac4463925e70fd978af74f270b176dcf", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -937,6 +937,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn add_clause(&self, landing_pad: ValueRef, clause: ValueRef) {\n+        unsafe {\n+            llvm::LLVMAddClause(landing_pad, clause);\n+        }\n+    }\n+\n     pub fn set_cleanup(&self, landing_pad: ValueRef) {\n         self.count_insn(\"setcleanup\");\n         unsafe {"}, {"sha": "7900000d3a9df1d33478acb7ad2b119721182047", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -620,16 +620,17 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }, ArgVals(args), dest)\n }\n \n-/// This behemoth of a function translates function calls. Unfortunately, in order to generate more\n-/// efficient LLVM output at -O0, it has quite a complex signature (refactoring this into two\n-/// functions seems like a good idea).\n+/// This behemoth of a function translates function calls. Unfortunately, in\n+/// order to generate more efficient LLVM output at -O0, it has quite a complex\n+/// signature (refactoring this into two functions seems like a good idea).\n ///\n-/// In particular, for lang items, it is invoked with a dest of None, and in that case the return\n-/// value contains the result of the fn. The lang item must not return a structural type or else\n-/// all heck breaks loose.\n+/// In particular, for lang items, it is invoked with a dest of None, and in\n+/// that case the return value contains the result of the fn. The lang item must\n+/// not return a structural type or else all heck breaks loose.\n ///\n-/// For non-lang items, `dest` is always Some, and hence the result is written into memory\n-/// somewhere. Nonetheless we return the actual return value of the function.\n+/// For non-lang items, `dest` is always Some, and hence the result is written\n+/// into memory somewhere. Nonetheless we return the actual return value of the\n+/// function.\n pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                            debug_loc: DebugLoc,\n                                            get_callee: F,"}, {"sha": "37722d5a549fe7f7a693122ac241b8da0f342f96", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 50, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -122,11 +122,9 @@ pub use self::Heap::*;\n use llvm::{BasicBlockRef, ValueRef};\n use trans::base;\n use trans::build;\n-use trans::callee;\n use trans::common;\n-use trans::common::{Block, FunctionContext, ExprId, NodeIdAndSpan};\n+use trans::common::{Block, FunctionContext, NodeIdAndSpan};\n use trans::debuginfo::{DebugLoc, ToDebugLoc};\n-use trans::declare;\n use trans::glue;\n use middle::region;\n use trans::type_::Type;\n@@ -833,53 +831,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                                     &[Type::i8p(self.ccx), Type::i32(self.ccx)],\n                                     false);\n \n-        // The exception handling personality function.\n-        //\n-        // If our compilation unit has the `eh_personality` lang item somewhere\n-        // within it, then we just need to translate that. Otherwise, we're\n-        // building an rlib which will depend on some upstream implementation of\n-        // this function, so we just codegen a generic reference to it. We don't\n-        // specify any of the types for the function, we just make it a symbol\n-        // that LLVM can later use.\n-        //\n-        // Note that MSVC is a little special here in that we don't use the\n-        // `eh_personality` lang item at all. Currently LLVM has support for\n-        // both Dwarf and SEH unwind mechanisms for MSVC targets and uses the\n-        // *name of the personality function* to decide what kind of unwind side\n-        // tables/landing pads to emit. It looks like Dwarf is used by default,\n-        // injecting a dependency on the `_Unwind_Resume` symbol for resuming\n-        // an \"exception\", but for MSVC we want to force SEH. This means that we\n-        // can't actually have the personality function be our standard\n-        // `rust_eh_personality` function, but rather we wired it up to the\n-        // CRT's custom personality function, which forces LLVM to consider\n-        // landing pads as \"landing pads for SEH\".\n-        let target = &self.ccx.sess().target.target;\n-        let llpersonality = match pad_bcx.tcx().lang_items.eh_personality() {\n-            Some(def_id) if !target.options.is_like_msvc => {\n-                callee::trans_fn_ref(pad_bcx.ccx(), def_id, ExprId(0),\n-                                     pad_bcx.fcx.param_substs).val\n-            }\n-            _ => {\n-                let mut personality = self.ccx.eh_personality().borrow_mut();\n-                match *personality {\n-                    Some(llpersonality) => llpersonality,\n-                    None => {\n-                        let name = if !target.options.is_like_msvc {\n-                            \"rust_eh_personality\"\n-                        } else if target.arch == \"x86\" {\n-                            \"_except_handler3\"\n-                        } else {\n-                            \"__C_specific_handler\"\n-                        };\n-                        let fty = Type::variadic_func(&[], &Type::i32(self.ccx));\n-                        let f = declare::declare_cfn(self.ccx, name, fty,\n-                                                     self.ccx.tcx().types.i32);\n-                        *personality = Some(f);\n-                        f\n-                    }\n-                }\n-            }\n-        };\n+        let llpersonality = pad_bcx.fcx.eh_personality();\n \n         // The only landing pad clause will be 'cleanup'\n         let llretval = build::LandingPad(pad_bcx, llretty, llpersonality, 1);"}, {"sha": "f00029ec2ff932a8d762423017949e92f963ee36", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -163,11 +163,10 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n \n-    // Currently there\u2019s only a single user of get_or_create_declaration_if_closure and it\n-    // unconditionally defines the function, therefore we use define_* here.\n-    let llfn = declare::define_internal_rust_fn(ccx, &symbol[..], function_type).unwrap_or_else(||{\n-        ccx.sess().bug(&format!(\"symbol `{}` already defined\", symbol));\n-    });\n+    // Currently there\u2019s only a single user of\n+    // get_or_create_declaration_if_closure and it unconditionally defines the\n+    // function, therefore we use define_* here.\n+    let llfn = declare::define_internal_rust_fn(ccx, &symbol[..], function_type);\n \n     // set an inline hint for all closures\n     attributes::inline(llfn, attributes::InlineAttr::Hint);\n@@ -388,11 +387,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Create the by-value helper.\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, llonce_fn_ty, \"once_shim\");\n-    let lloncefn = declare::define_internal_rust_fn(ccx, &function_name[..], llonce_fn_ty)\n-        .unwrap_or_else(||{\n-            ccx.sess().bug(&format!(\"symbol `{}` already defined\", function_name));\n-        });\n-\n+    let lloncefn = declare::define_internal_rust_fn(ccx, &function_name,\n+                                                    llonce_fn_ty);\n     let sig = tcx.erase_late_bound_regions(&llonce_bare_fn_ty.sig);\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();"}, {"sha": "1e87053c2ae63e422e35d86d3fbffbd5e1cdbb9b", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -25,6 +25,7 @@ use middle::lang_items::LangItem;\n use middle::subst::{self, Substs};\n use trans::base;\n use trans::build;\n+use trans::callee;\n use trans::cleanup;\n use trans::consts;\n use trans::datum;\n@@ -479,6 +480,56 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n         type_needs_drop_given_env(self.ccx.tcx(), ty, &self.param_env)\n     }\n+\n+    pub fn eh_personality(&self) -> ValueRef {\n+        // The exception handling personality function.\n+        //\n+        // If our compilation unit has the `eh_personality` lang item somewhere\n+        // within it, then we just need to translate that. Otherwise, we're\n+        // building an rlib which will depend on some upstream implementation of\n+        // this function, so we just codegen a generic reference to it. We don't\n+        // specify any of the types for the function, we just make it a symbol\n+        // that LLVM can later use.\n+        //\n+        // Note that MSVC is a little special here in that we don't use the\n+        // `eh_personality` lang item at all. Currently LLVM has support for\n+        // both Dwarf and SEH unwind mechanisms for MSVC targets and uses the\n+        // *name of the personality function* to decide what kind of unwind side\n+        // tables/landing pads to emit. It looks like Dwarf is used by default,\n+        // injecting a dependency on the `_Unwind_Resume` symbol for resuming\n+        // an \"exception\", but for MSVC we want to force SEH. This means that we\n+        // can't actually have the personality function be our standard\n+        // `rust_eh_personality` function, but rather we wired it up to the\n+        // CRT's custom personality function, which forces LLVM to consider\n+        // landing pads as \"landing pads for SEH\".\n+        let target = &self.ccx.sess().target.target;\n+        match self.ccx.tcx().lang_items.eh_personality() {\n+            Some(def_id) if !target.options.is_like_msvc => {\n+                callee::trans_fn_ref(self.ccx, def_id, ExprId(0),\n+                                     self.param_substs).val\n+            }\n+            _ => {\n+                let mut personality = self.ccx.eh_personality().borrow_mut();\n+                match *personality {\n+                    Some(llpersonality) => llpersonality,\n+                    None => {\n+                        let name = if !target.options.is_like_msvc {\n+                            \"rust_eh_personality\"\n+                        } else if target.arch == \"x86\" {\n+                            \"_except_handler3\"\n+                        } else {\n+                            \"__C_specific_handler\"\n+                        };\n+                        let fty = Type::variadic_func(&[], &Type::i32(self.ccx));\n+                        let f = declare::declare_cfn(self.ccx, name, fty,\n+                                                     self.ccx.tcx().types.i32);\n+                        *personality = Some(f);\n+                        f\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n // Basic block context.  We create a block context for each basic block"}, {"sha": "760a4ae827aac66ef86adb86d07278e3d26b7f58", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -142,6 +142,7 @@ pub struct LocalCrateContext<'tcx> {\n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n     eh_personality: RefCell<Option<ValueRef>>,\n+    rust_try_fn: RefCell<Option<ValueRef>>,\n \n     intrinsics: RefCell<FnvHashMap<&'static str, ValueRef>>,\n \n@@ -461,6 +462,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 closure_vals: RefCell::new(FnvHashMap()),\n                 dbg_cx: dbg_cx,\n                 eh_personality: RefCell::new(None),\n+                rust_try_fn: RefCell::new(None),\n                 intrinsics: RefCell::new(FnvHashMap()),\n                 n_llvm_insns: Cell::new(0),\n                 trait_cache: RefCell::new(FnvHashMap()),\n@@ -726,6 +728,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.eh_personality\n     }\n \n+    pub fn rust_try_fn<'a>(&'a self) -> &'a RefCell<Option<ValueRef>> {\n+        &self.local.rust_try_fn\n+    }\n+\n     fn intrinsics<'a>(&'a self) -> &'a RefCell<FnvHashMap<&'static str, ValueRef>> {\n         &self.local.intrinsics\n     }\n@@ -923,6 +929,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n     ifn!(\"llvm.lifetime.end\", fn(t_i64, i8p) -> void);\n \n     ifn!(\"llvm.expect.i1\", fn(i1, i1) -> i1);\n+    ifn!(\"llvm.eh.typeid.for\", fn(i8p) -> t_i32);\n \n     // Some intrinsics were introduced in later versions of LLVM, but they have\n     // fallbacks in libc or libm and such."}, {"sha": "c802de91e38b3da452a8b09f64de196bad07fc1c", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -176,8 +176,8 @@ pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRe\n /// return None if the name already has a definition associated with it. In that\n /// case an error should be reported to the user, because it usually happens due\n /// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-pub fn define_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, fn_type: Type,\n-                 output: ty::FnOutput) -> Option<ValueRef> {\n+pub fn define_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv,\n+                 fn_type: Type, output: ty::FnOutput) -> Option<ValueRef> {\n     if get_defined_value(ccx, name).is_some() {\n         None\n     } else {\n@@ -224,20 +224,21 @@ pub fn define_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n /// Declare a Rust function with an intention to define it.\n ///\n /// Use this function when you intend to define a function. This function will\n-/// return None if the name already has a definition associated with it. In that\n-/// case an error should be reported to the user, because it usually happens due\n-/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-pub fn define_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n-                                         fn_type: ty::Ty<'tcx>) -> Option<ValueRef> {\n+/// return panic if the name already has a definition associated with it. This\n+/// can happen with #[no_mangle] or #[export_name], for example.\n+pub fn define_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                         name: &str,\n+                                         fn_type: ty::Ty<'tcx>) -> ValueRef {\n     if get_defined_value(ccx, name).is_some() {\n-        None\n+        ccx.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n     } else {\n-        Some(declare_internal_rust_fn(ccx, name, fn_type))\n+        declare_internal_rust_fn(ccx, name, fn_type)\n     }\n }\n \n \n-/// Get defined or externally defined (AvailableExternally linkage) value by name.\n+/// Get defined or externally defined (AvailableExternally linkage) value by\n+/// name.\n fn get_defined_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n     debug!(\"get_defined_value(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{"}, {"sha": "e102e3cd062be220dbf886d712cbcecef7c69be7", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -627,9 +627,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                ccx.tcx().map.path_to_string(id),\n                id, t);\n \n-        let llfn = declare::define_internal_rust_fn(ccx, &ps[..], t).unwrap_or_else(||{\n-            ccx.sess().bug(&format!(\"symbol `{}` already defined\", ps));\n-        });\n+        let llfn = declare::define_internal_rust_fn(ccx, &ps, t);\n         attributes::from_fn_attrs(ccx, attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, param_substs, id, &[]);\n         llfn"}, {"sha": "e78218fd10dd8fab399075745aafb2ae4c117ef9", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 341, "deletions": 3, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -10,6 +10,7 @@\n \n #![allow(non_upper_case_globals)]\n \n+use arena::TypedArena;\n use llvm;\n use llvm::{SequentiallyConsistent, Acquire, Release, AtomicXchg, ValueRef, TypeKind};\n use middle::subst;\n@@ -23,6 +24,7 @@ use trans::cleanup::CleanupMethods;\n use trans::common::*;\n use trans::datum::*;\n use trans::debuginfo::DebugLoc;\n+use trans::declare;\n use trans::expr;\n use trans::glue;\n use trans::type_of::*;\n@@ -31,7 +33,8 @@ use trans::machine;\n use trans::machine::llsize_of;\n use trans::type_::Type;\n use middle::ty::{self, Ty, HasTypeFlags};\n-use syntax::abi::RustIntrinsic;\n+use middle::subst::Substs;\n+use syntax::abi::{self, RustIntrinsic};\n use syntax::ast;\n use syntax::parse::token;\n \n@@ -302,6 +305,42 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n+    let call_debug_location = DebugLoc::At(call_info.id, call_info.span);\n+\n+    // For `try` we need some custom control flow\n+    if &name[..] == \"try\" {\n+        if let callee::ArgExprs(ref exprs) = args {\n+            let (func, data) = if exprs.len() != 2 {\n+                ccx.sess().bug(\"expected two exprs as arguments for \\\n+                                `try` intrinsic\");\n+            } else {\n+                (&exprs[0], &exprs[1])\n+            };\n+\n+            // translate arguments\n+            let func = unpack_datum!(bcx, expr::trans(bcx, func));\n+            let func = unpack_datum!(bcx, func.to_rvalue_datum(bcx, \"func\"));\n+            let data = unpack_datum!(bcx, expr::trans(bcx, data));\n+            let data = unpack_datum!(bcx, data.to_rvalue_datum(bcx, \"data\"));\n+\n+            let dest = match dest {\n+                expr::SaveIn(d) => d,\n+                expr::Ignore => alloc_ty(bcx, tcx.mk_mut_ptr(tcx.types.i8),\n+                                         \"try_result\"),\n+            };\n+\n+            // do the invoke\n+            bcx = try_intrinsic(bcx, func.val, data.val, dest,\n+                                call_debug_location);\n+\n+            fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n+            return Result::new(bcx, dest);\n+        } else {\n+            ccx.sess().bug(\"expected two exprs as arguments for \\\n+                            `try` intrinsic\");\n+        }\n+    }\n+\n     // Push the arguments.\n     let mut llargs = Vec::new();\n     bcx = callee::trans_args(bcx,\n@@ -314,8 +353,6 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n-    let call_debug_location = DebugLoc::At(call_info.id, call_info.span);\n-\n     // These are the only intrinsic functions that diverge.\n     if &name[..] == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n@@ -989,3 +1026,304 @@ fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ret\n     }\n }\n+\n+fn try_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             func: ValueRef,\n+                             data: ValueRef,\n+                             dest: ValueRef,\n+                             dloc: DebugLoc) -> Block<'blk, 'tcx> {\n+    if bcx.sess().no_landing_pads() {\n+        Call(bcx, func, &[data], None, dloc);\n+        Store(bcx, C_null(Type::i8p(bcx.ccx())), dest);\n+        bcx\n+    } else if bcx.sess().target.target.options.is_like_msvc {\n+        trans_msvc_try(bcx, func, data, dest, dloc)\n+    } else {\n+        trans_gnu_try(bcx, func, data, dest, dloc)\n+    }\n+}\n+\n+// MSVC's definition of the `rust_try` function. The exact implementation here\n+// is a little different than the GNU (standard) version below, not only because\n+// of the personality function but also because of the other fiddly bits about\n+// SEH. LLVM also currently requires us to structure this a very particular way\n+// as explained below.\n+//\n+// Like with the GNU version we generate a shim wrapper\n+fn trans_msvc_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              func: ValueRef,\n+                              data: ValueRef,\n+                              dest: ValueRef,\n+                              dloc: DebugLoc) -> Block<'blk, 'tcx> {\n+    let llfn = get_rust_try_fn(bcx.fcx, &mut |try_fn_ty, output| {\n+        let ccx = bcx.ccx();\n+        let dloc = DebugLoc::None;\n+        let rust_try = declare::define_internal_rust_fn(ccx, \"__rust_try\",\n+                                                         try_fn_ty);\n+        let (fcx, block_arena);\n+        block_arena = TypedArena::new();\n+        fcx = new_fn_ctxt(ccx, rust_try, ast::DUMMY_NODE_ID, false,\n+                          output, ccx.tcx().mk_substs(Substs::trans_empty()),\n+                          None, &block_arena);\n+        let bcx = init_function(&fcx, true, output);\n+        let then = fcx.new_temp_block(\"then\");\n+        let catch = fcx.new_temp_block(\"catch\");\n+        let catch_return = fcx.new_temp_block(\"catch-return\");\n+        let catch_resume = fcx.new_temp_block(\"catch-resume\");\n+        let personality = fcx.eh_personality();\n+\n+        let eh_typeid_for = ccx.get_intrinsic(&\"llvm.eh.typeid.for\");\n+        let rust_try_filter = match bcx.tcx().lang_items.msvc_try_filter() {\n+            Some(did) => callee::trans_fn_ref(ccx, did, ExprId(0),\n+                                              bcx.fcx.param_substs).val,\n+            None => bcx.sess().bug(\"msvc_try_filter not defined\"),\n+        };\n+\n+        // Type indicator for the exception being thrown, not entirely sure\n+        // what's going on here but it's what all the examples in LLVM use.\n+        let lpad_ty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)],\n+                                    false);\n+\n+        llvm::SetFunctionAttribute(rust_try, llvm::Attribute::NoInline);\n+        llvm::SetFunctionAttribute(rust_try, llvm::Attribute::OptimizeNone);\n+        let func = llvm::get_param(rust_try, 0);\n+        let data = llvm::get_param(rust_try, 1);\n+\n+        // Invoke the function, specifying our two temporary landing pads as the\n+        // ext point. After the invoke we've terminated our basic block.\n+        Invoke(bcx, func, &[data], then.llbb, catch.llbb, None, dloc);\n+\n+        // All the magic happens in this landing pad, and this is basically the\n+        // only landing pad in rust tagged with \"catch\" to indicate that we're\n+        // catching an exception. The other catch handlers in the GNU version\n+        // below just catch *all* exceptions, but that's because most exceptions\n+        // are already filtered out by the gnu personality function.\n+        //\n+        // For MSVC we're just using a standard personality function that we\n+        // can't customize (e.g. _except_handler3 or __C_specific_handler), so\n+        // we need to do the exception filtering ourselves. This is currently\n+        // performed by the `__rust_try_filter` function. This function,\n+        // specified in the landingpad instruction, will be invoked by Windows\n+        // SEH routines and will return whether the exception in question can be\n+        // caught (aka the Rust runtime is the one that threw the exception).\n+        //\n+        // To get this to compile (currently LLVM segfaults if it's not in this\n+        // particular structure), when the landingpad is executing we test to\n+        // make sure that the ID of the exception being thrown is indeed the one\n+        // that we were expecting. If it's not, we resume the exception, and\n+        // otherwise we return the pointer that we got Full disclosure: It's not\n+        // clear to me what this `llvm.eh.typeid` stuff is doing *other* then\n+        // just allowing LLVM to compile this file without segfaulting. I would\n+        // expect the entire landing pad to just be:\n+        //\n+        //     %vals = landingpad ...\n+        //     %ehptr = extractvalue { i8*, i32 } %vals, 0\n+        //     ret i8* %ehptr\n+        //\n+        // but apparently LLVM chokes on this, so we do the more complicated\n+        // thing to placate it.\n+        let vals = LandingPad(catch, lpad_ty, personality, 1);\n+        let rust_try_filter = BitCast(catch, rust_try_filter, Type::i8p(ccx));\n+        AddClause(catch, vals, rust_try_filter);\n+        let ehptr = ExtractValue(catch, vals, 0);\n+        let sel = ExtractValue(catch, vals, 1);\n+        let filter_sel = Call(catch, eh_typeid_for, &[rust_try_filter], None,\n+                              dloc);\n+        let is_filter = ICmp(catch, llvm::IntEQ, sel, filter_sel, dloc);\n+        CondBr(catch, is_filter, catch_return.llbb, catch_resume.llbb, dloc);\n+\n+        // Our \"catch-return\" basic block is where we've determined that we\n+        // actually need to catch this exception, in which case we just return\n+        // the exception pointer.\n+        Ret(catch_return, ehptr, dloc);\n+\n+        // The \"catch-resume\" block is where we're running this landing pad but\n+        // we actually need to not catch the exception, so just resume the\n+        // exception to return.\n+        Resume(catch_resume, vals);\n+\n+        // On the successful branch we just return null.\n+        Ret(then, C_null(Type::i8p(ccx)), dloc);\n+\n+        return rust_try\n+    });\n+\n+    // Note that no invoke is used here because by definition this function\n+    // can't panic (that's what it's catching).\n+    let ret = Call(bcx, llfn, &[func, data], None, dloc);\n+    Store(bcx, ret, dest);\n+    return bcx;\n+}\n+\n+// Definition of the standard \"try\" function for Rust using the GNU-like model\n+// of exceptions (e.g. the normal semantics of LLVM's landingpad and invoke\n+// instructions).\n+//\n+// This translation is a little surprising for two reasons:\n+//\n+// 1. We always call a shim function instead of inlining the call to `invoke`\n+//    manually here. This is done because in LLVM we're only allowed to have one\n+//    personality per function definition. The call to the `try` intrinsic is\n+//    being inlined into the function calling it, and that function may already\n+//    have other personality functions in play. By calling a shim we're\n+//    guaranteed that our shim will have the right personality function.\n+//\n+// 2. Instead of making one shim (explained above), we make two shims! The\n+//    reason for this has to do with the technical details about the\n+//    implementation of unwinding in the runtime, but the tl;dr; is that the\n+//    outer shim's personality function says \"catch rust exceptions\" and the\n+//    inner shim's landing pad will not `resume` the exception being thrown.\n+//    This means that the outer shim's landing pad is never run and the inner\n+//    shim's return value is the return value of the whole call.\n+//\n+// The double-shim aspect is currently done for implementation ease on the\n+// runtime side of things, and more info can be found in\n+// src/libstd/rt/unwind/gcc.rs.\n+fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             func: ValueRef,\n+                             data: ValueRef,\n+                             dest: ValueRef,\n+                             dloc: DebugLoc) -> Block<'blk, 'tcx> {\n+    let llfn = get_rust_try_fn(bcx.fcx, &mut |try_fn_ty, output| {\n+        let ccx = bcx.ccx();\n+        let dloc = DebugLoc::None;\n+\n+        // Type indicator for the exception being thrown, not entirely sure\n+        // what's going on here but it's what all the examples in LLVM use.\n+        let lpad_ty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)],\n+                                    false);\n+\n+        // Define the \"inner try\" shim\n+        let rust_try_inner = declare::define_internal_rust_fn(ccx,\n+                                                              \"__rust_try_inner\",\n+                                                              try_fn_ty);\n+        trans_rust_try(ccx, rust_try_inner, lpad_ty, bcx.fcx.eh_personality(),\n+                       output, dloc, &mut |bcx, then, catch| {\n+            let func = llvm::get_param(rust_try_inner, 0);\n+            let data = llvm::get_param(rust_try_inner, 1);\n+            Invoke(bcx, func, &[data], then.llbb, catch.llbb, None, dloc);\n+            C_null(Type::i8p(ccx))\n+        });\n+\n+        // Define the \"outer try\" shim.\n+        let rust_try = declare::define_internal_rust_fn(ccx, \"__rust_try\",\n+                                                        try_fn_ty);\n+        let catch_pers = match bcx.tcx().lang_items.eh_personality_catch() {\n+            Some(did) => callee::trans_fn_ref(ccx, did, ExprId(0),\n+                                              bcx.fcx.param_substs).val,\n+            None => bcx.tcx().sess.bug(\"eh_personality_catch not defined\"),\n+        };\n+        trans_rust_try(ccx, rust_try, lpad_ty, catch_pers, output, dloc,\n+                       &mut |bcx, then, catch| {\n+            let func = llvm::get_param(rust_try, 0);\n+            let data = llvm::get_param(rust_try, 1);\n+            Invoke(bcx, rust_try_inner, &[func, data], then.llbb, catch.llbb,\n+                   None, dloc)\n+        });\n+        return rust_try\n+    });\n+\n+    // Note that no invoke is used here because by definition this function\n+    // can't panic (that's what it's catching).\n+    let ret = Call(bcx, llfn, &[func, data], None, dloc);\n+    Store(bcx, ret, dest);\n+    return bcx;\n+\n+    // Translates both the inner and outer shims described above. The only\n+    // difference between these two is the function invoked and the personality\n+    // involved, so a common routine is shared.\n+    //\n+    //   bcx:\n+    //      invoke %func(%args...) normal %normal unwind %unwind\n+    //\n+    //   normal:\n+    //      ret null\n+    //\n+    //   unwind:\n+    //      (ptr, _) = landingpad\n+    //      br (ptr != null), done, reraise\n+    //\n+    //   done:\n+    //      ret ptr\n+    //\n+    //   reraise:\n+    //      resume\n+    //\n+    // Note that the branch checking for `null` here isn't actually necessary,\n+    // it's just an unfortunate hack to make sure that LLVM doesn't optimize too\n+    // much. If this were not present, then LLVM would correctly deduce that our\n+    // inner shim should be tagged with `nounwind` (as it catches all\n+    // exceptions) and then the outer shim's `invoke` will be translated to just\n+    // a simple call, destroying that entry for the personality function.\n+    //\n+    // To ensure that both shims always have an `invoke` this check against null\n+    // confuses LLVM enough to the point that it won't infer `nounwind` and\n+    // we'll proceed as normal.\n+    fn trans_rust_try<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                llfn: ValueRef,\n+                                lpad_ty: Type,\n+                                personality: ValueRef,\n+                                output: ty::FnOutput<'tcx>,\n+                                dloc: DebugLoc,\n+                                invoke: &mut FnMut(Block, Block, Block) -> ValueRef) {\n+        let (fcx, block_arena);\n+        block_arena = TypedArena::new();\n+        fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n+                          output, ccx.tcx().mk_substs(Substs::trans_empty()),\n+                          None, &block_arena);\n+        let bcx = init_function(&fcx, true, output);\n+        let then = bcx.fcx.new_temp_block(\"then\");\n+        let catch = bcx.fcx.new_temp_block(\"catch\");\n+        let reraise = bcx.fcx.new_temp_block(\"reraise\");\n+        let catch_return = bcx.fcx.new_temp_block(\"catch-return\");\n+\n+        let invoke_ret = invoke(bcx, then, catch);\n+        Ret(then, invoke_ret, dloc);\n+        let vals = LandingPad(catch, lpad_ty, personality, 1);\n+        AddClause(catch, vals, C_null(Type::i8p(ccx)));\n+        let ptr = ExtractValue(catch, vals, 0);\n+        let valid = ICmp(catch, llvm::IntNE, ptr, C_null(Type::i8p(ccx)), dloc);\n+        CondBr(catch, valid, catch_return.llbb, reraise.llbb, dloc);\n+        Ret(catch_return, ptr, dloc);\n+        Resume(reraise, vals);\n+    }\n+}\n+\n+// Helper to generate the `Ty` associated with `rust_Try`\n+fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n+                             f: &mut FnMut(Ty<'tcx>,\n+                                           ty::FnOutput<'tcx>) -> ValueRef)\n+                             -> ValueRef {\n+    let ccx = fcx.ccx;\n+    if let Some(llfn) = *ccx.rust_try_fn().borrow() {\n+        return llfn\n+    }\n+\n+    // Define the types up front for the signatures of the rust_try and\n+    // rust_try_inner functions.\n+    let tcx = ccx.tcx();\n+    let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n+    let fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: ast::Unsafety::Unsafe,\n+        abi: abi::Rust,\n+        sig: ty::Binder(ty::FnSig {\n+            inputs: vec![i8p],\n+            output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n+            variadic: false,\n+        }),\n+    });\n+    let fn_ty = tcx.mk_fn(None, fn_ty);\n+    let output = ty::FnOutput::FnConverging(i8p);\n+    let try_fn_ty  = tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: ast::Unsafety::Unsafe,\n+        abi: abi::Rust,\n+        sig: ty::Binder(ty::FnSig {\n+            inputs: vec![fn_ty, i8p],\n+            output: output,\n+            variadic: false,\n+        }),\n+    });\n+    let rust_try = f(tcx.mk_fn(None, try_fn_ty), output);\n+    *ccx.rust_try_fn().borrow_mut() = Some(rust_try);\n+    return rust_try\n+}"}, {"sha": "8901361b27976396cfada7ff1c19b21ed4914634", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -550,9 +550,7 @@ fn trans_object_shim<'a, 'tcx>(\n     let shim_fn_ty = tcx.mk_fn(None, fty);\n     let method_bare_fn_ty = tcx.mk_fn(None, method_ty);\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, shim_fn_ty, \"object_shim\");\n-    let llfn = declare::define_internal_rust_fn(ccx, &function_name, shim_fn_ty).unwrap_or_else(||{\n-        ccx.sess().bug(&format!(\"symbol `{}` already defined\", function_name));\n-    });\n+    let llfn = declare::define_internal_rust_fn(ccx, &function_name, shim_fn_ty);\n \n     let sig = ccx.tcx().erase_late_bound_regions(&fty.sig);\n "}, {"sha": "217181da1421aac8ac688d3a52a8091cbbfca8b9", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -137,10 +137,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let lldecl = if abi != abi::Rust {\n             foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s[..])\n         } else {\n-            // FIXME(nagisa): perhaps needs a more fine grained selection? See setup_lldecl below.\n-            declare::define_internal_rust_fn(ccx, &s[..], mono_ty).unwrap_or_else(||{\n-                ccx.sess().bug(&format!(\"symbol `{}` already defined\", s));\n-            })\n+            // FIXME(nagisa): perhaps needs a more fine grained selection? See\n+            // setup_lldecl below.\n+            declare::define_internal_rust_fn(ccx, &s, mono_ty)\n         };\n \n         ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);"}, {"sha": "17140db904f628e4d4f009642e141c1357dfb8e1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -5096,6 +5096,21 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                                                                   ty::BrAnon(0))),\n                                     param(ccx, 0))], tcx.types.u64),\n \n+            \"try\" => {\n+                let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n+                let fn_ty = ty::BareFnTy {\n+                    unsafety: ast::Unsafety::Normal,\n+                    abi: abi::Rust,\n+                    sig: ty::Binder(FnSig {\n+                        inputs: vec![mut_u8],\n+                        output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n+                        variadic: false,\n+                    }),\n+                };\n+                let fn_ty = tcx.mk_bare_fn(fn_ty);\n+                (0, vec![tcx.mk_fn(None, fn_ty), mut_u8], mut_u8)\n+            }\n+\n             ref other => {\n                 span_err!(tcx.sess, it.span, E0093,\n                     \"unrecognized intrinsic function: `{}`\", *other);"}, {"sha": "87941e79b2f7d79e6d2aa87b1454172ea9035be9", "filename": "src/libstd/rt/unwind/gcc.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(private_no_mangle_fns)]\n+\n use prelude::v1::*;\n \n use any::Any;\n-use libc::c_void;\n use rt::libunwind as uw;\n \n struct Exception {\n@@ -41,7 +42,7 @@ pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n     }\n }\n \n-pub unsafe fn cleanup(ptr: *mut c_void) -> Box<Any + Send + 'static> {\n+pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> {\n     let my_ep = ptr as *mut Exception;\n     rtdebug!(\"caught {}\", (*my_ep).uwe.exception_class);\n     let cause = (*my_ep).cause.take();\n@@ -89,7 +90,7 @@ pub mod eabi {\n     use rt::libunwind as uw;\n     use libc::c_int;\n \n-    extern \"C\" {\n+    extern {\n         fn __gcc_personality_v0(version: c_int,\n                                 actions: uw::_Unwind_Action,\n                                 exception_class: uw::_Unwind_Exception_Class,\n@@ -98,9 +99,8 @@ pub mod eabi {\n             -> uw::_Unwind_Reason_Code;\n     }\n \n-    #[lang=\"eh_personality\"]\n-    #[no_mangle] // referenced from rust_try.ll\n-    #[allow(private_no_mangle_fns)]\n+    #[lang = \"eh_personality\"]\n+    #[no_mangle]\n     extern fn rust_eh_personality(\n         version: c_int,\n         actions: uw::_Unwind_Action,\n@@ -115,8 +115,9 @@ pub mod eabi {\n         }\n     }\n \n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality_catch(\n+    #[cfg_attr(not(stage0), lang = \"eh_personality_catch\")]\n+    #[no_mangle]\n+    pub extern fn rust_eh_personality_catch(\n         _version: c_int,\n         actions: uw::_Unwind_Action,\n         _exception_class: uw::_Unwind_Exception_Class,\n@@ -142,7 +143,7 @@ pub mod eabi {\n     use rt::libunwind as uw;\n     use libc::c_int;\n \n-    extern \"C\" {\n+    extern {\n         fn __gcc_personality_sj0(version: c_int,\n                                 actions: uw::_Unwind_Action,\n                                 exception_class: uw::_Unwind_Exception_Class,\n@@ -151,9 +152,9 @@ pub mod eabi {\n             -> uw::_Unwind_Reason_Code;\n     }\n \n-    #[lang=\"eh_personality\"]\n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality(\n+    #[lang = \"eh_personality\"]\n+    #[no_mangle]\n+    pub extern fn rust_eh_personality(\n         version: c_int,\n         actions: uw::_Unwind_Action,\n         exception_class: uw::_Unwind_Exception_Class,\n@@ -167,8 +168,9 @@ pub mod eabi {\n         }\n     }\n \n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality_catch(\n+    #[cfg_attr(not(stage0), lang = \"eh_personality_catch\")]\n+    #[no_mangle]\n+    pub extern fn rust_eh_personality_catch(\n         _version: c_int,\n         actions: uw::_Unwind_Action,\n         _exception_class: uw::_Unwind_Exception_Class,\n@@ -196,17 +198,16 @@ pub mod eabi {\n     use rt::libunwind as uw;\n     use libc::c_int;\n \n-    extern \"C\" {\n+    extern {\n         fn __gcc_personality_v0(state: uw::_Unwind_State,\n                                 ue_header: *mut uw::_Unwind_Exception,\n                                 context: *mut uw::_Unwind_Context)\n             -> uw::_Unwind_Reason_Code;\n     }\n \n-    #[lang=\"eh_personality\"]\n-    #[no_mangle] // referenced from rust_try.ll\n-    #[allow(private_no_mangle_fns)]\n-    extern \"C\" fn rust_eh_personality(\n+    #[lang = \"eh_personality\"]\n+    #[no_mangle]\n+    extern fn rust_eh_personality(\n         state: uw::_Unwind_State,\n         ue_header: *mut uw::_Unwind_Exception,\n         context: *mut uw::_Unwind_Context\n@@ -217,8 +218,9 @@ pub mod eabi {\n         }\n     }\n \n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality_catch(\n+    #[cfg_attr(not(stage0), lang = \"eh_personality_catch\")]\n+    #[no_mangle]\n+    pub extern fn rust_eh_personality_catch(\n         state: uw::_Unwind_State,\n         _ue_header: *mut uw::_Unwind_Exception,\n         _context: *mut uw::_Unwind_Context\n@@ -266,15 +268,15 @@ pub mod eabi {\n     }\n \n     type _Unwind_Personality_Fn =\n-        extern \"C\" fn(\n+        extern fn(\n             version: c_int,\n             actions: uw::_Unwind_Action,\n             exception_class: uw::_Unwind_Exception_Class,\n             ue_header: *mut uw::_Unwind_Exception,\n             context: *mut uw::_Unwind_Context\n         ) -> uw::_Unwind_Reason_Code;\n \n-    extern \"C\" {\n+    extern {\n         fn __gcc_personality_seh0(\n             exceptionRecord: *mut EXCEPTION_RECORD,\n             establisherFrame: *mut c_void,\n@@ -291,10 +293,9 @@ pub mod eabi {\n         ) -> EXCEPTION_DISPOSITION;\n     }\n \n-    #[lang=\"eh_personality\"]\n-    #[no_mangle] // referenced from rust_try.ll\n-    #[allow(private_no_mangle_fns)]\n-    extern \"C\" fn rust_eh_personality(\n+    #[lang = \"eh_personality\"]\n+    #[no_mangle]\n+    extern fn rust_eh_personality(\n         exceptionRecord: *mut EXCEPTION_RECORD,\n         establisherFrame: *mut c_void,\n         contextRecord: *mut CONTEXT,\n@@ -307,15 +308,16 @@ pub mod eabi {\n         }\n     }\n \n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality_catch(\n+    #[cfg_attr(not(stage0), lang = \"eh_personality_catch\")]\n+    #[no_mangle]\n+    pub extern fn rust_eh_personality_catch(\n         exceptionRecord: *mut EXCEPTION_RECORD,\n         establisherFrame: *mut c_void,\n         contextRecord: *mut CONTEXT,\n         dispatcherContext: *mut DISPATCHER_CONTEXT\n     ) -> EXCEPTION_DISPOSITION\n     {\n-        extern \"C\" fn inner(\n+        extern fn inner(\n                 _version: c_int,\n                 actions: uw::_Unwind_Action,\n                 _exception_class: uw::_Unwind_Exception_Class,"}, {"sha": "db2310ba361b342d9c436f523943e7aa57beef2c", "filename": "src/libstd/rt/unwind/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibstd%2Frt%2Funwind%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibstd%2Frt%2Funwind%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fmod.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -69,7 +69,6 @@ use cmp;\n use panicking;\n use fmt;\n use intrinsics;\n-use libc::c_void;\n use mem;\n use sync::atomic::{self, Ordering};\n use sys_common::mutex::Mutex;\n@@ -127,7 +126,7 @@ extern {}\n ///   run.\n pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> {\n     let mut f = Some(f);\n-    return inner_try(try_fn::<F>, &mut f as *mut _ as *mut c_void);\n+    return inner_try(try_fn::<F>, &mut f as *mut _ as *mut u8);\n \n     // If an inner function were not used here, then this generic function `try`\n     // uses the native symbol `rust_try`, for which the code is statically\n@@ -140,20 +139,26 @@ pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> {\n     // `dllexport`, but it's easier to not have conditional `src/rt/rust_try.ll`\n     // files and instead just have this non-generic shim the compiler can take\n     // care of exposing correctly.\n-    unsafe fn inner_try(f: extern fn(*mut c_void), data: *mut c_void)\n+    #[cfg(not(stage0))]\n+    unsafe fn inner_try(f: fn(*mut u8), data: *mut u8)\n                         -> Result<(), Box<Any + Send>> {\n         let prev = PANICKING.with(|s| s.get());\n         PANICKING.with(|s| s.set(false));\n-        let ep = rust_try(f, data);\n+        let ep = intrinsics::try(f, data);\n         PANICKING.with(|s| s.set(prev));\n         if ep.is_null() {\n             Ok(())\n         } else {\n             Err(imp::cleanup(ep))\n         }\n     }\n+    #[cfg(stage0)]\n+    unsafe fn inner_try(f: fn(*mut u8), data: *mut u8)\n+                        -> Result<(), Box<Any + Send>> {\n+        Ok(f(data))\n+    }\n \n-    extern fn try_fn<F: FnOnce()>(opt_closure: *mut c_void) {\n+    fn try_fn<F: FnOnce()>(opt_closure: *mut u8) {\n         let opt_closure = opt_closure as *mut Option<F>;\n         unsafe { (*opt_closure).take().unwrap()(); }\n     }\n@@ -163,8 +168,8 @@ pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> {\n         // When f(...) returns normally, the return value is null.\n         // When f(...) throws, the return value is a pointer to the caught\n         // exception object.\n-        fn rust_try(f: extern fn(*mut c_void),\n-                    data: *mut c_void) -> *mut c_void;\n+        fn rust_try(f: extern fn(*mut u8),\n+                    data: *mut u8) -> *mut u8;\n     }\n }\n "}, {"sha": "ed44f9a8bda9499b0bfa7835295503afd999eb18", "filename": "src/libstd/rt/unwind/seh.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibstd%2Frt%2Funwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Flibstd%2Frt%2Funwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fseh.rs?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -102,7 +102,7 @@ pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n     rtabort!(\"could not unwind stack\");\n }\n \n-pub unsafe fn cleanup(ptr: *mut c_void) -> Box<Any + Send + 'static> {\n+pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> {\n     // The `ptr` here actually corresponds to the code of the exception, and our\n     // real data is stored in our thread local.\n     rtassert!(ptr as DWORD == RUST_PANIC);\n@@ -135,8 +135,9 @@ fn rust_eh_personality() {\n // to ensure that it's code is RUST_PANIC, which was set by the call to\n // `RaiseException` above in the `panic` function.\n #[no_mangle]\n+#[lang = \"msvc_try_filter\"]\n pub extern fn __rust_try_filter(eh_ptrs: *mut EXCEPTION_POINTERS,\n-                                _rbp: *mut c_void) -> i32 {\n+                                _rbp: *mut u8) -> i32 {\n     unsafe {\n         ((*(*eh_ptrs).ExceptionRecord).ExceptionCode == RUST_PANIC) as i32\n     }"}, {"sha": "8643131d0fb74eadb5196b219e324b359e6a9822", "filename": "src/rt/rust_try.ll", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/39d4faf989cea236e2e1669ab85d060d1c62cd85/src%2Frt%2Frust_try.ll", "raw_url": "https://github.com/rust-lang/rust/raw/39d4faf989cea236e2e1669ab85d060d1c62cd85/src%2Frt%2Frust_try.ll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_try.ll?ref=39d4faf989cea236e2e1669ab85d060d1c62cd85", "patch": "@@ -1,54 +0,0 @@\n-; Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-; file at the top-level directory of this distribution and at\n-; http://rust-lang.org/COPYRIGHT.\n-;\n-; Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-; http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-; <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-; option. This file may not be copied, modified, or distributed\n-; except according to those terms.\n-\n-; Rust's try-catch\n-; When f(...) returns normally, the return value is null.\n-; When f(...) throws, the return value is a pointer to the caught exception object.\n-\n-; See also: libstd/rt/unwind/mod.rs\n-\n-define i8* @rust_try(void (i8*)* %f, i8* %env)\n-    personality i8* bitcast (i32 (...)* @rust_eh_personality_catch to i8*)\n-{\n-\n-    %1 = invoke i8* @rust_try_inner(void (i8*)* %f, i8* %env)\n-        to label %normal\n-        unwind label %catch\n-\n-normal:\n-    ret i8* %1\n-\n-catch:\n-    landingpad { i8*, i32 } catch i8* null\n-    ; rust_try_inner's landing pad does not resume unwinds, so execution will\n-    ; never reach here\n-    ret i8* null\n-}\n-\n-define internal i8* @rust_try_inner(void (i8*)* %f, i8* %env)\n-    personality i8* bitcast (i32 (...)* @rust_eh_personality to i8*)\n-{\n-\n-    invoke void %f(i8* %env)\n-        to label %normal\n-        unwind label %catch\n-\n-normal:\n-    ret i8* null\n-\n-catch:\n-    %1 = landingpad { i8*, i32 } catch i8* null\n-    ; extract and return pointer to the exception object\n-    %2 = extractvalue { i8*, i32 } %1, 0\n-    ret i8* %2\n-}\n-\n-declare i32 @rust_eh_personality(...)\n-declare i32 @rust_eh_personality_catch(...)"}, {"sha": "bdee53b136e103b5f91050ccc79ab1a01c0c42e1", "filename": "src/rt/rust_try_msvc_32.ll", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/39d4faf989cea236e2e1669ab85d060d1c62cd85/src%2Frt%2Frust_try_msvc_32.ll", "raw_url": "https://github.com/rust-lang/rust/raw/39d4faf989cea236e2e1669ab85d060d1c62cd85/src%2Frt%2Frust_try_msvc_32.ll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_try_msvc_32.ll?ref=39d4faf989cea236e2e1669ab85d060d1c62cd85", "patch": "@@ -1,42 +0,0 @@\n-; Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-; file at the top-level directory of this distribution and at\n-; http://rust-lang.org/COPYRIGHT.\n-;\n-; Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-; http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-; <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-; option. This file may not be copied, modified, or distributed\n-; except according to those terms.\n-\n-; For more comments about what's going on here see rust_try_msvc_64.ll. The only\n-; difference between that and this file is the personality function used as it's\n-; different for 32-bit MSVC than it is for 64-bit.\n-\n-define i8* @rust_try(void (i8*)* %f, i8* %env)\n-    personality i8* bitcast (i32 (...)* @_except_handler3 to i8*)\n-{\n-    invoke void %f(i8* %env)\n-        to label %normal\n-        unwind label %catch\n-\n-normal:\n-    ret i8* null\n-catch:\n-    %vals = landingpad { i8*, i32 }\n-              catch i8* bitcast (i32 (i8*, i8*)* @__rust_try_filter to i8*)\n-    %ehptr = extractvalue { i8*, i32 } %vals, 0\n-    %sel = extractvalue { i8*, i32 } %vals, 1\n-    %filter_sel = call i32 @llvm.eh.typeid.for(i8* bitcast (i32 (i8*, i8*)* @__rust_try_filter to i8*))\n-    %is_filter = icmp eq i32 %sel, %filter_sel\n-    br i1 %is_filter, label %catch-return, label %catch-resume\n-\n-catch-return:\n-    ret i8* %ehptr\n-\n-catch-resume:\n-    resume { i8*, i32 } %vals\n-}\n-\n-declare i32 @_except_handler3(...)\n-declare i32 @__rust_try_filter(i8*, i8*)\n-declare i32 @llvm.eh.typeid.for(i8*) readnone nounwind"}, {"sha": "c38e6081bf2d3fdc07e1788ac15cb911c733a539", "filename": "src/rt/rust_try_msvc_64.ll", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/39d4faf989cea236e2e1669ab85d060d1c62cd85/src%2Frt%2Frust_try_msvc_64.ll", "raw_url": "https://github.com/rust-lang/rust/raw/39d4faf989cea236e2e1669ab85d060d1c62cd85/src%2Frt%2Frust_try_msvc_64.ll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_try_msvc_64.ll?ref=39d4faf989cea236e2e1669ab85d060d1c62cd85", "patch": "@@ -1,80 +0,0 @@\n-; Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-; file at the top-level directory of this distribution and at\n-; http://rust-lang.org/COPYRIGHT.\n-;\n-; Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-; http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-; <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-; option. This file may not be copied, modified, or distributed\n-; except according to those terms.\n-\n-; 64-bit MSVC's definition of the `rust_try` function. This function can't be\n-; defined in Rust as it's a \"try-catch\" block that's not expressible in Rust's\n-; syntax, so we're using LLVM to produce an object file with the associated\n-; handler.\n-;\n-; To use the correct system implementation details, this file is separate from\n-; the standard rust_try.ll as we need specifically use the __C_specific_handler\n-; personality function or otherwise LLVM doesn't emit SEH handling tables.\n-; There's also a few fiddly bits about SEH right now in LLVM that require us to\n-; structure this a fairly particular way!\n-;\n-; See also: src/libstd/rt/unwind/seh.rs\n-\n-define i8* @rust_try(void (i8*)* %f, i8* %env)\n-    personality i8* bitcast (i32 (...)* @__C_specific_handler to i8*)\n-{\n-    invoke void %f(i8* %env)\n-        to label %normal\n-        unwind label %catch\n-\n-normal:\n-    ret i8* null\n-\n-; Here's where most of the magic happens, this is the only landing pad in rust\n-; tagged with \"catch\" to indicate that we're catching an exception. The other\n-; catch handlers in rust_try.ll just catch *all* exceptions, but that's because\n-; most exceptions are already filtered out by their personality function.\n-;\n-; For MSVC we're just using a standard personality function that we can't\n-; customize, so we need to do the exception filtering ourselves, and this is\n-; currently performed by the `__rust_try_filter` function. This function,\n-; specified in the landingpad instruction, will be invoked by Windows SEH\n-; routines and will return whether the exception in question can be caught (aka\n-; the Rust runtime is the one that threw the exception).\n-;\n-; To get this to compile (currently LLVM segfaults if it's not in this\n-; particular structure), when the landingpad is executing we test to make sure\n-; that the ID of the exception being thrown is indeed the one that we were\n-; expecting. If it's not, we resume the exception, and otherwise we return the\n-; pointer that we got\n-;\n-; Full disclosure: It's not clear to me what this `llvm.eh.typeid` stuff is\n-; doing *other* then just allowing LLVM to compile this file without\n-; segfaulting. I would expect the entire landing pad to just be:\n-;\n-;     %vals = landingpad ...\n-;     %ehptr = extractvalue { i8*, i32 } %vals, 0\n-;     ret i8* %ehptr\n-;\n-; but apparently LLVM chokes on this, so we do the more complicated thing to\n-; placate it.\n-catch:\n-    %vals = landingpad { i8*, i32 }\n-              catch i8* bitcast (i32 (i8*, i8*)* @__rust_try_filter to i8*)\n-    %ehptr = extractvalue { i8*, i32 } %vals, 0\n-    %sel = extractvalue { i8*, i32 } %vals, 1\n-    %filter_sel = call i32 @llvm.eh.typeid.for(i8* bitcast (i32 (i8*, i8*)* @__rust_try_filter to i8*))\n-    %is_filter = icmp eq i32 %sel, %filter_sel\n-    br i1 %is_filter, label %catch-return, label %catch-resume\n-\n-catch-return:\n-    ret i8* %ehptr\n-\n-catch-resume:\n-    resume { i8*, i32 } %vals\n-}\n-\n-declare i32 @__C_specific_handler(...)\n-declare i32 @__rust_try_filter(i8*, i8*)\n-declare i32 @llvm.eh.typeid.for(i8*) readnone nounwind"}, {"sha": "5007af0e777b84bc080f71ebb74cf9945edb1895", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c35b2bd226736925961ca6853b2ef29e8094cd90/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=c35b2bd226736925961ca6853b2ef29e8094cd90", "patch": "@@ -120,7 +120,8 @@ extern \"C\" void LLVMAddDereferenceableCallSiteAttr(LLVMValueRef Instr, unsigned\n                                                          idx, B)));\n }\n \n-extern \"C\" void LLVMAddFunctionAttribute(LLVMValueRef Fn, unsigned index, uint64_t Val) {\n+extern \"C\" void LLVMAddFunctionAttribute(LLVMValueRef Fn, unsigned index,\n+                                         uint64_t Val) {\n   Function *A = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addRawValue(Val);"}]}