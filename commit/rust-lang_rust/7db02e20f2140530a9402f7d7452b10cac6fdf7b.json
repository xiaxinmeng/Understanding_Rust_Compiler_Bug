{"sha": "7db02e20f2140530a9402f7d7452b10cac6fdf7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkYjAyZTIwZjIxNDA1MzBhOTQwMmY3ZDc0NTJiMTBjYWM2ZmRmN2I=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-19T23:01:48Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-19T23:01:48Z"}, "message": "std: Rebuild mpmc queues on Unsafe/Arc\n\nThis removes usage of UnsafeArc and uses proper self mutability for concurrent\ntypes.", "tree": {"sha": "4318e0a2453a45b3d8ece84d0124d8b56db18869", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4318e0a2453a45b3d8ece84d0124d8b56db18869"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7db02e20f2140530a9402f7d7452b10cac6fdf7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7db02e20f2140530a9402f7d7452b10cac6fdf7b", "html_url": "https://github.com/rust-lang/rust/commit/7db02e20f2140530a9402f7d7452b10cac6fdf7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7db02e20f2140530a9402f7d7452b10cac6fdf7b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efbd3724c012d68afd428beaa22f0d5aabff007d", "url": "https://api.github.com/repos/rust-lang/rust/commits/efbd3724c012d68afd428beaa22f0d5aabff007d", "html_url": "https://github.com/rust-lang/rust/commit/efbd3724c012d68afd428beaa22f0d5aabff007d"}], "stats": {"total": 50, "additions": 27, "deletions": 23}, "files": [{"sha": "7fb98e140865de77dfb4b1e6c15d620ef2fb7fc1", "filename": "src/libstd/sync/mpmc_bounded_queue.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7db02e20f2140530a9402f7d7452b10cac6fdf7b/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db02e20f2140530a9402f7d7452b10cac6fdf7b/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs?ref=7db02e20f2140530a9402f7d7452b10cac6fdf7b", "patch": "@@ -29,13 +29,15 @@\n \n // http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue\n \n+use alloc::arc::Arc;\n+\n use clone::Clone;\n use kinds::Send;\n use num::next_power_of_two;\n use option::{Option, Some, None};\n-use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicUint,Relaxed,Release,Acquire};\n use vec::Vec;\n+use ty::Unsafe;\n \n struct Node<T> {\n     sequence: AtomicUint,\n@@ -44,7 +46,7 @@ struct Node<T> {\n \n struct State<T> {\n     pad0: [u8, ..64],\n-    buffer: Vec<Node<T>>,\n+    buffer: Vec<Unsafe<Node<T>>>,\n     mask: uint,\n     pad1: [u8, ..64],\n     enqueue_pos: AtomicUint,\n@@ -54,7 +56,7 @@ struct State<T> {\n }\n \n pub struct Queue<T> {\n-    state: UnsafeArc<State<T>>,\n+    state: Arc<State<T>>,\n }\n \n impl<T: Send> State<T> {\n@@ -70,7 +72,7 @@ impl<T: Send> State<T> {\n             capacity\n         };\n         let buffer = Vec::from_fn(capacity, |i| {\n-            Node { sequence:AtomicUint::new(i), value: None }\n+            Unsafe::new(Node { sequence:AtomicUint::new(i), value: None })\n         });\n         State{\n             pad0: [0, ..64],\n@@ -84,19 +86,21 @@ impl<T: Send> State<T> {\n         }\n     }\n \n-    fn push(&mut self, value: T) -> bool {\n+    fn push(&self, value: T) -> bool {\n         let mask = self.mask;\n         let mut pos = self.enqueue_pos.load(Relaxed);\n         loop {\n-            let node = self.buffer.get_mut(pos & mask);\n-            let seq = node.sequence.load(Acquire);\n+            let node = self.buffer.get(pos & mask);\n+            let seq = unsafe { (*node.get()).sequence.load(Acquire) };\n             let diff: int = seq as int - pos as int;\n \n             if diff == 0 {\n                 let enqueue_pos = self.enqueue_pos.compare_and_swap(pos, pos+1, Relaxed);\n                 if enqueue_pos == pos {\n-                    node.value = Some(value);\n-                    node.sequence.store(pos+1, Release);\n+                    unsafe {\n+                        (*node.get()).value = Some(value);\n+                        (*node.get()).sequence.store(pos+1, Release);\n+                    }\n                     break\n                 } else {\n                     pos = enqueue_pos;\n@@ -110,19 +114,21 @@ impl<T: Send> State<T> {\n         true\n     }\n \n-    fn pop(&mut self) -> Option<T> {\n+    fn pop(&self) -> Option<T> {\n         let mask = self.mask;\n         let mut pos = self.dequeue_pos.load(Relaxed);\n         loop {\n-            let node = self.buffer.get_mut(pos & mask);\n-            let seq = node.sequence.load(Acquire);\n+            let node = self.buffer.get(pos & mask);\n+            let seq = unsafe { (*node.get()).sequence.load(Acquire) };\n             let diff: int = seq as int - (pos + 1) as int;\n             if diff == 0 {\n                 let dequeue_pos = self.dequeue_pos.compare_and_swap(pos, pos+1, Relaxed);\n                 if dequeue_pos == pos {\n-                    let value = node.value.take();\n-                    node.sequence.store(pos + mask + 1, Release);\n-                    return value\n+                    unsafe {\n+                        let value = (*node.get()).value.take();\n+                        (*node.get()).sequence.store(pos + mask + 1, Release);\n+                        return value\n+                    }\n                 } else {\n                     pos = dequeue_pos;\n                 }\n@@ -138,24 +144,22 @@ impl<T: Send> State<T> {\n impl<T: Send> Queue<T> {\n     pub fn with_capacity(capacity: uint) -> Queue<T> {\n         Queue{\n-            state: UnsafeArc::new(State::with_capacity(capacity))\n+            state: Arc::new(State::with_capacity(capacity))\n         }\n     }\n \n-    pub fn push(&mut self, value: T) -> bool {\n-        unsafe { (*self.state.get()).push(value) }\n+    pub fn push(&self, value: T) -> bool {\n+        self.state.push(value)\n     }\n \n-    pub fn pop(&mut self) -> Option<T> {\n-        unsafe { (*self.state.get()).pop() }\n+    pub fn pop(&self) -> Option<T> {\n+        self.state.pop()\n     }\n }\n \n impl<T: Send> Clone for Queue<T> {\n     fn clone(&self) -> Queue<T> {\n-        Queue {\n-            state: self.state.clone()\n-        }\n+        Queue { state: self.state.clone() }\n     }\n }\n "}]}