{"sha": "e39a86019d79d0f2dc5f6cc94fcdf2f073b478e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzOWE4NjAxOWQ3OWQwZjJkYzVmNmNjOTRmY2RmMmYwNzNiNDc4ZTk=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-10-04T15:56:55Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-10-08T04:29:38Z"}, "message": "Use the new module information for intra-doc links\n\n- Make the parent module conditional on whether the docs are on a re-export\n- Make `resolve_link` take `&Item` instead of `&mut Item`\n\n  Previously the borrow checker gave an error about multiple mutable\n  borrows, because `dox` borrowed from `item`.\n\n- Fix `crate::` for re-exports\n\n  `crate` means something different depending on where the attribute\n  came from.\n\n- Make it work for `#[doc]` attributes too\n\n  This required combining several attributes as one so they would keep\n  the links.", "tree": {"sha": "6cc41306b89076907fcaefde187cfb180db14d76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cc41306b89076907fcaefde187cfb180db14d76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e39a86019d79d0f2dc5f6cc94fcdf2f073b478e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e39a86019d79d0f2dc5f6cc94fcdf2f073b478e9", "html_url": "https://github.com/rust-lang/rust/commit/e39a86019d79d0f2dc5f6cc94fcdf2f073b478e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e39a86019d79d0f2dc5f6cc94fcdf2f073b478e9/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fbfdc548aa8f0f7b9e7bbd54d6916eb5ed53e23", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fbfdc548aa8f0f7b9e7bbd54d6916eb5ed53e23", "html_url": "https://github.com/rust-lang/rust/commit/8fbfdc548aa8f0f7b9e7bbd54d6916eb5ed53e23"}], "stats": {"total": 128, "additions": 84, "deletions": 44}, "files": [{"sha": "b9be3e2f92b4696653d6a4d48f68750ff0330e89", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 66, "deletions": 44, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/e39a86019d79d0f2dc5f6cc94fcdf2f073b478e9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e39a86019d79d0f2dc5f6cc94fcdf2f073b478e9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=e39a86019d79d0f2dc5f6cc94fcdf2f073b478e9", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::def::{\n     Namespace::{self, *},\n     PerNS, Res,\n };\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_middle::ty;\n use rustc_resolve::ParentScope;\n use rustc_session::lint::{\n@@ -767,17 +767,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             self.mod_ids.push(item.def_id);\n         }\n \n-        #[cfg(debug_assertions)]\n-        for attr in &item.attrs.doc_strings {\n-            if let Some(id) = attr.parent_module {\n-                trace!(\"docs {:?} came from {:?}\", attr.doc, id);\n-            } else {\n-                debug!(\"no parent found for {:?}\", attr.doc);\n-            }\n-        }\n-        let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);\n-        //trace!(\"got documentation '{}'\", dox);\n-\n         // find item's parent to resolve `Self` in item's docs below\n         let parent_name = self.cx.as_local_hir_id(item.def_id).and_then(|item_hir| {\n             let parent_hir = self.cx.tcx.hir().get_parent_item(item_hir);\n@@ -815,16 +804,53 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             }\n         });\n \n-        for (ori_link, link_range) in markdown_links(&dox) {\n-            self.resolve_link(\n-                &mut item,\n-                &dox,\n-                &current_item,\n-                parent_node,\n-                &parent_name,\n-                ori_link,\n-                link_range,\n-            );\n+        // We want to resolve in the lexical scope of the documentation.\n+        // In the presence of re-exports, this is not the same as the module of the item.\n+        // Rather than merging all documentation into one, resolve it one attribute at a time\n+        // so we know which module it came from.\n+        let mut attrs = item.attrs.doc_strings.iter().peekable();\n+        while let Some(attr) = attrs.next() {\n+            // `collapse_docs` does not have the behavior we want:\n+            // we want `///` and `#[doc]` to count as the same attribute,\n+            // but currently it will treat them as separate.\n+            // As a workaround, combine all attributes with the same parent module into the same attribute.\n+            let mut combined_docs = attr.doc.clone();\n+            loop {\n+                match attrs.peek() {\n+                    Some(next) if next.parent_module == attr.parent_module => {\n+                        combined_docs.push('\\n');\n+                        combined_docs.push_str(&attrs.next().unwrap().doc);\n+                    }\n+                    _ => break,\n+                }\n+            }\n+            debug!(\"combined_docs={}\", combined_docs);\n+\n+            let (krate, parent_node) = if let Some(id) = attr.parent_module {\n+                trace!(\"docs {:?} came from {:?}\", attr.doc, id);\n+                (id.krate, Some(id))\n+            } else {\n+                trace!(\"no parent found for {:?}\", attr.doc);\n+                (item.def_id.krate, parent_node)\n+            };\n+            // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n+            // This is a degenerate case and it's not supported by rustdoc.\n+            // FIXME: this will break links that start in `#[doc = ...]` and end as a sugared doc. Should this be supported?\n+            for (ori_link, link_range) in markdown_links(&combined_docs) {\n+                let link = self.resolve_link(\n+                    &item,\n+                    &combined_docs,\n+                    &current_item,\n+                    parent_node,\n+                    &parent_name,\n+                    krate,\n+                    ori_link,\n+                    link_range,\n+                );\n+                if let Some(link) = link {\n+                    item.attrs.links.push(link);\n+                }\n+            }\n         }\n \n         if item.is_mod() && !item.attrs.inner_docs {\n@@ -846,36 +872,37 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n impl LinkCollector<'_, '_> {\n     fn resolve_link(\n         &self,\n-        item: &mut Item,\n+        item: &Item,\n         dox: &str,\n         current_item: &Option<String>,\n         parent_node: Option<DefId>,\n         parent_name: &Option<String>,\n+        krate: CrateNum,\n         ori_link: String,\n         link_range: Option<Range<usize>>,\n-    ) {\n+    ) -> Option<ItemLink> {\n         trace!(\"considering link '{}'\", ori_link);\n \n         // Bail early for real links.\n         if ori_link.contains('/') {\n-            return;\n+            return None;\n         }\n \n         // [] is mostly likely not supposed to be a link\n         if ori_link.is_empty() {\n-            return;\n+            return None;\n         }\n \n         let cx = self.cx;\n         let link = ori_link.replace(\"`\", \"\");\n         let parts = link.split('#').collect::<Vec<_>>();\n         let (link, extra_fragment) = if parts.len() > 2 {\n             anchor_failure(cx, &item, &link, dox, link_range, AnchorFailure::MultipleAnchors);\n-            return;\n+            return None;\n         } else if parts.len() == 2 {\n             if parts[0].trim().is_empty() {\n                 // This is an anchor to an element of the current page, nothing to do in here!\n-                return;\n+                return None;\n             }\n             (parts[0], Some(parts[1].to_owned()))\n         } else {\n@@ -896,7 +923,7 @@ impl LinkCollector<'_, '_> {\n             .trim();\n \n             if path_str.contains(|ch: char| !(ch.is_alphanumeric() || ch == ':' || ch == '_')) {\n-                return;\n+                return None;\n             }\n \n             // We stripped `()` and `!` when parsing the disambiguator.\n@@ -936,7 +963,7 @@ impl LinkCollector<'_, '_> {\n                     link_range,\n                     smallvec![err_kind],\n                 );\n-                return;\n+                return None;\n             };\n \n             // replace `Self` with suitable item's parent name\n@@ -955,7 +982,7 @@ impl LinkCollector<'_, '_> {\n                 // (consider `crate::char`). Instead, change it to `self::`. This works because 'self' is now the crate root.\n                 resolved_self = format!(\"self::{}\", &path_str[\"crate::\".len()..]);\n                 path_str = &resolved_self;\n-                module_id = DefId { krate: item.def_id.krate, index: CRATE_DEF_INDEX };\n+                module_id = DefId { krate, index: CRATE_DEF_INDEX };\n             }\n \n             match self.resolve_with_disambiguator(\n@@ -970,7 +997,7 @@ impl LinkCollector<'_, '_> {\n                 link_range.clone(),\n             ) {\n                 Some(x) => x,\n-                None => return,\n+                None => return None,\n             }\n         };\n \n@@ -994,15 +1021,15 @@ impl LinkCollector<'_, '_> {\n                             link_range,\n                             AnchorFailure::RustdocAnchorConflict(prim),\n                         );\n-                        return;\n+                        return None;\n                     }\n                     res = prim;\n                     fragment = Some(path.to_owned());\n                 } else {\n                     // `[char]` when a `char` module is in scope\n                     let candidates = vec![res, prim];\n                     ambiguity_error(cx, &item, path_str, dox, link_range, candidates);\n-                    return;\n+                    return None;\n                 }\n             }\n         }\n@@ -1026,16 +1053,11 @@ impl LinkCollector<'_, '_> {\n         if let Res::PrimTy(..) = res {\n             match disambiguator {\n                 Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n-                    item.attrs.links.push(ItemLink {\n-                        link: ori_link,\n-                        link_text,\n-                        did: None,\n-                        fragment,\n-                    });\n+                    Some(ItemLink { link: ori_link, link_text, did: None, fragment })\n                 }\n                 Some(other) => {\n                     report_mismatch(other, Disambiguator::Primitive);\n-                    return;\n+                    None\n                 }\n             }\n         } else {\n@@ -1058,7 +1080,7 @@ impl LinkCollector<'_, '_> {\n                     (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n                     (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n                         report_mismatch(specified, Disambiguator::Kind(kind));\n-                        return;\n+                        return None;\n                     }\n                 }\n             }\n@@ -1081,14 +1103,14 @@ impl LinkCollector<'_, '_> {\n                 }\n             }\n             let id = register_res(cx, res);\n-            item.attrs.links.push(ItemLink { link: ori_link, link_text, did: Some(id), fragment });\n+            Some(ItemLink { link: ori_link, link_text, did: Some(id), fragment })\n         }\n     }\n \n     fn resolve_with_disambiguator(\n         &self,\n         disambiguator: Option<Disambiguator>,\n-        item: &mut Item,\n+        item: &Item,\n         dox: &str,\n         path_str: &str,\n         current_item: &Option<String>,"}, {"sha": "adb072a7ed5552384f3d00139eff000ecdb43f0c", "filename": "src/test/rustdoc/intra-link-reexport-additional-docs.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e39a86019d79d0f2dc5f6cc94fcdf2f073b478e9/src%2Ftest%2Frustdoc%2Fintra-link-reexport-additional-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e39a86019d79d0f2dc5f6cc94fcdf2f073b478e9/src%2Ftest%2Frustdoc%2Fintra-link-reexport-additional-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-reexport-additional-docs.rs?ref=e39a86019d79d0f2dc5f6cc94fcdf2f073b478e9", "patch": "@@ -0,0 +1,18 @@\n+#![crate_name = \"foo\"]\n+\n+// @has foo/struct.JoinPathsError.html '//a[@href=\"../foo/fn.with_code.html\"]' 'crate::with_code'\n+/// [crate::with_code]\n+// @has - '//a[@href=\"../foo/fn.with_code.html\"]' 'different text'\n+/// [different text][with_code]\n+// @has - '//a[@href=\"../foo/fn.me_too.html\"]' 'me_too'\n+#[doc = \"[me_too]\"]\n+// @has - '//a[@href=\"../foo/fn.me_three.html\"]' 'reference link'\n+/// This [reference link]\n+#[doc = \"has an attr in the way\"]\n+///\n+/// [reference link]: me_three\n+pub use std::env::JoinPathsError;\n+\n+pub fn with_code() {}\n+pub fn me_too() {}\n+pub fn me_three() {}"}]}