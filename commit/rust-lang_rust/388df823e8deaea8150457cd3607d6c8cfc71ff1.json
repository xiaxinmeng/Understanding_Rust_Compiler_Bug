{"sha": "388df823e8deaea8150457cd3607d6c8cfc71ff1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4OGRmODIzZThkZWFlYTgxNTA0NTdjZDM2MDdkNmM4Y2ZjNzFmZjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-11T23:06:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-11T23:06:27Z"}, "message": "Auto merge of #50161 - rizakrko:impl_note, r=estebank\n\nadded missing implementation hint\n\nFixes [#50151](https://github.com/rust-lang/rust/issues/50151).\nActually, i don't know, should following code\n`let x = |ref x: isize| { x += 1; };`\nemit\n`note: an implementation of std::ops::AddAssign might be missing for &isize`\nor\n`note: this is a reference to a type that + can be applied to; you need to dereference this variable once for this operation to work`\nor both", "tree": {"sha": "ad8879b0aaacc05cace38b1d4440d7991ef3ffa3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad8879b0aaacc05cace38b1d4440d7991ef3ffa3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/388df823e8deaea8150457cd3607d6c8cfc71ff1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/388df823e8deaea8150457cd3607d6c8cfc71ff1", "html_url": "https://github.com/rust-lang/rust/commit/388df823e8deaea8150457cd3607d6c8cfc71ff1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/388df823e8deaea8150457cd3607d6c8cfc71ff1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cd465087d800f6e1183ed3e8a71262039245902", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cd465087d800f6e1183ed3e8a71262039245902", "html_url": "https://github.com/rust-lang/rust/commit/0cd465087d800f6e1183ed3e8a71262039245902"}, {"sha": "17c56d409ec43f8492b4ffd5117fcee6c4ce0a27", "url": "https://api.github.com/repos/rust-lang/rust/commits/17c56d409ec43f8492b4ffd5117fcee6c4ce0a27", "html_url": "https://github.com/rust-lang/rust/commit/17c56d409ec43f8492b4ffd5117fcee6c4ce0a27"}], "stats": {"total": 281, "additions": 201, "deletions": 80}, "files": [{"sha": "23081b87d2651e4f7ec1bfc1143d9b7d90f0aa7c", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 165, "deletions": 70, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=388df823e8deaea8150457cd3607d6c8cfc71ff1", "patch": "@@ -12,8 +12,8 @@\n \n use super::{FnCtxt, Needs};\n use super::method::MethodCallee;\n-use rustc::ty::{self, Ty, TypeFoldable, TypeVariants};\n-use rustc::ty::TypeVariants::{TyStr, TyRef, TyAdt};\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::TypeVariants::{TyRef, TyAdt, TyStr, TyUint, TyNever, TyTuple, TyChar, TyArray};\n use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use errors;\n@@ -246,76 +246,151 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Err(()) => {\n                 // error types are considered \"builtin\"\n                 if !lhs_ty.references_error() {\n-                    if let IsAssign::Yes = is_assign {\n-                        struct_span_err!(self.tcx.sess, expr.span, E0368,\n-                                         \"binary assignment operation `{}=` \\\n-                                          cannot be applied to type `{}`\",\n-                                         op.node.as_str(),\n-                                         lhs_ty)\n-                            .span_label(lhs_expr.span,\n-                                        format!(\"cannot use `{}=` on type `{}`\",\n-                                        op.node.as_str(), lhs_ty))\n-                            .emit();\n-                    } else {\n-                        let mut err = struct_span_err!(self.tcx.sess, expr.span, E0369,\n-                            \"binary operation `{}` cannot be applied to type `{}`\",\n-                            op.node.as_str(),\n-                            lhs_ty);\n-\n-                        if let TypeVariants::TyRef(_, rty, _) = lhs_ty.sty {\n-                            if {\n-                                !self.infcx.type_moves_by_default(self.param_env,\n-                                                                  rty,\n-                                                                  lhs_expr.span) &&\n-                                    self.lookup_op_method(rty,\n-                                                          &[rhs_ty],\n-                                                          Op::Binary(op, is_assign))\n-                                        .is_ok()\n-                            } {\n-                                err.note(\n-                                    &format!(\n-                                        \"this is a reference to a type that `{}` can be applied \\\n-                                        to; you need to dereference this variable once for this \\\n-                                        operation to work\",\n-                                    op.node.as_str()));\n+                    let codemap = self.tcx.sess.codemap();\n+                    match is_assign {\n+                        IsAssign::Yes => {\n+                            let mut err = struct_span_err!(self.tcx.sess, expr.span, E0368,\n+                                                \"binary assignment operation `{}=` \\\n+                                                cannot be applied to type `{}`\",\n+                                                op.node.as_str(),\n+                                                lhs_ty);\n+                            err.span_label(lhs_expr.span,\n+                                    format!(\"cannot use `{}=` on type `{}`\",\n+                                    op.node.as_str(), lhs_ty));\n+                            let mut suggested_deref = false;\n+                            if let TyRef(_, mut rty, _) = lhs_ty.sty {\n+                                if {\n+                                    !self.infcx.type_moves_by_default(self.param_env,\n+                                                                        rty,\n+                                                                        lhs_expr.span) &&\n+                                        self.lookup_op_method(rty,\n+                                                              &[rhs_ty],\n+                                                              Op::Binary(op, is_assign))\n+                                            .is_ok()\n+                                } {\n+                                    if let Ok(lstring) = codemap.span_to_snippet(lhs_expr.span) {\n+                                        while let TyRef(_, rty_inner, _) = rty.sty {\n+                                            rty = rty_inner;\n+                                        }\n+                                        let msg = &format!(\n+                                                \"`{}=` can be used on '{}', you can \\\n+                                                dereference `{2}`: `*{2}`\",\n+                                                op.node.as_str(),\n+                                                rty,\n+                                                lstring\n+                                        );\n+                                        err.help(msg);\n+                                        suggested_deref = true;\n+                                    }\n+                                }\n                             }\n+                            let missing_trait = match op.node {\n+                                hir::BiAdd    => Some(\"std::ops::AddAssign\"),\n+                                hir::BiSub    => Some(\"std::ops::SubAssign\"),\n+                                hir::BiMul    => Some(\"std::ops::MulAssign\"),\n+                                hir::BiDiv    => Some(\"std::ops::DivAssign\"),\n+                                hir::BiRem    => Some(\"std::ops::RemAssign\"),\n+                                hir::BiBitAnd => Some(\"std::ops::BitAndAssign\"),\n+                                hir::BiBitXor => Some(\"std::ops::BitXorAssign\"),\n+                                hir::BiBitOr  => Some(\"std::ops::BitOrAssign\"),\n+                                hir::BiShl    => Some(\"std::ops::ShlAssign\"),\n+                                hir::BiShr    => Some(\"std::ops::ShrAssign\"),\n+                                _             => None\n+                            };\n+                            if let Some(missing_trait) = missing_trait {\n+                                if op.node == hir::BiAdd &&\n+                                    self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n+                                                            rhs_ty, &mut err) {\n+                                    // This has nothing here because it means we did string\n+                                    // concatenation (e.g. \"Hello \" + \"World!\"). This means\n+                                    // we don't want the note in the else clause to be emitted\n+                                } else if let ty::TyParam(_) = lhs_ty.sty {\n+                                    // FIXME: point to span of param\n+                                    err.note(&format!(\n+                                        \"`{}` might need a bound for `{}`\",\n+                                        lhs_ty, missing_trait\n+                                    ));\n+                                } else if !suggested_deref {\n+                                    err.note(&format!(\n+                                        \"an implementation of `{}` might \\\n+                                         be missing for `{}`\",\n+                                        missing_trait, lhs_ty\n+                                    ));\n+                                }\n+                            }\n+                            err.emit();\n                         }\n-\n-                        let missing_trait = match op.node {\n-                            hir::BiAdd    => Some(\"std::ops::Add\"),\n-                            hir::BiSub    => Some(\"std::ops::Sub\"),\n-                            hir::BiMul    => Some(\"std::ops::Mul\"),\n-                            hir::BiDiv    => Some(\"std::ops::Div\"),\n-                            hir::BiRem    => Some(\"std::ops::Rem\"),\n-                            hir::BiBitAnd => Some(\"std::ops::BitAnd\"),\n-                            hir::BiBitOr  => Some(\"std::ops::BitOr\"),\n-                            hir::BiShl    => Some(\"std::ops::Shl\"),\n-                            hir::BiShr    => Some(\"std::ops::Shr\"),\n-                            hir::BiEq | hir::BiNe => Some(\"std::cmp::PartialEq\"),\n-                            hir::BiLt | hir::BiLe | hir::BiGt | hir::BiGe =>\n-                                Some(\"std::cmp::PartialOrd\"),\n-                            _             => None\n-                        };\n-\n-                        if let Some(missing_trait) = missing_trait {\n-                            if missing_trait == \"std::ops::Add\" &&\n-                                self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n-                                                        rhs_ty, &mut err) {\n-                                // This has nothing here because it means we did string\n-                                // concatenation (e.g. \"Hello \" + \"World!\"). This means\n-                                // we don't want the note in the else clause to be emitted\n-                            } else if let ty::TyParam(_) = lhs_ty.sty {\n-                                // FIXME: point to span of param\n-                                err.note(\n-                                    &format!(\"`{}` might need a bound for `{}`\",\n-                                             lhs_ty, missing_trait));\n-                            } else {\n-                                err.note(\n-                                    &format!(\"an implementation of `{}` might be missing for `{}`\",\n-                                             missing_trait, lhs_ty));\n+                        IsAssign::No => {\n+                            let mut err = struct_span_err!(self.tcx.sess, expr.span, E0369,\n+                                            \"binary operation `{}` cannot be applied to type `{}`\",\n+                                            op.node.as_str(),\n+                                            lhs_ty);\n+                            let mut suggested_deref = false;\n+                            if let TyRef(_, mut rty, _) = lhs_ty.sty {\n+                                if {\n+                                    !self.infcx.type_moves_by_default(self.param_env,\n+                                                                        rty,\n+                                                                        lhs_expr.span) &&\n+                                        self.lookup_op_method(rty,\n+                                                              &[rhs_ty],\n+                                                              Op::Binary(op, is_assign))\n+                                            .is_ok()\n+                                } {\n+                                    if let Ok(lstring) = codemap.span_to_snippet(lhs_expr.span) {\n+                                        while let TyRef(_, rty_inner, _) = rty.sty {\n+                                            rty = rty_inner;\n+                                        }\n+                                        let msg = &format!(\n+                                                \"`{}` can be used on '{}', you can \\\n+                                                dereference `{2}`: `*{2}`\",\n+                                                op.node.as_str(),\n+                                                rty,\n+                                                lstring\n+                                        );\n+                                        err.help(msg);\n+                                        suggested_deref = true;\n+                                    }\n+                                }\n                             }\n+                            let missing_trait = match op.node {\n+                                hir::BiAdd    => Some(\"std::ops::Add\"),\n+                                hir::BiSub    => Some(\"std::ops::Sub\"),\n+                                hir::BiMul    => Some(\"std::ops::Mul\"),\n+                                hir::BiDiv    => Some(\"std::ops::Div\"),\n+                                hir::BiRem    => Some(\"std::ops::Rem\"),\n+                                hir::BiBitAnd => Some(\"std::ops::BitAnd\"),\n+                                hir::BiBitXor => Some(\"std::ops::BitXor\"),\n+                                hir::BiBitOr  => Some(\"std::ops::BitOr\"),\n+                                hir::BiShl    => Some(\"std::ops::Shl\"),\n+                                hir::BiShr    => Some(\"std::ops::Shr\"),\n+                                hir::BiEq | hir::BiNe => Some(\"std::cmp::PartialEq\"),\n+                                hir::BiLt | hir::BiLe | hir::BiGt | hir::BiGe =>\n+                                    Some(\"std::cmp::PartialOrd\"),\n+                                _             => None\n+                            };\n+                            if let Some(missing_trait) = missing_trait {\n+                                if op.node == hir::BiAdd &&\n+                                    self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n+                                                            rhs_ty, &mut err) {\n+                                    // This has nothing here because it means we did string\n+                                    // concatenation (e.g. \"Hello \" + \"World!\"). This means\n+                                    // we don't want the note in the else clause to be emitted\n+                                } else if let ty::TyParam(_) = lhs_ty.sty {\n+                                    // FIXME: point to span of param\n+                                    err.note(&format!(\n+                                        \"`{}` might need a bound for `{}`\",\n+                                        lhs_ty, missing_trait\n+                                    ));\n+                                } else if !suggested_deref {\n+                                    err.note(&format!(\n+                                        \"an implementation of `{}` might \\\n+                                         be missing for `{}`\",\n+                                        missing_trait, lhs_ty\n+                                    ));\n+                                }\n+                            }\n+                            err.emit();\n                         }\n-                        err.emit();\n                     }\n                 }\n                 self.tcx.types.err\n@@ -393,9 +468,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Err(()) => {\n                 let actual = self.resolve_type_vars_if_possible(&operand_ty);\n                 if !actual.references_error() {\n-                    struct_span_err!(self.tcx.sess, ex.span, E0600,\n+                    let mut err = struct_span_err!(self.tcx.sess, ex.span, E0600,\n                                      \"cannot apply unary operator `{}` to type `{}`\",\n-                                     op.as_str(), actual).emit();\n+                                     op.as_str(), actual);\n+                    err.span_label(ex.span, format!(\"cannot apply unary \\\n+                                                    operator `{}`\", op.as_str()));\n+                    match actual.sty {\n+                        TyUint(_) if op == hir::UnNeg => {\n+                            err.note(&format!(\"unsigned values cannot be negated\"));\n+                        },\n+                        TyStr | TyNever | TyChar | TyTuple(_) | TyArray(_,_) => {},\n+                        TyRef(_, ref lty, _) if lty.sty == TyStr => {},\n+                        _ => {\n+                            let missing_trait = match op {\n+                                hir::UnNeg => \"std::ops::Neg\",\n+                                hir::UnNot => \"std::ops::Not\",\n+                                hir::UnDeref => \"std::ops::UnDerf\"\n+                            };\n+                            err.note(&format!(\"an implementation of `{}` might \\\n+                                                be missing for `{}`\",\n+                                             missing_trait, operand_ty));\n+                        }\n+                    }\n+                    err.emit();\n                 }\n                 self.tcx.types.err\n             }"}, {"sha": "c89defa3dd196d97a4a8822a33b37b1a933b527a", "filename": "src/test/ui/binary-op-on-double-ref.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinary-op-on-double-ref.stderr?ref=388df823e8deaea8150457cd3607d6c8cfc71ff1", "patch": "@@ -4,8 +4,7 @@ error[E0369]: binary operation `%` cannot be applied to type `&&{integer}`\n LL |         x % 2 == 0\n    |         ^^^^^\n    |\n-   = note: this is a reference to a type that `%` can be applied to; you need to dereference this variable once for this operation to work\n-   = note: an implementation of `std::ops::Rem` might be missing for `&&{integer}`\n+   = help: `%` can be used on '{integer}', you can dereference `x`: `*x`\n \n error: aborting due to previous error\n "}, {"sha": "15c159a3b153cf8f8cfcdc586eac03a2dce496ae", "filename": "src/test/ui/codemap_tests/issue-28308.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr?ref=388df823e8deaea8150457cd3607d6c8cfc71ff1", "patch": "@@ -2,7 +2,7 @@ error[E0600]: cannot apply unary operator `!` to type `&'static str`\n   --> $DIR/issue-28308.rs:12:5\n    |\n LL |     assert!(\"foo\");\n-   |     ^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^ cannot apply unary operator `!`\n \n error: aborting due to previous error\n "}, {"sha": "43e1ca4096cf69a37f9c90006a04ced496241fc9", "filename": "src/test/ui/error-codes/E0067.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Ferror-codes%2FE0067.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Ferror-codes%2FE0067.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0067.stderr?ref=388df823e8deaea8150457cd3607d6c8cfc71ff1", "patch": "@@ -5,6 +5,8 @@ LL |     LinkedList::new() += 1; //~ ERROR E0368\n    |     -----------------^^^^^\n    |     |\n    |     cannot use `+=` on type `std::collections::LinkedList<_>`\n+   |\n+   = note: an implementation of `std::ops::AddAssign` might be missing for `std::collections::LinkedList<_>`\n \n error[E0067]: invalid left-hand side expression\n   --> $DIR/E0067.rs:14:5"}, {"sha": "c29ec4fe6ae76e2f09e9ae53971e886b78deacc9", "filename": "src/test/ui/error-codes/E0600.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Ferror-codes%2FE0600.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Ferror-codes%2FE0600.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0600.stderr?ref=388df823e8deaea8150457cd3607d6c8cfc71ff1", "patch": "@@ -2,7 +2,7 @@ error[E0600]: cannot apply unary operator `!` to type `&'static str`\n   --> $DIR/E0600.rs:12:5\n    |\n LL |     !\"a\"; //~ ERROR E0600\n-   |     ^^^^\n+   |     ^^^^ cannot apply unary operator `!`\n \n error: aborting due to previous error\n "}, {"sha": "69f11b4b7c08c33c74af00c7a73a05bd941ec0aa", "filename": "src/test/ui/error-festival.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Ferror-festival.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Ferror-festival.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-festival.stderr?ref=388df823e8deaea8150457cd3607d6c8cfc71ff1", "patch": "@@ -17,6 +17,8 @@ LL |     x += 2;\n    |     -^^^^^\n    |     |\n    |     cannot use `+=` on type `&str`\n+   |\n+   = note: an implementation of `std::ops::AddAssign` might be missing for `&str`\n \n error[E0599]: no method named `z` found for type `&str` in the current scope\n   --> $DIR/error-festival.rs:26:7\n@@ -28,7 +30,9 @@ error[E0600]: cannot apply unary operator `!` to type `Question`\n   --> $DIR/error-festival.rs:29:5\n    |\n LL |     !Question::Yes;\n-   |     ^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^ cannot apply unary operator `!`\n+   |\n+   = note: an implementation of `std::ops::Not` might be missing for `Question`\n \n error[E0604]: only `u8` can be cast as `char`, not `u32`\n   --> $DIR/error-festival.rs:35:5"}, {"sha": "85e9b56e4af9db3f0caeee55d1621e7421599e08", "filename": "src/test/ui/feature-gate-negate-unsigned.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Ffeature-gate-negate-unsigned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Ffeature-gate-negate-unsigned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-negate-unsigned.stderr?ref=388df823e8deaea8150457cd3607d6c8cfc71ff1", "patch": "@@ -2,13 +2,17 @@ error[E0600]: cannot apply unary operator `-` to type `usize`\n   --> $DIR/feature-gate-negate-unsigned.rs:20:23\n    |\n LL |     let _max: usize = -1;\n-   |                       ^^\n+   |                       ^^ cannot apply unary operator `-`\n+   |\n+   = note: unsigned values cannot be negated\n \n error[E0600]: cannot apply unary operator `-` to type `u8`\n   --> $DIR/feature-gate-negate-unsigned.rs:24:14\n    |\n LL |     let _y = -x;\n-   |              ^^\n+   |              ^^ cannot apply unary operator `-`\n+   |\n+   = note: unsigned values cannot be negated\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7ae01fb7d6012996c1e80ebb82038431117b6aaa", "filename": "src/test/ui/issue-5239-1.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Fissue-5239-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Fissue-5239-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-5239-1.stderr?ref=388df823e8deaea8150457cd3607d6c8cfc71ff1", "patch": "@@ -5,6 +5,8 @@ LL |     let x = |ref x: isize| { x += 1; };\n    |                              -^^^^^\n    |                              |\n    |                              cannot use `+=` on type `&isize`\n+   |\n+   = help: `+=` can be used on 'isize', you can dereference `x`: `*x`\n \n error: aborting due to previous error\n "}, {"sha": "b889c884fcbb223f66e2eb574dc482cf6c06f908", "filename": "src/test/ui/reachable/expr_unary.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr?ref=388df823e8deaea8150457cd3607d6c8cfc71ff1", "patch": "@@ -2,7 +2,7 @@ error[E0600]: cannot apply unary operator `!` to type `!`\n   --> $DIR/expr_unary.rs:17:16\n    |\n LL |     let x: ! = ! { return; }; //~ ERROR unreachable\n-   |                ^^^^^^^^^^^^^\n+   |                ^^^^^^^^^^^^^ cannot apply unary operator `!`\n \n error: unreachable expression\n   --> $DIR/expr_unary.rs:17:16"}, {"sha": "b3e79ce2447fb564838d82ea413716b8c7ec8e03", "filename": "src/test/ui/type-check/missing_trait_impl.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Ftype-check%2Fmissing_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Ftype-check%2Fmissing_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fmissing_trait_impl.rs?ref=388df823e8deaea8150457cd3607d6c8cfc71ff1", "patch": "@@ -14,3 +14,7 @@ fn main() {\n fn foo<T>(x: T, y: T) {\n     let z = x + y; //~ ERROR binary operation `+` cannot be applied to type `T`\n }\n+\n+fn bar<T>(x: T) {\n+    x += x; //~ ERROR binary assignment operation `+=` cannot be applied to type `T`\n+}"}, {"sha": "4b01a626814e555a5427e4a316b65d970ef12c8a", "filename": "src/test/ui/type-check/missing_trait_impl.stderr", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Ftype-check%2Fmissing_trait_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/388df823e8deaea8150457cd3607d6c8cfc71ff1/src%2Ftest%2Fui%2Ftype-check%2Fmissing_trait_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fmissing_trait_impl.stderr?ref=388df823e8deaea8150457cd3607d6c8cfc71ff1", "patch": "@@ -6,6 +6,17 @@ LL |     let z = x + y; //~ ERROR binary operation `+` cannot be applied to type\n    |\n    = note: `T` might need a bound for `std::ops::Add`\n \n-error: aborting due to previous error\n+error[E0368]: binary assignment operation `+=` cannot be applied to type `T`\n+  --> $DIR/missing_trait_impl.rs:19:5\n+   |\n+LL |     x += x; //~ ERROR binary assignment operation `+=` cannot be applied to type `T`\n+   |     -^^^^^\n+   |     |\n+   |     cannot use `+=` on type `T`\n+   |\n+   = note: `T` might need a bound for `std::ops::AddAssign`\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0369`.\n+Some errors occurred: E0368, E0369.\n+For more information about an error, try `rustc --explain E0368`."}]}