{"sha": "143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "node_id": "C_kwDOAAsO6NoAKDE0M2VhYThkNDQxNjQxMjUxYWI0MWVkNzNkZWFiYTBkOGQwY2Y0YTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-23T22:25:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-23T22:25:51Z"}, "message": "Auto merge of #93970 - cjgillot:novis, r=petrochenkov\n\nRemove visibility information from HIR\n\nThe resolver exports all the necessary visibility information through the `tcx.visibility` query.\nThis PR stops having a dedicated visibility field in HIR, in order to use this query.\nWe keep a `vis_span` field for diagnostic purposes.", "tree": {"sha": "0d290ae21f7e3b0a82dc75745f8740973b7e2c5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d290ae21f7e3b0a82dc75745f8740973b7e2c5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "html_url": "https://github.com/rust-lang/rust/commit/143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de1026a67b0a3f5d6b61a1f77093af97d4799376", "url": "https://api.github.com/repos/rust-lang/rust/commits/de1026a67b0a3f5d6b61a1f77093af97d4799376", "html_url": "https://github.com/rust-lang/rust/commit/de1026a67b0a3f5d6b61a1f77093af97d4799376"}, {"sha": "0a6e1350e0bf95ce01762bf067f3a623ea33a618", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a6e1350e0bf95ce01762bf067f3a623ea33a618", "html_url": "https://github.com/rust-lang/rust/commit/0a6e1350e0bf95ce01762bf067f3a623ea33a618"}], "stats": {"total": 860, "additions": 311, "deletions": 549}, "files": [{"sha": "0f90239f4c8b39aa07822c2eed1c893bc733e997", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -290,18 +290,6 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.insert(lifetime.span, lifetime.hir_id, Node::Lifetime(lifetime));\n     }\n \n-    fn visit_vis(&mut self, visibility: &'hir Visibility<'hir>) {\n-        match visibility.node {\n-            VisibilityKind::Public | VisibilityKind::Crate(_) | VisibilityKind::Inherited => {}\n-            VisibilityKind::Restricted { hir_id, .. } => {\n-                self.insert(visibility.span, hir_id, Node::Visibility(visibility));\n-                self.with_parent(hir_id, |this| {\n-                    intravisit::walk_vis(this, visibility);\n-                });\n-            }\n-        }\n-    }\n-\n     fn visit_variant(&mut self, v: &'hir Variant<'hir>, g: &'hir Generics<'hir>, item_id: HirId) {\n         self.insert(v.span, v.id, Node::Variant(v));\n         self.with_parent(v.id, |this| {"}, {"sha": "29353d47b87e89ad36a2fed4666141b447332117", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 13, "deletions": 93, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_session::utils::NtToTokenstream;\n use rustc_session::Session;\n-use rustc_span::source_map::{respan, DesugaringKind};\n+use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n@@ -230,15 +230,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_item(&mut self, i: &Item) -> &'hir hir::Item<'hir> {\n         let mut ident = i.ident;\n-        let mut vis = self.lower_visibility(&i.vis);\n+        let vis_span = self.lower_span(i.vis.span);\n         let hir_id = self.lower_node_id(i.id);\n         let attrs = self.lower_attrs(hir_id, &i.attrs);\n-        let kind = self.lower_item_kind(i.span, i.id, hir_id, &mut ident, attrs, &mut vis, &i.kind);\n+        let kind = self.lower_item_kind(i.span, i.id, hir_id, &mut ident, attrs, vis_span, &i.kind);\n         let item = hir::Item {\n             def_id: hir_id.expect_owner(),\n             ident: self.lower_ident(ident),\n             kind,\n-            vis,\n+            vis_span,\n             span: self.lower_span(i.span),\n         };\n         self.arena.alloc(item)\n@@ -251,7 +251,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         hir_id: hir::HirId,\n         ident: &mut Ident,\n         attrs: Option<&'hir [Attribute]>,\n-        vis: &mut hir::Visibility<'hir>,\n+        vis_span: Span,\n         i: &ItemKind,\n     ) -> hir::ItemKind<'hir> {\n         match *i {\n@@ -260,7 +260,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Start with an empty prefix.\n                 let prefix = Path { segments: vec![], span: use_tree.span, tokens: None };\n \n-                self.lower_use_tree(use_tree, &prefix, id, vis, ident, attrs)\n+                self.lower_use_tree(use_tree, &prefix, id, vis_span, ident, attrs)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n                 let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n@@ -527,12 +527,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         tree: &UseTree,\n         prefix: &Path,\n         id: NodeId,\n-        vis: &mut hir::Visibility<'hir>,\n+        vis_span: Span,\n         ident: &mut Ident,\n         attrs: Option<&'hir [Attribute]>,\n     ) -> hir::ItemKind<'hir> {\n         debug!(\"lower_use_tree(tree={:?})\", tree);\n-        debug!(\"lower_use_tree: vis = {:?}\", vis);\n \n         let path = &tree.prefix;\n         let segments = prefix.segments.iter().chain(path.segments.iter()).cloned().collect();\n@@ -586,7 +585,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let res = this.lower_res(res);\n                         let path = this.lower_path_extra(res, &path, ParamMode::Explicit);\n                         let kind = hir::ItemKind::Use(path, hir::UseKind::Single);\n-                        let vis = this.rebuild_vis(&vis);\n                         if let Some(attrs) = attrs {\n                             this.attrs.insert(hir::ItemLocalId::new(0), attrs);\n                         }\n@@ -595,7 +593,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             def_id: new_id,\n                             ident: this.lower_ident(ident),\n                             kind,\n-                            vis,\n+                            vis_span,\n                             span: this.lower_span(span),\n                         };\n                         hir::OwnerNode::Item(this.arena.alloc(item))\n@@ -657,11 +655,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     // own its own names, we have to adjust the owner before\n                     // lowering the rest of the import.\n                     self.with_hir_id_owner(id, |this| {\n-                        let mut vis = this.rebuild_vis(&vis);\n                         let mut ident = *ident;\n \n                         let kind =\n-                            this.lower_use_tree(use_tree, &prefix, id, &mut vis, &mut ident, attrs);\n+                            this.lower_use_tree(use_tree, &prefix, id, vis_span, &mut ident, attrs);\n                         if let Some(attrs) = attrs {\n                             this.attrs.insert(hir::ItemLocalId::new(0), attrs);\n                         }\n@@ -670,37 +667,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             def_id: new_hir_id,\n                             ident: this.lower_ident(ident),\n                             kind,\n-                            vis,\n+                            vis_span,\n                             span: this.lower_span(use_tree.span),\n                         };\n                         hir::OwnerNode::Item(this.arena.alloc(item))\n                     });\n                 }\n \n-                // Subtle and a bit hacky: we lower the privacy level\n-                // of the list stem to \"private\" most of the time, but\n-                // not for \"restricted\" paths. The key thing is that\n-                // we don't want it to stay as `pub` (with no caveats)\n-                // because that affects rustdoc and also the lints\n-                // about `pub` items. But we can't *always* make it\n-                // private -- particularly not for restricted paths --\n-                // because it contains node-ids that would then be\n-                // unused, failing the check that HirIds are \"densely\n-                // assigned\".\n-                match vis.node {\n-                    hir::VisibilityKind::Public\n-                    | hir::VisibilityKind::Crate(_)\n-                    | hir::VisibilityKind::Inherited => {\n-                        *vis = respan(\n-                            self.lower_span(prefix.span.shrink_to_lo()),\n-                            hir::VisibilityKind::Inherited,\n-                        );\n-                    }\n-                    hir::VisibilityKind::Restricted { .. } => {\n-                        // Do nothing here, as described in the comment on the match.\n-                    }\n-                }\n-\n                 let res = self.expect_full_res_from_use(id).next().unwrap_or(Res::Err);\n                 let res = self.lower_res(res);\n                 let path = self.lower_path_extra(res, &prefix, ParamMode::Explicit);\n@@ -709,37 +682,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n-    /// many times in the HIR tree; for each occurrence, we need to assign distinct\n-    /// `NodeId`s. (See, e.g., #56128.)\n-    fn rebuild_use_path(&mut self, path: &hir::Path<'hir>) -> &'hir hir::Path<'hir> {\n-        debug!(\"rebuild_use_path(path = {:?})\", path);\n-        let segments =\n-            self.arena.alloc_from_iter(path.segments.iter().map(|seg| hir::PathSegment {\n-                ident: seg.ident,\n-                hir_id: seg.hir_id.map(|_| self.next_id()),\n-                res: seg.res,\n-                args: None,\n-                infer_args: seg.infer_args,\n-            }));\n-        self.arena.alloc(hir::Path { span: path.span, res: path.res, segments })\n-    }\n-\n-    fn rebuild_vis(&mut self, vis: &hir::Visibility<'hir>) -> hir::Visibility<'hir> {\n-        let vis_kind = match vis.node {\n-            hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n-            hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n-            hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n-            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n-                hir::VisibilityKind::Restricted {\n-                    path: self.rebuild_use_path(path),\n-                    hir_id: self.next_id(),\n-                }\n-            }\n-        };\n-        respan(self.lower_span(vis.span), vis_kind)\n-    }\n-\n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> &'hir hir::ForeignItem<'hir> {\n         let hir_id = self.lower_node_id(i.id);\n         let def_id = hir_id.expect_owner();\n@@ -773,7 +715,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ForeignItemKind::TyAlias(..) => hir::ForeignItemKind::Type,\n                 ForeignItemKind::MacCall(_) => panic!(\"macro shouldn't exist here\"),\n             },\n-            vis: self.lower_visibility(&i.vis),\n+            vis_span: self.lower_span(i.vis.span),\n             span: self.lower_span(i.span),\n         };\n         self.arena.alloc(item)\n@@ -851,7 +793,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // FIXME(jseyfried): positional field hygiene.\n                 None => Ident::new(sym::integer(index), self.lower_span(f.span)),\n             },\n-            vis: self.lower_visibility(&f.vis),\n+            vis_span: self.lower_span(f.vis.span),\n             ty,\n         }\n     }\n@@ -1016,8 +958,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             def_id: hir_id.expect_owner(),\n             ident: self.lower_ident(i.ident),\n             generics,\n-            vis: self.lower_visibility(&i.vis),\n             kind,\n+            vis_span: self.lower_span(i.vis.span),\n             span: self.lower_span(i.span),\n         };\n         self.arena.alloc(item)\n@@ -1044,28 +986,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    /// If an `explicit_owner` is given, this method allocates the `HirId` in\n-    /// the address space of that item instead of the item currently being\n-    /// lowered. This can happen during `lower_impl_item_ref()` where we need to\n-    /// lower a `Visibility` value although we haven't lowered the owning\n-    /// `ImplItem` in question yet.\n-    fn lower_visibility(&mut self, v: &Visibility) -> hir::Visibility<'hir> {\n-        let node = match v.kind {\n-            VisibilityKind::Public => hir::VisibilityKind::Public,\n-            VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n-            VisibilityKind::Restricted { ref path, id } => {\n-                debug!(\"lower_visibility: restricted path id = {:?}\", id);\n-                let lowered_id = self.lower_node_id(id);\n-                hir::VisibilityKind::Restricted {\n-                    path: self.lower_path(id, path, ParamMode::Explicit),\n-                    hir_id: lowered_id,\n-                }\n-            }\n-            VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n-        };\n-        respan(self.lower_span(v.span), node)\n-    }\n-\n     fn lower_defaultness(\n         &self,\n         d: Defaultness,"}, {"sha": "b15f299b5f2cb9e5da02d6131f0a44d80d18a9c0", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -61,7 +61,7 @@ use rustc_session::parse::feature_err;\n use rustc_session::utils::{FlattenNonterminals, NtToTokenstream};\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnId, MacroKind};\n-use rustc_span::source_map::{respan, DesugaringKind};\n+use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -1530,7 +1530,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             def_id: opaque_ty_id,\n             ident: Ident::empty(),\n             kind: opaque_ty_item_kind,\n-            vis: respan(self.lower_span(span.shrink_to_lo()), hir::VisibilityKind::Inherited),\n+            vis_span: self.lower_span(span.shrink_to_lo()),\n             span: self.lower_span(opaque_ty_span),\n         };\n         hir::OwnerNode::Item(self.arena.alloc(opaque_ty_item))"}, {"sha": "ef56093bed8d9f6dbe0979d47013fe03ae65290c", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 11, "deletions": 36, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -4,8 +4,8 @@ crate use crate::hir_id::{HirId, ItemLocalId};\n use crate::intravisit::FnKind;\n use crate::LangItem;\n \n+use rustc_ast as ast;\n use rustc_ast::util::parser::ExprPrecedence;\n-use rustc_ast::{self as ast, CrateSugar};\n use rustc_ast::{Attribute, FloatTy, IntTy, Label, LitKind, TraitObjectSyntax, UintTy};\n pub use rustc_ast::{BorrowKind, ImplPolarity, IsAuto};\n pub use rustc_ast::{CaptureBy, Movability, Mutability};\n@@ -2140,10 +2140,10 @@ impl ImplItemId {\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n     pub def_id: LocalDefId,\n-    pub vis: Visibility<'hir>,\n     pub generics: Generics<'hir>,\n     pub kind: ImplItemKind<'hir>,\n     pub span: Span,\n+    pub vis_span: Span,\n }\n \n impl ImplItem<'_> {\n@@ -2645,34 +2645,11 @@ pub struct PolyTraitRef<'hir> {\n     pub span: Span,\n }\n \n-pub type Visibility<'hir> = Spanned<VisibilityKind<'hir>>;\n-\n-#[derive(Copy, Clone, Debug, HashStable_Generic)]\n-pub enum VisibilityKind<'hir> {\n-    Public,\n-    Crate(CrateSugar),\n-    Restricted { path: &'hir Path<'hir>, hir_id: HirId },\n-    Inherited,\n-}\n-\n-impl VisibilityKind<'_> {\n-    pub fn is_pub(&self) -> bool {\n-        matches!(*self, VisibilityKind::Public)\n-    }\n-\n-    pub fn is_pub_restricted(&self) -> bool {\n-        match *self {\n-            VisibilityKind::Public | VisibilityKind::Inherited => false,\n-            VisibilityKind::Crate(..) | VisibilityKind::Restricted { .. } => true,\n-        }\n-    }\n-}\n-\n #[derive(Debug, HashStable_Generic)]\n pub struct FieldDef<'hir> {\n     pub span: Span,\n+    pub vis_span: Span,\n     pub ident: Ident,\n-    pub vis: Visibility<'hir>,\n     pub hir_id: HirId,\n     pub ty: &'hir Ty<'hir>,\n }\n@@ -2744,8 +2721,8 @@ pub struct Item<'hir> {\n     pub ident: Ident,\n     pub def_id: LocalDefId,\n     pub kind: ItemKind<'hir>,\n-    pub vis: Visibility<'hir>,\n     pub span: Span,\n+    pub vis_span: Span,\n }\n \n impl Item<'_> {\n@@ -3002,7 +2979,7 @@ pub struct ForeignItem<'hir> {\n     pub kind: ForeignItemKind<'hir>,\n     pub def_id: LocalDefId,\n     pub span: Span,\n-    pub vis: Visibility<'hir>,\n+    pub vis_span: Span,\n }\n \n impl ForeignItem<'_> {\n@@ -3210,7 +3187,6 @@ pub enum Node<'hir> {\n \n     Lifetime(&'hir Lifetime),\n     GenericParam(&'hir GenericParam<'hir>),\n-    Visibility(&'hir Visibility<'hir>),\n \n     Crate(&'hir Mod<'hir>),\n \n@@ -3253,7 +3229,6 @@ impl<'hir> Node<'hir> {\n             | Node::Binding(..)\n             | Node::Arm(..)\n             | Node::Local(..)\n-            | Node::Visibility(..)\n             | Node::Crate(..)\n             | Node::Ty(..)\n             | Node::TraitRef(..)\n@@ -3318,18 +3293,18 @@ impl<'hir> Node<'hir> {\n         match self {\n             Node::Item(i) => match i.kind {\n                 ItemKind::Fn(ref sig, ref generics, _) => {\n-                    Some(FnKind::ItemFn(i.ident, generics, sig.header, &i.vis))\n+                    Some(FnKind::ItemFn(i.ident, generics, sig.header))\n                 }\n                 _ => None,\n             },\n             Node::TraitItem(ti) => match ti.kind {\n                 TraitItemKind::Fn(ref sig, TraitFn::Provided(_)) => {\n-                    Some(FnKind::Method(ti.ident, sig, None))\n+                    Some(FnKind::Method(ti.ident, sig))\n                 }\n                 _ => None,\n             },\n             Node::ImplItem(ii) => match ii.kind {\n-                ImplItemKind::Fn(ref sig, _) => Some(FnKind::Method(ii.ident, sig, Some(&ii.vis))),\n+                ImplItemKind::Fn(ref sig, _) => Some(FnKind::Method(ii.ident, sig)),\n                 _ => None,\n             },\n             Node::Expr(e) => match e.kind {\n@@ -3350,8 +3325,8 @@ mod size_asserts {\n     rustc_data_structures::static_assert_size!(super::QPath<'static>, 24);\n     rustc_data_structures::static_assert_size!(super::Ty<'static>, 72);\n \n-    rustc_data_structures::static_assert_size!(super::Item<'static>, 184);\n+    rustc_data_structures::static_assert_size!(super::Item<'static>, 160);\n     rustc_data_structures::static_assert_size!(super::TraitItem<'static>, 128);\n-    rustc_data_structures::static_assert_size!(super::ImplItem<'static>, 144);\n-    rustc_data_structures::static_assert_size!(super::ForeignItem<'static>, 136);\n+    rustc_data_structures::static_assert_size!(super::ImplItem<'static>, 120);\n+    rustc_data_structures::static_assert_size!(super::ForeignItem<'static>, 112);\n }"}, {"sha": "59bd46ae353b2f23611d087d0ba11de57ec68614", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -100,10 +100,10 @@ where\n #[derive(Copy, Clone, Debug)]\n pub enum FnKind<'a> {\n     /// `#[xxx] pub async/const/extern \"Abi\" fn foo()`\n-    ItemFn(Ident, &'a Generics<'a>, FnHeader, &'a Visibility<'a>),\n+    ItemFn(Ident, &'a Generics<'a>, FnHeader),\n \n     /// `fn foo(&self)`\n-    Method(Ident, &'a FnSig<'a>, Option<&'a Visibility<'a>>),\n+    Method(Ident, &'a FnSig<'a>),\n \n     /// `|x, y| {}`\n     Closure,\n@@ -112,8 +112,8 @@ pub enum FnKind<'a> {\n impl<'a> FnKind<'a> {\n     pub fn header(&self) -> Option<&FnHeader> {\n         match *self {\n-            FnKind::ItemFn(_, _, ref header, _) => Some(header),\n-            FnKind::Method(_, ref sig, _) => Some(&sig.header),\n+            FnKind::ItemFn(_, _, ref header) => Some(header),\n+            FnKind::Method(_, ref sig) => Some(&sig.header),\n             FnKind::Closure => None,\n         }\n     }\n@@ -475,9 +475,6 @@ pub trait Visitor<'v>: Sized {\n         walk_assoc_type_binding(self, type_binding)\n     }\n     fn visit_attribute(&mut self, _id: HirId, _attr: &'v Attribute) {}\n-    fn visit_vis(&mut self, vis: &'v Visibility<'v>) {\n-        walk_vis(self, vis)\n-    }\n     fn visit_associated_item_kind(&mut self, kind: &'v AssocItemKind) {\n         walk_associated_item_kind(self, kind);\n     }\n@@ -554,7 +551,6 @@ pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param<'v>) {\n }\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n-    visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.ident);\n     match item.kind {\n         ItemKind::ExternCrate(orig_name) => {\n@@ -572,7 +568,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             visitor.visit_nested_body(body);\n         }\n         ItemKind::Fn(ref sig, ref generics, body_id) => visitor.visit_fn(\n-            FnKind::ItemFn(item.ident, generics, sig.header, &item.vis),\n+            FnKind::ItemFn(item.ident, generics, sig.header),\n             &sig.decl,\n             body_id,\n             item.span,\n@@ -859,7 +855,6 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n \n pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem<'v>) {\n     visitor.visit_id(foreign_item.hir_id());\n-    visitor.visit_vis(&foreign_item.vis);\n     visitor.visit_ident(foreign_item.ident);\n \n     match foreign_item.kind {\n@@ -999,7 +994,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n         }\n         TraitItemKind::Fn(ref sig, TraitFn::Provided(body_id)) => {\n             visitor.visit_fn(\n-                FnKind::Method(trait_item.ident, sig, None),\n+                FnKind::Method(trait_item.ident, sig),\n                 &sig.decl,\n                 body_id,\n                 trait_item.span,\n@@ -1025,10 +1020,9 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n-    let ImplItem { def_id: _, ident, ref vis, ref generics, ref kind, span: _ } = *impl_item;\n+    let ImplItem { def_id: _, ident, ref generics, ref kind, span: _, vis_span: _ } = *impl_item;\n \n     visitor.visit_ident(ident);\n-    visitor.visit_vis(vis);\n     visitor.visit_generics(generics);\n     match *kind {\n         ImplItemKind::Const(ref ty, body) => {\n@@ -1038,7 +1032,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n         }\n         ImplItemKind::Fn(ref sig, body_id) => {\n             visitor.visit_fn(\n-                FnKind::Method(impl_item.ident, sig, Some(&impl_item.vis)),\n+                FnKind::Method(impl_item.ident, sig),\n                 &sig.decl,\n                 body_id,\n                 impl_item.span,\n@@ -1082,7 +1076,6 @@ pub fn walk_struct_def<'v, V: Visitor<'v>>(\n \n pub fn walk_field_def<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v FieldDef<'v>) {\n     visitor.visit_id(field.hir_id);\n-    visitor.visit_vis(&field.vis);\n     visitor.visit_ident(field.ident);\n     visitor.visit_ty(&field.ty);\n }\n@@ -1250,13 +1243,6 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n     visitor.visit_expr(&arm.body);\n }\n \n-pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility<'v>) {\n-    if let VisibilityKind::Restricted { ref path, hir_id } = vis.node {\n-        visitor.visit_id(hir_id);\n-        visitor.visit_path(path, hir_id)\n-    }\n-}\n-\n pub fn walk_associated_item_kind<'v, V: Visitor<'v>>(_: &mut V, _: &'v AssocItemKind) {\n     // No visitable content here: this fn exists so you can call it if\n     // the right thing to do, should content be added in the future,"}, {"sha": "87ff94577836cfcccd89d382c2eb98bc252356b9", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 27, "deletions": 80, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -8,12 +8,11 @@ use rustc_ast_pretty::pprust::{Comments, PrintState};\n use rustc_hir as hir;\n use rustc_hir::{GenericArg, GenericParam, GenericParamKind, Node, Term};\n use rustc_hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n-use rustc_span::source_map::{SourceMap, Spanned};\n+use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, Ident, IdentPrinter, Symbol};\n use rustc_span::{self, FileName};\n use rustc_target::spec::abi::Abi;\n \n-use std::borrow::Cow;\n use std::cell::Cell;\n use std::vec;\n \n@@ -98,7 +97,6 @@ impl<'a> State<'a> {\n                 self.print_block(&a)\n             }\n             Node::Lifetime(a) => self.print_lifetime(&a),\n-            Node::Visibility(a) => self.print_visibility(&a),\n             Node::GenericParam(_) => panic!(\"cannot print Node::GenericParam\"),\n             Node::Field(_) => panic!(\"cannot print Node::Field\"),\n             // These cases do not carry enough information in the\n@@ -191,13 +189,6 @@ where\n     printer.s.eof()\n }\n \n-pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility<'_>, w: S) -> String {\n-    to_string(NO_ANN, |s| {\n-        s.print_visibility(vis);\n-        s.word(w)\n-    })\n-}\n-\n pub fn generic_params_to_string(generic_params: &[GenericParam<'_>]) -> String {\n     to_string(NO_ANN, |s| s.print_generic_params(generic_params))\n }\n@@ -223,21 +214,19 @@ pub fn fn_to_string(\n     header: hir::FnHeader,\n     name: Option<Symbol>,\n     generics: &hir::Generics<'_>,\n-    vis: &hir::Visibility<'_>,\n     arg_names: &[Ident],\n     body_id: Option<hir::BodyId>,\n ) -> String {\n-    to_string(NO_ANN, |s| s.print_fn(decl, header, name, generics, vis, arg_names, body_id))\n+    to_string(NO_ANN, |s| s.print_fn(decl, header, name, generics, arg_names, body_id))\n }\n \n pub fn enum_def_to_string(\n     enum_definition: &hir::EnumDef<'_>,\n     generics: &hir::Generics<'_>,\n     name: Symbol,\n     span: rustc_span::Span,\n-    visibility: &hir::Visibility<'_>,\n ) -> String {\n-    to_string(NO_ANN, |s| s.print_enum_def(enum_definition, generics, name, span, visibility))\n+    to_string(NO_ANN, |s| s.print_enum_def(enum_definition, generics, name, span))\n }\n \n impl<'a> State<'a> {\n@@ -395,7 +384,6 @@ impl<'a> State<'a> {\n                     },\n                     Some(item.ident.name),\n                     generics,\n-                    &item.vis,\n                     arg_names,\n                     None,\n                 );\n@@ -404,7 +392,7 @@ impl<'a> State<'a> {\n                 self.end() // end the outer fn box\n             }\n             hir::ForeignItemKind::Static(ref t, m) => {\n-                self.head(visibility_qualified(&item.vis, \"static\"));\n+                self.head(\"static\");\n                 if m == hir::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n@@ -416,7 +404,7 @@ impl<'a> State<'a> {\n                 self.end() // end the outer cbox\n             }\n             hir::ForeignItemKind::Type => {\n-                self.head(visibility_qualified(&item.vis, \"type\"));\n+                self.head(\"type\");\n                 self.print_ident(item.ident);\n                 self.word(\";\");\n                 self.end(); // end the head-ibox\n@@ -430,9 +418,8 @@ impl<'a> State<'a> {\n         ident: Ident,\n         ty: &hir::Ty<'_>,\n         default: Option<hir::BodyId>,\n-        vis: &hir::Visibility<'_>,\n     ) {\n-        self.word(visibility_qualified(vis, \"\"));\n+        self.head(\"\");\n         self.word_space(\"const\");\n         self.print_ident(ident);\n         self.word_space(\":\");\n@@ -473,7 +460,7 @@ impl<'a> State<'a> {\n         generics: &hir::Generics<'_>,\n         inner: impl Fn(&mut Self),\n     ) {\n-        self.head(visibility_qualified(&item.vis, \"type\"));\n+        self.head(\"type\");\n         self.print_ident(item.ident);\n         self.print_generic_params(&generics.params);\n         self.end(); // end the inner ibox\n@@ -494,7 +481,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Item(item));\n         match item.kind {\n             hir::ItemKind::ExternCrate(orig_name) => {\n-                self.head(visibility_qualified(&item.vis, \"extern crate\"));\n+                self.head(\"extern crate\");\n                 if let Some(orig_name) = orig_name {\n                     self.print_name(orig_name);\n                     self.space();\n@@ -507,7 +494,7 @@ impl<'a> State<'a> {\n                 self.end(); // end outer head-block\n             }\n             hir::ItemKind::Use(ref path, kind) => {\n-                self.head(visibility_qualified(&item.vis, \"use\"));\n+                self.head(\"use\");\n                 self.print_path(path, false);\n \n                 match kind {\n@@ -526,7 +513,7 @@ impl<'a> State<'a> {\n                 self.end(); // end outer head-block\n             }\n             hir::ItemKind::Static(ref ty, m, expr) => {\n-                self.head(visibility_qualified(&item.vis, \"static\"));\n+                self.head(\"static\");\n                 if m == hir::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n@@ -542,7 +529,7 @@ impl<'a> State<'a> {\n                 self.end(); // end the outer cbox\n             }\n             hir::ItemKind::Const(ref ty, expr) => {\n-                self.head(visibility_qualified(&item.vis, \"const\"));\n+                self.head(\"const\");\n                 self.print_ident(item.ident);\n                 self.word_space(\":\");\n                 self.print_type(&ty);\n@@ -561,7 +548,6 @@ impl<'a> State<'a> {\n                     sig.header,\n                     Some(item.ident.name),\n                     param_names,\n-                    &item.vis,\n                     &[],\n                     Some(body),\n                 );\n@@ -571,12 +557,10 @@ impl<'a> State<'a> {\n                 self.ann.nested(self, Nested::Body(body));\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n-                self.print_mac_def(macro_def, &item.ident, item.span, |state| {\n-                    state.print_visibility(&item.vis)\n-                });\n+                self.print_mac_def(macro_def, &item.ident, item.span, |_| {});\n             }\n             hir::ItemKind::Mod(ref _mod) => {\n-                self.head(visibility_qualified(&item.vis, \"mod\"));\n+                self.head(\"mod\");\n                 self.print_ident(item.ident);\n                 self.nbsp();\n                 self.bopen();\n@@ -594,7 +578,7 @@ impl<'a> State<'a> {\n                 self.bclose(item.span);\n             }\n             hir::ItemKind::GlobalAsm(ref asm) => {\n-                self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n+                self.head(\"global_asm!\");\n                 self.print_inline_asm(asm);\n                 self.end()\n             }\n@@ -620,14 +604,14 @@ impl<'a> State<'a> {\n                 });\n             }\n             hir::ItemKind::Enum(ref enum_definition, ref params) => {\n-                self.print_enum_def(enum_definition, params, item.ident.name, item.span, &item.vis);\n+                self.print_enum_def(enum_definition, params, item.ident.name, item.span);\n             }\n             hir::ItemKind::Struct(ref struct_def, ref generics) => {\n-                self.head(visibility_qualified(&item.vis, \"struct\"));\n+                self.head(\"struct\");\n                 self.print_struct(struct_def, generics, item.ident.name, item.span, true);\n             }\n             hir::ItemKind::Union(ref struct_def, ref generics) => {\n-                self.head(visibility_qualified(&item.vis, \"union\"));\n+                self.head(\"union\");\n                 self.print_struct(struct_def, generics, item.ident.name, item.span, true);\n             }\n             hir::ItemKind::Impl(hir::Impl {\n@@ -642,7 +626,6 @@ impl<'a> State<'a> {\n                 items,\n             }) => {\n                 self.head(\"\");\n-                self.print_visibility(&item.vis);\n                 self.print_defaultness(defaultness);\n                 self.print_unsafety(unsafety);\n                 self.word_nbsp(\"impl\");\n@@ -679,7 +662,6 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, trait_items) => {\n                 self.head(\"\");\n-                self.print_visibility(&item.vis);\n                 self.print_is_auto(is_auto);\n                 self.print_unsafety(unsafety);\n                 self.word_nbsp(\"trait\");\n@@ -705,7 +687,7 @@ impl<'a> State<'a> {\n                 self.bclose(item.span);\n             }\n             hir::ItemKind::TraitAlias(ref generics, ref bounds) => {\n-                self.head(visibility_qualified(&item.vis, \"trait\"));\n+                self.head(\"trait\");\n                 self.print_ident(item.ident);\n                 self.print_generic_params(&generics.params);\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n@@ -753,9 +735,8 @@ impl<'a> State<'a> {\n         generics: &hir::Generics<'_>,\n         name: Symbol,\n         span: rustc_span::Span,\n-        visibility: &hir::Visibility<'_>,\n     ) {\n-        self.head(visibility_qualified(visibility, \"enum\"));\n+        self.head(\"enum\");\n         self.print_name(name);\n         self.print_generic_params(&generics.params);\n         self.print_where_clause(&generics.where_clause);\n@@ -778,27 +759,6 @@ impl<'a> State<'a> {\n         self.bclose(span)\n     }\n \n-    pub fn print_visibility(&mut self, vis: &hir::Visibility<'_>) {\n-        match vis.node {\n-            hir::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n-            hir::VisibilityKind::Crate(ast::CrateSugar::JustCrate) => self.word_nbsp(\"crate\"),\n-            hir::VisibilityKind::Crate(ast::CrateSugar::PubCrate) => self.word_nbsp(\"pub(crate)\"),\n-            hir::VisibilityKind::Restricted { ref path, .. } => {\n-                self.word(\"pub(\");\n-                if path.segments.len() == 1 && path.segments[0].ident.name == kw::Super {\n-                    // Special case: `super` can print like `pub(super)`.\n-                    self.word(\"super\");\n-                } else {\n-                    // Everything else requires `in` at present.\n-                    self.word_nbsp(\"in\");\n-                    self.print_path(path, false);\n-                }\n-                self.word_nbsp(\")\");\n-            }\n-            hir::VisibilityKind::Inherited => (),\n-        }\n-    }\n-\n     pub fn print_defaultness(&mut self, defaultness: hir::Defaultness) {\n         match defaultness {\n             hir::Defaultness::Default { .. } => self.word_nbsp(\"default\"),\n@@ -823,7 +783,6 @@ impl<'a> State<'a> {\n                     self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n                         s.maybe_print_comment(field.span.lo());\n                         s.print_outer_attributes(s.attrs(field.hir_id));\n-                        s.print_visibility(&field.vis);\n                         s.print_type(&field.ty)\n                     });\n                     self.pclose();\n@@ -845,7 +804,6 @@ impl<'a> State<'a> {\n                     self.hardbreak_if_not_bol();\n                     self.maybe_print_comment(field.span.lo());\n                     self.print_outer_attributes(self.attrs(field.hir_id));\n-                    self.print_visibility(&field.vis);\n                     self.print_ident(field.ident);\n                     self.word_nbsp(\":\");\n                     self.print_type(&field.ty);\n@@ -872,11 +830,10 @@ impl<'a> State<'a> {\n         ident: Ident,\n         m: &hir::FnSig<'_>,\n         generics: &hir::Generics<'_>,\n-        vis: &hir::Visibility<'_>,\n         arg_names: &[Ident],\n         body_id: Option<hir::BodyId>,\n     ) {\n-        self.print_fn(&m.decl, m.header, Some(ident.name), generics, vis, arg_names, body_id)\n+        self.print_fn(&m.decl, m.header, Some(ident.name), generics, arg_names, body_id)\n     }\n \n     pub fn print_trait_item(&mut self, ti: &hir::TraitItem<'_>) {\n@@ -886,21 +843,15 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(self.attrs(ti.hir_id()));\n         match ti.kind {\n             hir::TraitItemKind::Const(ref ty, default) => {\n-                let vis =\n-                    Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Inherited };\n-                self.print_associated_const(ti.ident, &ty, default, &vis);\n+                self.print_associated_const(ti.ident, &ty, default);\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(ref arg_names)) => {\n-                let vis =\n-                    Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Inherited };\n-                self.print_method_sig(ti.ident, sig, &ti.generics, &vis, arg_names, None);\n+                self.print_method_sig(ti.ident, sig, &ti.generics, arg_names, None);\n                 self.word(\";\");\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                let vis =\n-                    Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Inherited };\n                 self.head(\"\");\n-                self.print_method_sig(ti.ident, sig, &ti.generics, &vis, &[], Some(body));\n+                self.print_method_sig(ti.ident, sig, &ti.generics, &[], Some(body));\n                 self.nbsp();\n                 self.end(); // need to close a box\n                 self.end(); // need to close a box\n@@ -926,11 +877,11 @@ impl<'a> State<'a> {\n \n         match ii.kind {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n-                self.print_associated_const(ii.ident, &ty, Some(expr), &ii.vis);\n+                self.print_associated_const(ii.ident, &ty, Some(expr));\n             }\n             hir::ImplItemKind::Fn(ref sig, body) => {\n                 self.head(\"\");\n-                self.print_method_sig(ii.ident, sig, &ii.generics, &ii.vis, &[], Some(body));\n+                self.print_method_sig(ii.ident, sig, &ii.generics, &[], Some(body));\n                 self.nbsp();\n                 self.end(); // need to close a box\n                 self.end(); // need to close a box\n@@ -2008,11 +1959,10 @@ impl<'a> State<'a> {\n         header: hir::FnHeader,\n         name: Option<Symbol>,\n         generics: &hir::Generics<'_>,\n-        vis: &hir::Visibility<'_>,\n         arg_names: &[Ident],\n         body_id: Option<hir::BodyId>,\n     ) {\n-        self.print_fn_header_info(header, vis);\n+        self.print_fn_header_info(header);\n \n         if let Some(name) = name {\n             self.nbsp();\n@@ -2301,16 +2251,13 @@ impl<'a> State<'a> {\n             },\n             name,\n             &generics,\n-            &Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Inherited },\n             arg_names,\n             None,\n         );\n         self.end();\n     }\n \n-    pub fn print_fn_header_info(&mut self, header: hir::FnHeader, vis: &hir::Visibility<'_>) {\n-        self.word(visibility_qualified(vis, \"\"));\n-\n+    pub fn print_fn_header_info(&mut self, header: hir::FnHeader) {\n         match header.constness {\n             hir::Constness::NotConst => {}\n             hir::Constness::Const => self.word_nbsp(\"const\"),"}, {"sha": "68658e2616e9b76c697e1166374a1ebbbc09f05f", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 50, "deletions": 61, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -36,8 +36,7 @@ use rustc_feature::{deprecated_attributes, AttributeGate, BuiltinAttribute, Gate\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n-use rustc_hir::{ForeignItemKind, GenericParamKind, PatKind};\n-use rustc_hir::{HirId, Node};\n+use rustc_hir::{ForeignItemKind, GenericParamKind, HirId, PatKind};\n use rustc_index::vec::Idx;\n use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n@@ -487,9 +486,6 @@ declare_lint! {\n pub struct MissingDoc {\n     /// Stack of whether `#[doc(hidden)]` is set at each level which has lint attributes.\n     doc_hidden_stack: Vec<bool>,\n-\n-    /// Private traits or trait items that leaked through. Don't check their methods.\n-    private_traits: FxHashSet<hir::HirId>,\n }\n \n impl_lint_pass!(MissingDoc => [MISSING_DOCS]);\n@@ -520,7 +516,7 @@ fn has_doc(attr: &ast::Attribute) -> bool {\n \n impl MissingDoc {\n     pub fn new() -> MissingDoc {\n-        MissingDoc { doc_hidden_stack: vec![false], private_traits: FxHashSet::default() }\n+        MissingDoc { doc_hidden_stack: vec![false] }\n     }\n \n     fn doc_hidden(&self) -> bool {\n@@ -598,30 +594,16 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         match it.kind {\n-            hir::ItemKind::Trait(.., trait_item_refs) => {\n+            hir::ItemKind::Trait(..) => {\n                 // Issue #11592: traits are always considered exported, even when private.\n-                if let hir::VisibilityKind::Inherited = it.vis.node {\n-                    self.private_traits.insert(it.hir_id());\n-                    for trait_item_ref in trait_item_refs {\n-                        self.private_traits.insert(trait_item_ref.id.hir_id());\n-                    }\n+                if cx.tcx.visibility(it.def_id)\n+                    == ty::Visibility::Restricted(\n+                        cx.tcx.parent_module_from_def_id(it.def_id).to_def_id(),\n+                    )\n+                {\n                     return;\n                 }\n             }\n-            hir::ItemKind::Impl(hir::Impl { of_trait: Some(ref trait_ref), items, .. }) => {\n-                // If the trait is private, add the impl items to `private_traits` so they don't get\n-                // reported for missing docs.\n-                let real_trait = trait_ref.path.res.def_id();\n-                let Some(def_id) = real_trait.as_local() else { return };\n-                let Some(Node::Item(item)) = cx.tcx.hir().find_by_def_id(def_id) else { return };\n-                if let hir::VisibilityKind::Inherited = item.vis.node {\n-                    for impl_item_ref in items {\n-                        self.private_traits.insert(impl_item_ref.id.hir_id());\n-                    }\n-                }\n-                return;\n-            }\n-\n             hir::ItemKind::TyAlias(..)\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::Macro(..)\n@@ -641,10 +623,6 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_>, trait_item: &hir::TraitItem<'_>) {\n-        if self.private_traits.contains(&trait_item.hir_id()) {\n-            return;\n-        }\n-\n         let (article, desc) = cx.tcx.article_and_description(trait_item.def_id.to_def_id());\n \n         self.check_missing_docs_attrs(cx, trait_item.def_id, trait_item.span, article, desc);\n@@ -1384,66 +1362,77 @@ impl UnreachablePub {\n         cx: &LateContext<'_>,\n         what: &str,\n         def_id: LocalDefId,\n-        vis: &hir::Visibility<'_>,\n         span: Span,\n+        vis_span: Span,\n         exportable: bool,\n     ) {\n         let mut applicability = Applicability::MachineApplicable;\n-        match vis.node {\n-            hir::VisibilityKind::Public if !cx.access_levels.is_reachable(def_id) => {\n-                if span.from_expansion() {\n-                    applicability = Applicability::MaybeIncorrect;\n+        if cx.tcx.visibility(def_id).is_public() && !cx.access_levels.is_reachable(def_id) {\n+            if vis_span.from_expansion() {\n+                applicability = Applicability::MaybeIncorrect;\n+            }\n+            let def_span = cx.tcx.sess.source_map().guess_head_span(span);\n+            cx.struct_span_lint(UNREACHABLE_PUB, def_span, |lint| {\n+                let mut err = lint.build(&format!(\"unreachable `pub` {}\", what));\n+                let replacement = if cx.tcx.features().crate_visibility_modifier {\n+                    \"crate\"\n+                } else {\n+                    \"pub(crate)\"\n                 }\n-                let def_span = cx.tcx.sess.source_map().guess_head_span(span);\n-                cx.struct_span_lint(UNREACHABLE_PUB, def_span, |lint| {\n-                    let mut err = lint.build(&format!(\"unreachable `pub` {}\", what));\n-                    let replacement = if cx.tcx.features().crate_visibility_modifier {\n-                        \"crate\"\n-                    } else {\n-                        \"pub(crate)\"\n-                    }\n-                    .to_owned();\n+                .to_owned();\n \n-                    err.span_suggestion(\n-                        vis.span,\n-                        \"consider restricting its visibility\",\n-                        replacement,\n-                        applicability,\n-                    );\n-                    if exportable {\n-                        err.help(\"or consider exporting it for use by other crates\");\n-                    }\n-                    err.emit();\n-                });\n-            }\n-            _ => {}\n+                err.span_suggestion(\n+                    vis_span,\n+                    \"consider restricting its visibility\",\n+                    replacement,\n+                    applicability,\n+                );\n+                if exportable {\n+                    err.help(\"or consider exporting it for use by other crates\");\n+                }\n+                err.emit();\n+            });\n         }\n     }\n }\n \n impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        self.perform_lint(cx, \"item\", item.def_id, &item.vis, item.span, true);\n+        // Do not warn for fake `use` statements.\n+        if let hir::ItemKind::Use(_, hir::UseKind::ListStem) = &item.kind {\n+            return;\n+        }\n+        self.perform_lint(cx, \"item\", item.def_id, item.span, item.vis_span, true);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'tcx>) {\n         self.perform_lint(\n             cx,\n             \"item\",\n             foreign_item.def_id,\n-            &foreign_item.vis,\n             foreign_item.span,\n+            foreign_item.vis_span,\n             true,\n         );\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n         let def_id = cx.tcx.hir().local_def_id(field.hir_id);\n-        self.perform_lint(cx, \"field\", def_id, &field.vis, field.span, false);\n+        self.perform_lint(cx, \"field\", def_id, field.span, field.vis_span, false);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n-        self.perform_lint(cx, \"item\", impl_item.def_id, &impl_item.vis, impl_item.span, false);\n+        // Only lint inherent impl items.\n+        if cx.tcx.associated_item(impl_item.def_id).trait_item_def_id.is_none() {\n+            self.perform_lint(\n+                cx,\n+                \"item\",\n+                impl_item.def_id,\n+                impl_item.span,\n+                impl_item.vis_span,\n+                false,\n+            );\n+        }\n     }\n }\n "}, {"sha": "e1507d0fbb48ff0525d7f68f08c44008e84dae33", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -406,7 +406,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n                 }\n                 _ => (),\n             },\n-            FnKind::ItemFn(ident, _, header, _) => {\n+            FnKind::ItemFn(ident, _, header) => {\n                 // Skip foreign-ABI #[no_mangle] functions (Issue #31924)\n                 if header.abi != Abi::Rust && cx.sess().contains_name(attrs, sym::no_mangle) {\n                     return;"}, {"sha": "e0ed402283904a1bf99a1a9f0dbf7df8cf73bb6d", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -14,7 +14,6 @@ use rustc_hir::*;\n use rustc_index::vec::Idx;\n use rustc_middle::hir::nested_filter;\n use rustc_span::def_id::StableCrateId;\n-use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n@@ -304,7 +303,6 @@ impl<'hir> Map<'hir> {\n             | Node::Param(_)\n             | Node::Arm(_)\n             | Node::Lifetime(_)\n-            | Node::Visibility(_)\n             | Node::Block(_) => return None,\n         };\n         Some(def_kind)\n@@ -1000,12 +998,7 @@ impl<'hir> Map<'hir> {\n             },\n             Node::Lifetime(lifetime) => lifetime.span,\n             Node::GenericParam(param) => param.span,\n-            Node::Visibility(&Spanned {\n-                node: VisibilityKind::Restricted { ref path, .. },\n-                ..\n-            }) => path.span,\n             Node::Infer(i) => i.span,\n-            Node::Visibility(v) => bug!(\"unexpected Visibility {:?}\", v),\n             Node::Local(local) => local.span,\n             Node::Crate(item) => item.spans.inner_span,\n         };\n@@ -1128,6 +1121,10 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n     }\n     tcx.sess.opts.dep_tracking_hash(true).hash_stable(&mut hcx, &mut stable_hasher);\n     tcx.sess.local_stable_crate_id().hash_stable(&mut hcx, &mut stable_hasher);\n+    // Hash visibility information since it does not appear in HIR.\n+    let resolutions = tcx.resolutions(());\n+    resolutions.visibilities.hash_stable(&mut hcx, &mut stable_hasher);\n+    resolutions.has_pub_restricted.hash_stable(&mut hcx, &mut stable_hasher);\n \n     let crate_hash: Fingerprint = stable_hasher.finish();\n     Svh::new(crate_hash.to_smaller_hash())\n@@ -1232,7 +1229,6 @@ fn hir_id_to_string(map: Map<'_>, id: HirId) -> String {\n         Some(Node::Ctor(..)) => format!(\"ctor {}{}\", path_str(), id_str),\n         Some(Node::Lifetime(_)) => node_str(\"lifetime\"),\n         Some(Node::GenericParam(ref param)) => format!(\"generic_param {:?}{}\", param, id_str),\n-        Some(Node::Visibility(ref vis)) => format!(\"visibility {:?}{}\", vis, id_str),\n         Some(Node::Crate(..)) => String::from(\"root_crate\"),\n         None => format!(\"unknown node{}\", id_str),\n     }"}, {"sha": "ec416722c214e6018bc9f566c7e2aa065292b4c4", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -36,7 +36,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap, CRATE_DEF_ID};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap};\n use rustc_hir::Node;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n@@ -131,6 +131,8 @@ pub struct ResolverOutputs {\n     pub definitions: rustc_hir::definitions::Definitions,\n     pub cstore: Box<CrateStoreDyn>,\n     pub visibilities: FxHashMap<LocalDefId, Visibility>,\n+    /// This field is used to decide whether we should make `PRIVATE_IN_PUBLIC` a hard error.\n+    pub has_pub_restricted: bool,\n     pub access_levels: AccessLevels,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     pub maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n@@ -317,22 +319,6 @@ impl<'tcx> DefIdTree for TyCtxt<'tcx> {\n }\n \n impl Visibility {\n-    pub fn from_hir(visibility: &hir::Visibility<'_>, id: hir::HirId, tcx: TyCtxt<'_>) -> Self {\n-        match visibility.node {\n-            hir::VisibilityKind::Public => Visibility::Public,\n-            hir::VisibilityKind::Crate(_) => Visibility::Restricted(CRATE_DEF_ID.to_def_id()),\n-            hir::VisibilityKind::Restricted { ref path, .. } => match path.res {\n-                // If there is no resolution, `resolve` will have already reported an error, so\n-                // assume that the visibility is public to avoid reporting more privacy errors.\n-                Res::Err => Visibility::Public,\n-                def => Visibility::Restricted(def.def_id()),\n-            },\n-            hir::VisibilityKind::Inherited => {\n-                Visibility::Restricted(tcx.parent_module(id).to_def_id())\n-            }\n-        }\n-    }\n-\n     /// Returns `true` if an item with this visibility is accessible from the given block.\n     pub fn is_accessible_from<T: DefIdTree>(self, module: DefId, tree: T) -> bool {\n         let restriction = match self {"}, {"sha": "b661f6f9d729eaa31020189d6d53e01dfa971924", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 24, "deletions": 35, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -45,8 +45,6 @@ struct MarkSymbolVisitor<'tcx> {\n     live_symbols: FxHashSet<LocalDefId>,\n     repr_has_repr_c: bool,\n     in_pat: bool,\n-    inherited_pub_visibility: bool,\n-    pub_visibility: bool,\n     ignore_variant_stack: Vec<DefId>,\n     // maps from tuple struct constructors to tuple struct items\n     struct_constructors: FxHashMap<LocalDefId, LocalDefId>,\n@@ -284,33 +282,23 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n         }\n \n         let had_repr_c = self.repr_has_repr_c;\n-        let had_inherited_pub_visibility = self.inherited_pub_visibility;\n-        let had_pub_visibility = self.pub_visibility;\n         self.repr_has_repr_c = false;\n-        self.inherited_pub_visibility = false;\n-        self.pub_visibility = false;\n         match node {\n-            Node::Item(item) => {\n-                self.pub_visibility = item.vis.node.is_pub();\n+            Node::Item(item) => match item.kind {\n+                hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n+                    let def = self.tcx.adt_def(item.def_id);\n+                    self.repr_has_repr_c = def.repr().c();\n \n-                match item.kind {\n-                    hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                        let def = self.tcx.adt_def(item.def_id);\n-                        self.repr_has_repr_c = def.repr().c();\n-\n-                        intravisit::walk_item(self, &item);\n-                    }\n-                    hir::ItemKind::Enum(..) => {\n-                        self.inherited_pub_visibility = self.pub_visibility;\n-\n-                        intravisit::walk_item(self, &item);\n-                    }\n-                    hir::ItemKind::ForeignMod { .. } => {}\n-                    _ => {\n-                        intravisit::walk_item(self, &item);\n-                    }\n+                    intravisit::walk_item(self, &item);\n                 }\n-            }\n+                hir::ItemKind::Enum(..) => {\n+                    intravisit::walk_item(self, &item);\n+                }\n+                hir::ItemKind::ForeignMod { .. } => {}\n+                _ => {\n+                    intravisit::walk_item(self, &item);\n+                }\n+            },\n             Node::TraitItem(trait_item) => {\n                 intravisit::walk_trait_item(self, trait_item);\n             }\n@@ -322,8 +310,6 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n             }\n             _ => {}\n         }\n-        self.pub_visibility = had_pub_visibility;\n-        self.inherited_pub_visibility = had_inherited_pub_visibility;\n         self.repr_has_repr_c = had_repr_c;\n     }\n \n@@ -354,14 +340,19 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n         _: hir::HirId,\n         _: rustc_span::Span,\n     ) {\n+        let tcx = self.tcx;\n         let has_repr_c = self.repr_has_repr_c;\n-        let inherited_pub_visibility = self.inherited_pub_visibility;\n-        let pub_visibility = self.pub_visibility;\n-        let live_fields = def.fields().iter().filter(|f| {\n-            has_repr_c || (pub_visibility && (inherited_pub_visibility || f.vis.node.is_pub()))\n+        let live_fields = def.fields().iter().filter_map(|f| {\n+            let def_id = tcx.hir().local_def_id(f.hir_id);\n+            if has_repr_c {\n+                return Some(def_id);\n+            }\n+            if !tcx.visibility(f.hir_id.owner).is_public() {\n+                return None;\n+            }\n+            if tcx.visibility(def_id).is_public() { Some(def_id) } else { None }\n         });\n-        let hir = self.tcx.hir();\n-        self.live_symbols.extend(live_fields.map(|f| hir.local_def_id(f.hir_id)));\n+        self.live_symbols.extend(live_fields);\n \n         intravisit::walk_struct_def(self, def);\n     }\n@@ -602,8 +593,6 @@ fn live_symbols_and_ignored_derived_traits<'tcx>(\n         live_symbols: Default::default(),\n         repr_has_repr_c: false,\n         in_pat: false,\n-        inherited_pub_visibility: false,\n-        pub_visibility: false,\n         ignore_variant_stack: vec![],\n         struct_constructors,\n         ignored_derived_traits: FxHashMap::default(),"}, {"sha": "5f9a03575575c6ad9767be7764e4ce6d82899083", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 20, "deletions": 49, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -295,28 +295,6 @@ fn min(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'_>) -> ty::Visib\n     if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-/// Visitor used to determine if pub(restricted) is used anywhere in the crate.\n-///\n-/// This is done so that `private_in_public` warnings can be turned into hard errors\n-/// in crates that have been updated to use pub(restricted).\n-////////////////////////////////////////////////////////////////////////////////\n-struct PubRestrictedVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    has_pub_restricted: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for PubRestrictedVisitor<'tcx> {\n-    type NestedFilter = nested_filter::All;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.tcx.hir()\n-    }\n-    fn visit_vis(&mut self, vis: &'tcx hir::Visibility<'tcx>) {\n-        self.has_pub_restricted = self.has_pub_restricted || vis.node.is_pub_restricted();\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n /// Visitor used to determine impl visibility and reachability.\n ////////////////////////////////////////////////////////////////////////////////\n@@ -682,7 +660,9 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     self.update_with_hir_id(ctor_hir_id, item_level);\n                 }\n                 for field in def.fields() {\n-                    if field.vis.node.is_pub() {\n+                    let def_id = self.tcx.hir().local_def_id(field.hir_id);\n+                    let vis = self.tcx.visibility(def_id);\n+                    if vis.is_public() {\n                         self.update_with_hir_id(field.hir_id, item_level);\n                     }\n                 }\n@@ -1361,7 +1341,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // .. and it corresponds to a private type in the AST (this returns\n             // `None` for type parameters).\n             match self.tcx.hir().find(self.tcx.hir().local_def_id_to_hir_id(did)) {\n-                Some(Node::Item(item)) => !item.vis.node.is_pub(),\n+                Some(Node::Item(_)) => !self.tcx.visibility(did).is_public(),\n                 Some(_) | None => false,\n             }\n         } else {\n@@ -1383,8 +1363,8 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn item_is_public(&self, def_id: LocalDefId, vis: &hir::Visibility<'_>) -> bool {\n-        self.access_levels.is_reachable(def_id) || vis.node.is_pub()\n+    fn item_is_public(&self, def_id: LocalDefId) -> bool {\n+        self.access_levels.is_reachable(def_id) || self.tcx.visibility(def_id).is_public()\n     }\n }\n \n@@ -1519,8 +1499,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                                 match impl_item.kind {\n                                     hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..)\n-                                        if self\n-                                            .item_is_public(impl_item.def_id, &impl_item.vis) =>\n+                                        if self.item_is_public(impl_item.def_id) =>\n                                     {\n                                         intravisit::walk_impl_item(self, impl_item)\n                                     }\n@@ -1591,7 +1570,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::TyAlias(..) => return,\n \n             // Not at all public, so we don't care.\n-            _ if !self.item_is_public(item.def_id, &item.vis) => {\n+            _ if !self.item_is_public(item.def_id) => {\n                 return;\n             }\n \n@@ -1655,7 +1634,9 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_field_def(&mut self, s: &'tcx hir::FieldDef<'tcx>) {\n-        if s.vis.node.is_pub() || self.in_variant {\n+        let def_id = self.tcx.hir().local_def_id(s.hir_id);\n+        let vis = self.tcx.visibility(def_id);\n+        if vis.is_public() || self.in_variant {\n             intravisit::walk_field_def(self, s);\n         }\n     }\n@@ -1680,7 +1661,6 @@ struct SearchInterfaceForPrivateItemsVisitor<'tcx> {\n     item_def_id: LocalDefId,\n     /// The visitor checks that each component type is at least this visible.\n     required_visibility: ty::Visibility,\n-    has_pub_restricted: bool,\n     has_old_errors: bool,\n     in_assoc_ty: bool,\n }\n@@ -1769,7 +1749,10 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n             };\n             let make_msg = || format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr);\n             let span = self.tcx.def_span(self.item_def_id.to_def_id());\n-            if self.has_pub_restricted || self.has_old_errors || self.in_assoc_ty {\n+            if self.has_old_errors\n+                || self.in_assoc_ty\n+                || self.tcx.resolutions(()).has_pub_restricted\n+            {\n                 let mut err = if kind == \"trait\" {\n                     struct_span_err!(self.tcx.sess, span, E0445, \"{}\", make_msg())\n                 } else {\n@@ -1828,7 +1811,6 @@ impl<'tcx> DefIdVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'tcx> {\n \n struct PrivateItemsInPublicInterfacesVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    has_pub_restricted: bool,\n     old_error_set_ancestry: LocalDefIdSet,\n }\n \n@@ -1842,7 +1824,6 @@ impl<'tcx> PrivateItemsInPublicInterfacesVisitor<'tcx> {\n             tcx: self.tcx,\n             item_def_id: def_id,\n             required_visibility,\n-            has_pub_restricted: self.has_pub_restricted,\n             has_old_errors: self.old_error_set_ancestry.contains(&def_id),\n             in_assoc_ty: false,\n         }\n@@ -1994,19 +1975,16 @@ fn visibility(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Visibility {\n             match tcx.hir().get(hir_id) {\n                 // Unique types created for closures participate in type privacy checking.\n                 // They have visibilities inherited from the module they are defined in.\n-                Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(..), .. }) => {\n-                    ty::Visibility::Restricted(tcx.parent_module(hir_id).to_def_id())\n-                }\n-                // - AST lowering may clone `use` items and the clones don't\n+                Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(..), .. })\n+                // - AST lowering creates dummy `use` items which don't\n                 //   get their entries in the resolver's visibility table.\n                 // - AST lowering also creates opaque type items with inherited visibilities.\n                 //   Visibility on them should have no effect, but to avoid the visibility\n                 //   query failing on some items, we provide it for opaque types as well.\n-                Node::Item(hir::Item {\n-                    vis,\n-                    kind: hir::ItemKind::Use(..) | hir::ItemKind::OpaqueTy(..),\n+                | Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Use(_, hir::UseKind::ListStem) | hir::ItemKind::OpaqueTy(..),\n                     ..\n-                }) => ty::Visibility::from_hir(vis, hir_id, tcx),\n+                }) => ty::Visibility::Restricted(tcx.parent_module(hir_id).to_def_id()),\n                 // Visibilities of trait impl items are inherited from their traits\n                 // and are not filled in resolve.\n                 Node::ImplItem(impl_item) => {\n@@ -2083,12 +2061,6 @@ fn check_private_in_public(tcx: TyCtxt<'_>, (): ()) {\n     };\n     tcx.hir().walk_toplevel_module(&mut visitor);\n \n-    let has_pub_restricted = {\n-        let mut pub_restricted_visitor = PubRestrictedVisitor { tcx, has_pub_restricted: false };\n-        tcx.hir().walk_toplevel_module(&mut pub_restricted_visitor);\n-        pub_restricted_visitor.has_pub_restricted\n-    };\n-\n     let mut old_error_set_ancestry = HirIdSet::default();\n     for mut id in visitor.old_error_set.iter().copied() {\n         loop {\n@@ -2106,7 +2078,6 @@ fn check_private_in_public(tcx: TyCtxt<'_>, (): ()) {\n     // Check for private types and traits in public interfaces.\n     let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n         tcx,\n-        has_pub_restricted,\n         // Only definition IDs are ever searched in `old_error_set_ancestry`,\n         // so we can filter away all non-definition IDs at this point.\n         old_error_set_ancestry: old_error_set_ancestry"}, {"sha": "291b6645d9aa6d00a185cf9364e83f2908a46e22", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -265,6 +265,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 })\n             }\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n+                // Make `PRIVATE_IN_PUBLIC` lint a hard error.\n+                self.r.has_pub_restricted = true;\n                 // For visibilities we are not ready to provide correct implementation of \"uniform\n                 // paths\" right now, so on 2018 edition we only allow module-relative paths for now.\n                 // On 2015 edition visibilities are resolved as crate-relative by default,\n@@ -458,6 +460,14 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let mut source = module_path.pop().unwrap();\n                 let mut type_ns_only = false;\n \n+                self.r.visibilities.insert(self.r.local_def_id(id), vis);\n+                if id1 != ast::DUMMY_NODE_ID {\n+                    self.r.visibilities.insert(self.r.local_def_id(id1), vis);\n+                }\n+                if id2 != ast::DUMMY_NODE_ID {\n+                    self.r.visibilities.insert(self.r.local_def_id(id2), vis);\n+                }\n+\n                 if nested {\n                     // Correctly handle `self`\n                     if source.ident.name == kw::SelfLower {\n@@ -580,6 +590,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     is_prelude: self.r.session.contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(ty::Visibility::Invisible),\n                 };\n+                self.r.visibilities.insert(self.r.local_def_id(id), vis);\n                 self.add_import(prefix, kind, use_tree.span, id, item, root_span, item.id, vis);\n             }\n             ast::UseTreeKind::Nested(ref items) => {"}, {"sha": "ce3069265d0206381b1c29dda43f0258a8af8428", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -685,8 +685,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         hir_id: hir::HirId,\n     ) {\n         let name = match fk {\n-            intravisit::FnKind::ItemFn(id, _, _, _) => id.name,\n-            intravisit::FnKind::Method(id, _, _) => id.name,\n+            intravisit::FnKind::ItemFn(id, _, _) => id.name,\n+            intravisit::FnKind::Method(id, _) => id.name,\n             intravisit::FnKind::Closure => sym::closure,\n         };\n         let name = name.as_str();"}, {"sha": "cca1f1025866863465fae0b73fd465019ac6bfef", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -934,6 +934,7 @@ pub struct Resolver<'a> {\n     glob_map: FxHashMap<LocalDefId, FxHashSet<Symbol>>,\n     /// Visibilities in \"lowered\" form, for all entities that have them.\n     visibilities: FxHashMap<LocalDefId, ty::Visibility>,\n+    has_pub_restricted: bool,\n     used_imports: FxHashSet<NodeId>,\n     maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n     maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n@@ -1313,6 +1314,7 @@ impl<'a> Resolver<'a> {\n \n             glob_map: Default::default(),\n             visibilities,\n+            has_pub_restricted: false,\n             used_imports: FxHashSet::default(),\n             maybe_unused_trait_imports: Default::default(),\n             maybe_unused_extern_crates: Vec::new(),\n@@ -1423,6 +1425,7 @@ impl<'a> Resolver<'a> {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n         let definitions = self.definitions;\n         let visibilities = self.visibilities;\n+        let has_pub_restricted = self.has_pub_restricted;\n         let extern_crate_map = self.extern_crate_map;\n         let reexport_map = self.reexport_map;\n         let maybe_unused_trait_imports = self.maybe_unused_trait_imports;\n@@ -1435,6 +1438,7 @@ impl<'a> Resolver<'a> {\n             definitions,\n             cstore: Box::new(self.crate_loader.into_cstore()),\n             visibilities,\n+            has_pub_restricted,\n             access_levels,\n             extern_crate_map,\n             reexport_map,\n@@ -1461,6 +1465,7 @@ impl<'a> Resolver<'a> {\n             access_levels: self.access_levels.clone(),\n             cstore: Box::new(self.cstore().clone()),\n             visibilities: self.visibilities.clone(),\n+            has_pub_restricted: self.has_pub_restricted,\n             extern_crate_map: self.extern_crate_map.clone(),\n             reexport_map: self.reexport_map.clone(),\n             glob_map: self.glob_map.clone(),"}, {"sha": "6681ea9d299cf057c69b0090b03de10541a45f4a", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -25,7 +25,6 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::span_bug;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::config::Input;\n-use rustc_span::source_map::respan;\n use rustc_span::symbol::Ident;\n use rustc_span::*;\n \n@@ -57,20 +56,14 @@ macro_rules! down_cast_data {\n }\n \n macro_rules! access_from {\n-    ($save_ctxt:expr, $item:expr, $id:expr) => {\n+    ($save_ctxt:expr, $id:expr) => {\n         Access {\n-            public: $item.vis.node.is_pub(),\n+            public: $save_ctxt.tcx.visibility($id).is_public(),\n             reachable: $save_ctxt.access_levels.is_reachable($id),\n         }\n     };\n }\n \n-macro_rules! access_from_vis {\n-    ($save_ctxt:expr, $vis:expr, $id:expr) => {\n-        Access { public: $vis.node.is_pub(), reachable: $save_ctxt.access_levels.is_reachable($id) }\n-    };\n-}\n-\n pub struct DumpVisitor<'tcx> {\n     pub save_ctxt: SaveContext<'tcx>,\n     tcx: TyCtxt<'tcx>,\n@@ -257,7 +250,6 @@ impl<'tcx> DumpVisitor<'tcx> {\n         def_id: LocalDefId,\n         ident: Ident,\n         generics: &'tcx hir::Generics<'tcx>,\n-        vis: &hir::Visibility<'tcx>,\n         span: Span,\n     ) {\n         debug!(\"process_method: {:?}:{}\", def_id, ident);\n@@ -272,10 +264,10 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 v.process_generic_params(&generics, &method_data.qualname, hir_id);\n \n                 method_data.value =\n-                    fn_to_string(sig.decl, sig.header, Some(ident.name), generics, vis, &[], None);\n+                    fn_to_string(sig.decl, sig.header, Some(ident.name), generics, &[], None);\n                 method_data.sig = sig::method_signature(hir_id, ident, generics, sig, &v.save_ctxt);\n \n-                v.dumper.dump_def(&access_from_vis!(v.save_ctxt, vis, def_id), method_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, def_id), method_data);\n             }\n \n             // walk arg and return types\n@@ -302,7 +294,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, field, self.tcx.hir().local_def_id(field.hir_id)),\n+                &access_from!(self.save_ctxt, self.tcx.hir().local_def_id(field.hir_id)),\n                 field_data,\n             );\n         }\n@@ -369,7 +361,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 v.process_formals(body.params, &fn_data.qualname);\n                 v.process_generic_params(ty_params, &fn_data.qualname, item.hir_id());\n \n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.def_id), fn_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item.def_id), fn_data);\n             }\n \n             for arg in decl.inputs {\n@@ -393,7 +385,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         self.nest_typeck_results(item.def_id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.def_id), var_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item.def_id), var_data);\n             }\n             v.visit_ty(&typ);\n             v.visit_expr(expr);\n@@ -407,7 +399,6 @@ impl<'tcx> DumpVisitor<'tcx> {\n         typ: &'tcx hir::Ty<'tcx>,\n         expr: Option<&'tcx hir::Expr<'tcx>>,\n         parent_id: DefId,\n-        vis: &hir::Visibility<'tcx>,\n         attrs: &'tcx [ast::Attribute],\n     ) {\n         let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id.to_def_id()));\n@@ -418,7 +409,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             let span = self.span_from_span(ident.span);\n \n             self.dumper.dump_def(\n-                &access_from_vis!(self.save_ctxt, vis, def_id),\n+                &access_from!(self.save_ctxt, def_id),\n                 Def {\n                     kind: DefKind::Const,\n                     id: id_from_hir_id(hir_id, &self.save_ctxt),\n@@ -469,7 +460,11 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 let fields_str = fields\n                     .iter()\n                     .filter_map(|f| {\n-                        if include_priv_fields || f.vis.node.is_pub() {\n+                        if include_priv_fields {\n+                            return Some(f.ident.to_string());\n+                        }\n+                        let def_id = self.save_ctxt.tcx.hir().local_def_id(f.hir_id);\n+                        if self.save_ctxt.tcx.visibility(def_id).is_public() {\n                             Some(f.ident.to_string())\n                         } else {\n                             None\n@@ -487,7 +482,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             let span = self.span_from_span(item.ident.span);\n             let attrs = self.tcx.hir().attrs(item.hir_id());\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item, item.def_id),\n+                &access_from!(self.save_ctxt, item.def_id),\n                 Def {\n                     kind,\n                     id: id_from_def_id(item.def_id.to_def_id()),\n@@ -527,7 +522,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n-        let access = access_from!(self.save_ctxt, item, item.def_id);\n+        let access = access_from!(self.save_ctxt, item.def_id);\n \n         for variant in enum_definition.variants {\n             let name = variant.ident.name.to_string();\n@@ -662,7 +657,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 methods.iter().map(|i| id_from_def_id(i.id.def_id.to_def_id())).collect();\n             let attrs = self.tcx.hir().attrs(item.hir_id());\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item, item.def_id),\n+                &access_from!(self.save_ctxt, item.def_id),\n                 Def {\n                     kind: DefKind::Trait,\n                     id,\n@@ -724,7 +719,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n     fn process_mod(&mut self, item: &'tcx hir::Item<'tcx>) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item, item.def_id), mod_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item.def_id), mod_data);\n         }\n     }\n \n@@ -979,33 +974,28 @@ impl<'tcx> DumpVisitor<'tcx> {\n \n     fn process_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>, trait_id: DefId) {\n         self.process_macro_use(trait_item.span);\n-        let vis_span = trait_item.span.shrink_to_lo();\n         match trait_item.kind {\n             hir::TraitItemKind::Const(ref ty, body) => {\n                 let body = body.map(|b| &self.tcx.hir().body(b).value);\n-                let respan = respan(vis_span, hir::VisibilityKind::Public);\n                 let attrs = self.tcx.hir().attrs(trait_item.hir_id());\n                 self.process_assoc_const(\n                     trait_item.def_id,\n                     trait_item.ident,\n                     &ty,\n                     body,\n                     trait_id,\n-                    &respan,\n                     attrs,\n                 );\n             }\n             hir::TraitItemKind::Fn(ref sig, ref trait_fn) => {\n                 let body =\n                     if let hir::TraitFn::Provided(body) = trait_fn { Some(*body) } else { None };\n-                let respan = respan(vis_span, hir::VisibilityKind::Public);\n                 self.process_method(\n                     sig,\n                     body,\n                     trait_item.def_id,\n                     trait_item.ident,\n                     &trait_item.generics,\n-                    &respan,\n                     trait_item.span,\n                 );\n             }\n@@ -1064,7 +1054,6 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     &ty,\n                     Some(&body.value),\n                     impl_id,\n-                    &impl_item.vis,\n                     attrs,\n                 );\n             }\n@@ -1075,7 +1064,6 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     impl_item.def_id,\n                     impl_item.ident,\n                     &impl_item.generics,\n-                    &impl_item.vis,\n                     impl_item.span,\n                 );\n             }\n@@ -1147,7 +1135,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             hir::ItemKind::Use(path, hir::UseKind::Single) => {\n                 let sub_span = path.segments.last().unwrap().ident.span;\n                 if !self.span.filter_generated(sub_span) {\n-                    let access = access_from!(self.save_ctxt, item, item.def_id);\n+                    let access = access_from!(self.save_ctxt, item.def_id);\n                     let ref_id = self.lookup_def_id(item.hir_id()).map(id_from_def_id);\n                     let span = self.span_from_span(sub_span);\n                     let parent =\n@@ -1176,7 +1164,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 // we don't want to track anyway, since it's probably macro-internal `use`\n                 if let Some(sub_span) = self.span.sub_span_of_star(item.span) {\n                     if !self.span.filter_generated(item.span) {\n-                        let access = access_from!(self.save_ctxt, item, item.def_id);\n+                        let access = access_from!(self.save_ctxt, item.def_id);\n                         let span = self.span_from_span(sub_span);\n                         let parent =\n                             self.save_ctxt.tcx.parent(item.def_id.to_def_id()).map(id_from_def_id);\n@@ -1249,7 +1237,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                     let attrs = self.tcx.hir().attrs(item.hir_id());\n \n                     self.dumper.dump_def(\n-                        &access_from!(self.save_ctxt, item, item.def_id),\n+                        &access_from!(self.save_ctxt, item.def_id),\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1443,7 +1431,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        let access = access_from!(self.save_ctxt, item, item.def_id);\n+        let access = access_from!(self.save_ctxt, item.def_id);\n \n         match item.kind {\n             hir::ForeignItemKind::Fn(decl, _, ref generics) => {"}, {"sha": "582186cbd1fe7221c30c5655bc4c9b7fe97b1421", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -27,7 +27,6 @@ use rustc_middle::{bug, span_bug};\n use rustc_session::config::{CrateType, Input, OutputType};\n use rustc_session::cstore::ExternCrate;\n use rustc_session::output::{filename_for_metadata, out_filename};\n-use rustc_span::source_map::Spanned;\n use rustc_span::symbol::Ident;\n use rustc_span::*;\n \n@@ -165,7 +164,6 @@ impl<'tcx> SaveContext<'tcx> {\n                         },\n                         Some(item.ident.name),\n                         generics,\n-                        &item.vis,\n                         arg_names,\n                         None,\n                     ),\n@@ -221,7 +219,6 @@ impl<'tcx> SaveContext<'tcx> {\n                         sig.header,\n                         Some(item.ident.name),\n                         generics,\n-                        &item.vis,\n                         &[],\n                         None,\n                     ),\n@@ -310,7 +307,7 @@ impl<'tcx> SaveContext<'tcx> {\n                 let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n                 filter!(self.span_utils, item.ident.span);\n                 let value =\n-                    enum_def_to_string(def, generics, item.ident.name, item.span, &item.vis);\n+                    enum_def_to_string(def, generics, item.ident.name, item.span);\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Enum,\n                     id: id_from_def_id(def_id),\n@@ -595,11 +592,6 @@ impl<'tcx> SaveContext<'tcx> {\n             Node::TraitRef(tr) => tr.path.res,\n \n             Node::Item(&hir::Item { kind: hir::ItemKind::Use(path, _), .. }) => path.res,\n-            Node::Visibility(&Spanned {\n-                node: hir::VisibilityKind::Restricted { ref path, .. },\n-                ..\n-            }) => path.res,\n-\n             Node::PathSegment(seg) => match seg.res {\n                 Some(res) if res != Res::Err => res,\n                 _ => {"}, {"sha": "721f251650f54656a68497be907d8abfa01561b0", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -257,7 +257,6 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n                 | hir::Node::Ctor(..)\n                 | hir::Node::Lifetime(..)\n                 | hir::Node::GenericParam(..)\n-                | hir::Node::Visibility(..)\n                 | hir::Node::Crate(..)\n                 | hir::Node::Infer(..) => bug!(\"Unsupported branch target: {:?}\", node),\n             }"}, {"sha": "d52886a09bd958d5485dd8764ca75b0e9cd17f84", "filename": "compiler/rustc_typeck/src/check_unused.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -18,8 +18,11 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n \n     for id in tcx.hir().items() {\n         if matches!(tcx.hir().def_kind(id.def_id), DefKind::Use) {\n+            if tcx.visibility(id.def_id).is_public() {\n+                continue;\n+            }\n             let item = tcx.hir().item(id);\n-            if item.vis.node.is_pub() || item.span.is_dummy() {\n+            if item.span.is_dummy() {\n                 continue;\n             }\n             if let hir::ItemKind::Use(path, _) = item.kind {\n@@ -176,7 +179,7 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n                 Some(orig_name) => format!(\"use {} as {};\", orig_name, item.ident.name),\n                 None => format!(\"use {};\", item.ident.name),\n             };\n-            let vis = tcx.sess.source_map().span_to_snippet(item.vis.span).unwrap_or_default();\n+            let vis = tcx.sess.source_map().span_to_snippet(item.vis_span).unwrap_or_default();\n             let add_vis = |to| if vis.is_empty() { to } else { format!(\"{} {}\", vis, to) };\n             lint.build(\"`extern crate` is not idiomatic in the new edition\")\n                 .span_suggestion_short("}, {"sha": "6582cdc4a2c85e4ba16c11e3329022092a9af43a", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -29,16 +29,14 @@\n \n // Change enum visibility -----------------------------------------------------\n #[cfg(any(cfail1,cfail4))]\n-enum EnumVisibility { A }\n+enum     EnumVisibility { A }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes\")]\n #[rustc_clean(cfg=\"cfail6\")]\n-pub enum EnumVisibility {\n-    A\n-}\n+pub enum EnumVisibility { A }\n \n \n "}, {"sha": "5463b0dc87e4020ba43ee5c236d781b5e8af157d", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -116,7 +116,7 @@ impl Foo {\n // Change Method Privacy -------------------------------------------------------\n #[cfg(any(cfail1,cfail4))]\n impl Foo {\n-    //------------------------------------------------------------------------------\n+    //----------------------------------------------------\n     //--------------------------\n     //------------------------------------------------------------------------------\n     //--------------------------\n@@ -129,9 +129,9 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail5\")]\n #[rustc_clean(cfg=\"cfail6\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"associated_item,hir_owner,hir_owner_nodes\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"associated_item\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n-    #[rustc_clean(cfg=\"cfail5\", except=\"associated_item,hir_owner,hir_owner_nodes\")]\n+    #[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,associated_item\")]\n     #[rustc_clean(cfg=\"cfail6\")]\n     fn     method_privacy() { }\n }"}, {"sha": "697be056761530e4312b751604fb17ee09d51c25", "filename": "src/test/incremental/hashes/statics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -24,10 +24,10 @@\n \n // Change static visibility\n #[cfg(any(cfail1,cfail4))]\n-static STATIC_VISIBILITY: u8 = 0;\n+static     STATIC_VISIBILITY: u8 = 0;\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes\")]\n #[rustc_clean(cfg=\"cfail6\")]"}, {"sha": "b4d558d259fe696b734fa402af305ede5fdb45e9", "filename": "src/test/incremental/hashes/struct_defs.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -84,12 +84,12 @@ struct TupleStructAddField(\n // Tuple Struct Field Visibility -----------------------------------------------\n \n #[cfg(any(cfail1,cfail4))]\n-struct TupleStructFieldVisibility(char);\n+struct TupleStructFieldVisibility(    char);\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,type_of\", cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"type_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,type_of\", cfg=\"cfail5\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,type_of\")]\n #[rustc_clean(cfg=\"cfail6\")]\n struct TupleStructFieldVisibility(pub char);\n \n@@ -142,16 +142,14 @@ struct RecordStructAddField {\n // Record Struct Field Visibility ----------------------------------------------\n \n #[cfg(any(cfail1,cfail4))]\n-struct RecordStructFieldVisibility { x: f32 }\n+struct RecordStructFieldVisibility {     x: f32 }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,type_of\", cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"type_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,type_of\", cfg=\"cfail5\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,type_of\")]\n #[rustc_clean(cfg=\"cfail6\")]\n-struct RecordStructFieldVisibility {\n-    pub x: f32\n-}\n+struct RecordStructFieldVisibility { pub x: f32 }\n \n \n // Add Lifetime Parameter ------------------------------------------------------\n@@ -257,12 +255,12 @@ pub struct EmptyStruct;\n // Visibility ------------------------------------------------------------------\n \n #[cfg(any(cfail1,cfail4))]\n-struct Visibility;\n+struct     Visibility;\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes\", cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes\", cfg=\"cfail5\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub struct Visibility;\n "}, {"sha": "717e9e8c8e1112bea8ad0679fc0d4c73e4b98c25", "filename": "src/test/incremental/hashes/trait_defs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -31,9 +31,9 @@\n trait TraitVisibility { }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes\", cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes\", cfg=\"cfail5\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub trait TraitVisibility { }\n "}, {"sha": "a59a3002c7f68508c28bdfda5ff2e2ffc5e1b7f8", "filename": "src/test/pretty/hir-pretty-loop.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fpretty%2Fhir-pretty-loop.pp", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fpretty%2Fhir-pretty-loop.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fhir-pretty-loop.pp?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -6,4 +6,4 @@\n // pretty-mode:hir\n // pp-exact:hir-pretty-loop.pp\n \n-pub fn foo() { loop { break; } }\n+fn foo() { loop { break; } }"}, {"sha": "752c36a0fbc5a58759f1fa0d0e564990c783f301", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -8,9 +8,9 @@\n \n // #4264 fixed-length vector types\n \n-pub fn foo(_: [i32; (3 as usize)]) ({ } as ())\n+fn foo(_: [i32; (3 as usize)]) ({ } as ())\n \n-pub fn bar() ({\n+fn bar() ({\n         const FOO: usize = ((5 as usize) - (4 as usize) as usize);\n         let _: [(); (FOO as usize)] = ([(() as ())] as [(); 1]);\n \n@@ -41,14 +41,14 @@\n                 (res as String)\n             } as String);\n     } as ())\n-pub type Foo = [i32; (3 as usize)];\n-pub struct Bar {\n-    pub x: [i32; (3 as usize)],\n+type Foo = [i32; (3 as usize)];\n+struct Bar {\n+    x: [i32; (3 as usize)],\n }\n-pub struct TupleBar([i32; (4 as usize)]);\n-pub enum Baz { BazVariant([i32; (5 as usize)]), }\n-pub fn id<T>(x: T) -> T ({ (x as T) } as T)\n-pub fn use_id() ({\n+struct TupleBar([i32; (4 as usize)]);\n+enum Baz { BazVariant([i32; (5 as usize)]), }\n+fn id<T>(x: T) -> T ({ (x as T) } as T)\n+fn use_id() ({\n         let _ =\n             ((id::<[i32; (3 as usize)]> as\n                     fn([i32; 3]) -> [i32; 3] {id::<[i32; 3]>})(([(1 as i32),"}, {"sha": "4dc951985ae4d14a398d223b9ade6a4eb71f9bfb", "filename": "src/test/ui/lint/unreachable_pub-pub_crate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -26,6 +26,11 @@ mod private_mod {\n         pub fn count_neutrons(&self) -> usize { self.neutrons } //~ WARNING unreachable_pub\n         pub(crate) fn count_electrons(&self) -> usize { self.electrons }\n     }\n+    impl Clone for Hydrogen {\n+        fn clone(&self) -> Hydrogen {\n+            Hydrogen { neutrons: self.neutrons, electrons: self.electrons }\n+        }\n+    }\n \n     pub enum Helium {} //~ WARNING unreachable_pub\n     pub union Lithium { c1: usize, c2: u8 } //~ WARNING unreachable_pub"}, {"sha": "6c05a030138bc04bdd72ba4b85eccc720a7d3e1f", "filename": "src/test/ui/lint/unreachable_pub-pub_crate.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.stderr?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -50,7 +50,7 @@ LL |         pub fn count_neutrons(&self) -> usize { self.neutrons }\n    |         help: consider restricting its visibility: `pub(crate)`\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:30:5\n+  --> $DIR/unreachable_pub-pub_crate.rs:35:5\n    |\n LL |     pub enum Helium {}\n    |     ---^^^^^^^^^^^^\n@@ -60,7 +60,7 @@ LL |     pub enum Helium {}\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:31:5\n+  --> $DIR/unreachable_pub-pub_crate.rs:36:5\n    |\n LL |     pub union Lithium { c1: usize, c2: u8 }\n    |     ---^^^^^^^^^^^^^^\n@@ -70,7 +70,7 @@ LL |     pub union Lithium { c1: usize, c2: u8 }\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:32:5\n+  --> $DIR/unreachable_pub-pub_crate.rs:37:5\n    |\n LL |     pub fn beryllium() {}\n    |     ---^^^^^^^^^^^^^^^\n@@ -80,7 +80,7 @@ LL |     pub fn beryllium() {}\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:33:5\n+  --> $DIR/unreachable_pub-pub_crate.rs:38:5\n    |\n LL |     pub trait Boron {}\n    |     ---^^^^^^^^^^^^\n@@ -90,7 +90,7 @@ LL |     pub trait Boron {}\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:34:5\n+  --> $DIR/unreachable_pub-pub_crate.rs:39:5\n    |\n LL |     pub const CARBON: usize = 1;\n    |     ---^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -100,7 +100,7 @@ LL |     pub const CARBON: usize = 1;\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:35:5\n+  --> $DIR/unreachable_pub-pub_crate.rs:40:5\n    |\n LL |     pub static NITROGEN: usize = 2;\n    |     ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -110,7 +110,7 @@ LL |     pub static NITROGEN: usize = 2;\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:36:5\n+  --> $DIR/unreachable_pub-pub_crate.rs:41:5\n    |\n LL |     pub type Oxygen = bool;\n    |     ---^^^^^^^^^^^^^^^^^^^^\n@@ -120,7 +120,7 @@ LL |     pub type Oxygen = bool;\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:39:47\n+  --> $DIR/unreachable_pub-pub_crate.rs:44:47\n    |\n LL |         ($visibility: vis, $name: ident) => { $visibility struct $name {} }\n    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -135,7 +135,7 @@ LL |     define_empty_struct_with_visibility!(pub, Fluorine);\n    = note: this warning originates in the macro `define_empty_struct_with_visibility` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:45:9\n+  --> $DIR/unreachable_pub-pub_crate.rs:50:9\n    |\n LL |         pub fn catalyze() -> bool;\n    |         ---^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "39e2b5961563087de4d246cdcf8234d19609002d", "filename": "src/test/ui/lint/unreachable_pub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fui%2Flint%2Funreachable_pub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fui%2Flint%2Funreachable_pub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -22,6 +22,11 @@ mod private_mod {\n         pub fn count_neutrons(&self) -> usize { self.neutrons } //~ WARNING unreachable_pub\n         crate fn count_electrons(&self) -> usize { self.electrons }\n     }\n+    impl Clone for Hydrogen {\n+        fn clone(&self) -> Hydrogen {\n+            Hydrogen { neutrons: self.neutrons, electrons: self.electrons }\n+        }\n+    }\n \n     pub enum Helium {} //~ WARNING unreachable_pub\n     pub union Lithium { c1: usize, c2: u8 } //~ WARNING unreachable_pub"}, {"sha": "e8e55be5a478007c9f5b22373203f9820daa20cc", "filename": "src/test/ui/lint/unreachable_pub.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -50,7 +50,7 @@ LL |         pub fn count_neutrons(&self) -> usize { self.neutrons }\n    |         help: consider restricting its visibility: `crate`\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:26:5\n+  --> $DIR/unreachable_pub.rs:31:5\n    |\n LL |     pub enum Helium {}\n    |     ---^^^^^^^^^^^^\n@@ -60,7 +60,7 @@ LL |     pub enum Helium {}\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:27:5\n+  --> $DIR/unreachable_pub.rs:32:5\n    |\n LL |     pub union Lithium { c1: usize, c2: u8 }\n    |     ---^^^^^^^^^^^^^^\n@@ -70,7 +70,7 @@ LL |     pub union Lithium { c1: usize, c2: u8 }\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:28:5\n+  --> $DIR/unreachable_pub.rs:33:5\n    |\n LL |     pub fn beryllium() {}\n    |     ---^^^^^^^^^^^^^^^\n@@ -80,7 +80,7 @@ LL |     pub fn beryllium() {}\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:29:5\n+  --> $DIR/unreachable_pub.rs:34:5\n    |\n LL |     pub trait Boron {}\n    |     ---^^^^^^^^^^^^\n@@ -90,7 +90,7 @@ LL |     pub trait Boron {}\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:30:5\n+  --> $DIR/unreachable_pub.rs:35:5\n    |\n LL |     pub const CARBON: usize = 1;\n    |     ---^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -100,7 +100,7 @@ LL |     pub const CARBON: usize = 1;\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:31:5\n+  --> $DIR/unreachable_pub.rs:36:5\n    |\n LL |     pub static NITROGEN: usize = 2;\n    |     ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -110,7 +110,7 @@ LL |     pub static NITROGEN: usize = 2;\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:32:5\n+  --> $DIR/unreachable_pub.rs:37:5\n    |\n LL |     pub type Oxygen = bool;\n    |     ---^^^^^^^^^^^^^^^^^^^^\n@@ -120,7 +120,7 @@ LL |     pub type Oxygen = bool;\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:35:47\n+  --> $DIR/unreachable_pub.rs:40:47\n    |\n LL |         ($visibility: vis, $name: ident) => { $visibility struct $name {} }\n    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -135,7 +135,7 @@ LL |     define_empty_struct_with_visibility!(pub, Fluorine);\n    = note: this warning originates in the macro `define_empty_struct_with_visibility` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:41:9\n+  --> $DIR/unreachable_pub.rs:46:9\n    |\n LL |         pub fn catalyze() -> bool;\n    |         ---^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "ffe730743241d2824c94b848c839f812b3db11e5", "filename": "src/test/ui/match/issue-82392.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fui%2Fmatch%2Fissue-82392.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fui%2Fmatch%2Fissue-82392.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fissue-82392.stdout?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -6,7 +6,7 @@ extern crate std;\n // compile-flags: -Zunpretty=hir,typed\n // check-pass\n \n-pub fn main() ({\n+fn main() ({\n         (if (true as bool)\n                 ({ } as\n                     ()) else if (let Some(a) ="}, {"sha": "5b3d7375de0e3ef1b21a700b7d8ea81b778a1134", "filename": "src/test/ui/type-alias-impl-trait/issue-60662.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60662.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60662.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60662.stdout?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -10,5 +10,5 @@ extern crate std;\n trait Animal { }\n \n fn main() {\n-        pub type ServeFut = /*impl Trait*/;\n+        type ServeFut = /*impl Trait*/;\n     }"}, {"sha": "2bf7f868905458be690ecf5d3d39e80fcd404470", "filename": "src/tools/clippy/clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -82,7 +82,7 @@ impl CognitiveComplexity {\n \n         if rust_cc > self.limit.limit() {\n             let fn_span = match kind {\n-                FnKind::ItemFn(ident, _, _, _) | FnKind::Method(ident, _, _) => ident.span,\n+                FnKind::ItemFn(ident, _, _) | FnKind::Method(ident, _) => ident.span,\n                 FnKind::Closure => {\n                     let header_span = body_span.with_hi(decl.output.span().lo());\n                     let pos = snippet_opt(cx, header_span).and_then(|snip| {"}, {"sha": "346d03ca5568f0aaf7c3593a45f721999a758ea3", "filename": "src/tools/clippy/clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -260,7 +260,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n                     }\n                     // The `module_name_repetitions` lint should only trigger if the item has the module in its\n                     // name. Having the same name is accepted.\n-                    if item.vis.node.is_pub() && item_camel.len() > mod_camel.len() {\n+                    if cx.tcx.visibility(item.def_id).is_public() && item_camel.len() > mod_camel.len() {\n                         let matching = count_match_start(mod_camel, &item_camel);\n                         let rmatching = count_match_end(mod_camel, &item_camel);\n                         let nchars = mod_camel.chars().count();"}, {"sha": "173d41b4b05060b7794a9cbac5432ace09c817c0", "filename": "src/tools/clippy/clippy_lints/src/exhaustive_items.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -78,7 +78,10 @@ impl LateLintPass<'_> for ExhaustiveItems {\n             if !attrs.iter().any(|a| a.has_name(sym::non_exhaustive));\n             then {\n                 let (lint, msg) = if let ItemKind::Struct(ref v, ..) = item.kind {\n-                    if v.fields().iter().any(|f| !f.vis.node.is_pub()) {\n+                    if v.fields().iter().any(|f| {\n+                        let def_id = cx.tcx.hir().local_def_id(f.hir_id);\n+                        !cx.tcx.visibility(def_id).is_public()\n+                    }) {\n                         // skip structs with private fields\n                         return;\n                     }"}, {"sha": "565a1c871d7580458b633285ea8a84aa913e0410", "filename": "src/tools/clippy/clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -17,8 +17,8 @@ pub(super) fn check_fn<'tcx>(\n     hir_id: hir::HirId,\n ) {\n     let unsafety = match kind {\n-        intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }, _) => unsafety,\n-        intravisit::FnKind::Method(_, sig, _) => sig.header.unsafety,\n+        intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }) => unsafety,\n+        intravisit::FnKind::Method(_, sig) => sig.header.unsafety,\n         intravisit::FnKind::Closure => return,\n     };\n "}, {"sha": "5c8d8b8e7552c9e15f23b53a60f891a94357bf8a", "filename": "src/tools/clippy/clippy_lints/src/functions/too_many_arguments.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -26,9 +26,8 @@ pub(super) fn check_fn(\n                     header: hir::FnHeader { abi: Abi::Rust, .. },\n                     ..\n                 },\n-                _,\n             )\n-            | intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _) => check_arg_number(\n+            | intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }) => check_arg_number(\n                 cx,\n                 decl,\n                 span.with_hi(decl.output.span().hi()),"}, {"sha": "9c734221ebcea4989523b48545b88bb7e7916927", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -85,7 +85,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n         }\n \n         match kind {\n-            FnKind::ItemFn(.., header, _) => {\n+            FnKind::ItemFn(.., header) => {\n                 let attrs = cx.tcx.hir().attrs(hir_id);\n                 if header.abi != Abi::Rust || requires_exact_signature(attrs) {\n                     return;"}, {"sha": "9af3059a37f93c9f7137de24778a71a0cada764a", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -251,7 +251,7 @@ impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n         }\n \n         match kind {\n-            FnKind::ItemFn(.., header, _) => {\n+            FnKind::ItemFn(.., header) => {\n                 if header.abi != Abi::Rust {\n                     return;\n                 }"}, {"sha": "e2e2400f8e267ae8e398778ed0de72ba17b1bdbb", "filename": "src/tools/clippy/clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -1,8 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use rustc_errors::Applicability;\n-use rustc_hir::{Item, ItemKind, VisibilityKind};\n+use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::def_id::CRATE_DEF_ID;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -41,7 +43,7 @@ impl_lint_pass!(RedundantPubCrate => [REDUNDANT_PUB_CRATE]);\n \n impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n-        if let VisibilityKind::Crate { .. } = item.vis.node {\n+        if cx.tcx.visibility(item.def_id) == ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id()) {\n             if !cx.access_levels.is_exported(item.def_id) && self.is_exported.last() == Some(&false) {\n                 let span = item.span.with_hi(item.ident.span.hi());\n                 let descr = cx.tcx.def_kind(item.def_id).descr(item.def_id.to_def_id());\n@@ -52,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n                     &format!(\"pub(crate) {} inside private module\", descr),\n                     |diag| {\n                         diag.span_suggestion(\n-                            item.vis.span,\n+                            item.vis_span,\n                             \"consider using\",\n                             \"pub\".to_string(),\n                             Applicability::MachineApplicable,"}, {"sha": "91e5e1e8b289288ae9c2e8d653f28484bfd8db36", "filename": "src/tools/clippy/clippy_lints/src/return_self_not_must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -111,7 +111,7 @@ impl<'tcx> LateLintPass<'tcx> for ReturnSelfNotMustUse {\n     ) {\n         if_chain! {\n             // We are only interested in methods, not in functions or associated functions.\n-            if matches!(kind, FnKind::Method(_, _, _));\n+            if matches!(kind, FnKind::Method(_, _));\n             if let Some(fn_def) = cx.tcx.hir().opt_local_def_id(hir_id);\n             if let Some(impl_def) = cx.tcx.impl_of_method(fn_def.to_def_id());\n             // We don't want this method to be te implementation of a trait because the"}, {"sha": "41333bb2addf7bbf70dfffc8a4fff632993348a3", "filename": "src/tools/clippy/clippy_lints/src/unused_async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_async.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -67,7 +67,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAsync {\n         span: Span,\n         hir_id: HirId,\n     ) {\n-        if let FnKind::ItemFn(_, _, FnHeader { asyncness, .. }, _) = &fn_kind {\n+        if let FnKind::ItemFn(_, _, FnHeader { asyncness, .. }) = &fn_kind {\n             if matches!(asyncness, IsAsync::Async) {\n                 let mut visitor = AsyncFnVisitor { cx, found_await: false };\n                 walk_fn(&mut visitor, fn_kind, fn_decl, body.id(), span, hir_id);"}, {"sha": "37b114a0cfbc2239b4d539789daf80d638bba804", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -4,6 +4,7 @@ use clippy_utils::get_attr;\n use rustc_ast::ast::{Attribute, InlineAsmTemplatePiece};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::ty;\n use rustc_session::Session;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -45,14 +46,16 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n             return;\n         }\n         println!(\"impl item `{}`\", item.ident.name);\n-        match item.vis.node {\n-            hir::VisibilityKind::Public => println!(\"public\"),\n-            hir::VisibilityKind::Crate(_) => println!(\"visible crate wide\"),\n-            hir::VisibilityKind::Restricted { path, .. } => println!(\n-                \"visible in module `{}`\",\n-                rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(path, false))\n-            ),\n-            hir::VisibilityKind::Inherited => println!(\"visibility inherited from outer item\"),\n+        match cx.tcx.visibility(item.def_id) {\n+            ty::Visibility::Public => println!(\"public\"),\n+            ty::Visibility::Restricted(def_id) => {\n+                if def_id.is_top_level_module() {\n+                    println!(\"visible crate wide\")\n+                } else {\n+                    println!(\"visible in module `{}`\", cx.tcx.def_path_str(def_id))\n+                }\n+            },\n+            ty::Visibility::Invisible => println!(\"invisible\"),\n         }\n         match item.kind {\n             hir::ImplItemKind::Const(_, body_id) => {\n@@ -360,14 +363,16 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n     let did = item.def_id;\n     println!(\"item `{}`\", item.ident.name);\n-    match item.vis.node {\n-        hir::VisibilityKind::Public => println!(\"public\"),\n-        hir::VisibilityKind::Crate(_) => println!(\"visible crate wide\"),\n-        hir::VisibilityKind::Restricted { path, .. } => println!(\n-            \"visible in module `{}`\",\n-            rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(path, false))\n-        ),\n-        hir::VisibilityKind::Inherited => println!(\"visibility inherited from outer item\"),\n+    match cx.tcx.visibility(item.def_id) {\n+        ty::Visibility::Public => println!(\"public\"),\n+        ty::Visibility::Restricted(def_id) => {\n+            if def_id.is_top_level_module() {\n+                println!(\"visible crate wide\")\n+            } else {\n+                println!(\"visible in module `{}`\", cx.tcx.def_path_str(def_id))\n+            }\n+        },\n+        ty::Visibility::Invisible => println!(\"invisible\"),\n     }\n     match item.kind {\n         hir::ItemKind::ExternCrate(ref _renamed_from) => {"}, {"sha": "2f74eaf3cf5c319a9fff3f2bc0e06d06e24da1e3", "filename": "src/tools/clippy/clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::{\n     Item, ItemKind, PathSegment, UseKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::kw;\n use rustc_span::{sym, BytePos};\n@@ -115,7 +116,8 @@ impl LateLintPass<'_> for WildcardImports {\n         if is_test_module_or_function(cx.tcx, item) {\n             self.test_modules_deep = self.test_modules_deep.saturating_add(1);\n         }\n-        if item.vis.node.is_pub() || item.vis.node.is_pub_restricted() {\n+        let module = cx.tcx.parent_module_from_def_id(item.def_id);\n+        if cx.tcx.visibility(item.def_id) != ty::Visibility::Restricted(module.to_def_id()) {\n             return;\n         }\n         if_chain! {"}, {"sha": "74978720424d46e3f64f6970383b53c11c724e53", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/143eaa8d441641251ab41ed73deaba0d8d0cf4a5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=143eaa8d441641251ab41ed73deaba0d8d0cf4a5", "patch": "@@ -1690,7 +1690,7 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n \n /// Checks if the given function kind is an async function.\n pub fn is_async_fn(kind: FnKind<'_>) -> bool {\n-    matches!(kind, FnKind::ItemFn(_, _, header, _) if header.asyncness == IsAsync::Async)\n+    matches!(kind, FnKind::ItemFn(_, _, header) if header.asyncness == IsAsync::Async)\n }\n \n /// Peels away all the compiler generated code surrounding the body of an async function,"}]}