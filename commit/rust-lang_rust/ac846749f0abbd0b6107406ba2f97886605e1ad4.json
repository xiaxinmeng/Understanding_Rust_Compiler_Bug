{"sha": "ac846749f0abbd0b6107406ba2f97886605e1ad4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjODQ2NzQ5ZjBhYmJkMGI2MTA3NDA2YmEyZjk3ODg2NjA1ZTFhZDQ=", "commit": {"author": {"name": "Vladimir Matveev", "email": "vladimir.matweev@gmail.com", "date": "2014-10-22T19:00:47Z"}, "committer": {"name": "Vladimir Matveev", "email": "vladimir.matweev@gmail.com", "date": "2014-11-05T09:01:23Z"}, "message": "Switched io::net::tcp to use ToSocketAddr\n\nTcpListener and TcpStream are converted to use ToSocketAddr trait in\ntheir constructor methods.\n\n[breaking-change]", "tree": {"sha": "add14d798cc2a519e067b72616d43ee2a49a20cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/add14d798cc2a519e067b72616d43ee2a49a20cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac846749f0abbd0b6107406ba2f97886605e1ad4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac846749f0abbd0b6107406ba2f97886605e1ad4", "html_url": "https://github.com/rust-lang/rust/commit/ac846749f0abbd0b6107406ba2f97886605e1ad4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac846749f0abbd0b6107406ba2f97886605e1ad4/comments", "author": {"login": "netvl", "id": 280456, "node_id": "MDQ6VXNlcjI4MDQ1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/280456?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netvl", "html_url": "https://github.com/netvl", "followers_url": "https://api.github.com/users/netvl/followers", "following_url": "https://api.github.com/users/netvl/following{/other_user}", "gists_url": "https://api.github.com/users/netvl/gists{/gist_id}", "starred_url": "https://api.github.com/users/netvl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netvl/subscriptions", "organizations_url": "https://api.github.com/users/netvl/orgs", "repos_url": "https://api.github.com/users/netvl/repos", "events_url": "https://api.github.com/users/netvl/events{/privacy}", "received_events_url": "https://api.github.com/users/netvl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "netvl", "id": 280456, "node_id": "MDQ6VXNlcjI4MDQ1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/280456?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netvl", "html_url": "https://github.com/netvl", "followers_url": "https://api.github.com/users/netvl/followers", "following_url": "https://api.github.com/users/netvl/following{/other_user}", "gists_url": "https://api.github.com/users/netvl/gists{/gist_id}", "starred_url": "https://api.github.com/users/netvl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netvl/subscriptions", "organizations_url": "https://api.github.com/users/netvl/orgs", "repos_url": "https://api.github.com/users/netvl/repos", "events_url": "https://api.github.com/users/netvl/events{/privacy}", "received_events_url": "https://api.github.com/users/netvl/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d97bfb22f8c4958909c5669c256c50f124c17d58", "url": "https://api.github.com/repos/rust-lang/rust/commits/d97bfb22f8c4958909c5669c256c50f124c17d58", "html_url": "https://github.com/rust-lang/rust/commit/d97bfb22f8c4958909c5669c256c50f124c17d58"}], "stats": {"total": 357, "additions": 130, "deletions": 227}, "files": [{"sha": "68577e192d2eb0eb10fe5b2fe6b3dea3c5d928e2", "filename": "src/libstd/io/net/mod.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac846749f0abbd0b6107406ba2f97886605e1ad4/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac846749f0abbd0b6107406ba2f97886605e1ad4/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fmod.rs?ref=ac846749f0abbd0b6107406ba2f97886605e1ad4", "patch": "@@ -10,8 +10,11 @@\n \n //! Networking I/O\n \n+use io::{IoError, InvalidInput};\n+use option::None;\n+use result::{Result, Ok, Err};\n use rt::rtio;\n-use self::ip::{Ipv4Addr, Ipv6Addr, IpAddr};\n+use self::ip::{Ipv4Addr, Ipv6Addr, IpAddr, ToSocketAddr};\n \n pub use self::addrinfo::get_host_addresses;\n \n@@ -38,3 +41,25 @@ fn from_rtio(ip: rtio::IpAddr) -> IpAddr {\n         }\n     }\n }\n+\n+fn with_addresses<A: ToSocketAddr, T>(\n+    addr: A, \n+    action: |&mut rtio::IoFactory, rtio::SocketAddr| -> Result<T, rtio::IoError>\n+) -> Result<T, IoError> {\n+    const DEFAULT_ERROR: IoError = IoError {\n+        kind: InvalidInput,\n+        desc: \"no addresses found for hostname\",\n+        detail: None\n+    };\n+\n+    let addresses = try!(addr.to_socket_addr_all());\n+    let mut err = DEFAULT_ERROR;\n+    for addr in addresses.into_iter() {\n+        let addr = rtio::SocketAddr { ip: to_rtio(addr.ip), port: addr.port };\n+        match rtio::LocalIo::maybe_raise(|io| action(io, addr)) {\n+            Ok(r) => return Ok(r),\n+            Err(e) => err = IoError::from_rtio_error(e)\n+        }\n+    }\n+    Err(err)\n+}"}, {"sha": "5dffc45bcd85c124e67d9cb09c6e8b50f3f63b6d", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 104, "deletions": 226, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/ac846749f0abbd0b6107406ba2f97886605e1ad4/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac846749f0abbd0b6107406ba2f97886605e1ad4/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=ac846749f0abbd0b6107406ba2f97886605e1ad4", "patch": "@@ -23,7 +23,7 @@ use iter::Iterator;\n use slice::ImmutableSlice;\n use result::{Ok,Err};\n use io::net::addrinfo::get_host_addresses;\n-use io::net::ip::SocketAddr;\n+use io::net::ip::{SocketAddr, ToSocketAddr};\n use io::{IoError, ConnectionFailed, InvalidInput};\n use io::{Reader, Writer, Listener, Acceptor};\n use io::{standard_error, TimedOut};\n@@ -45,7 +45,7 @@ use time::Duration;\n /// # #![allow(unused_must_use)]\n /// use std::io::TcpStream;\n ///\n-/// let mut stream = TcpStream::connect(\"127.0.0.1\", 34254);\n+/// let mut stream = TcpStream::connect(\"127.0.0.1:34254\");\n ///\n /// stream.write([1]);\n /// let mut buf = [0];\n@@ -61,35 +61,13 @@ impl TcpStream {\n         TcpStream { obj: s }\n     }\n \n-    /// Open a TCP connection to a remote host by hostname or IP address.\n+    /// Open a TCP connection to a remote host.\n     ///\n-    /// `host` can be a hostname or IP address string. If no error is\n-    /// encountered, then `Ok(stream)` is returned.\n-    pub fn connect(host: &str, port: u16) -> IoResult<TcpStream> {\n-        let addresses = match FromStr::from_str(host) {\n-            Some(addr) => vec!(addr),\n-            None => try!(get_host_addresses(host))\n-        };\n-        let mut err = IoError {\n-            kind: ConnectionFailed,\n-            desc: \"no addresses found for hostname\",\n-            detail: None\n-        };\n-        for addr in addresses.iter() {\n-            let addr = rtio::SocketAddr{ ip: super::to_rtio(*addr), port: port };\n-            let result = LocalIo::maybe_raise(|io| {\n-                io.tcp_connect(addr, None).map(TcpStream::new)\n-            });\n-            match result {\n-                Ok(stream) => {\n-                    return Ok(stream)\n-                }\n-                Err(connect_err) => {\n-                    err = IoError::from_rtio_error(connect_err)\n-                }\n-            }\n-        }\n-        Err(err)\n+    /// `addr` is an address of the remote host. Anything which implements `ToSocketAddr`\n+    /// trait can be supplied for the address; see this trait documentation for\n+    /// concrete examples.\n+    pub fn connect<A: ToSocketAddr>(addr: A) -> IoResult<TcpStream> {\n+        super::with_addresses(addr, |io, addr| io.tcp_connect(addr, None).map(TcpStream::new))\n     }\n \n     /// Creates a TCP connection to a remote socket address, timing out after\n@@ -99,23 +77,21 @@ impl TcpStream {\n     /// specified elapses before a connection is made an error will be\n     /// returned. The error's kind will be `TimedOut`.\n     ///\n-    /// Note that the `addr` argument may one day be split into a separate host\n-    /// and port, similar to the API seen in `connect`.\n+    /// Same as the `connect` method, `addr` argument type can vary as defined\n+    /// by `ToSocketAddr` trait.\n     ///\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n     #[experimental = \"the timeout argument may eventually change types\"]\n-    pub fn connect_timeout(addr: SocketAddr,\n-                           timeout: Duration) -> IoResult<TcpStream> {\n+    pub fn connect_timeout<A: ToSocketAddr>(addr: A,\n+                                            timeout: Duration) -> IoResult<TcpStream> {\n         if timeout <= Duration::milliseconds(0) {\n             return Err(standard_error(TimedOut));\n         }\n \n-        let SocketAddr { ip, port } = addr;\n-        let addr = rtio::SocketAddr { ip: super::to_rtio(ip), port: port };\n-        LocalIo::maybe_raise(|io| {\n+        super::with_addresses(addr, |io, addr|\n             io.tcp_connect(addr, Some(timeout.num_milliseconds() as u64)).map(TcpStream::new)\n-        }).map_err(IoError::from_rtio_error)\n+        )\n     }\n \n     /// Returns the socket address of the remote peer of this TCP connection.\n@@ -174,7 +150,7 @@ impl TcpStream {\n     /// use std::io::TcpStream;\n     /// use std::time::Duration;\n     ///\n-    /// let mut stream = TcpStream::connect(\"127.0.0.1\", 34254).unwrap();\n+    /// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n     /// let stream2 = stream.clone();\n     ///\n     /// spawn(proc() {\n@@ -311,7 +287,7 @@ impl Writer for TcpStream {\n /// use std::io::{TcpListener, TcpStream};\n /// use std::io::{Acceptor, Listener};\n ///\n-/// let listener = TcpListener::bind(\"127.0.0.1\", 80);\n+/// let listener = TcpListener::bind(\"127.0.0.1:80\");\n ///\n /// // bind the listener to the specified address\n /// let mut acceptor = listener.listen();\n@@ -340,32 +316,15 @@ pub struct TcpListener {\n }\n \n impl TcpListener {\n-    /// Creates a new `TcpListener` which will be bound to the specified IP\n-    /// and port. This listener is not ready for accepting connections,\n-    /// `listen` must be called on it before that's possible.\n+    /// Creates a new `TcpListener` which will be bound to the specified address. \n+    /// This listener is not ready for accepting connections, `listen` must be called \n+    /// on it before that's possible.\n     ///\n     /// Binding with a port number of 0 will request that the OS assigns a port\n     /// to this listener. The port allocated can be queried via the\n     /// `socket_name` function.\n-    pub fn bind(addr: &str, port: u16) -> IoResult<TcpListener> {\n-        match FromStr::from_str(addr) {\n-            Some(ip) => {\n-                let addr = rtio::SocketAddr{\n-                    ip: super::to_rtio(ip),\n-                    port: port,\n-                };\n-                LocalIo::maybe_raise(|io| {\n-                    io.tcp_bind(addr).map(|l| TcpListener { obj: l })\n-                }).map_err(IoError::from_rtio_error)\n-            }\n-            None => {\n-                Err(IoError{\n-                    kind: InvalidInput,\n-                    desc: \"invalid IP address specified\",\n-                    detail: None\n-                })\n-            }\n-        }\n+    pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<TcpListener> {\n+        super::with_addresses(addr, |io, addr| io.tcp_bind(addr).map(|l| TcpListener { obj: l }))\n     }\n \n     /// Returns the local socket address of this listener.\n@@ -419,7 +378,7 @@ impl TcpAcceptor {\n     /// use std::io::TcpListener;\n     /// use std::io::{Listener, Acceptor, TimedOut};\n     ///\n-    /// let mut a = TcpListener::bind(\"127.0.0.1\", 8482).listen().unwrap();\n+    /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n     ///\n     /// // After 100ms have passed, all accepts will fail\n     /// a.set_timeout(Some(100));\n@@ -462,7 +421,7 @@ impl TcpAcceptor {\n     /// # #![allow(experimental)]\n     /// use std::io::{TcpListener, Listener, Acceptor, EndOfFile};\n     ///\n-    /// let mut a = TcpListener::bind(\"127.0.0.1\", 8482).listen().unwrap();\n+    /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n     /// let a2 = a.clone();\n     ///\n     /// spawn(proc() {\n@@ -531,15 +490,15 @@ mod test {\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n     #[test]\n     fn bind_error() {\n-        match TcpListener::bind(\"0.0.0.0\", 1) {\n+        match TcpListener::bind(\"0.0.0.0:1\") {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, PermissionDenied),\n         }\n     }\n \n     #[test]\n     fn connect_error() {\n-        match TcpStream::connect(\"0.0.0.0\", 1) {\n+        match TcpStream::connect(\"0.0.0.0:1\") {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, ConnectionRefused),\n         }\n@@ -548,13 +507,11 @@ mod test {\n     #[test]\n     fn listen_ip4_localhost() {\n         let socket_addr = next_test_ip4();\n-        let ip_str = socket_addr.ip.to_string();\n-        let port = socket_addr.port;\n-        let listener = TcpListener::bind(ip_str.as_slice(), port);\n+        let listener = TcpListener::bind(socket_addr);\n         let mut acceptor = listener.listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(\"localhost\", port);\n+            let mut stream = TcpStream::connect((\"localhost\", socket_addr.port));\n             stream.write([144]).unwrap();\n         });\n \n@@ -567,12 +524,10 @@ mod test {\n     #[test]\n     fn connect_localhost() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(\"localhost\", addr.port);\n+            let mut stream = TcpStream::connect((\"localhost\", addr.port));\n             stream.write([64]).unwrap();\n         });\n \n@@ -585,12 +540,10 @@ mod test {\n     #[test]\n     fn connect_ip4_loopback() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(\"127.0.0.1\", addr.port);\n+            let mut stream = TcpStream::connect((\"127.0.0.1\", addr.port));\n             stream.write([44]).unwrap();\n         });\n \n@@ -603,12 +556,10 @@ mod test {\n     #[test]\n     fn connect_ip6_loopback() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(\"::1\", addr.port);\n+            let mut stream = TcpStream::connect((\"::1\", addr.port));\n             stream.write([66]).unwrap();\n         });\n \n@@ -621,12 +572,10 @@ mod test {\n     #[test]\n     fn smoke_test_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let mut stream = TcpStream::connect(addr);\n             stream.write([99]).unwrap();\n         });\n \n@@ -639,12 +588,10 @@ mod test {\n     #[test]\n     fn smoke_test_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let mut stream = TcpStream::connect(addr);\n             stream.write([99]).unwrap();\n         });\n \n@@ -657,12 +604,10 @@ mod test {\n     #[test]\n     fn read_eof_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n@@ -675,12 +620,10 @@ mod test {\n     #[test]\n     fn read_eof_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n@@ -693,12 +636,10 @@ mod test {\n     #[test]\n     fn read_eof_twice_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n@@ -719,12 +660,10 @@ mod test {\n     #[test]\n     fn read_eof_twice_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n@@ -745,12 +684,10 @@ mod test {\n     #[test]\n     fn write_close_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n@@ -773,12 +710,10 @@ mod test {\n     #[test]\n     fn write_close_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n+            let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n@@ -801,14 +736,12 @@ mod test {\n     #[test]\n     fn multiple_connect_serial_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n         let max = 10u;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n             for _ in range(0, max) {\n-                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+                let mut stream = TcpStream::connect(addr);\n                 stream.write([99]).unwrap();\n             }\n         });\n@@ -823,14 +756,12 @@ mod test {\n     #[test]\n     fn multiple_connect_serial_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n         let max = 10u;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n             for _ in range(0, max) {\n-                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+                let mut stream = TcpStream::connect(addr);\n                 stream.write([99]).unwrap();\n             }\n         });\n@@ -845,10 +776,8 @@ mod test {\n     #[test]\n     fn multiple_connect_interleaved_greedy_schedule_ip4() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n         static MAX: int = 10;\n-        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -867,13 +796,11 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n-            let ip_str = addr.ip.to_string();\n-            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+                let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -885,10 +812,8 @@ mod test {\n     #[test]\n     fn multiple_connect_interleaved_greedy_schedule_ip6() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n         static MAX: int = 10;\n-        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -907,13 +832,11 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n-            let ip_str = addr.ip.to_string();\n-            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+                let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -926,9 +849,7 @@ mod test {\n     fn multiple_connect_interleaved_lazy_schedule_ip4() {\n         static MAX: int = 10;\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -947,13 +868,11 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n-            let ip_str = addr.ip.to_string();\n-            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+                let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -966,9 +885,7 @@ mod test {\n     fn multiple_connect_interleaved_lazy_schedule_ip6() {\n         static MAX: int = 10;\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -987,13 +904,11 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n-            let ip_str = addr.ip.to_string();\n-            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n+                let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -1003,9 +918,7 @@ mod test {\n     }\n \n     pub fn socket_name(addr: SocketAddr) {\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut listener = TcpListener::bind(ip_str.as_slice(), port).unwrap();\n+        let mut listener = TcpListener::bind(addr).unwrap();\n \n         // Make sure socket_name gives\n         // us the socket we binded to.\n@@ -1015,15 +928,13 @@ mod test {\n     }\n \n     pub fn peer_name(addr: SocketAddr) {\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let acceptor = TcpListener::bind(addr).listen();\n         spawn(proc() {\n             let mut acceptor = acceptor;\n             acceptor.accept().unwrap();\n         });\n \n-        let stream = TcpStream::connect(ip_str.as_slice(), port);\n+        let stream = TcpStream::connect(addr);\n \n         assert!(stream.is_ok());\n         let mut stream = stream.unwrap();\n@@ -1052,11 +963,9 @@ mod test {\n     #[test]\n     fn partial_read() {\n         let addr = next_test_ip4();\n-        let port = addr.port;\n         let (tx, rx) = channel();\n         spawn(proc() {\n-            let ip_str = addr.ip.to_string();\n-            let mut srv = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n+            let mut srv = TcpListener::bind(addr).listen().unwrap();\n             tx.send(());\n             let mut cl = srv.accept().unwrap();\n             cl.write([10]).unwrap();\n@@ -1066,8 +975,7 @@ mod test {\n         });\n \n         rx.recv();\n-        let ip_str = addr.ip.to_string();\n-        let mut c = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+        let mut c = TcpStream::connect(addr).unwrap();\n         let mut b = [0, ..10];\n         assert_eq!(c.read(b), Ok(1));\n         c.write([1]).unwrap();\n@@ -1077,11 +985,9 @@ mod test {\n     #[test]\n     fn double_bind() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let listener = TcpListener::bind(ip_str.as_slice(), port).unwrap().listen();\n+        let listener = TcpListener::bind(addr).unwrap().listen();\n         assert!(listener.is_ok());\n-        match TcpListener::bind(ip_str.as_slice(), port).listen() {\n+        match TcpListener::bind(addr).listen() {\n             Ok(..) => panic!(),\n             Err(e) => {\n                 assert!(e.kind == ConnectionRefused || e.kind == OtherIoError,\n@@ -1093,20 +999,17 @@ mod test {\n     #[test]\n     fn fast_rebind() {\n         let addr = next_test_ip4();\n-        let port = addr.port;\n         let (tx, rx) = channel();\n \n         spawn(proc() {\n-            let ip_str = addr.ip.to_string();\n             rx.recv();\n-            let _stream = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+            let _stream = TcpStream::connect(addr).unwrap();\n             // Close\n             rx.recv();\n         });\n \n         {\n-            let ip_str = addr.ip.to_string();\n-            let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+            let mut acceptor = TcpListener::bind(addr).listen();\n             tx.send(());\n             {\n                 let _stream = acceptor.accept().unwrap();\n@@ -1115,18 +1018,16 @@ mod test {\n             }\n             // Close listener\n         }\n-        let _listener = TcpListener::bind(addr.ip.to_string().as_slice(), port);\n+        let _listener = TcpListener::bind(addr);\n     }\n \n     #[test]\n     fn tcp_clone_smoke() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str.as_slice(), port);\n+            let mut s = TcpStream::connect(addr);\n             let mut buf = [0, 0];\n             assert_eq!(s.read(buf), Ok(1));\n             assert_eq!(buf[0], 1);\n@@ -1153,14 +1054,12 @@ mod test {\n     #[test]\n     fn tcp_clone_two_read() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str.as_slice(), port);\n+            let mut s = TcpStream::connect(addr);\n             s.write([1]).unwrap();\n             rx.recv();\n             s.write([2]).unwrap();\n@@ -1188,12 +1087,10 @@ mod test {\n     #[test]\n     fn tcp_clone_two_write() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str.as_slice(), port);\n+            let mut s = TcpStream::connect(addr);\n             let mut buf = [0, 1];\n             s.read(buf).unwrap();\n             s.read(buf).unwrap();\n@@ -1218,17 +1115,15 @@ mod test {\n         use rt::rtio::RtioTcpStream;\n \n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let a = TcpListener::bind(ip_str.as_slice(), port).unwrap().listen();\n+        let a = TcpListener::bind(addr).unwrap().listen();\n         spawn(proc() {\n             let mut a = a;\n             let mut c = a.accept().unwrap();\n             assert_eq!(c.read_to_end(), Ok(vec!()));\n             c.write([1]).unwrap();\n         });\n \n-        let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+        let mut s = TcpStream::connect(addr).unwrap();\n         assert!(s.obj.close_write().is_ok());\n         assert!(s.write([1]).is_err());\n         assert_eq!(s.read_to_end(), Ok(vec!(1)));\n@@ -1237,9 +1132,7 @@ mod test {\n     #[test]\n     fn accept_timeout() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str.as_slice(), port).unwrap().listen().unwrap();\n+        let mut a = TcpListener::bind(addr).unwrap().listen().unwrap();\n \n         a.set_timeout(Some(10));\n \n@@ -1258,8 +1151,7 @@ mod test {\n         if !cfg!(target_os = \"freebsd\") {\n             let (tx, rx) = channel();\n             spawn(proc() {\n-                tx.send(TcpStream::connect(addr.ip.to_string().as_slice(),\n-                                           port).unwrap());\n+                tx.send(TcpStream::connect(addr).unwrap());\n             });\n             let _l = rx.recv();\n             for i in range(0i, 1001) {\n@@ -1276,18 +1168,15 @@ mod test {\n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n         spawn(proc() {\n-            drop(TcpStream::connect(addr.ip.to_string().as_slice(),\n-                                    port).unwrap());\n+            drop(TcpStream::connect(addr).unwrap());\n         });\n         a.accept().unwrap();\n     }\n \n     #[test]\n     fn close_readwrite_smoke() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n+        let a = TcpListener::bind(addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n         spawn(proc() {\n             let mut a = a;\n@@ -1296,7 +1185,7 @@ mod test {\n         });\n \n         let mut b = [0];\n-        let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+        let mut s = TcpStream::connect(addr).unwrap();\n         let mut s2 = s.clone();\n \n         // closing should prevent reads/writes\n@@ -1324,17 +1213,15 @@ mod test {\n     #[test]\n     fn close_read_wakes_up() {\n         let addr = next_test_ip4();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n+        let a = TcpListener::bind(addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n         spawn(proc() {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv_opt();\n         });\n \n-        let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+        let mut s = TcpStream::connect(addr).unwrap();\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n         spawn(proc() {\n@@ -1352,12 +1239,10 @@ mod test {\n     #[test]\n     fn readwrite_timeouts() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+            let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             assert!(s.write([0]).is_ok());\n             let _ = rx.recv_opt();\n@@ -1387,12 +1272,10 @@ mod test {\n     #[test]\n     fn read_timeouts() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+            let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             let mut amt = 0;\n             while amt < 100 * 128 * 1024 {\n@@ -1418,12 +1301,10 @@ mod test {\n     #[test]\n     fn write_timeouts() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+            let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             assert!(s.write([0]).is_ok());\n             let _ = rx.recv_opt();\n@@ -1448,12 +1329,10 @@ mod test {\n     #[test]\n     fn timeout_concurrent_read() {\n         let addr = next_test_ip6();\n-        let ip_str = addr.ip.to_string();\n-        let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n+        let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n+            let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             assert_eq!(s.write([0]), Ok(()));\n             let _ = rx.recv_opt();\n@@ -1478,16 +1357,15 @@ mod test {\n     #[test]\n     fn clone_while_reading() {\n         let addr = next_test_ip6();\n-        let listen = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let listen = TcpListener::bind(addr);\n         let mut accept = listen.listen().unwrap();\n \n         // Enqueue a task to write to a socket\n         let (tx, rx) = channel();\n         let (txdone, rxdone) = channel();\n         let txdone2 = txdone.clone();\n         spawn(proc() {\n-            let mut tcp = TcpStream::connect(addr.ip.to_string().as_slice(),\n-                                             addr.port).unwrap();\n+            let mut tcp = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             tcp.write_u8(0).unwrap();\n             txdone2.send(());\n@@ -1519,15 +1397,15 @@ mod test {\n     #[test]\n     fn clone_accept_smoke() {\n         let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let l = TcpListener::bind(addr);\n         let mut a = l.listen().unwrap();\n         let mut a2 = a.clone();\n \n         spawn(proc() {\n-            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+            let _ = TcpStream::connect(addr);\n         });\n         spawn(proc() {\n-            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+            let _ = TcpStream::connect(addr);\n         });\n \n         assert!(a.accept().is_ok());\n@@ -1537,7 +1415,7 @@ mod test {\n     #[test]\n     fn clone_accept_concurrent() {\n         let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let l = TcpListener::bind(addr);\n         let a = l.listen().unwrap();\n         let a2 = a.clone();\n \n@@ -1548,10 +1426,10 @@ mod test {\n         spawn(proc() { let mut a = a2; tx2.send(a.accept()) });\n \n         spawn(proc() {\n-            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+            let _ = TcpStream::connect(addr);\n         });\n         spawn(proc() {\n-            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+            let _ = TcpStream::connect(addr);\n         });\n \n         assert!(rx.recv().is_ok());\n@@ -1561,7 +1439,7 @@ mod test {\n     #[test]\n     fn close_accept_smoke() {\n         let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let l = TcpListener::bind(addr);\n         let mut a = l.listen().unwrap();\n \n         a.close_accept().unwrap();\n@@ -1571,7 +1449,7 @@ mod test {\n     #[test]\n     fn close_accept_concurrent() {\n         let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let l = TcpListener::bind(addr);\n         let a = l.listen().unwrap();\n         let mut a2 = a.clone();\n "}]}