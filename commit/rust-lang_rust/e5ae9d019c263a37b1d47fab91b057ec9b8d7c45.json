{"sha": "e5ae9d019c263a37b1d47fab91b057ec9b8d7c45", "node_id": "C_kwDOAAsO6NoAKGU1YWU5ZDAxOWMyNjNhMzdiMWQ0N2ZhYjkxYjA1N2VjOWI4ZDdjNDU", "commit": {"author": {"name": "Rejyr", "email": "jerrylwang123@gmail.com", "date": "2022-09-04T19:46:35Z"}, "committer": {"name": "Rejyr", "email": "jerrylwang123@gmail.com", "date": "2023-01-09T22:07:25Z"}, "message": "migrate: `unused.rs`", "tree": {"sha": "21bbf02ddcf2779fba1597fe64de20efe3750177", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21bbf02ddcf2779fba1597fe64de20efe3750177"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5ae9d019c263a37b1d47fab91b057ec9b8d7c45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5ae9d019c263a37b1d47fab91b057ec9b8d7c45", "html_url": "https://github.com/rust-lang/rust/commit/e5ae9d019c263a37b1d47fab91b057ec9b8d7c45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5ae9d019c263a37b1d47fab91b057ec9b8d7c45/comments", "author": {"login": "Rejyr", "id": 88239847, "node_id": "MDQ6VXNlcjg4MjM5ODQ3", "avatar_url": "https://avatars.githubusercontent.com/u/88239847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Rejyr", "html_url": "https://github.com/Rejyr", "followers_url": "https://api.github.com/users/Rejyr/followers", "following_url": "https://api.github.com/users/Rejyr/following{/other_user}", "gists_url": "https://api.github.com/users/Rejyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/Rejyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Rejyr/subscriptions", "organizations_url": "https://api.github.com/users/Rejyr/orgs", "repos_url": "https://api.github.com/users/Rejyr/repos", "events_url": "https://api.github.com/users/Rejyr/events{/privacy}", "received_events_url": "https://api.github.com/users/Rejyr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Rejyr", "id": 88239847, "node_id": "MDQ6VXNlcjg4MjM5ODQ3", "avatar_url": "https://avatars.githubusercontent.com/u/88239847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Rejyr", "html_url": "https://github.com/Rejyr", "followers_url": "https://api.github.com/users/Rejyr/followers", "following_url": "https://api.github.com/users/Rejyr/following{/other_user}", "gists_url": "https://api.github.com/users/Rejyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/Rejyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Rejyr/subscriptions", "organizations_url": "https://api.github.com/users/Rejyr/orgs", "repos_url": "https://api.github.com/users/Rejyr/repos", "events_url": "https://api.github.com/users/Rejyr/events{/privacy}", "received_events_url": "https://api.github.com/users/Rejyr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d44ccaa56f2ddebfe5794330876325d3b6b83869", "url": "https://api.github.com/repos/rust-lang/rust/commits/d44ccaa56f2ddebfe5794330876325d3b6b83869", "html_url": "https://github.com/rust-lang/rust/commit/d44ccaa56f2ddebfe5794330876325d3b6b83869"}], "stats": {"total": 304, "additions": 201, "deletions": 103}, "files": [{"sha": "c68bfc98f9351b340cbda993107d8f0a0bf1e6ed", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 132, "deletions": 1, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/e5ae9d019c263a37b1d47fab91b057ec9b8d7c45/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ae9d019c263a37b1d47fab91b057ec9b8d7c45/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=e5ae9d019c263a37b1d47fab91b057ec9b8d7c45", "patch": "@@ -1,7 +1,11 @@\n-use rustc_errors::{fluent, AddSubdiagnostic, DecorateLint, EmissionGuarantee};\n+use rustc_errors::{fluent, AddSubdiagnostic, Applicability, DecorateLint, EmissionGuarantee};\n+use rustc_hir::def_id::DefId;\n use rustc_macros::{LintDiagnostic, SessionSubdiagnostic};\n+use rustc_middle::ty::Ty;\n use rustc_span::{Span, Symbol};\n \n+use crate::LateContext;\n+\n #[derive(LintDiagnostic)]\n #[diag(lint_range_endpoint_out_of_range)]\n pub struct RangeEndpointOutOfRange<'a> {\n@@ -146,3 +150,130 @@ pub struct InvalidAtomicOrderingDiag {\n     #[label]\n     pub fail_order_arg_span: Span,\n }\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_op)]\n+pub struct UnusedOp<'a> {\n+    pub op: &'a str,\n+    #[label]\n+    pub label: Span,\n+    #[suggestion(style = \"verbose\", code = \"let _ = \", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_result)]\n+pub struct UnusedResult<'a> {\n+    pub ty: Ty<'a>,\n+}\n+\n+// FIXME(davidtwco): this isn't properly translatable becauses of the\n+// pre/post strings\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_closure)]\n+#[note]\n+pub struct UnusedClosure<'a> {\n+    pub count: usize,\n+    pub pre: &'a str,\n+    pub post: &'a str,\n+}\n+\n+// FIXME(davidtwco): this isn't properly translatable becauses of the\n+// pre/post strings\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_generator)]\n+#[note]\n+pub struct UnusedGenerator<'a> {\n+    pub count: usize,\n+    pub pre: &'a str,\n+    pub post: &'a str,\n+}\n+\n+// FIXME(davidtwco): this isn't properly translatable becauses of the pre/post\n+// strings\n+pub struct UnusedDef<'a, 'b> {\n+    pub pre: &'a str,\n+    pub post: &'a str,\n+    pub cx: &'a LateContext<'b>,\n+    pub def_id: DefId,\n+    pub note: Option<Symbol>,\n+}\n+\n+// FIXME: refactor with `Option<String>` in macro\n+impl<'a, 'b, G: EmissionGuarantee> DecorateLint<'_, G> for UnusedDef<'a, 'b> {\n+    fn decorate_lint(self, diag: rustc_errors::LintDiagnosticBuilder<'_, G>) {\n+        let mut diag = diag.build(fluent::lint_unused_def);\n+        diag.set_arg(\"pre\", self.pre);\n+        diag.set_arg(\"post\", self.post);\n+        diag.set_arg(\"def\", self.cx.tcx.def_path_str(self.def_id));\n+        // check for #[must_use = \"...\"]\n+        if let Some(note) = self.note {\n+            diag.note(note.as_str());\n+        }\n+        diag.emit();\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_path_statement_drop)]\n+pub struct PathStatementDrop {\n+    #[subdiagnostic]\n+    pub sub: PathStatementDropSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum PathStatementDropSub {\n+    #[suggestion(\n+        suggestion,\n+        code = \"drop({snippet});\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+    },\n+    #[help(help)]\n+    Help {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_path_statement_no_effect)]\n+pub struct PathStatementNoEffect;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_delim)]\n+pub struct UnusedDelim<'a> {\n+    pub delim: &'static str,\n+    pub item: &'a str,\n+    #[subdiagnostic]\n+    pub suggestion: Option<UnusedDelimSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n+pub struct UnusedDelimSuggestion {\n+    #[suggestion_part(code = \"{start_replace}\")]\n+    pub start_span: Span,\n+    pub start_replace: &'static str,\n+    #[suggestion_part(code = \"{end_replace}\")]\n+    pub end_span: Span,\n+    pub end_replace: &'static str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_import_braces)]\n+pub struct UnusedImportBracesDiag {\n+    pub node: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_allocation)]\n+pub struct UnusedAllocationDiag;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_allocation_mut)]\n+pub struct UnusedAllocationMutDiag;"}, {"sha": "8c5f68d614461db60b05eea8f0797eb4c07995b6", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 69, "deletions": 102, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/e5ae9d019c263a37b1d47fab91b057ec9b8d7c45/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ae9d019c263a37b1d47fab91b057ec9b8d7c45/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=e5ae9d019c263a37b1d47fab91b057ec9b8d7c45", "patch": "@@ -1,9 +1,16 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+use crate::lints::{\n+    PathStatementDrop, PathStatementDropSub, PathStatementNoEffect, UnusedAllocationDiag,\n+    UnusedAllocationMutDiag, UnusedClosure, UnusedDef, UnusedDelim, UnusedDelimSuggestion,\n+    UnusedGenerator, UnusedImportBracesDiag, UnusedOp, UnusedResult,\n+};\n use crate::Lint;\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_ast::util::{classify, parser};\n use rustc_ast::{ExprKind, StmtKind};\n-use rustc_errors::{fluent, pluralize, Applicability, MultiSpan};\n+use rustc_errors::{pluralize, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -163,23 +170,20 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n         let mut op_warned = false;\n \n         if let Some(must_use_op) = must_use_op {\n-            cx.struct_span_lint(UNUSED_MUST_USE, expr.span, fluent::lint_unused_op, |lint| {\n-                lint.set_arg(\"op\", must_use_op)\n-                    .span_label(expr.span, fluent::label)\n-                    .span_suggestion_verbose(\n-                        expr.span.shrink_to_lo(),\n-                        fluent::suggestion,\n-                        \"let _ = \",\n-                        Applicability::MachineApplicable,\n-                    )\n-            });\n+            cx.emit_spanned_lint(\n+                UNUSED_MUST_USE,\n+                expr.span,\n+                UnusedOp {\n+                    op: must_use_op,\n+                    label: expr.span,\n+                    suggestion: expr.span.shrink_to_lo(),\n+                },\n+            );\n             op_warned = true;\n         }\n \n         if !(type_lint_emitted_or_suppressed || fn_warned || op_warned) {\n-            cx.struct_span_lint(UNUSED_RESULTS, s.span, fluent::lint_unused_result, |lint| {\n-                lint.set_arg(\"ty\", ty)\n-            });\n+            cx.emit_spanned_lint(UNUSED_RESULTS, s.span, UnusedResult { ty });\n         }\n \n         fn check_fn_must_use(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n@@ -402,47 +406,31 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     );\n                 }\n                 MustUsePath::Closure(span) => {\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         UNUSED_MUST_USE,\n                         *span,\n-                        fluent::lint_unused_closure,\n-                        |lint| {\n-                            // FIXME(davidtwco): this isn't properly translatable because of the\n-                            // pre/post strings\n-                            lint.set_arg(\"count\", plural_len)\n-                                .set_arg(\"pre\", descr_pre)\n-                                .set_arg(\"post\", descr_post)\n-                                .note(fluent::note)\n-                        },\n+                        UnusedClosure { count: plural_len, pre: descr_pre, post: descr_post },\n                     );\n                 }\n                 MustUsePath::Generator(span) => {\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         UNUSED_MUST_USE,\n                         *span,\n-                        fluent::lint_unused_generator,\n-                        |lint| {\n-                            // FIXME(davidtwco): this isn't properly translatable because of the\n-                            // pre/post strings\n-                            lint.set_arg(\"count\", plural_len)\n-                                .set_arg(\"pre\", descr_pre)\n-                                .set_arg(\"post\", descr_post)\n-                                .note(fluent::note)\n-                        },\n+                        UnusedGenerator { count: plural_len, pre: descr_pre, post: descr_post },\n                     );\n                 }\n                 MustUsePath::Def(span, def_id, reason) => {\n-                    cx.struct_span_lint(UNUSED_MUST_USE, *span, fluent::lint_unused_def, |lint| {\n-                        // FIXME(davidtwco): this isn't properly translatable because of the pre/post\n-                        // strings\n-                        lint.set_arg(\"pre\", descr_pre);\n-                        lint.set_arg(\"post\", descr_post);\n-                        lint.set_arg(\"def\", cx.tcx.def_path_str(*def_id));\n-                        if let Some(note) = reason {\n-                            lint.note(note.as_str());\n-                        }\n-                        lint\n-                    });\n+                    cx.emit_spanned_lint(\n+                        UNUSED_MUST_USE,\n+                        *span,\n+                        UnusedDef {\n+                            pre: descr_pre,\n+                            post: descr_post,\n+                            cx,\n+                            def_id: *def_id,\n+                            note: *reason,\n+                        },\n+                    );\n                 }\n             }\n         }\n@@ -478,31 +466,15 @@ impl<'tcx> LateLintPass<'tcx> for PathStatements {\n             if let hir::ExprKind::Path(_) = expr.kind {\n                 let ty = cx.typeck_results().expr_ty(expr);\n                 if ty.needs_drop(cx.tcx, cx.param_env) {\n-                    cx.struct_span_lint(\n-                        PATH_STATEMENTS,\n-                        s.span,\n-                        fluent::lint_path_statement_drop,\n-                        |lint| {\n-                            if let Ok(snippet) = cx.sess().source_map().span_to_snippet(expr.span) {\n-                                lint.span_suggestion(\n-                                    s.span,\n-                                    fluent::suggestion,\n-                                    format!(\"drop({});\", snippet),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            } else {\n-                                lint.span_help(s.span, fluent::suggestion);\n-                            }\n-                            lint\n-                        },\n-                    );\n+                    let sub = if let Ok(snippet) = cx.sess().source_map().span_to_snippet(expr.span)\n+                    {\n+                        PathStatementDropSub::Suggestion { span: s.span, snippet }\n+                    } else {\n+                        PathStatementDropSub::Help { span: s.span }\n+                    };\n+                    cx.emit_spanned_lint(PATH_STATEMENTS, s.span, PathStatementDrop { sub })\n                 } else {\n-                    cx.struct_span_lint(\n-                        PATH_STATEMENTS,\n-                        s.span,\n-                        fluent::lint_path_statement_no_effect,\n-                        |lint| lint,\n-                    );\n+                    cx.emit_spanned_lint(PATH_STATEMENTS, s.span, PathStatementNoEffect);\n                 }\n             }\n         }\n@@ -695,36 +667,35 @@ trait UnusedDelimLint {\n         } else {\n             MultiSpan::from(value_span)\n         };\n-        cx.struct_span_lint(self.lint(), primary_span, fluent::lint_unused_delim, |lint| {\n-            lint.set_arg(\"delim\", Self::DELIM_STR);\n-            lint.set_arg(\"item\", msg);\n-            if let Some((lo, hi)) = spans {\n-                let sm = cx.sess().source_map();\n-                let lo_replace =\n+        let suggestion = spans.map(|(lo, hi)| {\n+            let sm = cx.sess().source_map();\n+            let lo_replace =\n                     if keep_space.0 &&\n                         let Ok(snip) = sm.span_to_prev_source(lo) && !snip.ends_with(' ') {\n-                        \" \".to_string()\n+                        \" \"\n                         } else {\n-                            \"\".to_string()\n+                            \"\"\n                         };\n \n-                let hi_replace =\n+            let hi_replace =\n                     if keep_space.1 &&\n                         let Ok(snip) = sm.span_to_next_source(hi) && !snip.starts_with(' ') {\n-                        \" \".to_string()\n+                        \" \"\n                         } else {\n-                            \"\".to_string()\n+                            \"\"\n                         };\n-\n-                let replacement = vec![(lo, lo_replace), (hi, hi_replace)];\n-                lint.multipart_suggestion(\n-                    fluent::suggestion,\n-                    replacement,\n-                    Applicability::MachineApplicable,\n-                );\n+            UnusedDelimSuggestion {\n+                start_span: lo,\n+                start_replace: lo_replace,\n+                end_span: hi,\n+                end_replace: hi_replace,\n             }\n-            lint\n         });\n+        cx.emit_spanned_lint(\n+            self.lint(),\n+            primary_span,\n+            UnusedDelim { delim: Self::DELIM_STR, item: msg, suggestion },\n+        );\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n@@ -1297,11 +1268,10 @@ impl UnusedImportBraces {\n                 ast::UseTreeKind::Nested(_) => return,\n             };\n \n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 UNUSED_IMPORT_BRACES,\n                 item.span,\n-                fluent::lint_unused_import_braces,\n-                |lint| lint.set_arg(\"node\", node_name),\n+                UnusedImportBracesDiag { node: node_name },\n             );\n         }\n     }\n@@ -1351,17 +1321,14 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAllocation {\n \n         for adj in cx.typeck_results().expr_adjustments(e) {\n             if let adjustment::Adjust::Borrow(adjustment::AutoBorrow::Ref(_, m)) = adj.kind {\n-                cx.struct_span_lint(\n-                    UNUSED_ALLOCATION,\n-                    e.span,\n-                    match m {\n-                        adjustment::AutoBorrowMutability::Not => fluent::lint_unused_allocation,\n-                        adjustment::AutoBorrowMutability::Mut { .. } => {\n-                            fluent::lint_unused_allocation_mut\n-                        }\n-                    },\n-                    |lint| lint,\n-                );\n+                match m {\n+                    adjustment::AutoBorrowMutability::Not => {\n+                        cx.emit_spanned_lint(UNUSED_ALLOCATION, e.span, UnusedAllocationDiag);\n+                    }\n+                    adjustment::AutoBorrowMutability::Mut { .. } => {\n+                        cx.emit_spanned_lint(UNUSED_ALLOCATION, e.span, UnusedAllocationMutDiag);\n+                    }\n+                };\n             }\n         }\n     }"}]}