{"sha": "0b4bff93fa650b122634389a3ac041f478c79dc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNGJmZjkzZmE2NTBiMTIyNjM0Mzg5YTNhYzA0MWY0NzhjNzlkYzU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-06T15:35:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-06T15:35:16Z"}, "message": "Merge #10168\n\n10168: internal: make name consistent with usage r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "370b1cf589a6a3b7c94613257f03381d40c65efa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/370b1cf589a6a3b7c94613257f03381d40c65efa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b4bff93fa650b122634389a3ac041f478c79dc5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhNjU0CRBK7hj4Ov3rIwAAlvoIABIJi+6txhe0aMBPKrZ6BWp6\n5MwRNf8Osw90DLK0h9uJVTTrO5XHqDUzGMSKG05AgrOtQJfd0y2Th3gKakGSirU1\nweVkgSm1AcCs97MtvHamGT0K1NLz92dI+QxzY49M19g8btnCMqV8RTEhNgrDSEKt\nYqqidNi8t4x0je2SJmFlprkBoG9qZdzRwEVAincXQkhG2Riu8a3v+MQxpQqZxbmk\nufzjDypy7eVNktmSNEbyGXAxftHjMXNqhV1UpZNwJYIKJctXKhXTBWkYE0qBOKQh\njUk+HpK/q7ANjQ32XyvrRp53+Ljwzkhtm0laD2896OUgbb01/2BkzHlDwCmXQaY=\n=UcEQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 370b1cf589a6a3b7c94613257f03381d40c65efa\nparent 7d9eb4fd7397dd7c556051007d8d21fdc9a93cf6\nparent 104cd0ce883eef6060042bdf694d493d16be49a9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1630942516 +0000\ncommitter GitHub <noreply@github.com> 1630942516 +0000\n\nMerge #10168\n\n10168: internal: make name consistent with usage r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b4bff93fa650b122634389a3ac041f478c79dc5", "html_url": "https://github.com/rust-lang/rust/commit/0b4bff93fa650b122634389a3ac041f478c79dc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b4bff93fa650b122634389a3ac041f478c79dc5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d9eb4fd7397dd7c556051007d8d21fdc9a93cf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d9eb4fd7397dd7c556051007d8d21fdc9a93cf6", "html_url": "https://github.com/rust-lang/rust/commit/7d9eb4fd7397dd7c556051007d8d21fdc9a93cf6"}, {"sha": "104cd0ce883eef6060042bdf694d493d16be49a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/104cd0ce883eef6060042bdf694d493d16be49a9", "html_url": "https://github.com/rust-lang/rust/commit/104cd0ce883eef6060042bdf694d493d16be49a9"}], "stats": {"total": 194, "additions": 105, "deletions": 89}, "files": [{"sha": "f8cc940486d43356c51dab4e35df67280a06dcc3", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=0b4bff93fa650b122634389a3ac041f478c79dc5", "patch": "@@ -695,7 +695,8 @@ impl Attr {\n         hygiene: &Hygiene,\n         id: AttrId,\n     ) -> Option<Attr> {\n-        let (parse, _) = mbe::token_tree_to_syntax_node(tt, mbe::FragmentKind::MetaItem).ok()?;\n+        let (parse, _) =\n+            mbe::token_tree_to_syntax_node(tt, mbe::ParserEntryPoint::MetaItem).ok()?;\n         let ast = ast::Meta::cast(parse.syntax_node())?;\n \n         Self::from_src(db, ast, hygiene, id)"}, {"sha": "c5738a2a0ec810f59fc8465e02da8d40e00b5031", "filename": "crates/hir_expand/src/builtin_derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=0b4bff93fa650b122634389a3ac041f478c79dc5", "patch": "@@ -72,7 +72,7 @@ struct BasicAdtInfo {\n }\n \n fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, mbe::ExpandError> {\n-    let (parsed, token_map) = mbe::token_tree_to_syntax_node(tt, mbe::FragmentKind::Items)?; // FragmentKind::Items doesn't parse attrs?\n+    let (parsed, token_map) = mbe::token_tree_to_syntax_node(tt, mbe::ParserEntryPoint::Items)?; // FragmentKind::Items doesn't parse attrs?\n     let macro_items = ast::MacroItems::cast(parsed.syntax_node()).ok_or_else(|| {\n         debug!(\"derive node didn't parse\");\n         mbe::ExpandError::UnexpectedToken"}, {"sha": "14fe5cd3bbc141776db9387b2db43b993f427ba3", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=0b4bff93fa650b122634389a3ac041f478c79dc5", "patch": "@@ -444,12 +444,12 @@ fn token_tree_to_syntax_node(\n     tt: &tt::Subtree,\n     expand_to: ExpandTo,\n ) -> Result<(Parse<SyntaxNode>, mbe::TokenMap), ExpandError> {\n-    let fragment = match expand_to {\n-        ExpandTo::Statements => mbe::FragmentKind::Statements,\n-        ExpandTo::Items => mbe::FragmentKind::Items,\n-        ExpandTo::Pattern => mbe::FragmentKind::Pattern,\n-        ExpandTo::Type => mbe::FragmentKind::Type,\n-        ExpandTo::Expr => mbe::FragmentKind::Expr,\n+    let entry_point = match expand_to {\n+        ExpandTo::Statements => mbe::ParserEntryPoint::Statements,\n+        ExpandTo::Items => mbe::ParserEntryPoint::Items,\n+        ExpandTo::Pattern => mbe::ParserEntryPoint::Pattern,\n+        ExpandTo::Type => mbe::ParserEntryPoint::Type,\n+        ExpandTo::Expr => mbe::ParserEntryPoint::Expr,\n     };\n-    mbe::token_tree_to_syntax_node(tt, fragment)\n+    mbe::token_tree_to_syntax_node(tt, entry_point)\n }"}, {"sha": "ac87c5102335e6a2d8f805e4cfe8e71c742b3255", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=0b4bff93fa650b122634389a3ac041f478c79dc5", "patch": "@@ -131,7 +131,7 @@ pub fn expand_eager_macro(\n     let arg_file_id = arg_id;\n \n     let parsed_args = diagnostic_sink\n-        .result(mbe::token_tree_to_syntax_node(&parsed_args, mbe::FragmentKind::Expr))?\n+        .result(mbe::token_tree_to_syntax_node(&parsed_args, mbe::ParserEntryPoint::Expr))?\n         .0;\n     let result = eager_macro_recur(\n         db,"}, {"sha": "7d8f97c775cfa40580bee92aed5a952600191cbb", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=0b4bff93fa650b122634389a3ac041f478c79dc5", "patch": "@@ -69,7 +69,7 @@ use crate::{\n };\n \n use super::ExpandResult;\n-use parser::FragmentKind::*;\n+use parser::ParserEntryPoint::*;\n use smallvec::{smallvec, SmallVec};\n use syntax::SmolStr;\n "}, {"sha": "0a1b7cc848979a332d7bad492a05163f15f5a5f7", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=0b4bff93fa650b122634389a3ac041f478c79dc5", "patch": "@@ -24,7 +24,7 @@ use crate::{\n };\n \n // FIXME: we probably should re-think  `token_tree_to_syntax_node` interfaces\n-pub use ::parser::FragmentKind;\n+pub use ::parser::ParserEntryPoint;\n pub use tt::{Delimiter, DelimiterKind, Punct};\n \n #[derive(Debug, PartialEq, Eq)]"}, {"sha": "fb082a4a05a6e2ed9bdd6492868efceeb7176e29", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=0b4bff93fa650b122634389a3ac041f478c79dc5", "patch": "@@ -13,7 +13,7 @@ use syntax::{\n use tt::buffer::{Cursor, TokenBuffer};\n \n use crate::{\n-    subtree_source::SubtreeTokenSource, tt_iter::TtIter, ExpandError, FragmentKind, TokenMap,\n+    subtree_source::SubtreeTokenSource, tt_iter::TtIter, ExpandError, ParserEntryPoint, TokenMap,\n };\n \n /// Convert the syntax node to a `TokenTree` (what macro\n@@ -49,7 +49,7 @@ pub fn syntax_node_to_token_tree_censored(\n \n pub fn token_tree_to_syntax_node(\n     tt: &tt::Subtree,\n-    fragment_kind: FragmentKind,\n+    entry_point: ParserEntryPoint,\n ) -> Result<(Parse<SyntaxNode>, TokenMap), ExpandError> {\n     let buffer = match tt {\n         tt::Subtree { delimiter: None, token_trees } => {\n@@ -59,7 +59,7 @@ pub fn token_tree_to_syntax_node(\n     };\n     let mut token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(buffer.begin());\n-    parser::parse_fragment(&mut token_source, &mut tree_sink, fragment_kind);\n+    parser::parse(&mut token_source, &mut tree_sink, entry_point);\n     if tree_sink.roots.len() != 1 {\n         return Err(ExpandError::ConversionError);\n     }\n@@ -100,7 +100,7 @@ pub fn parse_exprs_with_sep(tt: &tt::Subtree, sep: char) -> Vec<tt::Subtree> {\n     let mut res = Vec::new();\n \n     while iter.peek_n(0).is_some() {\n-        let expanded = iter.expect_fragment(FragmentKind::Expr);\n+        let expanded = iter.expect_fragment(ParserEntryPoint::Expr);\n         if expanded.err.is_some() {\n             break;\n         }\n@@ -790,7 +790,7 @@ mod tests {\n             \"#,\n         )\n         .expand_tt(\"stmts!();\");\n-        assert!(token_tree_to_syntax_node(&expansion, FragmentKind::Expr).is_err());\n+        assert!(token_tree_to_syntax_node(&expansion, ParserEntryPoint::Expr).is_err());\n     }\n \n     #[test]\n@@ -823,7 +823,7 @@ mod tests {\n         let source_file = ast::SourceFile::parse(\"struct Foo { a: x::Y }\").ok().unwrap();\n         let struct_def = source_file.syntax().descendants().find_map(ast::Struct::cast).unwrap();\n         let tt = syntax_node_to_token_tree(struct_def.syntax()).0;\n-        token_tree_to_syntax_node(&tt, FragmentKind::Item).unwrap();\n+        token_tree_to_syntax_node(&tt, ParserEntryPoint::Item).unwrap();\n     }\n \n     #[test]"}, {"sha": "0b80c8f3ae9746500930bfc8416d0587897467ba", "filename": "crates/mbe/src/tests.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fmbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fmbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests.rs?ref=0b4bff93fa650b122634389a3ac041f478c79dc5", "patch": "@@ -6,7 +6,7 @@ use std::fmt::Write;\n use syntax::{ast, AstNode, NodeOrToken, SyntaxNode, WalkEvent};\n use test_utils::assert_eq_text;\n \n-use crate::FragmentKind;\n+use crate::ParserEntryPoint;\n \n use super::*;\n \n@@ -44,13 +44,16 @@ macro_rules! impl_fixture {\n             #[allow(unused)]\n             fn expand_items(&self, invocation: &str) -> SyntaxNode {\n                 let expanded = self.expand_tt(invocation);\n-                token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap().0.syntax_node()\n+                token_tree_to_syntax_node(&expanded, ParserEntryPoint::Items)\n+                    .unwrap()\n+                    .0\n+                    .syntax_node()\n             }\n \n             #[allow(unused)]\n             fn expand_statements(&self, invocation: &str) -> SyntaxNode {\n                 let expanded = self.expand_tt(invocation);\n-                token_tree_to_syntax_node(&expanded, FragmentKind::Statements)\n+                token_tree_to_syntax_node(&expanded, ParserEntryPoint::Statements)\n                     .unwrap()\n                     .0\n                     .syntax_node()\n@@ -59,7 +62,10 @@ macro_rules! impl_fixture {\n             #[allow(unused)]\n             fn expand_expr(&self, invocation: &str) -> SyntaxNode {\n                 let expanded = self.expand_tt(invocation);\n-                token_tree_to_syntax_node(&expanded, FragmentKind::Expr).unwrap().0.syntax_node()\n+                token_tree_to_syntax_node(&expanded, ParserEntryPoint::Expr)\n+                    .unwrap()\n+                    .0\n+                    .syntax_node()\n             }\n \n             #[allow(unused)]\n@@ -76,17 +82,17 @@ macro_rules! impl_fixture {\n             }\n \n             fn assert_expand_items(&self, invocation: &str, expected: &str) -> &$name {\n-                self.assert_expansion(FragmentKind::Items, invocation, expected);\n+                self.assert_expansion(ParserEntryPoint::Items, invocation, expected);\n                 self\n             }\n \n             #[allow(unused)]\n             fn assert_expand_statements(&self, invocation: &str, expected: &str) -> &$name {\n-                self.assert_expansion(FragmentKind::Statements, invocation, expected);\n+                self.assert_expansion(ParserEntryPoint::Statements, invocation, expected);\n                 self\n             }\n \n-            fn assert_expansion(&self, kind: FragmentKind, invocation: &str, expected: &str) {\n+            fn assert_expansion(&self, kind: ParserEntryPoint, invocation: &str, expected: &str) {\n                 let expanded = self.expand_tt(invocation);\n                 assert_eq!(expanded.to_string(), expected);\n "}, {"sha": "eb2e2f6a503703fa1dc225ccf75adb0d58e8165c", "filename": "crates/mbe/src/tests/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs?ref=0b4bff93fa650b122634389a3ac041f478c79dc5", "patch": "@@ -1,4 +1,4 @@\n-use ::parser::FragmentKind;\n+use ::parser::ParserEntryPoint;\n use syntax::{\n     SyntaxKind::{ERROR, IDENT},\n     T,\n@@ -55,7 +55,7 @@ macro_rules! foobar {\n     )\n     .expand_tt(\"foobar!(baz);\");\n \n-    let (node, token_map) = token_tree_to_syntax_node(&expanded, FragmentKind::Items).unwrap();\n+    let (node, token_map) = token_tree_to_syntax_node(&expanded, ParserEntryPoint::Items).unwrap();\n     let content = node.syntax_node().to_string();\n \n     let get_text = |id, kind| -> String {"}, {"sha": "ff0272808b7c2eb68d3ca7779c38f2647cf4caaa", "filename": "crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=0b4bff93fa650b122634389a3ac041f478c79dc5", "patch": "@@ -1,7 +1,7 @@\n //! A \"Parser\" structure for token trees. We use this when parsing a declarative\n //! macro definition into a list of patterns and templates.\n \n-use crate::{subtree_source::SubtreeTokenSource, ExpandError, ExpandResult};\n+use crate::{subtree_source::SubtreeTokenSource, ExpandError, ExpandResult, ParserEntryPoint};\n \n use parser::TreeSink;\n use syntax::SyntaxKind;\n@@ -92,7 +92,7 @@ impl<'a> TtIter<'a> {\n \n     pub(crate) fn expect_fragment(\n         &mut self,\n-        fragment_kind: parser::FragmentKind,\n+        entry_point: ParserEntryPoint,\n     ) -> ExpandResult<Option<tt::TokenTree>> {\n         struct OffsetTokenSink<'a> {\n             cursor: Cursor<'a>,\n@@ -119,10 +119,10 @@ impl<'a> TtIter<'a> {\n         let mut src = SubtreeTokenSource::new(&buffer);\n         let mut sink = OffsetTokenSink { cursor: buffer.begin(), error: false };\n \n-        parser::parse_fragment(&mut src, &mut sink, fragment_kind);\n+        parser::parse(&mut src, &mut sink, entry_point);\n \n         let mut err = if !sink.cursor.is_root() || sink.error {\n-            Some(err!(\"expected {:?}\", fragment_kind))\n+            Some(err!(\"expected {:?}\", entry_point))\n         } else {\n             None\n         };"}, {"sha": "cc23bff667f0e7757845bdfcc163d1b783a24b97", "filename": "crates/parser/src/grammar.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar.rs?ref=0b4bff93fa650b122634389a3ac041f478c79dc5", "patch": "@@ -44,20 +44,23 @@ use crate::{\n     TokenSet,\n };\n \n-pub(crate) fn root(p: &mut Parser) {\n-    let m = p.start();\n-    p.eat(SHEBANG);\n-    items::mod_contents(p, false);\n-    m.complete(p, SOURCE_FILE);\n-}\n-\n-/// Various pieces of syntax that can be parsed by macros by example\n-pub(crate) mod fragments {\n+pub(crate) mod entry_points {\n     use super::*;\n \n-    pub(crate) use super::{\n-        expressions::block_expr, paths::type_path as path, patterns::pattern_single, types::type_,\n-    };\n+    pub(crate) fn source_file(p: &mut Parser) {\n+        let m = p.start();\n+        p.eat(SHEBANG);\n+        items::mod_contents(p, false);\n+        m.complete(p, SOURCE_FILE);\n+    }\n+\n+    pub(crate) use expressions::block_expr;\n+\n+    pub(crate) use paths::type_path as path;\n+\n+    pub(crate) use patterns::pattern_single as pattern;\n+\n+    pub(crate) use types::type_;\n \n     pub(crate) fn expr(p: &mut Parser) {\n         let _ = expressions::expr_with_attrs(p);\n@@ -71,8 +74,8 @@ pub(crate) mod fragments {\n         expressions::stmt(p, expressions::StmtWithSemi::Optional, false)\n     }\n \n-    pub(crate) fn opt_visibility(p: &mut Parser) {\n-        let _ = super::opt_visibility(p);\n+    pub(crate) fn visibility(p: &mut Parser) {\n+        let _ = opt_visibility(p);\n     }\n \n     // Parse a meta item , which excluded [], e.g : #[ MetaItem ]"}, {"sha": "53fec552f83e4061065672dc860f20715dc0164f", "filename": "crates/parser/src/lib.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fparser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fparser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flib.rs?ref=0b4bff93fa650b122634389a3ac041f478c79dc5", "patch": "@@ -71,23 +71,13 @@ pub trait TreeSink {\n     fn error(&mut self, error: ParseError);\n }\n \n-fn parse_from_tokens<F>(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink, f: F)\n-where\n-    F: FnOnce(&mut parser::Parser),\n-{\n-    let mut p = parser::Parser::new(token_source);\n-    f(&mut p);\n-    let events = p.finish();\n-    event::process(tree_sink, events);\n-}\n-\n-/// Parse given tokens into the given sink as a rust file.\n-pub fn parse(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::root);\n-}\n-\n+/// rust-analyzer parser allows you to choose one of the possible entry points.\n+///\n+/// The primary consumer of this API are declarative macros, `$x:expr` matchers\n+/// are implemented by calling into the parser with non-standard entry point.\n #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n-pub enum FragmentKind {\n+pub enum ParserEntryPoint {\n+    SourceFile,\n     Path,\n     Expr,\n     Statement,\n@@ -103,27 +93,37 @@ pub enum FragmentKind {\n     Attr,\n }\n \n-pub fn parse_fragment(\n+/// Parse given tokens into the given sink as a rust file.\n+pub fn parse_source_file(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n+    parse(token_source, tree_sink, ParserEntryPoint::SourceFile);\n+}\n+\n+pub fn parse(\n     token_source: &mut dyn TokenSource,\n     tree_sink: &mut dyn TreeSink,\n-    fragment_kind: FragmentKind,\n+    entry_point: ParserEntryPoint,\n ) {\n-    let parser: fn(&'_ mut parser::Parser) = match fragment_kind {\n-        FragmentKind::Path => grammar::fragments::path,\n-        FragmentKind::Expr => grammar::fragments::expr,\n-        FragmentKind::Type => grammar::fragments::type_,\n-        FragmentKind::Pattern => grammar::fragments::pattern_single,\n-        FragmentKind::Item => grammar::fragments::item,\n-        FragmentKind::Block => grammar::fragments::block_expr,\n-        FragmentKind::Visibility => grammar::fragments::opt_visibility,\n-        FragmentKind::MetaItem => grammar::fragments::meta_item,\n-        FragmentKind::Statement => grammar::fragments::stmt,\n-        FragmentKind::StatementOptionalSemi => grammar::fragments::stmt_optional_semi,\n-        FragmentKind::Items => grammar::fragments::macro_items,\n-        FragmentKind::Statements => grammar::fragments::macro_stmts,\n-        FragmentKind::Attr => grammar::fragments::attr,\n+    let entry_point: fn(&'_ mut parser::Parser) = match entry_point {\n+        ParserEntryPoint::SourceFile => grammar::entry_points::source_file,\n+        ParserEntryPoint::Path => grammar::entry_points::path,\n+        ParserEntryPoint::Expr => grammar::entry_points::expr,\n+        ParserEntryPoint::Type => grammar::entry_points::type_,\n+        ParserEntryPoint::Pattern => grammar::entry_points::pattern,\n+        ParserEntryPoint::Item => grammar::entry_points::item,\n+        ParserEntryPoint::Block => grammar::entry_points::block_expr,\n+        ParserEntryPoint::Visibility => grammar::entry_points::visibility,\n+        ParserEntryPoint::MetaItem => grammar::entry_points::meta_item,\n+        ParserEntryPoint::Statement => grammar::entry_points::stmt,\n+        ParserEntryPoint::StatementOptionalSemi => grammar::entry_points::stmt_optional_semi,\n+        ParserEntryPoint::Items => grammar::entry_points::macro_items,\n+        ParserEntryPoint::Statements => grammar::entry_points::macro_stmts,\n+        ParserEntryPoint::Attr => grammar::entry_points::attr,\n     };\n-    parse_from_tokens(token_source, tree_sink, parser)\n+\n+    let mut p = parser::Parser::new(token_source);\n+    entry_point(&mut p);\n+    let events = p.finish();\n+    event::process(tree_sink, events);\n }\n \n /// A parsing function for a specific braced-block."}, {"sha": "c79742d8efb3ea2c4dde471fa067244569a6a0a9", "filename": "crates/syntax/src/lib.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fsyntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fsyntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Flib.rs?ref=0b4bff93fa650b122634389a3ac041f478c79dc5", "patch": "@@ -173,52 +173,58 @@ impl SourceFile {\n     }\n }\n \n+// FIXME: `parse` functions shouldn't hang directly from AST nodes, and they\n+// shouldn't return `Result`.\n+//\n+// We need a dedicated module for parser entry points, and they should always\n+// return `Parse`.\n+\n impl ast::Path {\n     /// Returns `text`, parsed as a path, but only if it has no errors.\n     pub fn parse(text: &str) -> Result<Self, ()> {\n-        parsing::parse_text_fragment(text, parser::FragmentKind::Path)\n+        parsing::parse_text_as(text, parser::ParserEntryPoint::Path)\n     }\n }\n \n impl ast::Pat {\n     /// Returns `text`, parsed as a pattern, but only if it has no errors.\n     pub fn parse(text: &str) -> Result<Self, ()> {\n-        parsing::parse_text_fragment(text, parser::FragmentKind::Pattern)\n+        parsing::parse_text_as(text, parser::ParserEntryPoint::Pattern)\n     }\n }\n \n impl ast::Expr {\n     /// Returns `text`, parsed as an expression, but only if it has no errors.\n     pub fn parse(text: &str) -> Result<Self, ()> {\n-        parsing::parse_text_fragment(text, parser::FragmentKind::Expr)\n+        parsing::parse_text_as(text, parser::ParserEntryPoint::Expr)\n     }\n }\n \n impl ast::Item {\n     /// Returns `text`, parsed as an item, but only if it has no errors.\n     pub fn parse(text: &str) -> Result<Self, ()> {\n-        parsing::parse_text_fragment(text, parser::FragmentKind::Item)\n+        parsing::parse_text_as(text, parser::ParserEntryPoint::Item)\n     }\n }\n \n impl ast::Type {\n     /// Returns `text`, parsed as an type reference, but only if it has no errors.\n     pub fn parse(text: &str) -> Result<Self, ()> {\n-        parsing::parse_text_fragment(text, parser::FragmentKind::Type)\n+        parsing::parse_text_as(text, parser::ParserEntryPoint::Type)\n     }\n }\n \n impl ast::Attr {\n     /// Returns `text`, parsed as an attribute, but only if it has no errors.\n     pub fn parse(text: &str) -> Result<Self, ()> {\n-        parsing::parse_text_fragment(text, parser::FragmentKind::Attr)\n+        parsing::parse_text_as(text, parser::ParserEntryPoint::Attr)\n     }\n }\n \n impl ast::Stmt {\n     /// Returns `text`, parsed as statement, but only if it has no errors.\n     pub fn parse(text: &str) -> Result<Self, ()> {\n-        parsing::parse_text_fragment(text, parser::FragmentKind::StatementOptionalSemi)\n+        parsing::parse_text_as(text, parser::ParserEntryPoint::StatementOptionalSemi)\n     }\n }\n "}, {"sha": "a45f262877e8bf235f682c924c18f6a2e7d9cde2", "filename": "crates/syntax/src/parsing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fsyntax%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4bff93fa650b122634389a3ac041f478c79dc5/crates%2Fsyntax%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fparsing.rs?ref=0b4bff93fa650b122634389a3ac041f478c79dc5", "patch": "@@ -20,7 +20,7 @@ pub(crate) fn parse_text(text: &str) -> (GreenNode, Vec<SyntaxError>) {\n     let mut token_source = TextTokenSource::new(text, &tokens);\n     let mut tree_sink = TextTreeSink::new(text, &tokens);\n \n-    parser::parse(&mut token_source, &mut tree_sink);\n+    parser::parse_source_file(&mut token_source, &mut tree_sink);\n \n     let (tree, mut parser_errors) = tree_sink.finish();\n     parser_errors.extend(lexer_errors);\n@@ -29,9 +29,9 @@ pub(crate) fn parse_text(text: &str) -> (GreenNode, Vec<SyntaxError>) {\n }\n \n /// Returns `text` parsed as a `T` provided there are no parse errors.\n-pub(crate) fn parse_text_fragment<T: AstNode>(\n+pub(crate) fn parse_text_as<T: AstNode>(\n     text: &str,\n-    fragment_kind: parser::FragmentKind,\n+    entry_point: parser::ParserEntryPoint,\n ) -> Result<T, ()> {\n     let (tokens, lexer_errors) = tokenize(text);\n     if !lexer_errors.is_empty() {\n@@ -45,7 +45,7 @@ pub(crate) fn parse_text_fragment<T: AstNode>(\n     // tokens. We arbitrarily give it a SourceFile.\n     use parser::TreeSink;\n     tree_sink.start_node(SyntaxKind::SOURCE_FILE);\n-    parser::parse_fragment(&mut token_source, &mut tree_sink, fragment_kind);\n+    parser::parse(&mut token_source, &mut tree_sink, entry_point);\n     tree_sink.finish_node();\n \n     let (tree, parser_errors) = tree_sink.finish();"}]}