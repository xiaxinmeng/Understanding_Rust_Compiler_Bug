{"sha": "a46db484abcdd517c0116301c77364e8e1c373af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0NmRiNDg0YWJjZGQ1MTdjMDExNjMwMWM3NzM2NGU4ZTFjMzczYWY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-10T00:12:34Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-10T00:12:34Z"}, "message": "Copyedit first two sections of borrowed pointer tutorial", "tree": {"sha": "7ff90ffb884f9d923f94b515d2202628c9d48c18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ff90ffb884f9d923f94b515d2202628c9d48c18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a46db484abcdd517c0116301c77364e8e1c373af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a46db484abcdd517c0116301c77364e8e1c373af", "html_url": "https://github.com/rust-lang/rust/commit/a46db484abcdd517c0116301c77364e8e1c373af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a46db484abcdd517c0116301c77364e8e1c373af/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd6f24f9d14ac90d167386a56e7a6ac1f0318195", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6f24f9d14ac90d167386a56e7a6ac1f0318195", "html_url": "https://github.com/rust-lang/rust/commit/cd6f24f9d14ac90d167386a56e7a6ac1f0318195"}], "stats": {"total": 98, "additions": 49, "deletions": 49}, "files": [{"sha": "0ca6045b79f752f8e19ec01d2f6eddfd0a37a90f", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a46db484abcdd517c0116301c77364e8e1c373af/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/a46db484abcdd517c0116301c77364e8e1c373af/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=a46db484abcdd517c0116301c77364e8e1c373af", "patch": "@@ -2,40 +2,40 @@\n \n # Introduction\n \n-Borrowed pointers are one of the more flexible and powerful tools\n-available in Rust. A borrowed pointer can be used to point anywhere:\n-into the managed and exchange heaps, into the stack, and even into the\n-interior of another data structure. With regard to flexibility, it is\n-comparable to a C pointer or C++ reference. However, unlike C and C++,\n-the Rust compiler includes special checks that ensure that borrowed\n-pointers are being used safely. Another advantage of borrowed pointers\n-is that they are invisible to the garbage collector, so working with\n-borrowed pointers helps keep things efficient.\n-\n-Despite the fact that they are completely safe, at runtime, a borrowed\n-pointer is \u201cjust a pointer\u201d. They introduce zero overhead. All safety\n-checks are done at compilation time.\n+Borrowed pointers are one of the more flexible and powerful tools available in\n+Rust. A borrowed pointer can point anywhere: into the managed or exchange\n+heap, into the stack, and even into the interior of another data structure. A\n+borrowed pointer is as flexible as a C pointer or C++ reference. However,\n+unlike C and C++ compilers, the Rust compiler includes special static checks\n+that ensure that programs use borrowed pointers safely. Another advantage of\n+borrowed pointers is that they are invisible to the garbage collector, so\n+working with borrowed pointers helps reduce the overhead of automatic memory\n+management.\n+\n+Despite their complete safety, a borrowed pointer's representation at runtime\n+is the same as that of an ordinary pointer in a C program. They introduce zero\n+overhead. The compiler does all safety checks at compile time.\n \n Although borrowed pointers have rather elaborate theoretical\n underpinnings (region pointers), the core concepts will be familiar to\n-anyone who worked with C or C++. Therefore, the best way to explain\n+anyone who has worked with C or C++. Therefore, the best way to explain\n how they are used\u2014and their limitations\u2014is probably just to work\n through several examples.\n \n # By example\n \n-Borrowed pointers are called borrowed because they are only valid for\n-a limit duration. Borrowed pointers never claim any kind of ownership\n-over the data that they point at: instead, they are used for cases\n-where you like to make use of data for a short time.\n+Borrowed pointers are called *borrowed* because they are only valid for\n+a limited duration. Borrowed pointers never claim any kind of ownership\n+over the data that they point to: instead, they are used for cases\n+where you would like to use data for a short time.\n \n As an example, consider a simple struct type `Point`:\n \n ~~~\n struct Point {x: float, y: float}\n ~~~\n \n-We can use this simple definition to allocate points in many ways. For\n+We can use this simple definition to allocate points in many different ways. For\n example, in this code, each of these three local variables contains a\n point, but allocated in a different place:\n \n@@ -46,17 +46,17 @@ let shared_box   : @Point = @Point {x: 5.0, y: 1.0};\n let unique_box   : ~Point = ~Point {x: 7.0, y: 9.0};\n ~~~\n \n-Suppose we wanted to write a procedure that computed the distance\n-between any two points, no matter where they were stored. For example,\n-we might like to compute the distance between `on_the_stack` and\n-`shared_box`, or between `shared_box` and `unique_box`. One option is\n-to define a function that takes two arguments of type point\u2014that is,\n-it takes the points by value. But this will cause the points to be\n-copied when we call the function. For points, this is probably not so\n-bad, but often copies are expensive or, worse, if there are mutable\n-fields, they can change the semantics of your program. So we\u2019d like to\n-define a function that takes the points by pointer. We can use\n-borrowed pointers to do this:\n+Suppose we wanted to write a procedure that computed the distance between any\n+two points, no matter where they were stored. For example, we might like to\n+compute the distance between `on_the_stack` and `shared_box`, or between\n+`shared_box` and `unique_box`. One option is to define a function that takes\n+two arguments of type `Point`\u2014that is, it takes the points by value. But we\n+define it this way, calling the function will cause the points to be\n+copied. For points, this is probably not so bad, but often copies are\n+expensive. Worse, if the data type contains mutable fields, copying can change\n+the semantics of your program in unexpected ways. So we'd like to define a\n+function that takes the points by pointer. We can use borrowed pointers to do\n+this:\n \n ~~~\n # struct Point {x: float, y: float}\n@@ -80,28 +80,28 @@ compute_distance(&on_the_stack, shared_box);\n compute_distance(shared_box, unique_box);\n ~~~\n \n-Here the `&` operator is used to take the address of the variable\n+Here, the `&` operator takes the address of the variable\n `on_the_stack`; this is because `on_the_stack` has the type `Point`\n (that is, a struct value) and we have to take its address to get a\n value. We also call this _borrowing_ the local variable\n-`on_the_stack`, because we are created an alias: that is, another\n-route to the same data.\n-\n-In the case of the boxes `shared_box` and `unique_box`, however, no\n-explicit action is necessary. The compiler will automatically convert\n-a box like `@Point` or `~Point` to a borrowed pointer like\n-`&Point`. This is another form of borrowing; in this case, the\n-contents of the shared/unique box is being lent out.\n-\n-Whenever a value is borrowed, there are some limitations on what you\n-can do with the original. For example, if the contents of a variable\n-have been lent out, you cannot send that variable to another task, nor\n-will you be permitted to take actions that might cause the borrowed\n-value to be freed or to change its type (I\u2019ll get into what kinds of\n-actions those are shortly). This rule should make intuitive sense: you\n-must wait for a borrowed value to be returned (that is, for the\n-borrowed pointer to go out of scope) before you can make full use of\n-it again.\n+`on_the_stack`, because we have created an alias: that is, another\n+name for the same data.\n+\n+In contrast, we can pass the boxes `shared_box` and `unique_box` to\n+`compute_distance` directly. The compiler automatically converts a box like\n+`@Point` or `~Point` to a borrowed pointer like `&Point`. This is another form\n+of borrowing: in this case, the caller lends the contents of the shared or\n+unique box to the callee.\n+\n+Whenever a caller lends data to a callee, there are some limitations on what\n+the caller can do with the original. For example, if the contents of a\n+variable have been lent out, you cannot send that variable to another task. In\n+addition, the compiler will reject any code that might cause the borrowed\n+value to be freed or overwrite its component fields with values of different\n+types (I'll get into what kinds of actions those are shortly). This rule\n+should make intuitive sense: you must wait for a borrower to return the value\n+that you lent it (that is, wait for the borrowed pointer to go out of scope)\n+before you can make full use of it again.\n \n # Other uses for the & operator\n "}]}