{"sha": "753ea76336be2def223335c63d7b20188651a8c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1M2VhNzYzMzZiZTJkZWYyMjMzMzVjNjNkN2IyMDE4ODY1MWE4YzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-18T08:49:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-18T08:49:13Z"}, "message": "Auto merge of #37083 - nnethercote:uleb128, r=eddyb\n\nInline read_{un,}signed_leb128 and opaque::Decoder functions.\n\n`read_unsigned_leb128` is hot within rustc because it's heavily used\nduring the reading of crate metadata. This commit tweaks its signature\n(and that of `read_signed_leb128`, for consistency) so it can increment\nthe buffer index directly instead of maintaining its own copy, the\nchange in which is then used by the caller to advance the index.\n\nThis reduces the instruction count (as measured by Cachegrind) for some\nbenchmarks a bit, e.g. hyper-0.5.0 by 0.7%.", "tree": {"sha": "63e0870a006829ad7ad8348c3389013524334f36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63e0870a006829ad7ad8348c3389013524334f36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/753ea76336be2def223335c63d7b20188651a8c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/753ea76336be2def223335c63d7b20188651a8c6", "html_url": "https://github.com/rust-lang/rust/commit/753ea76336be2def223335c63d7b20188651a8c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/753ea76336be2def223335c63d7b20188651a8c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3543a0f6020fb16860f471e8651fa05f5709e83a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3543a0f6020fb16860f471e8651fa05f5709e83a", "html_url": "https://github.com/rust-lang/rust/commit/3543a0f6020fb16860f471e8651fa05f5709e83a"}, {"sha": "6a4bb35b70862f33ac2491ffe6c55fb210c8490d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a4bb35b70862f33ac2491ffe6c55fb210c8490d", "html_url": "https://github.com/rust-lang/rust/commit/6a4bb35b70862f33ac2491ffe6c55fb210c8490d"}], "stats": {"total": 18, "additions": 18, "deletions": 0}, "files": [{"sha": "8e8e03f1f8ebb1586d0c988f0b719c9d1f134349", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753ea76336be2def223335c63d7b20188651a8c6/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753ea76336be2def223335c63d7b20188651a8c6/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=753ea76336be2def223335c63d7b20188651a8c6", "patch": "@@ -38,6 +38,7 @@ pub fn write_unsigned_leb128(out: &mut Vec<u8>, start_position: usize, mut value\n     return position - start_position;\n }\n \n+#[inline]\n pub fn read_unsigned_leb128(data: &[u8], start_position: usize) -> (u64, usize) {\n     let mut result = 0;\n     let mut shift = 0;\n@@ -78,6 +79,7 @@ pub fn write_signed_leb128(out: &mut Vec<u8>, start_position: usize, mut value:\n     return position - start_position;\n }\n \n+#[inline]\n pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i64, usize) {\n     let mut result = 0;\n     let mut shift = 0;"}, {"sha": "87b6ed2ed403cae28a74e2eeaec12597ac1abc5c", "filename": "src/libserialize/opaque.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/753ea76336be2def223335c63d7b20188651a8c6/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753ea76336be2def223335c63d7b20188651a8c6/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=753ea76336be2def223335c63d7b20188651a8c6", "patch": "@@ -179,74 +179,90 @@ macro_rules! read_sleb128 {\n impl<'a> serialize::Decoder for Decoder<'a> {\n     type Error = String;\n \n+    #[inline]\n     fn read_nil(&mut self) -> Result<(), Self::Error> {\n         Ok(())\n     }\n \n+    #[inline]\n     fn read_u64(&mut self) -> Result<u64, Self::Error> {\n         read_uleb128!(self, u64)\n     }\n \n+    #[inline]\n     fn read_u32(&mut self) -> Result<u32, Self::Error> {\n         read_uleb128!(self, u32)\n     }\n \n+    #[inline]\n     fn read_u16(&mut self) -> Result<u16, Self::Error> {\n         read_uleb128!(self, u16)\n     }\n \n+    #[inline]\n     fn read_u8(&mut self) -> Result<u8, Self::Error> {\n         let value = self.data[self.position];\n         self.position += 1;\n         Ok(value)\n     }\n \n+    #[inline]\n     fn read_usize(&mut self) -> Result<usize, Self::Error> {\n         read_uleb128!(self, usize)\n     }\n \n+    #[inline]\n     fn read_i64(&mut self) -> Result<i64, Self::Error> {\n         read_sleb128!(self, i64)\n     }\n \n+    #[inline]\n     fn read_i32(&mut self) -> Result<i32, Self::Error> {\n         read_sleb128!(self, i32)\n     }\n \n+    #[inline]\n     fn read_i16(&mut self) -> Result<i16, Self::Error> {\n         read_sleb128!(self, i16)\n     }\n \n+    #[inline]\n     fn read_i8(&mut self) -> Result<i8, Self::Error> {\n         let as_u8 = self.data[self.position];\n         self.position += 1;\n         unsafe { Ok(::std::mem::transmute(as_u8)) }\n     }\n \n+    #[inline]\n     fn read_isize(&mut self) -> Result<isize, Self::Error> {\n         read_sleb128!(self, isize)\n     }\n \n+    #[inline]\n     fn read_bool(&mut self) -> Result<bool, Self::Error> {\n         let value = self.read_u8()?;\n         Ok(value != 0)\n     }\n \n+    #[inline]\n     fn read_f64(&mut self) -> Result<f64, Self::Error> {\n         let bits = self.read_u64()?;\n         Ok(unsafe { ::std::mem::transmute(bits) })\n     }\n \n+    #[inline]\n     fn read_f32(&mut self) -> Result<f32, Self::Error> {\n         let bits = self.read_u32()?;\n         Ok(unsafe { ::std::mem::transmute(bits) })\n     }\n \n+    #[inline]\n     fn read_char(&mut self) -> Result<char, Self::Error> {\n         let bits = self.read_u32()?;\n         Ok(::std::char::from_u32(bits).unwrap())\n     }\n \n+    #[inline]\n     fn read_str(&mut self) -> Result<Cow<str>, Self::Error> {\n         let len = self.read_usize()?;\n         let s = ::std::str::from_utf8(&self.data[self.position..self.position + len]).unwrap();"}]}