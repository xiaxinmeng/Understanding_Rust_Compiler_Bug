{"sha": "a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7", "node_id": "C_kwDOAAsO6NoAKGEzYzk2NWY1ZmViNWRkMWI1MGVmOGMwZDFjNTRkNjI0ZmQxMGUzYTc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-29T04:34:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-29T04:34:45Z"}, "message": "Rollup merge of #100843 - IntQuant:issue-100717-infer, r=compiler-errors\n\nMigrate part of rustc_infer to session diagnostic", "tree": {"sha": "af5c08409102c7554761e816daa5b6b65e174425", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af5c08409102c7554761e816daa5b6b65e174425"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDEHlCRBK7hj4Ov3rIwAARSkIAHwDl6JKCI1lzgOtmrB+fn/M\nd5h0AKGGzwdEonvatMVBcHbcDfkU8bFsJ2x+Xsri4dVcSWe5L+txVylb35F4yOm/\n/csWIR016/UEwmLUwb7SigT2ca3Fk67IsXhkMZHQbxJgQie+Ug7M9+bZRoq3hMkd\nzAUGRij7iVqAGjR677zYVCIA0IgT9Ero8XJIuUwavtnX4hN0F+9r44KtmEn6/fVN\nLNyfhcc69q6SWzbRPUZsU91gnYTdJNODZIzxCrx7dkAh/NM2aLH6t+5vU5l9yqyY\nDcBsEWLdmElNutpVRXcQyePbtwA36IfQOgBig+U9qQavn7xJu7JMgpeXUmfV8/0=\n=ibJn\n-----END PGP SIGNATURE-----\n", "payload": "tree af5c08409102c7554761e816daa5b6b65e174425\nparent 26c86c69931b44732b1554033ba54700f0930060\nparent e1765a9c56d8d9b235bc5b8fda2a0f1d4e92ff49\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661747685 +0200\ncommitter GitHub <noreply@github.com> 1661747685 +0200\n\nRollup merge of #100843 - IntQuant:issue-100717-infer, r=compiler-errors\n\nMigrate part of rustc_infer to session diagnostic\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7", "html_url": "https://github.com/rust-lang/rust/commit/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26c86c69931b44732b1554033ba54700f0930060", "url": "https://api.github.com/repos/rust-lang/rust/commits/26c86c69931b44732b1554033ba54700f0930060", "html_url": "https://github.com/rust-lang/rust/commit/26c86c69931b44732b1554033ba54700f0930060"}, {"sha": "e1765a9c56d8d9b235bc5b8fda2a0f1d4e92ff49", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1765a9c56d8d9b235bc5b8fda2a0f1d4e92ff49", "html_url": "https://github.com/rust-lang/rust/commit/e1765a9c56d8d9b235bc5b8fda2a0f1d4e92ff49"}], "stats": {"total": 861, "additions": 649, "deletions": 212}, "files": [{"sha": "7c3879fdd98d41c25ab8be243218d8ea1980a5b9", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7", "patch": "@@ -3631,6 +3631,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\","}, {"sha": "60086cd6e477f430bff9432081f32af0d7583b40", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7", "patch": "@@ -0,0 +1,112 @@\n+infer_opaque_hidden_type =\n+    opaque type's hidden type cannot be another opaque type from the same scope\n+    .label = one of the two opaque types used here has to be outside its defining scope\n+    .opaque_type = opaque type whose hidden type is being assigned\n+    .hidden_type = opaque type being used as hidden type\n+\n+infer_type_annotations_needed = {$source_kind ->\n+    [closure] type annotations needed for the closure `{$source_name}`\n+    [normal] type annotations needed for `{$source_name}`\n+    *[other] type annotations needed\n+}\n+    .label = type must be known at this point\n+\n+infer_label_bad = {$bad_kind ->\n+    *[other] cannot infer type\n+    [more_info] cannot infer {$prefix_kind ->\n+        *[type] type for {$prefix}\n+        [const_with_param] the value of const parameter\n+        [const] the value of the constant\n+    } `{$name}`{$has_parent ->\n+        [true] {\" \"}declared on the {$parent_prefix} `{$parent_name}`\n+        *[false] {\"\"}\n+    }\n+}\n+\n+infer_source_kind_subdiag_let = {$kind ->\n+    [with_pattern] consider giving `{$name}` an explicit type\n+    [closure] consider giving this closure parameter an explicit type\n+    *[other] consider giving this pattern a type\n+}{$x_kind ->\n+    [has_name] , where the {$prefix_kind ->\n+        *[type] type for {$prefix}\n+        [const_with_param] the value of const parameter\n+        [const] the value of the constant\n+    } `{$arg_name}` is specified\n+    [underscore] , where the placeholders `_` are specified\n+    *[empty] {\"\"}\n+}\n+\n+infer_source_kind_subdiag_generic_label =\n+    cannot infer {$is_type ->\n+    [true] type\n+    *[false] the value\n+    } of the {$is_type ->\n+    [true] type\n+    *[false] const\n+    } {$parent_exists ->\n+    [true] parameter `{$param_name}` declared on the {$parent_prefix} `{$parent_name}`\n+    *[false] parameter {$param_name}\n+    }\n+\n+infer_source_kind_subdiag_generic_suggestion =\n+    consider specifying the generic {$arg_count ->\n+    [one] argument\n+    *[other] arguments\n+    }\n+\n+infer_source_kind_fully_qualified =\n+    try using a fully qualified path to specify the expected types\n+\n+infer_source_kind_closure_return =\n+    try giving this closure an explicit return type\n+\n+# generator_kind  may need to be translated\n+infer_need_type_info_in_generator =\n+    type inside {$generator_kind ->\n+    [async_block] `async` block\n+    [async_closure] `async` closure\n+    [async_fn] `async fn` body\n+    *[generator] generator\n+    } must be known in this context\n+\n+\n+infer_subtype = ...so that the {$requirement ->\n+    [method_compat] method type is compatible with trait\n+    [type_compat] associated type is compatible with trait\n+    [const_compat] const is compatible with trait\n+    [expr_assignable] expression is assignable\n+    [if_else_different] `if` and `else` have incompatible types\n+    [no_else] `if` missing an `else` returns `()`\n+    [fn_main_correct_type] `main` function has the correct type\n+    [fn_start_correct_type] #[start]` function has the correct type\n+    [intristic_correct_type] intrinsic has the correct type\n+    [method_correct_type] method receiver has the correct type\n+    *[other] types are compatible\n+}\n+infer_subtype_2 = ...so that {$requirement ->\n+    [method_compat] method type is compatible with trait\n+    [type_compat] associated type is compatible with trait\n+    [const_compat] const is compatible with trait\n+    [expr_assignable] expression is assignable\n+    [if_else_different] `if` and `else` have incompatible types\n+    [no_else] `if` missing an `else` returns `()`\n+    [fn_main_correct_type] `main` function has the correct type\n+    [fn_start_correct_type] #[start]` function has the correct type\n+    [intristic_correct_type] intrinsic has the correct type\n+    [method_correct_type] method receiver has the correct type\n+    *[other] types are compatible\n+}\n+\n+infer_reborrow = ...so that reference does not outlive borrowed content\n+infer_reborrow_upvar = ...so that closure can access `{$name}`\n+infer_relate_object_bound = ...so that it can be closed over into an object\n+infer_data_borrowed = ...so that the type `{$name}` is not borrowed for too long\n+infer_reference_outlives_referent = ...so that the reference type `{$name}` does not outlive the data it points at\n+infer_relate_param_bound = ...so that the type `{$name}` will meet its required lifetime bounds{$continues ->\n+[true] ...\n+*[false] {\"\"}\n+}\n+infer_relate_param_bound_2 = ...that is required by this bound\n+infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n+infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait"}, {"sha": "b17668dc0ae7718fd194f2931625483ced29ef5d", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7", "patch": "@@ -41,6 +41,7 @@ fluent_messages! {\n     driver => \"../locales/en-US/driver.ftl\",\n     expand => \"../locales/en-US/expand.ftl\",\n     interface => \"../locales/en-US/interface.ftl\",\n+    infer => \"../locales/en-US/infer.ftl\",\n     lint => \"../locales/en-US/lint.ftl\",\n     parser => \"../locales/en-US/parser.ftl\",\n     passes => \"../locales/en-US/passes.ftl\","}, {"sha": "aced787d6711600ee0337b7ee4dd16a3c736973b", "filename": "compiler/rustc_infer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2FCargo.toml?ref=a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7", "patch": "@@ -15,6 +15,7 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "938f8aa77a5b4589f6e5eb2f5ed5956fce22ee8b", "filename": "compiler/rustc_infer/src/errors.rs", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs?ref=a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7", "patch": "@@ -0,0 +1,254 @@\n+use rustc_errors::{fluent, AddSubdiagnostic, DiagnosticMessage, DiagnosticStyledString};\n+use rustc_hir::FnRetTy;\n+use rustc_macros::SessionDiagnostic;\n+use rustc_span::{BytePos, Span};\n+\n+use crate::infer::error_reporting::{\n+    need_type_info::{GeneratorKindAsDiagArg, UnderspecifiedArgKind},\n+    ObligationCauseAsDiagArg,\n+};\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::opaque_hidden_type)]\n+pub struct OpaqueHiddenTypeDiag {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[note(infer::opaque_type)]\n+    pub opaque_type: Span,\n+    #[note(infer::hidden_type)]\n+    pub hidden_type: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0282\")]\n+pub struct AnnotationRequired<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+// Copy of `AnnotationRequired` for E0283\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0283\")]\n+pub struct AmbigousImpl<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+// Copy of `AnnotationRequired` for E0284\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0284\")]\n+pub struct AmbigousReturn<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::need_type_info_in_generator, code = \"E0698\")]\n+pub struct NeedTypeInfoInGenerator<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub generator_kind: GeneratorKindAsDiagArg,\n+    #[subdiagnostic]\n+    pub bad_label: InferenceBadError<'a>,\n+}\n+\n+// Used when a better one isn't available\n+#[derive(SessionSubdiagnostic)]\n+#[label(infer::label_bad)]\n+pub struct InferenceBadError<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub bad_kind: &'static str,\n+    pub prefix_kind: UnderspecifiedArgKind,\n+    pub has_parent: bool,\n+    pub prefix: &'a str,\n+    pub parent_prefix: &'a str,\n+    pub parent_name: String,\n+    pub name: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum SourceKindSubdiag<'a> {\n+    #[suggestion_verbose(\n+        infer::source_kind_subdiag_let,\n+        code = \": {type_name}\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    LetLike {\n+        #[primary_span]\n+        span: Span,\n+        name: String,\n+        type_name: String,\n+        kind: &'static str,\n+        x_kind: &'static str,\n+        prefix_kind: UnderspecifiedArgKind,\n+        prefix: &'a str,\n+        arg_name: String,\n+    },\n+    #[label(infer::source_kind_subdiag_generic_label)]\n+    GenericLabel {\n+        #[primary_span]\n+        span: Span,\n+        is_type: bool,\n+        param_name: String,\n+        parent_exists: bool,\n+        parent_prefix: String,\n+        parent_name: String,\n+    },\n+    #[suggestion_verbose(\n+        infer::source_kind_subdiag_generic_suggestion,\n+        code = \"::<{args}>\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    GenericSuggestion {\n+        #[primary_span]\n+        span: Span,\n+        arg_count: usize,\n+        args: String,\n+    },\n+}\n+\n+// Has to be implemented manually because multipart suggestions are not supported by the derive macro.\n+// Would be a part of `SourceKindSubdiag` otherwise.\n+pub enum SourceKindMultiSuggestion<'a> {\n+    FullyQualified {\n+        span: Span,\n+        def_path: String,\n+        adjustment: &'a str,\n+        successor: (&'a str, BytePos),\n+    },\n+    ClosureReturn {\n+        ty_info: String,\n+        data: &'a FnRetTy<'a>,\n+        should_wrap_expr: Option<Span>,\n+    },\n+}\n+\n+impl AddSubdiagnostic for SourceKindMultiSuggestion<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            Self::FullyQualified { span, def_path, adjustment, successor } => {\n+                let suggestion = vec![\n+                    (span.shrink_to_lo(), format!(\"{def_path}({adjustment}\")),\n+                    (span.shrink_to_hi().with_hi(successor.1), successor.0.to_string()),\n+                ];\n+                diag.multipart_suggestion_verbose(\n+                    fluent::infer::source_kind_fully_qualified,\n+                    suggestion,\n+                    rustc_errors::Applicability::HasPlaceholders,\n+                );\n+            }\n+            Self::ClosureReturn { ty_info, data, should_wrap_expr } => {\n+                let (arrow, post) = match data {\n+                    FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n+                    _ => (\"\", \"\"),\n+                };\n+                let suggestion = match should_wrap_expr {\n+                    Some(end_span) => vec![\n+                        (data.span(), format!(\"{}{}{}{{ \", arrow, ty_info, post)),\n+                        (end_span, \" }\".to_string()),\n+                    ],\n+                    None => vec![(data.span(), format!(\"{}{}{}\", arrow, ty_info, post))],\n+                };\n+                diag.multipart_suggestion_verbose(\n+                    fluent::infer::source_kind_closure_return,\n+                    suggestion,\n+                    rustc_errors::Applicability::HasPlaceholders,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+pub enum RegionOriginNote<'a> {\n+    Plain {\n+        span: Span,\n+        msg: DiagnosticMessage,\n+    },\n+    WithName {\n+        span: Span,\n+        msg: DiagnosticMessage,\n+        name: &'a str,\n+        continues: bool,\n+    },\n+    WithRequirement {\n+        span: Span,\n+        requirement: ObligationCauseAsDiagArg<'a>,\n+        expected_found: Option<(DiagnosticStyledString, DiagnosticStyledString)>,\n+    },\n+}\n+\n+impl AddSubdiagnostic for RegionOriginNote<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        let mut label_or_note = |span, msg: DiagnosticMessage| {\n+            let sub_count = diag.children.iter().filter(|d| d.span.is_dummy()).count();\n+            let expanded_sub_count = diag.children.iter().filter(|d| !d.span.is_dummy()).count();\n+            let span_is_primary = diag.span.primary_spans().iter().all(|&sp| sp == span);\n+            if span_is_primary && sub_count == 0 && expanded_sub_count == 0 {\n+                diag.span_label(span, msg);\n+            } else if span_is_primary && expanded_sub_count == 0 {\n+                diag.note(msg);\n+            } else {\n+                diag.span_note(span, msg);\n+            }\n+        };\n+        match self {\n+            RegionOriginNote::Plain { span, msg } => {\n+                label_or_note(span, msg);\n+            }\n+            RegionOriginNote::WithName { span, msg, name, continues } => {\n+                label_or_note(span, msg);\n+                diag.set_arg(\"name\", name);\n+                diag.set_arg(\"continues\", continues);\n+            }\n+            RegionOriginNote::WithRequirement {\n+                span,\n+                requirement,\n+                expected_found: Some((expected, found)),\n+            } => {\n+                label_or_note(span, fluent::infer::subtype);\n+                diag.set_arg(\"requirement\", requirement);\n+\n+                diag.note_expected_found(&\"\", expected, &\"\", found);\n+            }\n+            RegionOriginNote::WithRequirement { span, requirement, expected_found: None } => {\n+                // FIXME: this really should be handled at some earlier stage. Our\n+                // handling of region checking when type errors are present is\n+                // *terrible*.\n+                label_or_note(span, fluent::infer::subtype_2);\n+                diag.set_arg(\"requirement\", requirement);\n+            }\n+        };\n+    }\n+}"}, {"sha": "465508e12058f9ef9e5ab173b848a2ab6ab015d8", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7", "patch": "@@ -58,7 +58,7 @@ use crate::traits::{\n };\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed};\n+use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -78,7 +78,7 @@ use std::{cmp, fmt, iter};\n \n mod note;\n \n-mod need_type_info;\n+pub(crate) mod need_type_info;\n pub use need_type_info::TypeAnnotationNeeded;\n \n pub mod nice_region_error;\n@@ -2886,6 +2886,30 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n     }\n }\n \n+/// Newtype to allow implementing IntoDiagnosticArg\n+pub struct ObligationCauseAsDiagArg<'tcx>(pub ObligationCause<'tcx>);\n+\n+impl IntoDiagnosticArg for ObligationCauseAsDiagArg<'_> {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        use crate::traits::ObligationCauseCode::*;\n+        let kind = match self.0.code() {\n+            CompareImplItemObligation { kind: ty::AssocKind::Fn, .. } => \"method_compat\",\n+            CompareImplItemObligation { kind: ty::AssocKind::Type, .. } => \"type_compat\",\n+            CompareImplItemObligation { kind: ty::AssocKind::Const, .. } => \"const_compat\",\n+            ExprAssignable => \"expr_assignable\",\n+            IfExpression { .. } => \"if_else_different\",\n+            IfExpressionWithNoElse => \"no_else\",\n+            MainFunctionType => \"fn_main_correct_type\",\n+            StartFunctionType => \"fn_start_correct_type\",\n+            IntrinsicType => \"intristic_correct_type\",\n+            MethodReceiver => \"method_correct_type\",\n+            _ => \"other\",\n+        }\n+        .into();\n+        rustc_errors::DiagnosticArgValue::Str(kind)\n+    }\n+}\n+\n /// This is a bare signal of what kind of type we're dealing with. `ty::TyKind` tracks\n /// extra information about each type, but we only care about the category.\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "e990fe7ecb50427edb13538bd0a4a0b985cf7fa0", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 199, "deletions": 128, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7", "patch": "@@ -1,6 +1,10 @@\n+use crate::errors::{\n+    AmbigousImpl, AmbigousReturn, AnnotationRequired, InferenceBadError, NeedTypeInfoInGenerator,\n+    SourceKindMultiSuggestion, SourceKindSubdiag,\n+};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::InferCtxt;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def::{CtorOf, DefKind, Namespace};\n@@ -14,6 +18,7 @@ use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n use rustc_middle::ty::{self, DefIdTree, InferConst};\n use rustc_middle::ty::{IsSuggestable, Ty, TyCtxt, TypeckResults};\n+use rustc_session::SessionDiagnostic;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{BytePos, Span};\n use std::borrow::Cow;\n@@ -60,38 +65,49 @@ pub struct InferenceDiagnosticsParentData {\n     name: String,\n }\n \n+#[derive(Clone)]\n pub enum UnderspecifiedArgKind {\n     Type { prefix: Cow<'static, str> },\n     Const { is_parameter: bool },\n }\n \n impl InferenceDiagnosticsData {\n-    /// Generate a label for a generic argument which can't be inferred. When not\n-    /// much is known about the argument, `use_diag` may be used to describe the\n-    /// labeled value.\n-    fn cannot_infer_msg(&self) -> String {\n-        if self.name == \"_\" && matches!(self.kind, UnderspecifiedArgKind::Type { .. }) {\n-            return \"cannot infer type\".to_string();\n-        }\n-\n-        let suffix = match &self.parent {\n-            Some(parent) => parent.suffix_string(),\n-            None => String::new(),\n-        };\n-\n-        // For example: \"cannot infer type for type parameter `T`\"\n-        format!(\"cannot infer {} `{}`{}\", self.kind.prefix_string(), self.name, suffix)\n+    fn can_add_more_info(&self) -> bool {\n+        !(self.name == \"_\" && matches!(self.kind, UnderspecifiedArgKind::Type { .. }))\n     }\n \n-    fn where_x_is_specified(&self, in_type: Ty<'_>) -> String {\n+    fn where_x_is_kind(&self, in_type: Ty<'_>) -> &'static str {\n         if in_type.is_ty_infer() {\n-            String::new()\n+            \"empty\"\n         } else if self.name == \"_\" {\n             // FIXME: Consider specializing this message if there is a single `_`\n             // in the type.\n-            \", where the placeholders `_` are specified\".to_string()\n+            \"underscore\"\n         } else {\n-            format!(\", where the {} `{}` is specified\", self.kind.prefix_string(), self.name)\n+            \"has_name\"\n+        }\n+    }\n+\n+    /// Generate a label for a generic argument which can't be inferred. When not\n+    /// much is known about the argument, `use_diag` may be used to describe the\n+    /// labeled value.\n+    fn make_bad_error(&self, span: Span) -> InferenceBadError<'_> {\n+        let has_parent = self.parent.is_some();\n+        let bad_kind = if self.can_add_more_info() { \"more_info\" } else { \"other\" };\n+        let (parent_prefix, parent_name) = self\n+            .parent\n+            .as_ref()\n+            .map(|parent| (parent.prefix, parent.name.clone()))\n+            .unwrap_or_default();\n+        InferenceBadError {\n+            span,\n+            bad_kind,\n+            prefix_kind: self.kind.clone(),\n+            prefix: self.kind.try_get_prefix().unwrap_or_default(),\n+            name: self.name.clone(),\n+            has_parent,\n+            parent_prefix,\n+            parent_name,\n         }\n     }\n }\n@@ -113,18 +129,24 @@ impl InferenceDiagnosticsParentData {\n     fn for_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<InferenceDiagnosticsParentData> {\n         Self::for_parent_def_id(tcx, tcx.parent(def_id))\n     }\n+}\n \n-    fn suffix_string(&self) -> String {\n-        format!(\" declared on the {} `{}`\", self.prefix, self.name)\n+impl IntoDiagnosticArg for UnderspecifiedArgKind {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        let kind = match self {\n+            Self::Type { .. } => \"type\",\n+            Self::Const { is_parameter: true } => \"const_with_param\",\n+            Self::Const { is_parameter: false } => \"const\",\n+        };\n+        rustc_errors::DiagnosticArgValue::Str(kind.into())\n     }\n }\n \n impl UnderspecifiedArgKind {\n-    fn prefix_string(&self) -> Cow<'static, str> {\n+    fn try_get_prefix(&self) -> Option<&str> {\n         match self {\n-            Self::Type { prefix } => format!(\"type for {}\", prefix).into(),\n-            Self::Const { is_parameter: true } => \"the value of const parameter\".into(),\n-            Self::Const { is_parameter: false } => \"the value of the constant\".into(),\n+            Self::Type { prefix } => Some(prefix.as_ref()),\n+            Self::Const { .. } => None,\n         }\n     }\n }\n@@ -303,11 +325,44 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         arg_data: InferenceDiagnosticsData,\n         error_code: TypeAnnotationNeeded,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let error_code = error_code.into();\n-        let mut err =\n-            self.tcx.sess.struct_span_err_with_code(span, \"type annotations needed\", error_code);\n-        err.span_label(span, arg_data.cannot_infer_msg());\n-        err\n+        let source_kind = \"other\";\n+        let source_name = \"\";\n+        let failure_span = None;\n+        let infer_subdiags = Vec::new();\n+        let multi_suggestions = Vec::new();\n+        let bad_label = Some(arg_data.make_bad_error(span));\n+        match error_code {\n+            TypeAnnotationNeeded::E0282 => AnnotationRequired {\n+                span,\n+                source_kind,\n+                source_name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            TypeAnnotationNeeded::E0283 => AmbigousImpl {\n+                span,\n+                source_kind,\n+                source_name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            TypeAnnotationNeeded::E0284 => AmbigousReturn {\n+                span,\n+                source_kind,\n+                source_name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+        }\n     }\n \n     pub fn emit_inference_failure_err(\n@@ -340,48 +395,39 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             return self.bad_inference_failure_err(failure_span, arg_data, error_code)\n         };\n \n-        let error_code = error_code.into();\n-        let mut err = self.tcx.sess.struct_span_err_with_code(\n-            span,\n-            &format!(\"type annotations needed{}\", kind.ty_msg(self)),\n-            error_code,\n-        );\n-\n-        if should_label_span && !failure_span.overlaps(span) {\n-            err.span_label(failure_span, \"type must be known at this point\");\n-        }\n+        let (source_kind, name) = kind.ty_localized_msg(self);\n+        let failure_span = if should_label_span && !failure_span.overlaps(span) {\n+            Some(failure_span)\n+        } else {\n+            None\n+        };\n \n+        let mut infer_subdiags = Vec::new();\n+        let mut multi_suggestions = Vec::new();\n         match kind {\n             InferSourceKind::LetBinding { insert_span, pattern_name, ty } => {\n-                let suggestion_msg = if let Some(name) = pattern_name {\n-                    format!(\n-                        \"consider giving `{}` an explicit type{}\",\n-                        name,\n-                        arg_data.where_x_is_specified(ty)\n-                    )\n-                } else {\n-                    format!(\n-                        \"consider giving this pattern a type{}\",\n-                        arg_data.where_x_is_specified(ty)\n-                    )\n-                };\n-                err.span_suggestion_verbose(\n-                    insert_span,\n-                    &suggestion_msg,\n-                    format!(\": {}\", ty_to_string(self, ty)),\n-                    Applicability::HasPlaceholders,\n-                );\n+                infer_subdiags.push(SourceKindSubdiag::LetLike {\n+                    span: insert_span,\n+                    name: pattern_name.map(|name| name.to_string()).unwrap_or_else(String::new),\n+                    x_kind: arg_data.where_x_is_kind(ty),\n+                    prefix_kind: arg_data.kind.clone(),\n+                    prefix: arg_data.kind.try_get_prefix().unwrap_or_default(),\n+                    arg_name: arg_data.name,\n+                    kind: if pattern_name.is_some() { \"with_pattern\" } else { \"other\" },\n+                    type_name: ty_to_string(self, ty),\n+                });\n             }\n             InferSourceKind::ClosureArg { insert_span, ty } => {\n-                err.span_suggestion_verbose(\n-                    insert_span,\n-                    &format!(\n-                        \"consider giving this closure parameter an explicit type{}\",\n-                        arg_data.where_x_is_specified(ty)\n-                    ),\n-                    format!(\": {}\", ty_to_string(self, ty)),\n-                    Applicability::HasPlaceholders,\n-                );\n+                infer_subdiags.push(SourceKindSubdiag::LetLike {\n+                    span: insert_span,\n+                    name: String::new(),\n+                    x_kind: arg_data.where_x_is_kind(ty),\n+                    prefix_kind: arg_data.kind.clone(),\n+                    prefix: arg_data.kind.try_get_prefix().unwrap_or_default(),\n+                    arg_name: arg_data.name,\n+                    kind: \"closure\",\n+                    type_name: ty_to_string(self, ty),\n+                });\n             }\n             InferSourceKind::GenericArg {\n                 insert_span,\n@@ -393,19 +439,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 let generics = self.tcx.generics_of(generics_def_id);\n                 let is_type = matches!(arg.unpack(), GenericArgKind::Type(_));\n \n-                let cannot_infer_msg = format!(\n-                    \"cannot infer {} of the {} parameter `{}`{}\",\n-                    if is_type { \"type\" } else { \"the value\" },\n-                    if is_type { \"type\" } else { \"const\" },\n-                    generics.params[argument_index].name,\n-                    // We use the `generics_def_id` here, as even when suggesting `None::<T>`,\n-                    // the type parameter `T` was still declared on the enum, not on the\n-                    // variant.\n+                let (parent_exists, parent_prefix, parent_name) =\n                     InferenceDiagnosticsParentData::for_parent_def_id(self.tcx, generics_def_id)\n-                        .map_or(String::new(), |parent| parent.suffix_string()),\n-                );\n+                        .map_or((false, String::new(), String::new()), |parent| {\n+                            (true, parent.prefix.to_string(), parent.name)\n+                        });\n \n-                err.span_label(span, cannot_infer_msg);\n+                infer_subdiags.push(SourceKindSubdiag::GenericLabel {\n+                    span,\n+                    is_type,\n+                    param_name: generics.params[argument_index].name.to_string(),\n+                    parent_exists,\n+                    parent_prefix,\n+                    parent_name,\n+                });\n \n                 let args = fmt_printer(self, Namespace::TypeNS)\n                     .comma_sep(generic_args.iter().copied().map(|arg| {\n@@ -435,15 +482,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     .unwrap()\n                     .into_buffer();\n \n-                err.span_suggestion_verbose(\n-                    insert_span,\n-                    &format!(\n-                        \"consider specifying the generic argument{}\",\n-                        pluralize!(generic_args.len()),\n-                    ),\n-                    format!(\"::<{}>\", args),\n-                    Applicability::HasPlaceholders,\n-                );\n+                infer_subdiags.push(SourceKindSubdiag::GenericSuggestion {\n+                    span: insert_span,\n+                    arg_count: generic_args.len(),\n+                    args,\n+                });\n             }\n             InferSourceKind::FullyQualifiedMethodCall { receiver, successor, substs, def_id } => {\n                 let printer = fmt_printer(self, Namespace::ValueNS);\n@@ -468,37 +511,54 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     _ => \"\",\n                 };\n \n-                let suggestion = vec![\n-                    (receiver.span.shrink_to_lo(), format!(\"{def_path}({adjustment}\")),\n-                    (receiver.span.shrink_to_hi().with_hi(successor.1), successor.0.to_string()),\n-                ];\n-                err.multipart_suggestion_verbose(\n-                    \"try using a fully qualified path to specify the expected types\",\n-                    suggestion,\n-                    Applicability::HasPlaceholders,\n-                );\n+                multi_suggestions.push(SourceKindMultiSuggestion::FullyQualified {\n+                    span: receiver.span,\n+                    def_path,\n+                    adjustment,\n+                    successor,\n+                });\n             }\n             InferSourceKind::ClosureReturn { ty, data, should_wrap_expr } => {\n-                let ret = ty_to_string(self, ty);\n-                let (arrow, post) = match data {\n-                    FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n-                    _ => (\"\", \"\"),\n-                };\n-                let suggestion = match should_wrap_expr {\n-                    Some(end_span) => vec![\n-                        (data.span(), format!(\"{}{}{}{{ \", arrow, ret, post)),\n-                        (end_span, \" }\".to_string()),\n-                    ],\n-                    None => vec![(data.span(), format!(\"{}{}{}\", arrow, ret, post))],\n-                };\n-                err.multipart_suggestion_verbose(\n-                    \"try giving this closure an explicit return type\",\n-                    suggestion,\n-                    Applicability::HasPlaceholders,\n-                );\n+                let ty_info = ty_to_string(self, ty);\n+                multi_suggestions.push(SourceKindMultiSuggestion::ClosureReturn {\n+                    ty_info,\n+                    data,\n+                    should_wrap_expr,\n+                });\n+            }\n+        }\n+        match error_code {\n+            TypeAnnotationNeeded::E0282 => AnnotationRequired {\n+                span,\n+                source_kind,\n+                source_name: &name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label: None,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            TypeAnnotationNeeded::E0283 => AmbigousImpl {\n+                span,\n+                source_kind,\n+                source_name: &name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label: None,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            TypeAnnotationNeeded::E0284 => AmbigousReturn {\n+                span,\n+                source_kind,\n+                source_name: &name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label: None,\n             }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n         }\n-        err\n     }\n \n     pub fn need_type_info_err_in_generator(\n@@ -510,15 +570,26 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(ty);\n         let data = self.extract_inference_diagnostics_data(ty.into(), None);\n \n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n+        NeedTypeInfoInGenerator {\n+            bad_label: data.make_bad_error(span),\n             span,\n-            E0698,\n-            \"type inside {} must be known in this context\",\n-            kind,\n-        );\n-        err.span_label(span, data.cannot_infer_msg());\n-        err\n+            generator_kind: GeneratorKindAsDiagArg(kind),\n+        }\n+        .into_diagnostic(&self.tcx.sess.parse_sess)\n+    }\n+}\n+\n+pub struct GeneratorKindAsDiagArg(pub hir::GeneratorKind);\n+\n+impl IntoDiagnosticArg for GeneratorKindAsDiagArg {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        let kind = match self.0 {\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) => \"async_block\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure) => \"async_closure\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn) => \"async_fn\",\n+            hir::GeneratorKind::Gen => \"generator\",\n+        };\n+        rustc_errors::DiagnosticArgValue::Str(kind.into())\n     }\n }\n \n@@ -579,22 +650,22 @@ impl<'tcx> InferSource<'tcx> {\n }\n \n impl<'tcx> InferSourceKind<'tcx> {\n-    fn ty_msg(&self, infcx: &InferCtxt<'_, 'tcx>) -> String {\n+    fn ty_localized_msg(&self, infcx: &InferCtxt<'_, 'tcx>) -> (&'static str, String) {\n         match *self {\n             InferSourceKind::LetBinding { ty, .. }\n             | InferSourceKind::ClosureArg { ty, .. }\n             | InferSourceKind::ClosureReturn { ty, .. } => {\n                 if ty.is_closure() {\n-                    format!(\" for the closure `{}`\", closure_as_fn_str(infcx, ty))\n+                    (\"closure\", closure_as_fn_str(infcx, ty))\n                 } else if !ty.is_ty_infer() {\n-                    format!(\" for `{}`\", ty_to_string(infcx, ty))\n+                    (\"normal\", ty_to_string(infcx, ty))\n                 } else {\n-                    String::new()\n+                    (\"other\", String::new())\n                 }\n             }\n             // FIXME: We should be able to add some additional info here.\n             InferSourceKind::GenericArg { .. }\n-            | InferSourceKind::FullyQualifiedMethodCall { .. } => String::new(),\n+            | InferSourceKind::FullyQualifiedMethodCall { .. } => (\"other\", String::new()),\n         }\n     }\n }"}, {"sha": "cffdf56bb6d48f78a28eb2856b4a9816e3386a39", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 48, "deletions": 66, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7", "patch": "@@ -1,96 +1,78 @@\n-use crate::infer::error_reporting::{note_and_explain_region, ObligationCauseExt};\n+use crate::errors::RegionOriginNote;\n+use crate::infer::error_reporting::note_and_explain_region;\n use crate::infer::{self, InferCtxt, SubregionOrigin};\n-use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{\n+    fluent, struct_span_err, AddSubdiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+};\n use rustc_middle::traits::ObligationCauseCode;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::{self, Region};\n \n+use super::ObligationCauseAsDiagArg;\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub(super) fn note_region_origin(&self, err: &mut Diagnostic, origin: &SubregionOrigin<'tcx>) {\n-        let mut label_or_note = |span, msg: &str| {\n-            let sub_count = err.children.iter().filter(|d| d.span.is_dummy()).count();\n-            let expanded_sub_count = err.children.iter().filter(|d| !d.span.is_dummy()).count();\n-            let span_is_primary = err.span.primary_spans().iter().all(|&sp| sp == span);\n-            if span_is_primary && sub_count == 0 && expanded_sub_count == 0 {\n-                err.span_label(span, msg);\n-            } else if span_is_primary && expanded_sub_count == 0 {\n-                err.note(msg);\n-            } else {\n-                err.span_note(span, msg);\n-            }\n-        };\n         match *origin {\n-            infer::Subtype(ref trace) => {\n-                if let Some((expected, found)) = self.values_str(trace.values) {\n-                    label_or_note(\n-                        trace.cause.span,\n-                        &format!(\"...so that the {}\", trace.cause.as_requirement_str()),\n-                    );\n-\n-                    err.note_expected_found(&\"\", expected, &\"\", found);\n-                } else {\n-                    // FIXME: this really should be handled at some earlier stage. Our\n-                    // handling of region checking when type errors are present is\n-                    // *terrible*.\n-\n-                    label_or_note(\n-                        trace.cause.span,\n-                        &format!(\"...so that {}\", trace.cause.as_requirement_str()),\n-                    );\n-                }\n-            }\n-            infer::Reborrow(span) => {\n-                label_or_note(span, \"...so that reference does not outlive borrowed content\");\n+            infer::Subtype(ref trace) => RegionOriginNote::WithRequirement {\n+                span: trace.cause.span,\n+                requirement: ObligationCauseAsDiagArg(trace.cause.clone()),\n+                expected_found: self.values_str(trace.values),\n             }\n+            .add_to_diagnostic(err),\n+            infer::Reborrow(span) => RegionOriginNote::Plain { span, msg: fluent::infer::reborrow }\n+                .add_to_diagnostic(err),\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n                 let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n-                label_or_note(span, &format!(\"...so that closure can access `{}`\", var_name));\n+                RegionOriginNote::WithName {\n+                    span,\n+                    msg: fluent::infer::reborrow,\n+                    name: &var_name.to_string(),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n             }\n             infer::RelateObjectBound(span) => {\n-                label_or_note(span, \"...so that it can be closed over into an object\");\n+                RegionOriginNote::Plain { span, msg: fluent::infer::relate_object_bound }\n+                    .add_to_diagnostic(err);\n             }\n             infer::DataBorrowed(ty, span) => {\n-                label_or_note(\n+                RegionOriginNote::WithName {\n                     span,\n-                    &format!(\n-                        \"...so that the type `{}` is not borrowed for too long\",\n-                        self.ty_to_string(ty)\n-                    ),\n-                );\n+                    msg: fluent::infer::data_borrowed,\n+                    name: &self.ty_to_string(ty),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n-                label_or_note(\n+                RegionOriginNote::WithName {\n                     span,\n-                    &format!(\n-                        \"...so that the reference type `{}` does not outlive the data it points at\",\n-                        self.ty_to_string(ty)\n-                    ),\n-                );\n+                    msg: fluent::infer::reference_outlives_referent,\n+                    name: &self.ty_to_string(ty),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n             }\n-            infer::RelateParamBound(span, t, opt_span) => {\n-                label_or_note(\n+            infer::RelateParamBound(span, ty, opt_span) => {\n+                RegionOriginNote::WithName {\n                     span,\n-                    &format!(\n-                        \"...so that the type `{}` will meet its required lifetime bounds{}\",\n-                        self.ty_to_string(t),\n-                        if opt_span.is_some() { \"...\" } else { \"\" },\n-                    ),\n-                );\n+                    msg: fluent::infer::relate_param_bound,\n+                    name: &self.ty_to_string(ty),\n+                    continues: opt_span.is_some(),\n+                }\n+                .add_to_diagnostic(err);\n                 if let Some(span) = opt_span {\n-                    err.span_note(span, \"...that is required by this bound\");\n+                    RegionOriginNote::Plain { span, msg: fluent::infer::relate_param_bound_2 }\n+                        .add_to_diagnostic(err);\n                 }\n             }\n             infer::RelateRegionParamBound(span) => {\n-                label_or_note(\n-                    span,\n-                    \"...so that the declared lifetime parameter bounds are satisfied\",\n-                );\n+                RegionOriginNote::Plain { span, msg: fluent::infer::relate_region_param_bound }\n+                    .add_to_diagnostic(err);\n             }\n             infer::CompareImplItemObligation { span, .. } => {\n-                label_or_note(\n-                    span,\n-                    \"...so that the definition in impl matches the definition from the trait\",\n-                );\n+                RegionOriginNote::Plain { span, msg: fluent::infer::compare_impl_item_obligation }\n+                    .add_to_diagnostic(err);\n             }\n             infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n                 self.note_region_origin(err, &parent);"}, {"sha": "233a5004a3931f53444eaf75538edc8f89d65e6a", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors::OpaqueHiddenTypeDiag;\n use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n use crate::traits;\n use hir::def_id::{DefId, LocalDefId};\n@@ -153,22 +154,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     if let Some(OpaqueTyOrigin::TyAlias) =\n                         did2.as_local().and_then(|did2| self.opaque_type_origin(did2, cause.span))\n                     {\n-                        self.tcx\n-                                .sess\n-                                .struct_span_err(\n-                                    cause.span,\n-                                    \"opaque type's hidden type cannot be another opaque type from the same scope\",\n-                                )\n-                                .span_label(cause.span, \"one of the two opaque types used here has to be outside its defining scope\")\n-                                .span_note(\n-                                    self.tcx.def_span(def_id),\n-                                    \"opaque type whose hidden type is being assigned\",\n-                                )\n-                                .span_note(\n-                                    self.tcx.def_span(did2),\n-                                    \"opaque type being used as hidden type\",\n-                                )\n-                                .emit();\n+                        self.tcx.sess.emit_err(OpaqueHiddenTypeDiag {\n+                            span: cause.span,\n+                            hidden_type: self.tcx.def_span(did2),\n+                            opaque_type: self.tcx.def_span(def_id),\n+                        });\n                     }\n                 }\n                 Some(self.register_hidden_type("}, {"sha": "602a9ab13f37792b9a0fdadce06d4f839aadba0e", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=a3c965f5feb5dd1b50ef8c0d1c54d624fd10e3a7", "patch": "@@ -34,5 +34,6 @@ extern crate tracing;\n #[macro_use]\n extern crate rustc_middle;\n \n+mod errors;\n pub mod infer;\n pub mod traits;"}]}