{"sha": "dd3738a2ba63d6ba2d8359c90732c994abeaf4be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMzczOGEyYmE2M2Q2YmEyZDgzNTljOTA3MzJjOTk0YWJlYWY0YmU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-10-21T22:28:59Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-10-27T23:56:11Z"}, "message": "resolve: Record full parent scope data for imports", "tree": {"sha": "a46c883a720e6482c0db67ca9d4a410128b8f6a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a46c883a720e6482c0db67ca9d4a410128b8f6a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd3738a2ba63d6ba2d8359c90732c994abeaf4be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd3738a2ba63d6ba2d8359c90732c994abeaf4be", "html_url": "https://github.com/rust-lang/rust/commit/dd3738a2ba63d6ba2d8359c90732c994abeaf4be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd3738a2ba63d6ba2d8359c90732c994abeaf4be/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cae6efc37d70ab7d353e6ab9ce229d59a65ed643", "url": "https://api.github.com/repos/rust-lang/rust/commits/cae6efc37d70ab7d353e6ab9ce229d59a65ed643", "html_url": "https://github.com/rust-lang/rust/commit/cae6efc37d70ab7d353e6ab9ce229d59a65ed643"}], "stats": {"total": 98, "additions": 52, "deletions": 46}, "files": [{"sha": "c98ea76bfa65a3fd756e64e99edbec6c4213e5be", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/dd3738a2ba63d6ba2d8359c90732c994abeaf4be/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3738a2ba63d6ba2d8359c90732c994abeaf4be/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=dd3738a2ba63d6ba2d8359c90732c994abeaf4be", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         mut uniform_paths_canary_emitted: bool,\n         nested: bool,\n         item: &Item,\n-        expansion: Mark,\n+        parent_scope: ParentScope<'a>,\n     ) {\n         debug!(\"build_reduced_graph_for_use_tree(parent_prefix={:?}, \\\n                 uniform_paths_canary_emitted={}, \\\n@@ -224,7 +224,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     root_use_tree.span,\n                     root_id,\n                     ty::Visibility::Invisible,\n-                    expansion,\n+                    parent_scope.clone(),\n                     true, // is_uniform_paths_canary\n                 );\n             };\n@@ -354,7 +354,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     root_use_tree.span,\n                     root_id,\n                     vis,\n-                    expansion,\n+                    parent_scope,\n                     false, // is_uniform_paths_canary\n                 );\n             }\n@@ -371,7 +371,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     root_use_tree.span,\n                     root_id,\n                     vis,\n-                    expansion,\n+                    parent_scope,\n                     false, // is_uniform_paths_canary\n                 );\n             }\n@@ -409,16 +409,17 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         uniform_paths_canary_emitted,\n                         true,\n                         item,\n-                        expansion,\n+                        parent_scope.clone(),\n                     );\n                 }\n             }\n         }\n     }\n \n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self, item: &Item, expansion: Mark) {\n-        let parent = self.current_module;\n+    fn build_reduced_graph_for_item(&mut self, item: &Item, parent_scope: ParentScope<'a>) {\n+        let parent = parent_scope.module;\n+        let expansion = parent_scope.expansion;\n         let ident = item.ident;\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n@@ -435,7 +436,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     false, // uniform_paths_canary_emitted\n                     false,\n                     item,\n-                    expansion,\n+                    parent_scope,\n                 );\n             }\n \n@@ -448,7 +449,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     self.injected_crate = Some(module);\n                 }\n \n-                let used = self.process_legacy_macro_imports(item, module, expansion);\n+                let used = self.process_legacy_macro_imports(item, module, &parent_scope);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.arenas);\n                 if ptr::eq(self.current_module, self.graph_root) {\n@@ -473,7 +474,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 let directive = self.arenas.alloc_import_directive(ImportDirective {\n                     root_id: item.id,\n                     id: item.id,\n-                    parent,\n+                    parent_scope,\n                     imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                     subclass: ImportDirectiveSubclass::ExternCrate {\n                         source: orig_name,\n@@ -483,7 +484,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     span: item.span,\n                     module_path: Vec::new(),\n                     vis: Cell::new(vis),\n-                    expansion,\n                     used: Cell::new(used),\n                     is_uniform_paths_canary: false,\n                 });\n@@ -856,9 +856,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     }\n \n     // This returns true if we should consider the underlying `extern crate` to be used.\n-    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>, expansion: Mark)\n-                                    -> bool {\n-        let allow_shadowing = expansion == Mark::root();\n+    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>,\n+                                    parent_scope: &ParentScope<'a>) -> bool {\n+        let allow_shadowing = parent_scope.expansion == Mark::root();\n         let legacy_imports = self.legacy_macro_imports(&item.attrs);\n         let used = legacy_imports != LegacyMacroImports::default();\n \n@@ -868,18 +868,17 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                       \"an `extern crate` loading macros must be at the crate root\");\n         }\n \n-        let (graph_root, arenas) = (self.graph_root, self.arenas);\n+        let arenas = self.arenas;\n         let macro_use_directive = |span| arenas.alloc_import_directive(ImportDirective {\n             root_id: item.id,\n             id: item.id,\n-            parent: graph_root,\n+            parent_scope: parent_scope.clone(),\n             imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n             subclass: ImportDirectiveSubclass::MacroUse,\n             root_span: span,\n             span,\n             module_path: Vec::new(),\n             vis: Cell::new(ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))),\n-            expansion,\n             used: Cell::new(false),\n             is_uniform_paths_canary: false,\n         });\n@@ -1010,7 +1009,13 @@ impl<'a, 'b, 'cl> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b, 'cl> {\n \n         let orig_current_module = self.resolver.current_module;\n         let orig_current_legacy_scope = self.current_legacy_scope;\n-        self.resolver.build_reduced_graph_for_item(item, self.expansion);\n+        let parent_scope = ParentScope {\n+            module: self.resolver.current_module,\n+            expansion: self.expansion,\n+            legacy: self.current_legacy_scope,\n+            derives: Vec::new(),\n+        };\n+        self.resolver.build_reduced_graph_for_item(item, parent_scope);\n         visit::walk_item(self, item);\n         self.resolver.current_module = orig_current_module;\n         if !macro_use {"}, {"sha": "6a9aaa4ea710c7047edb9cf48c43a874d7cab0a1", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dd3738a2ba63d6ba2d8359c90732c994abeaf4be/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3738a2ba63d6ba2d8359c90732c994abeaf4be/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=dd3738a2ba63d6ba2d8359c90732c994abeaf4be", "patch": "@@ -43,7 +43,7 @@ use std::cell::Cell;\n use std::mem;\n use rustc_data_structures::sync::Lrc;\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct InvocationData<'a> {\n     def_index: DefIndex,\n     /// Module in which the macro was invoked.\n@@ -70,6 +70,7 @@ impl<'a> InvocationData<'a> {\n \n /// Binding produced by a `macro_rules` item.\n /// Not modularized, can shadow previous legacy bindings, etc.\n+#[derive(Debug)]\n pub struct LegacyBinding<'a> {\n     binding: &'a NameBinding<'a>,\n     /// Legacy scope into which the `macro_rules` item was planted.\n@@ -82,7 +83,7 @@ pub struct LegacyBinding<'a> {\n /// (named or unnamed), or even further if it escapes with `#[macro_use]`.\n /// Some macro invocations need to introduce legacy scopes too because they\n /// potentially can expand into macro definitions.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum LegacyScope<'a> {\n     /// Created when invocation data is allocated in the arena,\n     /// must be replaced with a proper scope later.\n@@ -96,8 +97,8 @@ pub enum LegacyScope<'a> {\n     Invocation(&'a InvocationData<'a>),\n }\n \n-/// Everything you need to resolve a macro path.\n-#[derive(Clone)]\n+/// Everything you need to resolve a macro or import path.\n+#[derive(Clone, Debug)]\n pub struct ParentScope<'a> {\n     crate module: Module<'a>,\n     crate expansion: Mark,"}, {"sha": "2b1279ba202c6a84c2b08a1e60658df53d7417d4", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/dd3738a2ba63d6ba2d8359c90732c994abeaf4be/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd3738a2ba63d6ba2d8359c90732c994abeaf4be/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=dd3738a2ba63d6ba2d8359c90732c994abeaf4be", "patch": "@@ -16,6 +16,7 @@ use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use {Resolver, Segment};\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n+use macros::ParentScope;\n \n use rustc_data_structures::ptr_key::PtrKey;\n use rustc::ty;\n@@ -88,13 +89,12 @@ pub struct ImportDirective<'a> {\n     /// Span of the *root* use tree (see `root_id`).\n     pub root_span: Span,\n \n-    pub parent: Module<'a>,\n+    pub parent_scope: ParentScope<'a>,\n     pub module_path: Vec<Segment>,\n     /// The resolution of `module_path`.\n     pub imported_module: Cell<Option<ModuleOrUniformRoot<'a>>>,\n     pub subclass: ImportDirectiveSubclass<'a>,\n     pub vis: Cell<ty::Visibility>,\n-    pub expansion: Mark,\n     pub used: Cell<bool>,\n \n     /// Whether this import is a \"canary\" for the `uniform_paths` feature,\n@@ -307,8 +307,9 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             };\n             match self.resolve_ident_in_module(module, ident, ns, false, path_span) {\n                 Err(Determined) => continue,\n-                Ok(binding)\n-                    if !self.is_accessible_from(binding.vis, single_import.parent) => continue,\n+                Ok(binding) if !self.is_accessible_from(\n+                    binding.vis, single_import.parent_scope.module\n+                ) => continue,\n                 Ok(_) | Err(Undetermined) => return Err(Undetermined),\n             }\n         }\n@@ -381,8 +382,9 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n \n             match result {\n                 Err(Determined) => continue,\n-                Ok(binding)\n-                    if !self.is_accessible_from(binding.vis, glob_import.parent) => continue,\n+                Ok(binding) if !self.is_accessible_from(\n+                    binding.vis, glob_import.parent_scope.module\n+                ) => continue,\n                 Ok(_) | Err(Undetermined) => return Err(Undetermined),\n             }\n         }\n@@ -400,11 +402,11 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                                 root_span: Span,\n                                 root_id: NodeId,\n                                 vis: ty::Visibility,\n-                                expansion: Mark,\n+                                parent_scope: ParentScope<'a>,\n                                 is_uniform_paths_canary: bool) {\n-        let current_module = self.current_module;\n+        let current_module = parent_scope.module;\n         let directive = self.arenas.alloc_import_directive(ImportDirective {\n-            parent: current_module,\n+            parent_scope,\n             module_path,\n             imported_module: Cell::new(None),\n             subclass,\n@@ -413,7 +415,6 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             root_span,\n             root_id,\n             vis: Cell::new(vis),\n-            expansion,\n             used: Cell::new(false),\n             is_uniform_paths_canary,\n         });\n@@ -431,7 +432,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n             // which are not relevant to import resolution.\n             GlobImport { is_prelude: true, .. } => {}\n-            GlobImport { .. } => self.current_module.globs.borrow_mut().push(directive),\n+            GlobImport { .. } => current_module.globs.borrow_mut().push(directive),\n             _ => unreachable!(),\n         }\n     }\n@@ -462,7 +463,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             },\n             span: directive.span,\n             vis,\n-            expansion: directive.expansion,\n+            expansion: directive.parent_scope.expansion,\n         })\n     }\n \n@@ -568,12 +569,12 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             let scope = match ident.span.reverse_glob_adjust(module.expansion,\n                                                              directive.span.ctxt().modern()) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n-                Some(None) => directive.parent,\n+                Some(None) => directive.parent_scope.module,\n                 None => continue,\n             };\n             if self.is_accessible_from(binding.vis, scope) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n+                let _ = self.try_define(directive.parent_scope.module, ident, ns, imported_binding);\n             }\n         }\n \n@@ -587,7 +588,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             let dummy_binding = self.dummy_binding;\n             let dummy_binding = self.import(dummy_binding, directive);\n             self.per_ns(|this, ns| {\n-                let _ = this.try_define(directive.parent, target, ns, dummy_binding);\n+                let _ = this.try_define(directive.parent_scope.module, target, ns, dummy_binding);\n             });\n         }\n     }\n@@ -856,8 +857,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                Segment::names_to_string(&directive.module_path[..]),\n                module_to_string(self.current_module).unwrap_or_else(|| \"???\".to_string()));\n \n-\n-        self.current_module = directive.parent;\n+        self.current_module = directive.parent_scope.module;\n \n         let module = if let Some(module) = directive.imported_module.get() {\n             module\n@@ -868,7 +868,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             directive.vis.set(ty::Visibility::Invisible);\n             let result = self.resolve_path(\n                 Some(if directive.is_uniform_paths_canary {\n-                    ModuleOrUniformRoot::Module(directive.parent)\n+                    ModuleOrUniformRoot::Module(directive.parent_scope.module)\n                 } else {\n                     ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())\n                 }),\n@@ -910,7 +910,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 return\n             };\n \n-            let parent = directive.parent;\n+            let parent = directive.parent_scope.module;\n             match result[ns].get() {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n@@ -942,12 +942,12 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n     // If appropriate, returns an error to report.\n     fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> Option<(Span, String)> {\n-        self.current_module = directive.parent;\n+        self.current_module = directive.parent_scope.module;\n         let ImportDirective { ref module_path, span, .. } = *directive;\n \n         let module_result = self.resolve_path(\n             Some(if directive.is_uniform_paths_canary {\n-                ModuleOrUniformRoot::Module(directive.parent)\n+                ModuleOrUniformRoot::Module(directive.parent_scope.module)\n             } else {\n                 ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())\n             }),\n@@ -995,7 +995,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 }\n \n                 if let ModuleOrUniformRoot::Module(module) = module {\n-                    if module.def_id() == directive.parent.def_id() {\n+                    if module.def_id() == directive.parent_scope.module.def_id() {\n                         // Importing a module into itself is not allowed.\n                         return Some((directive.span,\n                             \"Cannot glob-import a module into itself.\".to_string()));\n@@ -1189,7 +1189,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         if let Some(Def::Trait(_)) = module.def() {\n             self.session.span_err(directive.span, \"items in traits are not importable.\");\n             return;\n-        } else if module.def_id() == directive.parent.def_id()  {\n+        } else if module.def_id() == directive.parent_scope.module.def_id()  {\n             return;\n         } else if let GlobImport { is_prelude: true, .. } = directive.subclass {\n             self.prelude = Some(module);\n@@ -1213,7 +1213,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             };\n             if self.is_accessible_from(binding.pseudo_vis(), scope) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n+                let _ = self.try_define(directive.parent_scope.module, ident, ns, imported_binding);\n             }\n         }\n "}]}