{"sha": "b2f6dd53c95c866e206798976cfcc2f9a9b2fe2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZjZkZDUzYzk1Yzg2NmUyMDY3OTg5NzZjZmNjMmY5YTliMmZlMmE=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-05-19T20:59:35Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-05-28T19:42:21Z"}, "message": "Expand macros in patterns", "tree": {"sha": "18bdae434d9f36b5c05db3858caa31f48f9fc900", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18bdae434d9f36b5c05db3858caa31f48f9fc900"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2f6dd53c95c866e206798976cfcc2f9a9b2fe2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2f6dd53c95c866e206798976cfcc2f9a9b2fe2a", "html_url": "https://github.com/rust-lang/rust/commit/b2f6dd53c95c866e206798976cfcc2f9a9b2fe2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2f6dd53c95c866e206798976cfcc2f9a9b2fe2a/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00704ea33b98dc880d9ac1e4ae7f61b45e8e4330", "url": "https://api.github.com/repos/rust-lang/rust/commits/00704ea33b98dc880d9ac1e4ae7f61b45e8e4330", "html_url": "https://github.com/rust-lang/rust/commit/00704ea33b98dc880d9ac1e4ae7f61b45e8e4330"}], "stats": {"total": 95, "additions": 90, "deletions": 5}, "files": [{"sha": "03001acc5d04d47e6914d640bce40c29691f67f0", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 90, "deletions": 5, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6dd53c95c866e206798976cfcc2f9a9b2fe2a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6dd53c95c866e206798976cfcc2f9a9b2fe2a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b2f6dd53c95c866e206798976cfcc2f9a9b2fe2a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{P, Block, Crate, DeclLocal, ExprMac};\n+use ast::{P, Block, Crate, DeclLocal, ExprMac, PatMac};\n use ast::{Local, Ident, MacInvocTT};\n use ast::{ItemMac, Mrk, Stmt, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n use ast::TokenTree;\n@@ -92,8 +92,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                                 None => {\n                                     fld.cx.span_err(\n                                         pth.span,\n-                                        format!(\"non-expr macro in expr pos: \\\n-                                                 {}\",\n+                                        format!(\"non-expression macro in expression position: {}\",\n                                                 extnamestr.get().as_slice()\n                                         ).as_slice());\n                                     return DummyResult::raw_expr(e.span);\n@@ -487,7 +486,7 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n                 }\n                 None => {\n                     fld.cx.span_err(pth.span,\n-                                    format!(\"expr macro in item position: {}\",\n+                                    format!(\"non-item macro in item position: {}\",\n                                             extnamestr.get()).as_slice());\n                     return SmallVector::zero();\n                 }\n@@ -639,7 +638,7 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n                 Some(stmt) => stmt,\n                 None => {\n                     fld.cx.span_err(pth.span,\n-                                    format!(\"non-stmt macro in stmt pos: {}\",\n+                                    format!(\"non-statement macro in statement position: {}\",\n                                             extnamestr).as_slice());\n                     return SmallVector::zero();\n                 }\n@@ -842,6 +841,83 @@ pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n     })\n }\n \n+pub fn expand_pat(p: @ast::Pat, fld: &mut MacroExpander) -> @ast::Pat {\n+    let (pth, tts) = match p.node {\n+        PatMac(ref mac) => {\n+            match mac.node {\n+                MacInvocTT(ref pth, ref tts, _) => {\n+                    (pth, (*tts).clone())\n+                }\n+            }\n+        }\n+        _ => return noop_fold_pat(p, fld),\n+    };\n+    if pth.segments.len() > 1u {\n+        fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n+        return DummyResult::raw_pat(p.span);\n+    }\n+    let extname = pth.segments.get(0).identifier;\n+    let extnamestr = token::get_ident(extname);\n+    let marked_after = match fld.extsbox.find(&extname.name) {\n+        None => {\n+            fld.cx.span_err(pth.span,\n+                            format!(\"macro undefined: '{}!'\",\n+                                    extnamestr).as_slice());\n+            // let compilation continue\n+            return DummyResult::raw_pat(p.span);\n+        }\n+\n+        Some(&NormalTT(ref expander, span)) => {\n+            fld.cx.bt_push(ExpnInfo {\n+                call_site: p.span,\n+                callee: NameAndSpan {\n+                    name: extnamestr.get().to_string(),\n+                    format: MacroBang,\n+                    span: span\n+                }\n+            });\n+\n+            let fm = fresh_mark();\n+            let marked_before = mark_tts(tts.as_slice(), fm);\n+            let mac_span = original_span(fld.cx);\n+            let expanded = match expander.expand(fld.cx,\n+                                   mac_span.call_site,\n+                                   marked_before.as_slice()).make_pat() {\n+                Some(e) => e,\n+                None => {\n+                    fld.cx.span_err(\n+                        pth.span,\n+                        format!(\n+                            \"non-pattern macro in pattern position: {}\",\n+                            extnamestr.get()\n+                        ).as_slice()\n+                    );\n+                    return DummyResult::raw_pat(p.span);\n+                }\n+            };\n+\n+            // mark after:\n+            mark_pat(expanded,fm)\n+        }\n+        _ => {\n+            fld.cx.span_err(p.span,\n+                            format!(\"{}! is not legal in pattern position\",\n+                                    extnamestr.get()).as_slice());\n+            return DummyResult::raw_pat(p.span);\n+        }\n+    };\n+\n+    let fully_expanded =\n+        fld.fold_pat(marked_after).node.clone();\n+    fld.cx.bt_pop();\n+\n+    @ast::Pat {\n+        id: ast::DUMMY_NODE_ID,\n+        node: fully_expanded,\n+        span: p.span,\n+    }\n+}\n+\n pub struct IdentRenamer<'a> {\n     renames: &'a mut RenameList,\n }\n@@ -885,6 +961,10 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_expr(expr, self)\n     }\n \n+    fn fold_pat(&mut self, pat: @ast::Pat) -> @ast::Pat {\n+        expand_pat(pat, self)\n+    }\n+\n     fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n         expand_item(item, self)\n     }\n@@ -974,6 +1054,11 @@ fn mark_expr(expr: @ast::Expr, m: Mrk) -> @ast::Expr {\n     new_mark_folder(m).fold_expr(expr)\n }\n \n+// apply a given mark to the given pattern. Used following the expansion of a macro.\n+fn mark_pat(pat: @ast::Pat, m: Mrk) -> @ast::Pat {\n+    new_mark_folder(m).fold_pat(pat)\n+}\n+\n // apply a given mark to the given stmt. Used following the expansion of a macro.\n fn mark_stmt(expr: &ast::Stmt, m: Mrk) -> @ast::Stmt {\n     new_mark_folder(m).fold_stmt(expr)"}]}