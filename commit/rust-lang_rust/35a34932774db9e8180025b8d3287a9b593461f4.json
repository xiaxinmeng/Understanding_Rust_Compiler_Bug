{"sha": "35a34932774db9e8180025b8d3287a9b593461f4", "node_id": "C_kwDOAAsO6NoAKDM1YTM0OTMyNzc0ZGI5ZTgxODAwMjViOGQzMjg3YTliNTkzNDYxZjQ", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2023-04-14T14:00:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-14T14:00:35Z"}, "message": "Rollup merge of #110305 - notriddle:notriddle/es6-map-set, r=GuillaumeGomez\n\nrustdoc-search: use ES6 `Map` and `Set` where they make sense\n\nSince all supported browsers now support these classes, and rustdoc has started using them in some places, it might as well use them everywhere it makes sense (because, as [MDN's Map page] says, it \"performs better in scenarios involving frequent additions and removals of key-value pairs.\").\n\n[MDN's Map page]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map", "tree": {"sha": "1fd74436049fbc16123ac27176c4fc9193d55bca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fd74436049fbc16123ac27176c4fc9193d55bca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35a34932774db9e8180025b8d3287a9b593461f4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkOVyDCRBK7hj4Ov3rIwAA3n8IAKGSxhYIFBYHBznup9g+YTLr\nvi7Xcx7b8BlYcF6e7UAV95hdxHM2/D8TwvNk/vyRo/80ZzH05ptDf8EdO/Il3G1V\nzOVfwEHoQpHo3jBAVFC7Nt3e7VfMqE9ZJJKC5wal07O6hx/dYnRyfZnliaTcxwYx\n98bvHJhxAO5atAQ9RhUV6yhC+SjMhH28fLd1pwS7USy7EeUqghM050Y/3Kdd0nCl\nJDuNamSQM3bVMoVW4kbta48cFilXR1lvdtrBQ0tQ2v57Aqbgj/BnJ1SgkGjh5j5Q\nRx1sTouXWzkI9Owl1M71ixWbmUwuaEb1jyDq+90n58bnnX9PrUCE33NTNvcFmfM=\n=MKAV\n-----END PGP SIGNATURE-----\n", "payload": "tree 1fd74436049fbc16123ac27176c4fc9193d55bca\nparent ad0a9350ad47711a7ee463750064db49a0d2df7e\nparent 53f499d4752885cabcdecad22f76bfe1037ad41f\nauthor Yuki Okushi <jtitor@2k36.org> 1681480835 +0900\ncommitter GitHub <noreply@github.com> 1681480835 +0900\n\nRollup merge of #110305 - notriddle:notriddle/es6-map-set, r=GuillaumeGomez\n\nrustdoc-search: use ES6 `Map` and `Set` where they make sense\n\nSince all supported browsers now support these classes, and rustdoc has started using them in some places, it might as well use them everywhere it makes sense (because, as [MDN's Map page] says, it \"performs better in scenarios involving frequent additions and removals of key-value pairs.\").\n\n[MDN's Map page]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35a34932774db9e8180025b8d3287a9b593461f4", "html_url": "https://github.com/rust-lang/rust/commit/35a34932774db9e8180025b8d3287a9b593461f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35a34932774db9e8180025b8d3287a9b593461f4/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad0a9350ad47711a7ee463750064db49a0d2df7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad0a9350ad47711a7ee463750064db49a0d2df7e", "html_url": "https://github.com/rust-lang/rust/commit/ad0a9350ad47711a7ee463750064db49a0d2df7e"}, {"sha": "53f499d4752885cabcdecad22f76bfe1037ad41f", "url": "https://api.github.com/repos/rust-lang/rust/commits/53f499d4752885cabcdecad22f76bfe1037ad41f", "html_url": "https://github.com/rust-lang/rust/commit/53f499d4752885cabcdecad22f76bfe1037ad41f"}], "stats": {"total": 131, "additions": 73, "deletions": 58}, "files": [{"sha": "4c81a0979c1a7f6a7c50b007a3c3d1ee4fc1f194", "filename": "src/librustdoc/html/static/js/externs.js", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35a34932774db9e8180025b8d3287a9b593461f4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "raw_url": "https://github.com/rust-lang/rust/raw/35a34932774db9e8180025b8d3287a9b593461f4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js?ref=35a34932774db9e8180025b8d3287a9b593461f4", "patch": "@@ -65,6 +65,11 @@ let Row;\n  */\n let ResultsTable;\n \n+/**\n+ * @typedef {Map<String, ResultObject>}\n+ */\n+let Results;\n+\n /**\n  * @typedef {{\n  *     desc: string,\n@@ -80,7 +85,7 @@ let ResultsTable;\n  *     ty: number,\n  * }}\n  */\n-let Results;\n+let ResultObject;\n \n /**\n  * A pair of [inputs, outputs], or 0 for null. This is stored in the search index."}, {"sha": "40cdc55bbc3becc8f3a203e86ba8209627f044c1", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 67, "deletions": 57, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/35a34932774db9e8180025b8d3287a9b593461f4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/35a34932774db9e8180025b8d3287a9b593461f4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=35a34932774db9e8180025b8d3287a9b593461f4", "patch": "@@ -191,7 +191,7 @@ function initSearch(rawSearchIndex) {\n      */\n     let searchIndex;\n     let currentResults;\n-    const ALIASES = Object.create(null);\n+    const ALIASES = new Map();\n \n     function isWhitespace(c) {\n         return \" \\t\\n\\r\".indexOf(c) !== -1;\n@@ -903,10 +903,18 @@ function initSearch(rawSearchIndex) {\n      * @return {ResultsTable}\n      */\n     function execQuery(parsedQuery, searchWords, filterCrates, currentCrate) {\n-        const results_others = {}, results_in_args = {}, results_returned = {};\n+        const results_others = new Map(), results_in_args = new Map(),\n+            results_returned = new Map();\n \n+        /**\n+         * Add extra data to result objects, and filter items that have been\n+         * marked for removal.\n+         *\n+         * @param {[ResultObject]} results\n+         * @returns {[ResultObject]}\n+         */\n         function transformResults(results) {\n-            const duplicates = {};\n+            const duplicates = new Set();\n             const out = [];\n \n             for (const result of results) {\n@@ -919,10 +927,10 @@ function initSearch(rawSearchIndex) {\n                     // To be sure than it some items aren't considered as duplicate.\n                     obj.fullPath += \"|\" + obj.ty;\n \n-                    if (duplicates[obj.fullPath]) {\n+                    if (duplicates.has(obj.fullPath)) {\n                         continue;\n                     }\n-                    duplicates[obj.fullPath] = true;\n+                    duplicates.add(obj.fullPath);\n \n                     obj.href = res[1];\n                     out.push(obj);\n@@ -934,24 +942,30 @@ function initSearch(rawSearchIndex) {\n             return out;\n         }\n \n+        /**\n+         * This function takes a result map, and sorts it by various criteria, including edit\n+         * distance, substring match, and the crate it comes from.\n+         *\n+         * @param {Results} results\n+         * @param {boolean} isType\n+         * @param {string} preferredCrate\n+         * @returns {[ResultObject]}\n+         */\n         function sortResults(results, isType, preferredCrate) {\n-            const userQuery = parsedQuery.userQuery;\n-            const ar = [];\n-            for (const entry in results) {\n-                if (hasOwnPropertyRustdoc(results, entry)) {\n-                    const result = results[entry];\n-                    result.word = searchWords[result.id];\n-                    result.item = searchIndex[result.id] || {};\n-                    ar.push(result);\n-                }\n-            }\n-            results = ar;\n             // if there are no results then return to default and fail\n-            if (results.length === 0) {\n+            if (results.size === 0) {\n                 return [];\n             }\n \n-            results.sort((aaa, bbb) => {\n+            const userQuery = parsedQuery.userQuery;\n+            const result_list = [];\n+            for (const result of results.values()) {\n+                result.word = searchWords[result.id];\n+                result.item = searchIndex[result.id] || {};\n+                result_list.push(result);\n+            }\n+\n+            result_list.sort((aaa, bbb) => {\n                 let a, b;\n \n                 // sort by exact match with regard to the last word (mismatch goes later)\n@@ -1060,7 +1074,7 @@ function initSearch(rawSearchIndex) {\n                 nameSplit = hasPath ? null : parsedQuery.elems[0].path;\n             }\n \n-            for (const result of results) {\n+            for (const result of result_list) {\n                 // this validation does not make sense when searching by types\n                 if (result.dontValidate) {\n                     continue;\n@@ -1073,7 +1087,7 @@ function initSearch(rawSearchIndex) {\n                     result.id = -1;\n                 }\n             }\n-            return transformResults(results);\n+            return transformResults(result_list);\n         }\n \n         /**\n@@ -1096,7 +1110,7 @@ function initSearch(rawSearchIndex) {\n             // The names match, but we need to be sure that all generics kinda\n             // match as well.\n             if (elem.generics.length > 0 && row.generics.length >= elem.generics.length) {\n-                const elems = Object.create(null);\n+                const elems = new Map();\n                 for (const entry of row.generics) {\n                     if (entry.name === \"\") {\n                         // Pure generic, needs to check into it.\n@@ -1106,39 +1120,30 @@ function initSearch(rawSearchIndex) {\n                         }\n                         continue;\n                     }\n-                    if (elems[entry.name] === undefined) {\n-                        elems[entry.name] = [];\n+                    let currentEntryElems;\n+                    if (elems.has(entry.name)) {\n+                        currentEntryElems = elems.get(entry.name);\n+                    } else {\n+                        currentEntryElems = [];\n+                        elems.set(entry.name, currentEntryElems);\n                     }\n-                    elems[entry.name].push(entry.ty);\n+                    currentEntryElems.push(entry.ty);\n                 }\n                 // We need to find the type that matches the most to remove it in order\n                 // to move forward.\n                 const handleGeneric = generic => {\n-                    let match = null;\n-                    if (elems[generic.name]) {\n-                        match = generic.name;\n-                    } else {\n-                        for (const elem_name in elems) {\n-                            if (!hasOwnPropertyRustdoc(elems, elem_name)) {\n-                                continue;\n-                            }\n-                            if (elem_name === generic) {\n-                                match = elem_name;\n-                                break;\n-                            }\n-                        }\n-                    }\n-                    if (match === null) {\n+                    if (!elems.has(generic.name)) {\n                         return false;\n                     }\n-                    const matchIdx = elems[match].findIndex(tmp_elem =>\n+                    const matchElems = elems.get(generic.name);\n+                    const matchIdx = matchElems.findIndex(tmp_elem =>\n                         typePassesFilter(generic.typeFilter, tmp_elem));\n                     if (matchIdx === -1) {\n                         return false;\n                     }\n-                    elems[match].splice(matchIdx, 1);\n-                    if (elems[match].length === 0) {\n-                        delete elems[match];\n+                    matchElems.splice(matchIdx, 1);\n+                    if (matchElems.length === 0) {\n+                        elems.delete(generic.name);\n                     }\n                     return true;\n                 };\n@@ -1424,22 +1429,22 @@ function initSearch(rawSearchIndex) {\n             const aliases = [];\n             const crateAliases = [];\n             if (filterCrates !== null) {\n-                if (ALIASES[filterCrates] && ALIASES[filterCrates][lowerQuery]) {\n-                    const query_aliases = ALIASES[filterCrates][lowerQuery];\n+                if (ALIASES.has(filterCrates) && ALIASES.get(filterCrates).has(lowerQuery)) {\n+                    const query_aliases = ALIASES.get(filterCrates).get(lowerQuery);\n                     for (const alias of query_aliases) {\n                         aliases.push(createAliasFromItem(searchIndex[alias]));\n                     }\n                 }\n             } else {\n-                Object.keys(ALIASES).forEach(crate => {\n-                    if (ALIASES[crate][lowerQuery]) {\n+                for (const [crate, crateAliasesIndex] of ALIASES) {\n+                    if (crateAliasesIndex.has(lowerQuery)) {\n                         const pushTo = crate === currentCrate ? crateAliases : aliases;\n-                        const query_aliases = ALIASES[crate][lowerQuery];\n+                        const query_aliases = crateAliasesIndex.get(lowerQuery);\n                         for (const alias of query_aliases) {\n                             pushTo.push(createAliasFromItem(searchIndex[alias]));\n                         }\n                     }\n-                });\n+                }\n             }\n \n             const sortFunc = (aaa, bbb) => {\n@@ -1496,19 +1501,19 @@ function initSearch(rawSearchIndex) {\n         function addIntoResults(results, fullId, id, index, dist, path_dist, maxEditDistance) {\n             const inBounds = dist <= maxEditDistance || index !== -1;\n             if (dist === 0 || (!parsedQuery.literalSearch && inBounds)) {\n-                if (results[fullId] !== undefined) {\n-                    const result = results[fullId];\n+                if (results.has(fullId)) {\n+                    const result = results.get(fullId);\n                     if (result.dontValidate || result.dist <= dist) {\n                         return;\n                     }\n                 }\n-                results[fullId] = {\n+                results.set(fullId, {\n                     id: id,\n                     index: index,\n                     dontValidate: parsedQuery.literalSearch,\n                     dist: dist,\n                     path_dist: path_dist,\n-                };\n+                });\n             }\n         }\n \n@@ -2345,17 +2350,22 @@ function initSearch(rawSearchIndex) {\n             }\n \n             if (aliases) {\n-                ALIASES[crate] = Object.create(null);\n+                const currentCrateAliases = new Map();\n+                ALIASES.set(crate, currentCrateAliases);\n                 for (const alias_name in aliases) {\n                     if (!hasOwnPropertyRustdoc(aliases, alias_name)) {\n                         continue;\n                     }\n \n-                    if (!hasOwnPropertyRustdoc(ALIASES[crate], alias_name)) {\n-                        ALIASES[crate][alias_name] = [];\n+                    let currentNameAliases;\n+                    if (currentCrateAliases.has(alias_name)) {\n+                        currentNameAliases = currentCrateAliases.get(alias_name);\n+                    } else {\n+                        currentNameAliases = [];\n+                        currentCrateAliases.set(alias_name, currentNameAliases);\n                     }\n                     for (const local_alias of aliases[alias_name]) {\n-                        ALIASES[crate][alias_name].push(local_alias + currentIndex);\n+                        currentNameAliases.push(local_alias + currentIndex);\n                     }\n                 }\n             }"}]}