{"sha": "f0eb36c2af5cd6b92fafb7ed386f75618958f857", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZWIzNmMyYWY1Y2Q2YjkyZmFmYjdlZDM4NmY3NTYxODk1OGY4NTc=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-11T13:07:21Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-11T13:07:21Z"}, "message": "added parent method, also changed match-if-let note to help", "tree": {"sha": "0e0819095f179fa5d3cbd01ba0606e0e3cf30191", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e0819095f179fa5d3cbd01ba0606e0e3cf30191"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0eb36c2af5cd6b92fafb7ed386f75618958f857", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0eb36c2af5cd6b92fafb7ed386f75618958f857", "html_url": "https://github.com/rust-lang/rust/commit/f0eb36c2af5cd6b92fafb7ed386f75618958f857", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0eb36c2af5cd6b92fafb7ed386f75618958f857/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "228f06a960d761e62f55b432b910642d31e8e26a", "url": "https://api.github.com/repos/rust-lang/rust/commits/228f06a960d761e62f55b432b910642d31e8e26a", "html_url": "https://github.com/rust-lang/rust/commit/228f06a960d761e62f55b432b910642d31e8e26a"}], "stats": {"total": 256, "additions": 139, "deletions": 117}, "files": [{"sha": "0f0405a835ad1eebccfd3230a61cc871d86f2255", "filename": "src/misc.rs", "status": "modified", "additions": 92, "deletions": 89, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/f0eb36c2af5cd6b92fafb7ed386f75618958f857/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0eb36c2af5cd6b92fafb7ed386f75618958f857/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=f0eb36c2af5cd6b92fafb7ed386f75618958f857", "patch": "@@ -7,14 +7,13 @@ use rustc::lint::{Context, LintPass, LintArray, Lint, Level};\n use rustc::middle::ty;\n use syntax::codemap::{Span, Spanned};\n \n-use types::span_note_and_lint;\n-use utils::{match_path, snippet, span_lint};\n+use utils::{match_path, snippet, span_lint, span_help_and_lint};\n \n pub fn walk_ty<'t>(ty: ty::Ty<'t>) -> ty::Ty<'t> {\n-\tmatch ty.sty {\n-\t\tty::TyRef(_, ref tm) | ty::TyRawPtr(ref tm) => walk_ty(tm.ty),\n-\t\t_ => ty\n-\t}\n+    match ty.sty {\n+        ty::TyRef(_, ref tm) | ty::TyRawPtr(ref tm) => walk_ty(tm.ty),\n+        _ => ty\n+    }\n }\n \n /// Handles uncategorized lints\n@@ -42,9 +41,12 @@ impl LintPass for MiscPass {\n                     }\n                     // In some cases, an exhaustive match is preferred to catch situations when\n                     // an enum is extended. So we only consider cases where a `_` wildcard is used\n-                    if arms[1].pats[0].node == PatWild(PatWildSingle) && arms[0].pats.len() == 1 {\n-                        span_note_and_lint(cx, SINGLE_MATCH, expr.span,\n-                              \"You seem to be trying to use match for destructuring a single type. Did you mean to use `if let`?\",\n+                    if arms[1].pats[0].node == PatWild(PatWildSingle) && \n+                            arms[0].pats.len() == 1 {\n+                        span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n+                              \"You seem to be trying to use match for \\\n+                              destructuring a single type. Did you mean to \\\n+                              use `if let`?\",\n                               &*format!(\"Try if let {} = {} {{ ... }}\",\n                                       snippet(cx, arms[0].pats[0].span, \"..\"),\n                                       snippet(cx, ex.span, \"..\"))\n@@ -79,9 +81,9 @@ impl LintPass for StrToStringPass {\n \n         fn is_str(cx: &Context, expr: &ast::Expr) -> bool {\n             match walk_ty(cx.tcx.expr_ty(expr)).sty { \n-\t\t\t\tty::TyStr => true,\n-\t\t\t\t_ => false\n-\t\t\t}\n+                ty::TyStr => true,\n+                _ => false\n+            }\n         }\n     }\n }\n@@ -116,123 +118,124 @@ declare_lint!(pub CMP_NAN, Deny, \"Deny comparisons to std::f32::NAN or std::f64:\n pub struct CmpNan;\n \n impl LintPass for CmpNan {\n-\tfn get_lints(&self) -> LintArray {\n+    fn get_lints(&self) -> LintArray {\n         lint_array!(CMP_NAN)\n-\t}\n-\t\n-\tfn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-\t\tif let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n-\t\t\tif is_comparison_binop(cmp.node) {\n-\t\t\t\tif let &ExprPath(_, ref path) = &left.node {\n-\t\t\t\t\tcheck_nan(cx, path, expr.span);\n-\t\t\t\t}\n-\t\t\t\tif let &ExprPath(_, ref path) = &right.node {\n-\t\t\t\t\tcheck_nan(cx, path, expr.span);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n+    }\n+    \n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n+            if is_comparison_binop(cmp.node) {\n+                if let &ExprPath(_, ref path) = &left.node {\n+                    check_nan(cx, path, expr.span);\n+                }\n+                if let &ExprPath(_, ref path) = &right.node {\n+                    check_nan(cx, path, expr.span);\n+                }\n+            }\n+        }\n+    }\n }\n \n fn check_nan(cx: &Context, path: &Path, span: Span) {\n \tpath.segments.last().map(|seg| if seg.identifier.name == \"NAN\" {\n-\t\tspan_lint(cx, CMP_NAN, span, \"Doomed comparison with NAN, use std::{f32,f64}::is_nan instead\");\n+\t\tspan_lint(cx, CMP_NAN, span, \n+\t\t\t\"Doomed comparison with NAN, use std::{f32,f64}::is_nan instead\");\n \t});\n }\n \n declare_lint!(pub FLOAT_CMP, Warn,\n-\t\t\t  \"Warn on ==/!= comparison of floaty values\");\n-\t\t\t  \n+              \"Warn on ==/!= comparison of floaty values\");\n+              \n #[derive(Copy,Clone)]\n pub struct FloatCmp;\n \n impl LintPass for FloatCmp {\n-\tfn get_lints(&self) -> LintArray {\n+    fn get_lints(&self) -> LintArray {\n         lint_array!(FLOAT_CMP)\n-\t}\n-\t\n-\tfn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-\t\tif let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n-\t\t\tlet op = cmp.node;\n-\t\t\tif (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n-\t\t\t\tspan_lint(cx, FLOAT_CMP, expr.span, &format!(\n-\t\t\t\t\t\"{}-Comparison of f32 or f64 detected. You may want to change this to 'abs({} - {}) < epsilon' for some suitable value of epsilon\",\n-\t\t\t\t\tbinop_to_string(op), snippet(cx, left.span, \"..\"), \n-\t\t\t\t\tsnippet(cx, right.span, \"..\")));\n-\t\t\t}\n-\t\t}\n-\t}\n+    }\n+    \n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n+            let op = cmp.node;\n+            if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n+                span_lint(cx, FLOAT_CMP, expr.span, &format!(\n+                    \"{}-Comparison of f32 or f64 detected. You may want to change this to 'abs({} - {}) < epsilon' for some suitable value of epsilon\",\n+                    binop_to_string(op), snippet(cx, left.span, \"..\"), \n+                    snippet(cx, right.span, \"..\")));\n+            }\n+        }\n+    }\n }\n \n fn is_float(cx: &Context, expr: &Expr) -> bool {\n-\tif let ty::TyFloat(_) = walk_ty(cx.tcx.expr_ty(expr)).sty { \n-\t\ttrue\n-\t} else { \n-\t\tfalse \n-\t}\n+    if let ty::TyFloat(_) = walk_ty(cx.tcx.expr_ty(expr)).sty { \n+        true\n+    } else { \n+        false \n+    }\n }\n \n declare_lint!(pub PRECEDENCE, Warn,\n-\t\t\t  \"Warn on mixing bit ops with integer arithmetic without parenthesis\");\n-\t\t\t  \n+              \"Warn on mixing bit ops with integer arithmetic without parenthesis\");\n+              \n #[derive(Copy,Clone)]\n pub struct Precedence;\n \n impl LintPass for Precedence {\n-\tfn get_lints(&self) -> LintArray {\n+    fn get_lints(&self) -> LintArray {\n         lint_array!(PRECEDENCE)\n-\t}\n-\t\n-\tfn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-\t\tif let ExprBinary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n-\t\t\tif is_bit_op(op) && (is_arith_expr(left) || is_arith_expr(right)) {\n-\t\t\t\tspan_lint(cx, PRECEDENCE, expr.span, \n-\t\t\t\t\t\"Operator precedence can trip the unwary. Consider adding parenthesis to the subexpression.\");\n-\t\t\t}\n-\t\t}\n-\t}\n+    }\n+    \n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        if let ExprBinary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n+            if is_bit_op(op) && (is_arith_expr(left) || is_arith_expr(right)) {\n+                span_lint(cx, PRECEDENCE, expr.span, \n+                    \"Operator precedence can trip the unwary. Consider adding parenthesis to the subexpression.\");\n+            }\n+        }\n+    }\n }\n \n fn is_arith_expr(expr : &Expr) -> bool {\n-\tmatch expr.node {\n-\t\tExprBinary(Spanned { node: op, ..}, _, _) => is_arith_op(op),\n-\t\t_ => false\n-\t}\n+    match expr.node {\n+        ExprBinary(Spanned { node: op, ..}, _, _) => is_arith_op(op),\n+        _ => false\n+    }\n }\n \n fn is_bit_op(op : BinOp_) -> bool {\n-\tmatch op {\n-\t\tBiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr => true,\n-\t\t_ => false\n-\t}\n+    match op {\n+        BiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr => true,\n+        _ => false\n+    }\n }\n \n fn is_arith_op(op : BinOp_) -> bool {\n-\tmatch op {\n-\t\tBiAdd | BiSub | BiMul | BiDiv | BiRem => true,\n-\t\t_ => false\n-\t}\n+    match op {\n+        BiAdd | BiSub | BiMul | BiDiv | BiRem => true,\n+        _ => false\n+    }\n }\n \n declare_lint!(pub CMP_OWNED, Warn,\n-\t\t\t  \"Warn on creating an owned string just for comparison\");\n-\t\t\t  \n+              \"Warn on creating an owned string just for comparison\");\n+              \n #[derive(Copy,Clone)]\n pub struct CmpOwned;\n \n impl LintPass for CmpOwned {\n-\tfn get_lints(&self) -> LintArray {\n+    fn get_lints(&self) -> LintArray {\n         lint_array!(CMP_OWNED)\n-\t}\n-\t\n-\tfn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-\t\tif let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n-\t\t\tif is_comparison_binop(cmp.node) {\n-\t\t\t\tcheck_to_owned(cx, left, right.span);\n-\t\t\t\tcheck_to_owned(cx, right, left.span)\n-\t\t\t}\n-\t\t}\n-\t}\n+    }\n+    \n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n+            if is_comparison_binop(cmp.node) {\n+                check_to_owned(cx, left, right.span);\n+                check_to_owned(cx, right, left.span)\n+            }\n+        }\n+    }\n }\n \n fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n@@ -263,6 +266,6 @@ fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n }\n \n fn is_str_arg(cx: &Context, args: &[P<Expr>]) -> bool {\n-\targs.len() == 1 && if let ty::TyStr = \n-\t\twalk_ty(cx.tcx.expr_ty(&*args[0])).sty { true } else { false }\n+    args.len() == 1 && if let ty::TyStr = \n+        walk_ty(cx.tcx.expr_ty(&*args[0])).sty { true } else { false }\n }"}, {"sha": "a231171aee509a6005dbfab3b1cf39ab3fad20ac", "filename": "src/utils.rs", "status": "modified", "additions": 45, "deletions": 26, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f0eb36c2af5cd6b92fafb7ed386f75618958f857/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0eb36c2af5cd6b92fafb7ed386f75618958f857/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=f0eb36c2af5cd6b92fafb7ed386f75618958f857", "patch": "@@ -1,67 +1,86 @@\n-use rustc::lint::{Context, Lint};\n-use syntax::ast::{DefId, Name, Path};\n+use rustc::lint::{Context, Lint, Level};\n+use syntax::ast::{DefId, Expr, Name, NodeId, Path};\n use syntax::codemap::{ExpnInfo, Span};\n use syntax::ptr::P;\n+use rustc::ast_map::Node::NodeExpr;\n use rustc::middle::ty;\n use std::borrow::{Cow, IntoCow};\n use std::convert::From;\n \n /// returns true if the macro that expanded the crate was outside of\n /// the current crate or was a compiler plugin\n pub fn in_macro(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n-\t// no ExpnInfo = no macro\n-\topt_info.map_or(false, |info| {\n-\t\t// no span for the callee = external macro\n-\t\tinfo.callee.span.map_or(true, |span| {\n-\t\t\t// no snippet = external macro or compiler-builtin expansion\n-\t\t\tcx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code| \n-\t\t\t\t// macro doesn't start with \"macro_rules\"\n-\t\t\t\t// = compiler plugin\n-\t\t\t\t!code.starts_with(\"macro_rules\")\n-\t\t\t)\n-\t\t})\n-\t})\n+    // no ExpnInfo = no macro\n+    opt_info.map_or(false, |info| {\n+        // no span for the callee = external macro\n+        info.callee.span.map_or(true, |span| {\n+            // no snippet = external macro or compiler-builtin expansion\n+            cx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code| \n+                // macro doesn't start with \"macro_rules\"\n+                // = compiler plugin\n+                !code.starts_with(\"macro_rules\")\n+            )\n+        })\n+    })\n }\n \n /// invokes in_macro with the expansion info of the given span\n pub fn in_external_macro(cx: &Context, span: Span) -> bool {\n-\tcx.sess().codemap().with_expn_info(span.expn_id, \n-\t\t\t|info| in_macro(cx, info))\n+    cx.sess().codemap().with_expn_info(span.expn_id, \n+            |info| in_macro(cx, info))\n }\n \n /// check if a DefId's path matches the given absolute type path\n /// usage e.g. with\n /// `match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])`\n pub fn match_def_path(cx: &Context, def_id: DefId, path: &[&str]) -> bool {\n-\tcx.tcx.with_path(def_id, |iter| iter.map(|elem| elem.name())\n-\t\t.zip(path.iter()).all(|(nm, p)| &nm.as_str() == p))\n+    cx.tcx.with_path(def_id, |iter| iter.map(|elem| elem.name())\n+        .zip(path.iter()).all(|(nm, p)| &nm.as_str() == p))\n }\n \n /// match a Path against a slice of segment string literals, e.g.\n /// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n-\tpath.segments.iter().rev().zip(segments.iter().rev()).all(\n-\t\t|(a,b)| &a.identifier.name.as_str() == b)\n+    path.segments.iter().rev().zip(segments.iter().rev()).all(\n+        |(a,b)| &a.identifier.name.as_str() == b)\n }\n \n /// convert a span to a code snippet if available, otherwise use default, e.g.\n /// `snippet(cx, expr.span, \"..\")`\n pub fn snippet<'a>(cx: &Context, span: Span, default: &'a str) -> Cow<'a, str> {\n-\tcx.sess().codemap().span_to_snippet(span).map(From::from).unwrap_or(Cow::Borrowed(default))\n+    cx.sess().codemap().span_to_snippet(span).map(From::from).unwrap_or(Cow::Borrowed(default))\n+}\n+\n+/// get a parent expr if any \u2013 this is useful to constrain a lint\n+pub fn get_parent_expr<'c>(cx: &'c Context, e: &Expr) -> Option<&'c Expr> {\n+    let map = &cx.tcx.map;\n+    let node_id : NodeId = e.id;\n+    let parent_id : NodeId = map.get_parent_node(node_id);\n+    if node_id == parent_id { return None; }\n+    map.find(parent_id).and_then(|node| \n+        if let NodeExpr(parent) = node { Some(parent) } else { None } )\n }\n \n /// dereference a P<T> and return a ref on the result\n pub fn de_p<T>(p: &P<T>) -> &T { &*p }\n \n #[cfg(not(feature=\"structured_logging\"))]\n pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n-\tcx.span_lint(lint, sp, msg);\n+    cx.span_lint(lint, sp, msg);\n }\n \n #[cfg(feature=\"structured_logging\")]\n pub fn span_lint(cx: &Context, lint: &'static Lint, sp: Span, msg: &str) {\n-\t// lint.name / lint.desc is can give details of the lint\n-\t// cx.sess().codemap() has all these nice functions for line/column/snippet details\n-\t// http://doc.rust-lang.org/syntax/codemap/struct.CodeMap.html#method.span_to_string\n-\tcx.span_lint(lint, sp, msg);\n+    // lint.name / lint.desc is can give details of the lint\n+    // cx.sess().codemap() has all these nice functions for line/column/snippet details\n+    // http://doc.rust-lang.org/syntax/codemap/struct.CodeMap.html#method.span_to_string\n+    cx.span_lint(lint, sp, msg);\n+}\n+\n+pub fn span_help_and_lint(cx: &Context, lint: &'static Lint, span: Span, \n+        msg: &str, help: &str) {\n+    span_lint(cx, lint, span, msg);\n+    if cx.current_level(lint) != Level::Allow {\n+        cx.sess().span_help(span, help);\n+    }\n }"}, {"sha": "f1864f9d7f759c086c0dfc3da908e700169a6d78", "filename": "tests/compile-fail/match_if_let.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0eb36c2af5cd6b92fafb7ed386f75618958f857/tests%2Fcompile-fail%2Fmatch_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0eb36c2af5cd6b92fafb7ed386f75618958f857/tests%2Fcompile-fail%2Fmatch_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatch_if_let.rs?ref=f0eb36c2af5cd6b92fafb7ed386f75618958f857", "patch": "@@ -6,7 +6,7 @@\n fn main(){\n     let x = Some(1u8);\n     match x {  //~ ERROR You seem to be trying to use match\n-               //~^ NOTE Try if let Some(y) = x { ... }\n+               //~^ HELP Try if let Some(y) = x { ... }\n         Some(y) => println!(\"{:?}\", y),\n         _ => ()\n     }\n@@ -17,7 +17,7 @@ fn main(){\n     }\n     let z = (1u8,1u8);\n     match z { //~ ERROR You seem to be trying to use match\n-              //~^ NOTE Try if let (2...3, 7...9) = z { ... }\n+              //~^ HELP Try if let (2...3, 7...9) = z { ... }\n         (2...3, 7...9) => println!(\"{:?}\", z),\n         _ => {}\n     }"}]}