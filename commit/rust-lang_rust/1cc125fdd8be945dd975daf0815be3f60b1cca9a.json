{"sha": "1cc125fdd8be945dd975daf0815be3f60b1cca9a", "node_id": "C_kwDOAAsO6NoAKDFjYzEyNWZkZDhiZTk0NWRkOTc1ZGFmMDgxNWJlM2Y2MGIxY2NhOWE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-31T15:22:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-31T15:22:42Z"}, "message": "Merge #11291\n\n11291: internal: Make more precise range macro upmapping r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "9a17effef314480f431ddd98323ce329acd9e96a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a17effef314480f431ddd98323ce329acd9e96a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cc125fdd8be945dd975daf0815be3f60b1cca9a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh9/7CCRBK7hj4Ov3rIwAAvsoIAI0AwEOmhHoQY+fs/GB+1XWJ\njN2X9gPaBpUzLUQ/FsArwaS6qooEDeMNpmHjAETO8r0Cjl8Z83RLSDXdpRucUyZa\nC5L8cY6f1qrOGcc/s1PzcRctH3vI0qV71ZOgymaOeT6IIGx09GyIKQo3+5Lb0IRU\nds7oRO+izVWBr33KKLj4uNo2bX2q1GJe9jhK9nyL3uJoNn/j9OGQ5ao/I9i/nE0i\nWBN95K3ZXgVih0jEBtXS2GyyF3FDmmNoa4bMlfVOir5uqXGn2JppIGb2Z7ELO1Tr\nIuzI9lqLBHKJIHuCrzLHyB1+8RhKmy0C17Iwo0S3c1uD4YdtCvlz9PnOD+Ed8zQ=\n=pkPm\n-----END PGP SIGNATURE-----\n", "payload": "tree 9a17effef314480f431ddd98323ce329acd9e96a\nparent 0808ade4e43157f96ddaca8fa39f436038c3ede0\nparent 45ff51ba2206c50be7b79ec2817bb8c5a66d9b5c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1643642562 +0000\ncommitter GitHub <noreply@github.com> 1643642562 +0000\n\nMerge #11291\n\n11291: internal: Make more precise range macro upmapping r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cc125fdd8be945dd975daf0815be3f60b1cca9a", "html_url": "https://github.com/rust-lang/rust/commit/1cc125fdd8be945dd975daf0815be3f60b1cca9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cc125fdd8be945dd975daf0815be3f60b1cca9a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0808ade4e43157f96ddaca8fa39f436038c3ede0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0808ade4e43157f96ddaca8fa39f436038c3ede0", "html_url": "https://github.com/rust-lang/rust/commit/0808ade4e43157f96ddaca8fa39f436038c3ede0"}, {"sha": "45ff51ba2206c50be7b79ec2817bb8c5a66d9b5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/45ff51ba2206c50be7b79ec2817bb8c5a66d9b5c", "html_url": "https://github.com/rust-lang/rust/commit/45ff51ba2206c50be7b79ec2817bb8c5a66d9b5c"}], "stats": {"total": 160, "additions": 81, "deletions": 79}, "files": [{"sha": "e3ff05b49afb8a70cc28651bdd49a1d218b1ff13", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1cc125fdd8be945dd975daf0815be3f60b1cca9a/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc125fdd8be945dd975daf0815be3f60b1cca9a/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=1cc125fdd8be945dd975daf0815be3f60b1cca9a", "patch": "@@ -219,14 +219,20 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.find_file(syntax_node).file_id\n     }\n \n+    /// Attempts to map the node out of macro expanded files returning the original file range.\n+    /// If upmapping is not possible, this will fall back to the range of the macro call of the\n+    /// macro file the node resides in.\n     pub fn original_range(&self, node: &SyntaxNode) -> FileRange {\n         self.imp.original_range(node)\n     }\n \n+    /// Attempts to map the node out of macro expanded files returning the original file range.\n     pub fn original_range_opt(&self, node: &SyntaxNode) -> Option<FileRange> {\n         self.imp.original_range_opt(node)\n     }\n \n+    /// Attempts to map the node out of macro expanded files.\n+    /// This only work for attribute expansions, as other ones do not have nodes as input.\n     pub fn original_ast_node<N: AstNode>(&self, node: N) -> Option<N> {\n         self.imp.original_ast_node(node)\n     }\n@@ -445,7 +451,7 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn expand_attr_macro(&self, item: &ast::Item) -> Option<SyntaxNode> {\n-        let src = self.find_file(item.syntax()).with_value(item.clone());\n+        let src = self.wrap_node_infile(item.clone());\n         let macro_call_id = self.with_ctx(|ctx| ctx.item_to_macro_call(src))?;\n         let file_id = macro_call_id.as_file();\n         let node = self.parse_or_expand(file_id)?;\n@@ -519,8 +525,7 @@ impl<'db> SemanticsImpl<'db> {\n         speculative_args: &ast::Item,\n         token_to_map: SyntaxToken,\n     ) -> Option<(SyntaxNode, SyntaxToken)> {\n-        let file_id = self.find_file(actual_macro_call.syntax()).file_id;\n-        let macro_call = InFile::new(file_id, actual_macro_call.clone());\n+        let macro_call = self.wrap_node_infile(actual_macro_call.clone());\n         let macro_call_id = self.with_ctx(|ctx| ctx.item_to_macro_call(macro_call))?;\n         hir_expand::db::expand_speculative(\n             self.db.upcast(),\n@@ -740,8 +745,7 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn original_ast_node<N: AstNode>(&self, node: N) -> Option<N> {\n-        let InFile { file_id, .. } = self.find_file(node.syntax());\n-        InFile::new(file_id, node).original_ast_node(self.db.upcast()).map(|it| it.value)\n+        self.wrap_node_infile(node).original_ast_node(self.db.upcast()).map(|it| it.value)\n     }\n \n     fn diagnostics_display_range(&self, src: InFile<SyntaxNodePtr>) -> FileRange {\n@@ -792,8 +796,7 @@ impl<'db> SemanticsImpl<'db> {\n             gpl.lifetime_params()\n                 .find(|tp| tp.lifetime().as_ref().map(|lt| lt.text()).as_ref() == Some(&text))\n         })?;\n-        let file_id = self.find_file(lifetime_param.syntax()).file_id;\n-        let src = InFile::new(file_id, lifetime_param);\n+        let src = self.wrap_node_infile(lifetime_param);\n         ToDef::to_def(self, src)\n     }\n \n@@ -815,8 +818,7 @@ impl<'db> SemanticsImpl<'db> {\n                     .map_or(false, |lt| lt.text() == text)\n             })\n         })?;\n-        let file_id = self.find_file(label.syntax()).file_id;\n-        let src = InFile::new(file_id, label);\n+        let src = self.wrap_node_infile(label);\n         ToDef::to_def(self, src)\n     }\n \n@@ -880,7 +882,7 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn resolve_attr_macro_call(&self, item: &ast::Item) -> Option<MacroDef> {\n-        let item_in_file = self.find_file(item.syntax()).with_value(item.clone());\n+        let item_in_file = self.wrap_node_infile(item.clone());\n         let macro_call_id = self.with_ctx(|ctx| ctx.item_to_macro_call(item_in_file))?;\n         Some(MacroDef { id: self.db.lookup_intern_macro_call(macro_call_id).def })\n     }\n@@ -1080,6 +1082,11 @@ impl<'db> SemanticsImpl<'db> {\n         cache.get(root_node).copied()\n     }\n \n+    fn wrap_node_infile<N: AstNode>(&self, node: N) -> InFile<N> {\n+        let InFile { file_id, .. } = self.find_file(node.syntax());\n+        InFile::new(file_id, node)\n+    }\n+\n     fn find_file<'node>(&self, node: &'node SyntaxNode) -> InFile<&'node SyntaxNode> {\n         let root_node = find_root(node);\n         let file_id = self.lookup(&root_node).unwrap_or_else(|| {"}, {"sha": "857c9e0ed9fb89ef68531e33dde0fd055c79965d", "filename": "crates/hir/src/symbols.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1cc125fdd8be945dd975daf0815be3f60b1cca9a/crates%2Fhir%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc125fdd8be945dd975daf0815be3f60b1cca9a/crates%2Fhir%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsymbols.rs?ref=1cc125fdd8be945dd975daf0815be3f60b1cca9a", "patch": "@@ -39,24 +39,24 @@ impl DeclarationLocation {\n     }\n \n     pub fn original_range(&self, db: &dyn HirDatabase) -> Option<FileRange> {\n-        find_original_file_range(db, self.hir_file_id, &self.ptr)\n+        let node = resolve_node(db, self.hir_file_id, &self.ptr)?;\n+        Some(node.as_ref().original_file_range(db.upcast()))\n     }\n \n     pub fn original_name_range(&self, db: &dyn HirDatabase) -> Option<FileRange> {\n-        find_original_file_range(db, self.hir_file_id, &self.name_ptr)\n+        let node = resolve_node(db, self.hir_file_id, &self.name_ptr)?;\n+        node.as_ref().original_file_range_opt(db.upcast())\n     }\n }\n \n-fn find_original_file_range(\n+fn resolve_node(\n     db: &dyn HirDatabase,\n     file_id: HirFileId,\n     ptr: &SyntaxNodePtr,\n-) -> Option<FileRange> {\n+) -> Option<InFile<SyntaxNode>> {\n     let root = db.parse_or_expand(file_id)?;\n     let node = ptr.to_node(&root);\n-    let node = InFile::new(file_id, &node);\n-\n-    Some(node.original_file_range(db.upcast()))\n+    Some(InFile::new(file_id, node))\n }\n \n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]"}, {"sha": "580a1225cb2ceb2356a2a409e1687d49c2e7b6fb", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1cc125fdd8be945dd975daf0815be3f60b1cca9a/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc125fdd8be945dd975daf0815be3f60b1cca9a/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=1cc125fdd8be945dd975daf0815be3f60b1cca9a", "patch": "@@ -705,24 +705,14 @@ fn ascend_node_border_tokens(\n ) -> Option<InFile<(SyntaxToken, SyntaxToken)>> {\n     let expansion = file_id.expansion_info(db)?;\n \n-    // the input node has only one token ?\n-    let first = skip_trivia_token(node.first_token()?, Direction::Next)?;\n-    let last = skip_trivia_token(node.last_token()?, Direction::Prev)?;\n-    let is_single_token = first == last;\n-\n-    node.descendants().find_map(|it| {\n-        let first = skip_trivia_token(it.first_token()?, Direction::Next)?;\n-        let first = ascend_call_token(db, &expansion, InFile::new(file_id, first))?;\n-\n-        let last = skip_trivia_token(it.last_token()?, Direction::Prev)?;\n-        let last = ascend_call_token(db, &expansion, InFile::new(file_id, last))?;\n-\n-        if (!is_single_token && first == last) || (first.file_id != last.file_id) {\n-            return None;\n-        }\n-\n-        Some(InFile::new(first.file_id, (first.value, last.value)))\n-    })\n+    let first_token = |node: &SyntaxNode| skip_trivia_token(node.first_token()?, Direction::Next);\n+    let last_token = |node: &SyntaxNode| skip_trivia_token(node.last_token()?, Direction::Prev);\n+\n+    let first = first_token(node)?;\n+    let last = last_token(node)?;\n+    let first = ascend_call_token(db, &expansion, InFile::new(file_id, first))?;\n+    let last = ascend_call_token(db, &expansion, InFile::new(file_id, last))?;\n+    (first.file_id == last.file_id).then(|| InFile::new(first.file_id, (first.value, last.value)))\n }\n \n fn ascend_call_token(\n@@ -758,20 +748,28 @@ impl<N: AstNode> InFile<N> {\n     }\n \n     pub fn original_ast_node(self, db: &dyn db::AstDatabase) -> Option<InFile<N>> {\n-        match ascend_node_border_tokens(db, self.syntax()) {\n-            Some(InFile { file_id, value: (first, last) }) => {\n-                let original_file = file_id.original_file(db);\n-                if file_id != original_file.into() {\n-                    let range = first.text_range().cover(last.text_range());\n-                    tracing::error!(\"Failed mapping up more for {:?}\", range);\n-                    return None;\n-                }\n-                let anc = algo::least_common_ancestor(&first.parent()?, &last.parent()?)?;\n-                Some(InFile::new(file_id, anc.ancestors().find_map(N::cast)?))\n+        // This kind of upmapping can only be achieved in attribute expanded files,\n+        // as we don't have node inputs otherwise and  therefor can't find an `N` node in the input\n+        if !self.file_id.is_macro() {\n+            return Some(self);\n+        } else if !self.file_id.is_attr_macro(db) {\n+            return None;\n+        }\n+\n+        if let Some(InFile { file_id, value: (first, last) }) =\n+            ascend_node_border_tokens(db, self.syntax())\n+        {\n+            if file_id.is_macro() {\n+                let range = first.text_range().cover(last.text_range());\n+                tracing::error!(\"Failed mapping out of macro file for {:?}\", range);\n+                return None;\n             }\n-            _ if !self.file_id.is_macro() => Some(self),\n-            _ => None,\n+            // FIXME: This heuristic is brittle and with the right macro may select completely unrelated nodes\n+            let anc = algo::least_common_ancestor(&first.parent()?, &last.parent()?)?;\n+            let value = anc.ancestors().find_map(N::cast)?;\n+            return Some(InFile::new(file_id, value));\n         }\n+        None\n     }\n \n     pub fn syntax(&self) -> InFile<&SyntaxNode> {"}, {"sha": "21ff480df416073f69f8ebfe329a81ed63537ec1", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1cc125fdd8be945dd975daf0815be3f60b1cca9a/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc125fdd8be945dd975daf0815be3f60b1cca9a/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=1cc125fdd8be945dd975daf0815be3f60b1cca9a", "patch": "@@ -146,9 +146,10 @@ pub(crate) fn hover(\n         if let Some(res) = render::keyword(sema, config, &original_token) {\n             return Some(RangeInfo::new(original_token.text_range(), res));\n         }\n-        if let res @ Some(_) =\n-            descended.iter().find_map(|token| hover_type_fallback(sema, config, token))\n-        {\n+        let res = descended\n+            .iter()\n+            .find_map(|token| hover_type_fallback(sema, config, token, &original_token));\n+        if let res @ Some(_) = res {\n             return res;\n         }\n     }\n@@ -230,6 +231,7 @@ fn hover_type_fallback(\n     sema: &Semantics<RootDatabase>,\n     config: &HoverConfig,\n     token: &SyntaxToken,\n+    original_token: &SyntaxToken,\n ) -> Option<RangeInfo<HoverResult>> {\n     let node = token\n         .ancestors()\n@@ -248,7 +250,10 @@ fn hover_type_fallback(\n     };\n \n     let res = render::type_info(sema, config, &expr_or_pat)?;\n-    let range = sema.original_range(&node).range;\n+    let range = sema\n+        .original_range_opt(&node)\n+        .map(|frange| frange.range)\n+        .unwrap_or_else(|| original_token.text_range());\n     Some(RangeInfo::new(range, res))\n }\n "}, {"sha": "dd4c17df29f74ca11fab6f481e4d6811fdeb3c4c", "filename": "crates/ide/src/navigation_target.rs", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1cc125fdd8be945dd975daf0815be3f60b1cca9a/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc125fdd8be945dd975daf0815be3f60b1cca9a/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fnavigation_target.rs?ref=1cc125fdd8be945dd975daf0815be3f60b1cca9a", "patch": "@@ -14,7 +14,7 @@ use ide_db::{\n use ide_db::{defs::Definition, RootDatabase};\n use syntax::{\n     ast::{self, HasName},\n-    match_ast, AstNode, SmolStr, TextRange,\n+    match_ast, AstNode, SmolStr, SyntaxNode, TextRange,\n };\n \n /// `NavigationTarget` represents an element in the editor's UI which you can\n@@ -90,10 +90,8 @@ impl NavigationTarget {\n         let name = module.name(db).map(|it| it.to_smol_str()).unwrap_or_default();\n         if let Some(src @ InFile { value, .. }) = &module.declaration_source(db) {\n             let FileRange { file_id, range: full_range } = src.syntax().original_file_range(db);\n-            let focus_range = value\n-                .name()\n-                .and_then(|name| src.with_value(name.syntax()).original_file_range_opt(db))\n-                .map(|it| it.range);\n+            let focus_range =\n+                value.name().and_then(|it| orig_focus_range(db, src.file_id, it.syntax()));\n             let mut res = NavigationTarget::from_syntax(\n                 file_id,\n                 name,\n@@ -129,15 +127,11 @@ impl NavigationTarget {\n     /// Allows `NavigationTarget` to be created from a `NameOwner`\n     pub(crate) fn from_named(\n         db: &RootDatabase,\n-        node: InFile<&dyn ast::HasName>,\n+        node @ InFile { file_id, value }: InFile<&dyn ast::HasName>,\n         kind: SymbolKind,\n     ) -> NavigationTarget {\n-        let name = node.value.name().map(|it| it.text().into()).unwrap_or_else(|| \"_\".into());\n-        let focus_range = node\n-            .value\n-            .name()\n-            .and_then(|it| node.with_value(it.syntax()).original_file_range_opt(db))\n-            .map(|it| it.range);\n+        let name = value.name().map(|it| it.text().into()).unwrap_or_else(|| \"_\".into());\n+        let focus_range = value.name().and_then(|it| orig_focus_range(db, file_id, it.syntax()));\n         let FileRange { file_id, range } = node.map(|it| it.syntax()).original_file_range(db);\n \n         NavigationTarget::from_syntax(file_id, name, focus_range, range, kind)\n@@ -279,9 +273,7 @@ impl ToNav for hir::Module {\n             ModuleSource::SourceFile(node) => (node.syntax(), None),\n             ModuleSource::Module(node) => (\n                 node.syntax(),\n-                node.name()\n-                    .and_then(|it| InFile::new(file_id, it.syntax()).original_file_range_opt(db))\n-                    .map(|it| it.range),\n+                node.name().and_then(|it| orig_focus_range(db, file_id, it.syntax())),\n             ),\n             ModuleSource::BlockExpr(node) => (node.syntax(), None),\n         };\n@@ -299,10 +291,7 @@ impl TryToNav for hir::Impl {\n         let focus_range = if derive_attr.is_some() {\n             None\n         } else {\n-            value\n-                .self_ty()\n-                .and_then(|ty| InFile::new(file_id, ty.syntax()).original_file_range_opt(db))\n-                .map(|it| it.range)\n+            value.self_ty().and_then(|ty| orig_focus_range(db, file_id, ty.syntax()))\n         };\n \n         let FileRange { file_id, range: full_range } = match &derive_attr {\n@@ -397,9 +386,7 @@ impl ToNav for hir::Local {\n             Either::Left(bind_pat) => (bind_pat.syntax(), bind_pat.name()),\n             Either::Right(it) => (it.syntax(), it.name()),\n         };\n-        let focus_range = name\n-            .and_then(|it| InFile::new(file_id, it.syntax()).original_file_range_opt(db))\n-            .map(|it| it.range);\n+        let focus_range = name.and_then(|it| orig_focus_range(db, file_id, it.syntax()));\n         let FileRange { file_id, range: full_range } =\n             InFile::new(file_id, node).original_file_range(db);\n \n@@ -505,10 +492,7 @@ impl TryToNav for hir::ConstParam {\n         let InFile { file_id, value } = self.source(db)?;\n         let name = self.name(db).to_smol_str();\n \n-        let focus_range = value\n-            .name()\n-            .and_then(|it| InFile::new(file_id, it.syntax()).original_file_range_opt(db))\n-            .map(|it| it.range);\n+        let focus_range = value.name().and_then(|it| orig_focus_range(db, file_id, it.syntax()));\n         let FileRange { file_id, range: full_range } =\n             InFile::new(file_id, value.syntax()).original_file_range(db);\n         Some(NavigationTarget {\n@@ -549,6 +533,14 @@ pub(crate) fn description_from_symbol(db: &RootDatabase, symbol: &FileSymbol) ->\n     }\n }\n \n+fn orig_focus_range(\n+    db: &RootDatabase,\n+    file_id: hir::HirFileId,\n+    syntax: &SyntaxNode,\n+) -> Option<TextRange> {\n+    InFile::new(file_id, syntax).original_file_range_opt(db).map(|it| it.range)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use expect_test::expect;"}, {"sha": "0f7855a053e115a43280b7ac6e9ab0426f5ae1c2", "filename": "crates/syntax/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cc125fdd8be945dd975daf0815be3f60b1cca9a/crates%2Fsyntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc125fdd8be945dd975daf0815be3f60b1cca9a/crates%2Fsyntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Flib.rs?ref=1cc125fdd8be945dd975daf0815be3f60b1cca9a", "patch": "@@ -187,10 +187,10 @@ macro_rules! match_ast {\n     (match $node:ident { $($tt:tt)* }) => { match_ast!(match ($node) { $($tt)* }) };\n \n     (match ($node:expr) {\n-        $( ast::$ast:ident($it:pat) => $res:expr, )*\n+        $( $( $path:ident )::+ ($it:pat) => $res:expr, )*\n         _ => $catch_all:expr $(,)?\n     }) => {{\n-        $( if let Some($it) = ast::$ast::cast($node.clone()) { $res } else )*\n+        $( if let Some($it) = $($path::)+cast($node.clone()) { $res } else )*\n         { $catch_all }\n     }};\n }"}]}