{"sha": "a78030fbaa8d4196f7a60851aacfd9f7ed57d7db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ODAzMGZiYWE4ZDQxOTZmN2E2MDg1MWFhY2ZkOWY3ZWQ1N2Q3ZGI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-16T00:10:23Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-16T00:11:13Z"}, "message": "libsyntax: Parse tuple and unit structs", "tree": {"sha": "d0cdc1b8f696aa131b669159e83f958a9cf0b791", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0cdc1b8f696aa131b669159e83f958a9cf0b791"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a78030fbaa8d4196f7a60851aacfd9f7ed57d7db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a78030fbaa8d4196f7a60851aacfd9f7ed57d7db", "html_url": "https://github.com/rust-lang/rust/commit/a78030fbaa8d4196f7a60851aacfd9f7ed57d7db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a78030fbaa8d4196f7a60851aacfd9f7ed57d7db/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "913f7bdae744f88110eaca73fb28e4b8e987456c", "url": "https://api.github.com/repos/rust-lang/rust/commits/913f7bdae744f88110eaca73fb28e4b8e987456c", "html_url": "https://github.com/rust-lang/rust/commit/913f7bdae744f88110eaca73fb28e4b8e987456c"}], "stats": {"total": 121, "additions": 77, "deletions": 44}, "files": [{"sha": "9407f904bf7d8226ceac4ae0e917d0c2d5d3ca10", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 72, "deletions": 44, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/a78030fbaa8d4196f7a60851aacfd9f7ed57d7db/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78030fbaa8d4196f7a60851aacfd9f7ed57d7db/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a78030fbaa8d4196f7a60851aacfd9f7ed57d7db", "patch": "@@ -53,10 +53,11 @@ import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              ty_infer, ty_mac, ty_method, ty_nil, ty_param, ty_param_bound,\n              ty_path, ty_ptr, ty_rec, ty_rptr, ty_tup, ty_u32, ty_uniq,\n              ty_vec, ty_fixed_length, tuple_variant_kind, unchecked_blk, uniq,\n-             unsafe_blk, unsafe_fn, variant, view_item, view_item_,\n-             view_item_export, view_item_import, view_item_use, view_path,\n-             view_path_glob, view_path_list, view_path_simple, visibility,\n-             vstore, vstore_box, vstore_fixed, vstore_slice, vstore_uniq};\n+             unnamed_field, unsafe_blk, unsafe_fn, variant, view_item,\n+             view_item_, view_item_export, view_item_import, view_item_use,\n+             view_path, view_path_glob, view_path_list, view_path_simple,\n+             visibility, vstore, vstore_box, vstore_fixed, vstore_slice,\n+             vstore_uniq};\n \n export file_type;\n export parser;\n@@ -2563,61 +2564,88 @@ class parser {\n         let traits : ~[@trait_ref] = if self.eat(token::COLON)\n             { self.parse_trait_ref_list(token::LBRACE) }\n         else { ~[] };\n-        self.expect(token::LBRACE);\n-        let mut fields: ~[@struct_field] = ~[];\n+\n+        let mut fields: ~[@struct_field];\n         let mut methods: ~[@method] = ~[];\n+        let mut the_ctor: option<(fn_decl, ~[attribute], blk, codemap::span)>\n+            = none;\n+        let mut the_dtor: option<(blk, ~[attribute], codemap::span)> = none;\n         let ctor_id = self.get_id();\n-        let mut the_ctor : option<(fn_decl, ~[attribute], blk,\n-                                   codemap::span)> = none;\n-        let mut the_dtor : option<(blk, ~[attribute], codemap::span)> = none;\n-        while self.token != token::RBRACE {\n-            match self.parse_class_item(class_path) {\n-              ctor_decl(a_fn_decl, attrs, blk, s) => {\n-                  match the_ctor {\n-                    some((_, _, _, s_first)) => {\n-                      self.span_note(s, #fmt(\"Duplicate constructor \\\n-                                   declaration for class %s\", *class_name));\n-                       self.span_fatal(copy s_first, ~\"First constructor \\\n-                                                      declared here\");\n-                    }\n-                    none    => {\n-                      the_ctor = some((a_fn_decl, attrs, blk, s));\n-                    }\n+\n+        if self.eat(token::LBRACE) {\n+            // It's a record-like struct.\n+            fields = ~[];\n+            while self.token != token::RBRACE {\n+                match self.parse_class_item(class_path) {\n+                  ctor_decl(a_fn_decl, attrs, blk, s) => {\n+                      match the_ctor {\n+                        some((_, _, _, s_first)) => {\n+                          self.span_note(s, #fmt(\"Duplicate constructor \\\n+                                       declaration for class %s\", *class_name));\n+                           self.span_fatal(copy s_first, ~\"First constructor \\\n+                                                          declared here\");\n+                        }\n+                        none    => {\n+                          the_ctor = some((a_fn_decl, attrs, blk, s));\n+                        }\n+                      }\n                   }\n-              }\n-              dtor_decl(blk, attrs, s) => {\n-                  match the_dtor {\n-                    some((_, _, s_first)) => {\n-                      self.span_note(s, #fmt(\"Duplicate destructor \\\n-                                    declaration for class %s\", *class_name));\n-                      self.span_fatal(copy s_first, ~\"First destructor \\\n-                                                      declared here\");\n-                    }\n-                    none => {\n-                      the_dtor = some((blk, attrs, s));\n-                    }\n+                  dtor_decl(blk, attrs, s) => {\n+                      match the_dtor {\n+                        some((_, _, s_first)) => {\n+                          self.span_note(s, #fmt(\"Duplicate destructor \\\n+                                        declaration for class %s\", *class_name));\n+                          self.span_fatal(copy s_first, ~\"First destructor \\\n+                                                          declared here\");\n+                        }\n+                        none => {\n+                          the_dtor = some((blk, attrs, s));\n+                        }\n+                      }\n                   }\n-              }\n-              members(mms) => {\n-                for mms.each |mm| {\n-                    match mm {\n-                        @field_member(struct_field) =>\n-                            vec::push(fields, struct_field),\n-                        @method_member(the_method_member) =>\n-                            vec::push(methods, the_method_member)\n+                  members(mms) => {\n+                    for mms.each |mm| {\n+                        match mm {\n+                            @field_member(struct_field) =>\n+                                vec::push(fields, struct_field),\n+                            @method_member(the_method_member) =>\n+                                vec::push(methods, the_method_member)\n+                        }\n                     }\n+                  }\n                 }\n-              }\n             }\n+            self.bump();\n+        } else if self.token == token::LPAREN {\n+            // It's a tuple-like struct.\n+            fields = do self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n+                                                 seq_sep_trailing_allowed\n+                                                    (token::COMMA)) |p| {\n+                let lo = p.span.lo;\n+                let struct_field_ = {\n+                    kind: unnamed_field,\n+                    id: self.get_id(),\n+                    ty: p.parse_ty(false)\n+                };\n+                @spanned(lo, p.span.hi, struct_field_)\n+            };\n+            self.expect(token::SEMI);\n+        } else if self.eat(token::SEMI) {\n+            // It's a unit-like struct.\n+            fields = ~[];\n+        } else {\n+            self.fatal(fmt!(\"expected `{`, `(`, or `;` after struct name \\\n+                             but found `%s`\",\n+                            token_to_str(self.reader, self.token)));\n         }\n+\n         let actual_dtor = do option::map(the_dtor) |dtor| {\n             let (d_body, d_attrs, d_s) = dtor;\n             {node: {id: self.get_id(),\n                     attrs: d_attrs,\n                     self_id: self.get_id(),\n                     body: d_body},\n              span: d_s}};\n-        self.bump();\n         match the_ctor {\n           some((ct_d, ct_attrs, ct_b, ct_s)) => {\n             (class_name,"}, {"sha": "e054f441a1217e4e9b68708a339639b00b12dada", "filename": "src/test/run-pass/tuple-struct-trivial.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a78030fbaa8d4196f7a60851aacfd9f7ed57d7db/src%2Ftest%2Frun-pass%2Ftuple-struct-trivial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a78030fbaa8d4196f7a60851aacfd9f7ed57d7db/src%2Ftest%2Frun-pass%2Ftuple-struct-trivial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftuple-struct-trivial.rs?ref=a78030fbaa8d4196f7a60851aacfd9f7ed57d7db", "patch": "@@ -0,0 +1,5 @@\n+struct Foo(int, int, int);\n+\n+fn main() {\n+}\n+"}]}