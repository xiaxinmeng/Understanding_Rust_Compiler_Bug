{"sha": "b573e10d21b69ebfadf41aa9c2f0a27919fe4480", "node_id": "C_kwDOAAsO6NoAKGI1NzNlMTBkMjFiNjllYmZhZGY0MWFhOWMyZjBhMjc5MTlmZTQ0ODA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-27T01:12:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-27T01:12:30Z"}, "message": "Auto merge of #98553 - the8472:next_chunk_opt, r=Mark-Simulacrum\n\nOptimized vec::IntoIter::next_chunk impl\n\n```\nx86_64v1, default\ntest vec::bench_next_chunk                               ... bench:         696 ns/iter (+/- 22)\nx86_64v1, pr\ntest vec::bench_next_chunk                               ... bench:         309 ns/iter (+/- 4)\n\nznver2, default\ntest vec::bench_next_chunk                               ... bench:      17,272 ns/iter (+/- 117)\nznver2, pr\ntest vec::bench_next_chunk                               ... bench:         211 ns/iter (+/- 3)\n```\n\nOn znver2 the default impl seems to be slow due to different inlining decisions. It goes through `core::array::iter_next_chunk`\nwhich has a deep call tree.", "tree": {"sha": "e4ec1b41755a3e7e6f4e299ba14473e08a578667", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4ec1b41755a3e7e6f4e299ba14473e08a578667"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b573e10d21b69ebfadf41aa9c2f0a27919fe4480", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b573e10d21b69ebfadf41aa9c2f0a27919fe4480", "html_url": "https://github.com/rust-lang/rust/commit/b573e10d21b69ebfadf41aa9c2f0a27919fe4480", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b573e10d21b69ebfadf41aa9c2f0a27919fe4480/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d6d601c8a83284d6b23c253a3e2a060fd197316", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d6d601c8a83284d6b23c253a3e2a060fd197316", "html_url": "https://github.com/rust-lang/rust/commit/4d6d601c8a83284d6b23c253a3e2a060fd197316"}, {"sha": "4ba7cac359b0180add75d78929ebae4f90813fa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ba7cac359b0180add75d78929ebae4f90813fa1", "html_url": "https://github.com/rust-lang/rust/commit/4ba7cac359b0180add75d78929ebae4f90813fa1"}], "stats": {"total": 77, "additions": 75, "deletions": 2}, "files": [{"sha": "72ac897d4f178d0236193de5f24c516cd1c6692f", "filename": "library/alloc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b573e10d21b69ebfadf41aa9c2f0a27919fe4480/library%2Falloc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b573e10d21b69ebfadf41aa9c2f0a27919fe4480/library%2Falloc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Flib.rs?ref=b573e10d21b69ebfadf41aa9c2f0a27919fe4480", "patch": "@@ -2,6 +2,7 @@\n // See https://github.com/rust-lang/rust/issues/73535#event-3477699747\n #![cfg(not(target_os = \"android\"))]\n #![feature(btree_drain_filter)]\n+#![feature(iter_next_chunk)]\n #![feature(map_first_last)]\n #![feature(repr_simd)]\n #![feature(slice_partition_dedup)]"}, {"sha": "663f6b9dd1c9c038cbe3fbad3cbcb753329d27ec", "filename": "library/alloc/benches/vec.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b573e10d21b69ebfadf41aa9c2f0a27919fe4480/library%2Falloc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b573e10d21b69ebfadf41aa9c2f0a27919fe4480/library%2Falloc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec.rs?ref=b573e10d21b69ebfadf41aa9c2f0a27919fe4480", "patch": "@@ -762,3 +762,23 @@ fn bench_retain_whole_100000(b: &mut Bencher) {\n     let mut v = black_box(vec![826u32; 100000]);\n     b.iter(|| v.retain(|x| *x == 826u32));\n }\n+\n+#[bench]\n+fn bench_next_chunk(b: &mut Bencher) {\n+    let v = vec![13u8; 2048];\n+\n+    b.iter(|| {\n+        const CHUNK: usize = 8;\n+\n+        let mut sum = [0u32; CHUNK];\n+        let mut iter = black_box(v.clone()).into_iter();\n+\n+        while let Ok(chunk) = iter.next_chunk::<CHUNK>() {\n+            for i in 0..CHUNK {\n+                sum[i] += chunk[i] as u32;\n+            }\n+        }\n+\n+        sum\n+    })\n+}"}, {"sha": "8b6f4054851dd454ae01fa96d2e4c7aa909c090b", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b573e10d21b69ebfadf41aa9c2f0a27919fe4480/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b573e10d21b69ebfadf41aa9c2f0a27919fe4480/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=b573e10d21b69ebfadf41aa9c2f0a27919fe4480", "patch": "@@ -89,6 +89,7 @@\n #![feature(alloc_layout_extra)]\n #![feature(allocator_api)]\n #![feature(array_chunks)]\n+#![feature(array_into_iter_constructors)]\n #![feature(array_methods)]\n #![feature(array_windows)]\n #![feature(assert_matches)]\n@@ -117,8 +118,11 @@\n #![feature(hasher_prefixfree_extras)]\n #![feature(inplace_iteration)]\n #![feature(iter_advance_by)]\n+#![feature(iter_next_chunk)]\n #![feature(layout_for_ptr)]\n+#![feature(maybe_uninit_array_assume_init)]\n #![feature(maybe_uninit_slice)]\n+#![feature(maybe_uninit_uninit_array)]\n #![cfg_attr(test, feature(new_uninit))]\n #![feature(nonnull_slice_from_raw_parts)]\n #![feature(pattern)]"}, {"sha": "1b483e3fc7793a499fcc236781eea1e5f96f8123", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b573e10d21b69ebfadf41aa9c2f0a27919fe4480/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b573e10d21b69ebfadf41aa9c2f0a27919fe4480/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=b573e10d21b69ebfadf41aa9c2f0a27919fe4480", "patch": "@@ -2,13 +2,14 @@\n use super::AsVecIntoIter;\n use crate::alloc::{Allocator, Global};\n use crate::raw_vec::RawVec;\n+use core::array;\n use core::fmt;\n use core::intrinsics::arith_offset;\n use core::iter::{\n     FusedIterator, InPlaceIterable, SourceIter, TrustedLen, TrustedRandomAccessNoCoerce,\n };\n use core::marker::PhantomData;\n-use core::mem::{self, ManuallyDrop};\n+use core::mem::{self, ManuallyDrop, MaybeUninit};\n #[cfg(not(no_global_oom_handling))]\n use core::ops::Deref;\n use core::ptr::{self, NonNull};\n@@ -124,7 +125,6 @@ impl<T, A: Allocator> IntoIter<T, A> {\n     }\n \n     /// Forgets to Drop the remaining elements while still allowing the backing allocation to be freed.\n-    #[cfg(not(no_global_oom_handling))]\n     pub(crate) fn forget_remaining_elements(&mut self) {\n         self.ptr = self.end;\n     }\n@@ -204,6 +204,43 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n         self.len()\n     }\n \n+    #[inline]\n+    fn next_chunk<const N: usize>(&mut self) -> Result<[T; N], core::array::IntoIter<T, N>> {\n+        let mut raw_ary = MaybeUninit::uninit_array();\n+\n+        let len = self.len();\n+\n+        if mem::size_of::<T>() == 0 {\n+            if len < N {\n+                self.forget_remaining_elements();\n+                // Safety: ZSTs can be conjured ex nihilo, only the amount has to be correct\n+                return Err(unsafe { array::IntoIter::new_unchecked(raw_ary, 0..len) });\n+            }\n+\n+            self.ptr = unsafe { arith_offset(self.ptr as *const i8, N as isize) as *mut T };\n+            // Safety: ditto\n+            return Ok(unsafe { MaybeUninit::array_assume_init(raw_ary) });\n+        }\n+\n+        if len < N {\n+            // Safety: `len` indicates that this many elements are available and we just checked that\n+            // it fits into the array.\n+            unsafe {\n+                ptr::copy_nonoverlapping(self.ptr, raw_ary.as_mut_ptr() as *mut T, len);\n+                self.forget_remaining_elements();\n+                return Err(array::IntoIter::new_unchecked(raw_ary, 0..len));\n+            }\n+        }\n+\n+        // Safety: `len` is larger than the array size. Copy a fixed amount here to fully initialize\n+        // the array.\n+        return unsafe {\n+            ptr::copy_nonoverlapping(self.ptr, raw_ary.as_mut_ptr() as *mut T, N);\n+            self.ptr = self.ptr.add(N);\n+            Ok(MaybeUninit::array_assume_init(raw_ary))\n+        };\n+    }\n+\n     unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> Self::Item\n     where\n         Self: TrustedRandomAccessNoCoerce,"}, {"sha": "d83cd29ddbad92e5d76b3694a7f87a7303265eed", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b573e10d21b69ebfadf41aa9c2f0a27919fe4480/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b573e10d21b69ebfadf41aa9c2f0a27919fe4480/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=b573e10d21b69ebfadf41aa9c2f0a27919fe4480", "patch": "@@ -27,6 +27,7 @@\n #![feature(binary_heap_as_slice)]\n #![feature(inplace_iteration)]\n #![feature(iter_advance_by)]\n+#![feature(iter_next_chunk)]\n #![feature(round_char_boundary)]\n #![feature(slice_group_by)]\n #![feature(slice_partition_dedup)]"}, {"sha": "d94da8f5f5a0eac6731a298606f33715bd95f932", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b573e10d21b69ebfadf41aa9c2f0a27919fe4480/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b573e10d21b69ebfadf41aa9c2f0a27919fe4480/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=b573e10d21b69ebfadf41aa9c2f0a27919fe4480", "patch": "@@ -1,4 +1,5 @@\n use core::alloc::{Allocator, Layout};\n+use core::iter::IntoIterator;\n use core::ptr::NonNull;\n use std::alloc::System;\n use std::assert_matches::assert_matches;\n@@ -930,6 +931,15 @@ fn test_into_iter_count() {\n     assert_eq!([1, 2, 3].into_iter().count(), 3);\n }\n \n+#[test]\n+fn test_into_iter_next_chunk() {\n+    let mut iter = b\"lorem\".to_vec().into_iter();\n+\n+    assert_eq!(iter.next_chunk().unwrap(), [b'l', b'o']); // N is inferred as 2\n+    assert_eq!(iter.next_chunk().unwrap(), [b'r', b'e', b'm']); // N is inferred as 3\n+    assert_eq!(iter.next_chunk::<4>().unwrap_err().as_slice(), &[]); // N is explicitly 4\n+}\n+\n #[test]\n fn test_into_iter_clone() {\n     fn iter_equal<I: Iterator<Item = i32>>(it: I, slice: &[i32]) {"}]}