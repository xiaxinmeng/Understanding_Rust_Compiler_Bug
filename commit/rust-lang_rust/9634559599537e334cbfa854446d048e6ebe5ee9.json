{"sha": "9634559599537e334cbfa854446d048e6ebe5ee9", "node_id": "C_kwDOAAsO6NoAKDk2MzQ1NTk1OTk1MzdlMzM0Y2JmYTg1NDQ0NmQwNDhlNmViZTVlZTk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-09T22:29:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-09T22:29:55Z"}, "message": "Rollup merge of #91443 - compiler-errors:bad_collect_into_slice, r=wesleywiser\n\nBetter suggestions when user tries to collect into an unsized `[_]`\n\n1. Extend the predicate on `rustc_on_unimplemented` to support substitutions like note, label, etc (i.e. treat it as a `OnUnimplementedFormatString`) so we can have slightly more general `rustc_on_unimplemented` special-cases.\n2. Add a `rustc_on_unimplemented` if we fail on `FromIterator<A> for [A]` which happens when we don't explicitly collect into a `vec<A>`, but then pass the return from a `.collect` call into something that takes a slice.\n\nFixes #91423", "tree": {"sha": "ccbdfb0d1c274fff3ac3077f85356e112145c2a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccbdfb0d1c274fff3ac3077f85356e112145c2a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9634559599537e334cbfa854446d048e6ebe5ee9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiBEBjCRBK7hj4Ov3rIwAAqScIAInhiO9HluxFONtwoxQMUKXp\nohFdvPlO31IL4jSR+Mi8VHzwMznuJ1Sc0QiH4TdQD20ZAewuU4+ODGKQb1555vMd\n+4710yg+d/PW3+WcSgMuXQx27Em+pEzvsnAlbZa53ffA3DOl3QOaS7UOVwsBZ84H\nso+XYpw6jP2dTu4HDEuv16GvljlVLK+jACAJZvjVpLLx8boXDJw8afcAbhUDDvi9\nRA7l8YF41H9qoHE8M5nsr5AJgbur383ZP208unKYDasIoAC6cw2v54QxmjB244wN\nW99jbYcyeKPSBJxpr/hLEWUi8B6SCPup2kR4rBi5Q7dyw+xzayhmlpjwXA5+A7U=\n=/uXg\n-----END PGP SIGNATURE-----\n", "payload": "tree ccbdfb0d1c274fff3ac3077f85356e112145c2a0\nparent e7aca895980f25f6d2d3c48e10fd04656764d1e4\nparent fea0015f9320f59c46821957a01f688f79a02546\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1644445795 +0100\ncommitter GitHub <noreply@github.com> 1644445795 +0100\n\nRollup merge of #91443 - compiler-errors:bad_collect_into_slice, r=wesleywiser\n\nBetter suggestions when user tries to collect into an unsized `[_]`\n\n1. Extend the predicate on `rustc_on_unimplemented` to support substitutions like note, label, etc (i.e. treat it as a `OnUnimplementedFormatString`) so we can have slightly more general `rustc_on_unimplemented` special-cases.\n2. Add a `rustc_on_unimplemented` if we fail on `FromIterator<A> for [A]` which happens when we don't explicitly collect into a `vec<A>`, but then pass the return from a `.collect` call into something that takes a slice.\n\nFixes #91423\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9634559599537e334cbfa854446d048e6ebe5ee9", "html_url": "https://github.com/rust-lang/rust/commit/9634559599537e334cbfa854446d048e6ebe5ee9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9634559599537e334cbfa854446d048e6ebe5ee9/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7aca895980f25f6d2d3c48e10fd04656764d1e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7aca895980f25f6d2d3c48e10fd04656764d1e4", "html_url": "https://github.com/rust-lang/rust/commit/e7aca895980f25f6d2d3c48e10fd04656764d1e4"}, {"sha": "fea0015f9320f59c46821957a01f688f79a02546", "url": "https://api.github.com/repos/rust-lang/rust/commits/fea0015f9320f59c46821957a01f688f79a02546", "html_url": "https://github.com/rust-lang/rust/commit/fea0015f9320f59c46821957a01f688f79a02546"}], "stats": {"total": 118, "additions": 106, "deletions": 12}, "files": [{"sha": "ef0a1792d58af790d3d650f5c0fa45b7df1fcdb9", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9634559599537e334cbfa854446d048e6ebe5ee9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9634559599537e334cbfa854446d048e6ebe5ee9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9634559599537e334cbfa854446d048e6ebe5ee9", "patch": "@@ -668,6 +668,7 @@ symbols! {\n         fill,\n         finish,\n         flags,\n+        float,\n         float_to_int_unchecked,\n         floorf32,\n         floorf64,\n@@ -771,6 +772,8 @@ symbols! {\n         inline_const_pat,\n         inout,\n         instruction_set,\n+        integer_: \"integer\",\n+        integral,\n         intel,\n         into_future,\n         into_iter,"}, {"sha": "bdf677a63b632d0de11c2700f64e62a0f81809f5", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9634559599537e334cbfa854446d048e6ebe5ee9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9634559599537e334cbfa854446d048e6ebe5ee9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=9634559599537e334cbfa854446d048e6ebe5ee9", "patch": "@@ -62,6 +62,10 @@ impl<'tcx> OnUnimplementedDirective {\n         let mut errored = false;\n         let mut item_iter = items.iter();\n \n+        let parse_value = |value_str| {\n+            OnUnimplementedFormatString::try_parse(tcx, trait_def_id, value_str, span).map(Some)\n+        };\n+\n         let condition = if is_root {\n             None\n         } else {\n@@ -86,7 +90,14 @@ impl<'tcx> OnUnimplementedDirective {\n                         None,\n                     )\n                 })?;\n-            attr::eval_condition(cond, &tcx.sess.parse_sess, Some(tcx.features()), &mut |_| true);\n+            attr::eval_condition(cond, &tcx.sess.parse_sess, Some(tcx.features()), &mut |item| {\n+                if let Some(symbol) = item.value_str() {\n+                    if parse_value(symbol).is_err() {\n+                        errored = true;\n+                    }\n+                }\n+                true\n+            });\n             Some(cond.clone())\n         };\n \n@@ -97,10 +108,6 @@ impl<'tcx> OnUnimplementedDirective {\n         let mut subcommands = vec![];\n         let mut append_const_msg = None;\n \n-        let parse_value = |value_str| {\n-            OnUnimplementedFormatString::try_parse(tcx, trait_def_id, value_str, span).map(Some)\n-        };\n-\n         for item in item_iter {\n             if item.has_name(sym::message) && message.is_none() {\n                 if let Some(message_) = item.value_str() {\n@@ -221,6 +228,9 @@ impl<'tcx> OnUnimplementedDirective {\n         let mut append_const_msg = None;\n         info!(\"evaluate({:?}, trait_ref={:?}, options={:?})\", self, trait_ref, options);\n \n+        let options_map: FxHashMap<Symbol, String> =\n+            options.iter().filter_map(|(k, v)| v.as_ref().map(|v| (*k, v.to_owned()))).collect();\n+\n         for command in self.subcommands.iter().chain(Some(self)).rev() {\n             if let Some(ref condition) = command.condition {\n                 if !attr::eval_condition(\n@@ -229,7 +239,11 @@ impl<'tcx> OnUnimplementedDirective {\n                     Some(tcx.features()),\n                     &mut |c| {\n                         c.ident().map_or(false, |ident| {\n-                            options.contains(&(ident.name, c.value_str().map(|s| s.to_string())))\n+                            let value = c.value_str().map(|s| {\n+                                OnUnimplementedFormatString(s).format(tcx, trait_ref, &options_map)\n+                            });\n+\n+                            options.contains(&(ident.name, value))\n                         })\n                     },\n                 ) {\n@@ -257,13 +271,11 @@ impl<'tcx> OnUnimplementedDirective {\n             append_const_msg = command.append_const_msg.clone();\n         }\n \n-        let options: FxHashMap<Symbol, String> =\n-            options.iter().filter_map(|(k, v)| v.as_ref().map(|v| (*k, v.to_owned()))).collect();\n         OnUnimplementedNote {\n-            label: label.map(|l| l.format(tcx, trait_ref, &options)),\n-            message: message.map(|m| m.format(tcx, trait_ref, &options)),\n-            note: note.map(|n| n.format(tcx, trait_ref, &options)),\n-            enclosing_scope: enclosing_scope.map(|e_s| e_s.format(tcx, trait_ref, &options)),\n+            label: label.map(|l| l.format(tcx, trait_ref, &options_map)),\n+            message: message.map(|m| m.format(tcx, trait_ref, &options_map)),\n+            note: note.map(|n| n.format(tcx, trait_ref, &options_map)),\n+            enclosing_scope: enclosing_scope.map(|e_s| e_s.format(tcx, trait_ref, &options_map)),\n             append_const_msg,\n         }\n     }\n@@ -306,6 +318,12 @@ impl<'tcx> OnUnimplementedFormatString {\n                     Position::ArgumentNamed(s) if s == sym::from_desugaring => (),\n                     // `{ItemContext}` is allowed\n                     Position::ArgumentNamed(s) if s == sym::ItemContext => (),\n+                    // `{integral}` and `{integer}` and `{float}` are allowed\n+                    Position::ArgumentNamed(s)\n+                        if s == sym::integral || s == sym::integer_ || s == sym::float =>\n+                    {\n+                        ()\n+                    }\n                     // So is `{A}` if A is a type parameter\n                     Position::ArgumentNamed(s) => {\n                         match generics.params.iter().find(|param| param.name == s) {\n@@ -385,6 +403,12 @@ impl<'tcx> OnUnimplementedFormatString {\n                                 &empty_string\n                             } else if s == sym::ItemContext {\n                                 &item_context\n+                            } else if s == sym::integral {\n+                                \"{integral}\"\n+                            } else if s == sym::integer_ {\n+                                \"{integer}\"\n+                            } else if s == sym::float {\n+                                \"{float}\"\n                             } else {\n                                 bug!(\n                                     \"broken on_unimplemented {:?} for {:?}: \\"}, {"sha": "637d7bc44885e96902413d6eed0290f06004babf", "filename": "library/core/src/iter/traits/collect.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9634559599537e334cbfa854446d048e6ebe5ee9/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9634559599537e334cbfa854446d048e6ebe5ee9/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs?ref=9634559599537e334cbfa854446d048e6ebe5ee9", "patch": "@@ -81,6 +81,32 @@\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n+    on(\n+        _Self = \"[{A}]\",\n+        message = \"a value of type `{Self}` cannot be built since `{Self}` has no definite size\",\n+        label = \"try explicitly collecting into a `Vec<{A}>`\",\n+    ),\n+    on(\n+        all(\n+            A = \"{integer}\",\n+            any(\n+                _Self = \"[i8]\",\n+                _Self = \"[i16]\",\n+                _Self = \"[i32]\",\n+                _Self = \"[i64]\",\n+                _Self = \"[i128]\",\n+                _Self = \"[isize]\",\n+                _Self = \"[u8]\",\n+                _Self = \"[u16]\",\n+                _Self = \"[u32]\",\n+                _Self = \"[u64]\",\n+                _Self = \"[u128]\",\n+                _Self = \"[usize]\"\n+            )\n+        ),\n+        message = \"a value of type `{Self}` cannot be built since `{Self}` has no definite size\",\n+        label = \"try explicitly collecting into a `Vec<{A}>`\",\n+    ),\n     message = \"a value of type `{Self}` cannot be built from an iterator \\\n                over elements of type `{A}`\",\n     label = \"value of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\""}, {"sha": "905752dec7478749119da406f960da1469203698", "filename": "src/test/ui/iterators/collect-into-slice.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9634559599537e334cbfa854446d048e6ebe5ee9/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9634559599537e334cbfa854446d048e6ebe5ee9/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs?ref=9634559599537e334cbfa854446d048e6ebe5ee9", "patch": "@@ -0,0 +1,15 @@\n+fn process_slice(data: &[i32]) {\n+    //~^ NOTE required by a bound in this\n+    todo!()\n+}\n+\n+fn main() {\n+    let some_generated_vec = (0..10).collect();\n+    //~^ ERROR the size for values of type `[i32]` cannot be known at compilation time\n+    //~| ERROR a value of type `[i32]` cannot be built since `[i32]` has no definite size\n+    //~| NOTE try explicitly collecting into a `Vec<{integer}>`\n+    //~| NOTE required by a bound in `collect`\n+    //~| NOTE all local variables must have a statically known size\n+    //~| NOTE doesn't have a size known at compile-time\n+    process_slice(&some_generated_vec);\n+}"}, {"sha": "521f239451d2f9913793f4488d3403cd26e1f2cb", "filename": "src/test/ui/iterators/collect-into-slice.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9634559599537e334cbfa854446d048e6ebe5ee9/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9634559599537e334cbfa854446d048e6ebe5ee9/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr?ref=9634559599537e334cbfa854446d048e6ebe5ee9", "patch": "@@ -0,0 +1,26 @@\n+error[E0277]: the size for values of type `[i32]` cannot be known at compilation time\n+  --> $DIR/collect-into-slice.rs:7:9\n+   |\n+LL |     let some_generated_vec = (0..10).collect();\n+   |         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `[i32]`\n+   = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n+\n+error[E0277]: a value of type `[i32]` cannot be built since `[i32]` has no definite size\n+  --> $DIR/collect-into-slice.rs:7:38\n+   |\n+LL |     let some_generated_vec = (0..10).collect();\n+   |                                      ^^^^^^^ try explicitly collecting into a `Vec<{integer}>`\n+   |\n+   = help: the trait `FromIterator<{integer}>` is not implemented for `[i32]`\n+note: required by a bound in `collect`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `collect`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}]}