{"sha": "17b78c4a7a8e2a1699e8443cc88fa5f3fd224368", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3Yjc4YzRhN2E4ZTJhMTY5OWU4NDQzY2M4OGZhNWYzZmQyMjQzNjg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-15T17:15:35Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-18T11:49:01Z"}, "message": "Overhaul the kind-checking pass\n\nNot really useful yet because missing last-use-of-local optimization.\n\nAlso: instantiation of type parameters needs to be checked.\n\nIssue #1177", "tree": {"sha": "8fcf2ea0f4b443b23b71c435057305f2b6f07c2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fcf2ea0f4b443b23b71c435057305f2b6f07c2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17b78c4a7a8e2a1699e8443cc88fa5f3fd224368", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17b78c4a7a8e2a1699e8443cc88fa5f3fd224368", "html_url": "https://github.com/rust-lang/rust/commit/17b78c4a7a8e2a1699e8443cc88fa5f3fd224368", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17b78c4a7a8e2a1699e8443cc88fa5f3fd224368/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cefff237bf36c4868f047ceb3e98646710ef7ac0", "url": "https://api.github.com/repos/rust-lang/rust/commits/cefff237bf36c4868f047ceb3e98646710ef7ac0", "html_url": "https://github.com/rust-lang/rust/commit/cefff237bf36c4868f047ceb3e98646710ef7ac0"}], "stats": {"total": 315, "additions": 189, "deletions": 126}, "files": [{"sha": "abc7ee8413b470f5e952bf98e6a17d03e7ca079f", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 119, "deletions": 31, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/17b78c4a7a8e2a1699e8443cc88fa5f3fd224368/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b78c4a7a8e2a1699e8443cc88fa5f3fd224368/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=17b78c4a7a8e2a1699e8443cc88fa5f3fd224368", "patch": "@@ -1,3 +1,122 @@\n+import std::option::some;\n+import syntax::{visit, ast_util};\n+import syntax::ast::*;\n+import syntax::codemap::span;\n+\n+fn kind_to_str(k: kind) -> str {\n+    alt k {\n+      kind_sendable. { \"sendable\" }\n+      kind_copyable. { \"copyable\" }\n+      kind_noncopyable. { \"noncopyable\" }\n+    }\n+}\n+\n+type rval_map = std::map::hashmap<node_id, ()>;\n+\n+type ctx = {tcx: ty::ctxt,\n+            rval_map: rval_map,\n+            mutable ret_by_ref: bool};\n+\n+fn check_crate(tcx: ty::ctxt, crate: @crate) -> rval_map {\n+    let ctx = {tcx: tcx,\n+               rval_map: std::map::new_int_hash(),\n+               mutable ret_by_ref: false};\n+    let visit = visit::mk_vt(@{\n+        visit_expr: check_expr,\n+        visit_stmt: check_stmt,\n+        visit_fn: visit_fn\n+        with *visit::default_visitor()\n+    });\n+    visit::visit_crate(*crate, ctx, visit);\n+    // FIXME go through alias's copy_map, check implicit copies (either here,\n+    // or in alias.rs)\n+    tcx.sess.abort_if_errors();\n+    ret ctx.rval_map;\n+}\n+\n+fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n+    alt e.node {\n+      expr_assign(_, ex) | expr_assign_op(_, _, ex) |\n+      expr_block({node: {expr: some(ex), _}, _}) |\n+      expr_unary(box(_), ex) | expr_unary(uniq(_), ex) { maybe_copy(cx, ex); }\n+      expr_ret(some(ex)) { if !cx.ret_by_ref { maybe_copy(cx, ex); } }\n+      expr_copy(expr) { check_copy_ex(cx, expr, false); }\n+      // Vector add copies.\n+      expr_binary(add., ls, rs) { maybe_copy(cx, ls); maybe_copy(cx, rs); }\n+      expr_rec(fields, _) {\n+        for field in fields { maybe_copy(cx, field.node.expr); }\n+      }\n+      expr_tup(exprs) | expr_vec(exprs, _) {\n+        for expr in exprs { maybe_copy(cx, expr); }\n+      }\n+      expr_bind(_, args) {\n+        for a in args { alt a { some(ex) { maybe_copy(cx, ex); } _ {} } }\n+      }\n+      // FIXME check for by-copy args\n+      expr_call(_f, _args, _) {\n+\n+      }\n+      // FIXME: generic instantiation\n+      expr_path(_) {}\n+      expr_fn({proto: proto_shared(_), _}) {\n+        for free in *freevars::get_freevars(cx.tcx, e.id) {\n+            let id = ast_util::def_id_of_def(free).node;\n+            let ty = ty::node_id_to_type(cx.tcx, id);\n+            check_copy(cx, ty, e.span);\n+        }\n+      }\n+      expr_ternary(_, a, b) { maybe_copy(cx, a); maybe_copy(cx, b); }\n+      _ { }\n+    }\n+    visit::visit_expr(e, cx, v);\n+}\n+\n+fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n+    alt stmt.node {\n+      stmt_decl(@{node: decl_local(locals), _}, _) {\n+        for (_, local) in locals {\n+            alt local.node.init {\n+              some({op: init_assign., expr}) { maybe_copy(cx, expr); }\n+              _ {}\n+            }\n+        }\n+      }\n+      _ {}\n+    }\n+    visit::visit_stmt(stmt, cx, v);\n+}\n+\n+fn visit_fn(f: _fn, tps: [ty_param], sp: span, ident: fn_ident,\n+            id: node_id, cx: ctx, v: visit::vt<ctx>) {\n+    let old_ret = cx.ret_by_ref;\n+    cx.ret_by_ref = ast_util::ret_by_ref(f.decl.cf);\n+    visit::visit_fn(f, tps, sp, ident, id, cx, v);\n+    cx.ret_by_ref = old_ret;\n+}\n+\n+fn maybe_copy(cx: ctx, ex: @expr) {\n+    check_copy_ex(cx, ex, true);\n+}\n+\n+fn check_copy_ex(cx: ctx, ex: @expr, _warn: bool) {\n+    if ty::expr_is_lval(cx.tcx, ex) {\n+        let ty = ty::expr_ty(cx.tcx, ex);\n+        check_copy(cx, ty, ex.span);\n+        // FIXME turn this on again once vector types are no longer unique.\n+        // Right now, it is too annoying to be useful.\n+        /* if warn && ty::type_is_unique(cx.tcx, ty) {\n+            cx.tcx.sess.span_warn(ex.span, \"copying a unique value\");\n+        }*/\n+    }\n+}\n+\n+fn check_copy(cx: ctx, ty: ty::t, sp: span) {\n+    if ty::type_kind(cx.tcx, ty) == kind_noncopyable {\n+        cx.tcx.sess.span_err(sp, \"copying a noncopyable value\");\n+    }\n+}\n+\n+\n /*\n * Kinds are types of type.\n *\n@@ -84,28 +203,6 @@\n *\n */\n \n-import syntax::ast;\n-import ast::{kind, kind_sendable, kind_copyable, kind_noncopyable};\n-\n-fn kind_lteq(a: kind, b: kind) -> bool {\n-    alt a {\n-      kind_noncopyable. { true }\n-      kind_copyable. { b != kind_noncopyable }\n-      kind_sendable. { b == kind_sendable }\n-    }\n-}\n-\n-fn lower_kind(a: kind, b: kind) -> kind {\n-    if kind_lteq(a, b) { a } else { b }\n-}\n-\n-fn kind_to_str(k: kind) -> str {\n-    alt k {\n-      ast::kind_sendable. { \"sendable\" }\n-      ast::kind_copyable. { \"copyable\" }\n-      ast::kind_noncopyable. { \"noncopyable\" }\n-    }\n-}\n /*\n fn type_and_kind(tcx: ty::ctxt, e: @ast::expr) ->\n    {ty: ty::t, kind: ast::kind} {\n@@ -296,15 +393,6 @@ fn check_stmt(tcx: ty::ctxt, stmt: @ast::stmt) {\n     }\n }\n */\n-fn check_crate(_tcx: ty::ctxt, _crate: @ast::crate) {\n-    // FIXME stubbed out\n-/*    let visit =\n-        visit::mk_simple_visitor(@{visit_expr: bind check_expr(tcx, _),\n-                                   visit_stmt: bind check_stmt(tcx, _)\n-                                      with *visit::default_simple_visitor()});\n-    visit::visit_crate(*crate, (), visit);\n-    tcx.sess.abort_if_errors();*/\n-}\n \n //\n // Local Variables:"}, {"sha": "becdaa092abac3159a5be22592a83f90fffa5dea", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/17b78c4a7a8e2a1699e8443cc88fa5f3fd224368/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b78c4a7a8e2a1699e8443cc88fa5f3fd224368/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=17b78c4a7a8e2a1699e8443cc88fa5f3fd224368", "patch": "@@ -3128,7 +3128,7 @@ fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n       ast::expr_path(p) { ret trans_path(bcx, p, e.id); }\n       ast::expr_field(base, ident) {\n         // Lval means this is a record field, so not a method\n-        if !expr_is_lval(bcx_tcx(bcx), e) {\n+        if !ty::expr_is_lval(bcx_tcx(bcx), e) {\n             let of = trans_object_field(bcx, base, ident);\n             ret {bcx: of.bcx, val: of.mthptr, kind: owned,\n                  env: obj_env(of.objptr), generic: none};\n@@ -3149,25 +3149,6 @@ fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n     ret lval_no_env(lv.bcx, lv.val, lv.kind);\n }\n \n-fn expr_is_lval(tcx: ty::ctxt, e: @ast::expr) -> bool {\n-    alt e.node {\n-      ast::expr_path(_) | ast::expr_index(_, _) |\n-      ast::expr_unary(ast::deref., _) { true }\n-      ast::expr_field(base, ident) {\n-        let basety = ty::type_autoderef(tcx, ty::expr_ty(tcx, base));\n-        alt ty::struct(tcx, basety) {\n-          ty::ty_obj(_) { false }\n-          ty::ty_rec(_) { true }\n-        }\n-      }\n-      ast::expr_call(f, _, _) {\n-          let fty = ty::expr_ty(tcx, f);\n-          ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fty))\n-      }\n-      _ { false }\n-    }\n-}\n-\n // Use this when you know you are compiling an lval.\n // The additional bool returned indicates whether it's mem (that is\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n@@ -4103,7 +4084,7 @@ fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n // use trans_temp_expr.\n fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n     let bcx = bcx;\n-    if expr_is_lval(bcx_tcx(bcx), e) {\n+    if ty::expr_is_lval(bcx_tcx(bcx), e) {\n         ret trans_lval(bcx, e);\n     } else {\n         let tcx = bcx_tcx(bcx);\n@@ -4141,7 +4122,7 @@ fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> result {\n // - exprs with non-immediate type never get dest=by_val\n fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n     let tcx = bcx_tcx(bcx);\n-    if expr_is_lval(tcx, e) { ret lval_to_dps(bcx, e, dest); }\n+    if ty::expr_is_lval(tcx, e) { ret lval_to_dps(bcx, e, dest); }\n \n     alt e.node {\n       ast::expr_if(cond, thn, els) | ast::expr_if_check(cond, thn, els) {\n@@ -4176,7 +4157,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n       ast::expr_fn(f) { ret trans_expr_fn(bcx, f, e.span, e.id, dest); }\n       ast::expr_bind(f, args) { ret trans_bind(bcx, f, args, e.id, dest); }\n       ast::expr_copy(a) {\n-        if !expr_is_lval(tcx, a) { ret trans_expr(bcx, a, dest); }\n+        if !ty::expr_is_lval(tcx, a) { ret trans_expr(bcx, a, dest); }\n         else { ret lval_to_dps(bcx, a, dest); }\n       }\n       ast::expr_cast(val, _) { ret trans_cast(bcx, val, e.id, dest); }\n@@ -4574,7 +4555,7 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     alt local.node.init {\n       some(init) {\n         if init.op == ast::init_assign ||\n-           !expr_is_lval(bcx_tcx(bcx), init.expr) {\n+           !ty::expr_is_lval(bcx_tcx(bcx), init.expr) {\n             bcx = trans_expr_save_in(bcx, init.expr, llptr);\n         } else { // This is a move from an lval, must perform an actual move\n             let sub = trans_lval(bcx, init.expr);"}, {"sha": "5cd58c130f010bc4d6b719d1aca39d7465d663a1", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 60, "deletions": 64, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/17b78c4a7a8e2a1699e8443cc88fa5f3fd224368/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b78c4a7a8e2a1699e8443cc88fa5f3fd224368/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=17b78c4a7a8e2a1699e8443cc88fa5f3fd224368", "patch": "@@ -41,6 +41,7 @@ export eq_ty;\n export expr_has_ty_params;\n export expr_ty;\n export expr_ty_params_and_ty;\n+export expr_is_lval;\n export fold_ty;\n export field;\n export field_idx;\n@@ -139,6 +140,7 @@ export ty_fn_args;\n export type_constr;\n export type_contains_params;\n export type_contains_vars;\n+export kind_lteq;\n export type_kind;\n export type_err;\n export type_err_to_str;\n@@ -981,109 +983,84 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n         };\n }\n \n+fn kind_lteq(a: kind, b: kind) -> bool {\n+    alt a {\n+      kind_noncopyable. { true }\n+      kind_copyable. { b != kind_noncopyable }\n+      kind_sendable. { b == kind_sendable }\n+    }\n+}\n+\n+fn lower_kind(a: kind, b: kind) -> kind {\n+    if ty::kind_lteq(a, b) { a } else { b }\n+}\n+\n fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n     alt cx.kind_cache.find(ty) {\n       some(result) { ret result; }\n       none. {/* fall through */ }\n     }\n \n-    let result = ast::kind_noncopyable;\n-\n     // Insert a default in case we loop back on self recursively.\n-    cx.kind_cache.insert(ty, result);\n+    cx.kind_cache.insert(ty, ast::kind_sendable);\n \n-    alt struct(cx, ty) {\n-      // Scalar types are unique-kind, no substructure.\n+    let result = alt struct(cx, ty) {\n+      // Scalar and unique types are sendable\n       ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_uint. | ty_float. |\n-      ty_machine(_) | ty_char. | ty_native(_) {\n-        // no-op\n-      }\n-      // A handful of other built-in are unique too.\n-      ty_type. | ty_str. | ty_native_fn(_, _, _) {\n-        // no-op\n-      }\n+      ty_machine(_) | ty_char. | ty_native(_) |\n+      ty_type. | ty_str. | ty_native_fn(_, _, _) { ast::kind_sendable }\n       // FIXME: obj is broken for now, since we aren't asserting\n       // anything about its fields.\n-      ty_obj(_) {\n-        result = kind_copyable;\n-      }\n+      ty_obj(_) { kind_copyable }\n       // FIXME: the environment capture mode is not fully encoded\n       // here yet, leading to weirdness around closure.\n       ty_fn(proto, _, _, _, _) {\n-        result = alt proto {\n+        alt proto {\n           ast::proto_block. { ast::kind_noncopyable }\n           ast::proto_shared(_) { ast::kind_copyable }\n           ast::proto_bare. { ast::kind_sendable }\n-        };\n+        }\n       }\n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n-      ty_box(mt) {\n-        result = ast::kind_copyable;\n-      }\n+      ty_box(mt) { ast::kind_copyable }\n       // Pointers and unique containers raise pinned to shared.\n-      ty_ptr(tm) | ty_vec(tm) | ty_uniq(tm) {\n-        let k = type_kind(cx, tm.ty);\n-\n-        // FIXME (984) Doing this implies a lot of subtle rules about what can\n-        // and can't be copied, so I'm going to start by not raising unique of\n-        // pinned to shared, make sure that's relatively safe, then we can try\n-        // to make this work.\n-\n-        // if k == ast::kind_pinned { k = ast::kind_shared; }\n-\n-        result = kind::lower_kind(result, k);\n-      }\n+      ty_ptr(tm) | ty_vec(tm) | ty_uniq(tm) { type_kind(cx, tm.ty) }\n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n-        for f: field in flds {\n-            result = kind::lower_kind(result, type_kind(cx, f.mt.ty));\n-            if result == ast::kind_noncopyable { break; }\n-        }\n+        let lowest = ast::kind_sendable;\n+        for f in flds { lowest = lower_kind(lowest, type_kind(cx, f.mt.ty)); }\n+        lowest\n       }\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n-        for ty: t in tys {\n-            result = kind::lower_kind(result, type_kind(cx, ty));\n-            if result == ast::kind_noncopyable { break; }\n-        }\n+        let lowest = ast::kind_sendable;\n+        for ty in tys { lowest = lower_kind(lowest, type_kind(cx, ty)); }\n+        lowest\n       }\n       // Tags lower to the lowest of their variants.\n       ty_tag(did, tps) {\n-        let variants = tag_variants(cx, did);\n-        for variant: variant_info in variants {\n-            for aty: t in variant.args {\n+        let lowest = ast::kind_sendable;\n+        for variant in tag_variants(cx, did) {\n+            for aty in variant.args {\n                 // Perform any type parameter substitutions.\n                 let arg_ty = substitute_type_params(cx, tps, aty);\n-                result = kind::lower_kind(result, type_kind(cx, arg_ty));\n-                if result == ast::kind_noncopyable { break; }\n+                lowest = lower_kind(lowest, type_kind(cx, arg_ty));\n+                if lowest == ast::kind_noncopyable { break; }\n             }\n-            if result == ast::kind_noncopyable { break; }\n         }\n+        lowest\n       }\n-      // Resources are always pinned.\n-      ty_res(did, inner, tps) {\n-        result = ast::kind_noncopyable;\n-      }\n-      ty_var(_) {\n-        fail;\n-      }\n-      ty_param(_, k) {\n-        result = kind::lower_kind(result, k);\n-      }\n-      ty_constr(t, _) {\n-        result = type_kind(cx, t);\n-      }\n-      _ {\n-        cx.sess.bug(\"missed case: \" + ty_to_str(cx, ty));\n-      }\n-    }\n+      // Resources are always noncopyable.\n+      ty_res(did, inner, tps) { ast::kind_noncopyable }\n+      ty_param(_, k) { k }\n+      ty_constr(t, _) { type_kind(cx, t) }\n+    };\n \n     cx.kind_cache.insert(ty, result);\n     ret result;\n }\n \n-\n // FIXME: should we just return true for native types in\n // type_is_scalar?\n fn type_is_native(cx: ctxt, ty: t) -> bool {\n@@ -1708,6 +1685,25 @@ fn expr_has_ty_params(cx: ctxt, expr: @ast::expr) -> bool {\n     ret node_id_has_type_params(cx, expr.id);\n }\n \n+fn expr_is_lval(tcx: ty::ctxt, e: @ast::expr) -> bool {\n+    alt e.node {\n+      ast::expr_path(_) | ast::expr_index(_, _) |\n+      ast::expr_unary(ast::deref., _) { true }\n+      ast::expr_field(base, ident) {\n+        let basety = type_autoderef(tcx, expr_ty(tcx, base));\n+        alt struct(tcx, basety) {\n+          ty_obj(_) { false }\n+          ty_rec(_) { true }\n+        }\n+      }\n+      ast::expr_call(f, _, _) {\n+          let fty = expr_ty(tcx, f);\n+          ast_util::ret_by_ref(ty_fn_ret_style(tcx, fty))\n+      }\n+      _ { false }\n+    }\n+}\n+\n fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n     alt s.node {\n       ast::stmt_decl(_, id) { ret id; }"}, {"sha": "35509c754966336f510192404b46549614a352ad", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/17b78c4a7a8e2a1699e8443cc88fa5f3fd224368/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b78c4a7a8e2a1699e8443cc88fa5f3fd224368/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=17b78c4a7a8e2a1699e8443cc88fa5f3fd224368", "patch": "@@ -267,18 +267,16 @@ fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, &&ast_ty: @ast::ty)\n         if vec::len(ty_param_kinds_and_ty.kinds) == 0u {\n             ret ty_param_kinds_and_ty.ty;\n         }\n-        // The typedef is type-parametric. Do the type substitution.\n-        //\n \n+        // The typedef is type-parametric. Do the type substitution.\n         let param_bindings: [ty::t] = [];\n+        if vec::len(args) != vec::len(ty_param_kinds_and_ty.kinds) {\n+            tcx.sess.span_fatal(sp, \"Wrong number of type arguments for a \\\n+                                     polymorphic type\");\n+        }\n         for ast_ty: @ast::ty in args {\n             param_bindings += [ast_ty_to_ty(tcx, getter, ast_ty)];\n         }\n-        if vec::len(param_bindings) != vec::len(ty_param_kinds_and_ty.kinds) {\n-            tcx.sess.span_fatal(sp,\n-                                \"Wrong number of type arguments for a \\\n-                                 polymorphic type\");\n-        }\n         let typ =\n             ty::substitute_type_params(tcx, param_bindings,\n                                        ty_param_kinds_and_ty.ty);"}]}