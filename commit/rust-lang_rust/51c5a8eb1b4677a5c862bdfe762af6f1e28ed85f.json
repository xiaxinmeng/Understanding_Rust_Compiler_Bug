{"sha": "51c5a8eb1b4677a5c862bdfe762af6f1e28ed85f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxYzVhOGViMWI0Njc3YTVjODYyYmRmZTc2MmFmNmYxZTI4ZWQ4NWY=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-10-10T17:30:17Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-10-10T17:30:17Z"}, "message": "Remove the runtime guide.\n\nNow that libgreen is gone, this is all wrong.\n\nFixes #17923", "tree": {"sha": "9994310600d7c2b71e7aa85efdadf20e4dbacc5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9994310600d7c2b71e7aa85efdadf20e4dbacc5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51c5a8eb1b4677a5c862bdfe762af6f1e28ed85f", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51c5a8eb1b4677a5c862bdfe762af6f1e28ed85f", "html_url": "https://github.com/rust-lang/rust/commit/51c5a8eb1b4677a5c862bdfe762af6f1e28ed85f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51c5a8eb1b4677a5c862bdfe762af6f1e28ed85f/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "158eaa643b96f474c6aeb11a94d6ba444c1f3867", "url": "https://api.github.com/repos/rust-lang/rust/commits/158eaa643b96f474c6aeb11a94d6ba444c1f3867", "html_url": "https://github.com/rust-lang/rust/commit/158eaa643b96f474c6aeb11a94d6ba444c1f3867"}], "stats": {"total": 287, "additions": 1, "deletions": 286}, "files": [{"sha": "ab73a72f00a83af1caea333fd202d8bff06fd554", "filename": "mk/docs.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51c5a8eb1b4677a5c862bdfe762af6f1e28ed85f/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/51c5a8eb1b4677a5c862bdfe762af6f1e28ed85f/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=51c5a8eb1b4677a5c862bdfe762af6f1e28ed85f", "patch": "@@ -27,7 +27,7 @@\n ######################################################################\n DOCS := index intro tutorial guide guide-ffi guide-macros guide-lifetimes \\\n \tguide-tasks guide-container guide-pointers guide-testing \\\n-\tguide-runtime guide-plugin complement-bugreport \\\n+\tguide-plugin complement-bugreport \\\n \tcomplement-lang-faq complement-design-faq complement-project-faq rust \\\n     rustdoc guide-unsafe guide-strings reference\n "}, {"sha": "578ff0edf144bef03fab520475352de5ac0c2862", "filename": "src/doc/guide-runtime.md", "status": "removed", "additions": 0, "deletions": 283, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/158eaa643b96f474c6aeb11a94d6ba444c1f3867/src%2Fdoc%2Fguide-runtime.md", "raw_url": "https://github.com/rust-lang/rust/raw/158eaa643b96f474c6aeb11a94d6ba444c1f3867/src%2Fdoc%2Fguide-runtime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-runtime.md?ref=158eaa643b96f474c6aeb11a94d6ba444c1f3867", "patch": "@@ -1,283 +0,0 @@\n-% A Guide to the Rust Runtime\n-\n-Rust includes two runtime libraries in the standard distribution, which provide\n-a unified interface to primitives such as I/O, but the language itself does not\n-require a runtime. The compiler is capable of generating code that works in all\n-environments, even kernel environments. Neither does the Rust language need a\n-runtime to provide memory safety; the type system itself is sufficient to write\n-safe code, verified statically at compile time. The runtime merely uses the\n-safety features of the language to build a number of convenient and safe\n-high-level abstractions.\n-\n-That being said, code without a runtime is often very limited in what it can do.\n-As a result, Rust's standard libraries supply a set of functionality that is\n-normally considered the Rust runtime.  This guide will discuss Rust's user-space\n-runtime, how to use it, and what it can do.\n-\n-# What is the runtime?\n-\n-The Rust runtime can be viewed as a collection of code which enables services\n-like I/O, task spawning, TLS, etc. It's essentially an ephemeral collection of\n-objects which enable programs to perform common tasks more easily. The actual\n-implementation of the runtime itself is mostly a sparse set of opt-in primitives\n-that are all self-contained and avoid leaking their abstractions into libraries.\n-\n-The current runtime is the engine behind these features (not a comprehensive\n-list):\n-\n-* I/O\n-* Task spawning\n-* Message passing\n-* Task synchronization\n-* Task-local storage\n-* Logging\n-* Task unwinding\n-\n-## What is the runtime accomplishing?\n-\n-The runtime is designed with a few goals in mind:\n-\n-* Rust libraries should work in a number of environments without having to worry\n-  about the exact details of the environment itself. Two commonly referred to\n-  environments are the M:N and 1:1 environments. Since the Rust runtime was\n-  first designed, it has supported M:N threading, and it has since gained 1:1\n-  support as well.\n-\n-* The runtime should not enforce separate \"modes of compilation\" in order to\n-  work in multiple circumstances. It is an explicit goal that you compile a Rust\n-  library once and use it forever (in all environments).\n-\n-* The runtime should be fast. There should be no architectural design barrier\n-  which is preventing programs from running at optimal speeds. It is not a goal\n-  for the runtime to be written \"as fast as can be\" at every moment in time. For\n-  example, no claims will be made that the current implementation of the runtime\n-  is the fastest it will ever be. This goal is simply to prevent any\n-  architectural roadblock from hindering performance.\n-\n-* The runtime should be nearly invisible. The design of the runtime should not\n-  encourage direct interaction with it, and using the runtime should be\n-  essentially transparent to libraries. This does not mean it should be\n-  impossible to query the runtime, but rather it should be unconventional.\n-\n-# Architecture of the runtime\n-\n-This section explains the current architecture of the Rust runtime. It has\n-evolved over the development of Rust through many iterations, and this is simply\n-the documentation of the current iteration.\n-\n-## A local task\n-\n-The core abstraction of the Rust runtime is the task. A task represents a\n-\"thread\" of execution of Rust code, but it does not necessarily correspond to an\n-OS thread. Most runtime services are accessed through the local task, allowing\n-for runtime policy decisions to be made on a per-task basis.\n-\n-A consequence of this decision is to require all Rust code using the standard\n-library to have a local `Task` structure available to them. This `Task` is\n-stored in the OS's thread local storage (OS TLS) to allow for efficient access\n-to it.\n-\n-It has also been decided that the presence or non-presence of a local `Task` is\n-essentially the *only* assumption that the runtime can make. Almost all runtime\n-services are routed through this local structure.\n-\n-This requirement of a local task is a core assumption on behalf of *all* code\n-using the standard library, hence it is defined in the standard library itself.\n-\n-## I/O\n-\n-When dealing with I/O in general, there are a few flavors by which it can be\n-dealt with, and not all flavors are right for all situations. I/O is also a\n-tricky topic that is nearly impossible to get consistent across all\n-environments. As a result, a Rust task is not guaranteed to have access to I/O,\n-and it is not even guaranteed what the implementation of the I/O will be.\n-\n-This conclusion implies that I/O *cannot* be defined in the standard library.\n-The standard library does, however, provide the interface to I/O that all Rust\n-tasks are able to consume.\n-\n-This interface is implemented differently for various flavors of tasks, and is\n-designed with a focus around synchronous I/O calls. This architecture does not\n-fundamentally prevent other forms of I/O from being defined, but it is not done\n-at this time.\n-\n-The I/O interface that the runtime must provide can be found in the\n-[std::rt::rtio](std/rt/rtio/trait.IoFactory.html) module. Note that this\n-interface is *unstable*, and likely always will be.\n-\n-## Task Spawning\n-\n-A frequent operation performed by tasks is to spawn a child task to perform some\n-work. This is the means by which parallelism is enabled in Rust. This decision\n-of how to spawn a task is not a general decision, and is hence a local decision\n-to the task (not defined in the standard library).\n-\n-Task spawning is interpreted as \"spawning a sibling\" and is enabled through the\n-high level interface in `std::task`. The child task can be configured\n-accordingly, and runtime implementations must respect these options when\n-spawning a new task.\n-\n-Another local task operation is dealing with the runnable state of the task\n-itself.  This frequently comes up when the question is \"how do I block a task?\"\n-or \"how do I wake up a task?\". These decisions are inherently local to the task\n-itself, yet again implying that they are not defined in the standard library.\n-\n-## The `Runtime` trait and the `Task` structure\n-\n-The full complement of runtime features is defined by the [`Runtime`\n-trait](std/rt/trait.Runtime.html) and the [`Task`\n-struct](std/rt/task/struct.Task.html). A `Task` is constant among all runtime\n-implementations, but each runtime has its own implementation of the\n-`Runtime` trait.\n-\n-The local `Task` stores the runtime value inside of itself, and then ownership\n-dances ensue to invoke methods on the runtime.\n-\n-# Implementations of the runtime\n-\n-The Rust distribution provides two implementations of the runtime. These two\n-implementations are generally known as 1:1 threading and M:N threading.\n-\n-As with many problems in computer science, there is no right answer in this\n-question of which implementation of the runtime to choose. Each implementation\n-has its benefits and each has its drawbacks. The descriptions below are meant to\n-inform programmers about what the implementation provides and what it doesn't\n-provide in order to make an informed decision about which to choose.\n-\n-## 1:1 - using `libnative`\n-\n-The library `libnative` is an implementation of the runtime built upon native OS\n-threads plus libc blocking I/O calls. This is called 1:1 threading because each\n-user-space thread corresponds to exactly one kernel thread.\n-\n-In this model, each Rust task corresponds to one OS thread, and each I/O object\n-essentially corresponds to a file descriptor (or the equivalent of the platform\n-you're running on).\n-\n-Some benefits to using libnative are:\n-\n-* Guaranteed interop with FFI bindings. If a C library you are using blocks the\n-  thread to do I/O (such as a database driver), then this will not interfere\n-  with other Rust tasks (because only the OS thread will be blocked).\n-* Less I/O overhead as opposed to M:N in some cases. Not all M:N I/O is\n-  guaranteed to be \"as fast as can be\", and some things (like filesystem APIs)\n-  are not truly asynchronous on all platforms, meaning that the M:N\n-  implementation may incur more overhead than a 1:1 implementation.\n-\n-## M:N - using `libgreen`\n-\n-The library `libgreen` implements the runtime with \"green threads\" on top of the\n-asynchronous I/O framework [libuv][libuv]. The M in M:N threading is the number\n-of OS threads that a process has, and the N is the number of Rust tasks. In this\n-model, N Rust tasks are multiplexed among M OS threads, and context switching is\n-implemented in user-space.\n-\n-The primary concern of an M:N runtime is that a Rust task cannot block itself in\n-a syscall. If this happens, then the entire OS thread is frozen and unavailable\n-for running more Rust tasks, making this a (M-1):N runtime (and you can see how\n-this can reach 0/deadlock). By using asynchronous I/O under the hood (all I/O\n-still looks synchronous in terms of code), OS threads are never blocked until\n-the appropriate time comes.\n-\n-Upon reading `libgreen`, you may notice that there is no I/O implementation\n-inside of the library, but rather just the infrastructure for maintaining a set\n-of green schedulers which switch among Rust tasks. The actual I/O implementation\n-is found in `librustuv` which are the Rust bindings to libuv. This distinction\n-is made to allow for other I/O implementations not built on libuv (but none\n-exist at this time).\n-\n-Some benefits of using libgreen are:\n-\n-* Fast task spawning. When using M:N threading, spawning a new task can avoid\n-  executing a syscall entirely, which can lead to more efficient task spawning\n-  times.\n-* Fast task switching. Because context switching is implemented in user-space,\n-  all task contention operations (mutexes, channels, etc) never execute\n-  syscalls, leading to much faster implementations and runtimes. An efficient\n-  context switch also leads to higher throughput servers than 1:1 threading\n-  because tasks can be switched out much more efficiently.\n-\n-### Pools of Schedulers\n-\n-M:N threading is built upon the concept of a pool of M OS threads (which\n-libgreen refers to as schedulers), able to run N Rust tasks. This abstraction is\n-encompassed in libgreen's [`SchedPool`](green/struct.SchedPool.html) type. This type allows for\n-fine-grained control over the pool of schedulers which will be used to run Rust\n-tasks.\n-\n-In addition the `SchedPool` type is the *only* way through which a new M:N task\n-can be spawned. Sibling tasks to Rust tasks themselves (created through\n-`std::task::spawn`) will be spawned into the same pool of schedulers that the\n-original task was home to. New tasks must previously have some form of handle\n-into the pool of schedulers in order to spawn a new task.\n-\n-## Which to choose?\n-\n-With two implementations of the runtime available, a choice obviously needs to\n-be made to see which will be used. The compiler itself will always by-default\n-link to one of these runtimes.\n-\n-Having a default decision made in the compiler is done out of necessity and\n-convenience. The compiler's decision of runtime to link to is *not* an\n-endorsement of one over the other. As always, this decision can be overridden.\n-\n-For example, this program will be linked to \"the default runtime\". The current\n-default runtime is to use libnative.\n-\n-~~~{.rust}\n-fn main() {}\n-~~~\n-\n-### Force booting with libgreen\n-\n-In this example, the `main` function will be booted with I/O support powered by\n-libuv. This is done by linking to the `rustuv` crate and specifying the\n-`rustuv::event_loop` function as the event loop factory.\n-\n-To create a pool of green tasks which have no I/O support, you may shed the\n-`rustuv` dependency and use the `green::basic::event_loop` function instead of\n-`rustuv::event_loop`. All tasks will have no I/O support, but they will still be\n-able to deschedule/reschedule (use channels, locks, etc).\n-\n-~~~{.ignore}\n-extern crate green;\n-extern crate rustuv;\n-\n-#[start]\n-fn start(argc: int, argv: *const *const u8) -> int {\n-    green::start(argc, argv, rustuv::event_loop, main)\n-}\n-\n-fn main() {}\n-~~~\n-\n-### Force booting with libnative\n-\n-This program's `main` function will always be booted with libnative, running\n-inside of an OS thread.\n-\n-~~~{.rust}\n-extern crate native;\n-\n-#[start]\n-fn start(argc: int, argv: *const *const u8) -> int {\n-    native::start(argc, argv, main)\n-}\n-\n-fn main() {}\n-~~~\n-\n-# Finding the runtime\n-\n-The actual code for the runtime is spread out among a few locations:\n-\n-* [std::rt][stdrt]\n-* [libnative][libnative]\n-* [libgreen][libgreen]\n-* [librustuv][librustuv]\n-\n-[libuv]: https://github.com/joyent/libuv/\n-[stdrt]: std/rt/index.html\n-[libnative]: native/index.html\n-[libgreen]: green/index.html\n-[librustuv]: rustuv/index.html"}, {"sha": "ad548d3a8f93c331c0d64928087cccdece7c1a8e", "filename": "src/doc/index.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51c5a8eb1b4677a5c862bdfe762af6f1e28ed85f/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/51c5a8eb1b4677a5c862bdfe762af6f1e28ed85f/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=51c5a8eb1b4677a5c862bdfe762af6f1e28ed85f", "patch": "@@ -62,7 +62,6 @@ a guide that can help you out:\n * [Writing Unsafe and Low-Level Code](guide-unsafe.html)\n * [Macros](guide-macros.html)\n * [Testing](guide-testing.html)\n-* [Rust's Runtime](guide-runtime.html)\n * [Compiler Plugins](guide-plugin.html)\n \n # Tools"}, {"sha": "6fd4c95794ee7e96b72b1b79b7271a0abc275ac1", "filename": "src/doc/po4a.conf", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51c5a8eb1b4677a5c862bdfe762af6f1e28ed85f/src%2Fdoc%2Fpo4a.conf", "raw_url": "https://github.com/rust-lang/rust/raw/51c5a8eb1b4677a5c862bdfe762af6f1e28ed85f/src%2Fdoc%2Fpo4a.conf", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo4a.conf?ref=51c5a8eb1b4677a5c862bdfe762af6f1e28ed85f", "patch": "@@ -15,7 +15,6 @@\n [type: text] src/doc/guide-macros.md $lang:doc/l10n/$lang/guide-macros.md\n [type: text] src/doc/guide-plugin.md $lang:doc/l10n/$lang/guide-plugin.md\n [type: text] src/doc/guide-pointers.md $lang:doc/l10n/$lang/guide-pointers.md\n-[type: text] src/doc/guide-runtime.md $lang:doc/l10n/$lang/guide-runtime.md\n [type: text] src/doc/guide-strings.md $lang:doc/l10n/$lang/guide-strings.md\n [type: text] src/doc/guide-tasks.md $lang:doc/l10n/$lang/guide-tasks.md\n [type: text] src/doc/guide-testing.md $lang:doc/l10n/$lang/guide-testing.md"}]}