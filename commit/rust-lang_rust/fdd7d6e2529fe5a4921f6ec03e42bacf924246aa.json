{"sha": "fdd7d6e2529fe5a4921f6ec03e42bacf924246aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZDdkNmUyNTI5ZmU1YTQ5MjFmNmVjMDNlNDJiYWNmOTI0MjQ2YWE=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-06-28T00:41:21Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-07-24T17:37:36Z"}, "message": "Change as_slice to as_array", "tree": {"sha": "662bf5456e51988a468ac3e5ba39b4094f688b00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/662bf5456e51988a468ac3e5ba39b4094f688b00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa", "html_url": "https://github.com/rust-lang/rust/commit/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f178dda187c479f463e74f92e3bdd8be13bad9e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f178dda187c479f463e74f92e3bdd8be13bad9e7", "html_url": "https://github.com/rust-lang/rust/commit/f178dda187c479f463e74f92e3bdd8be13bad9e7"}], "stats": {"total": 74, "additions": 21, "deletions": 53}, "files": [{"sha": "4560a0a1467c8263c93bbb6707e07042a877b64d", "filename": "crates/core_simd/src/first.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa/crates%2Fcore_simd%2Fsrc%2Ffirst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa/crates%2Fcore_simd%2Fsrc%2Ffirst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ffirst.rs?ref=fdd7d6e2529fe5a4921f6ec03e42bacf924246aa", "patch": "@@ -7,13 +7,13 @@ macro_rules! impl_vector {\n                 Self([value; LANES])\n             }\n \n-            /// Returns a slice containing the entire SIMD vector.\n-            pub const fn as_slice(&self) -> &[$type] {\n+            /// Returns an array reference containing the entire SIMD vector.\n+            pub const fn as_array(&self) -> &[$type; LANES] {\n                 &self.0\n             }\n \n-            /// Returns a mutable slice containing the entire SIMD vector.\n-            pub fn as_mut_slice(&mut self) -> &mut [$type] {\n+            /// Returns a mutable array reference containing the entire SIMD vector.\n+            pub fn as_mut_array(&mut self) -> &mut [$type; LANES] {\n                 &mut self.0\n             }\n \n@@ -24,23 +24,7 @@ macro_rules! impl_vector {\n \n             /// Converts a SIMD vector to an array.\n             pub const fn to_array(self) -> [$type; LANES] {\n-                // workaround for rust-lang/rust#80108\n-                // TODO fix this\n-                #[cfg(target_arch = \"wasm32\")]\n-                {\n-                    let mut arr = [self.0[0]; LANES];\n-                    let mut i = 0;\n-                    while i < LANES {\n-                        arr[i] = self.0[i];\n-                        i += 1;\n-                    }\n-                    arr\n-                }\n-\n-                #[cfg(not(target_arch = \"wasm32\"))]\n-                {\n-                    self.0\n-                }\n+                self.0\n             }\n         }\n "}, {"sha": "9491bdd1d5a6bbd2b07116f732033ee183b28483", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=fdd7d6e2529fe5a4921f6ec03e42bacf924246aa", "patch": "@@ -331,7 +331,7 @@ macro_rules! impl_unsigned_int_ops {\n \n                         #[inline]\n                         fn div(self, rhs: Self) -> Self::Output {\n-                            if rhs.as_slice()\n+                            if rhs.as_array()\n                                 .iter()\n                                 .any(|x| *x == 0)\n                             {\n@@ -340,8 +340,8 @@ macro_rules! impl_unsigned_int_ops {\n \n                             // Guards for div(MIN, -1),\n                             // this check only applies to signed ints\n-                            if <$scalar>::MIN != 0 && self.as_slice().iter()\n-                                    .zip(rhs.as_slice().iter())\n+                            if <$scalar>::MIN != 0 && self.as_array().iter()\n+                                    .zip(rhs.as_array().iter())\n                                     .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n                                 panic!(\"attempt to divide with overflow\");\n                             }\n@@ -363,7 +363,7 @@ macro_rules! impl_unsigned_int_ops {\n                                 panic!(\"attempt to divide by zero\");\n                             }\n                             if <$scalar>::MIN != 0 &&\n-                                self.as_slice().iter().any(|x| *x == <$scalar>::MIN) &&\n+                                self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n                                 rhs == -1 as _ {\n                                     panic!(\"attempt to divide with overflow\");\n                             }\n@@ -421,7 +421,7 @@ macro_rules! impl_unsigned_int_ops {\n \n                         #[inline]\n                         fn rem(self, rhs: Self) -> Self::Output {\n-                            if rhs.as_slice()\n+                            if rhs.as_array()\n                                 .iter()\n                                 .any(|x| *x == 0)\n                             {\n@@ -430,8 +430,8 @@ macro_rules! impl_unsigned_int_ops {\n \n                             // Guards for rem(MIN, -1)\n                             // this branch applies the check only to signed ints\n-                            if <$scalar>::MIN != 0 && self.as_slice().iter()\n-                                    .zip(rhs.as_slice().iter())\n+                            if <$scalar>::MIN != 0 && self.as_array().iter()\n+                                    .zip(rhs.as_array().iter())\n                                     .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n                                 panic!(\"attempt to calculate the remainder with overflow\");\n                             }\n@@ -453,7 +453,7 @@ macro_rules! impl_unsigned_int_ops {\n                                 panic!(\"attempt to calculate the remainder with a divisor of zero\");\n                             }\n                             if <$scalar>::MIN != 0 &&\n-                                self.as_slice().iter().any(|x| *x == <$scalar>::MIN) &&\n+                                self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n                                 rhs == -1 as _ {\n                                     panic!(\"attempt to calculate the remainder with overflow\");\n                             }\n@@ -512,7 +512,7 @@ macro_rules! impl_unsigned_int_ops {\n                         #[inline]\n                         fn shl(self, rhs: Self) -> Self::Output {\n                             // TODO there is probably a better way of doing this\n-                            if rhs.as_slice()\n+                            if rhs.as_array()\n                                 .iter()\n                                 .copied()\n                                 .any(invalid_shift_rhs)\n@@ -577,7 +577,7 @@ macro_rules! impl_unsigned_int_ops {\n                         #[inline]\n                         fn shr(self, rhs: Self) -> Self::Output {\n                             // TODO there is probably a better way of doing this\n-                            if rhs.as_slice()\n+                            if rhs.as_array()\n                                 .iter()\n                                 .copied()\n                                 .any(invalid_shift_rhs)"}, {"sha": "41cf6fab612a90ae90f228493b86e3c92ea5facd", "filename": "crates/core_simd/src/reduction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=fdd7d6e2529fe5a4921f6ec03e42bacf924246aa", "patch": "@@ -64,7 +64,7 @@ macro_rules! impl_float_reductions {\n             pub fn horizontal_sum(self) -> $scalar {\n                 // LLVM sum is inaccurate on i586\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n-                    self.as_slice().iter().sum()\n+                    self.as_array().iter().sum()\n                 } else {\n                     unsafe { crate::intrinsics::simd_reduce_add_ordered(self, 0.) }\n                 }\n@@ -75,7 +75,7 @@ macro_rules! impl_float_reductions {\n             pub fn horizontal_product(self) -> $scalar {\n                 // LLVM product is inaccurate on i586\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n-                    self.as_slice().iter().product()\n+                    self.as_array().iter().product()\n                 } else {\n                     unsafe { crate::intrinsics::simd_reduce_mul_ordered(self, 1.) }\n                 }"}, {"sha": "0ca1ea14e2d508bb0a1cfc63628a576947e31aaa", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=fdd7d6e2529fe5a4921f6ec03e42bacf924246aa", "patch": "@@ -12,7 +12,7 @@ macro_rules! impl_integer_vector {\n             #[inline]\n             fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n                 // TODO use SIMD cmp\n-                self.to_array().cmp(other.as_ref())\n+                self.as_array().cmp(other.as_ref())\n             }\n         }\n \n@@ -22,7 +22,7 @@ macro_rules! impl_integer_vector {\n             where\n                 H: core::hash::Hasher\n             {\n-                self.as_slice().hash(state)\n+                self.as_array().hash(state)\n             }\n         }\n "}, {"sha": "a7adca80f8bda51cc4553dce887b40ae4c615105", "filename": "crates/core_simd/src/vector/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa/crates%2Fcore_simd%2Fsrc%2Fvector%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa/crates%2Fcore_simd%2Fsrc%2Fvector%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fmod.rs?ref=fdd7d6e2529fe5a4921f6ec03e42bacf924246aa", "patch": "@@ -30,12 +30,6 @@ pub trait Vector: sealed::Sealed {\n     /// Generates a SIMD vector with the same value in every lane.\n     #[must_use]\n     fn splat(val: Self::Scalar) -> Self;\n-\n-    /// Returns a slice containing the entire SIMD vector.\n-    fn as_slice(&self) -> &[Self::Scalar];\n-\n-    /// Returns a mutable slice containing the entire SIMD vector.\n-    fn as_mut_slice(&mut self) -> &mut [Self::Scalar];\n }\n \n macro_rules! impl_vector_for {\n@@ -60,16 +54,6 @@ macro_rules! impl_vector_for {\n             fn splat(val: Self::Scalar) -> Self {\n                 Self::splat(val)\n             }\n-\n-            #[inline]\n-            fn as_slice(&self) -> &[Self::Scalar] {\n-                self.as_slice()\n-            }\n-\n-            #[inline]\n-            fn as_mut_slice(&mut self) -> &mut [Self::Scalar] {\n-                self.as_mut_slice()\n-            }\n         }\n     };\n }"}, {"sha": "e7a6a8880121e121d09fb9a06fbed7fa0c4a3f30", "filename": "crates/core_simd/src/vector/uint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd7d6e2529fe5a4921f6ec03e42bacf924246aa/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=fdd7d6e2529fe5a4921f6ec03e42bacf924246aa", "patch": "@@ -12,7 +12,7 @@ macro_rules! impl_unsigned_vector {\n             #[inline]\n             fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n                 // TODO use SIMD cmp\n-                self.to_array().cmp(other.as_ref())\n+                self.as_array().cmp(other.as_ref())\n             }\n         }\n \n@@ -22,7 +22,7 @@ macro_rules! impl_unsigned_vector {\n             where\n                 H: core::hash::Hasher\n             {\n-                self.as_slice().hash(state)\n+                self.as_array().hash(state)\n             }\n         }\n     }"}]}