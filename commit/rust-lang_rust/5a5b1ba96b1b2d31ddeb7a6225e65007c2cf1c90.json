{"sha": "5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNWIxYmE5NmIxYjJkMzFkZGViN2E2MjI1ZTY1MDA3YzJjZjFjOTA=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-22T17:06:48Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-22T17:06:48Z"}, "message": "Merge pull request #216 from birkenfeld/match_pass\n\nnew lint: using &Ref patterns instead of matching on *expr (fixes #187)", "tree": {"sha": "4d11ea656aacf65493f3b0f159f0ddac192a734b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d11ea656aacf65493f3b0f159f0ddac192a734b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "html_url": "https://github.com/rust-lang/rust/commit/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29c602c7ac5bff1bef8a1ac5edf112880f44cd5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/29c602c7ac5bff1bef8a1ac5edf112880f44cd5f", "html_url": "https://github.com/rust-lang/rust/commit/29c602c7ac5bff1bef8a1ac5edf112880f44cd5f"}, {"sha": "7580da306e338089b1cffedb09a71cb11debddf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7580da306e338089b1cffedb09a71cb11debddf5", "html_url": "https://github.com/rust-lang/rust/commit/7580da306e338089b1cffedb09a71cb11debddf5"}], "stats": {"total": 255, "additions": 155, "deletions": 100}, "files": [{"sha": "72ce27392a72acceabe6c3f364cfabd67afab8c1", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "patch": "@@ -29,6 +29,7 @@ len_zero                 | warn    | checking `.len() == 0` or `.len() > 0` (or\n let_and_return           | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a function\n let_unit_value           | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n linkedlist               | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a RingBuf\n+match_ref_pats           | warn    | a match has all arms prefixed with `&`; the match expression can be dereferenced instead\n modulo_one               | warn    | taking a number modulo 1, which always returns 0\n mut_mut                  | warn    | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)\n needless_bool            | warn    | if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`"}, {"sha": "3e0ba4eb669f8e20941033c4c6b3558da1c2f5e6", "filename": "src/approx_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "patch": "@@ -37,10 +37,10 @@ impl LintPass for ApproxConstant {\n }\n \n fn check_lit(cx: &Context, lit: &Lit, span: Span) {\n-    match &lit.node {\n-        &LitFloat(ref str, TyF32) => check_known_consts(cx, span, str, \"f32\"),\n-        &LitFloat(ref str, TyF64) => check_known_consts(cx, span, str, \"f64\"),\n-        &LitFloatUnsuffixed(ref str) => check_known_consts(cx, span, str, \"f{32, 64}\"),\n+    match lit.node {\n+        LitFloat(ref str, TyF32) => check_known_consts(cx, span, str, \"f32\"),\n+        LitFloat(ref str, TyF64) => check_known_consts(cx, span, str, \"f64\"),\n+        LitFloatUnsuffixed(ref str) => check_known_consts(cx, span, str, \"f{32, 64}\"),\n         _ => ()\n     }\n }"}, {"sha": "6537fcf4c1abb77be0211a1e01cdf0b26c969491", "filename": "src/bit_mask.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "patch": "@@ -82,9 +82,9 @@ fn invert_cmp(cmp : BinOp_) -> BinOp_ {\n \n \n fn check_compare(cx: &Context, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u64, span: &Span) {\n-    match &bit_op.node {\n-        &ExprParen(ref subexp) => check_compare(cx, subexp, cmp_op, cmp_value, span),\n-        &ExprBinary(ref op, ref left, ref right) => {\n+    match bit_op.node {\n+        ExprParen(ref subexp) => check_compare(cx, subexp, cmp_op, cmp_value, span),\n+        ExprBinary(ref op, ref left, ref right) => {\n             if op.node != BiBitAnd && op.node != BiBitOr { return; }\n             fetch_int_literal(cx, right).or_else(|| fetch_int_literal(\n                 cx, left)).map_or((), |mask| check_bit_mask(cx, op.node,\n@@ -182,13 +182,13 @@ fn check_ineffective_gt(cx: &Context, span: Span, m: u64, c: u64, op: &str) {\n }\n \n fn fetch_int_literal(cx: &Context, lit : &Expr) -> Option<u64> {\n-    match &lit.node {\n-        &ExprLit(ref lit_ptr) => {\n+    match lit.node {\n+        ExprLit(ref lit_ptr) => {\n             if let &LitInt(value, _) = &lit_ptr.node {\n                 Option::Some(value) //TODO: Handle sign\n             } else { Option::None }\n         },\n-        &ExprPath(_, _) => {\n+        ExprPath(_, _) => {\n             // Important to let the borrow expire before the const lookup to avoid double\n             // borrowing.\n             let def_map = cx.tcx.def_map.borrow();"}, {"sha": "25e967b07e54d45df7b50349a2aa3e85ea5d2f36", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "patch": "@@ -18,9 +18,9 @@ impl LintPass for EtaPass {\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        match &expr.node {\n-            &ExprCall(_, ref args) |\n-            &ExprMethodCall(_, _, ref args) => {\n+        match expr.node {\n+            ExprCall(_, ref args) |\n+            ExprMethodCall(_, _, ref args) => {\n                 for arg in args {\n                     check_closure(cx, &*arg)\n                 }"}, {"sha": "5eaa0256402df186e0d37341cfc55e862ac11a11", "filename": "src/len_zero.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "patch": "@@ -22,10 +22,10 @@ impl LintPass for LenZero {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &Item) {\n-        match &item.node {\n-            &ItemTrait(_, _, _, ref trait_items) =>\n+        match item.node {\n+            ItemTrait(_, _, _, ref trait_items) =>\n                 check_trait_items(cx, item, trait_items),\n-            &ItemImpl(_, _, _, None, _, ref impl_items) => // only non-trait\n+            ItemImpl(_, _, _, None, _, ref impl_items) => // only non-trait\n                 check_impl_items(cx, item, impl_items),\n             _ => ()\n         }\n@@ -100,7 +100,7 @@ fn check_cmp(cx: &Context, span: Span, left: &Expr, right: &Expr, op: &str) {\n \n fn check_len_zero(cx: &Context, span: Span, method: &SpannedIdent,\n                   args: &[P<Expr>], lit: &Lit, op: &str) {\n-    if let &Spanned{node: LitInt(0, _), ..} = lit {\n+    if let Spanned{node: LitInt(0, _), ..} = *lit {\n         if method.node.name == \"len\" && args.len() == 1 &&\n             has_is_empty(cx, &*args[0]) {\n                 span_lint(cx, LEN_ZERO, span, &format!("}, {"sha": "26af063c9a5b04371e4bf821ca0a133b2a59da5f", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "patch": "@@ -38,11 +38,11 @@ pub mod returns;\n pub mod lifetimes;\n pub mod loops;\n pub mod ranges;\n+pub mod matches;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box types::TypePass as LintPassObject);\n-    reg.register_lint_pass(box misc::MiscPass as LintPassObject);\n     reg.register_lint_pass(box misc::TopLevelRefPass as LintPassObject);\n     reg.register_lint_pass(box misc::CmpNan as LintPassObject);\n     reg.register_lint_pass(box eq_op::EqOp as LintPassObject);\n@@ -71,6 +71,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box ranges::StepByZero as LintPassObject);\n     reg.register_lint_pass(box types::CastPass as LintPassObject);\n     reg.register_lint_pass(box types::TypeComplexityPass as LintPassObject);\n+    reg.register_lint_pass(box matches::MatchPass as LintPassObject);\n \n     reg.register_lint_group(\"clippy\", vec![\n         approx_const::APPROX_CONSTANT,\n@@ -87,6 +88,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         loops::EXPLICIT_ITER_LOOP,\n         loops::ITER_NEXT_LOOP,\n         loops::NEEDLESS_RANGE_LOOP,\n+        matches::MATCH_REF_PATS,\n+        matches::SINGLE_MATCH,\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n         methods::STR_TO_STRING,\n@@ -96,7 +99,6 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         misc::FLOAT_CMP,\n         misc::MODULO_ONE,\n         misc::PRECEDENCE,\n-        misc::SINGLE_MATCH,\n         misc::TOPLEVEL_REF_ARG,\n         mut_mut::MUT_MUT,\n         needless_bool::NEEDLESS_BOOL,"}, {"sha": "002da07f50b7180b38eb6e4b815c6c98b5f59604", "filename": "src/matches.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "patch": "@@ -0,0 +1,86 @@\n+use rustc::lint::*;\n+use syntax::ast;\n+use syntax::ast::*;\n+use std::borrow::Cow;\n+\n+use utils::{snippet, snippet_block, span_lint, span_help_and_lint};\n+\n+declare_lint!(pub SINGLE_MATCH, Warn,\n+              \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n+               is `_ => {}`) is used; recommends `if let` instead\");\n+declare_lint!(pub MATCH_REF_PATS, Warn,\n+              \"a match has all arms prefixed with `&`; the match expression can be \\\n+               dereferenced instead\");\n+\n+#[allow(missing_copy_implementations)]\n+pub struct MatchPass;\n+\n+impl LintPass for MatchPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(SINGLE_MATCH, MATCH_REF_PATS)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        if let ExprMatch(ref ex, ref arms, ast::MatchSource::Normal) = expr.node {\n+            // check preconditions for SINGLE_MATCH\n+                // only two arms\n+            if arms.len() == 2 &&\n+                // both of the arms have a single pattern and no guard\n+                arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n+                // and the second pattern is a `_` wildcard: this is not strictly necessary,\n+                // since the exhaustiveness check will ensure the last one is a catch-all,\n+                // but in some cases, an explicit match is preferred to catch situations\n+                // when an enum is extended, so we don't consider these cases\n+                arms[1].pats[0].node == PatWild(PatWildSingle) &&\n+                // finally, we don't want any content in the second arm (unit or empty block)\n+                is_unit_expr(&*arms[1].body)\n+            {\n+                let body_code = snippet_block(cx, arms[0].body.span, \"..\");\n+                let body_code = if let ExprBlock(_) = arms[0].body.node {\n+                    body_code\n+                } else {\n+                    Cow::Owned(format!(\"{{ {} }}\", body_code))\n+                };\n+                span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n+                      \"you seem to be trying to use match for \\\n+                      destructuring a single pattern. Did you mean to \\\n+                      use `if let`?\",\n+                      &*format!(\"try\\nif let {} = {} {}\",\n+                                snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                snippet(cx, ex.span, \"..\"),\n+                                body_code)\n+                );\n+            }\n+\n+            // check preconditions for MATCH_REF_PATS\n+            if has_only_ref_pats(arms) {\n+                if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n+                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n+                        \"you don't need to add `&` to both the expression to match \\\n+                         and the patterns: use `match {} {{ ...`\", snippet(cx, inner.span, \"..\")));\n+                } else {\n+                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n+                        \"instead of prefixing all patterns with `&`, you can dereference the \\\n+                         expression to match: `match *{} {{ ...`\", snippet(cx, ex.span, \"..\")));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_unit_expr(expr: &Expr) -> bool {\n+    match expr.node {\n+        ExprTup(ref v) if v.is_empty() => true,\n+        ExprBlock(ref b) if b.stmts.is_empty() && b.expr.is_none() => true,\n+        _ => false,\n+    }\n+}\n+\n+fn has_only_ref_pats(arms: &[Arm]) -> bool {\n+    arms.iter().flat_map(|a| &a.pats).all(|p| match p.node {\n+        PatRegion(..) => true,  // &-patterns\n+        PatWild(..) => true,    // an \"anything\" wildcard is also fine\n+        _ => false,\n+    })\n+}"}, {"sha": "81b03db5e143eabf04b214428d515f55aaab65a2", "filename": "src/misc.rs", "status": "modified", "additions": 4, "deletions": 65, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "patch": "@@ -1,75 +1,14 @@\n use rustc::lint::*;\n use syntax::ptr::P;\n-use syntax::ast;\n use syntax::ast::*;\n use syntax::ast_util::{is_comparison_binop, binop_to_string};\n use syntax::codemap::{Span, Spanned};\n use syntax::visit::FnKind;\n use rustc::middle::ty;\n-use std::borrow::Cow;\n \n-use utils::{match_path, snippet, snippet_block, span_lint, span_help_and_lint, walk_ptrs_ty};\n+use utils::{match_path, snippet, span_lint, walk_ptrs_ty};\n use consts::constant;\n \n-/// Handles uncategorized lints\n-/// Currently handles linting of if-let-able matches\n-#[allow(missing_copy_implementations)]\n-pub struct MiscPass;\n-\n-\n-declare_lint!(pub SINGLE_MATCH, Warn,\n-              \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n-               is `_ => {}`) is used; recommends `if let` instead\");\n-\n-impl LintPass for MiscPass {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(SINGLE_MATCH)\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        if let ExprMatch(ref ex, ref arms, ast::MatchSource::Normal) = expr.node {\n-            // check preconditions: only two arms\n-            if arms.len() == 2 &&\n-                // both of the arms have a single pattern and no guard\n-                arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n-                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n-                // and the second pattern is a `_` wildcard: this is not strictly necessary,\n-                // since the exhaustiveness check will ensure the last one is a catch-all,\n-                // but in some cases, an explicit match is preferred to catch situations\n-                // when an enum is extended, so we don't consider these cases\n-                arms[1].pats[0].node == PatWild(PatWildSingle) &&\n-                // finally, we don't want any content in the second arm (unit or empty block)\n-                is_unit_expr(&*arms[1].body)\n-            {\n-                let body_code = snippet_block(cx, arms[0].body.span, \"..\");\n-                let body_code = if let ExprBlock(_) = arms[0].body.node {\n-                    body_code\n-                } else {\n-                    Cow::Owned(format!(\"{{ {} }}\", body_code))\n-                };\n-                span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n-                      \"you seem to be trying to use match for \\\n-                      destructuring a single pattern. Did you mean to \\\n-                      use `if let`?\",\n-                      &*format!(\"try\\nif let {} = {} {}\",\n-                                snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                snippet(cx, ex.span, \"..\"),\n-                                body_code)\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn is_unit_expr(expr: &Expr) -> bool {\n-    match expr.node {\n-        ExprTup(ref v) if v.is_empty() => true,\n-        ExprBlock(ref b) if b.stmts.is_empty() && b.expr.is_none() => true,\n-        _ => false,\n-    }\n-}\n-\n-\n declare_lint!(pub TOPLEVEL_REF_ARG, Warn,\n               \"a function argument is declared `ref` (i.e. `fn foo(ref x: u8)`, but not \\\n                `fn foo((ref x, ref y): (u8, u8))`)\");\n@@ -236,8 +175,8 @@ impl LintPass for CmpOwned {\n }\n \n fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n-    match &expr.node {\n-        &ExprMethodCall(Spanned{node: ref ident, ..}, _, ref args) => {\n+    match expr.node {\n+        ExprMethodCall(Spanned{node: ref ident, ..}, _, ref args) => {\n             let name = ident.name;\n             if name == \"to_string\" ||\n                 name == \"to_owned\" && is_str_arg(cx, args) {\n@@ -247,7 +186,7 @@ fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n                         snippet(cx, other_span, \"..\")))\n                 }\n         },\n-        &ExprCall(ref path, _) => {\n+        ExprCall(ref path, _) => {\n             if let &ExprPath(None, ref path) = &path.node {\n                 if match_path(path, &[\"String\", \"from_str\"]) ||\n                     match_path(path, &[\"String\", \"from\"]) {"}, {"sha": "7671d63a35d4fde92ed9aaf90de040759c311b70", "filename": "src/needless_bool.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "patch": "@@ -60,9 +60,9 @@ fn fetch_bool_block(block: &Block) -> Option<bool> {\n }\n \n fn fetch_bool_expr(expr: &Expr) -> Option<bool> {\n-    match &expr.node {\n-        &ExprBlock(ref block) => fetch_bool_block(block),\n-        &ExprLit(ref lit_ptr) => if let &LitBool(value) = &lit_ptr.node {\n+    match expr.node {\n+        ExprBlock(ref block) => fetch_bool_block(block),\n+        ExprLit(ref lit_ptr) => if let LitBool(value) = lit_ptr.node {\n             Some(value) } else { None },\n         _ => None\n     }"}, {"sha": "b24ea345244aeedbb9d13281558393cc0afa2b3e", "filename": "src/strings.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "patch": "@@ -65,13 +65,13 @@ fn is_string(cx: &Context, e: &Expr) -> bool {\n }\n \n fn is_add(cx: &Context, src: &Expr, target: &Expr) -> bool {\n-    match &src.node {\n-        &ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) =>\n+    match src.node {\n+        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) =>\n             is_exp_equal(cx, target, left),\n-        &ExprBlock(ref block) => block.stmts.is_empty() &&\n+        ExprBlock(ref block) => block.stmts.is_empty() &&\n             block.expr.as_ref().map_or(false,\n                 |expr| is_add(cx, &*expr, target)),\n-        &ExprParen(ref expr) => is_add(cx, &*expr, target),\n+        ExprParen(ref expr) => is_add(cx, &*expr, target),\n         _ => false\n     }\n }"}, {"sha": "2b1aa5155591073880086d72e0ffb7693f9139df", "filename": "src/types.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "patch": "@@ -116,10 +116,10 @@ declare_lint!(pub CAST_POSSIBLE_TRUNCATION, Allow,\n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n-    let n = match &typ.sty {\n-    &ty::TyInt(i) =>  4 << (i as usize),\n-    &ty::TyUint(u) => 4 << (u as usize),\n-    _ => 0\n+    let n = match typ.sty {\n+        ty::TyInt(i) =>  4 << (i as usize),\n+        ty::TyUint(u) => 4 << (u as usize),\n+        _ => 0\n     };\n     // n == 4 is the usize/isize case\n     if n == 4 { ::std::usize::BITS } else { n }\n@@ -139,16 +139,16 @@ impl LintPass for CastPass {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n                         let from_nbits = int_ty_to_nbits(cast_from);\n-                        let to_nbits : usize = match &cast_to.sty {\n-                            &ty::TyFloat(ast::TyF32) => 32,\n-                            &ty::TyFloat(ast::TyF64) => 64,\n+                        let to_nbits : usize = match cast_to.sty {\n+                            ty::TyFloat(ast::TyF32) => 32,\n+                            ty::TyFloat(ast::TyF64) => 64,\n                             _ => 0\n                         };\n                         if from_nbits != 0 {\n                             if from_nbits >= to_nbits {\n                                 span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n                                           &format!(\"converting from {0} to {1}, which causes a loss of precision \\\n-                                          \t\t\t({0} is {2} bits wide, but {1}'s mantissa is only {3} bits wide)\",\n+                                                    ({0} is {2} bits wide, but {1}'s mantissa is only {3} bits wide)\",\n                                                    cast_from, cast_to, from_nbits, if to_nbits == 64 {52} else {23} ));\n                             }\n                         }"}, {"sha": "3cc540992c99c5629561f4197fc072355ddb52e3", "filename": "tests/compile-fail/matches.rs", "status": "renamed", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/tests%2Fcompile-fail%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90/tests%2Fcompile-fail%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatches.rs?ref=5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "patch": "@@ -2,8 +2,9 @@\n \n #![plugin(clippy)]\n #![deny(clippy)]\n+#![allow(unused)]\n \n-fn main(){\n+fn single_match(){\n     let x = Some(1u8);\n     match x {  //~ ERROR you seem to be trying to use match\n                //~^ HELP try\n@@ -36,3 +37,29 @@ fn main(){\n         _ => println!(\"nope\"),\n     }\n }\n+\n+fn ref_pats() {\n+    let ref v = Some(0);\n+    match v {  //~ERROR instead of prefixing all patterns with `&`\n+        &Some(v) => println!(\"{:?}\", v),\n+        &None => println!(\"none\"),\n+    }\n+    match v {  // this doesn't trigger, we have a different pattern\n+        &Some(v) => println!(\"some\"),\n+        other => println!(\"other\"),\n+    }\n+    let ref tup = (1, 2);\n+    match tup {  //~ERROR instead of prefixing all patterns with `&`\n+        &(v, 1) => println!(\"{}\", v),\n+        _ => println!(\"none\"),\n+    }\n+    // special case: using & both in expr and pats\n+    let w = Some(0);\n+    match &w {  //~ERROR you don't need to add `&` to both\n+        &Some(v) => println!(\"{:?}\", v),\n+        &None => println!(\"none\"),\n+    }\n+}\n+\n+fn main() {\n+}", "previous_filename": "tests/compile-fail/match_if_let.rs"}]}