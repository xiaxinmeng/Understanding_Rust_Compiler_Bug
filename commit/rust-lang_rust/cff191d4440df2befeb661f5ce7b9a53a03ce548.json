{"sha": "cff191d4440df2befeb661f5ce7b9a53a03ce548", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZjE5MWQ0NDQwZGYyYmVmZWI2NjFmNWNlN2I5YTUzYTAzY2U1NDg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-05T11:25:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-16T10:57:42Z"}, "message": "move refcells out from `RegionVarBindings` and up into `InferCtxt`", "tree": {"sha": "abd142347128f88e7f1581cc9be1372591c65103", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abd142347128f88e7f1581cc9be1372591c65103"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cff191d4440df2befeb661f5ce7b9a53a03ce548", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cff191d4440df2befeb661f5ce7b9a53a03ce548", "html_url": "https://github.com/rust-lang/rust/commit/cff191d4440df2befeb661f5ce7b9a53a03ce548", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cff191d4440df2befeb661f5ce7b9a53a03ce548/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "url": "https://api.github.com/repos/rust-lang/rust/commits/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "html_url": "https://github.com/rust-lang/rust/commit/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06"}], "stats": {"total": 307, "additions": 151, "deletions": 156}, "files": [{"sha": "dbe3905a8c61944a6824161a856e411bf0f84b3e", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=cff191d4440df2befeb661f5ce7b9a53a03ce548", "patch": "@@ -104,7 +104,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                a,\n                b);\n         let origin = Subtype(self.fields.trace.clone());\n-        self.fields.infcx.region_vars.make_eqregion(origin, a, b);\n+        self.fields.infcx.region_vars.borrow_mut().make_eqregion(origin, a, b);\n         Ok(a)\n     }\n "}, {"sha": "b6637069408e05ad22b401829b82d18093fe981a", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=cff191d4440df2befeb661f5ce7b9a53a03ce548", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         self.type_variables.borrow_mut().types_created_since_snapshot(\n                             &snapshot.type_snapshot);\n                     let region_vars =\n-                        self.region_vars.vars_created_since_snapshot(\n+                        self.region_vars.borrow().vars_created_since_snapshot(\n                             &snapshot.region_vars_snapshot);\n \n                     Ok((type_variables, region_vars, value))"}, {"sha": "c0e1369410616131e52a8287b40e0726d41ce44f", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=cff191d4440df2befeb661f5ce7b9a53a03ce548", "patch": "@@ -67,7 +67,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                b);\n \n         let origin = Subtype(self.fields.trace.clone());\n-        Ok(self.fields.infcx.region_vars.glb_regions(self.tcx(), origin, a, b))\n+        Ok(self.fields.infcx.region_vars.borrow_mut().glb_regions(self.tcx(), origin, a, b))\n     }\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)"}, {"sha": "e2a214ed0cbfe95ccb9bfcc04e7fc3b204663f1a", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=cff191d4440df2befeb661f5ce7b9a53a03ce548", "patch": "@@ -176,9 +176,9 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                      .filter(|&r| r != representative)\n                 {\n                     let origin = SubregionOrigin::Subtype(self.trace.clone());\n-                    self.infcx.region_vars.make_eqregion(origin,\n-                                                         *representative,\n-                                                         *region);\n+                    self.infcx.region_vars.borrow_mut().make_eqregion(origin,\n+                                                                      *representative,\n+                                                                      *region);\n                 }\n             }\n \n@@ -427,7 +427,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         fn fresh_bound_variable<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                                 debruijn: ty::DebruijnIndex)\n                                                 -> ty::Region<'tcx> {\n-            infcx.region_vars.new_bound(infcx.tcx, debruijn)\n+            infcx.region_vars.borrow_mut().new_bound(infcx.tcx, debruijn)\n         }\n     }\n }\n@@ -481,7 +481,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                        r: ty::Region<'tcx>,\n                        directions: TaintDirections)\n                        -> FxHashSet<ty::Region<'tcx>> {\n-        self.region_vars.tainted(self.tcx, &snapshot.region_vars_snapshot, r, directions)\n+        self.region_vars.borrow().tainted(self.tcx, &snapshot.region_vars_snapshot, r, directions)\n     }\n \n     fn region_vars_confined_to_snapshot(&self,\n@@ -539,7 +539,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n          */\n \n         let mut region_vars =\n-            self.region_vars.vars_created_since_snapshot(&snapshot.region_vars_snapshot);\n+            self.region_vars.borrow().vars_created_since_snapshot(&snapshot.region_vars_snapshot);\n \n         let escaping_types =\n             self.type_variables.borrow_mut().types_escaping_snapshot(&snapshot.type_snapshot);\n@@ -581,7 +581,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         where T : TypeFoldable<'tcx>\n     {\n         let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n-            self.region_vars.push_skolemized(self.tcx, br, &snapshot.region_vars_snapshot)\n+            self.region_vars.borrow_mut().push_skolemized(self.tcx,\n+                                                          br,\n+                                                          &snapshot.region_vars_snapshot)\n         });\n \n         debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n@@ -766,7 +768,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"pop_skolemized({:?})\", skol_map);\n         let skol_regions: FxHashSet<_> = skol_map.values().cloned().collect();\n-        self.region_vars.pop_skolemized(self.tcx, &skol_regions, &snapshot.region_vars_snapshot);\n+        self.region_vars.borrow_mut().pop_skolemized(self.tcx,\n+                                                     &skol_regions,\n+                                                     &snapshot.region_vars_snapshot);\n         if !skol_map.is_empty() {\n             self.projection_cache.borrow_mut().rollback_skolemized(\n                 &snapshot.projection_cache_snapshot);"}, {"sha": "dd775fb5e17cebbeed5ad919661a2923c5e9388e", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=cff191d4440df2befeb661f5ce7b9a53a03ce548", "patch": "@@ -113,8 +113,7 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n         }\n     };\n \n-    let constraints = &*region_vars.constraints.borrow();\n-    match dump_region_constraints_to(region_rels, constraints, &output_path) {\n+    match dump_region_constraints_to(region_rels, &region_vars.constraints, &output_path) {\n         Ok(()) => {}\n         Err(e) => {\n             let msg = format!(\"io error dumping region constraints: {}\", e);"}, {"sha": "ac3ba57d980c1631f4372963097fd9d7007569c4", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=cff191d4440df2befeb661f5ce7b9a53a03ce548", "patch": "@@ -80,7 +80,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n     /// constraints, assuming such values can be found; if they cannot,\n     /// errors are reported.\n     pub fn resolve_regions(\n-        &self,\n+        &mut self,\n         region_rels: &RegionRelations<'_, '_, 'tcx>,\n     ) -> (\n         LexicalRegionResolutions<'tcx>,\n@@ -114,7 +114,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n \n             (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n                 span_bug!(\n-                    (*self.var_origins.borrow())[v_id.index as usize].span(),\n+                    self.var_origins[v_id.index as usize].span(),\n                     \"lub_concrete_regions invoked with non-concrete \\\n                      regions: {:?}, {:?}\",\n                     a,\n@@ -183,7 +183,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n     }\n \n     fn infer_variable_values(\n-        &self,\n+        &mut self,\n         region_rels: &RegionRelations<'_, '_, 'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) -> LexicalRegionResolutions<'tcx> {\n@@ -222,12 +222,12 @@ impl<'tcx> RegionVarBindings<'tcx> {\n             \"----() Start constraint listing (context={:?}) ()----\",\n             free_regions.context\n         );\n-        for (idx, (constraint, _)) in self.constraints.borrow().iter().enumerate() {\n+        for (idx, (constraint, _)) in self.constraints.iter().enumerate() {\n             debug!(\"Constraint {} => {:?}\", idx, constraint);\n         }\n     }\n \n-    fn expand_givens(&self, graph: &RegionGraph) {\n+    fn expand_givens(&mut self, graph: &RegionGraph) {\n         // Givens are a kind of horrible hack to account for\n         // constraints like 'c <= '0 that are known to hold due to\n         // closure signatures (see the comment above on the `givens`\n@@ -238,15 +238,14 @@ impl<'tcx> RegionVarBindings<'tcx> {\n         //     and   '0 <= '1\n         //     then  'c <= '1\n \n-        let mut givens = self.givens.borrow_mut();\n-        let seeds: Vec<_> = givens.iter().cloned().collect();\n+        let seeds: Vec<_> = self.givens.iter().cloned().collect();\n         for (r, vid) in seeds {\n             let seed_index = NodeIndex(vid.index as usize);\n             for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n                 let succ_index = succ_index.0 as u32;\n                 if succ_index < self.num_vars() {\n                     let succ_vid = RegionVid { index: succ_index };\n-                    givens.insert((r, succ_vid));\n+                    self.givens.insert((r, succ_vid));\n                 }\n             }\n         }\n@@ -292,7 +291,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n         // Check if this relationship is implied by a given.\n         match *a_region {\n             ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                if self.givens.borrow().contains(&(a_region, b_vid)) {\n+                if self.givens.contains(&(a_region, b_vid)) {\n                     debug!(\"given\");\n                     return false;\n                 }\n@@ -333,8 +332,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n         var_data: &mut LexicalRegionResolutions<'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n-        let constraints = self.constraints.borrow();\n-        for (constraint, origin) in constraints.iter() {\n+        for (constraint, origin) in &self.constraints {\n             debug!(\n                 \"collect_errors: constraint={:?} origin={:?}\",\n                 constraint,\n@@ -392,7 +390,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n             }\n         }\n \n-        for verify in self.verifys.borrow().iter() {\n+        for verify in &self.verifys {\n             debug!(\"collect_errors: verify={:?}\", verify);\n             let sub = var_data.normalize(verify.region);\n \n@@ -488,8 +486,6 @@ impl<'tcx> RegionVarBindings<'tcx> {\n     fn construct_graph(&self) -> RegionGraph<'tcx> {\n         let num_vars = self.num_vars();\n \n-        let constraints = self.constraints.borrow();\n-\n         let mut graph = graph::Graph::new();\n \n         for _ in 0..num_vars {\n@@ -504,7 +500,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n         let dummy_source = graph.add_node(());\n         let dummy_sink = graph.add_node(());\n \n-        for (constraint, _) in constraints.iter() {\n+        for (constraint, _) in &self.constraints {\n             match *constraint {\n                 Constraint::VarSubVar(a_id, b_id) => {\n                     graph.add_edge(\n@@ -564,7 +560,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n         for lower_bound in &lower_bounds {\n             for upper_bound in &upper_bounds {\n                 if !region_rels.is_subregion_of(lower_bound.region, upper_bound.region) {\n-                    let origin = (*self.var_origins.borrow())[node_idx.index as usize].clone();\n+                    let origin = self.var_origins[node_idx.index as usize].clone();\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n                          sup: {:?}\",\n@@ -586,7 +582,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n         }\n \n         span_bug!(\n-            (*self.var_origins.borrow())[node_idx.index as usize].span(),\n+            self.var_origins[node_idx.index as usize].span(),\n             \"collect_error_for_expanding_node() could not find \\\n              error for var {:?}, lower_bounds={:?}, \\\n              upper_bounds={:?}\",\n@@ -671,7 +667,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n                     Constraint::RegSubVar(region, _) | Constraint::VarSubReg(_, region) => {\n                         state.result.push(RegionAndOrigin {\n                             region,\n-                            origin: this.constraints.borrow().get(&edge.data).unwrap().clone(),\n+                            origin: this.constraints.get(&edge.data).unwrap().clone(),\n                         });\n                     }\n \n@@ -694,7 +690,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n             changed = false;\n             iteration += 1;\n             debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n-            for (constraint, origin) in self.constraints.borrow().iter() {\n+            for (constraint, origin) in &self.constraints {\n                 let edge_changed = body(constraint, origin);\n                 if edge_changed {\n                     debug!(\"Updated due to constraint {:?}\", constraint);"}, {"sha": "e3a16ecb444ad0883eb6dc38107e9bd34332cf20", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=cff191d4440df2befeb661f5ce7b9a53a03ce548", "patch": "@@ -67,7 +67,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                b);\n \n         let origin = Subtype(self.fields.trace.clone());\n-        Ok(self.fields.infcx.region_vars.lub_regions(self.tcx(), origin, a, b))\n+        Ok(self.fields.infcx.region_vars.borrow_mut().lub_regions(self.tcx(), origin, a, b))\n     }\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)"}, {"sha": "4aef09aa935a55c9b96b7ee9bc16bf762f79f7c8", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=cff191d4440df2befeb661f5ce7b9a53a03ce548", "patch": "@@ -104,7 +104,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     float_unification_table: RefCell<UnificationTable<ty::FloatVid>>,\n \n     // For region variables.\n-    region_vars: RegionVarBindings<'tcx>,\n+    region_vars: RefCell<RegionVarBindings<'tcx>>,\n \n     // Once region inference is done, the values for each variable.\n     lexical_region_resolutions: RefCell<Option<LexicalRegionResolutions<'tcx>>>,\n@@ -424,7 +424,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n-            region_vars: RegionVarBindings::new(),\n+            region_vars: RefCell::new(RegionVarBindings::new()),\n             lexical_region_resolutions: RefCell::new(None),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n@@ -767,7 +767,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             type_snapshot: self.type_variables.borrow_mut().snapshot(),\n             int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n-            region_vars_snapshot: self.region_vars.start_snapshot(),\n+            region_vars_snapshot: self.region_vars.borrow_mut().start_snapshot(),\n             was_in_snapshot: in_snapshot,\n             // Borrow tables \"in progress\" (i.e. during typeck)\n             // to ban writes from within a snapshot to them.\n@@ -802,6 +802,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .borrow_mut()\n             .rollback_to(float_snapshot);\n         self.region_vars\n+            .borrow_mut()\n             .rollback_to(region_vars_snapshot);\n     }\n \n@@ -830,6 +831,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .borrow_mut()\n             .commit(float_snapshot);\n         self.region_vars\n+            .borrow_mut()\n             .commit(region_vars_snapshot);\n     }\n \n@@ -885,7 +887,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                      sub: ty::Region<'tcx>,\n                      sup: ty::RegionVid)\n     {\n-        self.region_vars.add_given(sub, sup);\n+        self.region_vars.borrow_mut().add_given(sub, sup);\n     }\n \n     pub fn can_sub<T>(&self,\n@@ -925,7 +927,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                        a: ty::Region<'tcx>,\n                        b: ty::Region<'tcx>) {\n         debug!(\"sub_regions({:?} <: {:?})\", a, b);\n-        self.region_vars.make_subregion(origin, a, b);\n+        self.region_vars.borrow_mut().make_subregion(origin, a, b);\n     }\n \n     pub fn equality_predicate(&self,\n@@ -1028,7 +1030,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn next_region_var(&self, origin: RegionVariableOrigin)\n                            -> ty::Region<'tcx> {\n-        self.tcx.mk_region(ty::ReVar(self.region_vars.new_region_var(origin)))\n+        self.tcx.mk_region(ty::ReVar(self.region_vars.borrow_mut().new_region_var(origin)))\n     }\n \n     /// Create a region inference variable for the given\n@@ -1124,7 +1126,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                region_context,\n                                                region_map,\n                                                free_regions);\n-        let (lexical_region_resolutions, errors) = self.region_vars.resolve_regions(&region_rels);\n+        let (lexical_region_resolutions, errors) =\n+            self.region_vars.borrow_mut().resolve_regions(&region_rels);\n \n         let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());\n@@ -1362,7 +1365,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                a,\n                bound);\n \n-        self.region_vars.verify_generic_bound(origin, kind, a, bound);\n+        self.region_vars.borrow_mut().verify_generic_bound(origin, kind, a, bound);\n     }\n \n     pub fn type_moves_by_default(&self,"}, {"sha": "0731a2cfed6c92ac20704b190087631928ee7d15", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 103, "deletions": 112, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=cff191d4440df2befeb661f5ce7b9a53a03ce548", "patch": "@@ -24,7 +24,6 @@ use ty::ReStatic;\n use ty::{BrFresh, ReLateBound, ReSkolemized, ReVar};\n \n use std::collections::BTreeMap;\n-use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem;\n use std::u32;\n@@ -145,7 +144,7 @@ enum CombineMapType {\n type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionVarBindings<'tcx> {\n-    pub(in infer) var_origins: RefCell<Vec<RegionVariableOrigin>>,\n+    pub(in infer) var_origins: Vec<RegionVariableOrigin>,\n \n     /// Constraints of the form `A <= B` introduced by the region\n     /// checker.  Here at least one of `A` and `B` must be a region\n@@ -156,14 +155,14 @@ pub struct RegionVarBindings<'tcx> {\n     /// which in turn affects the way that region errors are reported,\n     /// leading to small variations in error output across runs and\n     /// platforms.\n-    pub(in infer) constraints: RefCell<BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>>,\n+    pub(in infer) constraints: BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n \n     /// A \"verify\" is something that we need to verify after inference is\n     /// done, but which does not directly affect inference in any way.\n     ///\n     /// An example is a `A <= B` where neither `A` nor `B` are\n     /// inference variables.\n-    pub(in infer) verifys: RefCell<Vec<Verify<'tcx>>>,\n+    pub(in infer) verifys: Vec<Verify<'tcx>>,\n \n     /// A \"given\" is a relationship that is known to hold. In particular,\n     /// we often know from closure fn signatures that a particular free\n@@ -182,12 +181,12 @@ pub struct RegionVarBindings<'tcx> {\n     /// record the fact that `'a <= 'b` is implied by the fn signature,\n     /// and then ignore the constraint when solving equations. This is\n     /// a bit of a hack but seems to work.\n-    pub(in infer) givens: RefCell<FxHashSet<(Region<'tcx>, ty::RegionVid)>>,\n+    pub(in infer) givens: FxHashSet<(Region<'tcx>, ty::RegionVid)>,\n \n-    lubs: RefCell<CombineMap<'tcx>>,\n-    glbs: RefCell<CombineMap<'tcx>>,\n-    skolemization_count: Cell<u32>,\n-    bound_count: Cell<u32>,\n+    lubs: CombineMap<'tcx>,\n+    glbs: CombineMap<'tcx>,\n+    skolemization_count: u32,\n+    bound_count: u32,\n \n     /// The undo log records actions that might later be undone.\n     ///\n@@ -198,9 +197,9 @@ pub struct RegionVarBindings<'tcx> {\n     /// otherwise we end up adding entries for things like the lower\n     /// bound on a variable and so forth, which can never be rolled\n     /// back.\n-    undo_log: RefCell<Vec<UndoLogEntry<'tcx>>>,\n+    undo_log: Vec<UndoLogEntry<'tcx>>,\n \n-    unification_table: RefCell<UnificationTable<ty::RegionVid>>,\n+    unification_table: UnificationTable<ty::RegionVid>,\n }\n \n pub struct RegionSnapshot {\n@@ -246,73 +245,70 @@ impl TaintDirections {\n impl<'tcx> RegionVarBindings<'tcx> {\n     pub fn new() -> RegionVarBindings<'tcx> {\n         RegionVarBindings {\n-            var_origins: RefCell::new(Vec::new()),\n-            constraints: RefCell::new(BTreeMap::new()),\n-            verifys: RefCell::new(Vec::new()),\n-            givens: RefCell::new(FxHashSet()),\n-            lubs: RefCell::new(FxHashMap()),\n-            glbs: RefCell::new(FxHashMap()),\n-            skolemization_count: Cell::new(0),\n-            bound_count: Cell::new(0),\n-            undo_log: RefCell::new(Vec::new()),\n-            unification_table: RefCell::new(UnificationTable::new()),\n+            var_origins: Vec::new(),\n+            constraints: BTreeMap::new(),\n+            verifys: Vec::new(),\n+            givens: FxHashSet(),\n+            lubs: FxHashMap(),\n+            glbs: FxHashMap(),\n+            skolemization_count: 0,\n+            bound_count: 0,\n+            undo_log: Vec::new(),\n+            unification_table: UnificationTable::new(),\n         }\n     }\n \n     fn in_snapshot(&self) -> bool {\n-        !self.undo_log.borrow().is_empty()\n+        !self.undo_log.is_empty()\n     }\n \n-    pub fn start_snapshot(&self) -> RegionSnapshot {\n-        let length = self.undo_log.borrow().len();\n+    pub fn start_snapshot(&mut self) -> RegionSnapshot {\n+        let length = self.undo_log.len();\n         debug!(\"RegionVarBindings: start_snapshot({})\", length);\n-        self.undo_log.borrow_mut().push(OpenSnapshot);\n+        self.undo_log.push(OpenSnapshot);\n         RegionSnapshot {\n             length,\n-            region_snapshot: self.unification_table.borrow_mut().snapshot(),\n-            skolemization_count: self.skolemization_count.get(),\n+            region_snapshot: self.unification_table.snapshot(),\n+            skolemization_count: self.skolemization_count,\n         }\n     }\n \n-    pub fn commit(&self, snapshot: RegionSnapshot) {\n+    pub fn commit(&mut self, snapshot: RegionSnapshot) {\n         debug!(\"RegionVarBindings: commit({})\", snapshot.length);\n-        assert!(self.undo_log.borrow().len() > snapshot.length);\n-        assert!((*self.undo_log.borrow())[snapshot.length] == OpenSnapshot);\n+        assert!(self.undo_log.len() > snapshot.length);\n+        assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n         assert!(\n-            self.skolemization_count.get() == snapshot.skolemization_count,\n+            self.skolemization_count == snapshot.skolemization_count,\n             \"failed to pop skolemized regions: {} now vs {} at start\",\n-            self.skolemization_count.get(),\n+            self.skolemization_count,\n             snapshot.skolemization_count\n         );\n \n-        let mut undo_log = self.undo_log.borrow_mut();\n         if snapshot.length == 0 {\n-            undo_log.truncate(0);\n+            self.undo_log.truncate(0);\n         } else {\n-            (*undo_log)[snapshot.length] = CommitedSnapshot;\n+            (*self.undo_log)[snapshot.length] = CommitedSnapshot;\n         }\n         self.unification_table\n-            .borrow_mut()\n             .commit(snapshot.region_snapshot);\n     }\n \n-    pub fn rollback_to(&self, snapshot: RegionSnapshot) {\n+    pub fn rollback_to(&mut self, snapshot: RegionSnapshot) {\n         debug!(\"RegionVarBindings: rollback_to({:?})\", snapshot);\n-        let mut undo_log = self.undo_log.borrow_mut();\n-        assert!(undo_log.len() > snapshot.length);\n-        assert!((*undo_log)[snapshot.length] == OpenSnapshot);\n-        while undo_log.len() > snapshot.length + 1 {\n-            self.rollback_undo_entry(undo_log.pop().unwrap());\n+        assert!(self.undo_log.len() > snapshot.length);\n+        assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n+        while self.undo_log.len() > snapshot.length + 1 {\n+            let undo_entry = self.undo_log.pop().unwrap();\n+            self.rollback_undo_entry(undo_entry);\n         }\n-        let c = undo_log.pop().unwrap();\n+        let c = self.undo_log.pop().unwrap();\n         assert!(c == OpenSnapshot);\n-        self.skolemization_count.set(snapshot.skolemization_count);\n+        self.skolemization_count = snapshot.skolemization_count;\n         self.unification_table\n-            .borrow_mut()\n             .rollback_to(snapshot.region_snapshot);\n     }\n \n-    fn rollback_undo_entry(&self, undo_entry: UndoLogEntry<'tcx>) {\n+    fn rollback_undo_entry(&mut self, undo_entry: UndoLogEntry<'tcx>) {\n         match undo_entry {\n             OpenSnapshot => {\n                 panic!(\"Failure to observe stack discipline\");\n@@ -321,48 +317,46 @@ impl<'tcx> RegionVarBindings<'tcx> {\n                 // nothing to do here\n             }\n             AddVar(vid) => {\n-                let mut var_origins = self.var_origins.borrow_mut();\n-                var_origins.pop().unwrap();\n-                assert_eq!(var_origins.len(), vid.index as usize);\n+                self.var_origins.pop().unwrap();\n+                assert_eq!(self.var_origins.len(), vid.index as usize);\n             }\n             AddConstraint(ref constraint) => {\n-                self.constraints.borrow_mut().remove(constraint);\n+                self.constraints.remove(constraint);\n             }\n             AddVerify(index) => {\n-                self.verifys.borrow_mut().pop();\n-                assert_eq!(self.verifys.borrow().len(), index);\n+                self.verifys.pop();\n+                assert_eq!(self.verifys.len(), index);\n             }\n             AddGiven(sub, sup) => {\n-                self.givens.borrow_mut().remove(&(sub, sup));\n+                self.givens.remove(&(sub, sup));\n             }\n             AddCombination(Glb, ref regions) => {\n-                self.glbs.borrow_mut().remove(regions);\n+                self.glbs.remove(regions);\n             }\n             AddCombination(Lub, ref regions) => {\n-                self.lubs.borrow_mut().remove(regions);\n+                self.lubs.remove(regions);\n             }\n         }\n     }\n \n     pub fn num_vars(&self) -> u32 {\n-        let len = self.var_origins.borrow().len();\n+        let len = self.var_origins.len();\n         // enforce no overflow\n         assert!(len as u32 as usize == len);\n         len as u32\n     }\n \n-    pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n+    pub fn new_region_var(&mut self, origin: RegionVariableOrigin) -> RegionVid {\n         let vid = RegionVid {\n             index: self.num_vars(),\n         };\n-        self.var_origins.borrow_mut().push(origin.clone());\n+        self.var_origins.push(origin.clone());\n \n         let u_vid = self.unification_table\n-            .borrow_mut()\n             .new_key(unify_key::RegionVidKey { min_vid: vid });\n         assert_eq!(vid, u_vid);\n         if self.in_snapshot() {\n-            self.undo_log.borrow_mut().push(AddVar(vid));\n+            self.undo_log.push(AddVar(vid));\n         }\n         debug!(\n             \"created new region variable {:?} with origin {:?}\",\n@@ -373,7 +367,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n     }\n \n     pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n-        self.var_origins.borrow()[vid.index as usize].clone()\n+        self.var_origins[vid.index as usize].clone()\n     }\n \n     /// Creates a new skolemized region. Skolemized regions are fresh\n@@ -396,16 +390,16 @@ impl<'tcx> RegionVarBindings<'tcx> {\n     /// it's just there to make it explicit which snapshot bounds the\n     /// skolemized region that results. It should always be the top-most snapshot.\n     pub fn push_skolemized(\n-        &self,\n+        &mut self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         br: ty::BoundRegion,\n         snapshot: &RegionSnapshot,\n     ) -> Region<'tcx> {\n         assert!(self.in_snapshot());\n-        assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n+        assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n \n-        let sc = self.skolemization_count.get();\n-        self.skolemization_count.set(sc + 1);\n+        let sc = self.skolemization_count;\n+        self.skolemization_count = sc + 1;\n         tcx.mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n     }\n \n@@ -414,31 +408,31 @@ impl<'tcx> RegionVarBindings<'tcx> {\n     /// completes to remove all trace of the skolemized regions\n     /// created in that time.\n     pub fn pop_skolemized(\n-        &self,\n+        &mut self,\n         _tcx: TyCtxt<'_, '_, 'tcx>,\n         skols: &FxHashSet<ty::Region<'tcx>>,\n         snapshot: &RegionSnapshot,\n     ) {\n         debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n \n         assert!(self.in_snapshot());\n-        assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n+        assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n         assert!(\n-            self.skolemization_count.get() as usize >= skols.len(),\n+            self.skolemization_count as usize >= skols.len(),\n             \"popping more skolemized variables than actually exist, \\\n              sc now = {}, skols.len = {}\",\n-            self.skolemization_count.get(),\n+            self.skolemization_count,\n             skols.len()\n         );\n \n-        let last_to_pop = self.skolemization_count.get();\n+        let last_to_pop = self.skolemization_count;\n         let first_to_pop = last_to_pop - (skols.len() as u32);\n \n         assert!(\n             first_to_pop >= snapshot.skolemization_count,\n             \"popping more regions than snapshot contains, \\\n              sc now = {}, sc then = {}, skols.len = {}\",\n-            self.skolemization_count.get(),\n+            self.skolemization_count,\n             snapshot.skolemization_count,\n             skols.len()\n         );\n@@ -453,13 +447,11 @@ impl<'tcx> RegionVarBindings<'tcx> {\n                  }),\n             \"invalid skolemization keys or keys out of range ({}..{}): {:?}\",\n             snapshot.skolemization_count,\n-            self.skolemization_count.get(),\n+            self.skolemization_count,\n             skols\n         }\n \n-        let mut undo_log = self.undo_log.borrow_mut();\n-\n-        let constraints_to_kill: Vec<usize> = undo_log\n+        let constraints_to_kill: Vec<usize> = self.undo_log\n             .iter()\n             .enumerate()\n             .rev()\n@@ -468,11 +460,11 @@ impl<'tcx> RegionVarBindings<'tcx> {\n             .collect();\n \n         for index in constraints_to_kill {\n-            let undo_entry = mem::replace(&mut undo_log[index], Purged);\n+            let undo_entry = mem::replace(&mut self.undo_log[index], Purged);\n             self.rollback_undo_entry(undo_entry);\n         }\n \n-        self.skolemization_count.set(snapshot.skolemization_count);\n+        self.skolemization_count = snapshot.skolemization_count;\n         return;\n \n         fn kill_constraint<'tcx>(\n@@ -497,7 +489,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n     }\n \n     pub fn new_bound(\n-        &self,\n+        &mut self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         debruijn: ty::DebruijnIndex,\n     ) -> Region<'tcx> {\n@@ -519,35 +511,36 @@ impl<'tcx> RegionVarBindings<'tcx> {\n         // changing the representation of bound regions in a fn\n         // declaration\n \n-        let sc = self.bound_count.get();\n-        self.bound_count.set(sc + 1);\n+        let sc = self.bound_count;\n+        self.bound_count = sc + 1;\n \n-        if sc >= self.bound_count.get() {\n+        if sc >= self.bound_count {\n             bug!(\"rollover in RegionInference new_bound()\");\n         }\n \n         tcx.mk_region(ReLateBound(debruijn, BrFresh(sc)))\n     }\n \n-    fn add_constraint(&self, constraint: Constraint<'tcx>, origin: SubregionOrigin<'tcx>) {\n+    fn add_constraint(&mut self, constraint: Constraint<'tcx>, origin: SubregionOrigin<'tcx>) {\n         // cannot add constraints once regions are resolved\n         debug!(\"RegionVarBindings: add_constraint({:?})\", constraint);\n \n         // never overwrite an existing (constraint, origin) - only insert one if it isn't\n         // present in the map yet. This prevents origins from outside the snapshot being\n         // replaced with \"less informative\" origins e.g. during calls to `can_eq`\n+        let in_snapshot = self.in_snapshot();\n+        let undo_log = &mut self.undo_log;\n         self.constraints\n-            .borrow_mut()\n             .entry(constraint)\n             .or_insert_with(|| {\n-                if self.in_snapshot() {\n-                    self.undo_log.borrow_mut().push(AddConstraint(constraint));\n+                if in_snapshot {\n+                    undo_log.push(AddConstraint(constraint));\n                 }\n                 origin\n             });\n     }\n \n-    fn add_verify(&self, verify: Verify<'tcx>) {\n+    fn add_verify(&mut self, verify: Verify<'tcx>) {\n         // cannot add verifys once regions are resolved\n         debug!(\"RegionVarBindings: add_verify({:?})\", verify);\n \n@@ -559,26 +552,24 @@ impl<'tcx> RegionVarBindings<'tcx> {\n             _ => {}\n         }\n \n-        let mut verifys = self.verifys.borrow_mut();\n-        let index = verifys.len();\n-        verifys.push(verify);\n+        let index = self.verifys.len();\n+        self.verifys.push(verify);\n         if self.in_snapshot() {\n-            self.undo_log.borrow_mut().push(AddVerify(index));\n+            self.undo_log.push(AddVerify(index));\n         }\n     }\n \n-    pub fn add_given(&self, sub: Region<'tcx>, sup: ty::RegionVid) {\n+    pub fn add_given(&mut self, sub: Region<'tcx>, sup: ty::RegionVid) {\n         // cannot add givens once regions are resolved\n-        let mut givens = self.givens.borrow_mut();\n-        if givens.insert((sub, sup)) {\n+        if self.givens.insert((sub, sup)) {\n             debug!(\"add_given({:?} <= {:?})\", sub, sup);\n \n-            self.undo_log.borrow_mut().push(AddGiven(sub, sup));\n+            self.undo_log.push(AddGiven(sub, sup));\n         }\n     }\n \n     pub fn make_eqregion(\n-        &self,\n+        &mut self,\n         origin: SubregionOrigin<'tcx>,\n         sub: Region<'tcx>,\n         sup: Region<'tcx>,\n@@ -590,13 +581,13 @@ impl<'tcx> RegionVarBindings<'tcx> {\n             self.make_subregion(origin, sup, sub);\n \n             if let (ty::ReVar(sub), ty::ReVar(sup)) = (*sub, *sup) {\n-                self.unification_table.borrow_mut().union(sub, sup);\n+                self.unification_table.union(sub, sup);\n             }\n         }\n     }\n \n     pub fn make_subregion(\n-        &self,\n+        &mut self,\n         origin: SubregionOrigin<'tcx>,\n         sub: Region<'tcx>,\n         sup: Region<'tcx>,\n@@ -638,7 +629,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n \n     /// See `Verify::VerifyGenericBound`\n     pub fn verify_generic_bound(\n-        &self,\n+        &mut self,\n         origin: SubregionOrigin<'tcx>,\n         kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n@@ -653,7 +644,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n     }\n \n     pub fn lub_regions(\n-        &self,\n+        &mut self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         origin: SubregionOrigin<'tcx>,\n         a: Region<'tcx>,\n@@ -675,7 +666,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n     }\n \n     pub fn glb_regions(\n-        &self,\n+        &mut self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         origin: SubregionOrigin<'tcx>,\n         a: Region<'tcx>,\n@@ -697,37 +688,37 @@ impl<'tcx> RegionVarBindings<'tcx> {\n     }\n \n     pub fn opportunistic_resolve_var(\n-        &self,\n+        &mut self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         rid: RegionVid,\n     ) -> ty::Region<'tcx> {\n-        let vid = self.unification_table.borrow_mut().find_value(rid).min_vid;\n+        let vid = self.unification_table.find_value(rid).min_vid;\n         tcx.mk_region(ty::ReVar(vid))\n     }\n \n-    fn combine_map(&self, t: CombineMapType) -> &RefCell<CombineMap<'tcx>> {\n+    fn combine_map(&mut self, t: CombineMapType) -> &mut CombineMap<'tcx> {\n         match t {\n-            Glb => &self.glbs,\n-            Lub => &self.lubs,\n+            Glb => &mut self.glbs,\n+            Lub => &mut self.lubs,\n         }\n     }\n \n     fn combine_vars(\n-        &self,\n+        &mut self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         t: CombineMapType,\n         a: Region<'tcx>,\n         b: Region<'tcx>,\n         origin: SubregionOrigin<'tcx>,\n     ) -> Region<'tcx> {\n         let vars = TwoRegions { a: a, b: b };\n-        if let Some(&c) = self.combine_map(t).borrow().get(&vars) {\n+        if let Some(&c) = self.combine_map(t).get(&vars) {\n             return tcx.mk_region(ReVar(c));\n         }\n         let c = self.new_region_var(MiscVariable(origin.span()));\n-        self.combine_map(t).borrow_mut().insert(vars, c);\n+        self.combine_map(t).insert(vars, c);\n         if self.in_snapshot() {\n-            self.undo_log.borrow_mut().push(AddCombination(t, vars));\n+            self.undo_log.push(AddCombination(t, vars));\n         }\n         let new_r = tcx.mk_region(ReVar(c));\n         for &old_r in &[a, b] {\n@@ -741,7 +732,7 @@ impl<'tcx> RegionVarBindings<'tcx> {\n     }\n \n     pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot) -> Vec<RegionVid> {\n-        self.undo_log.borrow()[mark.length..]\n+        self.undo_log[mark.length..]\n             .iter()\n             .filter_map(|&elt| match elt {\n                 AddVar(vid) => Some(vid),\n@@ -778,8 +769,8 @@ impl<'tcx> RegionVarBindings<'tcx> {\n         let mut taint_set = taint::TaintSet::new(directions, r0);\n         taint_set.fixed_point(\n             tcx,\n-            &self.undo_log.borrow()[mark.length..],\n-            &self.verifys.borrow(),\n+            &self.undo_log[mark.length..],\n+            &self.verifys,\n         );\n         debug!(\"tainted: result={:?}\", taint_set);\n         return taint_set.into_set();"}, {"sha": "8a99eb08014325904ec9efbf2a76c38057cf9990", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=cff191d4440df2befeb661f5ce7b9a53a03ce548", "patch": "@@ -74,8 +74,10 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReVar(rid) => self.infcx.region_vars.opportunistic_resolve_var(self.tcx(), rid),\n-            _ => r,\n+            ty::ReVar(rid) =>\n+                self.infcx.region_vars.borrow_mut().opportunistic_resolve_var(self.tcx(), rid),\n+            _ =>\n+                r,\n         }\n     }\n }"}, {"sha": "bba4328e6ea840caeb6bbdac63dde1b81377b064", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff191d4440df2befeb661f5ce7b9a53a03ce548/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=cff191d4440df2befeb661f5ce7b9a53a03ce548", "patch": "@@ -137,7 +137,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         // from the \"cause\" field, we could perhaps give more tailored\n         // error messages.\n         let origin = SubregionOrigin::Subtype(self.fields.trace.clone());\n-        self.fields.infcx.region_vars.make_subregion(origin, a, b);\n+        self.fields.infcx.region_vars.borrow_mut().make_subregion(origin, a, b);\n \n         Ok(a)\n     }"}]}