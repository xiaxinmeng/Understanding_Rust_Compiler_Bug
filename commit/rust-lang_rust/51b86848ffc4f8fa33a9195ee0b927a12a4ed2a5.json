{"sha": "51b86848ffc4f8fa33a9195ee0b927a12a4ed2a5", "node_id": "C_kwDOAAsO6NoAKDUxYjg2ODQ4ZmZjNGY4ZmEzM2E5MTk1ZWUwYjkyN2ExMmE0ZWQyYTU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-25T23:21:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-25T23:21:20Z"}, "message": "Rollup merge of #90312 - r00ster91:search, r=Dylan-DPC\n\nFix some confusing wording and improve slice-search-related docs\n\nThis adds more links between `contains` and `binary_search` because I do think they have some relevant connections. If your (big) slice happens to be sorted and you know it, surely you should be using `[3; 100].binary_search(&5).is_ok()` over `[3; 100].contains(&5)`?\nThis also fixes the confusing \"searches this sorted X\" wording which just sounds really weird because it doesn't know whether it's actually sorted. It should be but it may not be. The new wording should make it clearer that you will probably want to sort it and in the same sentence it also mentions the related function `contains`.\nSimilarly, this mentions `binary_search` on `contains`' docs.\nThis also fixes some other minor stuff and inconsistencies.", "tree": {"sha": "d57ee7a6f774e7161e5a77d7231e549ca425ca0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d57ee7a6f774e7161e5a77d7231e549ca425ca0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51b86848ffc4f8fa33a9195ee0b927a12a4ed2a5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiZyzwCRBK7hj4Ov3rIwAAhWoIACNybfxOqaAyca3uN6VQfHYd\nFU3z88+/xk+nIUM3AhcQ4HjazwBBcVL7REZNrft88loMWVsBHjwSwnrAM5WWerEZ\nhaSJYzZT4X9d/CLtfNZUYx1MPWyUzVW9er3fd59teG9TOq4Iy4Mem8ai9l1hiYdh\n9zFf3XSLev5K2dg8CY65cKT7MC0Muk4VVEefT6MC8mk2lnNips9S7jaK7kVpqjan\nZ5cOlu6PEN/xgkkCmjOqSp/olnp5Y0jAFxU2v1DcBGable1wkiYY4+Lz0SMAyPx0\n905A0Ztpe4lA9fwIK3LMZ8Y49wxlWgUHGnfud/EgYJCGDunhq0nm3EKZkBj1Rww=\n=5rac\n-----END PGP SIGNATURE-----\n", "payload": "tree d57ee7a6f774e7161e5a77d7231e549ca425ca0b\nparent 055bf4ccd521c2c2185166c86951be7be145727c\nparent c18646067734f03354daa0d1c568e97433e4ad49\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1650928880 +0200\ncommitter GitHub <noreply@github.com> 1650928880 +0200\n\nRollup merge of #90312 - r00ster91:search, r=Dylan-DPC\n\nFix some confusing wording and improve slice-search-related docs\n\nThis adds more links between `contains` and `binary_search` because I do think they have some relevant connections. If your (big) slice happens to be sorted and you know it, surely you should be using `[3; 100].binary_search(&5).is_ok()` over `[3; 100].contains(&5)`?\nThis also fixes the confusing \"searches this sorted X\" wording which just sounds really weird because it doesn't know whether it's actually sorted. It should be but it may not be. The new wording should make it clearer that you will probably want to sort it and in the same sentence it also mentions the related function `contains`.\nSimilarly, this mentions `binary_search` on `contains`' docs.\nThis also fixes some other minor stuff and inconsistencies.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51b86848ffc4f8fa33a9195ee0b927a12a4ed2a5", "html_url": "https://github.com/rust-lang/rust/commit/51b86848ffc4f8fa33a9195ee0b927a12a4ed2a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51b86848ffc4f8fa33a9195ee0b927a12a4ed2a5/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "055bf4ccd521c2c2185166c86951be7be145727c", "url": "https://api.github.com/repos/rust-lang/rust/commits/055bf4ccd521c2c2185166c86951be7be145727c", "html_url": "https://github.com/rust-lang/rust/commit/055bf4ccd521c2c2185166c86951be7be145727c"}, {"sha": "c18646067734f03354daa0d1c568e97433e4ad49", "url": "https://api.github.com/repos/rust-lang/rust/commits/c18646067734f03354daa0d1c568e97433e4ad49", "html_url": "https://github.com/rust-lang/rust/commit/c18646067734f03354daa0d1c568e97433e4ad49"}], "stats": {"total": 46, "additions": 35, "deletions": 11}, "files": [{"sha": "736b38370ab87929a5b9b60efec2bf5cd2de4142", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51b86848ffc4f8fa33a9195ee0b927a12a4ed2a5/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b86848ffc4f8fa33a9195ee0b927a12a4ed2a5/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=51b86848ffc4f8fa33a9195ee0b927a12a4ed2a5", "patch": "@@ -645,7 +645,7 @@ impl<T> LinkedList<T> {\n     /// Returns `true` if the `LinkedList` contains an element equal to the\n     /// given value.\n     ///\n-    /// This operation should compute in *O*(*n*) time.\n+    /// This operation should compute linearly in *O*(*n*) time.\n     ///\n     /// # Examples\n     ///\n@@ -1569,7 +1569,7 @@ impl<'a, T> CursorMut<'a, T> {\n     /// Appends an element to the front of the cursor's parent list. The node\n     /// that the cursor points to is unchanged, even if it is the \"ghost\" node.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in *O*(1) time.\n     // `push_front` continues to point to \"ghost\" when it addes a node to mimic\n     // the behavior of `insert_before` on an empty list.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n@@ -1584,7 +1584,7 @@ impl<'a, T> CursorMut<'a, T> {\n     /// Appends an element to the back of the cursor's parent list. The node\n     /// that the cursor points to is unchanged, even if it is the \"ghost\" node.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in *O*(1) time.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn push_back(&mut self, elt: T) {\n         // Safety: We know that `push_back` does not change the position in\n@@ -1603,7 +1603,7 @@ impl<'a, T> CursorMut<'a, T> {\n     /// unchanged, unless it was pointing to the front element. In that case, it\n     /// points to the new front element.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in *O*(1) time.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n         // We can't check if current is empty, we must check the list directly.\n@@ -1630,7 +1630,7 @@ impl<'a, T> CursorMut<'a, T> {\n     /// unchanged, unless it was pointing to the back element. In that case, it\n     /// points to the \"ghost\" element.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in *O*(1) time.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn pop_back(&mut self) -> Option<T> {\n         if self.list.is_empty() {"}, {"sha": "ab14a43fb9379ea2681d0b2436755675022fe1d9", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/51b86848ffc4f8fa33a9195ee0b927a12a4ed2a5/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b86848ffc4f8fa33a9195ee0b927a12a4ed2a5/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=51b86848ffc4f8fa33a9195ee0b927a12a4ed2a5", "patch": "@@ -1342,6 +1342,12 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// Returns `true` if the deque contains an element equal to the\n     /// given value.\n     ///\n+    /// This operation is *O*(*n*).\n+    ///\n+    /// Note that if you have a sorted `VecDeque`, [`binary_search`] may be faster.\n+    ///\n+    /// [`binary_search`]: VecDeque::binary_search\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2560,7 +2566,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Binary searches the sorted deque for a given element.\n+    /// Binary searches this `VecDeque` for a given element.\n+    /// This behaves similarly to [`contains`] if this `VecDeque` is sorted.\n     ///\n     /// If the value is found then [`Result::Ok`] is returned, containing the\n     /// index of the matching element. If there are multiple matches, then any\n@@ -2570,6 +2577,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     ///\n     /// See also [`binary_search_by`], [`binary_search_by_key`], and [`partition_point`].\n     ///\n+    /// [`contains`]: VecDeque::contains\n     /// [`binary_search_by`]: VecDeque::binary_search_by\n     /// [`binary_search_by_key`]: VecDeque::binary_search_by_key\n     /// [`partition_point`]: VecDeque::partition_point\n@@ -2614,7 +2622,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         self.binary_search_by(|e| e.cmp(x))\n     }\n \n-    /// Binary searches the sorted deque with a comparator function.\n+    /// Binary searches this `VecDeque` with a comparator function.\n+    /// This behaves similarly to [`contains`] if this `VecDeque` is sorted.\n     ///\n     /// The comparator function should implement an order consistent\n     /// with the sort order of the deque, returning an order code that\n@@ -2629,6 +2638,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     ///\n     /// See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n     ///\n+    /// [`contains`]: VecDeque::contains\n     /// [`binary_search`]: VecDeque::binary_search\n     /// [`binary_search_by_key`]: VecDeque::binary_search_by_key\n     /// [`partition_point`]: VecDeque::partition_point\n@@ -2667,7 +2677,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Binary searches the sorted deque with a key extraction function.\n+    /// Binary searches this `VecDeque` with a key extraction function.\n+    /// This behaves similarly to [`contains`] if this `VecDeque` is sorted.\n     ///\n     /// Assumes that the deque is sorted by the key, for instance with\n     /// [`make_contiguous().sort_by_key()`] using the same key extraction function.\n@@ -2680,6 +2691,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     ///\n     /// See also [`binary_search`], [`binary_search_by`], and [`partition_point`].\n     ///\n+    /// [`contains`]: VecDeque::contains\n     /// [`make_contiguous().sort_by_key()`]: VecDeque::make_contiguous\n     /// [`binary_search`]: VecDeque::binary_search\n     /// [`binary_search_by`]: VecDeque::binary_search_by"}, {"sha": "a226dea54a4f2ab228512e666fb4abf7210cb742", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/51b86848ffc4f8fa33a9195ee0b927a12a4ed2a5/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51b86848ffc4f8fa33a9195ee0b927a12a4ed2a5/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=51b86848ffc4f8fa33a9195ee0b927a12a4ed2a5", "patch": "@@ -2139,6 +2139,12 @@ impl<T> [T] {\n \n     /// Returns `true` if the slice contains an element with the given value.\n     ///\n+    /// This operation is *O*(*n*).\n+    ///\n+    /// Note that if you have a sorted slice, [`binary_search`] may be faster.\n+    ///\n+    /// [`binary_search`]: slice::binary_search\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2298,7 +2304,8 @@ impl<T> [T] {\n         None\n     }\n \n-    /// Binary searches this sorted slice for a given element.\n+    /// Binary searches this slice for a given element.\n+    /// This behaves similary to [`contains`] if this slice is sorted.\n     ///\n     /// If the value is found then [`Result::Ok`] is returned, containing the\n     /// index of the matching element. If there are multiple matches, then any\n@@ -2310,6 +2317,7 @@ impl<T> [T] {\n     ///\n     /// See also [`binary_search_by`], [`binary_search_by_key`], and [`partition_point`].\n     ///\n+    /// [`contains`]: slice::contains\n     /// [`binary_search_by`]: slice::binary_search_by\n     /// [`binary_search_by_key`]: slice::binary_search_by_key\n     /// [`partition_point`]: slice::partition_point\n@@ -2349,7 +2357,8 @@ impl<T> [T] {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n-    /// Binary searches this sorted slice with a comparator function.\n+    /// Binary searches this slice with a comparator function.\n+    /// This behaves similarly to [`contains`] if this slice is sorted.\n     ///\n     /// The comparator function should implement an order consistent\n     /// with the sort order of the underlying slice, returning an\n@@ -2366,6 +2375,7 @@ impl<T> [T] {\n     ///\n     /// See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n     ///\n+    /// [`contains`]: slice::contains\n     /// [`binary_search`]: slice::binary_search\n     /// [`binary_search_by_key`]: slice::binary_search_by_key\n     /// [`partition_point`]: slice::partition_point\n@@ -2424,7 +2434,8 @@ impl<T> [T] {\n         Err(left)\n     }\n \n-    /// Binary searches this sorted slice with a key extraction function.\n+    /// Binary searches this slice with a key extraction function.\n+    /// This behaves similarly to [`contains`] if this slice is sorted.\n     ///\n     /// Assumes that the slice is sorted by the key, for instance with\n     /// [`sort_by_key`] using the same key extraction function.\n@@ -2439,6 +2450,7 @@ impl<T> [T] {\n     ///\n     /// See also [`binary_search`], [`binary_search_by`], and [`partition_point`].\n     ///\n+    /// [`contains`]: slice::contains\n     /// [`sort_by_key`]: slice::sort_by_key\n     /// [`binary_search`]: slice::binary_search\n     /// [`binary_search_by`]: slice::binary_search_by"}]}