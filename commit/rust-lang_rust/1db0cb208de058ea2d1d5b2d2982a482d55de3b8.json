{"sha": "1db0cb208de058ea2d1d5b2d2982a482d55de3b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYjBjYjIwOGRlMDU4ZWEyZDFkNWIyZDI5ODJhNDgyZDU1ZGUzYjg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-20T19:12:11Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-20T19:12:11Z"}, "message": "Add ungetc and re-indent _io.rs.", "tree": {"sha": "b303fbc8d5c309df60cd115f7b23110d8c1355f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b303fbc8d5c309df60cd115f7b23110d8c1355f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1db0cb208de058ea2d1d5b2d2982a482d55de3b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1db0cb208de058ea2d1d5b2d2982a482d55de3b8", "html_url": "https://github.com/rust-lang/rust/commit/1db0cb208de058ea2d1d5b2d2982a482d55de3b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1db0cb208de058ea2d1d5b2d2982a482d55de3b8/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34e5e98cf7dc12b0c900031639c708ade084ccc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/34e5e98cf7dc12b0c900031639c708ade084ccc0", "html_url": "https://github.com/rust-lang/rust/commit/34e5e98cf7dc12b0c900031639c708ade084ccc0"}], "stats": {"total": 197, "additions": 102, "deletions": 95}, "files": [{"sha": "2fb225ddc022fc8eed901ea7c769e56bf2065a36", "filename": "src/lib/_io.rs", "status": "modified", "additions": 99, "deletions": 95, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/1db0cb208de058ea2d1d5b2d2982a482d55de3b8/src%2Flib%2F_io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db0cb208de058ea2d1d5b2d2982a482d55de3b8/src%2Flib%2F_io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_io.rs?ref=1db0cb208de058ea2d1d5b2d2982a482d55de3b8", "patch": "@@ -5,150 +5,154 @@ import std._vec;\n \n type stdio_reader = unsafe obj {\n                            fn getc() -> int;\n+                           fn ungetc(int i);\n };\n \n fn new_stdio_reader(str path) -> stdio_reader {\n-  unsafe obj stdio_FILE_reader(os.libc.FILE f) {\n-    fn getc() -> int {\n-      ret os.libc.fgetc(f);\n-    }\n-    drop {\n-      os.libc.fclose(f);\n+    unsafe obj stdio_FILE_reader(os.libc.FILE f) {\n+        fn getc() -> int {\n+            ret os.libc.fgetc(f);\n+        }\n+        fn ungetc(int i) {\n+            os.libc.ungetc(i, f);\n+        }\n+        drop {\n+            os.libc.fclose(f);\n+        }\n     }\n-  }\n-  ret stdio_FILE_reader(os.libc.fopen(_str.buf(path),\n-                                      _str.buf(\"r\")));\n+    ret stdio_FILE_reader(os.libc.fopen(_str.buf(path),\n+                                        _str.buf(\"r\")));\n }\n \n \n type buf_reader = unsafe obj {\n-  fn read() -> vec[u8];\n+                         fn read() -> vec[u8];\n };\n \n type buf_writer = unsafe obj {\n-  fn write(vec[u8] v);\n+                         fn write(vec[u8] v);\n };\n \n fn default_bufsz() -> uint {\n-  ret 4096u;\n+    ret 4096u;\n }\n \n fn new_buf() -> vec[u8] {\n-  ret _vec.alloc[u8](default_bufsz());\n+    ret _vec.alloc[u8](default_bufsz());\n }\n \n fn new_buf_reader(str path) -> buf_reader {\n \n-  unsafe obj fd_buf_reader(int fd, mutable vec[u8] buf) {\n+    unsafe obj fd_buf_reader(int fd, mutable vec[u8] buf) {\n \n-    fn read() -> vec[u8] {\n+        fn read() -> vec[u8] {\n \n-      // Ensure our buf is singly-referenced.\n-      if (_vec.rustrt.refcount[u8](buf) != 1u) {\n-        buf = new_buf();\n-      }\n+            // Ensure our buf is singly-referenced.\n+            if (_vec.rustrt.refcount[u8](buf) != 1u) {\n+                buf = new_buf();\n+            }\n \n-      auto len = default_bufsz();\n-      auto vbuf = _vec.buf[u8](buf);\n-      auto count = os.libc.read(fd, vbuf, len);\n+            auto len = default_bufsz();\n+            auto vbuf = _vec.buf[u8](buf);\n+            auto count = os.libc.read(fd, vbuf, len);\n \n-      if (count < 0) {\n-        log \"error filling buffer\";\n-        log sys.rustrt.last_os_error();\n-        fail;\n-      }\n+            if (count < 0) {\n+                log \"error filling buffer\";\n+                log sys.rustrt.last_os_error();\n+                fail;\n+            }\n+\n+            _vec.len_set[u8](buf, count as uint);\n+            ret buf;\n+        }\n \n-      _vec.len_set[u8](buf, count as uint);\n-      ret buf;\n+        drop {\n+            os.libc.close(fd);\n+        }\n     }\n \n-    drop {\n-      os.libc.close(fd);\n+    auto fd = os.libc.open(_str.buf(path),\n+                           os.libc_constants.O_RDONLY() |\n+                           os.libc_constants.O_BINARY(),\n+                           0u);\n+\n+    if (fd < 0) {\n+        log \"error opening file for reading\";\n+        log sys.rustrt.last_os_error();\n+        fail;\n     }\n-  }\n-\n-  auto fd = os.libc.open(_str.buf(path),\n-                         os.libc_constants.O_RDONLY() |\n-                         os.libc_constants.O_BINARY(),\n-                         0u);\n-\n-  if (fd < 0) {\n-    log \"error opening file for reading\";\n-    log sys.rustrt.last_os_error();\n-    fail;\n-  }\n-  ret fd_buf_reader(fd, new_buf());\n+    ret fd_buf_reader(fd, new_buf());\n }\n \n type fileflag = tag(append(), create(), truncate());\n \n fn new_buf_writer(str path, vec[fileflag] flags) -> buf_writer {\n \n-  unsafe obj fd_buf_writer(int fd) {\n-\n-    fn write(vec[u8] v) {\n-      auto len = _vec.len[u8](v);\n-      auto count = 0u;\n-      auto vbuf;\n-      while (count < len) {\n-        vbuf = _vec.buf_off[u8](v, count);\n-        auto nout = os.libc.write(fd, vbuf, len);\n-        if (nout < 0) {\n-          log \"error dumping buffer\";\n-          log sys.rustrt.last_os_error();\n-          fail;\n+    unsafe obj fd_buf_writer(int fd) {\n+\n+        fn write(vec[u8] v) {\n+            auto len = _vec.len[u8](v);\n+            auto count = 0u;\n+            auto vbuf;\n+            while (count < len) {\n+                vbuf = _vec.buf_off[u8](v, count);\n+                auto nout = os.libc.write(fd, vbuf, len);\n+                if (nout < 0) {\n+                    log \"error dumping buffer\";\n+                    log sys.rustrt.last_os_error();\n+                    fail;\n+                }\n+                count += nout as uint;\n+            }\n+        }\n+\n+        drop {\n+            os.libc.close(fd);\n         }\n-        count += nout as uint;\n-      }\n     }\n \n-    drop {\n-      os.libc.close(fd);\n+    let int fflags =\n+        os.libc_constants.O_WRONLY() |\n+        os.libc_constants.O_BINARY();\n+\n+    for (fileflag f in flags) {\n+        alt (f) {\n+            case (append())   { fflags |= os.libc_constants.O_APPEND(); }\n+            case (create())   { fflags |= os.libc_constants.O_CREAT(); }\n+            case (truncate()) { fflags |= os.libc_constants.O_TRUNC(); }\n+        }\n     }\n-  }\n \n-  let int fflags =\n-    os.libc_constants.O_WRONLY() |\n-    os.libc_constants.O_BINARY();\n+    auto fd = os.libc.open(_str.buf(path),\n+                           fflags,\n+                           os.libc_constants.S_IRUSR() |\n+                           os.libc_constants.S_IWUSR());\n \n-  for (fileflag f in flags) {\n-    alt (f) {\n-      case (append())   { fflags |= os.libc_constants.O_APPEND(); }\n-      case (create())   { fflags |= os.libc_constants.O_CREAT(); }\n-      case (truncate()) { fflags |= os.libc_constants.O_TRUNC(); }\n+    if (fd < 0) {\n+        log \"error opening file for writing\";\n+        log sys.rustrt.last_os_error();\n+        fail;\n     }\n-  }\n-\n-  auto fd = os.libc.open(_str.buf(path),\n-                         fflags,\n-                         os.libc_constants.S_IRUSR() |\n-                         os.libc_constants.S_IWUSR());\n-\n-  if (fd < 0) {\n-    log \"error opening file for writing\";\n-    log sys.rustrt.last_os_error();\n-    fail;\n-  }\n-  ret fd_buf_writer(fd);\n+    ret fd_buf_writer(fd);\n }\n \n type writer =\n-  unsafe obj {\n-    fn write_str(str s);\n-    fn write_int(int n);\n-    fn write_uint(uint n);\n-  };\n+    unsafe obj {\n+           fn write_str(str s);\n+           fn write_int(int n);\n+           fn write_uint(uint n);\n+    };\n \n fn file_writer(str path,\n                vec[fileflag] flags)\n-  -> writer\n+    -> writer\n {\n-  unsafe obj fw(buf_writer out) {\n-    fn write_str(str s)   { out.write(_str.bytes(s)); }\n-    fn write_int(int n)   { out.write(_str.bytes(_int.to_str(n, 10u))); }\n-    fn write_uint(uint n) { out.write(_str.bytes(_uint.to_str(n, 10u))); }\n-  }\n-  ret fw(new_buf_writer(path, flags));\n+    unsafe obj fw(buf_writer out) {\n+        fn write_str(str s)   { out.write(_str.bytes(s)); }\n+        fn write_int(int n)   { out.write(_str.bytes(_int.to_str(n, 10u))); }\n+        fn write_uint(uint n) { out.write(_str.bytes(_uint.to_str(n, 10u))); }\n+    }\n+    ret fw(new_buf_writer(path, flags));\n }\n \n //"}, {"sha": "dd5d8bfc8ccf3b85aa08d8aed73cf374e660fede", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1db0cb208de058ea2d1d5b2d2982a482d55de3b8/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db0cb208de058ea2d1d5b2d2982a482d55de3b8/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=1db0cb208de058ea2d1d5b2d2982a482d55de3b8", "patch": "@@ -12,6 +12,7 @@ native mod libc = \"libc.so.6\" {\n   fn fopen(sbuf path, sbuf mode) -> FILE;\n   fn fclose(FILE f);\n   fn fgetc(FILE f) -> int;\n+  fn ungetc(int c, FILE f);\n \n   type dir;\n   // readdir is a mess; handle via wrapper function in rustrt."}, {"sha": "22ab3a79daa84e1e26f465280bf59e4e23685fec", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1db0cb208de058ea2d1d5b2d2982a482d55de3b8/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db0cb208de058ea2d1d5b2d2982a482d55de3b8/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=1db0cb208de058ea2d1d5b2d2982a482d55de3b8", "patch": "@@ -12,6 +12,7 @@ native mod libc = \"libc.dylib\" {\n   fn fopen(sbuf path, sbuf mode) -> FILE;\n   fn fclose(FILE f);\n   fn fgetc(FILE f) -> int;\n+  fn ungetc(int c, FILE f);\n \n   type dir;\n   // readdir is a mess; handle via wrapper function in rustrt."}, {"sha": "3a6da60f56a68a5b74a8307b5eb662ce39abaa43", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1db0cb208de058ea2d1d5b2d2982a482d55de3b8/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db0cb208de058ea2d1d5b2d2982a482d55de3b8/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=1db0cb208de058ea2d1d5b2d2982a482d55de3b8", "patch": "@@ -11,6 +11,7 @@ native mod libc = \"msvcrt.dll\" {\n   fn fopen(sbuf path, sbuf mode) -> FILE;\n   fn fclose(FILE f);\n   fn fgetc(FILE f) -> int;\n+  fn ungetc(int c, FILE f);\n }\n \n mod libc_constants {"}]}