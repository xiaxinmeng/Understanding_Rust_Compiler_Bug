{"sha": "8651011b6fffb7f95a354ce85eeb1d2aa4b476a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NTEwMTFiNmZmZmI3Zjk1YTM1NGNlODVlZWIxZDJhYTRiNDc2YTU=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@composition.al", "date": "2013-09-01T03:51:07Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@composition.al", "date": "2013-09-05T10:25:23Z"}, "message": "Factor shared code out into default GenericPath methods.", "tree": {"sha": "e1c86fc3f9c287935250ac7ed9a598c227c51d8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1c86fc3f9c287935250ac7ed9a598c227c51d8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8651011b6fffb7f95a354ce85eeb1d2aa4b476a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8651011b6fffb7f95a354ce85eeb1d2aa4b476a5", "html_url": "https://github.com/rust-lang/rust/commit/8651011b6fffb7f95a354ce85eeb1d2aa4b476a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8651011b6fffb7f95a354ce85eeb1d2aa4b476a5/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d285ea791058f7db8bef828740aae95e69becc99", "url": "https://api.github.com/repos/rust-lang/rust/commits/d285ea791058f7db8bef828740aae95e69becc99", "html_url": "https://github.com/rust-lang/rust/commit/d285ea791058f7db8bef828740aae95e69becc99"}], "stats": {"total": 367, "additions": 144, "deletions": 223}, "files": [{"sha": "16af8b1da3ef06b0e44808322b9e50337db7a534", "filename": "src/libstd/path.rs", "status": "modified", "additions": 144, "deletions": 223, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/8651011b6fffb7f95a354ce85eeb1d2aa4b476a5/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8651011b6fffb7f95a354ce85eeb1d2aa4b476a5/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=8651011b6fffb7f95a354ce85eeb1d2aa4b476a5", "patch": "@@ -57,61 +57,123 @@ pub fn PosixPath(s: &str) -> PosixPath {\n     GenericPath::from_str(s)\n }\n \n-pub trait GenericPath {\n+pub trait GenericPath : Clone + Eq + ToStr {\n     /// Converts a string to a Path\n     fn from_str(&str) -> Self;\n \n     /// Returns the directory component of `self`, as a string\n-    fn dirname(&self) -> ~str;\n+    fn dirname(&self) -> ~str {\n+        let s = self.dir_path().to_str();\n+        match s.len() {\n+            0 => ~\".\",\n+            _ => s,\n+        }\n+    }\n+\n     /// Returns the file component of `self`, as a string option.\n     /// Returns None if `self` names a directory.\n-    fn filename<'a>(&'a self) -> Option<&'a str>;\n+    fn filename<'a>(&'a self) -> Option<&'a str> {\n+        match self.components().len() {\n+            0 => None,\n+            n => Some(self.components()[n - 1].as_slice()),\n+        }\n+    }\n+\n     /// Returns the stem of the file component of `self`, as a string option.\n     /// The stem is the slice of a filename starting at 0 and ending just before\n     /// the last '.' in the name.\n     /// Returns None if `self` names a directory.\n-    fn filestem<'a>(&'a self) -> Option<&'a str>;\n+    fn filestem<'a>(&'a self) -> Option<&'a str> {\n+        match self.filename() {\n+            None => None,\n+            Some(ref f) => {\n+                match f.rfind('.') {\n+                    Some(p) => Some(f.slice_to(p)),\n+                    None => Some((*f)),\n+                }\n+            }\n+        }\n+    }\n+\n     /// Returns the type of the file component of `self`, as a string option.\n     /// The file type is the slice of a filename starting just after the last\n     /// '.' in the name and ending at the last index in the filename.\n     /// Returns None if `self` names a directory.\n-    fn filetype<'a>(&'a self) -> Option<&'a str>;\n+    fn filetype<'a>(&'a self) -> Option<&'a str> {\n+        match self.filename() {\n+            None => None,\n+            Some(ref f) => {\n+                match f.rfind('.') {\n+                    Some(p) if p < f.len() => Some(f.slice_from(p)),\n+                    _ => None,\n+                }\n+            }\n+        }\n+    }\n \n     /// Returns a new path consisting of `self` with the parent directory component replaced\n     /// with the given string.\n     fn with_dirname(&self, (&str)) -> Self;\n+\n     /// Returns a new path consisting of `self` with the file component replaced\n     /// with the given string.\n     fn with_filename(&self, (&str)) -> Self;\n+\n     /// Returns a new path consisting of `self` with the file stem replaced\n     /// with the given string.\n-    fn with_filestem(&self, (&str)) -> Self;\n+    fn with_filestem(&self, s: &str) -> Self {\n+        match self.filetype() {\n+            None => self.with_filename(s),\n+            Some(ref t) => self.with_filename(s.to_owned() + *t),\n+        }\n+    }\n+\n     /// Returns a new path consisting of `self` with the file type replaced\n     /// with the given string.\n-    fn with_filetype(&self, (&str)) -> Self;\n+    fn with_filetype(&self, t: &str) -> Self {\n+        match (t.len(), self.filestem()) {\n+            (0, None)        => (*self).clone(),\n+            (0, Some(ref s)) => self.with_filename(*s),\n+            (_, None)        => self.with_filename(fmt!(\".%s\", t)),\n+            (_, Some(ref s)) => self.with_filename(fmt!(\"%s.%s\", *s, t)),\n+        }\n+    }\n \n     /// Returns the directory component of `self`, as a new path.\n     /// If `self` has no parent, returns `self`.\n-    fn dir_path(&self) -> Self;\n+    fn dir_path(&self) -> Self {\n+        match self.components().len() {\n+            0 => (*self).clone(),\n+            _ => self.pop(),\n+        }\n+    }\n+\n     /// Returns the file component of `self`, as a new path.\n     /// If `self` names a directory, returns the empty path.\n     fn file_path(&self) -> Self;\n \n     /// Returns a new Path whose parent directory is `self` and whose\n     /// file component is the given string.\n     fn push(&self, (&str)) -> Self;\n+\n     /// Returns a new Path consisting of the given path, made relative to `self`.\n-    fn push_rel(&self, (&Self)) -> Self;\n+    fn push_rel(&self, other: &Self) -> Self {\n+        assert!(!other.is_absolute());\n+        self.push_many(other.components())\n+    }\n+\n     /// Returns a new Path consisting of the path given by the given vector\n     /// of strings, relative to `self`.\n     fn push_many<S: Str>(&self, (&[S])) -> Self;\n+\n     /// Identical to `dir_path` except in the case where `self` has only one\n     /// component. In this case, `pop` returns the empty path.\n     fn pop(&self) -> Self;\n \n     /// The same as `push_rel`, except that the directory argument must not\n     /// contain directory separators in any of its components.\n     fn unsafe_join(&self, (&Self)) -> Self;\n+\n     /// On Unix, always returns false. On Windows, returns true iff `self`'s\n     /// file stem is one of: `con` `aux` `com1` `com2` `com3` `com4`\n     /// `lpt1` `lpt2` `lpt3` `prn` `nul`\n@@ -126,7 +188,14 @@ pub trait GenericPath {\n     fn is_absolute(&self) -> bool;\n \n     /// True if `self` is an ancestor of `other`. See `test_is_ancestor_of` for examples\n-    fn is_ancestor_of(&self, (&Self)) -> bool;\n+    fn is_ancestor_of(&self, other: &Self) -> bool {\n+        debug!(\"%s / %s %? %?\", self.to_str(), other.to_str(), self.is_absolute(),\n+               self.components().len());\n+        self == other ||\n+            (!other.components().is_empty() &&\n+             !(self.components().is_empty() && !self.is_absolute()) &&\n+             self.is_ancestor_of(&other.pop()))\n+    }\n \n     /// Find the relative path from one file to another\n     fn get_relative_to(&self, abs2: (&Self)) -> Self {\n@@ -578,8 +647,6 @@ impl ToCStr for PosixPath {\n     }\n }\n \n-// FIXME (#3227): when default methods in traits are working, de-duplicate\n-// PosixPath and WindowsPath, most of their methods are common.\n impl GenericPath for PosixPath {\n     fn from_str(s: &str) -> PosixPath {\n         let components = s.split_iter('/')\n@@ -592,45 +659,6 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    fn dirname(&self) -> ~str {\n-        let s = self.dir_path().to_str();\n-        match s.len() {\n-            0 => ~\".\",\n-            _ => s,\n-        }\n-    }\n-\n-    fn filename<'a>(&'a self) -> Option<&'a str> {\n-        match self.components.len() {\n-            0 => None,\n-            n => Some(self.components[n - 1].as_slice()),\n-        }\n-    }\n-\n-    fn filestem<'a>(&'a self) -> Option<&'a str> {\n-        match self.filename() {\n-            None => None,\n-            Some(ref f) => {\n-                match f.rfind('.') {\n-                    Some(p) => Some(f.slice_to(p)),\n-                    None => Some((*f)),\n-                }\n-            }\n-        }\n-    }\n-\n-    fn filetype<'a>(&'a self) -> Option<&'a str> {\n-        match self.filename() {\n-            None => None,\n-            Some(ref f) => {\n-                match f.rfind('.') {\n-                    Some(p) if p < f.len() => Some(f.slice_from(p)),\n-                    _ => None,\n-                }\n-            }\n-        }\n-    }\n-\n     fn with_dirname(&self, d: &str) -> PosixPath {\n         let dpath = PosixPath(d);\n         match self.filename() {\n@@ -644,29 +672,6 @@ impl GenericPath for PosixPath {\n         self.dir_path().push(f)\n     }\n \n-    fn with_filestem(&self, s: &str) -> PosixPath {\n-        match self.filetype() {\n-            None => self.with_filename(s),\n-            Some(ref t) => self.with_filename(s.to_owned() + *t),\n-        }\n-    }\n-\n-    fn with_filetype(&self, t: &str) -> PosixPath {\n-        match (t.len(), self.filestem()) {\n-            (0, None)        => (*self).clone(),\n-            (0, Some(ref s)) => self.with_filename(*s),\n-            (_, None)        => self.with_filename(fmt!(\".%s\", t)),\n-            (_, Some(ref s)) => self.with_filename(fmt!(\"%s.%s\", *s, t)),\n-        }\n-    }\n-\n-    fn dir_path(&self) -> PosixPath {\n-        match self.components.len() {\n-            0 => (*self).clone(),\n-            _ => self.pop(),\n-        }\n-    }\n-\n     fn file_path(&self) -> PosixPath {\n         let cs = match self.filename() {\n           None => ~[],\n@@ -678,24 +683,17 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    fn push_rel(&self, other: &PosixPath) -> PosixPath {\n-        assert!(!other.is_absolute);\n-        self.push_many(other.components)\n-    }\n-\n-    fn unsafe_join(&self, other: &PosixPath) -> PosixPath {\n-        if other.is_absolute {\n-            PosixPath {\n-                is_absolute: true,\n-                components: other.components.clone(),\n+    fn push(&self, s: &str) -> PosixPath {\n+        let mut v = self.components.clone();\n+        for s in s.split_iter(posix::is_sep) {\n+            if !s.is_empty() {\n+                v.push(s.to_owned())\n             }\n-        } else {\n-            self.push_rel(other)\n         }\n-    }\n-\n-    fn is_restricted(&self) -> bool {\n-        false\n+        PosixPath {\n+            components: v,\n+            ..(*self).clone()\n+        }\n     }\n \n     fn push_many<S: Str>(&self, cs: &[S]) -> PosixPath {\n@@ -713,19 +711,6 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    fn push(&self, s: &str) -> PosixPath {\n-        let mut v = self.components.clone();\n-        for s in s.split_iter(posix::is_sep) {\n-            if !s.is_empty() {\n-                v.push(s.to_owned())\n-            }\n-        }\n-        PosixPath {\n-            components: v,\n-            ..(*self).clone()\n-        }\n-    }\n-\n     fn pop(&self) -> PosixPath {\n         let mut cs = self.components.clone();\n         if cs.len() != 0 {\n@@ -737,6 +722,21 @@ impl GenericPath for PosixPath {\n         } //..self }\n     }\n \n+    fn unsafe_join(&self, other: &PosixPath) -> PosixPath {\n+        if other.is_absolute {\n+            PosixPath {\n+                is_absolute: true,\n+                components: other.components.clone(),\n+            }\n+        } else {\n+            self.push_rel(other)\n+        }\n+    }\n+\n+    fn is_restricted(&self) -> bool {\n+        false\n+    }\n+\n     fn normalize(&self) -> PosixPath {\n         PosixPath {\n             is_absolute: self.is_absolute,\n@@ -748,15 +748,8 @@ impl GenericPath for PosixPath {\n         self.is_absolute\n     }\n \n-    fn is_ancestor_of(&self, other: &PosixPath) -> bool {\n-        debug!(\"%s / %s %? %?\", self.to_str(), other.to_str(), self.is_absolute,\n-               self.components.len());\n-        self == other ||\n-            (!other.components.is_empty() && !(self.components.is_empty() && !self.is_absolute) &&\n-             self.is_ancestor_of(&other.pop()))\n-    }\n+    fn components<'a>(&'a self) -> &'a [~str] { self.components.as_slice() }\n \n-   fn components<'a>(&'a self) -> &'a [~str] { self.components.as_slice() }\n }\n \n \n@@ -834,45 +827,6 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    fn dirname(&self) -> ~str {\n-        let s = self.dir_path().to_str();\n-        match s.len() {\n-            0 => ~\".\",\n-            _ => s,\n-        }\n-    }\n-\n-    fn filename<'a>(&'a self) -> Option<&'a str> {\n-        match self.components.len() {\n-            0 => None,\n-            n => Some(self.components[n - 1].as_slice()),\n-        }\n-    }\n-\n-    fn filestem<'a>(&'a self) -> Option<&'a str> {\n-        match self.filename() {\n-            None => None,\n-            Some(ref f) => {\n-                match f.rfind('.') {\n-                    Some(p) => Some(f.slice_to(p)),\n-                    None => Some((*f)),\n-                }\n-            }\n-        }\n-    }\n-\n-    fn filetype<'a>(&'a self) -> Option<&'a str> {\n-        match self.filename() {\n-          None => None,\n-          Some(ref f) => {\n-            match f.rfind('.') {\n-                Some(p) if p < f.len() => Some(f.slice_from(p)),\n-                _ => None,\n-            }\n-          }\n-        }\n-    }\n-\n     fn with_dirname(&self, d: &str) -> WindowsPath {\n         let dpath = WindowsPath(d);\n         match self.filename() {\n@@ -886,29 +840,6 @@ impl GenericPath for WindowsPath {\n         self.dir_path().push(f)\n     }\n \n-    fn with_filestem(&self, s: &str) -> WindowsPath {\n-        match self.filetype() {\n-            None => self.with_filename(s),\n-            Some(ref t) => self.with_filename(s.to_owned() + *t),\n-        }\n-    }\n-\n-    fn with_filetype(&self, t: &str) -> WindowsPath {\n-        match (t.len(), self.filestem()) {\n-            (0, None)        => (*self).clone(),\n-            (0, Some(ref s)) => self.with_filename(*s),\n-            (_, None)        => self.with_filename(fmt!(\".%s\", t)),\n-            (_, Some(ref s)) => self.with_filename(fmt!(\"%s.%s\", *s, t)),\n-        }\n-    }\n-\n-    fn dir_path(&self) -> WindowsPath {\n-        match self.components.len() {\n-            0 => (*self).clone(),\n-            _ => self.pop(),\n-        }\n-    }\n-\n     fn file_path(&self) -> WindowsPath {\n         WindowsPath {\n             host: None,\n@@ -921,9 +852,45 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    fn push_rel(&self, other: &WindowsPath) -> WindowsPath {\n-        assert!(!other.is_absolute);\n-        self.push_many(other.components)\n+    fn push(&self, s: &str) -> WindowsPath {\n+        let mut v = self.components.clone();\n+        for s in s.split_iter(windows::is_sep) {\n+            if !s.is_empty() {\n+                v.push(s.to_owned())\n+            }\n+        }\n+        WindowsPath { components: v, ..(*self).clone() }\n+    }\n+\n+    fn push_many<S: Str>(&self, cs: &[S]) -> WindowsPath {\n+        let mut v = self.components.clone();\n+        for e in cs.iter() {\n+            for s in e.as_slice().split_iter(windows::is_sep) {\n+                if !s.is_empty() {\n+                    v.push(s.to_owned())\n+                }\n+            }\n+        }\n+        // tedious, but as-is, we can't use ..self\n+        WindowsPath {\n+            host: self.host.clone(),\n+            device: self.device.clone(),\n+            is_absolute: self.is_absolute,\n+            components: v\n+        }\n+    }\n+\n+    fn pop(&self) -> WindowsPath {\n+        let mut cs = self.components.clone();\n+        if cs.len() != 0 {\n+            cs.pop();\n+        }\n+        WindowsPath {\n+            host: self.host.clone(),\n+            device: self.device.clone(),\n+            is_absolute: self.is_absolute,\n+            components: cs,\n+        }\n     }\n \n     fn unsafe_join(&self, other: &WindowsPath) -> WindowsPath {\n@@ -983,47 +950,6 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    fn push_many<S: Str>(&self, cs: &[S]) -> WindowsPath {\n-        let mut v = self.components.clone();\n-        for e in cs.iter() {\n-            for s in e.as_slice().split_iter(windows::is_sep) {\n-                if !s.is_empty() {\n-                    v.push(s.to_owned())\n-                }\n-            }\n-        }\n-        // tedious, but as-is, we can't use ..self\n-        WindowsPath {\n-            host: self.host.clone(),\n-            device: self.device.clone(),\n-            is_absolute: self.is_absolute,\n-            components: v\n-        }\n-    }\n-\n-    fn push(&self, s: &str) -> WindowsPath {\n-        let mut v = self.components.clone();\n-        for s in s.split_iter(windows::is_sep) {\n-            if !s.is_empty() {\n-                v.push(s.to_owned())\n-            }\n-        }\n-        WindowsPath { components: v, ..(*self).clone() }\n-    }\n-\n-    fn pop(&self) -> WindowsPath {\n-        let mut cs = self.components.clone();\n-        if cs.len() != 0 {\n-            cs.pop();\n-        }\n-        WindowsPath {\n-            host: self.host.clone(),\n-            device: self.device.clone(),\n-            is_absolute: self.is_absolute,\n-            components: cs,\n-        }\n-    }\n-\n     fn normalize(&self) -> WindowsPath {\n         WindowsPath {\n             host: self.host.clone(),\n@@ -1043,13 +969,8 @@ impl GenericPath for WindowsPath {\n         self.is_absolute\n     }\n \n-    fn is_ancestor_of(&self, other: &WindowsPath) -> bool {\n-        self == other ||\n-            (!other.components.is_empty() && !(self.components.is_empty() && !self.is_absolute) &&\n-             self.is_ancestor_of(&other.pop()))\n-    }\n+    fn components<'a>(&'a self) -> &'a [~str] { self.components.as_slice() }\n \n-   fn components<'a>(&'a self) -> &'a [~str] { self.components.as_slice() }\n }\n \n pub fn normalize(components: &[~str]) -> ~[~str] {"}]}