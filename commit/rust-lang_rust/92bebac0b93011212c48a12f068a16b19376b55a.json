{"sha": "92bebac0b93011212c48a12f068a16b19376b55a", "node_id": "C_kwDOAAsO6NoAKDkyYmViYWMwYjkzMDExMjEyYzQ4YTEyZjA2OGExNmIxOTM3NmI1NWE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-22T06:23:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-22T06:23:42Z"}, "message": "Rollup merge of #99539 - compiler-errors:bidirectional-block-suggestions, r=fee1-dead\n\nImprove suggestions for returning binding\n\nFixes #99525\n\nAlso reworks the cause codes for match and if a bit, I think cleaning them up in a positive way.\nWe no longer need to call `could_remove_semicolon` in successful code, which might save a few cycles?", "tree": {"sha": "4db7642303ff28d02ed7d15093b6bb5c6b0c4b52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4db7642303ff28d02ed7d15093b6bb5c6b0c4b52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92bebac0b93011212c48a12f068a16b19376b55a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi2kJvCRBK7hj4Ov3rIwAA2H4IAJcb+NJhUptb4/gnyOL8jWuG\nXismYXbk+WR1oV3aAh8s+a6T+4tKrFwtgltHf4eXHUjRcw/vWOTJbmKcItDilYfd\nwiH4Jq5HnJ/ci+a7AXR4iiPgzSr2X8MQKwl43dlrMP6ZiMfEG4Gy4gDj8l95KMHL\nh7y7DTsth1H6kF1WzJfOGnsm00GvTw/wjeRwKL3oPtbceCwhG1QBugZ80ZU0gdeG\nF2fXV+HDHYcyCKNOYMJyZDe7tL7MYpc0T11nqlsB7zIHZ+wxNxZhDZ59aRM+uZyS\nFmMdon00HSMkASbF/nIxCOAxCy5UFgjMvdxNXnz0FljaCK9mP8XBVoMqVCkmtG4=\n=6itt\n-----END PGP SIGNATURE-----\n", "payload": "tree 4db7642303ff28d02ed7d15093b6bb5c6b0c4b52\nparent aec458b54f1ddcd5aada9a8e83d79348e2a3be41\nparent 3eef023da04cd732ee6656867e2161b7dbfee821\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1658471022 +0530\ncommitter GitHub <noreply@github.com> 1658471022 +0530\n\nRollup merge of #99539 - compiler-errors:bidirectional-block-suggestions, r=fee1-dead\n\nImprove suggestions for returning binding\n\nFixes #99525\n\nAlso reworks the cause codes for match and if a bit, I think cleaning them up in a positive way.\nWe no longer need to call `could_remove_semicolon` in successful code, which might save a few cycles?\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92bebac0b93011212c48a12f068a16b19376b55a", "html_url": "https://github.com/rust-lang/rust/commit/92bebac0b93011212c48a12f068a16b19376b55a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92bebac0b93011212c48a12f068a16b19376b55a/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aec458b54f1ddcd5aada9a8e83d79348e2a3be41", "url": "https://api.github.com/repos/rust-lang/rust/commits/aec458b54f1ddcd5aada9a8e83d79348e2a3be41", "html_url": "https://github.com/rust-lang/rust/commit/aec458b54f1ddcd5aada9a8e83d79348e2a3be41"}, {"sha": "3eef023da04cd732ee6656867e2161b7dbfee821", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eef023da04cd732ee6656867e2161b7dbfee821", "html_url": "https://github.com/rust-lang/rust/commit/3eef023da04cd732ee6656867e2161b7dbfee821"}], "stats": {"total": 1092, "additions": 625, "deletions": 467}, "files": [{"sha": "18ffc227fed869e71de9fb50df4482263b38ffa4", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=92bebac0b93011212c48a12f068a16b19376b55a", "patch": "@@ -954,6 +954,16 @@ pub struct Block<'hir> {\n     pub targeted_by_break: bool,\n }\n \n+impl<'hir> Block<'hir> {\n+    pub fn innermost_block(&self) -> &Block<'hir> {\n+        let mut block = self;\n+        while let Some(Expr { kind: ExprKind::Block(inner_block, _), .. }) = block.expr {\n+            block = inner_block;\n+        }\n+        block\n+    }\n+}\n+\n #[derive(Debug, HashStable_Generic)]\n pub struct Pat<'hir> {\n     #[stable_hasher(ignore)]"}, {"sha": "4e87ec86658f81503f29af7340dae6dbee9b6705", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 422, "deletions": 117, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=92bebac0b93011212c48a12f068a16b19376b55a", "patch": "@@ -316,37 +316,6 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n     err\n }\n \n-/// Structurally compares two types, modulo any inference variables.\n-///\n-/// Returns `true` if two types are equal, or if one type is an inference variable compatible\n-/// with the other type. A TyVar inference type is compatible with any type, and an IntVar or\n-/// FloatVar inference type are compatible with themselves or their concrete types (Int and\n-/// Float types, respectively). When comparing two ADTs, these rules apply recursively.\n-pub fn same_type_modulo_infer<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-    match (&a.kind(), &b.kind()) {\n-        (&ty::Adt(did_a, substs_a), &ty::Adt(did_b, substs_b)) => {\n-            if did_a != did_b {\n-                return false;\n-            }\n-\n-            substs_a.types().zip(substs_b.types()).all(|(a, b)| same_type_modulo_infer(a, b))\n-        }\n-        (&ty::Int(_), &ty::Infer(ty::InferTy::IntVar(_)))\n-        | (&ty::Infer(ty::InferTy::IntVar(_)), &ty::Int(_) | &ty::Infer(ty::InferTy::IntVar(_)))\n-        | (&ty::Float(_), &ty::Infer(ty::InferTy::FloatVar(_)))\n-        | (\n-            &ty::Infer(ty::InferTy::FloatVar(_)),\n-            &ty::Float(_) | &ty::Infer(ty::InferTy::FloatVar(_)),\n-        )\n-        | (&ty::Infer(ty::InferTy::TyVar(_)), _)\n-        | (_, &ty::Infer(ty::InferTy::TyVar(_))) => true,\n-        (&ty::Ref(_, ty_a, mut_a), &ty::Ref(_, ty_b, mut_b)) => {\n-            mut_a == mut_b && same_type_modulo_infer(*ty_a, *ty_b)\n-        }\n-        _ => a == b,\n-    }\n-}\n-\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_region_errors(\n         &self,\n@@ -645,13 +614,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 err.span_label(span, \"expected due to this\");\n             }\n             ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                semi_span,\n+                arm_block_id,\n+                arm_span,\n+                arm_ty,\n+                prior_arm_block_id,\n+                prior_arm_span,\n+                prior_arm_ty,\n                 source,\n                 ref prior_arms,\n-                last_ty,\n                 scrut_hir_id,\n                 opt_suggest_box_span,\n-                arm_span,\n                 scrut_span,\n                 ..\n             }) => match source {\n@@ -682,10 +654,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                 }\n                 _ => {\n-                    // `last_ty` can be `!`, `expected` will have better info when present.\n+                    // `prior_arm_ty` can be `!`, `expected` will have better info when present.\n                     let t = self.resolve_vars_if_possible(match exp_found {\n                         Some(ty::error::ExpectedFound { expected, .. }) => expected,\n-                        _ => last_ty,\n+                        _ => prior_arm_ty,\n                     });\n                     let source_map = self.tcx.sess.source_map();\n                     let mut any_multiline_arm = source_map.is_multiline(arm_span);\n@@ -710,37 +682,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     };\n                     let msg = \"`match` arms have incompatible types\";\n                     err.span_label(outer_error_span, msg);\n-                    if let Some((sp, boxed)) = semi_span {\n-                        if let (StatementAsExpression::NeedsBoxing, [.., prior_arm]) =\n-                            (boxed, &prior_arms[..])\n-                        {\n-                            err.multipart_suggestion(\n-                                \"consider removing this semicolon and boxing the expressions\",\n-                                vec![\n-                                    (prior_arm.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                    (prior_arm.shrink_to_hi(), \")\".to_string()),\n-                                    (arm_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                    (arm_span.shrink_to_hi(), \")\".to_string()),\n-                                    (sp, String::new()),\n-                                ],\n-                                Applicability::HasPlaceholders,\n-                            );\n-                        } else if matches!(boxed, StatementAsExpression::NeedsBoxing) {\n-                            err.span_suggestion_short(\n-                                sp,\n-                                \"consider removing this semicolon and boxing the expressions\",\n-                                \"\",\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            err.span_suggestion_short(\n-                                sp,\n-                                \"consider removing this semicolon\",\n-                                \"\",\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    }\n+                    self.suggest_remove_semi_or_return_binding(\n+                        err,\n+                        prior_arm_block_id,\n+                        prior_arm_ty,\n+                        prior_arm_span,\n+                        arm_block_id,\n+                        arm_ty,\n+                        arm_span,\n+                    );\n                     if let Some(ret_sp) = opt_suggest_box_span {\n                         // Get return type span and point to it.\n                         self.suggest_boxing_for_return_impl_trait(\n@@ -752,43 +702,33 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n             },\n             ObligationCauseCode::IfExpression(box IfExpressionCause {\n-                then,\n-                else_sp,\n-                outer,\n-                semicolon,\n+                then_id,\n+                else_id,\n+                then_ty,\n+                else_ty,\n+                outer_span,\n                 opt_suggest_box_span,\n             }) => {\n-                err.span_label(then, \"expected because of this\");\n-                if let Some(sp) = outer {\n+                let then_span = self.find_block_span_from_hir_id(then_id);\n+                let else_span = self.find_block_span_from_hir_id(then_id);\n+                err.span_label(then_span, \"expected because of this\");\n+                if let Some(sp) = outer_span {\n                     err.span_label(sp, \"`if` and `else` have incompatible types\");\n                 }\n-                if let Some((sp, boxed)) = semicolon {\n-                    if matches!(boxed, StatementAsExpression::NeedsBoxing) {\n-                        err.multipart_suggestion(\n-                            \"consider removing this semicolon and boxing the expression\",\n-                            vec![\n-                                (then.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                (then.shrink_to_hi(), \")\".to_string()),\n-                                (else_sp.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                (else_sp.shrink_to_hi(), \")\".to_string()),\n-                                (sp, String::new()),\n-                            ],\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        err.span_suggestion_short(\n-                            sp,\n-                            \"consider removing this semicolon\",\n-                            \"\",\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                }\n+                self.suggest_remove_semi_or_return_binding(\n+                    err,\n+                    Some(then_id),\n+                    then_ty,\n+                    then_span,\n+                    Some(else_id),\n+                    else_ty,\n+                    else_span,\n+                );\n                 if let Some(ret_sp) = opt_suggest_box_span {\n                     self.suggest_boxing_for_return_impl_trait(\n                         err,\n                         ret_sp,\n-                        [then, else_sp].into_iter(),\n+                        [then_span, else_span].into_iter(),\n                     );\n                 }\n             }\n@@ -808,6 +748,56 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn suggest_remove_semi_or_return_binding(\n+        &self,\n+        err: &mut Diagnostic,\n+        first_id: Option<hir::HirId>,\n+        first_ty: Ty<'tcx>,\n+        first_span: Span,\n+        second_id: Option<hir::HirId>,\n+        second_ty: Ty<'tcx>,\n+        second_span: Span,\n+    ) {\n+        let remove_semicolon =\n+            [(first_id, second_ty), (second_id, first_ty)].into_iter().find_map(|(id, ty)| {\n+                let hir::Node::Block(blk) = self.tcx.hir().get(id?) else { return None };\n+                self.could_remove_semicolon(blk, ty)\n+            });\n+        match remove_semicolon {\n+            Some((sp, StatementAsExpression::NeedsBoxing)) => {\n+                err.multipart_suggestion(\n+                    \"consider removing this semicolon and boxing the expressions\",\n+                    vec![\n+                        (first_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                        (first_span.shrink_to_hi(), \")\".to_string()),\n+                        (second_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                        (second_span.shrink_to_hi(), \")\".to_string()),\n+                        (sp, String::new()),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            Some((sp, StatementAsExpression::CorrectType)) => {\n+                err.span_suggestion_short(\n+                    sp,\n+                    \"consider removing this semicolon\",\n+                    \"\",\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            None => {\n+                for (id, ty) in [(first_id, second_ty), (second_id, first_ty)] {\n+                    if let Some(id) = id\n+                        && let hir::Node::Block(blk) = self.tcx.hir().get(id)\n+                        && self.consider_returning_binding(blk, ty, err)\n+                    {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn suggest_boxing_for_return_impl_trait(\n         &self,\n         err: &mut Diagnostic,\n@@ -1723,15 +1713,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n         debug!(\"exp_found {:?} terr {:?} cause.code {:?}\", exp_found, terr, cause.code());\n         if let Some(exp_found) = exp_found {\n-            let should_suggest_fixes = if let ObligationCauseCode::Pattern { root_ty, .. } =\n-                cause.code()\n-            {\n-                // Skip if the root_ty of the pattern is not the same as the expected_ty.\n-                // If these types aren't equal then we've probably peeled off a layer of arrays.\n-                same_type_modulo_infer(self.resolve_vars_if_possible(*root_ty), exp_found.expected)\n-            } else {\n-                true\n-            };\n+            let should_suggest_fixes =\n+                if let ObligationCauseCode::Pattern { root_ty, .. } = cause.code() {\n+                    // Skip if the root_ty of the pattern is not the same as the expected_ty.\n+                    // If these types aren't equal then we've probably peeled off a layer of arrays.\n+                    self.same_type_modulo_infer(*root_ty, exp_found.expected)\n+                } else {\n+                    true\n+                };\n \n             if should_suggest_fixes {\n                 self.suggest_tuple_pattern(cause, &exp_found, diag);\n@@ -1786,7 +1775,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     .filter_map(|variant| {\n                         let sole_field = &variant.fields[0];\n                         let sole_field_ty = sole_field.ty(self.tcx, substs);\n-                        if same_type_modulo_infer(sole_field_ty, exp_found.found) {\n+                        if self.same_type_modulo_infer(sole_field_ty, exp_found.found) {\n                             let variant_path =\n                                 with_no_trimmed_paths!(self.tcx.def_path_str(variant.def_id));\n                             // FIXME #56861: DRYer prelude filtering\n@@ -1902,12 +1891,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             self.get_impl_future_output_ty(exp_found.expected).map(Binder::skip_binder),\n             self.get_impl_future_output_ty(exp_found.found).map(Binder::skip_binder),\n         ) {\n-            (Some(exp), Some(found)) if same_type_modulo_infer(exp, found) => match cause.code() {\n-                ObligationCauseCode::IfExpression(box IfExpressionCause { then, .. }) => {\n+            (Some(exp), Some(found)) if self.same_type_modulo_infer(exp, found) => match cause\n+                .code()\n+            {\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n+                    let then_span = self.find_block_span_from_hir_id(*then_id);\n                     diag.multipart_suggestion(\n                         \"consider `await`ing on both `Future`s\",\n                         vec![\n-                            (then.shrink_to_hi(), \".await\".to_string()),\n+                            (then_span.shrink_to_hi(), \".await\".to_string()),\n                             (exp_span.shrink_to_hi(), \".await\".to_string()),\n                         ],\n                         Applicability::MaybeIncorrect,\n@@ -1934,19 +1926,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     diag.help(\"consider `await`ing on both `Future`s\");\n                 }\n             },\n-            (_, Some(ty)) if same_type_modulo_infer(exp_found.expected, ty) => {\n+            (_, Some(ty)) if self.same_type_modulo_infer(exp_found.expected, ty) => {\n                 diag.span_suggestion_verbose(\n                     exp_span.shrink_to_hi(),\n                     \"consider `await`ing on the `Future`\",\n                     \".await\",\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n-            (Some(ty), _) if same_type_modulo_infer(ty, exp_found.found) => match cause.code() {\n-                ObligationCauseCode::Pattern { span: Some(span), .. }\n-                | ObligationCauseCode::IfExpression(box IfExpressionCause { then: span, .. }) => {\n+            (Some(ty), _) if self.same_type_modulo_infer(ty, exp_found.found) => match cause.code()\n+            {\n+                ObligationCauseCode::Pattern { span: Some(then_span), .. } => {\n                     diag.span_suggestion_verbose(\n-                        span.shrink_to_hi(),\n+                        then_span.shrink_to_hi(),\n+                        \"consider `await`ing on the `Future`\",\n+                        \".await\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n+                    let then_span = self.find_block_span_from_hir_id(*then_id);\n+                    diag.span_suggestion_verbose(\n+                        then_span.shrink_to_hi(),\n                         \"consider `await`ing on the `Future`\",\n                         \".await\",\n                         Applicability::MaybeIncorrect,\n@@ -1992,7 +1993,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 .iter()\n                 .filter(|field| field.vis.is_accessible_from(field.did, self.tcx))\n                 .map(|field| (field.name, field.ty(self.tcx, expected_substs)))\n-                .find(|(_, ty)| same_type_modulo_infer(*ty, exp_found.found))\n+                .find(|(_, ty)| self.same_type_modulo_infer(*ty, exp_found.found))\n             {\n                 if let ObligationCauseCode::Pattern { span: Some(span), .. } = *cause.code() {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n@@ -2057,7 +2058,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                         | (_, ty::Infer(_))\n                                         | (ty::Param(_), _)\n                                         | (ty::Infer(_), _) => {}\n-                                        _ if same_type_modulo_infer(exp_ty, found_ty) => {}\n+                                        _ if self.same_type_modulo_infer(exp_ty, found_ty) => {}\n                                         _ => show_suggestion = false,\n                                     };\n                                 }\n@@ -2179,7 +2180,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) {\n         let [expected_tup_elem] = expected_fields[..] else { return };\n \n-        if !same_type_modulo_infer(expected_tup_elem, found) {\n+        if !self.same_type_modulo_infer(expected_tup_elem, found) {\n             return;\n         }\n \n@@ -2647,6 +2648,76 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         span.is_desugaring(DesugaringKind::QuestionMark)\n             && self.tcx.is_diagnostic_item(sym::From, trait_def_id)\n     }\n+\n+    /// Structurally compares two types, modulo any inference variables.\n+    ///\n+    /// Returns `true` if two types are equal, or if one type is an inference variable compatible\n+    /// with the other type. A TyVar inference type is compatible with any type, and an IntVar or\n+    /// FloatVar inference type are compatible with themselves or their concrete types (Int and\n+    /// Float types, respectively). When comparing two ADTs, these rules apply recursively.\n+    pub fn same_type_modulo_infer(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+        let (a, b) = self.resolve_vars_if_possible((a, b));\n+        match (a.kind(), b.kind()) {\n+            (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b)) => {\n+                if def_a != def_b {\n+                    return false;\n+                }\n+\n+                substs_a\n+                    .types()\n+                    .zip(substs_b.types())\n+                    .all(|(a, b)| self.same_type_modulo_infer(a, b))\n+            }\n+            (&ty::FnDef(did_a, substs_a), &ty::FnDef(did_b, substs_b)) => {\n+                if did_a != did_b {\n+                    return false;\n+                }\n+\n+                substs_a\n+                    .types()\n+                    .zip(substs_b.types())\n+                    .all(|(a, b)| self.same_type_modulo_infer(a, b))\n+            }\n+            (&ty::Int(_) | &ty::Uint(_), &ty::Infer(ty::InferTy::IntVar(_)))\n+            | (\n+                &ty::Infer(ty::InferTy::IntVar(_)),\n+                &ty::Int(_) | &ty::Uint(_) | &ty::Infer(ty::InferTy::IntVar(_)),\n+            )\n+            | (&ty::Float(_), &ty::Infer(ty::InferTy::FloatVar(_)))\n+            | (\n+                &ty::Infer(ty::InferTy::FloatVar(_)),\n+                &ty::Float(_) | &ty::Infer(ty::InferTy::FloatVar(_)),\n+            )\n+            | (&ty::Infer(ty::InferTy::TyVar(_)), _)\n+            | (_, &ty::Infer(ty::InferTy::TyVar(_))) => true,\n+            (&ty::Ref(_, ty_a, mut_a), &ty::Ref(_, ty_b, mut_b)) => {\n+                mut_a == mut_b && self.same_type_modulo_infer(ty_a, ty_b)\n+            }\n+            (&ty::RawPtr(a), &ty::RawPtr(b)) => {\n+                a.mutbl == b.mutbl && self.same_type_modulo_infer(a.ty, b.ty)\n+            }\n+            (&ty::Slice(a), &ty::Slice(b)) => self.same_type_modulo_infer(a, b),\n+            (&ty::Array(a_ty, a_ct), &ty::Array(b_ty, b_ct)) => {\n+                self.same_type_modulo_infer(a_ty, b_ty) && a_ct == b_ct\n+            }\n+            (&ty::Tuple(a), &ty::Tuple(b)) => {\n+                if a.len() != b.len() {\n+                    return false;\n+                }\n+                std::iter::zip(a.iter(), b.iter()).all(|(a, b)| self.same_type_modulo_infer(a, b))\n+            }\n+            (&ty::FnPtr(a), &ty::FnPtr(b)) => {\n+                let a = a.skip_binder().inputs_and_output;\n+                let b = b.skip_binder().inputs_and_output;\n+                if a.len() != b.len() {\n+                    return false;\n+                }\n+                std::iter::zip(a.iter(), b.iter()).all(|(a, b)| self.same_type_modulo_infer(a, b))\n+            }\n+            // FIXME(compiler-errors): This needs to be generalized more\n+            _ => a == b,\n+        }\n+    }\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -2798,3 +2869,237 @@ impl TyCategory {\n         }\n     }\n }\n+\n+impl<'tcx> InferCtxt<'_, 'tcx> {\n+    /// Given a [`hir::Block`], get the span of its last expression or\n+    /// statement, peeling off any inner blocks.\n+    pub fn find_block_span(&self, block: &'tcx hir::Block<'tcx>) -> Span {\n+        let block = block.innermost_block();\n+        if let Some(expr) = &block.expr {\n+            expr.span\n+        } else if let Some(stmt) = block.stmts.last() {\n+            // possibly incorrect trailing `;` in the else arm\n+            stmt.span\n+        } else {\n+            // empty block; point at its entirety\n+            block.span\n+        }\n+    }\n+\n+    /// Given a [`hir::HirId`] for a block, get the span of its last expression\n+    /// or statement, peeling off any inner blocks.\n+    pub fn find_block_span_from_hir_id(&self, hir_id: hir::HirId) -> Span {\n+        match self.tcx.hir().get(hir_id) {\n+            hir::Node::Block(blk) => self.find_block_span(blk),\n+            // The parser was in a weird state if either of these happen, but\n+            // it's better not to panic.\n+            hir::Node::Expr(e) => e.span,\n+            _ => rustc_span::DUMMY_SP,\n+        }\n+    }\n+\n+    /// Be helpful when the user wrote `{... expr; }` and taking the `;` off\n+    /// is enough to fix the error.\n+    pub fn could_remove_semicolon(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> Option<(Span, StatementAsExpression)> {\n+        let blk = blk.innermost_block();\n+        // Do not suggest if we have a tail expr.\n+        if blk.expr.is_some() {\n+            return None;\n+        }\n+        let last_stmt = blk.stmts.last()?;\n+        let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n+            return None;\n+        };\n+        let last_expr_ty = self.in_progress_typeck_results?.borrow().expr_ty_opt(*last_expr)?;\n+        let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n+            _ if last_expr_ty.references_error() => return None,\n+            _ if self.same_type_modulo_infer(last_expr_ty, expected_ty) => {\n+                StatementAsExpression::CorrectType\n+            }\n+            (ty::Opaque(last_def_id, _), ty::Opaque(exp_def_id, _))\n+                if last_def_id == exp_def_id =>\n+            {\n+                StatementAsExpression::CorrectType\n+            }\n+            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n+                debug!(\n+                    \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n+                    last_def_id, last_bounds, exp_def_id, exp_bounds\n+                );\n+\n+                let last_local_id = last_def_id.as_local()?;\n+                let exp_local_id = exp_def_id.as_local()?;\n+\n+                match (\n+                    &self.tcx.hir().expect_item(last_local_id).kind,\n+                    &self.tcx.hir().expect_item(exp_local_id).kind,\n+                ) {\n+                    (\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n+                    ) if iter::zip(*last_bounds, *exp_bounds).all(|(left, right)| {\n+                        match (left, right) {\n+                            (\n+                                hir::GenericBound::Trait(tl, ml),\n+                                hir::GenericBound::Trait(tr, mr),\n+                            ) if tl.trait_ref.trait_def_id() == tr.trait_ref.trait_def_id()\n+                                && ml == mr =>\n+                            {\n+                                true\n+                            }\n+                            (\n+                                hir::GenericBound::LangItemTrait(langl, _, _, argsl),\n+                                hir::GenericBound::LangItemTrait(langr, _, _, argsr),\n+                            ) if langl == langr => {\n+                                // FIXME: consider the bounds!\n+                                debug!(\"{:?} {:?}\", argsl, argsr);\n+                                true\n+                            }\n+                            _ => false,\n+                        }\n+                    }) =>\n+                    {\n+                        StatementAsExpression::NeedsBoxing\n+                    }\n+                    _ => StatementAsExpression::CorrectType,\n+                }\n+            }\n+            _ => return None,\n+        };\n+        let span = if last_stmt.span.from_expansion() {\n+            let mac_call = rustc_span::source_map::original_sp(last_stmt.span, blk.span);\n+            self.tcx.sess.source_map().mac_call_stmt_semi_span(mac_call)?\n+        } else {\n+            last_stmt.span.with_lo(last_stmt.span.hi() - BytePos(1))\n+        };\n+        Some((span, needs_box))\n+    }\n+\n+    /// Suggest returning a local binding with a compatible type if the block\n+    /// has no return expression.\n+    pub fn consider_returning_binding(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut Diagnostic,\n+    ) -> bool {\n+        let blk = blk.innermost_block();\n+        // Do not suggest if we have a tail expr.\n+        if blk.expr.is_some() {\n+            return false;\n+        }\n+        let mut shadowed = FxHashSet::default();\n+        let mut candidate_idents = vec![];\n+        let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n+            if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n+                && let Some(pat_ty) = self\n+                    .in_progress_typeck_results\n+                    .and_then(|typeck_results| typeck_results.borrow().node_type_opt(*hir_id))\n+            {\n+                let pat_ty = self.resolve_vars_if_possible(pat_ty);\n+                if self.same_type_modulo_infer(pat_ty, expected_ty)\n+                    && !(pat_ty, expected_ty).references_error()\n+                    && shadowed.insert(ident.name)\n+                {\n+                    candidate_idents.push((*ident, pat_ty));\n+                }\n+            }\n+            true\n+        };\n+\n+        let hir = self.tcx.hir();\n+        for stmt in blk.stmts.iter().rev() {\n+            let hir::StmtKind::Local(local) = &stmt.kind else { continue; };\n+            local.pat.walk(&mut find_compatible_candidates);\n+        }\n+        match hir.find(hir.get_parent_node(blk.hir_id)) {\n+            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => {\n+                match hir.find(hir.get_parent_node(*hir_id)) {\n+                    Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n+                        pat.walk(&mut find_compatible_candidates);\n+                    }\n+                    Some(\n+                        hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n+                        | hir::Node::ImplItem(hir::ImplItem {\n+                            kind: hir::ImplItemKind::Fn(_, body),\n+                            ..\n+                        })\n+                        | hir::Node::TraitItem(hir::TraitItem {\n+                            kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n+                            ..\n+                        })\n+                        | hir::Node::Expr(hir::Expr {\n+                            kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n+                            ..\n+                        }),\n+                    ) => {\n+                        for param in hir.body(*body).params {\n+                            param.pat.walk(&mut find_compatible_candidates);\n+                        }\n+                    }\n+                    Some(hir::Node::Expr(hir::Expr {\n+                        kind:\n+                            hir::ExprKind::If(\n+                                hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n+                                then_block,\n+                                _,\n+                            ),\n+                        ..\n+                    })) if then_block.hir_id == *hir_id => {\n+                        let_.pat.walk(&mut find_compatible_candidates);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        match &candidate_idents[..] {\n+            [(ident, _ty)] => {\n+                let sm = self.tcx.sess.source_map();\n+                if let Some(stmt) = blk.stmts.last() {\n+                    let stmt_span = sm.stmt_span(stmt.span, blk.span);\n+                    let sugg = if sm.is_multiline(blk.span)\n+                        && let Some(spacing) = sm.indentation_before(stmt_span)\n+                    {\n+                        format!(\"\\n{spacing}{ident}\")\n+                    } else {\n+                        format!(\" {ident}\")\n+                    };\n+                    err.span_suggestion_verbose(\n+                        stmt_span.shrink_to_hi(),\n+                        format!(\"consider returning the local binding `{ident}`\"),\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    let sugg = if sm.is_multiline(blk.span)\n+                        && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n+                    {\n+                        format!(\"\\n{spacing}    {ident}\\n{spacing}\")\n+                    } else {\n+                        format!(\" {ident} \")\n+                    };\n+                    let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n+                    err.span_suggestion_verbose(\n+                        sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n+                        format!(\"consider returning the local binding `{ident}`\"),\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                true\n+            }\n+            values if (1..3).contains(&values.len()) => {\n+                let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n+                err.span_note(spans, \"consider returning one of these bindings\");\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+}"}, {"sha": "c55971557fac1967551d819554b9ffc0e8d947c8", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=92bebac0b93011212c48a12f068a16b19376b55a", "patch": "@@ -351,7 +351,7 @@ pub enum ObligationCauseCode<'tcx> {\n     ConstPatternStructural,\n \n     /// Computing common supertype in an if expression\n-    IfExpression(Box<IfExpressionCause>),\n+    IfExpression(Box<IfExpressionCause<'tcx>>),\n \n     /// Computing common supertype of an if expression with no else counter-part\n     IfExpressionWithNoElse,\n@@ -488,22 +488,27 @@ impl<'tcx> ty::Lift<'tcx> for StatementAsExpression {\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct MatchExpressionArmCause<'tcx> {\n+    pub arm_block_id: Option<hir::HirId>,\n+    pub arm_ty: Ty<'tcx>,\n     pub arm_span: Span,\n+    pub prior_arm_block_id: Option<hir::HirId>,\n+    pub prior_arm_ty: Ty<'tcx>,\n+    pub prior_arm_span: Span,\n     pub scrut_span: Span,\n-    pub semi_span: Option<(Span, StatementAsExpression)>,\n     pub source: hir::MatchSource,\n     pub prior_arms: Vec<Span>,\n-    pub last_ty: Ty<'tcx>,\n     pub scrut_hir_id: hir::HirId,\n     pub opt_suggest_box_span: Option<Span>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct IfExpressionCause {\n-    pub then: Span,\n-    pub else_sp: Span,\n-    pub outer: Option<Span>,\n-    pub semicolon: Option<(Span, StatementAsExpression)>,\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Lift, TypeFoldable, TypeVisitable)]\n+pub struct IfExpressionCause<'tcx> {\n+    pub then_id: hir::HirId,\n+    pub else_id: hir::HirId,\n+    pub then_ty: Ty<'tcx>,\n+    pub else_ty: Ty<'tcx>,\n+    pub outer_span: Option<Span>,\n     pub opt_suggest_box_span: Option<Span>,\n }\n "}, {"sha": "7fbd57ac7354aa2691dfec008de1a25618e355ea", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=92bebac0b93011212c48a12f068a16b19376b55a", "patch": "@@ -130,7 +130,6 @@ impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceConstDestructData<N> {\n // Lift implementations\n \n TrivialTypeTraversalAndLiftImpls! {\n-    super::IfExpressionCause,\n     super::ImplSourceDiscriminantKindData,\n     super::ImplSourcePointeeData,\n }"}, {"sha": "2f92a77a7957d886185adb768ea2c4f09ef8671b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=92bebac0b93011212c48a12f068a16b19376b55a", "patch": "@@ -22,7 +22,6 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::GenericParam;\n use rustc_hir::Item;\n use rustc_hir::Node;\n-use rustc_infer::infer::error_reporting::same_type_modulo_infer;\n use rustc_infer::traits::TraitEngine;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n@@ -640,7 +639,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                             if expected.len() == 1 { \"\" } else { \"s\" },\n                                         )\n                                     );\n-                                } else if !same_type_modulo_infer(given_ty, expected_ty) {\n+                                } else if !self.same_type_modulo_infer(given_ty, expected_ty) {\n                                     // Print type mismatch\n                                     let (expected_args, given_args) =\n                                         self.cmp(given_ty, expected_ty);"}, {"sha": "f629f6a0099d7a86d19cbd2f1c604b7b325c1024", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 68, "deletions": 101, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=92bebac0b93011212c48a12f068a16b19376b55a", "patch": "@@ -9,7 +9,6 @@ use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n-    StatementAsExpression,\n };\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -75,8 +74,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let mut other_arms = vec![]; // Used only for diagnostics.\n-        let mut prior_arm_ty = None;\n-        for (i, arm) in arms.iter().enumerate() {\n+        let mut prior_arm = None;\n+        for arm in arms {\n             if let Some(g) = &arm.guard {\n                 self.diverges.set(Diverges::Maybe);\n                 match g {\n@@ -96,21 +95,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let opt_suggest_box_span = self.opt_suggest_box_span(arm_ty, orig_expected);\n \n-            let (arm_span, semi_span) =\n-                self.get_appropriate_arm_semicolon_removal_span(&arms, i, prior_arm_ty, arm_ty);\n-            let (span, code) = match i {\n+            let (arm_block_id, arm_span) = if let hir::ExprKind::Block(blk, _) = arm.body.kind {\n+                (Some(blk.hir_id), self.find_block_span(blk))\n+            } else {\n+                (None, arm.body.span)\n+            };\n+\n+            let (span, code) = match prior_arm {\n                 // The reason for the first arm to fail is not that the match arms diverge,\n                 // but rather that there's a prior obligation that doesn't hold.\n-                0 => (arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id)),\n-                _ => (\n+                None => (arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id)),\n+                Some((prior_arm_block_id, prior_arm_ty, prior_arm_span)) => (\n                     expr.span,\n                     ObligationCauseCode::MatchExpressionArm(Box::new(MatchExpressionArmCause {\n+                        arm_block_id,\n                         arm_span,\n+                        arm_ty,\n+                        prior_arm_block_id,\n+                        prior_arm_ty,\n+                        prior_arm_span,\n                         scrut_span: scrut.span,\n-                        semi_span,\n                         source: match_src,\n                         prior_arms: other_arms.clone(),\n-                        last_ty: prior_arm_ty.unwrap(),\n                         scrut_hir_id: scrut.hir_id,\n                         opt_suggest_box_span,\n                     })),\n@@ -139,7 +145,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let ret_ty = ret_coercion.borrow().expected_ty();\n                             let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n                             self.can_coerce(arm_ty, ret_ty)\n-                                && prior_arm_ty.map_or(true, |t| self.can_coerce(t, ret_ty))\n+                                && prior_arm.map_or(true, |(_, t, _)| self.can_coerce(t, ret_ty))\n                                 // The match arms need to unify for the case of `impl Trait`.\n                                 && !matches!(ret_ty.kind(), ty::Opaque(..))\n                         }\n@@ -181,7 +187,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if other_arms.len() > 5 {\n                 other_arms.remove(0);\n             }\n-            prior_arm_ty = Some(arm_ty);\n+\n+            prior_arm = Some((arm_block_id, arm_ty, arm_span));\n         }\n \n         // If all of the arms in the `match` diverge,\n@@ -207,28 +214,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match_ty\n     }\n \n-    fn get_appropriate_arm_semicolon_removal_span(\n-        &self,\n-        arms: &'tcx [hir::Arm<'tcx>],\n-        i: usize,\n-        prior_arm_ty: Option<Ty<'tcx>>,\n-        arm_ty: Ty<'tcx>,\n-    ) -> (Span, Option<(Span, StatementAsExpression)>) {\n-        let arm = &arms[i];\n-        let (arm_span, mut semi_span) = if let hir::ExprKind::Block(blk, _) = &arm.body.kind {\n-            self.find_block_span(blk, prior_arm_ty)\n-        } else {\n-            (arm.body.span, None)\n-        };\n-        if semi_span.is_none() && i > 0 {\n-            if let hir::ExprKind::Block(blk, _) = &arms[i - 1].body.kind {\n-                let (_, semi_span_prev) = self.find_block_span(blk, Some(arm_ty));\n-                semi_span = semi_span_prev;\n-            }\n-        }\n-        (arm_span, semi_span)\n-    }\n-\n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n     fn warn_arms_when_scrutinee_diverges(&self, arms: &'tcx [hir::Arm<'tcx>]) {\n@@ -313,7 +298,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         else_ty: Ty<'tcx>,\n         opt_suggest_box_span: Option<Span>,\n     ) -> ObligationCause<'tcx> {\n-        let mut outer_sp = if self.tcx.sess.source_map().is_multiline(span) {\n+        let mut outer_span = if self.tcx.sess.source_map().is_multiline(span) {\n             // The `if`/`else` isn't in one line in the output, include some context to make it\n             // clear it is an if/else expression:\n             // ```\n@@ -339,69 +324,67 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             None\n         };\n \n-        let mut remove_semicolon = None;\n-        let error_sp = if let ExprKind::Block(block, _) = &else_expr.kind {\n-            let (error_sp, semi_sp) = self.find_block_span(block, Some(then_ty));\n-            remove_semicolon = semi_sp;\n-            if block.expr.is_none() && block.stmts.is_empty() {\n-                // Avoid overlapping spans that aren't as readable:\n-                // ```\n-                // 2 |        let x = if true {\n-                //   |   _____________-\n-                // 3 |  |         3\n-                //   |  |         - expected because of this\n-                // 4 |  |     } else {\n-                //   |  |____________^\n-                // 5 | ||\n-                // 6 | ||     };\n-                //   | ||     ^\n-                //   | ||_____|\n-                //   | |______if and else have incompatible types\n-                //   |        expected integer, found `()`\n-                // ```\n-                // by not pointing at the entire expression:\n-                // ```\n-                // 2 |       let x = if true {\n-                //   |               ------- `if` and `else` have incompatible types\n-                // 3 |           3\n-                //   |           - expected because of this\n-                // 4 |       } else {\n-                //   |  ____________^\n-                // 5 | |\n-                // 6 | |     };\n-                //   | |_____^ expected integer, found `()`\n-                // ```\n-                if outer_sp.is_some() {\n-                    outer_sp = Some(self.tcx.sess.source_map().guess_head_span(span));\n-                }\n+        let (error_sp, else_id) = if let ExprKind::Block(block, _) = &else_expr.kind {\n+            let block = block.innermost_block();\n+\n+            // Avoid overlapping spans that aren't as readable:\n+            // ```\n+            // 2 |        let x = if true {\n+            //   |   _____________-\n+            // 3 |  |         3\n+            //   |  |         - expected because of this\n+            // 4 |  |     } else {\n+            //   |  |____________^\n+            // 5 | ||\n+            // 6 | ||     };\n+            //   | ||     ^\n+            //   | ||_____|\n+            //   | |______if and else have incompatible types\n+            //   |        expected integer, found `()`\n+            // ```\n+            // by not pointing at the entire expression:\n+            // ```\n+            // 2 |       let x = if true {\n+            //   |               ------- `if` and `else` have incompatible types\n+            // 3 |           3\n+            //   |           - expected because of this\n+            // 4 |       } else {\n+            //   |  ____________^\n+            // 5 | |\n+            // 6 | |     };\n+            //   | |_____^ expected integer, found `()`\n+            // ```\n+            if block.expr.is_none() && block.stmts.is_empty()\n+                && let Some(outer_span) = &mut outer_span\n+            {\n+                *outer_span = self.tcx.sess.source_map().guess_head_span(*outer_span);\n             }\n-            error_sp\n+\n+            (self.find_block_span(block), block.hir_id)\n         } else {\n-            // shouldn't happen unless the parser has done something weird\n-            else_expr.span\n+            (else_expr.span, else_expr.hir_id)\n         };\n \n-        // Compute `Span` of `then` part of `if`-expression.\n-        let then_sp = if let ExprKind::Block(block, _) = &then_expr.kind {\n-            let (then_sp, semi_sp) = self.find_block_span(block, Some(else_ty));\n-            remove_semicolon = remove_semicolon.or(semi_sp);\n+        let then_id = if let ExprKind::Block(block, _) = &then_expr.kind {\n+            let block = block.innermost_block();\n+            // Exclude overlapping spans\n             if block.expr.is_none() && block.stmts.is_empty() {\n-                outer_sp = None; // same as in `error_sp`; cleanup output\n+                outer_span = None;\n             }\n-            then_sp\n+            block.hir_id\n         } else {\n-            // shouldn't happen unless the parser has done something weird\n-            then_expr.span\n+            then_expr.hir_id\n         };\n \n         // Finally construct the cause:\n         self.cause(\n             error_sp,\n             ObligationCauseCode::IfExpression(Box::new(IfExpressionCause {\n-                then: then_sp,\n-                else_sp: error_sp,\n-                outer: outer_sp,\n-                semicolon: remove_semicolon,\n+                else_id,\n+                then_id,\n+                then_ty,\n+                else_ty,\n+                outer_span,\n                 opt_suggest_box_span,\n             })),\n         )\n@@ -482,22 +465,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn find_block_span(\n-        &self,\n-        block: &'tcx hir::Block<'tcx>,\n-        expected_ty: Option<Ty<'tcx>>,\n-    ) -> (Span, Option<(Span, StatementAsExpression)>) {\n-        if let Some(expr) = &block.expr {\n-            (expr.span, None)\n-        } else if let Some(stmt) = block.stmts.last() {\n-            // possibly incorrect trailing `;` in the else arm\n-            (stmt.span, expected_ty.and_then(|ty| self.could_remove_semicolon(block, ty)))\n-        } else {\n-            // empty block; point at its entirety\n-            (block.span, None)\n-        }\n-    }\n-\n     // When we have a `match` as a tail expression in a `fn` with a returned `impl Trait`\n     // we check if the different arms would work with boxed trait objects instead and\n     // provide a structured suggestion in that case."}, {"sha": "21b3c9063a78a85331e4caf8ed7a5c252efce94f", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 82, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=92bebac0b93011212c48a12f068a16b19376b55a", "patch": "@@ -30,17 +30,15 @@ use rustc_middle::ty::{\n };\n use rustc_session::lint;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::source_map::{original_sp, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{self, BytePos, Span};\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n-    self, ObligationCause, ObligationCauseCode, StatementAsExpression, TraitEngine, TraitEngineExt,\n+    self, ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt,\n };\n \n use std::collections::hash_map::Entry;\n-use std::iter;\n use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -1059,84 +1057,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ));\n     }\n \n-    pub(in super::super) fn could_remove_semicolon(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected_ty: Ty<'tcx>,\n-    ) -> Option<(Span, StatementAsExpression)> {\n-        // Be helpful when the user wrote `{... expr;}` and\n-        // taking the `;` off is enough to fix the error.\n-        let last_stmt = blk.stmts.last()?;\n-        let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n-            return None;\n-        };\n-        let last_expr_ty = self.node_ty(last_expr.hir_id);\n-        let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n-            (ty::Opaque(last_def_id, _), ty::Opaque(exp_def_id, _))\n-                if last_def_id == exp_def_id =>\n-            {\n-                StatementAsExpression::CorrectType\n-            }\n-            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n-                debug!(\n-                    \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n-                    last_def_id, last_bounds, exp_def_id, exp_bounds\n-                );\n-\n-                let last_local_id = last_def_id.as_local()?;\n-                let exp_local_id = exp_def_id.as_local()?;\n-\n-                match (\n-                    &self.tcx.hir().expect_item(last_local_id).kind,\n-                    &self.tcx.hir().expect_item(exp_local_id).kind,\n-                ) {\n-                    (\n-                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n-                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n-                    ) if iter::zip(*last_bounds, *exp_bounds).all(|(left, right)| {\n-                        match (left, right) {\n-                            (\n-                                hir::GenericBound::Trait(tl, ml),\n-                                hir::GenericBound::Trait(tr, mr),\n-                            ) if tl.trait_ref.trait_def_id() == tr.trait_ref.trait_def_id()\n-                                && ml == mr =>\n-                            {\n-                                true\n-                            }\n-                            (\n-                                hir::GenericBound::LangItemTrait(langl, _, _, argsl),\n-                                hir::GenericBound::LangItemTrait(langr, _, _, argsr),\n-                            ) if langl == langr => {\n-                                // FIXME: consider the bounds!\n-                                debug!(\"{:?} {:?}\", argsl, argsr);\n-                                true\n-                            }\n-                            _ => false,\n-                        }\n-                    }) =>\n-                    {\n-                        StatementAsExpression::NeedsBoxing\n-                    }\n-                    _ => StatementAsExpression::CorrectType,\n-                }\n-            }\n-            _ => StatementAsExpression::CorrectType,\n-        };\n-        if (matches!(last_expr_ty.kind(), ty::Error(_))\n-            || self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err())\n-            && matches!(needs_box, StatementAsExpression::CorrectType)\n-        {\n-            return None;\n-        }\n-        let span = if last_stmt.span.from_expansion() {\n-            let mac_call = original_sp(last_stmt.span, blk.span);\n-            self.tcx.sess.source_map().mac_call_stmt_semi_span(mac_call)?\n-        } else {\n-            last_stmt.span.with_lo(last_stmt.span.hi() - BytePos(1))\n-        };\n-        Some((span, needs_box))\n-    }\n-\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     #[instrument(skip(self, span), level = \"debug\")]"}, {"sha": "3e6ff72204f4c49b6c02349d8588058d0ccd4566", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 115, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bebac0b93011212c48a12f068a16b19376b55a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=92bebac0b93011212c48a12f068a16b19376b55a", "patch": "@@ -3,7 +3,6 @@ use crate::astconv::AstConv;\n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n \n use rustc_ast::util::parser::ExprPrecedence;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n@@ -14,7 +13,7 @@ use rustc_hir::{\n use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Binder, IsSuggestable, Subst, ToPredicate, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, Binder, IsSuggestable, Subst, ToPredicate, Ty};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -904,117 +903,4 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             false\n         }\n     }\n-\n-    pub(crate) fn consider_returning_binding(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected_ty: Ty<'tcx>,\n-        err: &mut Diagnostic,\n-    ) {\n-        let mut shadowed = FxHashSet::default();\n-        let mut candidate_idents = vec![];\n-        let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n-            if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n-                && let Some(pat_ty) = self.typeck_results.borrow().node_type_opt(*hir_id)\n-            {\n-                let pat_ty = self.resolve_vars_if_possible(pat_ty);\n-                if self.can_coerce(pat_ty, expected_ty)\n-                    && !(pat_ty, expected_ty).references_error()\n-                    && shadowed.insert(ident.name)\n-                {\n-                    candidate_idents.push((*ident, pat_ty));\n-                }\n-            }\n-            true\n-        };\n-\n-        let hir = self.tcx.hir();\n-        for stmt in blk.stmts.iter().rev() {\n-            let StmtKind::Local(local) = &stmt.kind else { continue; };\n-            local.pat.walk(&mut find_compatible_candidates);\n-        }\n-        match hir.find(hir.get_parent_node(blk.hir_id)) {\n-            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => {\n-                match hir.find(hir.get_parent_node(*hir_id)) {\n-                    Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n-                        pat.walk(&mut find_compatible_candidates);\n-                    }\n-                    Some(\n-                        hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n-                        | hir::Node::ImplItem(hir::ImplItem {\n-                            kind: hir::ImplItemKind::Fn(_, body),\n-                            ..\n-                        })\n-                        | hir::Node::TraitItem(hir::TraitItem {\n-                            kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n-                            ..\n-                        })\n-                        | hir::Node::Expr(hir::Expr {\n-                            kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n-                            ..\n-                        }),\n-                    ) => {\n-                        for param in hir.body(*body).params {\n-                            param.pat.walk(&mut find_compatible_candidates);\n-                        }\n-                    }\n-                    Some(hir::Node::Expr(hir::Expr {\n-                        kind:\n-                            hir::ExprKind::If(\n-                                hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n-                                then_block,\n-                                _,\n-                            ),\n-                        ..\n-                    })) if then_block.hir_id == *hir_id => {\n-                        let_.pat.walk(&mut find_compatible_candidates);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        match &candidate_idents[..] {\n-            [(ident, _ty)] => {\n-                let sm = self.tcx.sess.source_map();\n-                if let Some(stmt) = blk.stmts.last() {\n-                    let stmt_span = sm.stmt_span(stmt.span, blk.span);\n-                    let sugg = if sm.is_multiline(blk.span)\n-                        && let Some(spacing) = sm.indentation_before(stmt_span)\n-                    {\n-                        format!(\"\\n{spacing}{ident}\")\n-                    } else {\n-                        format!(\" {ident}\")\n-                    };\n-                    err.span_suggestion_verbose(\n-                        stmt_span.shrink_to_hi(),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    let sugg = if sm.is_multiline(blk.span)\n-                        && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n-                    {\n-                        format!(\"\\n{spacing}    {ident}\\n{spacing}\")\n-                    } else {\n-                        format!(\" {ident} \")\n-                    };\n-                    let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n-                    err.span_suggestion_verbose(\n-                        sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            values if (1..3).contains(&values.len()) => {\n-                let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n-                err.span_note(spans, \"consider returning one of these bindings\");\n-            }\n-            _ => {}\n-        }\n-    }\n }"}, {"sha": "e5887689690e76fd5066d2193ae5613782cfe0b2", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/92bebac0b93011212c48a12f068a16b19376b55a/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92bebac0b93011212c48a12f068a16b19376b55a/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr?ref=92bebac0b93011212c48a12f068a16b19376b55a", "patch": "@@ -18,14 +18,6 @@ LL | |             break 0u8;\n LL | |         };\n    | |_________- enclosing `async` block\n \n-error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n-  --> $DIR/async-block-control-flow-static-semantics.rs:26:39\n-   |\n-LL |     let _: &dyn Future<Output = ()> = &block;\n-   |                                       ^^^^^^ expected `()`, found `u8`\n-   |\n-   = note: required for the cast from `impl Future<Output = u8>` to the object type `dyn Future<Output = ()>`\n-\n error[E0308]: mismatched types\n   --> $DIR/async-block-control-flow-static-semantics.rs:21:58\n    |\n@@ -40,7 +32,7 @@ LL | | }\n    | |_^ expected `u8`, found `()`\n \n error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n-  --> $DIR/async-block-control-flow-static-semantics.rs:17:39\n+  --> $DIR/async-block-control-flow-static-semantics.rs:26:39\n    |\n LL |     let _: &dyn Future<Output = ()> = &block;\n    |                                       ^^^^^^ expected `()`, found `u8`\n@@ -55,6 +47,14 @@ LL | fn return_targets_async_block_not_fn() -> u8 {\n    |    |\n    |    implicitly returns `()` as its body has no tail or `return` expression\n \n+error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n+  --> $DIR/async-block-control-flow-static-semantics.rs:17:39\n+   |\n+LL |     let _: &dyn Future<Output = ()> = &block;\n+   |                                       ^^^^^^ expected `()`, found `u8`\n+   |\n+   = note: required for the cast from `impl Future<Output = u8>` to the object type `dyn Future<Output = ()>`\n+\n error[E0308]: mismatched types\n   --> $DIR/async-block-control-flow-static-semantics.rs:47:44\n    |"}, {"sha": "a9284535e4dc4221a6c1faf198fc113706f2ec5c", "filename": "src/test/ui/issues/issue-59494.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92bebac0b93011212c48a12f068a16b19376b55a/src%2Ftest%2Fui%2Fissues%2Fissue-59494.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92bebac0b93011212c48a12f068a16b19376b55a/src%2Ftest%2Fui%2Fissues%2Fissue-59494.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59494.stderr?ref=92bebac0b93011212c48a12f068a16b19376b55a", "patch": "@@ -7,8 +7,6 @@ LL |     let t8 = t8n(t7, t7p(f, g));\n    |              required by a bound introduced by this call\n    |\n    = help: the trait `Fn<(_,)>` is not implemented for `impl Fn(((_, _), _))`\n-   = note: expected a closure with arguments `(((_, _), _),)`\n-              found a closure with arguments `(_,)`\n note: required by a bound in `t8n`\n   --> $DIR/issue-59494.rs:5:45\n    |"}, {"sha": "4fabc411abcbe8c8b4e16935d4853079194a6018", "filename": "src/test/ui/suggestions/return-bindings.fixed", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aec458b54f1ddcd5aada9a8e83d79348e2a3be41/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/aec458b54f1ddcd5aada9a8e83d79348e2a3be41/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.fixed?ref=aec458b54f1ddcd5aada9a8e83d79348e2a3be41", "patch": "@@ -1,23 +0,0 @@\n-// run-rustfix\n-\n-#![allow(unused)]\n-\n-fn a(i: i32) -> i32 { i }\n-//~^ ERROR mismatched types\n-\n-fn b(opt_str: Option<String>) {\n-    let s: String = if let Some(s) = opt_str {\n-        s\n-    //~^ ERROR mismatched types\n-    } else {\n-        String::new()\n-    };\n-}\n-\n-fn c() -> Option<i32> {\n-    //~^ ERROR mismatched types\n-    let x = Some(1);\n-    x\n-}\n-\n-fn main() {}"}, {"sha": "fa1bad37699f36fcba63fc02407d3c7af87fd00a", "filename": "src/test/ui/suggestions/return-bindings.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/92bebac0b93011212c48a12f068a16b19376b55a/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bebac0b93011212c48a12f068a16b19376b55a/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs?ref=92bebac0b93011212c48a12f068a16b19376b55a", "patch": "@@ -1,5 +1,3 @@\n-// run-rustfix\n-\n #![allow(unused)]\n \n fn a(i: i32) -> i32 {}\n@@ -18,4 +16,36 @@ fn c() -> Option<i32> {\n     let x = Some(1);\n }\n \n+fn d(opt_str: Option<String>) {\n+    let s: String = if let Some(s) = opt_str {\n+        //~^ ERROR mismatched types\n+    } else {\n+        String::new()\n+    };\n+}\n+\n+fn d2(opt_str: Option<String>) {\n+    let s = if let Some(s) = opt_str {\n+    } else {\n+        String::new()\n+        //~^ ERROR `if` and `else` have incompatible types\n+    };\n+}\n+\n+fn e(opt_str: Option<String>) {\n+    let s: String = match opt_str {\n+        Some(s) => {}\n+        //~^ ERROR mismatched types\n+        None => String::new(),\n+    };\n+}\n+\n+fn e2(opt_str: Option<String>) {\n+    let s = match opt_str {\n+        Some(s) => {}\n+        None => String::new(),\n+        //~^ ERROR `match` arms have incompatible types\n+    };\n+}\n+\n fn main() {}"}, {"sha": "c14fb336773d1f79791c5ebd88cc0909c5a438dd", "filename": "src/test/ui/suggestions/return-bindings.stderr", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/92bebac0b93011212c48a12f068a16b19376b55a/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92bebac0b93011212c48a12f068a16b19376b55a/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr?ref=92bebac0b93011212c48a12f068a16b19376b55a", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/return-bindings.rs:5:17\n+  --> $DIR/return-bindings.rs:3:17\n    |\n LL | fn a(i: i32) -> i32 {}\n    |    -            ^^^ expected `i32`, found `()`\n@@ -12,7 +12,7 @@ LL | fn a(i: i32) -> i32 { i }\n    |                       +\n \n error[E0308]: mismatched types\n-  --> $DIR/return-bindings.rs:9:46\n+  --> $DIR/return-bindings.rs:7:46\n    |\n LL |       let s: String = if let Some(s) = opt_str {\n    |  ______________________________________________^\n@@ -28,7 +28,7 @@ LL ~\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/return-bindings.rs:16:11\n+  --> $DIR/return-bindings.rs:14:11\n    |\n LL | fn c() -> Option<i32> {\n    |    -      ^^^^^^^^^^^ expected enum `Option`, found `()`\n@@ -43,6 +43,68 @@ LL ~     let x = Some(1);\n LL +     x\n    |\n \n-error: aborting due to 3 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/return-bindings.rs:20:46\n+   |\n+LL |       let s: String = if let Some(s) = opt_str {\n+   |  ______________________________________________^\n+LL | |\n+LL | |     } else {\n+   | |_____^ expected struct `String`, found `()`\n+   |\n+help: consider returning the local binding `s`\n+   |\n+LL ~     let s: String = if let Some(s) = opt_str {\n+LL +         s\n+LL ~\n+   |\n+\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/return-bindings.rs:30:9\n+   |\n+LL |       let s = if let Some(s) = opt_str {\n+   |  ______________________________________-\n+LL | |     } else {\n+   | |_____- expected because of this\n+LL |           String::new()\n+   |           ^^^^^^^^^^^^^ expected `()`, found struct `String`\n+   |\n+help: consider returning the local binding `s`\n+   |\n+LL ~     let s = if let Some(s) = opt_str {\n+LL +         s\n+LL ~     } else {\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/return-bindings.rs:37:20\n+   |\n+LL |         Some(s) => {}\n+   |                    ^^ expected struct `String`, found `()`\n+   |\n+help: consider returning the local binding `s`\n+   |\n+LL |         Some(s) => { s }\n+   |                      +\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/return-bindings.rs:46:17\n+   |\n+LL |       let s = match opt_str {\n+   |  _____________-\n+LL | |         Some(s) => {}\n+   | |                    -- this is found to be of type `()`\n+LL | |         None => String::new(),\n+   | |                 ^^^^^^^^^^^^^ expected `()`, found struct `String`\n+LL | |\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+help: consider returning the local binding `s`\n+   |\n+LL |         Some(s) => { s }\n+   |                      +\n+\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}