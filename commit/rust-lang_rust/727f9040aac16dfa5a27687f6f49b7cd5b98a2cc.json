{"sha": "727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyN2Y5MDQwYWFjMTZkZmE1YTI3Njg3ZjZmNDliN2NkNWI5OGEyY2M=", "commit": {"author": {"name": "Timoth\u00e9e Delabrouille", "email": "timothee.delabrouille@musicworldmedia.com", "date": "2021-04-25T16:17:11Z"}, "committer": {"name": "Timoth\u00e9e Delabrouille", "email": "timothee.delabrouille@musicworldmedia.com", "date": "2021-04-27T08:29:58Z"}, "message": "cfg taken out of Attributes, put in Item\n\ncheck item.is_fake() instead of self_id.is_some()\n\nRemove empty branching in Attributes::from_ast\n\ndiverse small refacto after Josha review\n\ncfg computation moved in merge_attrs\n\nrefacto use from_ast twice for coherence\n\ntake cfg out of Attributes and move it to Item", "tree": {"sha": "a2e1264f50e4c6bc6e626ad3371a62f624197ef4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2e1264f50e4c6bc6e626ad3371a62f624197ef4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "html_url": "https://github.com/rust-lang/rust/commit/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/comments", "author": null, "committer": null, "parents": [{"sha": "b4f1dfd2c57985a4cbb74fb34073ba04fd6f5f63", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4f1dfd2c57985a4cbb74fb34073ba04fd6f5f63", "html_url": "https://github.com/rust-lang/rust/commit/b4f1dfd2c57985a4cbb74fb34073ba04fd6f5f63"}], "stats": {"total": 189, "additions": 104, "deletions": 85}, "files": [{"sha": "92eb6214f79fed7133458e74b080eb98fe115fd6", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "patch": "@@ -126,6 +126,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 synthetic: true,\n                 blanket_impl: None,\n             }),\n+            cfg: None,\n         })\n     }\n "}, {"sha": "3a14a1d23f2d4186602b741c340e0806846db583", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "patch": "@@ -128,6 +128,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         synthetic: false,\n                         blanket_impl: Some(trait_ref.self_ty().clean(self.cx)),\n                     }),\n+                    cfg: None,\n                 });\n             }\n         }"}, {"sha": "674bf1a5814e19c6d29b0458e02365542ddba9df", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "patch": "@@ -1,6 +1,7 @@\n //! Support for inlining external documentation into the current AST.\n \n use std::iter::once;\n+use std::sync::Arc;\n \n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n@@ -15,7 +16,7 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n-use crate::clean::{self, Attributes, GetDefId, ToSource};\n+use crate::clean::{self, Attributes, AttributesExt, GetDefId, ToSource};\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n \n@@ -120,11 +121,16 @@ crate fn try_inline(\n         _ => return None,\n     };\n \n-    let target_attrs = load_attrs(cx, did);\n-    let attrs = box merge_attrs(cx, Some(parent_module), target_attrs, attrs_clone);\n-\n+    let (attrs, cfg) = merge_attrs(cx, Some(parent_module), load_attrs(cx, did), attrs_clone);\n     cx.inlined.insert(did);\n-    ret.push(clean::Item::from_def_id_and_attrs_and_parts(did, Some(name), kind, attrs, cx));\n+    ret.push(clean::Item::from_def_id_and_attrs_and_parts(\n+        did,\n+        Some(name),\n+        kind,\n+        box attrs,\n+        cx,\n+        cfg,\n+    ));\n     Some(ret)\n }\n \n@@ -288,22 +294,24 @@ fn merge_attrs(\n     parent_module: Option<DefId>,\n     old_attrs: Attrs<'_>,\n     new_attrs: Option<Attrs<'_>>,\n-) -> clean::Attributes {\n+) -> (clean::Attributes, Option<Arc<clean::cfg::Cfg>>) {\n     // NOTE: If we have additional attributes (from a re-export),\n     // always insert them first. This ensure that re-export\n     // doc comments show up before the original doc comments\n     // when we render them.\n     if let Some(inner) = new_attrs {\n-        if let Some(new_id) = parent_module {\n-            let diag = cx.sess().diagnostic();\n-            Attributes::from_ast(diag, old_attrs, Some((inner, new_id)))\n-        } else {\n-            let mut both = inner.to_vec();\n-            both.extend_from_slice(old_attrs);\n-            both.clean(cx)\n-        }\n+        let mut both = inner.to_vec();\n+        both.extend_from_slice(old_attrs);\n+        (\n+            if let Some(new_id) = parent_module {\n+                Attributes::from_ast(old_attrs, Some((inner, new_id)))\n+            } else {\n+                Attributes::from_ast(&both, None)\n+            },\n+            both.cfg(cx.sess().diagnostic()),\n+        )\n     } else {\n-        old_attrs.clean(cx)\n+        (old_attrs.clean(cx), old_attrs.cfg(cx.sess().diagnostic()))\n     }\n }\n \n@@ -414,8 +422,8 @@ crate fn build_impl(\n \n     debug!(\"build_impl: impl {:?} for {:?}\", trait_.def_id(), for_.def_id());\n \n-    let attrs = box merge_attrs(cx, parent_module.into(), load_attrs(cx, did), attrs);\n-    debug!(\"merged_attrs={:?}\", attrs);\n+    let (merged_attrs, cfg) = merge_attrs(cx, parent_module.into(), load_attrs(cx, did), attrs);\n+    debug!(\"merged_attrs={:?}\", merged_attrs);\n \n     ret.push(clean::Item::from_def_id_and_attrs_and_parts(\n         did,\n@@ -432,8 +440,9 @@ crate fn build_impl(\n             synthetic: false,\n             blanket_impl: None,\n         }),\n-        attrs,\n+        box merged_attrs,\n         cx,\n+        cfg,\n     ));\n }\n \n@@ -479,6 +488,7 @@ fn build_module(\n                         },\n                         true,\n                     )),\n+                    cfg: None,\n                 });\n             } else if let Some(i) = try_inline(cx, did, item.res, item.ident.name, None, visited) {\n                 items.extend(i)"}, {"sha": "60c5d68b7a0b66b0f3dc4580e7c6956bcd4fbc83", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "patch": "@@ -122,8 +122,8 @@ impl Clean<Item> for doctree::Module<'_> {\n }\n \n impl Clean<Attributes> for [ast::Attribute] {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Attributes {\n-        Attributes::from_ast(cx.sess().diagnostic(), self, None)\n+    fn clean(&self, _cx: &mut DocContext<'_>) -> Attributes {\n+        Attributes::from_ast(self, None)\n     }\n }\n \n@@ -1998,13 +1998,15 @@ fn clean_extern_crate(\n             return items;\n         }\n     }\n+\n     // FIXME: using `from_def_id_and_kind` breaks `rustdoc/masked` for some reason\n     vec![Item {\n         name: Some(name),\n         attrs: box attrs.clean(cx),\n         def_id: crate_def_id,\n         visibility: krate.vis.clean(cx),\n         kind: box ExternCrateItem { src: orig_name },\n+        cfg: attrs.cfg(cx.sess().diagnostic()),\n     }]\n }\n "}, {"sha": "5e47144588b3f3b0b2f5dc7c9bb5516c4b21051a", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 53, "deletions": 37, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "patch": "@@ -219,11 +219,13 @@ crate struct Item {\n     /// E.g., struct vs enum vs function.\n     crate kind: Box<ItemKind>,\n     crate def_id: DefId,\n+\n+    crate cfg: Option<Arc<Cfg>>,\n }\n \n // `Item` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Item, 40);\n+rustc_data_structures::static_assert_size!(Item, 48);\n \n impl fmt::Debug for Item {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -235,6 +237,7 @@ impl fmt::Debug for Item {\n             .field(\"kind\", &self.kind)\n             .field(\"visibility\", &self.visibility)\n             .field(\"def_id\", def_id)\n+            .field(\"cfg\", &self.cfg)\n             .finish()\n     }\n }\n@@ -262,6 +265,10 @@ impl Item {\n         if self.is_fake() { None } else { tcx.lookup_deprecation(self.def_id) }\n     }\n \n+    crate fn inner_docs(&self, tcx: TyCtxt<'_>) -> bool {\n+        if self.is_fake() { false } else { tcx.get_attrs(self.def_id).inner_docs() }\n+    }\n+\n     crate fn span(&self, tcx: TyCtxt<'_>) -> Span {\n         let kind = match &*self.kind {\n             ItemKind::StrippedItem(k) => k,\n@@ -305,12 +312,15 @@ impl Item {\n         kind: ItemKind,\n         cx: &mut DocContext<'_>,\n     ) -> Item {\n+        let ast_attrs = cx.tcx.get_attrs(def_id);\n+\n         Self::from_def_id_and_attrs_and_parts(\n             def_id,\n             name,\n             kind,\n-            box cx.tcx.get_attrs(def_id).clean(cx),\n+            box ast_attrs.clean(cx),\n             cx,\n+            ast_attrs.cfg(cx.sess().diagnostic()),\n         )\n     }\n \n@@ -320,6 +330,7 @@ impl Item {\n         kind: ItemKind,\n         attrs: Box<Attributes>,\n         cx: &mut DocContext<'_>,\n+        cfg: Option<Arc<Cfg>>,\n     ) -> Item {\n         debug!(\"name={:?}, def_id={:?}\", name, def_id);\n \n@@ -329,6 +340,7 @@ impl Item {\n             name,\n             attrs,\n             visibility: cx.tcx.visibility(def_id).clean(cx),\n+            cfg,\n         }\n     }\n \n@@ -668,6 +680,8 @@ crate trait AttributesExt {\n     fn inner_docs(&self) -> bool;\n \n     fn other_attrs(&self) -> Vec<ast::Attribute>;\n+\n+    fn cfg(&self, diagnostic: &::rustc_errors::Handler) -> Option<Arc<Cfg>>;\n }\n \n impl AttributesExt for [ast::Attribute] {\n@@ -691,6 +705,41 @@ impl AttributesExt for [ast::Attribute] {\n     fn other_attrs(&self) -> Vec<ast::Attribute> {\n         self.iter().filter(|attr| attr.doc_str().is_none()).cloned().collect()\n     }\n+\n+    fn cfg(&self, diagnostic: &::rustc_errors::Handler) -> Option<Arc<Cfg>> {\n+        let mut cfg = Cfg::True;\n+\n+        for attr in self.iter() {\n+            if attr.doc_str().is_none() && attr.has_name(sym::doc) {\n+                if let Some(mi) = attr.meta() {\n+                    if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n+                        // Extracted #[doc(cfg(...))]\n+                        match Cfg::parse(cfg_mi) {\n+                            Ok(new_cfg) => cfg &= new_cfg,\n+                            Err(e) => diagnostic.span_err(e.span, e.msg),\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for attr in self.lists(sym::target_feature) {\n+            if attr.has_name(sym::enable) {\n+                if let Some(feat) = attr.value_str() {\n+                    let meta = attr::mk_name_value_item_str(\n+                        Ident::with_dummy_span(sym::target_feature),\n+                        feat,\n+                        DUMMY_SP,\n+                    );\n+                    if let Ok(feat_cfg) = Cfg::parse(&meta) {\n+                        cfg &= feat_cfg;\n+                    }\n+                }\n+            }\n+        }\n+\n+        if cfg == Cfg::True { None } else { Some(Arc::new(cfg)) }\n+    }\n }\n \n crate trait NestedAttributesExt {\n@@ -799,7 +848,6 @@ impl<'a> FromIterator<&'a DocFragment> for String {\n crate struct Attributes {\n     crate doc_strings: Vec<DocFragment>,\n     crate other_attrs: Vec<ast::Attribute>,\n-    crate cfg: Option<Arc<Cfg>>,\n }\n \n #[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\n@@ -914,12 +962,10 @@ impl Attributes {\n     }\n \n     crate fn from_ast(\n-        diagnostic: &::rustc_errors::Handler,\n         attrs: &[ast::Attribute],\n         additional_attrs: Option<(&[ast::Attribute], DefId)>,\n     ) -> Attributes {\n         let mut doc_strings: Vec<DocFragment> = vec![];\n-        let mut cfg = Cfg::True;\n         let mut doc_line = 0;\n \n         fn update_need_backline(doc_strings: &mut Vec<DocFragment>, frag: &DocFragment) {\n@@ -967,14 +1013,7 @@ impl Attributes {\n             } else {\n                 if attr.has_name(sym::doc) {\n                     if let Some(mi) = attr.meta() {\n-                        if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n-                            // Extracted #[doc(cfg(...))]\n-                            match Cfg::parse(cfg_mi) {\n-                                Ok(new_cfg) => cfg &= new_cfg,\n-                                Err(e) => diagnostic.span_err(e.span, e.msg),\n-                            }\n-                        } else if let Some((filename, contents)) = Attributes::extract_include(&mi)\n-                        {\n+                        if let Some((filename, contents)) = Attributes::extract_include(&mi) {\n                             let line = doc_line;\n                             doc_line += contents.as_str().lines().count();\n                             let frag = DocFragment {\n@@ -1004,28 +1043,7 @@ impl Attributes {\n             .filter_map(clean_attr)\n             .collect();\n \n-        // treat #[target_feature(enable = \"feat\")] attributes as if they were\n-        // #[doc(cfg(target_feature = \"feat\"))] attributes as well\n-        for attr in attrs.lists(sym::target_feature) {\n-            if attr.has_name(sym::enable) {\n-                if let Some(feat) = attr.value_str() {\n-                    let meta = attr::mk_name_value_item_str(\n-                        Ident::with_dummy_span(sym::target_feature),\n-                        feat,\n-                        DUMMY_SP,\n-                    );\n-                    if let Ok(feat_cfg) = Cfg::parse(&meta) {\n-                        cfg &= feat_cfg;\n-                    }\n-                }\n-            }\n-        }\n-\n-        Attributes {\n-            doc_strings,\n-            other_attrs,\n-            cfg: if cfg == Cfg::True { None } else { Some(Arc::new(cfg)) },\n-        }\n+        Attributes { doc_strings, other_attrs }\n     }\n \n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n@@ -1091,7 +1109,6 @@ impl Attributes {\n impl PartialEq for Attributes {\n     fn eq(&self, rhs: &Self) -> bool {\n         self.doc_strings == rhs.doc_strings\n-            && self.cfg == rhs.cfg\n             && self\n                 .other_attrs\n                 .iter()\n@@ -1105,7 +1122,6 @@ impl Eq for Attributes {}\n impl Hash for Attributes {\n     fn hash<H: Hasher>(&self, hasher: &mut H) {\n         self.doc_strings.hash(hasher);\n-        self.cfg.hash(hasher);\n         for attr in &self.other_attrs {\n             attr.id.hash(hasher);\n         }"}, {"sha": "466d1b65406cd24ffd63aef83f2eba65264dd9a6", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "patch": "@@ -1093,9 +1093,9 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n         nested: F,\n     ) {\n         let ast_attrs = self.tcx.hir().attrs(hir_id);\n+        let mut attrs = Attributes::from_ast(ast_attrs, None);\n \n-        let mut attrs = Attributes::from_ast(self.sess.diagnostic(), ast_attrs, None);\n-        if let Some(ref cfg) = attrs.cfg {\n+        if let Some(ref cfg) = ast_attrs.cfg(self.sess.diagnostic()) {\n             if !cfg.matches(&self.sess.parse_sess, Some(&self.sess.features_untracked())) {\n                 return;\n             }"}, {"sha": "f4296a04e59216c8683579f66bb6b79881377c10", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "patch": "@@ -9,8 +9,7 @@ use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n use crate::clean::types::{\n-    AttributesExt, FnDecl, FnRetTy, GenericBound, Generics, GetDefId, Type, TypeKind,\n-    WherePredicate,\n+    AttributesExt, FnDecl, FnRetTy, GenericBound, Generics, GetDefId, Type, WherePredicate,\n };\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;"}, {"sha": "248bd46da857390763f8380683328c650f201e2f", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "patch": "@@ -608,17 +608,12 @@ fn document_item_info(\n }\n \n fn portability(item: &clean::Item, parent: Option<&clean::Item>) -> Option<String> {\n-    let cfg = match (&item.attrs.cfg, parent.and_then(|p| p.attrs.cfg.as_ref())) {\n+    let cfg = match (&item.cfg, parent.and_then(|p| p.cfg.as_ref())) {\n         (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n         (cfg, _) => cfg.as_deref().cloned(),\n     };\n \n-    debug!(\n-        \"Portability {:?} - {:?} = {:?}\",\n-        item.attrs.cfg,\n-        parent.and_then(|p| p.attrs.cfg.as_ref()),\n-        cfg\n-    );\n+    debug!(\"Portability {:?} - {:?} = {:?}\", item.cfg, parent.and_then(|p| p.cfg.as_ref()), cfg);\n \n     Some(format!(\"<div class=\\\"stab portability\\\">{}</div>\", cfg?.render_long_html()))\n }"}, {"sha": "1bb1db00e8825d4a3d83d2757e3841a2df38601e", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "patch": "@@ -1,10 +1,11 @@\n+use clean::AttributesExt;\n+\n use std::cmp::Ordering;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::dep_graph::DepContext;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::hygiene::MacroKind;\n@@ -284,16 +285,14 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n \n             clean::ImportItem(ref import) => {\n                 let (stab, stab_tags) = if let Some(import_def_id) = import.source.did {\n-                    let import_attrs = Box::new(clean::Attributes::from_ast(\n-                        cx.tcx().sess().diagnostic(),\n-                        cx.tcx().get_attrs(import_def_id),\n-                        None,\n-                    ));\n+                    let ast_attrs = cx.tcx().get_attrs(import_def_id);\n+                    let import_attrs = Box::new(clean::Attributes::from_ast(ast_attrs, None));\n \n                     // Just need an item with the correct def_id and attrs\n                     let import_item = clean::Item {\n                         def_id: import_def_id,\n                         attrs: import_attrs,\n+                        cfg: ast_attrs.cfg(cx.tcx().sess.diagnostic()),\n                         ..myitem.clone()\n                     };\n \n@@ -400,12 +399,12 @@ fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) ->\n         tags += &tag_html(\"unstable\", \"\", \"Experimental\");\n     }\n \n-    let cfg = match (&item.attrs.cfg, parent.attrs.cfg.as_ref()) {\n+    let cfg = match (&item.cfg, parent.cfg.as_ref()) {\n         (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n         (cfg, _) => cfg.as_deref().cloned(),\n     };\n \n-    debug!(\"Portability {:?} - {:?} = {:?}\", item.attrs.cfg, parent.attrs.cfg, cfg);\n+    debug!(\"Portability {:?} - {:?} = {:?}\", item.cfg, parent.cfg, cfg);\n     if let Some(ref cfg) = cfg {\n         tags += &tag_html(\"portability\", &cfg.render_long_plain(), &cfg.render_short_html());\n     }"}, {"sha": "2d8c347c3c1678575188ef24b404290670862e21", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "patch": "@@ -41,7 +41,7 @@ impl JsonRenderer<'_> {\n             .map(rustc_ast_pretty::pprust::attribute_to_string)\n             .collect();\n         let span = item.span(self.tcx);\n-        let clean::Item { name, attrs: _, kind: _, visibility, def_id } = item;\n+        let clean::Item { name, attrs: _, kind: _, visibility, def_id, cfg: _ } = item;\n         let inner = match *item.kind {\n             clean::StrippedItem(_) => return None,\n             _ => from_clean_item(item, self.tcx),"}, {"sha": "f1064756fdde7c928859b1c732aceeece6676950", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "patch": "@@ -2,7 +2,6 @@\n //!\n //! [RFC 1946]: https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md\n \n-use clean::AttributesExt;\n use rustc_ast as ast;\n use rustc_data_structures::{fx::FxHashMap, stable_set::FxHashSet};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n@@ -854,10 +853,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             }\n         });\n \n-        let inner_docs = match self_id {\n-            Some(did) => self.cx.tcx.get_attrs(did).inner_docs(),\n-            None => false,\n-        };\n+        let inner_docs = item.inner_docs(self.cx.tcx);\n \n         if item.is_mod() && inner_docs {\n             self.mod_ids.push(item.def_id);\n@@ -1056,7 +1052,7 @@ impl LinkCollector<'_, '_> {\n             };\n         let mut path_str = &*path_str;\n \n-        let inner_docs = self.cx.tcx.get_attrs(item.def_id).inner_docs();\n+        let inner_docs = item.inner_docs(self.cx.tcx);\n \n         // In order to correctly resolve intra-doc links we need to\n         // pick a base AST node to work from.  If the documentation for"}, {"sha": "f5a362bfbe8c6edf9e966b0863a87127821c38b5", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "patch": "@@ -24,7 +24,7 @@ impl DocFolder for CfgPropagator {\n     fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n         let old_parent_cfg = self.parent_cfg.clone();\n \n-        let new_cfg = match (self.parent_cfg.take(), item.attrs.cfg.take()) {\n+        let new_cfg = match (self.parent_cfg.take(), item.cfg.take()) {\n             (None, None) => None,\n             (Some(rc), None) | (None, Some(rc)) => Some(rc),\n             (Some(mut a), Some(b)) => {\n@@ -34,7 +34,7 @@ impl DocFolder for CfgPropagator {\n             }\n         };\n         self.parent_cfg = new_cfg.clone();\n-        item.attrs.cfg = new_cfg;\n+        item.cfg = new_cfg;\n \n         let result = self.fold_item_recur(item);\n         self.parent_cfg = old_parent_cfg;"}]}