{"sha": "2d02e105d1dcde0688c7127c2ce96b372afc38c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMDJlMTA1ZDFkY2RlMDY4OGM3MTI3YzJjZTk2YjM3MmFmYzM4YzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-19T08:45:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-19T08:45:04Z"}, "message": "Auto merge of #1156 - divergentdave:fcntl-F_DUPFD_CLOEXEC, r=RalfJung\n\nAdd F_DUPFD/F_DUPFD_CLOEXEC to fcntl shim\n\nThis adds support for `F_DUPFD` and `F_DUPFD_CLOEXEC` to the shim for `fcntl`. (The `FileHandler` does not track the `FD_CLOEXEC` flag for open files, so these commands are effectively the same.) These changes enable using `File::try_clone`.\n\nI also changed the initial value of the `low` field in `FileHandler`, so that it matches the intent of the preceding comment. The `open` shim was pre-incrementing it when choosing new file descriptor numbers, so FD 3 was being skipped.", "tree": {"sha": "0e3e6717f2ecc731964e0abef84b6697649b16da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e3e6717f2ecc731964e0abef84b6697649b16da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d02e105d1dcde0688c7127c2ce96b372afc38c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d02e105d1dcde0688c7127c2ce96b372afc38c4", "html_url": "https://github.com/rust-lang/rust/commit/2d02e105d1dcde0688c7127c2ce96b372afc38c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d02e105d1dcde0688c7127c2ce96b372afc38c4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "329383acbdb3ff538d952f70187e497e07010f3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/329383acbdb3ff538d952f70187e497e07010f3e", "html_url": "https://github.com/rust-lang/rust/commit/329383acbdb3ff538d952f70187e497e07010f3e"}, {"sha": "ae7d98b68fb34723bb0b8e18f1de71f7e0491397", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae7d98b68fb34723bb0b8e18f1de71f7e0491397", "html_url": "https://github.com/rust-lang/rust/commit/ae7d98b68fb34723bb0b8e18f1de71f7e0491397"}], "stats": {"total": 258, "additions": 202, "deletions": 56}, "files": [{"sha": "85ee98aa3a123ee6dc87e080785314526b11b638", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d02e105d1dcde0688c7127c2ce96b372afc38c4/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d02e105d1dcde0688c7127c2ce96b372afc38c4/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=2d02e105d1dcde0688c7127c2ce96b372afc38c4", "patch": "@@ -1,5 +1,6 @@\n #![feature(rustc_private)]\n #![feature(option_expect_none, option_unwrap_none)]\n+#![feature(map_first_last)]\n #![warn(rust_2018_idioms)]\n #![allow(clippy::cast_lossless)]\n "}, {"sha": "e5ed22634db9ecfa50c9ddb03ef4222eaecb3dbf", "filename": "src/shims/fs.rs", "status": "modified", "additions": 83, "deletions": 31, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/2d02e105d1dcde0688c7127c2ce96b372afc38c4/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d02e105d1dcde0688c7127c2ce96b372afc38c4/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=2d02e105d1dcde0688c7127c2ce96b372afc38c4", "patch": "@@ -1,4 +1,4 @@\n-use std::collections::HashMap;\n+use std::collections::BTreeMap;\n use std::convert::{TryFrom, TryInto};\n use std::fs::{remove_file, rename, File, OpenOptions};\n use std::io::{Read, Seek, SeekFrom, Write};\n@@ -18,18 +18,48 @@ pub struct FileHandle {\n     writable: bool,\n }\n \n+#[derive(Debug, Default)]\n pub struct FileHandler {\n-    handles: HashMap<i32, FileHandle>,\n-    low: i32,\n+    handles: BTreeMap<i32, FileHandle>,\n }\n \n-impl Default for FileHandler {\n-    fn default() -> Self {\n-        FileHandler {\n-            handles: Default::default(),\n-            // 0, 1 and 2 are reserved for stdin, stdout and stderr.\n-            low: 3,\n-        }\n+// fd numbers 0, 1, and 2 are reserved for stdin, stdout, and stderr\n+const MIN_NORMAL_FILE_FD: i32 = 3;\n+\n+impl FileHandler {\n+    fn insert_fd(&mut self, file_handle: FileHandle) -> i32 {\n+        self.insert_fd_with_min_fd(file_handle, 0)\n+    }\n+\n+    fn insert_fd_with_min_fd(&mut self, file_handle: FileHandle, min_fd: i32) -> i32 {\n+        let min_fd = std::cmp::max(min_fd, MIN_NORMAL_FILE_FD);\n+\n+        // Find the lowest unused FD, starting from min_fd. If the first such unused FD is in\n+        // between used FDs, the find_map combinator will return it. If the first such unused FD\n+        // is after all other used FDs, the find_map combinator will return None, and we will use\n+        // the FD following the greatest FD thus far.\n+        let candidate_new_fd = self\n+            .handles\n+            .range(min_fd..)\n+            .zip(min_fd..)\n+            .find_map(|((fd, _fh), counter)| {\n+                if *fd != counter {\n+                    // There was a gap in the fds stored, return the first unused one\n+                    // (note that this relies on BTreeMap iterating in key order)\n+                    Some(counter)\n+                } else {\n+                    // This fd is used, keep going\n+                    None\n+                }\n+            });\n+        let new_fd = candidate_new_fd.unwrap_or_else(|| {\n+            // find_map ran out of BTreeMap entries before finding a free fd, use one plus the\n+            // maximum fd in the map\n+            self.handles.last_entry().map(|entry| entry.key() + 1).unwrap_or(min_fd)\n+        });\n+\n+        self.handles.insert(new_fd, file_handle).unwrap_none();\n+        new_fd\n     }\n }\n \n@@ -107,10 +137,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let path = this.read_os_str_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n \n         let fd = options.open(&path).map(|file| {\n-            let mut fh = &mut this.machine.file_handler;\n-            fh.low += 1;\n-            fh.handles.insert(fh.low, FileHandle { file, writable }).unwrap_none();\n-            fh.low\n+            let fh = &mut this.machine.file_handler;\n+            fh.insert_fd(FileHandle { file, writable })\n         });\n \n         this.try_unwrap_io_result(fd)\n@@ -120,7 +148,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         fd_op: OpTy<'tcx, Tag>,\n         cmd_op: OpTy<'tcx, Tag>,\n-        _arg1_op: Option<OpTy<'tcx, Tag>>,\n+        start_op: Option<OpTy<'tcx, Tag>>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -139,6 +167,31 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             } else {\n                 this.handle_not_found()\n             }\n+        } else if cmd == this.eval_libc_i32(\"F_DUPFD\")?\n+            || cmd == this.eval_libc_i32(\"F_DUPFD_CLOEXEC\")?\n+        {\n+            // Note that we always assume the FD_CLOEXEC flag is set for every open file, in part\n+            // because exec() isn't supported. The F_DUPFD and F_DUPFD_CLOEXEC commands only\n+            // differ in whether the FD_CLOEXEC flag is pre-set on the new file descriptor,\n+            // thus they can share the same implementation here.\n+            if fd < MIN_NORMAL_FILE_FD {\n+                throw_unsup_format!(\"Duplicating file descriptors for stdin, stdout, or stderr is not supported\")\n+            }\n+            let start_op = start_op.ok_or_else(|| {\n+                err_unsup_format!(\n+                    \"fcntl with command F_DUPFD or F_DUPFD_CLOEXEC requires a third argument\"\n+                )\n+            })?;\n+            let start = this.read_scalar(start_op)?.to_i32()?;\n+            let fh = &mut this.machine.file_handler;\n+            let (file_result, writable) = match fh.handles.get(&fd) {\n+                Some(FileHandle { file, writable }) => (file.try_clone(), *writable),\n+                None => return this.handle_not_found(),\n+            };\n+            let fd_result = file_result.map(|duplicated| {\n+                fh.insert_fd_with_min_fd(FileHandle { file: duplicated, writable }, start)\n+            });\n+            this.try_unwrap_io_result(fd_result)\n         } else {\n             throw_unsup_format!(\"The {:#x} command is not supported for `fcntl`)\", cmd);\n         }\n@@ -151,23 +204,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n \n-        if let Some(handle) = this.machine.file_handler.handles.remove(&fd) {\n+        if let Some(FileHandle { file, writable }) = this.machine.file_handler.handles.remove(&fd) {\n             // We sync the file if it was opened in a mode different than read-only.\n-            if handle.writable {\n+            if writable {\n                 // `File::sync_all` does the checks that are done when closing a file. We do this to\n                 // to handle possible errors correctly.\n-                let result = this.try_unwrap_io_result(handle.file.sync_all().map(|_| 0i32));\n+                let result = this.try_unwrap_io_result(file.sync_all().map(|_| 0i32));\n                 // Now we actually close the file.\n-                drop(handle);\n+                drop(file);\n                 // And return the result.\n                 result\n             } else {\n                 // We drop the file, this closes it but ignores any errors produced when closing\n-                // it. This is done because `File::sync_call` cannot be done over files like\n+                // it. This is done because `File::sync_all` cannot be done over files like\n                 // `/dev/urandom` which are read-only. Check\n                 // https://github.com/rust-lang/miri/issues/999#issuecomment-568920439 for a deeper\n                 // discussion.\n-                drop(handle);\n+                drop(file);\n                 Ok(0)\n             }\n         } else {\n@@ -200,16 +253,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n         let count = count.min(this.isize_max() as u64).min(isize::max_value() as u64);\n \n-        if let Some(handle) = this.machine.file_handler.handles.get_mut(&fd) {\n+        if let Some(FileHandle { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n             // This can never fail because `count` was capped to be smaller than\n             // `isize::max_value()`.\n             let count = isize::try_from(count).unwrap();\n             // We want to read at most `count` bytes. We are sure that `count` is not negative\n             // because it was a target's `usize`. Also we are sure that its smaller than\n             // `usize::max_value()` because it is a host's `isize`.\n             let mut bytes = vec![0; count as usize];\n-            let result = handle\n-                .file\n+            let result = file\n                 .read(&mut bytes)\n                 // `File::read` never returns a value larger than `count`, so this cannot fail.\n                 .map(|c| i64::try_from(c).unwrap());\n@@ -255,9 +307,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n         let count = count.min(this.isize_max() as u64).min(isize::max_value() as u64);\n \n-        if let Some(handle) = this.machine.file_handler.handles.get_mut(&fd) {\n+        if let Some(FileHandle { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n             let bytes = this.memory.read_bytes(buf, Size::from_bytes(count))?;\n-            let result = handle.file.write(&bytes).map(|c| i64::try_from(c).unwrap());\n+            let result = file.write(&bytes).map(|c| i64::try_from(c).unwrap());\n             this.try_unwrap_io_result(result)\n         } else {\n             this.handle_not_found()\n@@ -290,8 +342,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(-1);\n         };\n \n-        if let Some(handle) = this.machine.file_handler.handles.get_mut(&fd) {\n-            let result = handle.file.seek(seek_from).map(|offset| offset as i64);\n+        if let Some(FileHandle { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n+            let result = file.seek(seek_from).map(|offset| offset as i64);\n             this.try_unwrap_io_result(result)\n         } else {\n             this.handle_not_found()\n@@ -652,11 +704,11 @@ impl FileMetadata {\n         fd: i32,\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n         let option = ecx.machine.file_handler.handles.get(&fd);\n-        let handle = match option {\n-            Some(handle) => handle,\n+        let file = match option {\n+            Some(FileHandle { file, writable: _ }) => file,\n             None => return ecx.handle_not_found().map(|_: i32| None),\n         };\n-        let metadata = handle.file.metadata();\n+        let metadata = file.metadata();\n \n         FileMetadata::from_meta(ecx, metadata)\n     }"}, {"sha": "3851a4d45e92beb952ec89e003228089daaeba07", "filename": "tests/run-pass/fs.rs", "status": "modified", "additions": 118, "deletions": 25, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/2d02e105d1dcde0688c7127c2ce96b372afc38c4/tests%2Frun-pass%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d02e105d1dcde0688c7127c2ce96b372afc38c4/tests%2Frun-pass%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs.rs?ref=2d02e105d1dcde0688c7127c2ce96b372afc38c4", "patch": "@@ -5,25 +5,23 @@ use std::fs::{File, remove_file, rename};\n use std::io::{Read, Write, ErrorKind, Result, Seek, SeekFrom};\n use std::path::{PathBuf, Path};\n \n-fn test_metadata(bytes: &[u8], path: &Path) -> Result<()> {\n-    // Test that the file metadata is correct.\n-    let metadata = path.metadata()?;\n-    // `path` should point to a file.\n-    assert!(metadata.is_file());\n-    // The size of the file must be equal to the number of written bytes.\n-    assert_eq!(bytes.len() as u64, metadata.len());\n-    Ok(())\n+fn main() {\n+    test_file();\n+    test_file_clone();\n+    test_seek();\n+    test_metadata();\n+    test_symlink();\n+    test_errors();\n+    test_rename();\n }\n \n-fn main() {\n+fn test_file() {\n     let tmp = std::env::temp_dir();\n-    let filename = PathBuf::from(\"miri_test_fs.txt\");\n+    let filename = PathBuf::from(\"miri_test_fs_file.txt\");\n     let path = tmp.join(&filename);\n-    let symlink_path = tmp.join(\"miri_test_fs_symlink.txt\");\n     let bytes = b\"Hello, World!\\n\";\n     // Clean the paths for robustness.\n     remove_file(&path).ok();\n-    remove_file(&symlink_path).ok();\n \n     // Test creating, writing and closing a file (closing is tested when `file` is dropped).\n     let mut file = File::create(&path).unwrap();\n@@ -42,6 +40,47 @@ fn main() {\n     file.read_to_end(&mut contents).unwrap();\n     assert_eq!(bytes, contents.as_slice());\n \n+    // Removing file should succeed.\n+    remove_file(&path).unwrap();\n+}\n+\n+fn test_file_clone() {\n+    let tmp = std::env::temp_dir();\n+    let filename = PathBuf::from(\"miri_test_fs_file_clone.txt\");\n+    let path = tmp.join(&filename);\n+    let bytes = b\"Hello, World!\\n\";\n+    // Clean the paths for robustness.\n+    remove_file(&path).ok();\n+\n+    let mut file = File::create(&path).unwrap();\n+    file.write(bytes).unwrap();\n+\n+    // Cloning a file should be successful.\n+    let file = File::open(&path).unwrap();\n+    let mut cloned = file.try_clone().unwrap();\n+    // Reading from a cloned file should get the same text.\n+    let mut contents = Vec::new();\n+    cloned.read_to_end(&mut contents).unwrap();\n+    assert_eq!(bytes, contents.as_slice());\n+\n+    // Removing file should succeed.\n+    remove_file(&path).unwrap();\n+}\n+\n+fn test_seek() {\n+    let tmp = std::env::temp_dir();\n+    let filename = PathBuf::from(\"miri_test_fs_seek.txt\");\n+    let path = tmp.join(&filename);\n+    let bytes = b\"Hello, World!\\n\";\n+    // Clean the paths for robustness.\n+    remove_file(&path).ok();\n+\n+    let mut file = File::create(&path).unwrap();\n+    file.write(bytes).unwrap();\n+\n+    let mut file = File::open(&path).unwrap();\n+    let mut contents = Vec::new();\n+    file.read_to_end(&mut contents).unwrap();\n     // Test that seeking to the beginning and reading until EOF gets the text again.\n     file.seek(SeekFrom::Start(0)).unwrap();\n     let mut contents = Vec::new();\n@@ -59,11 +98,53 @@ fn main() {\n     file.read_to_end(&mut contents).unwrap();\n     assert_eq!(&bytes[2..], contents.as_slice());\n \n+    // Removing file should succeed.\n+    remove_file(&path).unwrap();\n+}\n+\n+fn check_metadata(bytes: &[u8], path: &Path) -> Result<()> {\n+    // Test that the file metadata is correct.\n+    let metadata = path.metadata()?;\n+    // `path` should point to a file.\n+    assert!(metadata.is_file());\n+    // The size of the file must be equal to the number of written bytes.\n+    assert_eq!(bytes.len() as u64, metadata.len());\n+    Ok(())\n+}\n+\n+fn test_metadata() {\n+    let tmp = std::env::temp_dir();\n+    let filename = PathBuf::from(\"miri_test_fs_metadata.txt\");\n+    let path = tmp.join(&filename);\n+    let bytes = b\"Hello, World!\\n\";\n+    // Clean the paths for robustness.\n+    remove_file(&path).ok();\n+\n+    let mut file = File::create(&path).unwrap();\n+    file.write(bytes).unwrap();\n+\n     // Test that metadata of an absolute path is correct.\n-    test_metadata(bytes, &path).unwrap();\n+    check_metadata(bytes, &path).unwrap();\n     // Test that metadata of a relative path is correct.\n     std::env::set_current_dir(&tmp).unwrap();\n-    test_metadata(bytes, &filename).unwrap();\n+    check_metadata(bytes, &filename).unwrap();\n+\n+    // Removing file should succeed.\n+    remove_file(&path).unwrap();\n+}\n+\n+fn test_symlink() {\n+    let tmp = std::env::temp_dir();\n+    let filename = PathBuf::from(\"miri_test_fs_link_target.txt\");\n+    let path = tmp.join(&filename);\n+    let symlink_path = tmp.join(\"miri_test_fs_symlink.txt\");\n+    let bytes = b\"Hello, World!\\n\";\n+    // Clean the paths for robustness.\n+    remove_file(&path).ok();\n+    remove_file(&symlink_path).ok();\n+\n+    let mut file = File::create(&path).unwrap();\n+    file.write(bytes).unwrap();\n \n     // Creating a symbolic link should succeed.\n     std::os::unix::fs::symlink(&path, &symlink_path).unwrap();\n@@ -73,18 +154,38 @@ fn main() {\n     symlink_file.read_to_end(&mut contents).unwrap();\n     assert_eq!(bytes, contents.as_slice());\n     // Test that metadata of a symbolic link is correct.\n-    test_metadata(bytes, &symlink_path).unwrap();\n+    check_metadata(bytes, &symlink_path).unwrap();\n     // Test that the metadata of a symbolic link is correct when not following it.\n     assert!(symlink_path.symlink_metadata().unwrap().file_type().is_symlink());\n     // Removing symbolic link should succeed.\n     remove_file(&symlink_path).unwrap();\n \n     // Removing file should succeed.\n     remove_file(&path).unwrap();\n+}\n \n+fn test_errors() {\n+    let tmp = std::env::temp_dir();\n+    let filename = PathBuf::from(\"miri_test_fs_errors.txt\");\n+    let path = tmp.join(&filename);\n+    let bytes = b\"Hello, World!\\n\";\n+    // Clean the paths for robustness.\n+    remove_file(&path).ok();\n+\n+    // The following tests also check that the `__errno_location()` shim is working properly.\n+    // Opening a non-existing file should fail with a \"not found\" error.\n+    assert_eq!(ErrorKind::NotFound, File::open(&path).unwrap_err().kind());\n+    // Removing a non-existing file should fail with a \"not found\" error.\n+    assert_eq!(ErrorKind::NotFound, remove_file(&path).unwrap_err().kind());\n+    // Reading the metadata of a non-existing file should fail with a \"not found\" error.\n+    assert_eq!(ErrorKind::NotFound, check_metadata(bytes, &path).unwrap_err().kind());\n+}\n+\n+fn test_rename() {\n+    let tmp = std::env::temp_dir();\n     // Renaming a file should succeed.\n-    let path1 = tmp.join(\"rename_source.txt\");\n-    let path2 = tmp.join(\"rename_destination.txt\");\n+    let path1 = tmp.join(\"miri_test_fs_rename_source.txt\");\n+    let path2 = tmp.join(\"miri_test_fs_rename_destination.txt\");\n     // Clean files for robustness.\n     remove_file(&path1).ok();\n     remove_file(&path2).ok();\n@@ -94,12 +195,4 @@ fn main() {\n     assert_eq!(ErrorKind::NotFound, path1.metadata().unwrap_err().kind());\n     assert!(path2.metadata().unwrap().is_file());\n     remove_file(&path2).unwrap();\n-\n-    // The two following tests also check that the `__errno_location()` shim is working properly.\n-    // Opening a non-existing file should fail with a \"not found\" error.\n-    assert_eq!(ErrorKind::NotFound, File::open(&path).unwrap_err().kind());\n-    // Removing a non-existing file should fail with a \"not found\" error.\n-    assert_eq!(ErrorKind::NotFound, remove_file(&path).unwrap_err().kind());\n-    // Reading the metadata of a non-existing file should fail with a \"not found\" error.\n-    assert_eq!(ErrorKind::NotFound, test_metadata(bytes, &path).unwrap_err().kind());\n }"}]}