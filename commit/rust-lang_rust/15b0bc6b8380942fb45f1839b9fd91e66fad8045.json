{"sha": "15b0bc6b8380942fb45f1839b9fd91e66fad8045", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1YjBiYzZiODM4MDk0MmZiNDVmMTgzOWI5ZmQ5MWU2NmZhZDgwNDU=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-02-06T12:49:08Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-02-13T20:14:58Z"}, "message": "Separate the query cache from the query state.", "tree": {"sha": "6491b4d4bae653079332cb01f76e76188728638e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6491b4d4bae653079332cb01f76e76188728638e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15b0bc6b8380942fb45f1839b9fd91e66fad8045", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15b0bc6b8380942fb45f1839b9fd91e66fad8045", "html_url": "https://github.com/rust-lang/rust/commit/15b0bc6b8380942fb45f1839b9fd91e66fad8045", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15b0bc6b8380942fb45f1839b9fd91e66fad8045/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f46259a7516f0bc453f9a0edb318be11c3d4a28", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f46259a7516f0bc453f9a0edb318be11c3d4a28", "html_url": "https://github.com/rust-lang/rust/commit/9f46259a7516f0bc453f9a0edb318be11c3d4a28"}], "stats": {"total": 308, "additions": 173, "deletions": 135}, "files": [{"sha": "14db71cb8f0701040da9ad286fa75c2ed6580f75", "filename": "compiler/rustc_data_structures/src/sharded.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs?ref=15b0bc6b8380942fb45f1839b9fd91e66fad8045", "patch": "@@ -63,23 +63,9 @@ impl<T> Sharded<T> {\n         if SHARDS == 1 { &self.shards[0].0 } else { self.get_shard_by_hash(make_hash(val)) }\n     }\n \n-    /// Get a shard with a pre-computed hash value. If `get_shard_by_value` is\n-    /// ever used in combination with `get_shard_by_hash` on a single `Sharded`\n-    /// instance, then `hash` must be computed with `FxHasher`. Otherwise,\n-    /// `hash` can be computed with any hasher, so long as that hasher is used\n-    /// consistently for each `Sharded` instance.\n-    #[inline]\n-    pub fn get_shard_index_by_hash(&self, hash: u64) -> usize {\n-        let hash_len = mem::size_of::<usize>();\n-        // Ignore the top 7 bits as hashbrown uses these and get the next SHARD_BITS highest bits.\n-        // hashbrown also uses the lowest bits, so we can't use those\n-        let bits = (hash >> (hash_len * 8 - 7 - SHARD_BITS)) as usize;\n-        bits % SHARDS\n-    }\n-\n     #[inline]\n     pub fn get_shard_by_hash(&self, hash: u64) -> &Lock<T> {\n-        &self.shards[self.get_shard_index_by_hash(hash)].0\n+        &self.shards[get_shard_index_by_hash(hash)].0\n     }\n \n     #[inline]\n@@ -166,3 +152,17 @@ fn make_hash<K: Hash + ?Sized>(val: &K) -> u64 {\n     val.hash(&mut state);\n     state.finish()\n }\n+\n+/// Get a shard with a pre-computed hash value. If `get_shard_by_value` is\n+/// ever used in combination with `get_shard_by_hash` on a single `Sharded`\n+/// instance, then `hash` must be computed with `FxHasher`. Otherwise,\n+/// `hash` can be computed with any hasher, so long as that hasher is used\n+/// consistently for each `Sharded` instance.\n+#[inline]\n+pub fn get_shard_index_by_hash(hash: u64) -> usize {\n+    let hash_len = mem::size_of::<usize>();\n+    // Ignore the top 7 bits as hashbrown uses these and get the next SHARD_BITS highest bits.\n+    // hashbrown also uses the lowest bits, so we can't use those\n+    let bits = (hash >> (hash_len * 8 - 7 - SHARD_BITS)) as usize;\n+    bits % SHARDS\n+}"}, {"sha": "4654a8424706d4612d0b0d1e5bc0734d63123c6d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=15b0bc6b8380942fb45f1839b9fd91e66fad8045", "patch": "@@ -963,6 +963,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub(crate) definitions: &'tcx Definitions,\n \n     pub queries: query::Queries<'tcx>,\n+    pub query_caches: query::QueryCaches<'tcx>,\n \n     maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n     maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n@@ -1154,6 +1155,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             untracked_crate: krate,\n             definitions,\n             queries: query::Queries::new(providers, extern_providers, on_disk_query_result_cache),\n+            query_caches: query::QueryCaches::default(),\n             ty_rcache: Default::default(),\n             pred_rcache: Default::default(),\n             selection_cache: Default::default(),"}, {"sha": "b41edb5deeb2cc1973454b9d0141cf8a564017d9", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=15b0bc6b8380942fb45f1839b9fd91e66fad8045", "patch": "@@ -1244,10 +1244,9 @@ where\n         .prof\n         .extra_verbose_generic_activity(\"encode_query_results_for\", std::any::type_name::<Q>());\n \n-    let state = Q::query_state(tcx);\n-    assert!(state.all_inactive());\n-\n-    state.iter_results(|results| {\n+    assert!(Q::query_state(tcx).all_inactive());\n+    let cache = Q::query_cache(tcx);\n+    cache.iter_results(|results| {\n         for (key, value, dep_node) in results {\n             if Q::cache_on_disk(tcx, &key, Some(value)) {\n                 let dep_node = SerializedDepNodeIndex::new(dep_node.index());"}, {"sha": "9a011846fd62df686c50cf0dbea6ac9d8250d49a", "filename": "compiler/rustc_middle/src/ty/query/plumbing.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs?ref=15b0bc6b8380942fb45f1839b9fd91e66fad8045", "patch": "@@ -355,6 +355,11 @@ macro_rules! define_queries {\n             $(pub type $name<$tcx> = <query_storage::$name<$tcx> as QueryStorage>::Stored;)*\n         }\n \n+        #[derive(Default)]\n+        pub struct QueryCaches<$tcx> {\n+            $($(#[$attr])* $name: QueryCacheStore<query_storage::$name<$tcx>>,)*\n+        }\n+\n         $(impl<$tcx> QueryConfig for queries::$name<$tcx> {\n             type Key = $($K)*;\n             type Value = $V;\n@@ -370,10 +375,17 @@ macro_rules! define_queries {\n             type Cache = query_storage::$name<$tcx>;\n \n             #[inline(always)]\n-            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<crate::dep_graph::DepKind, <TyCtxt<$tcx> as QueryContext>::Query, Self::Cache> {\n+            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<crate::dep_graph::DepKind, Query<$tcx>, Self::Key> {\n                 &tcx.queries.$name\n             }\n \n+            #[inline(always)]\n+            fn query_cache<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryCacheStore<Self::Cache>\n+                where 'tcx:'a\n+            {\n+                &tcx.query_caches.$name\n+            }\n+\n             #[inline]\n             fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n                 let provider = tcx.queries.providers.get(key.query_crate())\n@@ -479,7 +491,7 @@ macro_rules! define_queries {\n                     alloc_self_profile_query_strings_for_query_cache(\n                         self,\n                         stringify!($name),\n-                        &self.queries.$name,\n+                        &self.query_caches.$name,\n                         &mut string_cache,\n                     );\n                 })*\n@@ -525,8 +537,8 @@ macro_rules! define_queries_struct {\n \n             $($(#[$attr])*  $name: QueryState<\n                 crate::dep_graph::DepKind,\n-                <TyCtxt<$tcx> as QueryContext>::Query,\n-                query_storage::$name<$tcx>,\n+                Query<$tcx>,\n+                query_keys::$name<$tcx>,\n             >,)*\n         }\n "}, {"sha": "9976e7885090cb4e23fd66e0e2e350b036a2a6a8", "filename": "compiler/rustc_middle/src/ty/query/profiling_support.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fprofiling_support.rs?ref=15b0bc6b8380942fb45f1839b9fd91e66fad8045", "patch": "@@ -5,7 +5,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfiler;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n-use rustc_query_system::query::{QueryCache, QueryContext, QueryState};\n+use rustc_query_system::query::{QueryCache, QueryCacheStore};\n use std::fmt::Debug;\n use std::io::Write;\n \n@@ -230,7 +230,7 @@ where\n pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n     tcx: TyCtxt<'tcx>,\n     query_name: &'static str,\n-    query_state: &QueryState<crate::dep_graph::DepKind, <TyCtxt<'tcx> as QueryContext>::Query, C>,\n+    query_cache: &QueryCacheStore<C>,\n     string_cache: &mut QueryKeyStringCache,\n ) where\n     C: QueryCache,\n@@ -251,7 +251,7 @@ pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n             // need to invoke queries itself, we cannot keep the query caches\n             // locked while doing so. Instead we copy out the\n             // `(query_key, dep_node_index)` pairs and release the lock again.\n-            let query_keys_and_indices: Vec<_> = query_state\n+            let query_keys_and_indices: Vec<_> = query_cache\n                 .iter_results(|results| results.map(|(k, _, i)| (k.clone(), i)).collect());\n \n             // Now actually allocate the strings. If allocating the strings\n@@ -276,7 +276,7 @@ pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n             let query_name = profiler.get_or_alloc_cached_string(query_name);\n             let event_id = event_id_builder.from_label(query_name).to_string_id();\n \n-            query_state.iter_results(|results| {\n+            query_cache.iter_results(|results| {\n                 let query_invocation_ids: Vec<_> = results.map(|v| v.2.into()).collect();\n \n                 profiler.bulk_map_query_invocation_id_to_single_string("}, {"sha": "c885a10f8059524040b4d33a8f86c46bb37eba10", "filename": "compiler/rustc_middle/src/ty/query/stats.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs?ref=15b0bc6b8380942fb45f1839b9fd91e66fad8045", "patch": "@@ -1,10 +1,9 @@\n use crate::ty::query::queries;\n use crate::ty::TyCtxt;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_query_system::query::{QueryAccessors, QueryCache, QueryContext, QueryState};\n+use rustc_query_system::query::{QueryAccessors, QueryCache, QueryCacheStore};\n \n use std::any::type_name;\n-use std::hash::Hash;\n use std::mem;\n #[cfg(debug_assertions)]\n use std::sync::atomic::Ordering;\n@@ -37,10 +36,8 @@ struct QueryStats {\n     local_def_id_keys: Option<usize>,\n }\n \n-fn stats<D, Q, C>(name: &'static str, map: &QueryState<D, Q, C>) -> QueryStats\n+fn stats<C>(name: &'static str, map: &QueryCacheStore<C>) -> QueryStats\n where\n-    D: Copy + Clone + Eq + Hash,\n-    Q: Clone,\n     C: QueryCache,\n {\n     let mut stats = QueryStats {\n@@ -128,12 +125,10 @@ macro_rules! print_stats {\n \n             $(\n                 queries.push(stats::<\n-                    crate::dep_graph::DepKind,\n-                    <TyCtxt<'_> as QueryContext>::Query,\n                     <queries::$name<'_> as QueryAccessors<TyCtxt<'_>>>::Cache,\n                 >(\n                     stringify!($name),\n-                    &tcx.queries.$name,\n+                    &tcx.query_caches.$name,\n                 ));\n             )*\n "}, {"sha": "d589c90fa7b123038d20efc21d5e8b3177962741", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=15b0bc6b8380942fb45f1839b9fd91e66fad8045", "patch": "@@ -1,5 +1,5 @@\n use crate::dep_graph::DepNodeIndex;\n-use crate::query::plumbing::{QueryLookup, QueryState};\n+use crate::query::plumbing::{QueryCacheStore, QueryLookup};\n \n use rustc_arena::TypedArena;\n use rustc_data_structures::fx::FxHashMap;\n@@ -31,13 +31,13 @@ pub trait QueryCache: QueryStorage {\n     /// It returns the shard index and a lock guard to the shard,\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n-    fn lookup<'s, D, Q, R, OnHit>(\n+    fn lookup<'s, R, OnHit>(\n         &self,\n-        state: &'s QueryState<D, Q, Self>,\n+        state: &'s QueryCacheStore<Self>,\n         key: &Self::Key,\n         // `on_hit` can be called while holding a lock to the query state shard.\n         on_hit: OnHit,\n-    ) -> Result<R, QueryLookup<'s, D, Q, Self::Key, Self::Sharded>>\n+    ) -> Result<R, QueryLookup<'s, Self::Sharded>>\n     where\n         OnHit: FnOnce(&Self::Stored, DepNodeIndex) -> R;\n \n@@ -93,17 +93,17 @@ where\n     type Sharded = FxHashMap<K, (V, DepNodeIndex)>;\n \n     #[inline(always)]\n-    fn lookup<'s, D, Q, R, OnHit>(\n+    fn lookup<'s, R, OnHit>(\n         &self,\n-        state: &'s QueryState<D, Q, Self>,\n+        state: &'s QueryCacheStore<Self>,\n         key: &K,\n         on_hit: OnHit,\n-    ) -> Result<R, QueryLookup<'s, D, Q, K, Self::Sharded>>\n+    ) -> Result<R, QueryLookup<'s, Self::Sharded>>\n     where\n         OnHit: FnOnce(&V, DepNodeIndex) -> R,\n     {\n         let lookup = state.get_lookup(key);\n-        let result = lookup.lock.cache.raw_entry().from_key_hashed_nocheck(lookup.key_hash, key);\n+        let result = lookup.lock.raw_entry().from_key_hashed_nocheck(lookup.key_hash, key);\n \n         if let Some((_, value)) = result {\n             let hit_result = on_hit(&value.0, value.1);\n@@ -176,17 +176,17 @@ where\n     type Sharded = FxHashMap<K, &'tcx (V, DepNodeIndex)>;\n \n     #[inline(always)]\n-    fn lookup<'s, D, Q, R, OnHit>(\n+    fn lookup<'s, R, OnHit>(\n         &self,\n-        state: &'s QueryState<D, Q, Self>,\n+        state: &'s QueryCacheStore<Self>,\n         key: &K,\n         on_hit: OnHit,\n-    ) -> Result<R, QueryLookup<'s, D, Q, K, Self::Sharded>>\n+    ) -> Result<R, QueryLookup<'s, Self::Sharded>>\n     where\n         OnHit: FnOnce(&&'tcx V, DepNodeIndex) -> R,\n     {\n         let lookup = state.get_lookup(key);\n-        let result = lookup.lock.cache.raw_entry().from_key_hashed_nocheck(lookup.key_hash, key);\n+        let result = lookup.lock.raw_entry().from_key_hashed_nocheck(lookup.key_hash, key);\n \n         if let Some((_, value)) = result {\n             let hit_result = on_hit(&&value.0, value.1);"}, {"sha": "fecd75049fb7aa8be830e9b6160b8afd3b162137", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=15b0bc6b8380942fb45f1839b9fd91e66fad8045", "patch": "@@ -4,7 +4,7 @@ use crate::dep_graph::DepNode;\n use crate::dep_graph::SerializedDepNodeIndex;\n use crate::query::caches::QueryCache;\n use crate::query::plumbing::CycleError;\n-use crate::query::{QueryContext, QueryState};\n+use crate::query::{QueryCacheStore, QueryContext, QueryState};\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use std::fmt::Debug;\n@@ -73,7 +73,12 @@ pub trait QueryAccessors<CTX: QueryContext>: QueryConfig {\n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: CTX) -> &'a QueryState<CTX::DepKind, CTX::Query, Self::Cache>;\n+    fn query_state<'a>(tcx: CTX) -> &'a QueryState<CTX::DepKind, CTX::Query, Self::Key>;\n+\n+    // Don't use this method to access query results, instead use the methods on TyCtxt\n+    fn query_cache<'a>(tcx: CTX) -> &'a QueryCacheStore<Self::Cache>\n+    where\n+        CTX: 'a;\n \n     fn to_dep_node(tcx: CTX, key: &Self::Key) -> DepNode<CTX::DepKind>\n     where"}, {"sha": "51a72594b5e0ccb66d24ae87b2c04aed90b4f88b", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 111, "deletions": 86, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b0bc6b8380942fb45f1839b9fd91e66fad8045/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=15b0bc6b8380942fb45f1839b9fd91e66fad8045", "patch": "@@ -13,7 +13,7 @@ use crate::query::{QueryContext, QueryMap};\n use rustc_data_structures::cold_path;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHasher};\n-use rustc_data_structures::sharded::Sharded;\n+use rustc_data_structures::sharded::{get_shard_index_by_hash, Sharded};\n use rustc_data_structures::sync::{Lock, LockGuard};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::{Diagnostic, FatalError};\n@@ -27,43 +27,73 @@ use std::ptr;\n #[cfg(debug_assertions)]\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n-pub(super) struct QueryStateShard<D, Q, K, C> {\n-    pub(super) cache: C,\n-    active: FxHashMap<K, QueryResult<D, Q>>,\n-\n-    /// Used to generate unique ids for active jobs.\n-    jobs: u32,\n+pub struct QueryCacheStore<C: QueryCache> {\n+    cache: C,\n+    shards: Sharded<C::Sharded>,\n+    #[cfg(debug_assertions)]\n+    pub cache_hits: AtomicUsize,\n }\n \n-impl<D, Q, K, C: Default> Default for QueryStateShard<D, Q, K, C> {\n-    fn default() -> QueryStateShard<D, Q, K, C> {\n-        QueryStateShard { cache: Default::default(), active: Default::default(), jobs: 0 }\n+impl<C: QueryCache> Default for QueryCacheStore<C> {\n+    fn default() -> Self {\n+        Self {\n+            cache: C::default(),\n+            shards: Default::default(),\n+            #[cfg(debug_assertions)]\n+            cache_hits: AtomicUsize::new(0),\n+        }\n     }\n }\n \n-pub struct QueryState<D, Q, C: QueryCache> {\n-    cache: C,\n-    shards: Sharded<QueryStateShard<D, Q, C::Key, C::Sharded>>,\n-    #[cfg(debug_assertions)]\n-    pub cache_hits: AtomicUsize,\n+/// Values used when checking a query cache which can be reused on a cache-miss to execute the query.\n+pub struct QueryLookup<'tcx, C> {\n+    pub(super) key_hash: u64,\n+    shard: usize,\n+    pub(super) lock: LockGuard<'tcx, C>,\n }\n \n-impl<D, Q, C: QueryCache> QueryState<D, Q, C> {\n-    pub(super) fn get_lookup<'tcx>(\n-        &'tcx self,\n-        key: &C::Key,\n-    ) -> QueryLookup<'tcx, D, Q, C::Key, C::Sharded> {\n-        // We compute the key's hash once and then use it for both the\n-        // shard lookup and the hashmap lookup. This relies on the fact\n-        // that both of them use `FxHasher`.\n-        let mut hasher = FxHasher::default();\n-        key.hash(&mut hasher);\n-        let key_hash = hasher.finish();\n-\n-        let shard = self.shards.get_shard_index_by_hash(key_hash);\n+// We compute the key's hash once and then use it for both the\n+// shard lookup and the hashmap lookup. This relies on the fact\n+// that both of them use `FxHasher`.\n+fn hash_for_shard<K: Hash>(key: &K) -> u64 {\n+    let mut hasher = FxHasher::default();\n+    key.hash(&mut hasher);\n+    hasher.finish()\n+}\n+\n+impl<C: QueryCache> QueryCacheStore<C> {\n+    pub(super) fn get_lookup<'tcx>(&'tcx self, key: &C::Key) -> QueryLookup<'tcx, C::Sharded> {\n+        let key_hash = hash_for_shard(key);\n+        let shard = get_shard_index_by_hash(key_hash);\n         let lock = self.shards.get_shard_by_index(shard).lock();\n         QueryLookup { key_hash, shard, lock }\n     }\n+\n+    pub fn iter_results<R>(\n+        &self,\n+        f: impl for<'a> FnOnce(\n+            Box<dyn Iterator<Item = (&'a C::Key, &'a C::Value, DepNodeIndex)> + 'a>,\n+        ) -> R,\n+    ) -> R {\n+        self.cache.iter(&self.shards, |shard| &mut *shard, f)\n+    }\n+}\n+\n+struct QueryStateShard<D, Q, K> {\n+    active: FxHashMap<K, QueryResult<D, Q>>,\n+\n+    /// Used to generate unique ids for active jobs.\n+    jobs: u32,\n+}\n+\n+impl<D, Q, K> Default for QueryStateShard<D, Q, K> {\n+    fn default() -> QueryStateShard<D, Q, K> {\n+        QueryStateShard { active: Default::default(), jobs: 0 }\n+    }\n+}\n+\n+pub struct QueryState<D, Q, K> {\n+    shards: Sharded<QueryStateShard<D, Q, K>>,\n }\n \n /// Indicates the state of a query for a given key in a query map.\n@@ -76,21 +106,12 @@ enum QueryResult<D, Q> {\n     Poisoned,\n }\n \n-impl<D, Q, C> QueryState<D, Q, C>\n+impl<D, Q, K> QueryState<D, Q, K>\n where\n     D: Copy + Clone + Eq + Hash,\n     Q: Clone,\n-    C: QueryCache,\n+    K: Eq + Hash + Clone + Debug,\n {\n-    pub fn iter_results<R>(\n-        &self,\n-        f: impl for<'a> FnOnce(\n-            Box<dyn Iterator<Item = (&'a C::Key, &'a C::Value, DepNodeIndex)> + 'a>,\n-        ) -> R,\n-    ) -> R {\n-        self.cache.iter(&self.shards, |shard| &mut shard.cache, f)\n-    }\n-\n     pub fn all_inactive(&self) -> bool {\n         let shards = self.shards.lock_shards();\n         shards.iter().all(|shard| shard.active.is_empty())\n@@ -99,7 +120,7 @@ where\n     pub fn try_collect_active_jobs(\n         &self,\n         kind: D,\n-        make_query: fn(C::Key) -> Q,\n+        make_query: fn(K) -> Q,\n         jobs: &mut QueryMap<D, Q>,\n     ) -> Option<()> {\n         // We use try_lock_shards here since we are called from the\n@@ -122,24 +143,12 @@ where\n     }\n }\n \n-impl<D, Q, C: QueryCache> Default for QueryState<D, Q, C> {\n-    fn default() -> QueryState<D, Q, C> {\n-        QueryState {\n-            cache: C::default(),\n-            shards: Default::default(),\n-            #[cfg(debug_assertions)]\n-            cache_hits: AtomicUsize::new(0),\n-        }\n+impl<D, Q, K> Default for QueryState<D, Q, K> {\n+    fn default() -> QueryState<D, Q, K> {\n+        QueryState { shards: Default::default() }\n     }\n }\n \n-/// Values used when checking a query cache which can be reused on a cache-miss to execute the query.\n-pub struct QueryLookup<'tcx, D, Q, K, C> {\n-    pub(super) key_hash: u64,\n-    shard: usize,\n-    pub(super) lock: LockGuard<'tcx, QueryStateShard<D, Q, K, C>>,\n-}\n-\n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n struct JobOwner<'tcx, D, Q, C>\n@@ -148,7 +157,8 @@ where\n     Q: Clone,\n     C: QueryCache,\n {\n-    state: &'tcx QueryState<D, Q, C>,\n+    state: &'tcx QueryState<D, Q, C::Key>,\n+    cache: &'tcx QueryCacheStore<C>,\n     key: C::Key,\n     id: QueryJobId<D>,\n }\n@@ -170,16 +180,20 @@ where\n     #[inline(always)]\n     fn try_start<'a, 'b, CTX>(\n         tcx: CTX,\n-        state: &'b QueryState<CTX::DepKind, CTX::Query, C>,\n+        state: &'b QueryState<CTX::DepKind, CTX::Query, C::Key>,\n+        cache: &'b QueryCacheStore<C>,\n         span: Span,\n         key: &C::Key,\n-        mut lookup: QueryLookup<'a, CTX::DepKind, CTX::Query, C::Key, C::Sharded>,\n+        lookup: QueryLookup<'a, C::Sharded>,\n         query: &QueryVtable<CTX, C::Key, C::Value>,\n     ) -> TryGetJob<'b, CTX::DepKind, CTX::Query, C>\n     where\n         CTX: QueryContext,\n     {\n-        let lock = &mut *lookup.lock;\n+        mem::drop(lookup.lock);\n+        let shard = lookup.shard;\n+        let mut state_lock = state.shards.get_shard_by_index(shard).lock();\n+        let lock = &mut *state_lock;\n \n         let (latch, mut _query_blocked_prof_timer) = match lock.active.entry((*key).clone()) {\n             Entry::Occupied(mut entry) => {\n@@ -195,7 +209,7 @@ where\n                         };\n \n                         // Create the id of the job we're waiting for\n-                        let id = QueryJobId::new(job.id, lookup.shard, query.dep_kind);\n+                        let id = QueryJobId::new(job.id, shard, query.dep_kind);\n \n                         (job.latch(id), _query_blocked_prof_timer)\n                     }\n@@ -210,18 +224,18 @@ where\n                 lock.jobs = id;\n                 let id = QueryShardJobId(NonZeroU32::new(id).unwrap());\n \n-                let global_id = QueryJobId::new(id, lookup.shard, query.dep_kind);\n+                let global_id = QueryJobId::new(id, shard, query.dep_kind);\n \n                 let job = tcx.current_query_job();\n                 let job = QueryJob::new(id, span, job);\n \n                 entry.insert(QueryResult::Started(job));\n \n-                let owner = JobOwner { state, id: global_id, key: (*key).clone() };\n+                let owner = JobOwner { state, cache, id: global_id, key: (*key).clone() };\n                 return TryGetJob::NotYetStarted(owner);\n             }\n         };\n-        mem::drop(lookup.lock);\n+        mem::drop(state_lock);\n \n         // If we are single-threaded we know that we have cycle error,\n         // so we just return the error.\n@@ -233,7 +247,7 @@ where\n                 span,\n             );\n             let value = query.handle_cycle_error(tcx, error);\n-            state.cache.store_nocache(value)\n+            cache.cache.store_nocache(value)\n         }));\n \n         // With parallel queries we might just have to wait on some other\n@@ -244,11 +258,11 @@ where\n \n             if let Err(cycle) = result {\n                 let value = query.handle_cycle_error(tcx, cycle);\n-                let value = state.cache.store_nocache(value);\n+                let value = cache.cache.store_nocache(value);\n                 return TryGetJob::Cycle(value);\n             }\n \n-            let cached = try_get_cached(tcx, state, key, |value, index| (value.clone(), index))\n+            let cached = try_get_cached(tcx, cache, key, |value, index| (value.clone(), index))\n                 .unwrap_or_else(|_| panic!(\"value must be in cache after waiting\"));\n \n             if let Some(prof_timer) = _query_blocked_prof_timer.take() {\n@@ -265,17 +279,25 @@ where\n         // We can move out of `self` here because we `mem::forget` it below\n         let key = unsafe { ptr::read(&self.key) };\n         let state = self.state;\n+        let cache = self.cache;\n \n         // Forget ourself so our destructor won't poison the query\n         mem::forget(self);\n \n         let (job, result) = {\n-            let mut lock = state.shards.get_shard_by_value(&key).lock();\n-            let job = match lock.active.remove(&key).unwrap() {\n-                QueryResult::Started(job) => job,\n-                QueryResult::Poisoned => panic!(),\n+            let key_hash = hash_for_shard(&key);\n+            let shard = get_shard_index_by_hash(key_hash);\n+            let job = {\n+                let mut lock = state.shards.get_shard_by_index(shard).lock();\n+                match lock.active.remove(&key).unwrap() {\n+                    QueryResult::Started(job) => job,\n+                    QueryResult::Poisoned => panic!(),\n+                }\n+            };\n+            let result = {\n+                let mut lock = cache.shards.get_shard_by_index(shard).lock();\n+                cache.cache.complete(&mut lock, key, result, dep_node_index)\n             };\n-            let result = state.cache.complete(&mut lock.cache, key, result, dep_node_index);\n             (job, result)\n         };\n \n@@ -353,34 +375,35 @@ where\n /// to compute it.\n fn try_get_cached<'a, CTX, C, R, OnHit>(\n     tcx: CTX,\n-    state: &'a QueryState<CTX::DepKind, CTX::Query, C>,\n+    cache: &'a QueryCacheStore<C>,\n     key: &C::Key,\n     // `on_hit` can be called while holding a lock to the query cache\n     on_hit: OnHit,\n-) -> Result<R, QueryLookup<'a, CTX::DepKind, CTX::Query, C::Key, C::Sharded>>\n+) -> Result<R, QueryLookup<'a, C::Sharded>>\n where\n     C: QueryCache,\n     CTX: QueryContext,\n     OnHit: FnOnce(&C::Stored, DepNodeIndex) -> R,\n {\n-    state.cache.lookup(state, &key, |value, index| {\n+    cache.cache.lookup(cache, &key, |value, index| {\n         if unlikely!(tcx.profiler().enabled()) {\n             tcx.profiler().query_cache_hit(index.into());\n         }\n         #[cfg(debug_assertions)]\n         {\n-            state.cache_hits.fetch_add(1, Ordering::Relaxed);\n+            cache.cache_hits.fetch_add(1, Ordering::Relaxed);\n         }\n         on_hit(value, index)\n     })\n }\n \n fn try_execute_query<CTX, C>(\n     tcx: CTX,\n-    state: &QueryState<CTX::DepKind, CTX::Query, C>,\n+    state: &QueryState<CTX::DepKind, CTX::Query, C::Key>,\n+    cache: &QueryCacheStore<C>,\n     span: Span,\n     key: C::Key,\n-    lookup: QueryLookup<'_, CTX::DepKind, CTX::Query, C::Key, C::Sharded>,\n+    lookup: QueryLookup<'_, C::Sharded>,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) -> C::Stored\n where\n@@ -389,7 +412,7 @@ where\n     CTX: QueryContext,\n {\n     let job = match JobOwner::<'_, CTX::DepKind, CTX::Query, C>::try_start(\n-        tcx, state, span, &key, lookup, query,\n+        tcx, state, cache, span, &key, lookup, query,\n     ) {\n         TryGetJob::NotYetStarted(job) => job,\n         TryGetJob::Cycle(result) => return result,\n@@ -604,7 +627,8 @@ where\n #[inline(never)]\n fn get_query_impl<CTX, C>(\n     tcx: CTX,\n-    state: &QueryState<CTX::DepKind, CTX::Query, C>,\n+    state: &QueryState<CTX::DepKind, CTX::Query, C::Key>,\n+    cache: &QueryCacheStore<C>,\n     span: Span,\n     key: C::Key,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n@@ -614,13 +638,13 @@ where\n     C: QueryCache,\n     C::Key: crate::dep_graph::DepNodeParams<CTX>,\n {\n-    let cached = try_get_cached(tcx, state, &key, |value, index| {\n+    let cached = try_get_cached(tcx, cache, &key, |value, index| {\n         tcx.dep_graph().read_index(index);\n         value.clone()\n     });\n     match cached {\n         Ok(value) => value,\n-        Err(lookup) => try_execute_query(tcx, state, span, key, lookup, query),\n+        Err(lookup) => try_execute_query(tcx, state, cache, span, key, lookup, query),\n     }\n }\n \n@@ -667,7 +691,8 @@ where\n #[inline(never)]\n fn force_query_impl<CTX, C>(\n     tcx: CTX,\n-    state: &QueryState<CTX::DepKind, CTX::Query, C>,\n+    state: &QueryState<CTX::DepKind, CTX::Query, C::Key>,\n+    cache: &QueryCacheStore<C>,\n     key: C::Key,\n     span: Span,\n     dep_node: DepNode<CTX::DepKind>,\n@@ -680,7 +705,7 @@ fn force_query_impl<CTX, C>(\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n \n-    let cached = try_get_cached(tcx, state, &key, |_, _| {\n+    let cached = try_get_cached(tcx, cache, &key, |_, _| {\n         // Cache hit, do nothing\n     });\n \n@@ -690,7 +715,7 @@ fn force_query_impl<CTX, C>(\n     };\n \n     let job = match JobOwner::<'_, CTX::DepKind, CTX::Query, C>::try_start(\n-        tcx, state, span, &key, lookup, query,\n+        tcx, state, cache, span, &key, lookup, query,\n     ) {\n         TryGetJob::NotYetStarted(job) => job,\n         TryGetJob::Cycle(_) => return,\n@@ -719,7 +744,7 @@ where\n     }\n \n     debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\", Q::NAME, key, span);\n-    let value = get_query_impl(tcx, Q::query_state(tcx), span, key, query);\n+    let value = get_query_impl(tcx, Q::query_state(tcx), Q::query_cache(tcx), span, key, query);\n     Some(value)\n }\n \n@@ -729,5 +754,5 @@ where\n     Q::Key: crate::dep_graph::DepNodeParams<CTX>,\n     CTX: QueryContext,\n {\n-    force_query_impl(tcx, Q::query_state(tcx), key, span, dep_node, &Q::VTABLE)\n+    force_query_impl(tcx, Q::query_state(tcx), Q::query_cache(tcx), key, span, dep_node, &Q::VTABLE)\n }"}]}