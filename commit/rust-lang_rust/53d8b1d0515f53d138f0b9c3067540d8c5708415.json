{"sha": "53d8b1d0515f53d138f0b9c3067540d8c5708415", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZDhiMWQwNTE1ZjUzZDEzOGYwYjljMzA2NzU0MGQ4YzU3MDg0MTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-07-20T18:14:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-07-20T19:01:32Z"}, "message": "std: Cut down #[inline] annotations where not necessary\n\nThis PR cuts down on a large number of `#[inline(always)]` and `#[inline]`\nannotations in libcore for various core functions. The `#[inline(always)]`\nannotation is almost never needed and is detrimental to debug build times as it\nforces LLVM to perform inlining when it otherwise wouldn't need to in debug\nbuilds. Additionally `#[inline]` is an unnecessary annoation on almost all\ngeneric functions because the function will already be monomorphized into other\ncodegen units and otherwise rarely needs the extra \"help\" from us to tell LLVM\nto inline something.\n\nOverall this PR cut the compile time of a [microbenchmark][1] by 30% from 1s to\n0.7s.\n\n[1]: https://gist.github.com/alexcrichton/a7d70319a45aa60cf36a6a7bf540dd3a", "tree": {"sha": "2a9b021ab507f3e4d28ea47de2a11ff5213f04b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a9b021ab507f3e4d28ea47de2a11ff5213f04b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53d8b1d0515f53d138f0b9c3067540d8c5708415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53d8b1d0515f53d138f0b9c3067540d8c5708415", "html_url": "https://github.com/rust-lang/rust/commit/53d8b1d0515f53d138f0b9c3067540d8c5708415", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53d8b1d0515f53d138f0b9c3067540d8c5708415/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e56bbeb19c48edf6a211448a6fb5b67b29eceec", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e56bbeb19c48edf6a211448a6fb5b67b29eceec", "html_url": "https://github.com/rust-lang/rust/commit/4e56bbeb19c48edf6a211448a6fb5b67b29eceec"}], "stats": {"total": 100, "additions": 50, "deletions": 50}, "files": [{"sha": "d6d3bf99505288cabf189e4a5beb0732cf83c004", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=53d8b1d0515f53d138f0b9c3067540d8c5708415", "patch": "@@ -106,7 +106,7 @@ pub trait Clone : Sized {\n     /// `a.clone_from(&b)` is equivalent to `a = b.clone()` in functionality,\n     /// but can be overridden to reuse the resources of `a` to avoid unnecessary\n     /// allocations.\n-    #[inline(always)]\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn clone_from(&mut self, source: &Self) {\n         *self = source.clone()"}, {"sha": "a9f55dc27880b4ef86882eb0ddf0e6193ca804e2", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=53d8b1d0515f53d138f0b9c3067540d8c5708415", "patch": "@@ -168,7 +168,7 @@ pub trait Eq: PartialEq<Self> {\n     //\n     // This should never be implemented by hand.\n     #[doc(hidden)]\n-    #[inline(always)]\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn assert_receiver_is_total_eq(&self) {}\n }"}, {"sha": "91fd01b36d495901c8279f6bf90ca511599fbc2e", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=53d8b1d0515f53d138f0b9c3067540d8c5708415", "patch": "@@ -239,7 +239,7 @@ impl<S: Sip> Hasher<S> {\n     // except for composite types (that includes slices and str hashing because of delimiter).\n     // Without this extra push the compiler is very reluctant to inline delimiter writes,\n     // degrading performance substantially for the most common use cases.\n-    #[inline(always)]\n+    #[inline]\n     fn short_write(&mut self, msg: &[u8]) {\n         debug_assert!(msg.len() <= 8);\n         let length = msg.len();"}, {"sha": "977438051d93b8bf904ece6ef3722b9183f7ad31", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=53d8b1d0515f53d138f0b9c3067540d8c5708415", "patch": "@@ -42,7 +42,7 @@ pub struct NonZero<T: Zeroable>(T);\n impl<T: Zeroable> NonZero<T> {\n     /// Creates an instance of NonZero with the provided value.\n     /// You must indeed ensure that the value is actually \"non-zero\".\n-    #[inline(always)]\n+    #[inline]\n     pub const unsafe fn new(inner: T) -> NonZero<T> {\n         NonZero(inner)\n     }"}, {"sha": "a8094ab932bf6248388aeefb91b652889f7f5a44", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=53d8b1d0515f53d138f0b9c3067540d8c5708415", "patch": "@@ -695,7 +695,7 @@ macro_rules! int_impl {\n         /// assert_eq!((-128i8).wrapping_div(-1), -128);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline(always)]\n+        #[inline]\n         pub fn wrapping_div(self, rhs: Self) -> Self {\n             self.overflowing_div(rhs).0\n         }\n@@ -721,7 +721,7 @@ macro_rules! int_impl {\n         /// assert_eq!((-128i8).wrapping_rem(-1), 0);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline(always)]\n+        #[inline]\n         pub fn wrapping_rem(self, rhs: Self) -> Self {\n             self.overflowing_rem(rhs).0\n         }\n@@ -744,7 +744,7 @@ macro_rules! int_impl {\n         /// assert_eq!((-128i8).wrapping_neg(), -128);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline(always)]\n+        #[inline]\n         pub fn wrapping_neg(self) -> Self {\n             self.overflowing_neg().0\n         }\n@@ -769,7 +769,7 @@ macro_rules! int_impl {\n         /// assert_eq!((-1i8).wrapping_shl(8), -1);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline(always)]\n+        #[inline]\n         pub fn wrapping_shl(self, rhs: u32) -> Self {\n             unsafe {\n                 intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n@@ -796,7 +796,7 @@ macro_rules! int_impl {\n         /// assert_eq!((-128i8).wrapping_shr(8), -128);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline(always)]\n+        #[inline]\n         pub fn wrapping_shr(self, rhs: u32) -> Self {\n             unsafe {\n                 intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n@@ -822,7 +822,7 @@ macro_rules! int_impl {\n         /// assert_eq!((-128i8).wrapping_abs() as u8, 128);\n         /// ```\n         #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n-        #[inline(always)]\n+        #[inline]\n         pub fn wrapping_abs(self) -> Self {\n             if self.is_negative() {\n                 self.wrapping_neg()\n@@ -1831,7 +1831,7 @@ macro_rules! uint_impl {\n         /// assert_eq!(100u8.wrapping_div(10), 10);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline(always)]\n+        #[inline]\n         pub fn wrapping_div(self, rhs: Self) -> Self {\n             self / rhs\n         }\n@@ -1851,7 +1851,7 @@ macro_rules! uint_impl {\n         /// assert_eq!(100u8.wrapping_rem(10), 0);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline(always)]\n+        #[inline]\n         pub fn wrapping_rem(self, rhs: Self) -> Self {\n             self % rhs\n         }\n@@ -1877,7 +1877,7 @@ macro_rules! uint_impl {\n         /// assert_eq!(180u8.wrapping_neg(), (127 + 1) - (180u8 - (127 + 1)));\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline(always)]\n+        #[inline]\n         pub fn wrapping_neg(self) -> Self {\n             self.overflowing_neg().0\n         }\n@@ -1902,7 +1902,7 @@ macro_rules! uint_impl {\n         /// assert_eq!(1u8.wrapping_shl(8), 1);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline(always)]\n+        #[inline]\n         pub fn wrapping_shl(self, rhs: u32) -> Self {\n             unsafe {\n                 intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n@@ -1929,7 +1929,7 @@ macro_rules! uint_impl {\n         /// assert_eq!(128u8.wrapping_shr(8), 128);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[inline(always)]\n+        #[inline]\n         pub fn wrapping_shr(self, rhs: u32) -> Self {\n             unsafe {\n                 intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)"}, {"sha": "acdf685e850abc9cdf5ec3c338144d6c332d3110", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=53d8b1d0515f53d138f0b9c3067540d8c5708415", "patch": "@@ -19,7 +19,7 @@ macro_rules! sh_impl_signed {\n         impl Shl<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n-            #[inline(always)]\n+            #[inline]\n             fn shl(self, other: $f) -> Wrapping<$t> {\n                 if other < 0 {\n                     Wrapping(self.0.wrapping_shr((-other & self::shift_max::$t as $f) as u32))\n@@ -31,7 +31,7 @@ macro_rules! sh_impl_signed {\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n-            #[inline(always)]\n+            #[inline]\n             fn shl_assign(&mut self, other: $f) {\n                 *self = *self << other;\n             }\n@@ -41,7 +41,7 @@ macro_rules! sh_impl_signed {\n         impl Shr<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n-            #[inline(always)]\n+            #[inline]\n             fn shr(self, other: $f) -> Wrapping<$t> {\n                 if other < 0 {\n                     Wrapping(self.0.wrapping_shl((-other & self::shift_max::$t as $f) as u32))\n@@ -53,7 +53,7 @@ macro_rules! sh_impl_signed {\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n-            #[inline(always)]\n+            #[inline]\n             fn shr_assign(&mut self, other: $f) {\n                 *self = *self >> other;\n             }\n@@ -67,15 +67,15 @@ macro_rules! sh_impl_unsigned {\n         impl Shl<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n-            #[inline(always)]\n+            #[inline]\n             fn shl(self, other: $f) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))\n             }\n         }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n-            #[inline(always)]\n+            #[inline]\n             fn shl_assign(&mut self, other: $f) {\n                 *self = *self << other;\n             }\n@@ -85,15 +85,15 @@ macro_rules! sh_impl_unsigned {\n         impl Shr<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n-            #[inline(always)]\n+            #[inline]\n             fn shr(self, other: $f) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))\n             }\n         }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n-            #[inline(always)]\n+            #[inline]\n             fn shr_assign(&mut self, other: $f) {\n                 *self = *self >> other;\n             }\n@@ -127,7 +127,7 @@ macro_rules! wrapping_impl {\n         impl Add for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n-            #[inline(always)]\n+            #[inline]\n             fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_add(other.0))\n             }\n@@ -137,7 +137,7 @@ macro_rules! wrapping_impl {\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl AddAssign for Wrapping<$t> {\n-            #[inline(always)]\n+            #[inline]\n             fn add_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self + other;\n             }\n@@ -147,7 +147,7 @@ macro_rules! wrapping_impl {\n         impl Sub for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n-            #[inline(always)]\n+            #[inline]\n             fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_sub(other.0))\n             }\n@@ -157,7 +157,7 @@ macro_rules! wrapping_impl {\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl SubAssign for Wrapping<$t> {\n-            #[inline(always)]\n+            #[inline]\n             fn sub_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self - other;\n             }\n@@ -167,7 +167,7 @@ macro_rules! wrapping_impl {\n         impl Mul for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n-            #[inline(always)]\n+            #[inline]\n             fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_mul(other.0))\n             }\n@@ -177,7 +177,7 @@ macro_rules! wrapping_impl {\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl MulAssign for Wrapping<$t> {\n-            #[inline(always)]\n+            #[inline]\n             fn mul_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self * other;\n             }\n@@ -187,7 +187,7 @@ macro_rules! wrapping_impl {\n         impl Div for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n-            #[inline(always)]\n+            #[inline]\n             fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_div(other.0))\n             }\n@@ -197,7 +197,7 @@ macro_rules! wrapping_impl {\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl DivAssign for Wrapping<$t> {\n-            #[inline(always)]\n+            #[inline]\n             fn div_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self / other;\n             }\n@@ -207,7 +207,7 @@ macro_rules! wrapping_impl {\n         impl Rem for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n-            #[inline(always)]\n+            #[inline]\n             fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_rem(other.0))\n             }\n@@ -217,7 +217,7 @@ macro_rules! wrapping_impl {\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl RemAssign for Wrapping<$t> {\n-            #[inline(always)]\n+            #[inline]\n             fn rem_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self % other;\n             }\n@@ -227,7 +227,7 @@ macro_rules! wrapping_impl {\n         impl Not for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n-            #[inline(always)]\n+            #[inline]\n             fn not(self) -> Wrapping<$t> {\n                 Wrapping(!self.0)\n             }\n@@ -239,7 +239,7 @@ macro_rules! wrapping_impl {\n         impl BitXor for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n-            #[inline(always)]\n+            #[inline]\n             fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0 ^ other.0)\n             }\n@@ -249,7 +249,7 @@ macro_rules! wrapping_impl {\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl BitXorAssign for Wrapping<$t> {\n-            #[inline(always)]\n+            #[inline]\n             fn bitxor_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self ^ other;\n             }\n@@ -259,7 +259,7 @@ macro_rules! wrapping_impl {\n         impl BitOr for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n-            #[inline(always)]\n+            #[inline]\n             fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0 | other.0)\n             }\n@@ -269,7 +269,7 @@ macro_rules! wrapping_impl {\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl BitOrAssign for Wrapping<$t> {\n-            #[inline(always)]\n+            #[inline]\n             fn bitor_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self | other;\n             }\n@@ -279,7 +279,7 @@ macro_rules! wrapping_impl {\n         impl BitAnd for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n-            #[inline(always)]\n+            #[inline]\n             fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0 & other.0)\n             }\n@@ -289,7 +289,7 @@ macro_rules! wrapping_impl {\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl BitAndAssign for Wrapping<$t> {\n-            #[inline(always)]\n+            #[inline]\n             fn bitand_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self & other;\n             }\n@@ -298,7 +298,7 @@ macro_rules! wrapping_impl {\n         #[stable(feature = \"wrapping_neg\", since = \"1.10.0\")]\n         impl Neg for Wrapping<$t> {\n             type Output = Self;\n-            #[inline(always)]\n+            #[inline]\n             fn neg(self) -> Self {\n                 Wrapping(0) - self\n             }"}, {"sha": "b19e07b8578c0072c3e639ff8c422992edcdf38f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=53d8b1d0515f53d138f0b9c3067540d8c5708415", "patch": "@@ -244,7 +244,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n ///     assert_eq!(std::ptr::read(y), 12);\n /// }\n /// ```\n-#[inline(always)]\n+#[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n     let mut tmp: T = mem::uninitialized();\n@@ -278,7 +278,7 @@ pub unsafe fn read<T>(src: *const T) -> T {\n ///     assert_eq!(std::ptr::read_unaligned(y), 12);\n /// }\n /// ```\n-#[inline(always)]\n+#[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n     let mut tmp: T = mem::uninitialized();"}, {"sha": "fa0c482e55c916ba7fa54591a2bcf9cb76fd047d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=53d8b1d0515f53d138f0b9c3067540d8c5708415", "patch": "@@ -1105,7 +1105,7 @@ impl<'a, T> IntoIterator for &'a mut [T] {\n     }\n }\n \n-#[inline(always)]\n+#[inline]\n fn size_from_ptr<T>(_: *const T) -> usize {\n     mem::size_of::<T>()\n }"}, {"sha": "1df69a1b598e408a0412e40f6fc1a520b58e0990", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=53d8b1d0515f53d138f0b9c3067540d8c5708415", "patch": "@@ -369,7 +369,7 @@ unsafe fn from_raw_parts_mut<'a>(p: *mut u8, len: usize) -> &'a mut str {\n ///\n /// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n /// ```\n-#[inline(always)]\n+#[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n     mem::transmute(v)\n@@ -381,7 +381,7 @@ pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n /// See the immutable version, [`from_utf8_unchecked()`][fromutf8], for more information.\n ///\n /// [fromutf8]: fn.from_utf8_unchecked.html\n-#[inline(always)]\n+#[inline]\n #[unstable(feature = \"str_mut_extras\", issue = \"41119\")]\n pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n     mem::transmute(v)\n@@ -1380,7 +1380,7 @@ fn contains_nonascii(x: usize) -> bool {\n /// returning `true` in that case, or, if it is invalid, `false` with\n /// `iter` reset such that it is pointing at the first byte in the\n /// invalid sequence.\n-#[inline(always)]\n+#[inline]\n fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n     let mut index = 0;\n     let len = v.len();"}, {"sha": "3c9c1d6cab4790477c177be0f83ebf1928c0e040", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d8b1d0515f53d138f0b9c3067540d8c5708415/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=53d8b1d0515f53d138f0b9c3067540d8c5708415", "patch": "@@ -668,7 +668,7 @@ unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b> {\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn next_match(&mut self) -> Option<(usize, usize)> {\n         match self.searcher {\n             StrSearcherImpl::Empty(..) => {\n@@ -936,7 +936,7 @@ impl TwoWaySearcher {\n         bytes.iter().fold(0, |a, &b| (1 << (b & 0x3f)) | a)\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn byteset_contains(&self, byte: u8) -> bool {\n         (self.byteset >> ((byte & 0x3f) as usize)) & 1 != 0\n     }\n@@ -946,7 +946,7 @@ impl TwoWaySearcher {\n     // left to right. If v matches, we try to match u by scanning right to left.\n     // How far we can jump when we encounter a mismatch is all based on the fact\n     // that (u, v) is a critical factorization for the needle.\n-    #[inline(always)]\n+    #[inline]\n     fn next<S>(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n         -> S::Output\n         where S: TwoWayStrategy"}]}