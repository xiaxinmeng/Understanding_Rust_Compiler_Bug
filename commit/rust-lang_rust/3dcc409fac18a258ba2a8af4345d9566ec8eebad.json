{"sha": "3dcc409fac18a258ba2a8af4345d9566ec8eebad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkY2M0MDlmYWMxOGEyNThiYTJhOGFmNDM0NWQ5NTY2ZWM4ZWViYWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-29T13:32:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-29T13:32:19Z"}, "message": "auto merge of #19549 : huonw/rust/middle-ty-2, r=nikomatsakis\n\nThis takes building `librustc/lib.rs` from using 696 MB to 588 (`rustc --no-trans`), and 1.99 GB to 1.87 (`rustc -O`). It also reduces `sty` down to 32 bytes on platforms with 64-bit pointers, at the expense of some more side-tables in `ctxt`. I'm sure there's more gains to be had from reducing the size of the side tables (e.g. by making the actual things they're storing smaller).\r\n\r\nr? @nikomatsakis", "tree": {"sha": "140cd42aa68752ae7760bf9f2765bf1ff8835189", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/140cd42aa68752ae7760bf9f2765bf1ff8835189"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dcc409fac18a258ba2a8af4345d9566ec8eebad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dcc409fac18a258ba2a8af4345d9566ec8eebad", "html_url": "https://github.com/rust-lang/rust/commit/3dcc409fac18a258ba2a8af4345d9566ec8eebad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dcc409fac18a258ba2a8af4345d9566ec8eebad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25fb12b8a5411901675ede6b147bbc6c0b7437b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/25fb12b8a5411901675ede6b147bbc6c0b7437b7", "html_url": "https://github.com/rust-lang/rust/commit/25fb12b8a5411901675ede6b147bbc6c0b7437b7"}, {"sha": "91db254c81f3c90d5d9d8b5db2660a918efef8bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/91db254c81f3c90d5d9d8b5db2660a918efef8bb", "html_url": "https://github.com/rust-lang/rust/commit/91db254c81f3c90d5d9d8b5db2660a918efef8bb"}], "stats": {"total": 1196, "additions": 697, "deletions": 499}, "files": [{"sha": "9ce344586fd99a595e1a309cab064e8dce55f694", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -1598,15 +1598,15 @@ impl LintPass for MissingCopyImplementations {\n                 }\n                 ty::mk_struct(cx.tcx,\n                               ast_util::local_def(item.id),\n-                              Substs::empty())\n+                              cx.tcx.mk_substs(Substs::empty()))\n             }\n             ast::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return\n                 }\n                 ty::mk_enum(cx.tcx,\n                             ast_util::local_def(item.id),\n-                            Substs::empty())\n+                            cx.tcx.mk_substs(Substs::empty()))\n             }\n             _ => return,\n         };"}, {"sha": "4447af809e4b208ae461a2926d59561a9e062b78", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -1449,7 +1449,7 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n         let space = subst::ParamSpace::from_uint(reader::doc_as_u64(doc) as uint);\n \n         let doc = reader::get_doc(rp_doc, tag_region_param_def_index);\n-        let index = reader::doc_as_u64(doc) as uint;\n+        let index = reader::doc_as_u64(doc) as u32;\n \n         let mut bounds = Vec::new();\n         reader::tagged_docs(rp_doc, tag_items_data_region, |p| {"}, {"sha": "9b008f36a9646fcf9c9d5227a0732ba2e08b225f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -262,8 +262,8 @@ fn parse_substs<'a, 'tcx>(st: &mut PState<'a, 'tcx>,\n     let types =\n         parse_vec_per_param_space(st, |st| parse_ty(st, |x,y| conv(x,y)));\n \n-    return subst::Substs { types: types,\n-                           regions: regions };\n+    subst::Substs { types: types,\n+                    regions: regions }\n }\n \n fn parse_region_substs(st: &mut PState, conv: conv_did) -> subst::RegionSubsts {\n@@ -281,7 +281,7 @@ fn parse_region_substs(st: &mut PState, conv: conv_did) -> subst::RegionSubsts {\n fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::BoundRegion {\n     match next(st) {\n         'a' => {\n-            let id = parse_uint(st);\n+            let id = parse_u32(st);\n             assert_eq!(next(st), '|');\n             ty::BrAnon(id)\n         }\n@@ -291,7 +291,7 @@ fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::BoundRegion {\n             ty::BrNamed(def, ident.name)\n         }\n         'f' => {\n-            let id = parse_uint(st);\n+            let id = parse_u32(st);\n             assert_eq!(next(st), '|');\n             ty::BrFresh(id)\n         }\n@@ -304,7 +304,7 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n     match next(st) {\n       'b' => {\n         assert_eq!(next(st), '[');\n-        let id = ty::DebruijnIndex::new(parse_uint(st));\n+        let id = ty::DebruijnIndex::new(parse_u32(st));\n         assert_eq!(next(st), '|');\n         let br = parse_bound_region(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n@@ -316,7 +316,7 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n         assert_eq!(next(st), '|');\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n-        let index = parse_uint(st);\n+        let index = parse_u32(st);\n         assert_eq!(next(st), '|');\n         let nm = token::str_to_ident(parse_str(st, ']')[]);\n         ty::ReEarlyBound(node_id, space, index, nm.name)\n@@ -380,7 +380,7 @@ fn parse_trait_ref<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n                              -> ty::TraitRef<'tcx> {\n     let def = parse_def(st, NominalType, |x,y| conv(x,y));\n     let substs = parse_substs(st, |x,y| conv(x,y));\n-    ty::TraitRef {def_id: def, substs: substs}\n+    ty::TraitRef {def_id: def, substs: st.tcx.mk_substs(substs)}\n }\n \n fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n@@ -409,7 +409,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n         let def = parse_def(st, NominalType, |x,y| conv(x,y));\n         let substs = parse_substs(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n-        return ty::mk_enum(st.tcx, def, substs);\n+        return ty::mk_enum(st.tcx, def, st.tcx.mk_substs(substs));\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n@@ -421,7 +421,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n       'p' => {\n         let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n         debug!(\"parsed ty_param: did={}\", did);\n-        let index = parse_uint(st);\n+        let index = parse_u32(st);\n         assert_eq!(next(st), '|');\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n@@ -432,7 +432,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n       '&' => {\n         let r = parse_region(st, |x,y| conv(x,y));\n         let mt = parse_mt(st, |x,y| conv(x,y));\n-        return ty::mk_rptr(st.tcx, r, mt);\n+        return ty::mk_rptr(st.tcx, st.tcx.mk_region(r), mt);\n       }\n       'V' => {\n         let t = parse_ty(st, |x,y| conv(x,y));\n@@ -454,10 +454,12 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n       }\n       'F' => {\n           let def_id = parse_def(st, NominalType, |x,y| conv(x,y));\n-          return ty::mk_bare_fn(st.tcx, Some(def_id), parse_bare_fn_ty(st, |x,y| conv(x,y)));\n+          return ty::mk_bare_fn(st.tcx, Some(def_id),\n+                                st.tcx.mk_bare_fn(parse_bare_fn_ty(st, |x,y| conv(x,y))));\n       }\n       'G' => {\n-          return ty::mk_bare_fn(st.tcx, None, parse_bare_fn_ty(st, |x,y| conv(x,y)));\n+          return ty::mk_bare_fn(st.tcx, None,\n+                                st.tcx.mk_bare_fn(parse_bare_fn_ty(st, |x,y| conv(x,y))));\n       }\n       '#' => {\n         let pos = parse_hex(st);\n@@ -490,15 +492,16 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n           let did = parse_def(st, NominalType, |x,y| conv(x,y));\n           let substs = parse_substs(st, |x,y| conv(x,y));\n           assert_eq!(next(st), ']');\n-          return ty::mk_struct(st.tcx, did, substs);\n+          return ty::mk_struct(st.tcx, did, st.tcx.mk_substs(substs));\n       }\n       'k' => {\n           assert_eq!(next(st), '[');\n           let did = parse_def(st, UnboxedClosureSource, |x,y| conv(x,y));\n           let region = parse_region(st, |x,y| conv(x,y));\n           let substs = parse_substs(st, |x,y| conv(x,y));\n           assert_eq!(next(st), ']');\n-          return ty::mk_unboxed_closure(st.tcx, did, region, substs);\n+          return ty::mk_unboxed_closure(st.tcx, did,\n+                  st.tcx.mk_region(region), st.tcx.mk_substs(substs));\n       }\n       'e' => {\n           return ty::mk_err();\n@@ -535,6 +538,13 @@ fn parse_uint(st: &mut PState) -> uint {\n     };\n }\n \n+fn parse_u32(st: &mut PState) -> u32 {\n+    let n = parse_uint(st);\n+    let m = n as u32;\n+    assert_eq!(m as uint, n);\n+    m\n+}\n+\n fn parse_param_space(st: &mut PState) -> subst::ParamSpace {\n     subst::ParamSpace::from_uint(parse_uint(st))\n }\n@@ -697,7 +707,7 @@ fn parse_type_param_def<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n     let def_id = parse_def(st, NominalType, |x,y| conv(x,y));\n     let space = parse_param_space(st);\n     assert_eq!(next(st), '|');\n-    let index = parse_uint(st);\n+    let index = parse_u32(st);\n     assert_eq!(next(st), '|');\n     let associated_with = parse_opt(st, |st| {\n         parse_def(st, NominalType, |x,y| conv(x,y))"}, {"sha": "3e9eaf7eea207776ded94417fa1dff962841df2f", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -83,7 +83,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n                 ast::TyF64 => mywrite!(w, \"MF\"),\n             }\n         }\n-        ty::ty_enum(def, ref substs) => {\n+        ty::ty_enum(def, substs) => {\n             mywrite!(w, \"t[{}|\", (cx.ds)(def));\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n@@ -104,7 +104,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         ty::ty_ptr(mt) => { mywrite!(w, \"*\"); enc_mt(w, cx, mt); }\n         ty::ty_rptr(r, mt) => {\n             mywrite!(w, \"&\");\n-            enc_region(w, cx, r);\n+            enc_region(w, cx, *r);\n             enc_mt(w, cx, mt);\n         }\n         ty::ty_vec(t, sz) => {\n@@ -123,12 +123,12 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n             mywrite!(w, \"f\");\n             enc_closure_ty(w, cx, &**f);\n         }\n-        ty::ty_bare_fn(Some(def_id), ref f) => {\n+        ty::ty_bare_fn(Some(def_id), f) => {\n             mywrite!(w, \"F\");\n             mywrite!(w, \"{}|\", (cx.ds)(def_id));\n             enc_bare_fn_ty(w, cx, f);\n         }\n-        ty::ty_bare_fn(None, ref f) => {\n+        ty::ty_bare_fn(None, f) => {\n             mywrite!(w, \"G\");\n             enc_bare_fn_ty(w, cx, f);\n         }\n@@ -138,14 +138,14 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         ty::ty_param(ParamTy {space, idx: id, def_id: did}) => {\n             mywrite!(w, \"p{}|{}|{}|\", (cx.ds)(did), id, space.to_uint())\n         }\n-        ty::ty_struct(def, ref substs) => {\n+        ty::ty_struct(def, substs) => {\n             mywrite!(w, \"a[{}|\", (cx.ds)(def));\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_unboxed_closure(def, region, ref substs) => {\n+        ty::ty_unboxed_closure(def, region, substs) => {\n             mywrite!(w, \"k[{}|\", (cx.ds)(def));\n-            enc_region(w, cx, region);\n+            enc_region(w, cx, *region);\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n@@ -301,7 +301,7 @@ fn enc_bound_region(w: &mut SeekableMemWriter, cx: &ctxt, br: ty::BoundRegion) {\n pub fn enc_trait_ref<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n                                s: &ty::TraitRef<'tcx>) {\n     mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n-    enc_substs(w, cx, &s.substs);\n+    enc_substs(w, cx, s.substs);\n }\n \n pub fn enc_trait_store(w: &mut SeekableMemWriter, cx: &ctxt, s: ty::TraitStore) {"}, {"sha": "023182df336528b9ac91c2298f3f8eca7d3dae8a", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -39,7 +39,7 @@ pub enum Def {\n     DefAssociatedPath(TyParamProvenance, ast::Ident),\n     DefTrait(ast::DefId),\n     DefPrimTy(ast::PrimTy),\n-    DefTyParam(ParamSpace, ast::DefId, uint),\n+    DefTyParam(ParamSpace, ast::DefId, u32),\n     DefUse(ast::DefId),\n     DefUpvar(ast::NodeId,  // id of closed over local\n              ast::NodeId,  // expr node that creates the closure"}, {"sha": "1dfd602794f80fdcbf29cef8a924ce097332af85", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -767,7 +767,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         // Select just those fields of the `with`\n         // expression that will actually be used\n         let with_fields = match with_cmt.ty.sty {\n-            ty::ty_struct(did, ref substs) => {\n+            ty::ty_struct(did, substs) => {\n                 ty::struct_fields(self.tcx(), did, substs)\n             }\n             _ => {\n@@ -861,7 +861,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,\n-                                         r, bk, AutoRef);\n+                                         *r, bk, AutoRef);\n                 }\n             }\n         }\n@@ -1271,4 +1271,3 @@ fn copy_or_move<'tcx>(tcx: &ty::ctxt<'tcx>,\n         Copy\n     }\n }\n-"}, {"sha": "13017da508d28eada44d42e871878c6540ddf07c", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -174,7 +174,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         self.unpack_actual_value(a, |a| {\n             match a.sty {\n-                ty::ty_bare_fn(Some(a_def_id), ref a_f) => {\n+                ty::ty_bare_fn(Some(a_def_id), a_f) => {\n                     // Function items are coercible to any closure\n                     // type; function pointers are not (that would\n                     // require double indirection).\n@@ -230,7 +230,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         };\n \n         let a_borrowed = ty::mk_rptr(self.tcx(),\n-                                     r_borrow,\n+                                     self.tcx().mk_region(r_borrow),\n                                      mt {ty: inner_ty, mutbl: mutbl_b});\n         try!(sub.tys(a_borrowed, b));\n \n@@ -271,7 +271,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             let coercion = Coercion(self.get_ref().trace.clone());\n                             let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n                             let ty = ty::mk_rptr(self.tcx(),\n-                                                 r_borrow,\n+                                                 self.tcx().mk_region(r_borrow),\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n@@ -358,7 +358,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                                              bounds: bounds },\n                                                ty_a)))\n                 }\n-                (&ty::ty_struct(did_a, ref substs_a), &ty::ty_struct(did_b, ref substs_b))\n+                (&ty::ty_struct(did_a, substs_a), &ty::ty_struct(did_b, substs_b))\n                   if did_a == did_b => {\n                     debug!(\"unsizing a struct\");\n                     // Try unsizing each type param in turn to see if we end up with ty_b.\n@@ -383,7 +383,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                 // Check that the whole types match.\n                                 let mut new_substs = substs_a.clone();\n                                 new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n-                                let ty = ty::mk_struct(tcx, did_a, new_substs);\n+                                let ty = ty::mk_struct(tcx, did_a, tcx.mk_substs(new_substs));\n                                 if self.get_ref().infcx.try(|_| sub.tys(ty, ty_b)).is_err() {\n                                     debug!(\"Unsized type parameter '{}', but still \\\n                                             could not match types {} and {}\",\n@@ -424,7 +424,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let r_a = self.get_ref().infcx.next_region_var(coercion);\n \n         self.coerce_object(a, b, b_mutbl,\n-                           |tr| ty::mk_rptr(tcx, r_a, ty::mt{ mutbl: b_mutbl, ty: tr }),\n+                           |tr| ty::mk_rptr(tcx, tcx.mk_region(r_a),\n+                                            ty::mt{ mutbl: b_mutbl, ty: tr }),\n                            || AutoPtr(r_a, b_mutbl, None))\n     }\n \n@@ -486,7 +487,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                b.repr(self.tcx()));\n \n         match a.sty {\n-            ty::ty_bare_fn(Some(a_def_id), ref f) => {\n+            ty::ty_bare_fn(Some(a_def_id), f) => {\n                 self.coerce_from_fn_item(a, a_def_id, f, b)\n             }\n             _ => {\n@@ -498,7 +499,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     fn coerce_from_fn_item(&self,\n                            a: Ty<'tcx>,\n                            fn_def_id_a: ast::DefId,\n-                           fn_ty_a: &ty::BareFnTy<'tcx>,\n+                           fn_ty_a: &'tcx ty::BareFnTy<'tcx>,\n                            b: Ty<'tcx>)\n                            -> CoerceResult<'tcx> {\n         /*!\n@@ -527,7 +528,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     Ok(Some(adj))\n                 }\n                 ty::ty_bare_fn(None, _) => {\n-                    let a_fn_pointer = ty::mk_bare_fn(self.tcx(), None, (*fn_ty_a).clone());\n+                    let a_fn_pointer = ty::mk_bare_fn(self.tcx(), None, fn_ty_a);\n                     try!(self.subtype(a_fn_pointer, b));\n                     Ok(Some(ty::AdjustReifyFnPointer(fn_def_id_a)))\n                 }"}, {"sha": "04ae0a5a6043219220c9d5cb1ea46231438d5a9a", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -343,8 +343,8 @@ pub trait Combine<'tcx> {\n         if a.def_id != b.def_id {\n             Err(ty::terr_traits(expected_found(self, a.def_id, b.def_id)))\n         } else {\n-            let substs = try!(self.substs(a.def_id, &a.substs, &b.substs));\n-            Ok(ty::TraitRef { def_id: a.def_id, substs: substs })\n+            let substs = try!(self.substs(a.def_id, a.substs, b.substs));\n+            Ok(ty::TraitRef { def_id: a.def_id, substs: self.tcx().mk_substs(substs) })\n         }\n     }\n \n@@ -470,13 +470,13 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n         Ok(a)\n       }\n \n-      (&ty::ty_enum(a_id, ref a_substs),\n-       &ty::ty_enum(b_id, ref b_substs))\n+      (&ty::ty_enum(a_id, a_substs),\n+       &ty::ty_enum(b_id, b_substs))\n       if a_id == b_id => {\n           let substs = try!(this.substs(a_id,\n                                           a_substs,\n                                           b_substs));\n-          Ok(ty::mk_enum(tcx, a_id, substs))\n+          Ok(ty::mk_enum(tcx, a_id, tcx.mk_substs(substs)))\n       }\n \n       (&ty::ty_trait(ref a_),\n@@ -487,21 +487,21 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n           Ok(ty::mk_trait(tcx, principal, bounds))\n       }\n \n-      (&ty::ty_struct(a_id, ref a_substs), &ty::ty_struct(b_id, ref b_substs))\n+      (&ty::ty_struct(a_id, a_substs), &ty::ty_struct(b_id, b_substs))\n       if a_id == b_id => {\n             let substs = try!(this.substs(a_id, a_substs, b_substs));\n-            Ok(ty::mk_struct(tcx, a_id, substs))\n+            Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n       }\n \n-      (&ty::ty_unboxed_closure(a_id, a_region, ref a_substs),\n-       &ty::ty_unboxed_closure(b_id, b_region, ref b_substs))\n+      (&ty::ty_unboxed_closure(a_id, a_region, a_substs),\n+       &ty::ty_unboxed_closure(b_id, b_region, b_substs))\n       if a_id == b_id => {\n           // All ty_unboxed_closure types with the same id represent\n           // the (anonymous) type of the same closure expression. So\n           // all of their regions should be equated.\n-          let region = try!(this.equate().regions(a_region, b_region));\n+          let region = try!(this.equate().regions(*a_region, *b_region));\n           let substs = try!(this.substs_variances(None, a_substs, b_substs));\n-          Ok(ty::mk_unboxed_closure(tcx, a_id, region, substs))\n+          Ok(ty::mk_unboxed_closure(tcx, a_id, tcx.mk_region(region), tcx.mk_substs(substs)))\n       }\n \n       (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n@@ -515,7 +515,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n       }\n \n       (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n-            let r = try!(this.contraregions(a_r, b_r));\n+            let r = try!(this.contraregions(*a_r, *b_r));\n             // FIXME(14985)  If we have mutable references to trait objects, we\n             // used to use covariant subtyping. I have preserved this behaviour,\n             // even though it is probably incorrect. So don't go down the usual\n@@ -527,7 +527,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n                 }\n                 _ => try!(this.mts(a_mt, b_mt))\n             };\n-            Ok(ty::mk_rptr(tcx, r, mt))\n+            Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n       }\n \n       (&ty::ty_vec(a_t, Some(sz_a)), &ty::ty_vec(b_t, Some(sz_b))) => {\n@@ -568,11 +568,11 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n         }\n       }\n \n-        (&ty::ty_bare_fn(a_opt_def_id, ref a_fty), &ty::ty_bare_fn(b_opt_def_id, ref b_fty))\n+        (&ty::ty_bare_fn(a_opt_def_id, a_fty), &ty::ty_bare_fn(b_opt_def_id, b_fty))\n             if a_opt_def_id == b_opt_def_id =>\n         {\n             let fty = try!(this.bare_fn_tys(a_fty, b_fty));\n-            Ok(ty::mk_bare_fn(tcx, a_opt_def_id, fty))\n+            Ok(ty::mk_bare_fn(tcx, a_opt_def_id, tcx.mk_bare_fn(fty)))\n         }\n \n       (&ty::ty_closure(ref a_fty), &ty::ty_closure(ref b_fty)) => {\n@@ -813,5 +813,3 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n         self.infcx.next_region_var(MiscVariable(self.span))\n     }\n }\n-\n-"}, {"sha": "2f62858071f6a9204f4e9119ba03bbae9d8c7a98", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -870,11 +870,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n struct RebuildPathInfo<'a> {\n     path: &'a ast::Path,\n     // indexes to insert lifetime on path.lifetimes\n-    indexes: Vec<uint>,\n+    indexes: Vec<u32>,\n     // number of lifetimes we expect to see on the type referred by `path`\n     // (e.g., expected=1 for struct Foo<'a>)\n-    expected: uint,\n-    anon_nums: &'a HashSet<uint>,\n+    expected: u32,\n+    anon_nums: &'a HashSet<u32>,\n     region_names: &'a HashSet<ast::Name>\n }\n \n@@ -885,8 +885,8 @@ struct Rebuilder<'a, 'tcx: 'a> {\n     generics: &'a ast::Generics,\n     same_regions: &'a [SameRegions],\n     life_giver: &'a LifeGiver,\n-    cur_anon: Cell<uint>,\n-    inserted_anons: RefCell<HashSet<uint>>,\n+    cur_anon: Cell<u32>,\n+    inserted_anons: RefCell<HashSet<u32>>,\n }\n \n enum FreshOrKept {\n@@ -976,7 +976,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n \n     fn extract_anon_nums_and_names(&self, same_regions: &SameRegions)\n-                                   -> (HashSet<uint>, HashSet<ast::Name>) {\n+                                   -> (HashSet<u32>, HashSet<ast::Name>) {\n         let mut anon_nums = HashSet::new();\n         let mut region_names = HashSet::new();\n         for br in same_regions.regions.iter() {\n@@ -1008,7 +1008,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         all_region_names\n     }\n \n-    fn inc_cur_anon(&self, n: uint) {\n+    fn inc_cur_anon(&self, n: u32) {\n         let anon = self.cur_anon.get();\n         self.cur_anon.set(anon+n);\n     }\n@@ -1021,12 +1021,12 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         self.cur_anon.set(anon);\n     }\n \n-    fn inc_and_offset_cur_anon(&self, n: uint) {\n+    fn inc_and_offset_cur_anon(&self, n: u32) {\n         self.inc_cur_anon(n);\n         self.offset_cur_anon();\n     }\n \n-    fn track_anon(&self, anon: uint) {\n+    fn track_anon(&self, anon: u32) {\n         self.inserted_anons.borrow_mut().insert(anon);\n     }\n \n@@ -1070,13 +1070,13 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     let lifetimes = last_seg.parameters.lifetimes();\n                     for (i, lt) in lifetimes.iter().enumerate() {\n                         if region_names.contains(&lt.name) {\n-                            insert.push(i);\n+                            insert.push(i as u32);\n                         }\n                     }\n                     let rebuild_info = RebuildPathInfo {\n                         path: &tr.path,\n                         indexes: insert,\n-                        expected: lifetimes.len(),\n+                        expected: lifetimes.len() as u32,\n                         anon_nums: &HashSet::new(),\n                         region_names: region_names\n                     };\n@@ -1096,7 +1096,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     fn rebuild_expl_self(&self,\n                          expl_self_opt: Option<ast::ExplicitSelf_>,\n                          lifetime: ast::Lifetime,\n-                         anon_nums: &HashSet<uint>,\n+                         anon_nums: &HashSet<u32>,\n                          region_names: &HashSet<ast::Name>)\n                          -> Option<ast::ExplicitSelf_> {\n         match expl_self_opt {\n@@ -1150,7 +1150,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     fn rebuild_args_ty(&self,\n                        inputs: &[ast::Arg],\n                        lifetime: ast::Lifetime,\n-                       anon_nums: &HashSet<uint>,\n+                       anon_nums: &HashSet<u32>,\n                        region_names: &HashSet<ast::Name>)\n                        -> Vec<ast::Arg> {\n         let mut new_inputs = Vec::new();\n@@ -1169,7 +1169,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n     fn rebuild_output(&self, ty: &ast::FunctionRetTy,\n                       lifetime: ast::Lifetime,\n-                      anon_nums: &HashSet<uint>,\n+                      anon_nums: &HashSet<u32>,\n                       region_names: &HashSet<ast::Name>) -> ast::FunctionRetTy {\n         match *ty {\n             ast::Return(ref ret_ty) => ast::Return(\n@@ -1182,7 +1182,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     fn rebuild_arg_ty_or_output(&self,\n                                 ty: &ast::Ty,\n                                 lifetime: ast::Lifetime,\n-                                anon_nums: &HashSet<uint>,\n+                                anon_nums: &HashSet<u32>,\n                                 region_names: &HashSet<ast::Name>)\n                                 -> P<ast::Ty> {\n         let mut new_ty = P(ty.clone());\n@@ -1229,7 +1229,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                             let generics = ty::lookup_item_type(self.tcx, did).generics;\n \n                             let expected =\n-                                generics.regions.len(subst::TypeSpace);\n+                                generics.regions.len(subst::TypeSpace) as u32;\n                             let lifetimes =\n                                 path.segments.last().unwrap().parameters.lifetimes();\n                             let mut insert = Vec::new();\n@@ -1238,15 +1238,15 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                 for (i, a) in range(anon,\n                                                     anon+expected).enumerate() {\n                                     if anon_nums.contains(&a) {\n-                                        insert.push(i);\n+                                        insert.push(i as u32);\n                                     }\n                                     self.track_anon(a);\n                                 }\n                                 self.inc_and_offset_cur_anon(expected);\n                             } else {\n                                 for (i, lt) in lifetimes.iter().enumerate() {\n                                     if region_names.contains(&lt.name) {\n-                                        insert.push(i);\n+                                        insert.push(i as u32);\n                                     }\n                                 }\n                             }\n@@ -1363,7 +1363,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     }\n                 } else {\n                     for (i, lt) in data.lifetimes.iter().enumerate() {\n-                        if indexes.contains(&i) {\n+                        if indexes.contains(&(i as u32)) {\n                             new_lts.push(lifetime);\n                         } else {\n                             new_lts.push(*lt);"}, {"sha": "d8455b8db71ed511df34c0e515cb19ac66f90034", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -41,7 +41,7 @@ use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n \n pub struct TypeFreshener<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    freshen_count: uint,\n+    freshen_count: u32,\n     freshen_map: hash_map::HashMap<ty::InferTy, Ty<'tcx>>,\n }\n \n@@ -59,7 +59,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n                   key: ty::InferTy,\n                   freshener: F)\n                   -> Ty<'tcx> where\n-        F: FnOnce(uint) -> ty::InferTy,\n+        F: FnOnce(u32) -> ty::InferTy,\n     {\n         match opt_ty {\n             Some(ty) => { return ty.fold_with(self); }"}, {"sha": "97fab3bc9395a4796e5a19076d30cb86b3984809", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -33,7 +33,7 @@ use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux::Repr;\n \n use std::cell::{Cell, RefCell};\n-use std::uint;\n+use std::u32;\n use syntax::ast;\n \n mod doc;\n@@ -196,8 +196,8 @@ pub struct RegionVarBindings<'a, 'tcx: 'a> {\n \n     lubs: RefCell<CombineMap>,\n     glbs: RefCell<CombineMap>,\n-    skolemization_count: Cell<uint>,\n-    bound_count: Cell<uint>,\n+    skolemization_count: Cell<u32>,\n+    bound_count: Cell<u32>,\n \n     // The undo log records actions that might later be undone.\n     //\n@@ -219,7 +219,7 @@ pub struct RegionVarBindings<'a, 'tcx: 'a> {\n #[allow(missing_copy_implementations)]\n pub struct RegionSnapshot {\n     length: uint,\n-    skolemization_count: uint,\n+    skolemization_count: u32,\n }\n \n impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n@@ -278,7 +278,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 AddVar(vid) => {\n                     let mut var_origins = self.var_origins.borrow_mut();\n                     var_origins.pop().unwrap();\n-                    assert_eq!(var_origins.len(), vid.index);\n+                    assert_eq!(var_origins.len(), vid.index as uint);\n                 }\n                 AddConstraint(ref constraint) => {\n                     self.constraints.borrow_mut().remove(constraint);\n@@ -303,8 +303,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.skolemization_count.set(snapshot.skolemization_count);\n     }\n \n-    pub fn num_vars(&self) -> uint {\n-        self.var_origins.borrow().len()\n+    pub fn num_vars(&self) -> u32 {\n+        let len = self.var_origins.borrow().len();\n+        // enforce no overflow\n+        assert!(len as u32 as uint == len);\n+        len as u32\n     }\n \n     pub fn new_region_var(&self, origin: RegionVariableOrigin<'tcx>) -> RegionVid {\n@@ -547,7 +550,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         match *self.values.borrow() {\n             None => {\n                 self.tcx.sess.span_bug(\n-                    (*self.var_origins.borrow())[rid.index].span(),\n+                    (*self.var_origins.borrow())[rid.index as uint].span(),\n                     \"attempt to resolve region variable before values have \\\n                      been computed!\")\n             }\n@@ -737,7 +740,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n           (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n-                (*self.var_origins.borrow())[v_id.index].span(),\n+                (*self.var_origins.borrow())[v_id.index as uint].span(),\n                 format!(\"lub_concrete_regions invoked with \\\n                          non-concrete regions: {}, {}\",\n                         a,\n@@ -840,7 +843,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (ReInfer(ReVar(v_id)), _) |\n             (_, ReInfer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n-                    (*self.var_origins.borrow())[v_id.index].span(),\n+                    (*self.var_origins.borrow())[v_id.index as uint].span(),\n                     format!(\"glb_concrete_regions invoked with \\\n                              non-concrete regions: {}, {}\",\n                             a,\n@@ -972,7 +975,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn construct_var_data(&self) -> Vec<VarData> {\n-        Vec::from_fn(self.num_vars(), |_| {\n+        Vec::from_fn(self.num_vars() as uint, |_| {\n             VarData {\n                 // All nodes are initially classified as contracting; during\n                 // the expansion phase, we will shift the classification for\n@@ -1001,14 +1004,14 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                    .repr(self.tcx));\n             match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n-                let b_data = &mut var_data[b_vid.index];\n+                let b_data = &mut var_data[b_vid.index as uint];\n                 self.expand_node(a_region, b_vid, b_data)\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match var_data[a_vid.index].value {\n+                match var_data[a_vid.index as uint].value {\n                   NoValue | ErrorValue => false,\n                   Value(a_region) => {\n-                    let b_node = &mut var_data[b_vid.index];\n+                    let b_node = &mut var_data[b_vid.index as uint];\n                     self.expand_node(a_region, b_vid, b_node)\n                   }\n                 }\n@@ -1089,16 +1092,16 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 false\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match var_data[b_vid.index].value {\n+                match var_data[b_vid.index as uint].value {\n                   NoValue | ErrorValue => false,\n                   Value(b_region) => {\n-                    let a_data = &mut var_data[a_vid.index];\n+                    let a_data = &mut var_data[a_vid.index as uint];\n                     self.contract_node(a_vid, a_data, b_region)\n                   }\n                 }\n               }\n               ConstrainVarSubReg(a_vid, b_region) => {\n-                let a_data = &mut var_data[a_vid.index];\n+                let a_data = &mut var_data[a_vid.index as uint];\n                 self.contract_node(a_vid, a_data, b_region)\n               }\n             }\n@@ -1244,11 +1247,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec = Vec::from_elem(self.num_vars(), uint::MAX);\n+        let mut dup_vec = Vec::from_elem(self.num_vars() as uint, u32::MAX);\n \n         let mut opt_graph = None;\n \n-        for idx in range(0u, self.num_vars()) {\n+        for idx in range(0u, self.num_vars() as uint) {\n             match var_data[idx].value {\n                 Value(_) => {\n                     /* Inference successful */\n@@ -1288,7 +1291,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     }\n                     let graph = opt_graph.as_ref().unwrap();\n \n-                    let node_vid = RegionVid { index: idx };\n+                    let node_vid = RegionVid { index: idx as u32 };\n                     match var_data[idx].classification {\n                         Expanding => {\n                             self.collect_error_for_expanding_node(\n@@ -1305,7 +1308,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n         }\n \n-        Vec::from_fn(self.num_vars(), |idx| var_data[idx].value)\n+        Vec::from_fn(self.num_vars() as uint, |idx| var_data[idx].value)\n     }\n \n     fn construct_graph(&self) -> RegionGraph {\n@@ -1314,28 +1317,28 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let constraints = self.constraints.borrow();\n         let num_edges = constraints.len();\n \n-        let mut graph = graph::Graph::with_capacity(num_vars + 1,\n+        let mut graph = graph::Graph::with_capacity(num_vars as uint + 1,\n                                                     num_edges);\n \n-        for _ in range(0u, num_vars) {\n+        for _ in range(0, num_vars) {\n             graph.add_node(());\n         }\n         let dummy_idx = graph.add_node(());\n \n         for (constraint, _) in constraints.iter() {\n             match *constraint {\n                 ConstrainVarSubVar(a_id, b_id) => {\n-                    graph.add_edge(NodeIndex(a_id.index),\n-                                   NodeIndex(b_id.index),\n+                    graph.add_edge(NodeIndex(a_id.index as uint),\n+                                   NodeIndex(b_id.index as uint),\n                                    *constraint);\n                 }\n                 ConstrainRegSubVar(_, b_id) => {\n                     graph.add_edge(dummy_idx,\n-                                   NodeIndex(b_id.index),\n+                                   NodeIndex(b_id.index as uint),\n                                    *constraint);\n                 }\n                 ConstrainVarSubReg(a_id, _) => {\n-                    graph.add_edge(NodeIndex(a_id.index),\n+                    graph.add_edge(NodeIndex(a_id.index as uint),\n                                    dummy_idx,\n                                    *constraint);\n                 }\n@@ -1349,7 +1352,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         &self,\n         graph: &RegionGraph,\n         var_data: &[VarData],\n-        dup_vec: &mut [uint],\n+        dup_vec: &mut [u32],\n         node_idx: RegionVid,\n         errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n@@ -1387,7 +1390,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n                     errors.push(SubSupConflict(\n-                        (*self.var_origins.borrow())[node_idx.index].clone(),\n+                        (*self.var_origins.borrow())[node_idx.index as uint].clone(),\n                         lower_bound.origin.clone(),\n                         lower_bound.region,\n                         upper_bound.origin.clone(),\n@@ -1398,7 +1401,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n \n         self.tcx.sess.span_bug(\n-            (*self.var_origins.borrow())[node_idx.index].span(),\n+            (*self.var_origins.borrow())[node_idx.index as uint].span(),\n             format!(\"collect_error_for_expanding_node() could not find error \\\n                     for var {}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n@@ -1410,7 +1413,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         &self,\n         graph: &RegionGraph,\n         var_data: &[VarData],\n-        dup_vec: &mut [uint],\n+        dup_vec: &mut [u32],\n         node_idx: RegionVid,\n         errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n@@ -1431,7 +1434,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                   Ok(_) => {}\n                   Err(_) => {\n                     errors.push(SupSupConflict(\n-                        (*self.var_origins.borrow())[node_idx.index].clone(),\n+                        (*self.var_origins.borrow())[node_idx.index as uint].clone(),\n                         upper_bound_1.origin.clone(),\n                         upper_bound_1.region,\n                         upper_bound_2.origin.clone(),\n@@ -1443,7 +1446,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n \n         self.tcx.sess.span_bug(\n-            (*self.var_origins.borrow())[node_idx.index].span(),\n+            (*self.var_origins.borrow())[node_idx.index as uint].span(),\n             format!(\"collect_error_for_contracting_node() could not find error \\\n                      for var {}, upper_bounds={}\",\n                     node_idx,\n@@ -1455,7 +1458,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                 var_data: &[VarData],\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction,\n-                                dup_vec: &mut [uint])\n+                                dup_vec: &mut [u32])\n                                 -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n         struct WalkState<'tcx> {\n             set: FnvHashSet<RegionVid>,\n@@ -1477,12 +1480,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         while !state.stack.is_empty() {\n             let node_idx = state.stack.pop().unwrap();\n-            let classification = var_data[node_idx.index].classification;\n+            let classification = var_data[node_idx.index as uint].classification;\n \n             // check whether we've visited this node on some previous walk\n-            if dup_vec[node_idx.index] == uint::MAX {\n-                dup_vec[node_idx.index] = orig_node_idx.index;\n-            } else if dup_vec[node_idx.index] != orig_node_idx.index {\n+            if dup_vec[node_idx.index as uint] == u32::MAX {\n+                dup_vec[node_idx.index as uint] = orig_node_idx.index;\n+            } else if dup_vec[node_idx.index as uint] != orig_node_idx.index {\n                 state.dup_found = true;\n             }\n \n@@ -1510,7 +1513,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                          dir: Direction) {\n             debug!(\"process_edges(source_vid={}, dir={})\", source_vid, dir);\n \n-            let source_node_index = NodeIndex(source_vid.index);\n+            let source_node_index = NodeIndex(source_vid.index as uint);\n             graph.each_adjacent_edge(source_node_index, dir, |_, edge| {\n                 match edge.data {\n                     ConstrainVarSubVar(from_vid, to_vid) => {\n@@ -1595,7 +1598,7 @@ fn normalize(values: &Vec<VarValue>, r: ty::Region) -> ty::Region {\n }\n \n fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n-    match values[rid.index] {\n+    match values[rid.index as uint] {\n         Value(r) => r,\n         NoValue => ReEmpty, // No constraints, return ty::ReEmpty\n         ErrorValue => ReStatic, // Previously reported error."}, {"sha": "49a1e6f9263125478dee022f1bec603328dfe561", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -15,7 +15,7 @@ use self::UndoEntry::*;\n use middle::ty::{mod, Ty};\n use std::cmp::min;\n use std::mem;\n-use std::uint;\n+use std::u32;\n use util::snapshot_vec as sv;\n \n pub struct TypeVariableTable<'tcx> {\n@@ -67,11 +67,11 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     }\n \n     fn relations<'a>(&'a mut self, a: ty::TyVid) -> &'a mut Vec<Relation> {\n-        relations(self.values.get_mut(a.index))\n+        relations(self.values.get_mut(a.index as uint))\n     }\n \n     pub fn var_diverges<'a>(&'a self, vid: ty::TyVid) -> bool {\n-        self.values.get(vid.index).diverging\n+        self.values.get(vid.index as uint).diverging\n     }\n \n     /// Records that `a <: b`, `a :> b`, or `a == b`, depending on `dir`.\n@@ -95,7 +95,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         stack: &mut Vec<(Ty<'tcx>, RelationDir, ty::TyVid)>)\n     {\n         let old_value = {\n-            let value_ptr = &mut self.values.get_mut(vid.index).value;\n+            let value_ptr = &mut self.values.get_mut(vid.index as uint).value;\n             mem::replace(value_ptr, Known(ty))\n         };\n \n@@ -117,11 +117,11 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             value: Bounded(vec![]),\n             diverging: diverging\n         });\n-        ty::TyVid { index: index }\n+        ty::TyVid { index: index as u32 }\n     }\n \n     pub fn probe(&self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n-        match self.values.get(vid.index).value {\n+        match self.values.get(vid.index as uint).value {\n             Bounded(..) => None,\n             Known(t) => Some(t)\n         }\n@@ -161,7 +161,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n          * unified `V1` with `T1`, this function would return `{T0}`.\n          */\n \n-        let mut new_elem_threshold = uint::MAX;\n+        let mut new_elem_threshold = u32::MAX;\n         let mut escaping_types = Vec::new();\n         let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n         debug!(\"actions_since_snapshot.len() = {}\", actions_since_snapshot.len());\n@@ -173,7 +173,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                     // always be the first one we see). Note that this\n                     // action must precede those variables being\n                     // specified.\n-                    new_elem_threshold = min(new_elem_threshold, index);\n+                    new_elem_threshold = min(new_elem_threshold, index as u32);\n                     debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n                 }\n \n@@ -201,12 +201,12 @@ impl<'tcx> sv::SnapshotVecDelegate<TypeVariableData<'tcx>,UndoEntry> for Delegat\n                action: UndoEntry) {\n         match action {\n             SpecifyVar(vid, relations) => {\n-                values[vid.index].value = Bounded(relations);\n+                values[vid.index as uint].value = Bounded(relations);\n             }\n \n             Relate(a, b) => {\n-                relations(&mut (*values)[a.index]).pop();\n-                relations(&mut (*values)[b.index]).pop();\n+                relations(&mut (*values)[a.index as uint]).pop();\n+                relations(&mut (*values)[b.index as uint]).pop();\n             }\n         }\n     }\n@@ -218,4 +218,3 @@ fn relations<'a>(v: &'a mut TypeVariableData) -> &'a mut Vec<Relation> {\n         Bounded(ref mut relations) => relations\n     }\n }\n-"}, {"sha": "dcf70263c0a43b281973630c4c3dc68e68223de1", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -347,9 +347,9 @@ impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n // Integral type keys\n \n impl<'tcx> UnifyKey<'tcx, Option<IntVarValue>> for ty::IntVid {\n-    fn index(&self) -> uint { self.index }\n+    fn index(&self) -> uint { self.index as uint }\n \n-    fn from_index(i: uint) -> ty::IntVid { ty::IntVid { index: i } }\n+    fn from_index(i: uint) -> ty::IntVid { ty::IntVid { index: i as u32 } }\n \n     fn unification_table<'v>(infcx: &'v InferCtxt)\n         -> &'v RefCell<UnificationTable<ty::IntVid, Option<IntVarValue>>>\n@@ -380,9 +380,9 @@ impl<'tcx> UnifyValue<'tcx> for Option<IntVarValue> { }\n // Floating point type keys\n \n impl<'tcx> UnifyKey<'tcx, Option<ast::FloatTy>> for ty::FloatVid {\n-    fn index(&self) -> uint { self.index }\n+    fn index(&self) -> uint { self.index as uint }\n \n-    fn from_index(i: uint) -> ty::FloatVid { ty::FloatVid { index: i } }\n+    fn from_index(i: uint) -> ty::FloatVid { ty::FloatVid { index: i as u32 } }\n \n     fn unification_table<'v>(infcx: &'v InferCtxt)\n         -> &'v RefCell<UnificationTable<ty::FloatVid, Option<ast::FloatTy>>>"}, {"sha": "ba18c02f52dc1e68b45432232edff069024e3796", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -37,7 +37,7 @@ fn type_size_is_affected_by_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>, typ: Ty<\n                 // No need to continue; we now know the result.\n                 false\n             }\n-            ty::ty_enum(did, ref substs) => {\n+            ty::ty_enum(did, substs) => {\n                 for enum_variant in (*ty::enum_variants(tcx, did)).iter() {\n                     for argument_type in enum_variant.args.iter() {\n                         let argument_type = argument_type.subst(tcx, substs);\n@@ -51,7 +51,7 @@ fn type_size_is_affected_by_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>, typ: Ty<\n                 // Don't traverse substitutions.\n                 false\n             }\n-            ty::ty_struct(did, ref substs) => {\n+            ty::ty_struct(did, substs) => {\n                 for field in ty::struct_fields(tcx, did, substs).iter() {\n                     result = result ||\n                         type_size_is_affected_by_type_parameters(tcx,"}, {"sha": "87841c7675b9168d29b6ca76595cbfe414f58203", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -204,7 +204,7 @@ pub fn opt_deref_kind(t: Ty) -> Option<deref_kind> {\n \n         ty::ty_rptr(r, mt) => {\n             let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n-            Some(deref_ptr(BorrowedPtr(kind, r)))\n+            Some(deref_ptr(BorrowedPtr(kind, *r)))\n         }\n \n         ty::ty_closure(box ty::ClosureTy {\n@@ -1071,7 +1071,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                           -> (ast::Mutability, ty::Region) {\n             match slice_ty.sty {\n                 ty::ty_rptr(r, ref mt) => match mt.ty.sty {\n-                    ty::ty_vec(_, None) => (mt.mutbl, r),\n+                    ty::ty_vec(_, None) => (mt.mutbl, *r),\n                     _ => vec_slice_info(tcx, pat, mt.ty),\n                 },\n "}, {"sha": "22dea3be1d4b65a236d5e19a19518a5517405f1d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -37,7 +37,7 @@ use util::nodemap::NodeMap;\n pub enum DefRegion {\n     DefStaticRegion,\n     DefEarlyBoundRegion(/* space */ subst::ParamSpace,\n-                        /* index */ uint,\n+                        /* index */ u32,\n                         /* lifetime decl */ ast::NodeId),\n     DefLateBoundRegion(ty::DebruijnIndex,\n                        /* lifetime decl */ ast::NodeId),\n@@ -508,10 +508,10 @@ impl<'a> LifetimeContext<'a> {\n \n fn search_lifetimes<'a>(lifetimes: &'a Vec<ast::LifetimeDef>,\n                     lifetime_ref: &ast::Lifetime)\n-                    -> Option<(uint, &'a ast::Lifetime)> {\n+                    -> Option<(u32, &'a ast::Lifetime)> {\n     for (i, lifetime_decl) in lifetimes.iter().enumerate() {\n         if lifetime_decl.lifetime.name == lifetime_ref.name {\n-            return Some((i, &lifetime_decl.lifetime));\n+            return Some((i as u32, &lifetime_decl.lifetime));\n         }\n     }\n     return None;"}, {"sha": "abacad7d37c90f58bc07a7f9902d730a9524cf7c", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -98,10 +98,10 @@ impl<'tcx> Substs<'tcx> {\n     }\n \n     pub fn type_for_def(&self, ty_param_def: &ty::TypeParameterDef) -> Ty<'tcx> {\n-        *self.types.get(ty_param_def.space, ty_param_def.index)\n+        *self.types.get(ty_param_def.space, ty_param_def.index as uint)\n     }\n \n-    pub fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+    pub fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.types.iter().any(|&t| ty::type_escapes_depth(t, depth)) || {\n             match self.regions {\n                 ErasedRegions =>\n@@ -582,7 +582,7 @@ struct SubstFolder<'a, 'tcx: 'a> {\n     ty_stack_depth: uint,\n \n     // Number of region binders we have passed through while doing the substitution\n-    region_binders_passed: uint,\n+    region_binders_passed: u32,\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n@@ -607,7 +607,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                 match self.substs.regions {\n                     ErasedRegions => ty::ReStatic,\n                     NonerasedRegions(ref regions) =>\n-                        match regions.opt_get(space, i) {\n+                        match regions.opt_get(space, i as uint) {\n                             Some(&r) => {\n                                 self.shift_region_through_binders(r)\n                             }\n@@ -663,7 +663,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n impl<'a,'tcx> SubstFolder<'a,'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n-        let opt_ty = self.substs.types.opt_get(p.space, p.idx);\n+        let opt_ty = self.substs.types.opt_get(p.space, p.idx as uint);\n         let ty = match opt_ty {\n             Some(t) => *t,\n             None => {"}, {"sha": "b10b1ce35c4361c9ba379b9985842b528bb25d32", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -806,7 +806,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // provide an impl, but only for suitable `fn` pointers\n-            ty::ty_bare_fn(_, ty::BareFnTy {\n+            ty::ty_bare_fn(_, &ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n@@ -1100,7 +1100,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         } else {\n                             // Recursively check all supertraits to find out if any further\n                             // bounds are required and thus we must fulfill.\n-                            let tmp_tr = data.principal_trait_ref_with_self_ty(ty::mk_err());\n+                            let tmp_tr = data.principal_trait_ref_with_self_ty(self.tcx(),\n+                                                                               ty::mk_err());\n                             for tr in util::supertraits(self.tcx(), tmp_tr) {\n                                 let td = ty::lookup_trait_def(self.tcx(), tr.def_id());\n \n@@ -1210,7 +1211,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(If(tys.clone()))\n             }\n \n-            ty::ty_unboxed_closure(def_id, _, ref substs) => {\n+            ty::ty_unboxed_closure(def_id, _, substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n                 // closures particularly, we need the results of\n                 // inference to decide how to reflect the type of each\n@@ -1248,7 +1249,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::ty_struct(def_id, ref substs) => {\n+            ty::ty_struct(def_id, substs) => {\n                 let types: Vec<Ty> =\n                     ty::struct_fields(self.tcx(), def_id, substs)\n                     .iter()\n@@ -1257,7 +1258,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nominal(self, bound, def_id, types)\n             }\n \n-            ty::ty_enum(def_id, ref substs) => {\n+            ty::ty_enum(def_id, substs) => {\n                 let types: Vec<Ty> =\n                     ty::substd_enum_variants(self.tcx(), def_id, substs)\n                     .iter()\n@@ -1549,7 +1550,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         let sig = match self_ty.sty {\n-            ty::ty_bare_fn(_, ty::BareFnTy {\n+            ty::ty_bare_fn(_, &ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 ref sig\n@@ -1574,7 +1575,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self_ty);\n         let trait_ref = Rc::new(ty::Binder(ty::TraitRef {\n             def_id: obligation.trait_ref.def_id(),\n-            substs: substs,\n+            substs: self.tcx().mk_substs(substs),\n         }));\n \n         try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n@@ -1615,7 +1616,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 obligation.self_ty());\n         let trait_ref = Rc::new(ty::Binder(ty::TraitRef {\n             def_id: obligation.trait_ref.def_id(),\n-            substs: substs,\n+            substs: self.tcx().mk_substs(substs),\n         }));\n \n         debug!(\"confirm_unboxed_closure_candidate(closure_def_id={}, trait_ref={})\","}, {"sha": "e75478b32438fe54e005f85db086e93b4ac11886", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -1,4 +1,3 @@\n-\n // Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -276,7 +275,7 @@ pub fn poly_trait_ref_for_builtin_bound<'tcx>(\n         Ok(def_id) => {\n             Ok(Rc::new(ty::Binder(ty::TraitRef {\n                 def_id: def_id,\n-                substs: Substs::empty().with_self_ty(param_ty)\n+                substs: tcx.mk_substs(Substs::empty().with_self_ty(param_ty))\n             })))\n         }\n         Err(e) => {"}, {"sha": "398e52cf0430b3082b149f457df4a9d9bbdd9429", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 238, "deletions": 103, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -410,7 +410,7 @@ pub fn type_of_adjust<'tcx>(cx: &ctxt<'tcx>, adj: &AutoAdjustment<'tcx>) -> Opti\n             },\n             &AutoPtr(r, m, Some(box ref autoref)) => {\n                 match type_of_autoref(cx, autoref) {\n-                    Some(ty) => Some(mk_rptr(cx, r, mt {mutbl: m, ty: ty})),\n+                    Some(ty) => Some(mk_rptr(cx, cx.mk_region(r), mt {mutbl: m, ty: ty})),\n                     None => None\n                 }\n             }\n@@ -604,18 +604,42 @@ pub struct TransmuteRestriction<'tcx> {\n     pub id: ast::NodeId,\n }\n \n+/// Internal storage\n+pub struct CtxtArenas<'tcx> {\n+    type_: TypedArena<TyS<'tcx>>,\n+    substs: TypedArena<Substs<'tcx>>,\n+    bare_fn: TypedArena<BareFnTy<'tcx>>,\n+    region: TypedArena<Region>,\n+}\n+\n+impl<'tcx> CtxtArenas<'tcx> {\n+    pub fn new() -> CtxtArenas<'tcx> {\n+        CtxtArenas {\n+            type_: TypedArena::new(),\n+            substs: TypedArena::new(),\n+            bare_fn: TypedArena::new(),\n+            region: TypedArena::new(),\n+        }\n+    }\n+}\n+\n /// The data structure to keep track of all the information that typechecker\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n pub struct ctxt<'tcx> {\n-    /// The arena that types are allocated from.\n-    type_arena: &'tcx TypedArena<TyS<'tcx>>,\n+    /// The arenas that types etc are allocated from.\n+    arenas: &'tcx CtxtArenas<'tcx>,\n \n     /// Specifically use a speedy hash algorithm for this hash map, it's used\n     /// quite often.\n     // FIXME(eddyb) use a FnvHashSet<InternedTy<'tcx>> when equivalent keys can\n     // queried from a HashSet.\n     interner: RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>,\n+    // FIXME as above, use a hashset if equivalent elements can be queried.\n+    substs_interner: RefCell<FnvHashMap<&'tcx Substs<'tcx>, &'tcx Substs<'tcx>>>,\n+    bare_fn_interner: RefCell<FnvHashMap<&'tcx BareFnTy<'tcx>, &'tcx BareFnTy<'tcx>>>,\n+    region_interner: RefCell<FnvHashMap<&'tcx Region, &'tcx Region>>,\n+\n     pub sess: Session,\n     pub def_map: DefMap,\n \n@@ -779,13 +803,87 @@ bitflags! {\n     }\n }\n \n+macro_rules! sty_debug_print {\n+    ($ctxt: expr, $($variant: ident),*) => {{\n+        // curious inner module to allow variant names to be used as\n+        // variable names.\n+        mod inner {\n+            use middle::ty;\n+            #[deriving(Copy)]\n+            struct DebugStat {\n+                total: uint,\n+                region_infer: uint,\n+                ty_infer: uint,\n+                both_infer: uint,\n+            }\n+\n+            pub fn go(tcx: &ty::ctxt) {\n+                let mut total = DebugStat {\n+                    total: 0,\n+                    region_infer: 0, ty_infer: 0, both_infer: 0,\n+                };\n+                $(let mut $variant = total;)*\n+\n+\n+                for (_, t) in tcx.interner.borrow().iter() {\n+                    let variant = match t.sty {\n+                        ty::ty_bool | ty::ty_char | ty::ty_int(..) | ty::ty_uint(..) |\n+                            ty::ty_float(..) | ty::ty_str => continue,\n+                        ty::ty_err => /* unimportant */ continue,\n+                        $(ty::$variant(..) => &mut $variant,)*\n+                    };\n+                    let region = t.flags.intersects(ty::HAS_RE_INFER);\n+                    let ty = t.flags.intersects(ty::HAS_TY_INFER);\n+\n+                    variant.total += 1;\n+                    total.total += 1;\n+                    if region { total.region_infer += 1; variant.region_infer += 1 }\n+                    if ty { total.ty_infer += 1; variant.ty_infer += 1 }\n+                    if region && ty { total.both_infer += 1; variant.both_infer += 1 }\n+                }\n+                println!(\"Ty interner             total           ty region  both\");\n+                $(println!(\"    {:18}: {uses:6} {usespc:4.1}%, \\\n+{ty:4.1}% {region:5.1}% {both:4.1}%\",\n+                           stringify!($variant),\n+                           uses = $variant.total,\n+                           usespc = $variant.total as f64 * 100.0 / total.total as f64,\n+                           ty = $variant.ty_infer as f64 * 100.0  / total.total as f64,\n+                           region = $variant.region_infer as f64 * 100.0  / total.total as f64,\n+                           both = $variant.both_infer as f64 * 100.0  / total.total as f64);\n+                  )*\n+                println!(\"                  total {uses:6}        \\\n+{ty:4.1}% {region:5.1}% {both:4.1}%\",\n+                         uses = total.total,\n+                         ty = total.ty_infer as f64 * 100.0  / total.total as f64,\n+                         region = total.region_infer as f64 * 100.0  / total.total as f64,\n+                         both = total.both_infer as f64 * 100.0  / total.total as f64)\n+            }\n+        }\n+\n+        inner::go($ctxt)\n+    }}\n+}\n+\n+impl<'tcx> ctxt<'tcx> {\n+    pub fn print_debug_stats(&self) {\n+        sty_debug_print!(\n+            self,\n+            ty_enum, ty_uniq, ty_vec, ty_ptr, ty_rptr, ty_bare_fn, ty_closure, ty_trait,\n+            ty_struct, ty_unboxed_closure, ty_tup, ty_param, ty_open, ty_infer);\n+\n+        println!(\"Substs interner: #{}\", self.substs_interner.borrow().len());\n+        println!(\"BareFnTy interner: #{}\", self.bare_fn_interner.borrow().len());\n+        println!(\"Region interner: #{}\", self.region_interner.borrow().len());\n+    }\n+}\n+\n #[deriving(Show)]\n pub struct TyS<'tcx> {\n     pub sty: sty<'tcx>,\n     pub flags: TypeFlags,\n \n     // the maximal depth of any bound regions appearing in this type.\n-    region_depth: uint,\n+    region_depth: u32,\n }\n \n impl fmt::Show for TypeFlags {\n@@ -878,7 +976,7 @@ pub fn type_has_escaping_regions(ty: Ty) -> bool {\n     type_escapes_depth(ty, 0)\n }\n \n-pub fn type_escapes_depth(ty: Ty, depth: uint) -> bool {\n+pub fn type_escapes_depth(ty: Ty, depth: u32) -> bool {\n     ty.region_depth > depth\n }\n \n@@ -932,7 +1030,7 @@ pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n #[deriving(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub struct ParamTy {\n     pub space: subst::ParamSpace,\n-    pub idx: uint,\n+    pub idx: u32,\n     pub def_id: DefId\n }\n \n@@ -979,7 +1077,7 @@ pub struct ParamTy {\n pub struct DebruijnIndex {\n     // We maintain the invariant that this is never 0. So 1 indicates\n     // the innermost binder. To ensure this, create with `DebruijnIndex::new`.\n-    pub depth: uint,\n+    pub depth: u32,\n }\n \n /// Representation of regions:\n@@ -990,7 +1088,7 @@ pub enum Region {\n     // parameters are substituted.\n     ReEarlyBound(/* param id */ ast::NodeId,\n                  subst::ParamSpace,\n-                 /*index*/ uint,\n+                 /*index*/ u32,\n                  ast::Name),\n \n     // Region bound in a function scope, which will be substituted when the\n@@ -1140,7 +1238,7 @@ impl Region {\n         }\n     }\n \n-    pub fn escapes_depth(&self, depth: uint) -> bool {\n+    pub fn escapes_depth(&self, depth: u32) -> bool {\n         match *self {\n             ty::ReLateBound(debruijn, _) => debruijn.depth > depth,\n             _ => false,\n@@ -1161,7 +1259,7 @@ pub struct FreeRegion {\n            RustcEncodable, RustcDecodable, Show, Copy)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n-    BrAnon(uint),\n+    BrAnon(u32),\n \n     /// Named region parameters for functions (a in &'a T)\n     ///\n@@ -1170,7 +1268,7 @@ pub enum BoundRegion {\n     BrNamed(ast::DefId, ast::Name),\n \n     /// Fresh bound identifiers created during GLB computations.\n-    BrFresh(uint),\n+    BrFresh(u32),\n \n     // Anonymous region for the implicit env pointer parameter\n     // to a closure\n@@ -1241,22 +1339,22 @@ pub enum sty<'tcx> {\n     /// from the tcx, use the `NodeId` from the `ast::Ty` and look it up in\n     /// the `ast_ty_to_ty_cache`. This is probably true for `ty_struct` as\n     /// well.`\n-    ty_enum(DefId, Substs<'tcx>),\n+    ty_enum(DefId, &'tcx Substs<'tcx>),\n     ty_uniq(Ty<'tcx>),\n     ty_str,\n     ty_vec(Ty<'tcx>, Option<uint>), // Second field is length.\n     ty_ptr(mt<'tcx>),\n-    ty_rptr(Region, mt<'tcx>),\n+    ty_rptr(&'tcx Region, mt<'tcx>),\n \n     // If the def-id is Some(_), then this is the type of a specific\n     // fn item. Otherwise, if None(_), it a fn pointer type.\n-    ty_bare_fn(Option<DefId>, BareFnTy<'tcx>),\n+    ty_bare_fn(Option<DefId>, &'tcx BareFnTy<'tcx>),\n \n     ty_closure(Box<ClosureTy<'tcx>>),\n     ty_trait(Box<TyTrait<'tcx>>),\n-    ty_struct(DefId, Substs<'tcx>),\n+    ty_struct(DefId, &'tcx Substs<'tcx>),\n \n-    ty_unboxed_closure(DefId, Region, Substs<'tcx>),\n+    ty_unboxed_closure(DefId, &'tcx Region, &'tcx Substs<'tcx>),\n \n     ty_tup(Vec<Ty<'tcx>>),\n \n@@ -1285,12 +1383,13 @@ impl<'tcx> TyTrait<'tcx> {\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self-type. A common choice is `mk_err()`\n     /// or some skolemized type.\n-    pub fn principal_trait_ref_with_self_ty(&self, self_ty: Ty<'tcx>)\n+    pub fn principal_trait_ref_with_self_ty(&self,\n+                                            tcx: &ctxt<'tcx>, self_ty: Ty<'tcx>)\n                                             -> Rc<ty::PolyTraitRef<'tcx>>\n     {\n         Rc::new(ty::Binder(ty::TraitRef {\n             def_id: self.principal.def_id(),\n-            substs: self.principal.substs().with_self_ty(self_ty),\n+            substs: tcx.mk_substs(self.principal.substs().with_self_ty(self_ty)),\n         }))\n     }\n }\n@@ -1313,7 +1412,7 @@ impl<'tcx> TyTrait<'tcx> {\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n-    pub substs: Substs<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n }\n \n pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n@@ -1327,8 +1426,8 @@ impl<'tcx> PolyTraitRef<'tcx> {\n         self.0.def_id\n     }\n \n-    pub fn substs(&self) -> &Substs<'tcx> {\n-        &self.0.substs\n+    pub fn substs(&self) -> &'tcx Substs<'tcx> {\n+        self.0.substs\n     }\n \n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n@@ -1461,22 +1560,22 @@ impl CLike for BuiltinBound {\n \n #[deriving(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TyVid {\n-    pub index: uint\n+    pub index: u32\n }\n \n #[deriving(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct IntVid {\n-    pub index: uint\n+    pub index: u32\n }\n \n #[deriving(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct FloatVid {\n-    pub index: uint\n+    pub index: u32\n }\n \n #[deriving(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct RegionVid {\n-    pub index: uint\n+    pub index: u32\n }\n \n #[deriving(Clone, Copy, PartialEq, Eq, Hash)]\n@@ -1488,18 +1587,18 @@ pub enum InferTy {\n     /// A `FreshTy` is one that is generated as a replacement for an\n     /// unbound type variable. This is convenient for caching etc. See\n     /// `middle::infer::freshen` for more details.\n-    FreshTy(uint),\n+    FreshTy(u32),\n \n     // FIXME -- once integral fallback is impl'd, we should remove\n     // this type. It's only needed to prevent spurious errors for\n     // integers whose type winds up never being constrained.\n-    FreshIntTy(uint),\n+    FreshIntTy(u32),\n }\n \n #[deriving(Clone, RustcEncodable, RustcDecodable, Eq, Hash, Show, Copy)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n-    ReSkolemized(uint, BoundRegion)\n+    ReSkolemized(u32, BoundRegion)\n }\n \n impl cmp::PartialEq for InferRegion {\n@@ -1576,7 +1675,7 @@ pub struct TypeParameterDef<'tcx> {\n     pub name: ast::Name,\n     pub def_id: ast::DefId,\n     pub space: subst::ParamSpace,\n-    pub index: uint,\n+    pub index: u32,\n     pub associated_with: Option<ast::DefId>,\n     pub bounds: ParamBounds<'tcx>,\n     pub default: Option<Ty<'tcx>>,\n@@ -1587,7 +1686,7 @@ pub struct RegionParameterDef {\n     pub name: ast::Name,\n     pub def_id: ast::DefId,\n     pub space: subst::ParamSpace,\n-    pub index: uint,\n+    pub index: u32,\n     pub bounds: Vec<ty::Region>,\n }\n \n@@ -1749,7 +1848,7 @@ impl<'tcx> GenericBounds<'tcx> {\n }\n \n impl<'tcx> TraitRef<'tcx> {\n-    pub fn new(def_id: ast::DefId, substs: Substs<'tcx>) -> TraitRef<'tcx> {\n+    pub fn new(def_id: ast::DefId, substs: &'tcx Substs<'tcx>) -> TraitRef<'tcx> {\n         TraitRef { def_id: def_id, substs: substs }\n     }\n \n@@ -1977,7 +2076,7 @@ impl UnboxedClosureKind {\n }\n \n pub fn mk_ctxt<'tcx>(s: Session,\n-                     type_arena: &'tcx TypedArena<TyS<'tcx>>,\n+                     arenas: &'tcx CtxtArenas<'tcx>,\n                      dm: DefMap,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n@@ -1987,8 +2086,11 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      lang_items: middle::lang_items::LanguageItems,\n                      stability: stability::Index) -> ctxt<'tcx> {\n     ctxt {\n-        type_arena: type_arena,\n+        arenas: arenas,\n         interner: RefCell::new(FnvHashMap::new()),\n+        substs_interner: RefCell::new(FnvHashMap::new()),\n+        bare_fn_interner: RefCell::new(FnvHashMap::new()),\n+        region_interner: RefCell::new(FnvHashMap::new()),\n         named_region_map: named_region_map,\n         item_variance_map: RefCell::new(DefIdMap::new()),\n         variance_computed: Cell::new(false),\n@@ -2048,6 +2150,38 @@ pub fn mk_ctxt<'tcx>(s: Session,\n \n // Type constructors\n \n+impl<'tcx> ctxt<'tcx> {\n+    pub fn mk_substs(&self, substs: Substs<'tcx>) -> &'tcx Substs<'tcx> {\n+        if let Some(substs) = self.substs_interner.borrow().get(&substs) {\n+            return *substs;\n+        }\n+\n+        let substs = self.arenas.substs.alloc(substs);\n+        self.substs_interner.borrow_mut().insert(substs, substs);\n+        substs\n+    }\n+\n+    pub fn mk_bare_fn(&self, bare_fn: BareFnTy<'tcx>) -> &'tcx BareFnTy<'tcx> {\n+        if let Some(bare_fn) = self.bare_fn_interner.borrow().get(&bare_fn) {\n+            return *bare_fn;\n+        }\n+\n+        let bare_fn = self.arenas.bare_fn.alloc(bare_fn);\n+        self.bare_fn_interner.borrow_mut().insert(bare_fn, bare_fn);\n+        bare_fn\n+    }\n+\n+    pub fn mk_region(&self, region: Region) -> &'tcx Region {\n+        if let Some(region) = self.region_interner.borrow().get(&region) {\n+            return *region;\n+        }\n+\n+        let region = self.arenas.region.alloc(region);\n+        self.region_interner.borrow_mut().insert(region, region);\n+        region\n+    }\n+}\n+\n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n pub fn mk_t<'tcx>(cx: &ctxt<'tcx>, st: sty<'tcx>) -> Ty<'tcx> {\n@@ -2069,7 +2203,7 @@ pub fn mk_t<'tcx>(cx: &ctxt<'tcx>, st: sty<'tcx>) -> Ty<'tcx> {\n \n     let flags = FlagComputation::for_sty(&st);\n \n-    let ty = cx.type_arena.alloc(TyS {\n+    let ty = cx.arenas.type_.alloc(TyS {\n         sty: st,\n         flags: flags.flags,\n         region_depth: flags.depth,\n@@ -2084,7 +2218,7 @@ struct FlagComputation {\n     flags: TypeFlags,\n \n     // maximum depth of any bound region that we have seen thus far\n-    depth: uint,\n+    depth: u32,\n }\n \n impl FlagComputation {\n@@ -2102,7 +2236,7 @@ impl FlagComputation {\n         self.flags = self.flags | flags;\n     }\n \n-    fn add_depth(&mut self, depth: uint) {\n+    fn add_depth(&mut self, depth: u32) {\n         if depth > self.depth {\n             self.depth = depth;\n         }\n@@ -2151,7 +2285,7 @@ impl FlagComputation {\n                 }\n             }\n \n-            &ty_unboxed_closure(_, ref region, ref substs) => {\n+            &ty_unboxed_closure(_, region, substs) => {\n                 self.add_region(*region);\n                 self.add_substs(substs);\n             }\n@@ -2160,7 +2294,7 @@ impl FlagComputation {\n                 self.add_flags(HAS_TY_INFER)\n             }\n \n-            &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n+            &ty_enum(_, substs) | &ty_struct(_, substs) => {\n                 self.add_substs(substs);\n             }\n \n@@ -2181,7 +2315,7 @@ impl FlagComputation {\n             }\n \n             &ty_rptr(r, ref m) => {\n-                self.add_region(r);\n+                self.add_region(*r);\n                 self.add_ty(m.ty);\n             }\n \n@@ -2286,15 +2420,15 @@ pub fn mk_str<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n     mk_t(cx, ty_str)\n }\n \n-pub fn mk_str_slice<'tcx>(cx: &ctxt<'tcx>, r: Region, m: ast::Mutability) -> Ty<'tcx> {\n+pub fn mk_str_slice<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, m: ast::Mutability) -> Ty<'tcx> {\n     mk_rptr(cx, r,\n             mt {\n                 ty: mk_t(cx, ty_str),\n                 mutbl: m\n             })\n }\n \n-pub fn mk_enum<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId, substs: Substs<'tcx>) -> Ty<'tcx> {\n+pub fn mk_enum<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_enum(did, substs))\n }\n@@ -2303,14 +2437,14 @@ pub fn mk_uniq<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_un\n \n pub fn mk_ptr<'tcx>(cx: &ctxt<'tcx>, tm: mt<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_ptr(tm)) }\n \n-pub fn mk_rptr<'tcx>(cx: &ctxt<'tcx>, r: Region, tm: mt<'tcx>) -> Ty<'tcx> {\n+pub fn mk_rptr<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, tm: mt<'tcx>) -> Ty<'tcx> {\n     mk_t(cx, ty_rptr(r, tm))\n }\n \n-pub fn mk_mut_rptr<'tcx>(cx: &ctxt<'tcx>, r: Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+pub fn mk_mut_rptr<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n     mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutMutable})\n }\n-pub fn mk_imm_rptr<'tcx>(cx: &ctxt<'tcx>, r: Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+pub fn mk_imm_rptr<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n     mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutImmutable})\n }\n \n@@ -2330,7 +2464,7 @@ pub fn mk_vec<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, sz: Option<uint>) -> Ty<'tcx>\n     mk_t(cx, ty_vec(ty, sz))\n }\n \n-pub fn mk_slice<'tcx>(cx: &ctxt<'tcx>, r: Region, tm: mt<'tcx>) -> Ty<'tcx> {\n+pub fn mk_slice<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, tm: mt<'tcx>) -> Ty<'tcx> {\n     mk_rptr(cx, r,\n             mt {\n                 ty: mk_vec(cx, tm.ty, None),\n@@ -2352,7 +2486,7 @@ pub fn mk_closure<'tcx>(cx: &ctxt<'tcx>, fty: ClosureTy<'tcx>) -> Ty<'tcx> {\n \n pub fn mk_bare_fn<'tcx>(cx: &ctxt<'tcx>,\n                         opt_def_id: Option<ast::DefId>,\n-                        fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n+                        fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n     mk_t(cx, ty_bare_fn(opt_def_id, fty))\n }\n \n@@ -2363,15 +2497,15 @@ pub fn mk_ctor_fn<'tcx>(cx: &ctxt<'tcx>,\n     let input_args = input_tys.iter().map(|ty| *ty).collect();\n     mk_bare_fn(cx,\n                Some(def_id),\n-               BareFnTy {\n+               cx.mk_bare_fn(BareFnTy {\n                    unsafety: ast::Unsafety::Normal,\n                    abi: abi::Rust,\n                    sig: ty::Binder(FnSig {\n                     inputs: input_args,\n                     output: ty::FnConverging(output),\n                     variadic: false\n                    })\n-                })\n+                }))\n }\n \n \n@@ -2388,13 +2522,13 @@ pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n }\n \n pub fn mk_struct<'tcx>(cx: &ctxt<'tcx>, struct_id: ast::DefId,\n-                       substs: Substs<'tcx>) -> Ty<'tcx> {\n+                       substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n \n pub fn mk_unboxed_closure<'tcx>(cx: &ctxt<'tcx>, closure_id: ast::DefId,\n-                                region: Region, substs: Substs<'tcx>)\n+                                region: &'tcx Region, substs: &'tcx Substs<'tcx>)\n                                 -> Ty<'tcx> {\n     mk_t(cx, ty_unboxed_closure(closure_id, region, substs))\n }\n@@ -2416,7 +2550,7 @@ pub fn mk_infer<'tcx>(cx: &ctxt<'tcx>, it: InferTy) -> Ty<'tcx> {\n }\n \n pub fn mk_param<'tcx>(cx: &ctxt<'tcx>, space: subst::ParamSpace,\n-                      n: uint, k: DefId) -> Ty<'tcx> {\n+                      n: u32, k: DefId) -> Ty<'tcx> {\n     mk_t(cx, ty_param(ParamTy { space: space, idx: n, def_id: k }))\n }\n \n@@ -2488,7 +2622,7 @@ pub fn fold_ty<'tcx, F>(cx: &ctxt<'tcx>, t0: Ty<'tcx>,\n \n impl ParamTy {\n     pub fn new(space: subst::ParamSpace,\n-               index: uint,\n+               index: u32,\n                def_id: ast::DefId)\n                -> ParamTy {\n         ParamTy { space: space, idx: index, def_id: def_id }\n@@ -2617,7 +2751,7 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n \n pub fn simd_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n-        ty_struct(did, ref substs) => {\n+        ty_struct(did, substs) => {\n             let fields = lookup_struct_fields(cx, did);\n             lookup_field_type(cx, did, fields[0].id, substs)\n         }\n@@ -2716,7 +2850,7 @@ pub fn type_needs_unwind_cleanup<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n                 ty_bool | ty_int(_) | ty_uint(_) |\n                 ty_float(_) | ty_tup(_) | ty_ptr(_) => false,\n \n-                ty_enum(did, ref substs) =>\n+                ty_enum(did, substs) =>\n                     enum_variants(cx, did).iter().any(|v|\n                         v.args.iter().any(|aty| {\n                             let t = aty.subst(cx, substs);\n@@ -2969,9 +3103,10 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n \n             ty_rptr(r, ref mt) => {\n                 TC::ReachesFfiUnsafe | match mt.ty.sty {\n-                    ty_str => borrowed_contents(r, ast::MutImmutable),\n-                    ty_vec(..) => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(r, mt.mutbl)),\n-                    _ => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(r, mt.mutbl)),\n+                    ty_str => borrowed_contents(*r, ast::MutImmutable),\n+                    ty_vec(..) => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(*r,\n+                                                                                      mt.mutbl)),\n+                    _ => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(*r, mt.mutbl)),\n                 }\n             }\n \n@@ -2984,7 +3119,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n             ty_str => TC::Nonsized,\n \n-            ty_struct(did, ref substs) => {\n+            ty_struct(did, substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let mut res =\n                     TypeContents::union(flds[],\n@@ -3000,21 +3135,21 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 apply_lang_items(cx, did, res)\n             }\n \n-            ty_unboxed_closure(did, r, ref substs) => {\n+            ty_unboxed_closure(did, r, substs) => {\n                 // FIXME(#14449): `borrowed_contents` below assumes `&mut`\n                 // unboxed closure.\n                 let upvars = unboxed_closure_upvars(cx, did, substs);\n                 TypeContents::union(upvars.as_slice(),\n                                     |f| tc_ty(cx, f.ty, cache))\n-                    | borrowed_contents(r, MutMutable)\n+                    | borrowed_contents(*r, MutMutable)\n             }\n \n             ty_tup(ref tys) => {\n                 TypeContents::union(tys[],\n                                     |ty| tc_ty(cx, *ty, cache))\n             }\n \n-            ty_enum(did, ref substs) => {\n+            ty_enum(did, substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n                 let mut res =\n                     TypeContents::union(variants[], |variant| {\n@@ -3306,15 +3441,15 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n                 false\n             }\n \n-            ty_struct(did, ref substs) => {\n+            ty_struct(did, substs) => {\n                 seen.push(did);\n                 let fields = struct_fields(cx, did, substs);\n                 let r = fields.iter().any(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n                 seen.pop().unwrap();\n                 r\n             }\n \n-            ty_unboxed_closure(did, _, ref substs) => {\n+            ty_unboxed_closure(did, _, substs) => {\n                 let upvars = unboxed_closure_upvars(cx, did, substs);\n                 upvars.iter().any(|f| type_requires(cx, seen, r_ty, f.ty))\n             }\n@@ -3327,7 +3462,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n                 false\n             }\n \n-            ty_enum(did, ref substs) => {\n+            ty_enum(did, substs) => {\n                 seen.push(did);\n                 let vs = enum_variants(cx, did);\n                 let r = !vs.is_empty() && vs.iter().all(|variant| {\n@@ -3394,19 +3529,19 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n             ty_vec(ty, Some(_)) => {\n                 is_type_structurally_recursive(cx, sp, seen, ty)\n             }\n-            ty_struct(did, ref substs) => {\n+            ty_struct(did, substs) => {\n                 let fields = struct_fields(cx, did, substs);\n                 find_nonrepresentable(cx, sp, seen, fields.iter().map(|f| f.mt.ty))\n             }\n-            ty_enum(did, ref substs) => {\n+            ty_enum(did, substs) => {\n                 let vs = enum_variants(cx, did);\n                 let iter = vs.iter()\n                     .flat_map(|variant| { variant.args.iter() })\n                     .map(|aty| { aty.subst_spanned(cx, substs, Some(sp)) });\n \n                 find_nonrepresentable(cx, sp, seen, iter)\n             }\n-            ty_unboxed_closure(did, _, ref substs) => {\n+            ty_unboxed_closure(did, _, substs) => {\n                 let upvars = unboxed_closure_upvars(cx, did, substs);\n                 find_nonrepresentable(cx, sp, seen, upvars.iter().map(|f| f.ty))\n             }\n@@ -3626,7 +3761,7 @@ pub fn lltype_is_sized<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n pub fn unsized_part_of_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_str | ty_trait(..) | ty_vec(..) => ty,\n-        ty_struct(def_id, ref substs) => {\n+        ty_struct(def_id, substs) => {\n             let unsized_fields: Vec<_> = struct_fields(cx, def_id, substs).iter()\n                 .map(|f| f.mt.ty).filter(|ty| !type_is_sized(cx, *ty)).collect();\n             // Exactly one of the fields must be unsized.\n@@ -3678,7 +3813,7 @@ pub fn deref<'tcx>(ty: Ty<'tcx>, explicit: bool) -> Option<mt<'tcx>> {\n \n pub fn close_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n-        ty_open(ty) => mk_rptr(cx, ReStatic, mt {ty: ty, mutbl:ast::MutImmutable}),\n+        ty_open(ty) => mk_rptr(cx, cx.mk_region(ReStatic), mt {ty: ty, mutbl:ast::MutImmutable}),\n         _ => cx.sess.bug(format!(\"Trying to close a non-open type {}\",\n                                  ty_to_string(cx, ty))[])\n     }\n@@ -3730,16 +3865,16 @@ pub fn positional_element_ty<'tcx>(cx: &ctxt<'tcx>,\n         (&ty_tup(ref v), None) => v.get(i).map(|&t| t),\n \n \n-        (&ty_struct(def_id, ref substs), None) => lookup_struct_fields(cx, def_id)\n+        (&ty_struct(def_id, substs), None) => lookup_struct_fields(cx, def_id)\n             .get(i)\n             .map(|&t|lookup_item_type(cx, t.id).ty.subst(cx, substs)),\n \n-        (&ty_enum(def_id, ref substs), Some(variant_def_id)) => {\n+        (&ty_enum(def_id, substs), Some(variant_def_id)) => {\n             let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);\n             variant_info.args.get(i).map(|t|t.subst(cx, substs))\n         }\n \n-        (&ty_enum(def_id, ref substs), None) => {\n+        (&ty_enum(def_id, substs), None) => {\n             assert!(enum_is_univariant(cx, def_id));\n             let enum_variants = enum_variants(cx, def_id);\n             let variant_info = &(*enum_variants)[0];\n@@ -3758,12 +3893,12 @@ pub fn named_element_ty<'tcx>(cx: &ctxt<'tcx>,\n                               variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n \n     match (&ty.sty, variant) {\n-        (&ty_struct(def_id, ref substs), None) => {\n+        (&ty_struct(def_id, substs), None) => {\n             let r = lookup_struct_fields(cx, def_id);\n             r.iter().find(|f| f.name == n)\n                 .map(|&f| lookup_field_type(cx, def_id, f.id, substs))\n         }\n-        (&ty_enum(def_id, ref substs), Some(variant_def_id)) => {\n+        (&ty_enum(def_id, substs), Some(variant_def_id)) => {\n             let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);\n             variant_info.arg_names.as_ref()\n                 .expect(\"must have struct enum variant if accessing a named fields\")\n@@ -3882,7 +4017,7 @@ pub fn ty_region(tcx: &ctxt,\n                  span: Span,\n                  ty: Ty) -> Region {\n     match ty.sty {\n-        ty_rptr(r, _) => r,\n+        ty_rptr(r, _) => *r,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n@@ -4025,8 +4160,8 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n \n                 AdjustReifyFnPointer(_) => {\n                     match unadjusted_ty.sty {\n-                        ty::ty_bare_fn(Some(_), ref b) => {\n-                            ty::mk_bare_fn(cx, None, (*b).clone())\n+                        ty::ty_bare_fn(Some(_), b) => {\n+                            ty::mk_bare_fn(cx, None, b)\n                         }\n                         ref b => {\n                             cx.sess.bug(\n@@ -4088,7 +4223,7 @@ pub fn adjust_ty_for_autoref<'tcx>(cx: &ctxt<'tcx>,\n                 &Some(box ref a) => adjust_ty_for_autoref(cx, span, ty, Some(a)),\n                 &None => ty\n             };\n-            mk_rptr(cx, r, mt {\n+            mk_rptr(cx, cx.mk_region(r), mt {\n                 ty: adjusted_ty,\n                 mutbl: m\n             })\n@@ -4126,12 +4261,12 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n                                           ty_to_string(cx, ty))[])\n         },\n         &UnsizeStruct(box ref k, tp_index) => match ty.sty {\n-            ty_struct(did, ref substs) => {\n+            ty_struct(did, substs) => {\n                 let ty_substs = substs.types.get_slice(subst::TypeSpace);\n                 let new_ty = unsize_ty(cx, ty_substs[tp_index], k, span);\n                 let mut unsized_substs = substs.clone();\n                 unsized_substs.types.get_mut_slice(subst::TypeSpace)[tp_index] = new_ty;\n-                mk_struct(cx, did, unsized_substs)\n+                mk_struct(cx, did, cx.mk_substs(unsized_substs))\n             }\n             _ => cx.sess.span_bug(span,\n                                   format!(\"UnsizeStruct with bad sty: {}\",\n@@ -4731,7 +4866,7 @@ pub fn associated_type_parameter_index(cx: &ctxt,\n                                        -> uint {\n     for type_parameter_def in trait_def.generics.types.iter() {\n         if type_parameter_def.def_id == associated_type_id {\n-            return type_parameter_def.index\n+            return type_parameter_def.index as uint\n         }\n     }\n     cx.sess.bug(\"couldn't find associated type parameter index\")\n@@ -5156,9 +5291,10 @@ pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n         trait_def.bounds.trait_bounds\n         .iter()\n         .map(|bound_trait_ref| {\n+            let substs = tcx.mk_substs(bound_trait_ref.substs().subst(tcx, trait_ref.substs()));\n             ty::Binder(\n                 ty::TraitRef::new(bound_trait_ref.def_id(),\n-                                  bound_trait_ref.substs().subst(tcx, trait_ref.substs())))\n+                                  substs))\n         })\n         .map(|bound_trait_ref| Rc::new(bound_trait_ref))\n         .collect();\n@@ -5375,7 +5511,7 @@ pub fn unboxed_closure_upvars<'tcx>(tcx: &ctxt<'tcx>, closure_id: ast::DefId, su\n                         var_id: freevar_def_id.node,\n                         closure_expr_id: closure_id.node\n                     }].clone();\n-                    freevar_ty = mk_rptr(tcx, borrow.region, ty::mt {\n+                    freevar_ty = mk_rptr(tcx, tcx.mk_region(borrow.region), ty::mt {\n                         ty: freevar_ty,\n                         mutbl: borrow.kind.to_mutbl_lossy()\n                     });\n@@ -5568,7 +5704,7 @@ pub fn object_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n \n     let opt_trait_ref = opt_principal.map_or(Vec::new(), |principal| {\n         let substs = principal.substs().with_self_ty(open_ty);\n-        vec!(Rc::new(ty::Binder(ty::TraitRef::new(principal.def_id(), substs))))\n+        vec!(Rc::new(ty::Binder(ty::TraitRef::new(principal.def_id(), tcx.mk_substs(substs)))))\n     });\n \n     let param_bounds = ty::ParamBounds {\n@@ -5927,7 +6063,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                 }\n                 ty_rptr(r, m) => {\n                     byte!(13);\n-                    region(state, r);\n+                    region(state, *r);\n                     mt(state, m);\n                 }\n                 ty_bare_fn(opt_def_id, ref b) => {\n@@ -5987,7 +6123,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                 ty_unboxed_closure(d, r, _) => {\n                     byte!(24);\n                     did(state, d);\n-                    region(state, r);\n+                    region(state, *r);\n                 }\n             }\n             true\n@@ -6095,7 +6231,7 @@ pub fn construct_parameter_environment<'tcx>(\n                    space,\n                    def.repr(tcx),\n                    i);\n-            let ty = ty::mk_param(tcx, space, i, def.def_id);\n+            let ty = ty::mk_param(tcx, space, i as u32, def.def_id);\n             types.push(space, ty);\n         }\n     }\n@@ -6229,13 +6365,13 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n     walk_ty(ty, |ty| {\n         match ty.sty {\n             ty_rptr(region, _) => {\n-                accumulator.push(region)\n+                accumulator.push(*region)\n             }\n             ty_trait(ref t) => {\n                 accumulator.push_all(t.principal.substs().regions().as_slice());\n             }\n-            ty_enum(_, ref substs) |\n-            ty_struct(_, ref substs) => {\n+            ty_enum(_, substs) |\n+            ty_struct(_, substs) => {\n                 accum_substs(accumulator, substs);\n             }\n             ty_closure(ref closure_ty) => {\n@@ -6244,7 +6380,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                     UniqTraitStore => {}\n                 }\n             }\n-            ty_unboxed_closure(_, ref region, ref substs) => {\n+            ty_unboxed_closure(_, region, substs) => {\n                 accumulator.push(*region);\n                 accum_substs(accumulator, substs);\n             }\n@@ -6416,12 +6552,12 @@ pub fn replace_late_bound_regions<'tcx, T, F>(\n }\n \n impl DebruijnIndex {\n-    pub fn new(depth: uint) -> DebruijnIndex {\n+    pub fn new(depth: u32) -> DebruijnIndex {\n         assert!(depth > 0);\n         DebruijnIndex { depth: depth }\n     }\n \n-    pub fn shifted(&self, amount: uint) -> DebruijnIndex {\n+    pub fn shifted(&self, amount: u32) -> DebruijnIndex {\n         DebruijnIndex { depth: self.depth + amount }\n     }\n }\n@@ -6559,15 +6695,15 @@ pub fn can_type_implement_copy<'tcx>(tcx: &ctxt<'tcx>,\n                                      param_env: &ParameterEnvironment<'tcx>)\n                                      -> Result<(),CopyImplementationError> {\n     match self_type.sty {\n-        ty::ty_struct(struct_did, ref substs) => {\n+        ty::ty_struct(struct_did, substs) => {\n             let fields = ty::struct_fields(tcx, struct_did, substs);\n             for field in fields.iter() {\n                 if type_moves_by_default(tcx, field.mt.ty, param_env) {\n                     return Err(FieldDoesNotImplementCopy(field.name))\n                 }\n             }\n         }\n-        ty::ty_enum(enum_did, ref substs) => {\n+        ty::ty_enum(enum_did, substs) => {\n             let enum_variants = ty::enum_variants(tcx, enum_did);\n             for variant in enum_variants.iter() {\n                 for variant_arg_type in variant.args.iter() {\n@@ -6592,43 +6728,42 @@ pub trait RegionEscape {\n         self.has_regions_escaping_depth(0)\n     }\n \n-    fn has_regions_escaping_depth(&self, depth: uint) -> bool;\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool;\n }\n \n impl<'tcx> RegionEscape for Ty<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         ty::type_escapes_depth(*self, depth)\n     }\n }\n \n impl RegionEscape for Region {\n-    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.escapes_depth(depth)\n     }\n }\n \n impl<'tcx> RegionEscape for TraitRef<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.substs.types.iter().any(|t| t.has_regions_escaping_depth(depth)) &&\n             self.substs.regions().iter().any(|t| t.has_regions_escaping_depth(depth))\n     }\n }\n \n impl<'tcx,T:RegionEscape> RegionEscape for Binder<T> {\n-    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.0.has_regions_escaping_depth(depth + 1)\n     }\n }\n \n impl<'tcx> RegionEscape for EquatePredicate<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)\n     }\n }\n \n impl<T:RegionEscape,U:RegionEscape> RegionEscape for OutlivesPredicate<T,U> {\n-    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)\n     }\n }\n-"}, {"sha": "782b464ed96d5c2fbd9847bcbbf652a7d48f2a8b", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -527,7 +527,8 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             ty::ty_open(typ.fold_with(this))\n         }\n         ty::ty_enum(tid, ref substs) => {\n-            ty::ty_enum(tid, substs.fold_with(this))\n+            let substs = substs.fold_with(this);\n+            ty::ty_enum(tid, this.tcx().mk_substs(substs))\n         }\n         ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n             ty::ty_trait(box ty::TyTrait {\n@@ -539,19 +540,24 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             ty::ty_tup(ts.fold_with(this))\n         }\n         ty::ty_bare_fn(opt_def_id, ref f) => {\n-            ty::ty_bare_fn(opt_def_id, f.fold_with(this))\n+            let bfn = f.fold_with(this);\n+            ty::ty_bare_fn(opt_def_id, this.tcx().mk_bare_fn(bfn))\n         }\n         ty::ty_closure(ref f) => {\n             ty::ty_closure(box f.fold_with(this))\n         }\n         ty::ty_rptr(r, ref tm) => {\n-            ty::ty_rptr(r.fold_with(this), tm.fold_with(this))\n+            let r = r.fold_with(this);\n+            ty::ty_rptr(this.tcx().mk_region(r), tm.fold_with(this))\n         }\n         ty::ty_struct(did, ref substs) => {\n-            ty::ty_struct(did, substs.fold_with(this))\n+            let substs = substs.fold_with(this);\n+            ty::ty_struct(did, this.tcx().mk_substs(substs))\n         }\n         ty::ty_unboxed_closure(did, ref region, ref substs) => {\n-            ty::ty_unboxed_closure(did, region.fold_with(this), substs.fold_with(this))\n+            let r = region.fold_with(this);\n+            let s = substs.fold_with(this);\n+            ty::ty_unboxed_closure(did, this.tcx().mk_region(r), this.tcx().mk_substs(s))\n         }\n         ty::ty_bool | ty::ty_char | ty::ty_str |\n         ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n@@ -624,9 +630,10 @@ pub fn super_fold_trait_ref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                        t: &ty::TraitRef<'tcx>)\n                                                        -> ty::TraitRef<'tcx>\n {\n+    let substs = t.substs.fold_with(this);\n     ty::TraitRef {\n         def_id: t.def_id,\n-        substs: t.substs.fold_with(this),\n+        substs: this.tcx().mk_substs(substs),\n     }\n }\n \n@@ -717,13 +724,13 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n \n pub struct RegionFolder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    current_depth: uint,\n-    fld_r: &'a mut (FnMut(ty::Region, uint) -> ty::Region + 'a),\n+    current_depth: u32,\n+    fld_r: &'a mut (FnMut(ty::Region, u32) -> ty::Region + 'a),\n }\n \n impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n     pub fn new<F>(tcx: &'a ty::ctxt<'tcx>, fld_r: &'a mut F) -> RegionFolder<'a, 'tcx>\n-        where F : FnMut(ty::Region, uint) -> ty::Region\n+        where F : FnMut(ty::Region, u32) -> ty::Region\n     {\n         RegionFolder {\n             tcx: tcx,\n@@ -745,7 +752,7 @@ pub fn fold_regions<'tcx,T,F>(tcx: &ty::ctxt<'tcx>,\n                               value: &T,\n                               mut f: F)\n                               -> T\n-    where F : FnMut(ty::Region, uint) -> ty::Region,\n+    where F : FnMut(ty::Region, u32) -> ty::Region,\n           T : TypeFoldable<'tcx>,\n {\n     value.fold_with(&mut RegionFolder::new(tcx, &mut f))\n@@ -813,7 +820,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n // regions. See comment on `shift_regions_through_binders` method in\n // `subst.rs` for more details.\n \n-pub fn shift_region(region: ty::Region, amount: uint) -> ty::Region {\n+pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n     match region {\n         ty::ReLateBound(debruijn, br) => {\n             ty::ReLateBound(debruijn.shifted(amount), br)\n@@ -825,12 +832,11 @@ pub fn shift_region(region: ty::Region, amount: uint) -> ty::Region {\n }\n \n pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>>(tcx: &ty::ctxt<'tcx>,\n-                                                            amount: uint, value: &T) -> T {\n+                                                            amount: u32, value: &T) -> T {\n     debug!(\"shift_regions(value={}, amount={})\",\n            value.repr(tcx), amount);\n \n     value.fold_with(&mut RegionFolder::new(tcx, &mut |region, _current_depth| {\n         shift_region(region, amount)\n     }))\n }\n-"}, {"sha": "5f3fbf897dc1602f9ea51fd20cf51a60007988c0", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -278,7 +278,8 @@ debugging_opts! {\n         PARSE_ONLY,\n         NO_TRANS,\n         NO_ANALYSIS,\n-        UNSTABLE_OPTIONS\n+        UNSTABLE_OPTIONS,\n+        PRINT_ENUM_SIZES\n     ]\n     0\n }\n@@ -331,7 +332,9 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n      (\"no-analysis\", \"Parse and expand the source, but run no analysis and\",\n       NO_TRANS),\n      (\"unstable-options\", \"Adds unstable command line options to rustc interface\",\n-      UNSTABLE_OPTIONS)]\n+      UNSTABLE_OPTIONS),\n+     (\"print-enum-sizes\", \"Print the size of enums and their variants\", PRINT_ENUM_SIZES),\n+    ]\n }\n \n #[deriving(Clone)]"}, {"sha": "35c325bd764f1a215c5bf1466e284fc17fa99dbe", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -202,6 +202,9 @@ impl Session {\n     pub fn show_span(&self) -> bool {\n         self.debugging_opt(config::SHOW_SPAN)\n     }\n+    pub fn print_enum_sizes(&self) -> bool {\n+        self.debugging_opt(config::PRINT_ENUM_SIZES)\n+    }\n     pub fn sysroot<'a>(&'a self) -> &'a Path {\n         match self.opts.maybe_sysroot {\n             Some (ref sysroot) => sysroot,\n@@ -304,4 +307,3 @@ pub fn early_warn(msg: &str) {\n     let mut emitter = diagnostic::EmitterWriter::stderr(diagnostic::Auto, None);\n     emitter.emit(None, msg, None, diagnostic::Warning);\n }\n-"}, {"sha": "3a383dd5a3b7c3f14e6405c667aa88461c11f0d0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -401,7 +401,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             }, ty_to_string(cx, tm.ty))\n         }\n         ty_rptr(r, ref tm) => {\n-            let mut buf = region_ptr_to_string(cx, r);\n+            let mut buf = region_ptr_to_string(cx, *r);\n             buf.push_str(mt_to_string(cx, tm)[]);\n             buf\n         }\n@@ -432,7 +432,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 param_ty.user_string(cx)\n             }\n         }\n-        ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n+        ty_enum(did, substs) | ty_struct(did, substs) => {\n             let base = ty::item_path_str(cx, did);\n             let generics = ty::lookup_item_type(cx, did).generics;\n             parameterized(cx, base.as_slice(), substs, &generics, did)\n@@ -449,7 +449,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                     bound_str)\n         }\n         ty_str => \"str\".to_string(),\n-        ty_unboxed_closure(ref did, _, ref substs) => {\n+        ty_unboxed_closure(ref did, _, substs) => {\n             let unboxed_closures = cx.unboxed_closures.borrow();\n             unboxed_closures.get(did).map(|cl| {\n                 closure_to_string(cx, &cl.closure_type.subst(cx, substs))\n@@ -759,7 +759,7 @@ impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n         format!(\"TraitRef({}, {})\",\n                 self.substs.self_ty().repr(tcx),\n-                parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics, self.def_id))\n+                parameterized(tcx, base.as_slice(), self.substs, &trait_def.generics, self.def_id))\n     }\n }\n \n@@ -1209,7 +1209,7 @@ impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         let path_str = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        parameterized(tcx, path_str.as_slice(), &self.substs,\n+        parameterized(tcx, path_str.as_slice(), self.substs,\n                       &trait_def.generics, self.def_id)\n     }\n }"}, {"sha": "7609554033cef5021c56421362d0eb388d039591", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -391,7 +391,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             }\n         }\n \n-        (&ty::ty_enum(enum_def_id, ref substs), ref enum_variant_info) => {\n+        (&ty::ty_enum(enum_def_id, substs), ref enum_variant_info) => {\n             let variant_info = {\n                 let mut variants = ty::substd_enum_variants(tcx, enum_def_id, substs);\n                 match *enum_variant_info {"}, {"sha": "0ac8d6ba734d0137960513e7da705cedd5608b37", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -32,7 +32,6 @@ use serialize::{json, Encodable};\n use std::io;\n use std::io::fs;\n use std::os;\n-use arena::TypedArena;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::attr;\n@@ -79,12 +78,23 @@ pub fn compile_input(sess: Session,\n \n         if stop_after_phase_2(&sess) { return; }\n \n-        let type_arena = TypedArena::new();\n-        let analysis = phase_3_run_analysis_passes(sess, ast_map, &type_arena, id);\n+        let arenas = ty::CtxtArenas::new();\n+        let analysis = phase_3_run_analysis_passes(sess, ast_map, &arenas, id);\n         phase_save_analysis(&analysis.ty_cx.sess, analysis.ty_cx.map.krate(), &analysis, outdir);\n+\n+        if log_enabled!(::log::INFO) {\n+            println!(\"Pre-trans\");\n+            analysis.ty_cx.print_debug_stats();\n+        }\n+\n         if stop_after_phase_3(&analysis.ty_cx.sess) { return; }\n         let (tcx, trans) = phase_4_translate_to_llvm(analysis);\n \n+        if log_enabled!(::log::INFO) {\n+            println!(\"Post-trans\");\n+            tcx.print_debug_stats();\n+        }\n+\n         // Discard interned strings as they are no longer required.\n         token::get_ident_interner().clear();\n \n@@ -331,7 +341,7 @@ pub fn assign_node_ids_and_map<'ast>(sess: &Session,\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                                          ast_map: ast_map::Map<'tcx>,\n-                                         type_arena: &'tcx TypedArena<ty::TyS<'tcx>>,\n+                                         arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                          name: String) -> ty::CrateAnalysis<'tcx> {\n     let time_passes = sess.time_passes();\n     let krate = ast_map.krate();\n@@ -391,7 +401,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n          middle::check_static_recursion::check_crate(&sess, krate, &def_map, &ast_map));\n \n     let ty_cx = ty::mk_ctxt(sess,\n-                            type_arena,\n+                            arenas,\n                             def_map,\n                             named_region_map,\n                             ast_map,"}, {"sha": "cf99d409ceb386928a00fd850772b79ea175fad1", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -40,7 +40,6 @@ use graphviz as dot;\n use std::io::{mod, MemReader};\n use std::option;\n use std::str::FromStr;\n-use arena::TypedArena;\n \n #[deriving(Copy, PartialEq, Show)]\n pub enum PpSourceMode {\n@@ -112,7 +111,7 @@ impl PpSourceMode {\n     fn call_with_pp_support<'tcx, A, B, F>(&self,\n                                            sess: Session,\n                                            ast_map: Option<ast_map::Map<'tcx>>,\n-                                           type_arena: &'tcx TypedArena<ty::TyS<'tcx>>,\n+                                           arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                            id: String,\n                                            payload: B,\n                                            f: F) -> A where\n@@ -134,8 +133,7 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n-                let analysis = driver::phase_3_run_analysis_passes(sess, ast_map,\n-                                                                   type_arena, id);\n+                let analysis = driver::phase_3_run_analysis_passes(sess, ast_map, arenas, id);\n                 let annotation = TypedAnnotation { analysis: analysis };\n                 f(&annotation, payload)\n             }\n@@ -510,7 +508,7 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let mut forest = ast_map::Forest::new(krate);\n-    let type_arena = TypedArena::new();\n+    let arenas = ty::CtxtArenas::new();\n \n     let (krate, ast_map) = if compute_ast_map {\n         let map = driver::assign_node_ids_and_map(&sess, &mut forest);\n@@ -539,7 +537,7 @@ pub fn pretty_print_input(sess: Session,\n     match (ppm, opt_uii) {\n         (PpmSource(s), None) =>\n             s.call_with_pp_support(\n-                sess, ast_map, &type_arena, id, out, |annotation, out| {\n+                sess, ast_map, &arenas, id, out, |annotation, out| {\n                     debug!(\"pretty printing source code {}\", s);\n                     let sess = annotation.sess();\n                     pprust::print_crate(sess.codemap(),\n@@ -554,7 +552,7 @@ pub fn pretty_print_input(sess: Session,\n \n         (PpmSource(s), Some(uii)) =>\n             s.call_with_pp_support(\n-                sess, ast_map, &type_arena, id, (out,uii), |annotation, (out,uii)| {\n+                sess, ast_map, &arenas, id, (out,uii), |annotation, (out,uii)| {\n                     debug!(\"pretty printing source code {}\", s);\n                     let sess = annotation.sess();\n                     let ast_map = annotation.ast_map()\n@@ -596,8 +594,7 @@ pub fn pretty_print_input(sess: Session,\n             match code {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n-                    let analysis = driver::phase_3_run_analysis_passes(sess, ast_map,\n-                                                                       &type_arena, id);\n+                    let analysis = driver::phase_3_run_analysis_passes(sess, ast_map, &arenas, id);\n                     print_flowgraph(variants, analysis, code, out)\n                 }\n                 None => {"}, {"sha": "941155ac5e7e349b7ddc108b2da9c8a6f25f3943", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -127,9 +127,9 @@ fn test_env<F>(source_string: &str,\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n     let stability_index = stability::Index::build(krate);\n-    let type_arena = TypedArena::new();\n+    let arenas = ty::CtxtArenas::new();\n     let tcx = ty::mk_ctxt(sess,\n-                          &type_arena,\n+                          &arenas,\n                           def_map,\n                           named_region_map,\n                           ast_map,\n@@ -256,15 +256,15 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         let input_args = input_tys.iter().map(|ty| *ty).collect();\n         ty::mk_bare_fn(self.infcx.tcx,\n                        None,\n-                       ty::BareFnTy {\n+                       self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n                            unsafety: ast::Unsafety::Normal,\n                            abi: abi::Rust,\n                            sig: ty::Binder(ty::FnSig {\n                                inputs: input_args,\n                                output: ty::FnConverging(output_ty),\n                                variadic: false\n                            })\n-                       })\n+                       }))\n     }\n \n     pub fn t_nil(&self) -> Ty<'tcx> {\n@@ -295,58 +295,62 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         })\n     }\n \n-    pub fn t_param(&self, space: subst::ParamSpace, index: uint) -> Ty<'tcx> {\n+    pub fn t_param(&self, space: subst::ParamSpace, index: u32) -> Ty<'tcx> {\n         ty::mk_param(self.infcx.tcx, space, index, ast_util::local_def(ast::DUMMY_NODE_ID))\n     }\n \n     pub fn re_early_bound(&self,\n                           space: subst::ParamSpace,\n-                          index: uint,\n+                          index: u32,\n                           name: &'static str)\n                           -> ty::Region\n     {\n         let name = token::intern(name);\n         ty::ReEarlyBound(ast::DUMMY_NODE_ID, space, index, name)\n     }\n \n-    pub fn re_late_bound_with_debruijn(&self, id: uint, debruijn: ty::DebruijnIndex) -> ty::Region {\n+    pub fn re_late_bound_with_debruijn(&self, id: u32, debruijn: ty::DebruijnIndex) -> ty::Region {\n         ty::ReLateBound(debruijn, ty::BrAnon(id))\n     }\n \n     pub fn t_rptr(&self, r: ty::Region) -> Ty<'tcx> {\n-        ty::mk_imm_rptr(self.infcx.tcx, r, ty::mk_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r), ty::mk_int())\n     }\n \n-    pub fn t_rptr_late_bound(&self, id: uint) -> Ty<'tcx> {\n+    pub fn t_rptr_late_bound(&self, id: u32) -> Ty<'tcx> {\n+        let r = self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1));\n         ty::mk_imm_rptr(self.infcx.tcx,\n-                        self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1)),\n+                        self.infcx.tcx.mk_region(r),\n                         ty::mk_int())\n     }\n \n     pub fn t_rptr_late_bound_with_debruijn(&self,\n-                                           id: uint,\n+                                           id: u32,\n                                            debruijn: ty::DebruijnIndex)\n                                            -> Ty<'tcx> {\n+        let r = self.re_late_bound_with_debruijn(id, debruijn);\n         ty::mk_imm_rptr(self.infcx.tcx,\n-                        self.re_late_bound_with_debruijn(id, debruijn),\n+                        self.infcx.tcx.mk_region(r),\n                         ty::mk_int())\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        ty::mk_imm_rptr(self.infcx.tcx, ty::ReScope(CodeExtent::from_node_id(id)), ty::mk_int())\n+        let r = ty::ReScope(CodeExtent::from_node_id(id));\n+        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r), ty::mk_int())\n     }\n \n-    pub fn re_free(&self, nid: ast::NodeId, id: uint) -> ty::Region {\n+    pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region {\n         ty::ReFree(ty::FreeRegion { scope: CodeExtent::from_node_id(nid),\n                                     bound_region: ty::BrAnon(id)})\n     }\n \n-    pub fn t_rptr_free(&self, nid: ast::NodeId, id: uint) -> Ty<'tcx> {\n-        ty::mk_imm_rptr(self.infcx.tcx, self.re_free(nid, id), ty::mk_int())\n+    pub fn t_rptr_free(&self, nid: ast::NodeId, id: u32) -> Ty<'tcx> {\n+        let r = self.re_free(nid, id);\n+        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r), ty::mk_int())\n     }\n \n     pub fn t_rptr_static(&self) -> Ty<'tcx> {\n-        ty::mk_imm_rptr(self.infcx.tcx, ty::ReStatic, ty::mk_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(ty::ReStatic), ty::mk_int())\n     }\n \n     pub fn dummy_type_trace(&self) -> infer::TypeTrace<'tcx> {\n@@ -816,4 +820,3 @@ fn subst_region_renumber_region() {\n         assert_eq!(t_substituted, t_expected);\n     })\n }\n-"}, {"sha": "c168709eec5b91c213d0e793917347fa87aa17f9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -4254,7 +4254,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                     let def_like = DlDef(DefTyParam(space,\n                                                     local_def(type_parameter.id),\n-                                                    index));\n+                                                    index as u32));\n                     // Associate this type parameter with\n                     // the item that bound it\n                     self.record_def(type_parameter.id,"}, {"sha": "a798d09872ca2fd8b31dd9dc8e9c6616132c0e3b", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -635,7 +635,7 @@ fn bind_subslice_pat(bcx: Block,\n     let slice_len_offset = C_uint(bcx.ccx(), offset_left + offset_right);\n     let slice_len = Sub(bcx, len, slice_len_offset);\n     let slice_ty = ty::mk_slice(bcx.tcx(),\n-                                ty::ReStatic,\n+                                bcx.tcx().mk_region(ty::ReStatic),\n                                 ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable});\n     let scratch = rvalue_scratch_datum(bcx, slice_ty, \"\");\n     Store(bcx, slice_begin,\n@@ -808,7 +808,9 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                 ty::ty_uint(ast::TyU8) => {\n                     // NOTE: cast &[u8] to &str and abuse the str_eq lang item,\n                     // which calls memcmp().\n-                    let t = ty::mk_str_slice(cx.tcx(), ty::ReStatic, ast::MutImmutable);\n+                    let t = ty::mk_str_slice(cx.tcx(),\n+                                             cx.tcx().mk_region(ty::ReStatic),\n+                                             ast::MutImmutable);\n                     let lhs = BitCast(cx, lhs, type_of::type_of(cx.ccx(), t).ptr_to());\n                     let rhs = BitCast(cx, rhs, type_of::type_of(cx.ccx(), t).ptr_to());\n                     compare_str(cx, lhs, rhs, rhs_t)"}, {"sha": "595d252a0b1a0826807b443a542142f236497641", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -156,7 +156,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_tup(ref elems) => {\n             Univariant(mk_struct(cx, elems[], false, t), false)\n         }\n-        ty::ty_struct(def_id, ref substs) => {\n+        ty::ty_struct(def_id, substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n             let mut ftys = fields.iter().map(|field| {\n                 ty::lookup_field_type(cx.tcx(), def_id, field.id, substs)\n@@ -167,12 +167,12 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             Univariant(mk_struct(cx, ftys[], packed, t), dtor)\n         }\n-        ty::ty_unboxed_closure(def_id, _, ref substs) => {\n+        ty::ty_unboxed_closure(def_id, _, substs) => {\n             let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs);\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n             Univariant(mk_struct(cx, upvar_types[], false, t), false)\n         }\n-        ty::ty_enum(def_id, ref substs) => {\n+        ty::ty_enum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n             let hint = *ty::lookup_repr_hints(cx.tcx(), def_id)[].get(0)\n                 .unwrap_or(&attr::ReprAny);\n@@ -361,7 +361,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n         },\n \n         // Is this the NonZero lang item wrapping a pointer or integer type?\n-        ty::ty_struct(did, ref substs) if Some(did) == tcx.lang_items.non_zero() => {\n+        ty::ty_struct(did, substs) if Some(did) == tcx.lang_items.non_zero() => {\n             let nonzero_fields = ty::lookup_struct_fields(tcx, did);\n             assert_eq!(nonzero_fields.len(), 1);\n             let nonzero_field = ty::lookup_field_type(tcx, did, nonzero_fields[0].id, substs);\n@@ -376,7 +376,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // Perhaps one of the fields of this struct is non-zero\n         // let's recurse and find out\n-        ty::ty_struct(def_id, ref substs) => {\n+        ty::ty_struct(def_id, substs) => {\n             let fields = ty::lookup_struct_fields(tcx, def_id);\n             for (j, field) in fields.iter().enumerate() {\n                 let field_ty = ty::lookup_field_type(tcx, def_id, field.id, substs);"}, {"sha": "dd5809730d6f53ef900c44e73d3c543359856d64", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 45, "deletions": 19, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -264,10 +264,10 @@ pub fn self_type_for_unboxed_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let unboxed_closure = &(*unboxed_closures)[closure_id];\n     match unboxed_closure.kind {\n         ty::FnUnboxedClosureKind => {\n-            ty::mk_imm_rptr(ccx.tcx(), ty::ReStatic, fn_ty)\n+            ty::mk_imm_rptr(ccx.tcx(), ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n         }\n         ty::FnMutUnboxedClosureKind => {\n-            ty::mk_mut_rptr(ccx.tcx(), ty::ReStatic, fn_ty)\n+            ty::mk_mut_rptr(ccx.tcx(), ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n         }\n         ty::FnOnceUnboxedClosureKind => fn_ty\n     }\n@@ -288,7 +288,7 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::ty_closure(ref f) => {\n             (f.sig.0.inputs.clone(), f.sig.0.output, f.abi, Some(Type::i8p(ccx)))\n         }\n-        ty::ty_unboxed_closure(closure_did, _, ref substs) => {\n+        ty::ty_unboxed_closure(closure_did, _, substs) => {\n             let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n             let unboxed_closure = &(*unboxed_closures)[closure_did];\n             let function_type = unboxed_closure.closure_type.clone();\n@@ -529,9 +529,9 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         assert_eq!(did.krate, ast::LOCAL_CRATE);\n \n         // Since we're in trans we don't care for any region parameters\n-        let ref substs = subst::Substs::erased(substs.types.clone());\n+        let substs = subst::Substs::erased(substs.types.clone());\n \n-        let (val, _) = monomorphize::monomorphic_fn(ccx, did, substs, None);\n+        let (val, _) = monomorphize::monomorphic_fn(ccx, did, &substs, None);\n \n         val\n     } else if did.krate == ast::LOCAL_CRATE {\n@@ -749,7 +749,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n               }\n           })\n       }\n-      ty::ty_unboxed_closure(def_id, _, ref substs) => {\n+      ty::ty_unboxed_closure(def_id, _, substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs);\n           for (i, upvar) in upvars.iter().enumerate() {\n@@ -769,7 +769,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n               cx = f(cx, llfld_a, *arg);\n           }\n       }\n-      ty::ty_enum(tid, ref substs) => {\n+      ty::ty_enum(tid, substs) => {\n           let fcx = cx.fcx;\n           let ccx = fcx.ccx;\n \n@@ -2125,14 +2125,20 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span, id: ast::NodeId) {\n     let mut sizes = Vec::new(); // does no allocation if no pushes, thankfully\n \n+    let print_info = ccx.sess().print_enum_sizes();\n+\n     let levels = ccx.tcx().node_lint_levels.borrow();\n     let lint_id = lint::LintId::of(lint::builtin::VARIANT_SIZE_DIFFERENCES);\n-    let lvlsrc = match levels.get(&(id, lint_id)) {\n-        None | Some(&(lint::Allow, _)) => return,\n-        Some(&lvlsrc) => lvlsrc,\n-    };\n+    let lvlsrc = levels.get(&(id, lint_id));\n+    let is_allow = lvlsrc.map_or(true, |&(lvl, _)| lvl == lint::Allow);\n+\n+    if is_allow && !print_info {\n+        // we're not interested in anything here\n+        return\n+    }\n \n-    let avar = adt::represent_type(ccx, ty::node_id_to_type(ccx.tcx(), id));\n+    let ty = ty::node_id_to_type(ccx.tcx(), id);\n+    let avar = adt::represent_type(ccx, ty);\n     match *avar {\n         adt::General(_, ref variants, _) => {\n             for var in variants.iter() {\n@@ -2158,13 +2164,29 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n             }\n     );\n \n+    if print_info {\n+        let llty = type_of::sizing_type_of(ccx, ty);\n+\n+        let sess = &ccx.tcx().sess;\n+        sess.span_note(sp, &*format!(\"total size: {} bytes\", llsize_of_real(ccx, llty)));\n+        match *avar {\n+            adt::General(..) => {\n+                for (i, var) in enum_def.variants.iter().enumerate() {\n+                    ccx.tcx().sess.span_note(var.span,\n+                                             &*format!(\"variant data: {} bytes\", sizes[i]));\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n     // we only warn if the largest variant is at least thrice as large as\n     // the second-largest.\n-    if largest > slargest * 3 && slargest > 0 {\n+    if !is_allow && largest > slargest * 3 && slargest > 0 {\n         // Use lint::raw_emit_lint rather than sess.add_lint because the lint-printing\n         // pass for the latter already ran.\n         lint::raw_emit_lint(&ccx.tcx().sess, lint::builtin::VARIANT_SIZE_DIFFERENCES,\n-                            lvlsrc, Some(sp),\n+                            *lvlsrc.unwrap(), Some(sp),\n                             format!(\"enum variant is more than three times larger \\\n                                      ({} bytes) than the next largest (ignoring padding)\",\n                                     largest)[]);\n@@ -2332,8 +2354,12 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       ast::ItemMod(ref m) => {\n         trans_mod(&ccx.rotate(), m);\n       }\n-      ast::ItemEnum(ref enum_definition, _) => {\n-        enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n+      ast::ItemEnum(ref enum_definition, ref gens) => {\n+        if gens.ty_params.is_empty() {\n+            // sizes only make sense for non-generic types\n+\n+            enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n+        }\n       }\n       ast::ItemConst(_, ref expr) => {\n           // Recurse on the expression to catch items in blocks\n@@ -2440,7 +2466,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n     let (fn_sig, abi, has_env) = match fn_ty.sty {\n         ty::ty_closure(ref f) => (f.sig.clone(), f.abi, true),\n         ty::ty_bare_fn(_, ref f) => (f.sig.clone(), f.abi, false),\n-        ty::ty_unboxed_closure(closure_did, _, ref substs) => {\n+        ty::ty_unboxed_closure(closure_did, _, substs) => {\n             let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n             let ref function_type = (*unboxed_closures)[closure_did]\n                                                     .closure_type;\n@@ -2573,14 +2599,14 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n                     attrs.arg(idx, llvm::ReadOnlyAttribute);\n                 }\n \n-                if let ReLateBound(_, BrAnon(_)) = b {\n+                if let ReLateBound(_, BrAnon(_)) = *b {\n                     attrs.arg(idx, llvm::NoCaptureAttribute);\n                 }\n             }\n \n             // When a reference in an argument has no named lifetime, it's impossible for that\n             // reference to escape this function (returned or stored beyond the call by a closure).\n-            ty::ty_rptr(ReLateBound(_, BrAnon(_)), mt) => {\n+            ty::ty_rptr(&ReLateBound(_, BrAnon(_)), mt) => {\n                 let llsz = llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n                 attrs.arg(idx, llvm::NoCaptureAttribute)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));"}, {"sha": "e3fe749b49003a2cf2d12fd4a1a832633404cd36", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -272,14 +272,14 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n            bare_fn_ty.repr(tcx));\n \n     // This is an impl of `Fn` trait, so receiver is `&self`.\n-    let bare_fn_ty_ref = ty::mk_imm_rptr(tcx, ty::ReStatic, bare_fn_ty);\n+    let bare_fn_ty_ref = ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), bare_fn_ty);\n \n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n     let (opt_def_id, input_tys, output_ty) =\n         match bare_fn_ty.sty {\n             ty::ty_bare_fn(opt_def_id,\n-                           ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n+                           &ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n                                           abi: synabi::Rust,\n                                           sig: ty::Binder(ty::FnSig { inputs: ref input_tys,\n                                                                       output: output_ty,\n@@ -296,14 +296,15 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let tuple_input_ty = ty::mk_tup(tcx, input_tys.to_vec());\n     let tuple_fn_ty = ty::mk_bare_fn(tcx,\n                                      opt_def_id,\n-                                     ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n-                                                    abi: synabi::RustCall,\n-                                                    sig: ty::Binder(ty::FnSig {\n-                                                        inputs: vec![bare_fn_ty_ref,\n-                                                                     tuple_input_ty],\n-                                                        output: output_ty,\n-                                                        variadic: false\n-                                                    })});\n+                                     tcx.mk_bare_fn(ty::BareFnTy {\n+                                         unsafety: ast::Unsafety::Normal,\n+                                         abi: synabi::RustCall,\n+                                         sig: ty::Binder(ty::FnSig {\n+                                             inputs: vec![bare_fn_ty_ref,\n+                                                          tuple_input_ty],\n+                                             output: output_ty,\n+                                             variadic: false\n+                                         })}));\n     debug!(\"tuple_fn_ty: {}\", tuple_fn_ty.repr(tcx));\n \n     //"}, {"sha": "1f61fed3998d1bfe28e299020d1b8fdab71e8bae", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -59,7 +59,7 @@ pub use trans::context::CrateContext;\n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                        ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n-        ty::ty_struct(def_id, ref substs) => {\n+        ty::ty_struct(def_id, substs) => {\n             let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n             fields.len() == 1 &&\n                 fields[0].name =="}, {"sha": "ea2d42bebdfc4cf9a45149778a0b9ee8798bd829", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -360,11 +360,11 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::ty_float(_) => {\n                 push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n             },\n-            ty::ty_enum(def_id, ref substs) => {\n+            ty::ty_enum(def_id, substs) => {\n                 unique_type_id.push_str(\"enum \");\n                 from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n             },\n-            ty::ty_struct(def_id, ref substs) => {\n+            ty::ty_struct(def_id, substs) => {\n                 unique_type_id.push_str(\"struct \");\n                 from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n             },\n@@ -430,7 +430,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                        trait_data.principal.substs(),\n                                        &mut unique_type_id);\n             },\n-            ty::ty_bare_fn(_, ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+            ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n                 if unsafety == ast::Unsafety::Unsafe {\n                     unique_type_id.push_str(\"unsafe \");\n                 }\n@@ -469,7 +469,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                                         closure_ty.clone(),\n                                                         &mut unique_type_id);\n             },\n-            ty::ty_unboxed_closure(ref def_id, _, ref substs) => {\n+            ty::ty_unboxed_closure(ref def_id, _, substs) => {\n                 let closure_ty = cx.tcx().unboxed_closures.borrow()\n                                    .get(def_id).unwrap().closure_type.subst(cx.tcx(), substs);\n                 self.get_unique_type_id_of_closure_type(cx,\n@@ -3003,12 +3003,12 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_closure(ref closurety) => {\n             subroutine_type_metadata(cx, unique_type_id, &closurety.sig, usage_site_span)\n         }\n-        ty::ty_unboxed_closure(ref def_id, _, ref substs) => {\n+        ty::ty_unboxed_closure(ref def_id, _, substs) => {\n             let sig = cx.tcx().unboxed_closures.borrow()\n                         .get(def_id).unwrap().closure_type.sig.subst(cx.tcx(), substs);\n             subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)\n         }\n-        ty::ty_struct(def_id, ref substs) => {\n+        ty::ty_struct(def_id, substs) => {\n             prepare_struct_metadata(cx,\n                                     t,\n                                     def_id,\n@@ -3763,8 +3763,8 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_uint(ast::TyU64)  => output.push_str(\"u64\"),\n         ty::ty_float(ast::TyF32) => output.push_str(\"f32\"),\n         ty::ty_float(ast::TyF64) => output.push_str(\"f64\"),\n-        ty::ty_struct(def_id, ref substs) |\n-        ty::ty_enum(def_id, ref substs) => {\n+        ty::ty_struct(def_id, substs) |\n+        ty::ty_enum(def_id, substs) => {\n             push_item_name(cx, def_id, qualified, output);\n             push_type_params(cx, substs, output);\n         },\n@@ -3819,7 +3819,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             push_item_name(cx, trait_data.principal.def_id(), false, output);\n             push_type_params(cx, trait_data.principal.substs(), output);\n         },\n-        ty::ty_bare_fn(_, ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+        ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n             if unsafety == ast::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n             }"}, {"sha": "60b5a08c7c5df59e584c6c23b1f388b629950953", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -322,7 +322,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let substs = principal.substs().with_self_ty(unadjusted_ty).erase_regions();\n                 let trait_ref =\n                     Rc::new(ty::Binder(ty::TraitRef { def_id: principal.def_id(),\n-                                                      substs: substs }));\n+                                                      substs: bcx.tcx().mk_substs(substs) }));\n                 let trait_ref = trait_ref.subst(bcx.tcx(), bcx.fcx.param_substs);\n                 let box_ty = mk_ty(unadjusted_ty);\n                 PointerCast(bcx,\n@@ -350,7 +350,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                               expr.id,\n                                               datum_ty,\n                                               |t| ty::mk_rptr(tcx,\n-                                                              ty::ReStatic,\n+                                                              tcx.mk_region(ty::ReStatic),\n                                                               ty::mt{\n                                                                   ty: t,\n                                                                   mutbl: ast::MutImmutable\n@@ -1085,7 +1085,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              None,\n                              expr.span,\n                              expr.id,\n-                             ty::mk_struct(tcx, did, substs),\n+                             ty::mk_struct(tcx, did, tcx.mk_substs(substs)),\n                              dest)\n             } else {\n                 tcx.sess.span_bug(expr.span,\n@@ -1339,15 +1339,15 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n     F: FnOnce(ty::Disr, &[ty::field<'tcx>]) -> R,\n {\n     match ty.sty {\n-        ty::ty_struct(did, ref substs) => {\n+        ty::ty_struct(did, substs) => {\n             op(0, struct_fields(tcx, did, substs)[])\n         }\n \n         ty::ty_tup(ref v) => {\n             op(0, tup_fields(v[])[])\n         }\n \n-        ty::ty_enum(_, ref substs) => {\n+        ty::ty_enum(_, substs) => {\n             // We want the *variant* ID here, not the enum ID.\n             match node_id_opt {\n                 None => {\n@@ -2130,7 +2130,7 @@ fn auto_ref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Compute final type. Note that we are loose with the region and\n     // mutability, since those things don't matter in trans.\n     let referent_ty = lv_datum.ty;\n-    let ptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::ReStatic, referent_ty);\n+    let ptr_ty = ty::mk_imm_rptr(bcx.tcx(), bcx.tcx().mk_region(ty::ReStatic), referent_ty);\n \n     // Get the pointer.\n     let llref = lv_datum.to_llref();"}, {"sha": "e276543264b0a553c6bd00ec2e3c5baea35b2775", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -310,7 +310,7 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n         return (size, align);\n     }\n     match t.sty {\n-        ty::ty_struct(id, ref substs) => {\n+        ty::ty_struct(id, substs) => {\n             let ccx = bcx.ccx();\n             // First get the size of all statically known fields.\n             // Don't use type_of::sizing_type_of because that expects t to be sized.\n@@ -407,7 +407,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                 }\n             }\n         }\n-        ty::ty_struct(did, ref substs) | ty::ty_enum(did, ref substs) => {\n+        ty::ty_struct(did, substs) | ty::ty_enum(did, substs) => {\n             let tcx = bcx.tcx();\n             match ty::ty_dtor(tcx, did) {\n                 ty::TraitDtor(dtor, true) => {"}, {"sha": "553613a8eac0e2d350e5846de86c540a7ae60746", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -240,7 +240,7 @@ pub fn trans_static_method_callee(bcx: Block,\n                                              Vec::new()));\n     debug!(\"trait_substs={}\", trait_substs.repr(bcx.tcx()));\n     let trait_ref = Rc::new(ty::Binder(ty::TraitRef { def_id: trait_id,\n-                                                      substs: trait_substs }));\n+                                                      substs: bcx.tcx().mk_substs(trait_substs) }));\n     let vtbl = fulfill_obligation(bcx.ccx(),\n                                   DUMMY_SP,\n                                   trait_ref);\n@@ -639,7 +639,7 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                        m.repr(tcx),\n                        substs.repr(tcx));\n                 if m.generics.has_type_params(subst::FnSpace) ||\n-                    ty::type_has_self(ty::mk_bare_fn(tcx, None, m.fty.clone()))\n+                    ty::type_has_self(ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(m.fty.clone())))\n                 {\n                     debug!(\"(making impl vtable) method has self or type \\\n                             params: {}\","}, {"sha": "81e6ec4df562714010173f4ee0f3fc91f19e3d37", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -633,7 +633,7 @@ fn ast_path_to_trait_ref<'tcx,AC,RS>(\n                                             regions,\n                                             assoc_bindings);\n \n-    ty::TraitRef::new(trait_def_id, substs)\n+    ty::TraitRef::new(trait_def_id, this.tcx().mk_substs(substs))\n }\n \n pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n@@ -940,7 +940,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n                 debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n                 let t = ast_ty_to_ty(this, rscope, &*mt.ty);\n-                ty::mk_rptr(tcx, r, ty::mt {ty: t, mutbl: mt.mutbl})\n+                ty::mk_rptr(tcx, tcx.mk_region(r), ty::mt {ty: t, mutbl: mt.mutbl})\n             }\n             ast::TyTup(ref fields) => {\n                 let flds = fields.iter()\n@@ -954,7 +954,8 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     tcx.sess.span_err(ast_ty.span,\n                                       \"variadic function must have C calling convention\");\n                 }\n-                ty::mk_bare_fn(tcx, None, ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl))\n+                let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl);\n+                ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(bare_fn))\n             }\n             ast::TyClosure(ref f) => {\n                 // Use corresponding trait store to figure out default bounds\n@@ -1217,7 +1218,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n                 }\n                 ty::ByReferenceExplicitSelfCategory(region, mutability) => {\n                     (Some(ty::mk_rptr(this.tcx(),\n-                                      region,\n+                                      this.tcx().mk_region(region),\n                                       ty::mt {\n                                         ty: self_info.untransformed_self_ty,\n                                         mutbl: mutability\n@@ -1350,7 +1351,7 @@ fn determine_explicit_self_category<'a, 'tcx, AC: AstConv<'tcx>,\n                 ty::ByValueExplicitSelfCategory\n             } else {\n                 match explicit_type.sty {\n-                    ty::ty_rptr(r, mt) => ty::ByReferenceExplicitSelfCategory(r, mt.mutbl),\n+                    ty::ty_rptr(r, mt) => ty::ByReferenceExplicitSelfCategory(*r, mt.mutbl),\n                     ty::ty_uniq(_) => ty::ByBoxExplicitSelfCategory,\n                     _ => ty::ByValueExplicitSelfCategory,\n                 }"}, {"sha": "09a5dd521f882de6dd28dc4c881bf6fdc7e8ab9d", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -93,7 +93,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     // and T is the expected type\n                     let region_var = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n                     let mt = ty::mt { ty: expected, mutbl: mutbl };\n-                    let region_ty = ty::mk_rptr(tcx, region_var, mt);\n+                    let region_ty = ty::mk_rptr(tcx, tcx.mk_region(region_var), mt);\n                     demand::eqtype(fcx, pat.span, region_ty, typ);\n                 }\n                 // otherwise the type of x is the expected type T\n@@ -154,7 +154,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             let mt = ty::mt { ty: inner_ty, mutbl: mutbl };\n             let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n-            let rptr_ty = ty::mk_rptr(tcx, region, mt);\n+            let rptr_ty = ty::mk_rptr(tcx, tcx.mk_region(region), mt);\n \n             if check_dereferencable(pcx, pat.span, expected, &**inner) {\n                 demand::suptype(fcx, pat.span, expected, rptr_ty);\n@@ -178,7 +178,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 })),\n                 _ => {\n                     let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n-                    ty::mk_slice(tcx, region, ty::mt {\n+                    ty::mk_slice(tcx, tcx.mk_region(region), ty::mt {\n                         ty: inner_ty,\n                         mutbl: ty::deref(expected_ty, true)\n                             .map_or(ast::MutImmutable, |mt| mt.mutbl)\n@@ -197,7 +197,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 let mutbl = ty::deref(expected_ty, true)\n                     .map_or(ast::MutImmutable, |mt| mt.mutbl);\n \n-                let slice_ty = ty::mk_slice(tcx, region, ty::mt {\n+                let slice_ty = ty::mk_slice(tcx, tcx.mk_region(region), ty::mt {\n                     ty: inner_ty,\n                     mutbl: mutbl\n                 });\n@@ -411,13 +411,13 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n \n     let real_path_ty = fcx.node_ty(pat.id);\n     let (arg_tys, kind_name) = match real_path_ty.sty {\n-        ty::ty_enum(enum_def_id, ref expected_substs)\n+        ty::ty_enum(enum_def_id, expected_substs)\n             if def == def::DefVariant(enum_def_id, def.def_id(), false) => {\n             let variant = ty::enum_variant_with_id(tcx, enum_def_id, def.def_id());\n             (variant.args.iter().map(|t| t.subst(tcx, expected_substs)).collect::<Vec<_>>(),\n                 \"variant\")\n         }\n-        ty::ty_struct(struct_def_id, ref expected_substs) => {\n+        ty::ty_struct(struct_def_id, expected_substs) => {\n             let struct_fields = ty::struct_fields(tcx, struct_def_id, expected_substs);\n             (struct_fields.iter().map(|field| field.mt.ty).collect::<Vec<_>>(),\n                 \"struct\")"}, {"sha": "c8a8a0ff55908b07ea0615417d53a2d4cdf7aadb", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -126,8 +126,9 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n     let closure_type = ty::mk_unboxed_closure(fcx.ccx.tcx,\n                                               expr_def_id,\n-                                              region,\n-                                              fcx.inh.param_env.free_substs.clone());\n+                                              fcx.ccx.tcx.mk_region(region),\n+                                              fcx.ccx.tcx.mk_substs(\n+                                                  fcx.inh.param_env.free_substs.clone()));\n \n     fcx.write_ty(expr.id, closure_type);\n "}, {"sha": "8ce7a7edb46d1011b631e2d7d6b3c9ed504a0fb4", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -113,11 +113,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         self.add_obligations(&pick, &method_bounds_substs, &method_bounds);\n \n         // Create the final `MethodCallee`.\n-        let fty = ty::mk_bare_fn(self.tcx(), None, ty::BareFnTy {\n+        let fty = ty::mk_bare_fn(self.tcx(), None, self.tcx().mk_bare_fn(ty::BareFnTy {\n             sig: ty::Binder(method_sig),\n             unsafety: pick.method_ty.fty.unsafety,\n             abi: pick.method_ty.fty.abi.clone(),\n-        });\n+        }));\n         let callee = MethodCallee {\n             origin: method_origin,\n             ty: fty,\n@@ -223,7 +223,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     // been ruled out when we deemed the trait to be\n                     // \"object safe\".\n                     let original_poly_trait_ref =\n-                        data.principal_trait_ref_with_self_ty(object_ty);\n+                        data.principal_trait_ref_with_self_ty(this.tcx(), object_ty);\n                     let upcast_poly_trait_ref =\n                         this.upcast(original_poly_trait_ref.clone(), trait_def_id);\n                     let upcast_trait_ref =\n@@ -275,7 +275,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                                                  self.infcx().next_ty_var());\n \n                 let trait_ref =\n-                    Rc::new(ty::TraitRef::new(trait_def_id, substs.clone()));\n+                    Rc::new(ty::TraitRef::new(trait_def_id, self.tcx().mk_substs(substs.clone())));\n                 let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n                                                            method_num: method_num });\n                 (substs, origin)"}, {"sha": "0c094823a75751d55478ffcc2c45ac719a87b3cd", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -164,7 +164,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n     // Construct a trait-reference `self_ty : Trait<input_tys>`\n     let substs = subst::Substs::new_trait(input_types, Vec::new(), assoc_types, self_ty);\n-    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n+    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, fcx.tcx().mk_substs(substs)));\n \n     // Construct an obligation\n     let poly_trait_ref = Rc::new(ty::Binder((*trait_ref).clone()));\n@@ -194,16 +194,16 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     // Substitute the trait parameters into the method type and\n     // instantiate late-bound regions to get the actual method type.\n     let ref bare_fn_ty = method_ty.fty;\n-    let fn_sig = bare_fn_ty.sig.subst(tcx, &trait_ref.substs);\n+    let fn_sig = bare_fn_ty.sig.subst(tcx, trait_ref.substs);\n     let fn_sig = fcx.infcx().replace_late_bound_regions_with_fresh_var(span,\n                                                                        infer::FnCall,\n                                                                        &fn_sig).0;\n     let transformed_self_ty = fn_sig.inputs[0];\n-    let fty = ty::mk_bare_fn(tcx, None, ty::BareFnTy {\n+    let fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(ty::BareFnTy {\n         sig: ty::Binder(fn_sig),\n         unsafety: bare_fn_ty.unsafety,\n         abi: bare_fn_ty.abi.clone(),\n-    });\n+    }));\n \n     debug!(\"lookup_in_trait_adjusted: matched method fty={} obligation={}\",\n            fty.repr(fcx.tcx()),\n@@ -217,7 +217,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     //\n     // Note that as the method comes from a trait, it should not have\n     // any late-bound regions appearing in its bounds.\n-    let method_bounds = method_ty.generics.to_bounds(fcx.tcx(), &trait_ref.substs);\n+    let method_bounds = method_ty.generics.to_bounds(fcx.tcx(), trait_ref.substs);\n     assert!(!method_bounds.has_escaping_regions());\n     fcx.add_obligations_for_parameters(\n         traits::ObligationCause::misc(span, fcx.body_id),\n@@ -260,7 +260,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                 span,\n                                 ty::AdjustDerefRef(ty::AutoDerefRef {\n                                     autoderefs: autoderefs,\n-                                    autoref: Some(ty::AutoPtr(region, mutbl, autoref))\n+                                    autoref: Some(ty::AutoPtr(*region, mutbl, autoref))\n                                 }));\n                         }\n \n@@ -425,4 +425,3 @@ fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .find(|m| m.name() == method_name)\n         .and_then(|item| item.as_opt_method())\n }\n-"}, {"sha": "3ecd2007ff13cc775d0dacfb39befd6ace8c75a0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -305,7 +305,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // a substitution that replaces `Self` with the object type\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n-        let trait_ref = data.principal_trait_ref_with_self_ty(self_ty);\n+        let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n         self.elaborate_bounds(&[trait_ref.clone()], false, |this, new_trait_ref, m, method_num| {\n             let vtable_index =\n                 get_method_index(tcx, &*new_trait_ref, trait_ref.clone(), method_num);\n@@ -499,7 +499,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             // Determine the receiver type that the method itself expects.\n             let xform_self_ty =\n-                self.xform_self_ty(&method, &impl_trait_ref.substs);\n+                self.xform_self_ty(&method, impl_trait_ref.substs);\n \n             debug!(\"xform_self_ty={}\", xform_self_ty.repr(self.tcx()));\n \n@@ -657,7 +657,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let tcx = self.tcx();\n         self.search_mutabilities(\n             |m| AutoRef(m, box step.adjustment.clone()),\n-            |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:step.self_ty, mutbl:m}))\n+            |m,r| ty::mk_rptr(tcx, tcx.mk_region(r), ty::mt {ty:step.self_ty, mutbl:m}))\n     }\n \n     fn search_mutabilities<F, G>(&mut self,"}, {"sha": "68cf139338aa2f5b7beb03eb123ddc6519571f3a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -1154,9 +1154,9 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n \n     // Compute skolemized form of impl and trait method tys.\n-    let impl_fty = ty::mk_bare_fn(tcx, None, impl_m.fty.clone());\n+    let impl_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(impl_m.fty.clone()));\n     let impl_fty = impl_fty.subst(tcx, &impl_to_skol_substs);\n-    let trait_fty = ty::mk_bare_fn(tcx, None, trait_m.fty.clone());\n+    let trait_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(trait_m.fty.clone()));\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n     // Check the impl method type IM is a subtype of the trait method\n@@ -2736,9 +2736,10 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-        ast::LitStr(..) => ty::mk_str_slice(tcx, ty::ReStatic, ast::MutImmutable),\n+        ast::LitStr(..) => ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic), ast::MutImmutable),\n         ast::LitBinary(..) => {\n-            ty::mk_slice(tcx, ty::ReStatic, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable })\n+            ty::mk_slice(tcx, tcx.mk_region(ty::ReStatic),\n+                         ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable })\n         }\n         ast::LitByte(_) => ty::mk_u8(),\n         ast::LitChar(_) => ty::mk_char(),\n@@ -2949,7 +2950,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         });\n \n         let fn_sig = match fn_ty.sty {\n-            ty::ty_bare_fn(_, ty::BareFnTy {ref sig, ..}) |\n+            ty::ty_bare_fn(_, &ty::BareFnTy {ref sig, ..}) |\n             ty::ty_closure(box ty::ClosureTy {ref sig, ..}) => sig,\n             _ => {\n                 fcx.type_error_message(call_expr.span, |actual| {\n@@ -3098,8 +3099,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 let (adj_ty, adjustment) = match lhs_ty.sty {\n                     ty::ty_rptr(r_in, mt) => {\n                         let r_adj = fcx.infcx().next_region_var(infer::Autoref(lhs.span));\n-                        fcx.mk_subr(infer::Reborrow(lhs.span), r_adj, r_in);\n-                        let adjusted_ty = ty::mk_rptr(fcx.tcx(), r_adj, mt);\n+                        fcx.mk_subr(infer::Reborrow(lhs.span), r_adj, *r_in);\n+                        let adjusted_ty = ty::mk_rptr(fcx.tcx(), fcx.tcx().mk_region(r_adj), mt);\n                         let autoptr = ty::AutoPtr(r_adj, mt.mutbl, None);\n                         let adjustment = ty::AutoDerefRef { autoderefs: 1, autoref: Some(autoptr) };\n                         (adjusted_ty, adjustment)\n@@ -3331,7 +3332,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let (_, autoderefs, field_ty) =\n             autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n                 match base_t.sty {\n-                    ty::ty_struct(base_id, ref substs) => {\n+                    ty::ty_struct(base_id, substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n                         lookup_field_ty(tcx, base_id, fields[],\n@@ -3392,7 +3393,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let (_, autoderefs, field_ty) =\n             autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n                 match base_t.sty {\n-                    ty::ty_struct(base_id, ref substs) => {\n+                    ty::ty_struct(base_id, substs) => {\n                         tuple_like = ty::is_tuple_struct(tcx, base_id);\n                         if tuple_like {\n                             debug!(\"tuple struct named {}\", ppaux::ty_to_string(tcx, base_t));\n@@ -3443,7 +3444,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 span: Span,\n                                                 class_id: ast::DefId,\n                                                 node_id: ast::NodeId,\n-                                                substitutions: subst::Substs<'tcx>,\n+                                                substitutions: &'tcx subst::Substs<'tcx>,\n                                                 field_types: &[ty::field_ty],\n                                                 ast_fields: &[ast::Field],\n                                                 check_completeness: bool,\n@@ -3495,7 +3496,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 Some((field_id, false)) => {\n                     expected_field_type =\n                         ty::lookup_field_type(\n-                            tcx, class_id, field_id, &substitutions);\n+                            tcx, class_id, field_id, substitutions);\n                     class_field_map.insert(\n                         field.ident.node.name, (field_id, true));\n                     fields_found += 1;\n@@ -3561,7 +3562,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        span,\n                                        class_id,\n                                        id,\n-                                       struct_substs,\n+                                       fcx.ccx.tcx.mk_substs(struct_substs),\n                                        class_fields[],\n                                        fields,\n                                        base_expr.is_none(),\n@@ -3604,7 +3605,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        span,\n                                        variant_id,\n                                        id,\n-                                       substitutions,\n+                                       fcx.ccx.tcx.mk_substs(substitutions),\n                                        variant_fields[],\n                                        fields,\n                                        true,\n@@ -3737,7 +3738,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             Some(mt) => mt.ty,\n                             None => {\n                                 let is_newtype = match oprnd_t.sty {\n-                                    ty::ty_struct(did, ref substs) => {\n+                                    ty::ty_struct(did, substs) => {\n                                         let fields = ty::struct_fields(fcx.tcx(), did, substs);\n                                         fields.len() == 1\n                                         && fields[0].name ==\n@@ -3839,11 +3840,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     // `'static`!\n                     let region = fcx.infcx().next_region_var(\n                         infer::AddrOfSlice(expr.span));\n-                    ty::mk_rptr(tcx, region, tm)\n+                    ty::mk_rptr(tcx, tcx.mk_region(region), tm)\n                 }\n                 _ => {\n                     let region = fcx.infcx().next_region_var(infer::AddrOfRegion(expr.span));\n-                    ty::mk_rptr(tcx, region, tm)\n+                    ty::mk_rptr(tcx, tcx.mk_region(region), tm)\n                 }\n             }\n         };\n@@ -4354,7 +4355,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                  traits::ItemObligation(did)),\n                     &bounds);\n \n-                ty::mk_struct(tcx, did, substs)\n+                ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n             } else {\n                 ty::mk_err()\n             }\n@@ -4749,7 +4750,7 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n         return;\n     }\n     match t.sty {\n-        ty::ty_struct(did, ref substs) => {\n+        ty::ty_struct(did, substs) => {\n             let fields = ty::lookup_struct_fields(tcx, did);\n             if fields.is_empty() {\n                 span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n@@ -5502,7 +5503,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             match t.sty {\n                 ty::ty_param(ParamTy {idx, ..}) => {\n                     debug!(\"Found use of ty param num {}\", idx);\n-                    tps_used[idx] = true;\n+                    tps_used[idx as uint] = true;\n                 }\n                 _ => ()\n             }\n@@ -5518,7 +5519,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n-    fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: uint) -> Ty<'tcx> {\n+    fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n         ty::mk_param(ccx.tcx, subst::FnSpace, n, local_def(0))\n     }\n \n@@ -5561,16 +5562,18 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1u, Vec::new(), ty::mk_uint()),\n-            \"init\" => (1u, Vec::new(), param(ccx, 0u)),\n-            \"uninit\" => (1u, Vec::new(), param(ccx, 0u)),\n+            \"init\" => (1u, Vec::new(), param(ccx, 0)),\n+            \"uninit\" => (1u, Vec::new(), param(ccx, 0)),\n             \"forget\" => (1u, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n             \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n             \"move_val_init\" => {\n                 (1u,\n                  vec!(\n-                    ty::mk_mut_rptr(tcx, ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(0)),\n+                    ty::mk_mut_rptr(tcx,\n+                                    tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                                                                  ty::BrAnon(0))),\n                                     param(ccx, 0)),\n-                    param(ccx, 0u)\n+                    param(ccx, 0)\n                   ),\n                ty::mk_nil(tcx))\n             }\n@@ -5594,7 +5597,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                     Ok(did) => (1u,\n                                 Vec::new(),\n                                 ty::mk_struct(ccx.tcx, did,\n-                                              subst::Substs::empty())),\n+                                              ccx.tcx.mk_substs(subst::Substs::empty()))),\n                     Err(msg) => {\n                         tcx.sess.span_fatal(it.span, msg[]);\n                     }\n@@ -5769,15 +5772,15 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         };\n         (n_tps, inputs, ty::FnConverging(output))\n     };\n-    let fty = ty::mk_bare_fn(tcx, None, ty::BareFnTy {\n+    let fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: ast::Unsafety::Unsafe,\n         abi: abi::RustIntrinsic,\n         sig: ty::Binder(FnSig {\n             inputs: inputs,\n             output: output,\n             variadic: false,\n         }),\n-    });\n+    }));\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n     if i_n_tps != n_tps {\n@@ -5798,4 +5801,3 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             });\n     }\n }\n-"}, {"sha": "b8cf215f89eeca4e57dc9a66409c7a8df54d96a9", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -645,7 +645,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             };\n             if let ty::ty_rptr(r_ptr, _) = base_ty.sty {\n                 mk_subregion_due_to_dereference(\n-                    rcx, expr.span, ty::ReScope(CodeExtent::from_node_id(expr.id)), r_ptr);\n+                    rcx, expr.span, ty::ReScope(CodeExtent::from_node_id(expr.id)), *r_ptr);\n             }\n \n             visit::walk_expr(rcx, expr);\n@@ -763,7 +763,7 @@ fn constrain_cast(rcx: &mut Rcx,\n             /*From:*/ (&ty::ty_rptr(from_r, ref from_mt),\n             /*To:  */  &ty::ty_rptr(to_r, ref to_mt)) => {\n                 // Target cannot outlive source, naturally.\n-                rcx.fcx.mk_subr(infer::Reborrow(cast_expr.span), to_r, from_r);\n+                rcx.fcx.mk_subr(infer::Reborrow(cast_expr.span), *to_r, *from_r);\n                 walk_cast(rcx, cast_expr, from_mt.ty, to_mt.ty);\n             }\n \n@@ -822,7 +822,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                         // Variables being referenced must be constrained and registered\n                         // in the upvar borrow map\n                         constrain_free_variables_in_by_ref_closure(\n-                            rcx, region, expr, freevars);\n+                            rcx, *region, expr, freevars);\n                     }\n                 })\n             }\n@@ -858,7 +858,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         }\n         ty::ty_unboxed_closure(_, region, _) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n-                let bounds = ty::region_existential_bound(region);\n+                let bounds = ty::region_existential_bound(*region);\n                 ensure_free_variable_types_outlive_closure_bound(rcx, bounds, expr, freevars);\n             })\n         }\n@@ -897,7 +897,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             let var_ty = match rcx.fcx.inh.upvar_borrow_map.borrow().get(&upvar_id) {\n                 Some(upvar_borrow) => {\n                     ty::mk_rptr(rcx.tcx(),\n-                                upvar_borrow.region,\n+                                rcx.tcx().mk_region(upvar_borrow.region),\n                                 ty::mt { mutbl: upvar_borrow.kind.to_mutbl_lossy(),\n                                          ty: raw_var_ty })\n                 }\n@@ -1137,7 +1137,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n                     let self_cmt = mc.cat_expr_autoderefd(deref_expr, i);\n-                    link_region(rcx, deref_expr.span, r,\n+                    link_region(rcx, deref_expr.span, *r,\n                                 ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n \n@@ -1158,7 +1158,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n \n         if let ty::ty_rptr(r_ptr, _) =  derefd_ty.sty {\n             mk_subregion_due_to_dereference(rcx, deref_expr.span,\n-                                            r_deref_expr, r_ptr);\n+                                            r_deref_expr, *r_ptr);\n         }\n \n         match ty::deref(derefd_ty, true) {\n@@ -1193,7 +1193,7 @@ fn constrain_index<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n         match mt.ty.sty {\n             ty::ty_vec(_, None) | ty::ty_str => {\n                 rcx.fcx.mk_subr(infer::IndexSlice(index_expr.span),\n-                                r_index_expr, r_ptr);\n+                                r_index_expr, *r_ptr);\n             }\n             _ => {}\n         }"}, {"sha": "ea70b9d9e2ef16f75028211b42cbbca4ef2c1feb", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -93,7 +93,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                 // captured by reference it must also outlive the\n                 // region bound on the closure, but this is explicitly\n                 // handled by logic in regionck.\n-                self.push_region_constraint_from_top(region);\n+                self.push_region_constraint_from_top(*region);\n             }\n \n             ty::ty_trait(ref t) => {\n@@ -102,8 +102,8 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                 self.accumulate_from_object_ty(ty, t.bounds.region_bound, required_region_bounds)\n             }\n \n-            ty::ty_enum(def_id, ref substs) |\n-            ty::ty_struct(def_id, ref substs) => {\n+            ty::ty_enum(def_id, substs) |\n+            ty::ty_struct(def_id, substs) => {\n                 self.accumulate_from_adt(ty, def_id, substs)\n             }\n \n@@ -114,7 +114,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n             }\n \n             ty::ty_rptr(r_b, mt) => {\n-                self.accumulate_from_rptr(ty, r_b, mt.ty);\n+                self.accumulate_from_rptr(ty, *r_b, mt.ty);\n             }\n \n             ty::ty_param(p) => {"}, {"sha": "ff16568aa63fcc92cfa343a8aff7e7c7e038c957", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -63,8 +63,8 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 // Ensure that if &'a T is cast to &'b Trait, then 'b <= 'a\n                 infer::mk_subr(fcx.infcx(),\n                                infer::RelateObjectBound(source_expr.span),\n-                               target_region,\n-                               referent_region);\n+                               *target_region,\n+                               *referent_region);\n \n                 check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n             }\n@@ -133,7 +133,7 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  object_trait: &ty::TyTrait<'tcx>,\n                                  span: Span)\n {\n-    let object_trait_ref = object_trait.principal_trait_ref_with_self_ty(ty::mk_err());\n+    let object_trait_ref = object_trait.principal_trait_ref_with_self_ty(tcx, ty::mk_err());\n     for tr in traits::supertraits(tcx, object_trait_ref) {\n         check_object_safety_inner(tcx, &*tr, span);\n     }\n@@ -251,7 +251,7 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Create the obligation for casting from T to Trait.\n     let object_trait_ref =\n-        object_trait.principal_trait_ref_with_self_ty(referent_ty);\n+        object_trait.principal_trait_ref_with_self_ty(fcx.tcx(), referent_ty);\n     let object_obligation =\n         Obligation::new(\n             ObligationCause::new(span,"}, {"sha": "258177bb72096ba9259d0f3ddf8f35584e6cde22", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -264,7 +264,7 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n     pub fn check_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n         let trait_def = ty::lookup_trait_def(self.fcx.tcx(), trait_ref.def_id);\n \n-        let bounds = trait_def.generics.to_bounds(self.tcx(), &trait_ref.substs);\n+        let bounds = trait_def.generics.to_bounds(self.tcx(), trait_ref.substs);\n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n                 self.span,\n@@ -311,8 +311,8 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         }\n \n         match t.sty{\n-            ty::ty_struct(type_id, ref substs) |\n-            ty::ty_enum(type_id, ref substs) => {\n+            ty::ty_struct(type_id, substs) |\n+            ty::ty_enum(type_id, substs) => {\n                 let polytype = ty::lookup_item_type(self.fcx.tcx(), type_id);\n \n                 if self.binding_count == 0 {\n@@ -355,7 +355,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n \n                 self.fold_substs(substs);\n             }\n-            ty::ty_bare_fn(_, ty::BareFnTy{sig: ref fn_sig, ..}) |\n+            ty::ty_bare_fn(_, &ty::BareFnTy{sig: ref fn_sig, ..}) |\n             ty::ty_closure(box ty::ClosureTy{sig: ref fn_sig, ..}) => {\n                 self.binding_count += 1;\n "}, {"sha": "f92c7764a69b06b177cc0d1572a23a336c66f0eb", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -235,7 +235,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             // impl, plus its own.\n             let new_polytype = ty::Polytype {\n                 generics: new_method_ty.generics.clone(),\n-                ty: ty::mk_bare_fn(tcx, Some(new_did), new_method_ty.fty.clone())\n+                ty: ty::mk_bare_fn(tcx, Some(new_did),\n+                                   tcx.mk_bare_fn(new_method_ty.fty.clone()))\n             };\n             debug!(\"new_polytype={}\", new_polytype.repr(tcx));\n "}, {"sha": "793c5f5b4a058b0af0543e6d06688df4fdf76ad6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -355,7 +355,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             m.def_id,\n             Polytype {\n                 generics: m.generics.clone(),\n-                ty: ty::mk_bare_fn(ccx.tcx, Some(m.def_id), m.fty.clone()) });\n+                ty: ty::mk_bare_fn(ccx.tcx, Some(m.def_id), ccx.tcx.mk_bare_fn(m.fty.clone())) });\n     }\n \n     fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -529,7 +529,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                                        untransformed_rcvr_ty,\n                                        rcvr_ty_generics,\n                                        rcvr_visibility));\n-        let fty = ty::mk_bare_fn(tcx, Some(m_def_id), mty.fty.clone());\n+        let fty = ty::mk_bare_fn(tcx, Some(m_def_id), tcx.mk_bare_fn(mty.fty.clone()));\n         debug!(\"method {} (id {}) has type {}\",\n                 m.pe_ident().repr(tcx),\n                 m.id,\n@@ -651,7 +651,7 @@ fn is_associated_type_valid_for_param(ty: Ty,\n                                       generics: &ty::Generics)\n                                       -> bool {\n     if let ty::ty_param(param_ty) = ty.sty {\n-        let type_parameter = generics.types.get(param_ty.space, param_ty.idx);\n+        let type_parameter = generics.types.get(param_ty.space, param_ty.idx as uint);\n         for trait_bound in type_parameter.bounds.trait_bounds.iter() {\n             if trait_bound.def_id() == trait_id {\n                 return true\n@@ -1264,7 +1264,7 @@ pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     tcx.struct_fields.borrow_mut().insert(local_def(id), Rc::new(field_tys));\n \n     let substs = mk_item_substs(ccx, &pty.generics);\n-    let selfty = ty::mk_struct(tcx, local_def(id), substs);\n+    let selfty = ty::mk_struct(tcx, local_def(id), tcx.mk_substs(substs));\n \n     // If this struct is enum-like or tuple-like, create the type of its\n     // constructor.\n@@ -1353,11 +1353,11 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     };\n \n-    let substs = mk_trait_substs(ccx, it.id, generics, items);\n+    let substs = ccx.tcx.mk_substs(mk_trait_substs(ccx, it.id, generics, items));\n \n     let ty_generics = ty_generics_for_trait(ccx,\n                                             it.id,\n-                                            &substs,\n+                                            substs,\n                                             generics,\n                                             items);\n \n@@ -1377,7 +1377,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         bounds: bounds,\n         trait_ref: Rc::new(ty::TraitRef {\n             def_id: def_id,\n-            substs: substs\n+            substs: ccx.tcx.mk_substs(substs)\n         })\n     });\n     tcx.trait_defs.borrow_mut().insert(def_id, trait_def.clone());\n@@ -1397,7 +1397,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     .enumerate()\n                     .map(|(i, def)| ty::ReEarlyBound(def.lifetime.id,\n                                                      subst::TypeSpace,\n-                                                     i,\n+                                                     i as u32,\n                                                      def.lifetime.name))\n                     .collect();\n \n@@ -1407,7 +1407,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     .iter()\n                     .enumerate()\n                     .map(|(i, def)| ty::mk_param(ccx.tcx, subst::TypeSpace,\n-                                                 i, local_def(def.id)))\n+                                                 i as u32, local_def(def.id)))\n                     .collect();\n \n         // ...and also create generics synthesized from the associated types.\n@@ -1465,7 +1465,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n             };\n             let pty = Polytype {\n                 generics: ty_generics,\n-                ty: ty::mk_bare_fn(ccx.tcx, Some(local_def(it.id)), tofd)\n+                ty: ty::mk_bare_fn(ccx.tcx, Some(local_def(it.id)), ccx.tcx.mk_bare_fn(tofd))\n             };\n             debug!(\"type of {} (id {}) is {}\",\n                     token::get_ident(it.ident),\n@@ -1502,7 +1502,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n                 generics,\n                 DontCreateTypeParametersForAssociatedTypes);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let t = ty::mk_enum(tcx, local_def(it.id), substs);\n+            let t = ty::mk_enum(tcx, local_def(it.id), tcx.mk_substs(substs));\n             let pty = Polytype {\n                 generics: ty_generics,\n                 ty: t\n@@ -1520,7 +1520,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n                 generics,\n                 DontCreateTypeParametersForAssociatedTypes);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let t = ty::mk_struct(tcx, local_def(it.id), substs);\n+            let t = ty::mk_struct(tcx, local_def(it.id), tcx.mk_substs(substs));\n             let pty = Polytype {\n                 generics: ty_generics,\n                 ty: t\n@@ -1598,7 +1598,7 @@ fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n-                                   substs: &subst::Substs<'tcx>,\n+                                   substs: &'tcx subst::Substs<'tcx>,\n                                    ast_generics: &ast::Generics,\n                                    items: &[ast::TraitItem])\n                                    -> ty::Generics<'tcx>\n@@ -1621,7 +1621,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         ccx,\n                         subst::AssocSpace,\n                         &associated_type.ty_param,\n-                        generics.types.len(subst::AssocSpace),\n+                        generics.types.len(subst::AssocSpace) as u32,\n                         Some(local_def(trait_id)));\n                 ccx.tcx.ty_param_defs.borrow_mut().insert(associated_type.ty_param.id,\n                                                           def.clone());\n@@ -1639,7 +1639,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let self_trait_ref =\n         Rc::new(ty::Binder(ty::TraitRef { def_id: local_def(trait_id),\n-                                          substs: (*substs).clone() }));\n+                                          substs: substs }));\n \n     let def = ty::TypeParameterDef {\n         space: subst::SelfSpace,\n@@ -1746,7 +1746,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                              .collect();\n         let def = ty::RegionParameterDef { name: l.lifetime.name,\n                                            space: space,\n-                                           index: i,\n+                                           index: i as u32,\n                                            def_id: local_def(l.lifetime.id),\n                                            bounds: bounds };\n         debug!(\"ty_generics: def for region param: {}\", def);\n@@ -1775,7 +1775,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n         let def = get_or_create_type_parameter_def(&gcx,\n                                                    space,\n                                                    param,\n-                                                   i,\n+                                                   i as u32,\n                                                    None);\n         debug!(\"ty_generics: def for type param: {}, {}\",\n                def.repr(this.tcx()),\n@@ -1788,7 +1788,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                                                           .get_slice(space)\n                                                           .iter() {\n         assert!(result.types.get_slice(space).len() ==\n-                associated_type_param.index);\n+                associated_type_param.index as uint);\n         debug!(\"ty_generics: def for associated type: {}, {}\",\n                associated_type_param.repr(this.tcx()),\n                space);\n@@ -1915,7 +1915,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                         name: associated_type_def.name,\n                         def_id: associated_type_def.def_id,\n                         space: space,\n-                        index: types.len() + index,\n+                        index: types.len() as u32 + index,\n                         bounds: ty::ParamBounds {\n                             builtin_bounds: associated_type_def.bounds.builtin_bounds,\n \n@@ -1963,7 +1963,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n                                              space: subst::ParamSpace,\n                                              param: &ast::TyParam,\n-                                             index: uint,\n+                                             index: u32,\n                                              associated_with: Option<ast::DefId>)\n                                              -> ty::TypeParameterDef<'tcx>\n     where AC: AstConv<'tcx>\n@@ -2143,13 +2143,13 @@ pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let t_fn = ty::mk_bare_fn(\n         ccx.tcx,\n         None,\n-        ty::BareFnTy {\n+        ccx.tcx.mk_bare_fn(ty::BareFnTy {\n             abi: abi,\n             unsafety: ast::Unsafety::Unsafe,\n             sig: ty::Binder(ty::FnSig {inputs: input_tys,\n-                                       output: output,\n-                                       variadic: decl.variadic}),\n-        });\n+                            output: output,\n+                            variadic: decl.variadic})\n+        }));\n     let pty = Polytype {\n         generics: ty_generics_for_fn_or_method,\n         ty: t_fn"}, {"sha": "3418cded022c9776cb1a6d9e392f34fc3069f431", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -225,15 +225,15 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 }\n                 _ => ()\n             }\n-            let se_ty = ty::mk_bare_fn(tcx, Some(local_def(main_id)), ty::BareFnTy {\n+            let se_ty = ty::mk_bare_fn(tcx, Some(local_def(main_id)), tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: Vec::new(),\n                     output: ty::FnConverging(ty::mk_nil(tcx)),\n                     variadic: false\n                 })\n-            });\n+            }));\n \n             require_same_types(tcx, None, false, main_span, main_t, se_ty,\n                 || {\n@@ -273,7 +273,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n \n-            let se_ty = ty::mk_bare_fn(tcx, Some(local_def(start_id)), ty::BareFnTy {\n+            let se_ty = ty::mk_bare_fn(tcx, Some(local_def(start_id)), tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n@@ -284,7 +284,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                     output: ty::FnConverging(ty::mk_int()),\n                     variadic: false\n                 }),\n-            });\n+            }));\n \n             require_same_types(tcx, None, false, start_span, start_t, se_ty,\n                 || {"}, {"sha": "a97dce88a57628d78c01bda81d2c23fc62625a34", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -106,7 +106,7 @@ impl RegionScope for SpecificRscope {\n /// A scope in which we generate anonymous, late-bound regions for\n /// omitted regions. This occurs in function signatures.\n pub struct BindingRscope {\n-    anon_bindings: Cell<uint>,\n+    anon_bindings: Cell<u32>,\n }\n \n impl BindingRscope {"}, {"sha": "bdd8c7c3da7c011b444af8df51793e4d6d46885d", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -732,7 +732,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::ty_rptr(region, ref mt) => {\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(region, contra);\n+                self.add_constraints_from_region(*region, contra);\n                 self.add_constraints_from_mt(mt, variance);\n             }\n \n@@ -750,8 +750,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::ty_enum(def_id, ref substs) |\n-            ty::ty_struct(def_id, ref substs) => {\n+            ty::ty_enum(def_id, substs) |\n+            ty::ty_struct(def_id, substs) => {\n                 let item_type = ty::lookup_item_type(self.tcx(), def_id);\n                 let generics = &item_type.generics;\n \n@@ -814,7 +814,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::ty_bare_fn(_, ty::BareFnTy { ref sig, .. }) |\n+            ty::ty_bare_fn(_, &ty::BareFnTy { ref sig, .. }) |\n             ty::ty_closure(box ty::ClosureTy {\n                     ref sig,\n                     store: ty::UniqTraitStore,\n@@ -854,18 +854,18 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         for p in type_param_defs.iter() {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id, TypeParam,\n-                                       p.space, p.index);\n+                                       p.space, p.index as uint);\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_ty = *substs.types.get(p.space, p.index);\n+            let substs_ty = *substs.types.get(p.space, p.index as uint);\n             self.add_constraints_from_ty(substs_ty, variance_i);\n         }\n \n         for p in region_param_defs.iter() {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id,\n-                                       RegionParam, p.space, p.index);\n+                                       RegionParam, p.space, p.index as uint);\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_r = *substs.regions().get(p.space, p.index);\n+            let substs_r = *substs.regions().get(p.space, p.index as uint);\n             self.add_constraints_from_region(substs_r, variance_i);\n         }\n     }"}, {"sha": "0308194527e9538a904986b188409160aebee3ad", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -620,7 +620,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n         let fqn = fqn.into_iter().map(|i| i.to_string())\n                      .collect::<Vec<String>>();\n         let path = external_path(cx, fqn.last().unwrap().as_slice(),\n-                                 Some(self.def_id), &self.substs);\n+                                 Some(self.def_id), self.substs);\n         cx.external_paths.borrow_mut().as_mut().unwrap().insert(self.def_id,\n                                                             (fqn, TypeTrait));\n \n@@ -634,7 +634,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n             if let sty::ty_tup(ref ts) = ty_s.sty {\n                 for &ty_s in ts.iter() {\n                     if let sty::ty_rptr(ref reg, _) = ty_s.sty {\n-                        if let &Region::ReLateBound(_, _) = reg {\n+                        if let &Region::ReLateBound(_, _) = *reg {\n                             debug!(\"  hit an ReLateBound {}\", reg);\n                             if let Some(lt) = reg.clean(cx) {\n                                 late_bounds.push(lt)\n@@ -1464,10 +1464,10 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     ty::RegionTraitStore(..) => Closure(decl),\n                 }\n             }\n-            ty::ty_struct(did, ref substs) |\n-            ty::ty_enum(did, ref substs) |\n+            ty::ty_struct(did, substs) |\n+            ty::ty_enum(did, substs) |\n             ty::ty_trait(box ty::TyTrait {\n-                principal: ty::Binder(ty::TraitRef { def_id: did, ref substs }),\n+                principal: ty::Binder(ty::TraitRef { def_id: did, substs }),\n                 .. }) =>\n             {\n                 let fqn = csearch::get_item_path(cx.tcx(), did);"}, {"sha": "59883f37737f0c1a866660b67490965bcc739903", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -19,7 +19,6 @@ use syntax::{ast, ast_map, codemap, diagnostic};\n \n use std::cell::RefCell;\n use std::collections::{HashMap, HashSet};\n-use arena::TypedArena;\n \n use visit_ast::RustdocVisitor;\n use clean;\n@@ -121,10 +120,10 @@ pub fn run_core(libs: Vec<Path>, cfgs: Vec<String>, externs: Externs,\n     let mut forest = ast_map::Forest::new(krate);\n     let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n \n-    let type_arena = TypedArena::new();\n+    let arenas = ty::CtxtArenas::new();\n     let ty::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n-    } = driver::phase_3_run_analysis_passes(sess, ast_map, &type_arena, name);\n+    } = driver::phase_3_run_analysis_passes(sess, ast_map, &arenas, name);\n \n     let ctxt = DocContext {\n         krate: ty_cx.map.krate(),"}, {"sha": "d4932fbb5f1c545f85b9e7becba26f2cd3fc0dd2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -607,7 +607,7 @@ pub enum Stmt_ {\n     /// Expr with trailing semi-colon (may have any type):\n     StmtSemi(P<Expr>, NodeId),\n \n-    StmtMac(Mac, MacStmtStyle),\n+    StmtMac(P<Mac>, MacStmtStyle),\n }\n \n #[deriving(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]"}, {"sha": "d2d624fa05e77be015f21786649b3295cda4def5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -672,7 +672,7 @@ fn expand_stmt(s: Stmt, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n         StmtMac(mac, style) => (mac, style),\n         _ => return expand_non_macro_stmt(s, fld)\n     };\n-    let expanded_stmt = match expand_mac_invoc(mac, s.span,\n+    let expanded_stmt = match expand_mac_invoc(mac.and_then(|m| m), s.span,\n                                                 |r| r.make_stmt(),\n                                                 mark_stmt, fld) {\n         Some(stmt) => stmt,"}, {"sha": "c58901701f530068df47429b8dabdf65baa0174f", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -1461,7 +1461,7 @@ pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n             }))\n         }\n         StmtMac(mac, semi) => SmallVector::one(P(Spanned {\n-            node: StmtMac(folder.fold_mac(mac), semi),\n+            node: StmtMac(mac.map(|m| folder.fold_mac(m)), semi),\n             span: span\n         }))\n     }"}, {"sha": "a2e2abab03e55fc933445d9973b56ddc1c064a03", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -3746,9 +3746,9 @@ impl<'a> Parser<'a> {\n             if id.name == token::special_idents::invalid.name {\n                 P(spanned(lo,\n                           hi,\n-                          StmtMac(spanned(lo,\n+                          StmtMac(P(spanned(lo,\n                                           hi,\n-                                          MacInvocTT(pth, tts, EMPTY_CTXT)),\n+                                          MacInvocTT(pth, tts, EMPTY_CTXT))),\n                                   style)))\n             } else {\n                 // if it has a special ident, it's definitely an item\n@@ -3911,7 +3911,7 @@ impl<'a> Parser<'a> {\n                                 _ => {\n                                     let e = self.mk_mac_expr(span.lo,\n                                                              span.hi,\n-                                                             macro.node);\n+                                                             macro.and_then(|m| m.node));\n                                     let e =\n                                         self.parse_dot_or_call_expr_with(e);\n                                     self.handle_expression_like_statement(\n@@ -3940,7 +3940,7 @@ impl<'a> Parser<'a> {\n                                     expr = Some(\n                                         self.mk_mac_expr(span.lo,\n                                                          span.hi,\n-                                                         m.node));\n+                                                         m.and_then(|x| x.node)));\n                                 }\n                                 _ => {\n                                     stmts.push(P(Spanned {"}, {"sha": "623f20bccd2ee36a100797e3b7bd19228c9f7479", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -1337,7 +1337,7 @@ impl<'a> State<'a> {\n                     ast::MacStmtWithBraces => token::Brace,\n                     _ => token::Paren\n                 };\n-                try!(self.print_mac(mac, delim));\n+                try!(self.print_mac(&**mac, delim));\n                 match style {\n                     ast::MacStmtWithBraces => {}\n                     _ => try!(word(&mut self.s, \";\")),"}, {"sha": "714339d0f0aaa84b8c33656b0a3176cc93a9ac54", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcc409fac18a258ba2a8af4345d9566ec8eebad/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3dcc409fac18a258ba2a8af4345d9566ec8eebad", "patch": "@@ -730,7 +730,7 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n         StmtExpr(ref expression, _) | StmtSemi(ref expression, _) => {\n             visitor.visit_expr(&**expression)\n         }\n-        StmtMac(ref macro, _) => visitor.visit_mac(macro),\n+        StmtMac(ref macro, _) => visitor.visit_mac(&**macro),\n     }\n }\n "}]}