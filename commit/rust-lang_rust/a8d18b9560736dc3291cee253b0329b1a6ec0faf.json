{"sha": "a8d18b9560736dc3291cee253b0329b1a6ec0faf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZDE4Yjk1NjA3MzZkYzMyOTFjZWUyNTNiMDMyOWIxYTZlYzBmYWY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-19T18:46:33Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-19T18:46:33Z"}, "message": "apply some of the feedback", "tree": {"sha": "dac72be88489974fd098d21a2f675a44123d87d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dac72be88489974fd098d21a2f675a44123d87d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8d18b9560736dc3291cee253b0329b1a6ec0faf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d18b9560736dc3291cee253b0329b1a6ec0faf", "html_url": "https://github.com/rust-lang/rust/commit/a8d18b9560736dc3291cee253b0329b1a6ec0faf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8d18b9560736dc3291cee253b0329b1a6ec0faf/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40598895394004a82bef1a7d9f99efdabd552d43", "url": "https://api.github.com/repos/rust-lang/rust/commits/40598895394004a82bef1a7d9f99efdabd552d43", "html_url": "https://github.com/rust-lang/rust/commit/40598895394004a82bef1a7d9f99efdabd552d43"}], "stats": {"total": 59, "additions": 34, "deletions": 25}, "files": [{"sha": "6def815e27dbc4567b31db2e37af14d80c2ac113", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8d18b9560736dc3291cee253b0329b1a6ec0faf/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d18b9560736dc3291cee253b0329b1a6ec0faf/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=a8d18b9560736dc3291cee253b0329b1a6ec0faf", "patch": "@@ -597,11 +597,11 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n \n /// Types which can be safely moved after being pinned.\n ///\n-/// Since Rust itself has no notion of immovable types, and will consider moves\n+/// Since Rust itself has no notion of immovable types, and considers moves\n /// (e.g. through assignment or [`mem::replace`]) to always be safe,\n /// this trait cannot prevent types from moving by itself.\n ///\n-/// Instead it can be used to prevent moves through the type system,\n+/// Instead it is used to prevent moves through the type system,\n /// by controlling the behavior of pointers wrapped in the [`Pin`] wrapper,\n /// which \"pin\" the type in place by not allowing it to be moved out of them.\n /// See the [`pin module`] documentation for more information on pinning.\n@@ -610,7 +610,7 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// which then allows it to move out with functions such as [`mem::replace`].\n ///\n /// `Unpin` has no consequence at all for non-pinned data. In particular,\n-/// [`mem::replace`] will happily move `!Unpin` data. However, you cannot use\n+/// [`mem::replace`] happily moves `!Unpin` data. However, you cannot use\n /// [`mem::replace`] on data wrapped inside a [`Pin`], and *that* is what makes\n /// this system work.\n ///"}, {"sha": "58d2636912dacc5d29f8ff29460f37f54c2b783c", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a8d18b9560736dc3291cee253b0329b1a6ec0faf/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d18b9560736dc3291cee253b0329b1a6ec0faf/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=a8d18b9560736dc3291cee253b0329b1a6ec0faf", "patch": "@@ -32,7 +32,8 @@\n //! # `Unpin`\n //!\n //! However, these restrictions are usually not necessary. Many types are always freely\n-//! movable, even when pinned. These types implement the [`Unpin`] auto-trait, which\n+//! movable, even when pinned, because they do not rely on having a stable address.\n+//! These types implement the [`Unpin`] auto-trait, which\n //! nullifies the effect of [`Pin`]. For `T: Unpin`, `Pin<Box<T>>` and `Box<T>` function\n //! identically, as do `Pin<&mut T>` and `&mut T`.\n //!\n@@ -99,20 +100,22 @@\n //! # `Drop` guarantee\n //!\n //! The purpose of pinning is to be able to rely on the placement of some data in memory.\n-//! To make this work, not just moving the data is restricted; deallocating or overwriting\n-//! it is restricted, too. Concretely, for pinned data you have to maintain the invariant\n-//! that *it will not get overwritten or deallocated until `drop` was called*.\n-//! (\"Overwriting\" here refers to other ways of invalidating storage, such as switching\n-//! from one enum variant to another.)\n+//! To make this work, not just moving the data is restricted; deallocating, repurposing or\n+//! otherwise invalidating the memory used to store the data is restricted, too.\n+//! Concretely, for pinned data you have to maintain the invariant\n+//! that *its memory will not get invalidated from the momentit gets pinned until\n+//! when `drop` is called*. Memory can be invalidated by deallocation, but also by\n+//! replacing a `Some(v)` by `None`, or calling `Vec::set_len` to \"kill\" some elements\n+//! off of a vector.\n //!\n //! The purpose of this guarantee is to allow data structures that store pointers\n //! to pinned data. For example, in an intrusive doubly-linked list, every element\n //! will have pointers to its predecessor and successor in the list. Every element\n //! will be pinned, because moving the elements around would invalidate the pointers.\n-//! Moreover, the `Drop` implemenetation of a linked list element will patch the pointers\n+//! Moreover, the `Drop` implementation of a linked list element will patch the pointers\n //! of its predecessor and successor to remove itself from the list. Clearly, if an element\n //! could be deallocated or overwritten without calling `drop`, the pointers into it\n-//! from its neighbouring elements would become invalid, breaking the data structure.\n+//! from its neighbouring elements would become invalid, which would break the data structure.\n //!\n //! Notice that this guarantee does *not* mean that memory does not leak! It is still\n //! completely okay not to ever call `drop` on a pinned element (e.g., you can still\n@@ -130,7 +133,9 @@\n //! a problem in safe code because implementing a type that relies on pinning\n //! requires unsafe code, but be aware that deciding to make use of pinning\n //! in your type (for example by implementing some operation on `Pin<&[mut] Self>`)\n-//! has consequences for your `Drop` implemenetation as well.\n+//! has consequences for your `Drop` implementation as well: if an element\n+//! of your type could have been pinned, you must treat Drop as implicitly taking\n+//! `Pin<&mut Self>`.\n //!\n //! # Projections and Structural Pinning\n //!\n@@ -151,12 +156,12 @@\n //! whether projections are provided. However, there are a couple requirements to be\n //! upheld when adding projection operations:\n //!\n-//! 1. The container must only be [`Unpin`] if all its fields are `Unpin`. This is the default,\n-//!    but `Unpin` is a safe trait, so as the author of the container it is your responsibility\n-//!    *not* to add something like `impl<T> Unpin for Container<T>`. (Notice that adding a\n-//!    projection operation requires unsafe code, so the fact that `Unpin` is a safe trait\n-//!    does not break the principle that you only have to worry about any of this if\n-//!    you use `unsafe`.)\n+//! 1. The container must only be [`Unpin`] if all the fields one can project to are\n+//!    `Unpin`. This is the default, but `Unpin` is a safe trait, so as the author of\n+//!    the container it is your responsibility *not* to add something like\n+//!    `impl<T> Unpin for Container<T>`. (Notice that adding a projection operation\n+//!    requires unsafe code, so the fact that `Unpin` is a safe trait  does not break\n+//!    the principle that you only have to worry about any of this if you use `unsafe`.)\n //! 2. The destructor of the container must not move out of its argument. This is the exact\n //!    point that was raised in the [previous section][drop-impl]: `drop` takes `&mut self`,\n //!    but the container (and hence its fields) might have been pinned before.\n@@ -293,9 +298,13 @@ impl<P: Deref> Pin<P> {\n     /// # Safety\n     ///\n     /// This constructor is unsafe because we cannot guarantee that the data\n-    /// pointed to by `pointer` is pinned. If the constructed `Pin<P>` does\n+    /// pointed to by `pointer` is pinned forever. If the constructed `Pin<P>` does\n     /// not guarantee that the data `P` points to is pinned, constructing a\n-    /// `Pin<P>` is undefined behavior.\n+    /// `Pin<P>` is unsafe. In particular, calling `Pin::new_unchecked`\n+    /// on an `&'a mut T` is unsafe because while you are able to pin it for the given\n+    /// lifetime `'a`, you have no control over whether it is kept pinned once `'a`\n+    /// ends. A value, once pinned, must remain pinned forever\n+    /// (unless its type implements `Unpin`).\n     ///\n     /// By using this method, you are making a promise about the `P::Deref` and\n     /// `P::DerefMut` implementations, if they exist. Most importantly, they\n@@ -305,25 +314,25 @@ impl<P: Deref> Pin<P> {\n     /// Moreover, by calling this method you promise that the reference `P`\n     /// dereferences to will not be moved out of again; in particular, it\n     /// must not be possible to obtain a `&mut P::Target` and then\n-    /// move out of that reference (using, for example [`replace`]).\n+    /// move out of that reference (using, for example [`mem::swap`]).\n     ///\n     /// For example, the following is a *violation* of `Pin`'s safety:\n     /// ```\n     /// use std::mem;\n     /// use std::pin::Pin;\n     ///\n-    /// fn foo<T>(mut a: T, b: T) {\n+    /// fn foo<T>(mut a: T, mut b: T) {\n     ///     unsafe { let p = Pin::new_unchecked(&mut a); } // should mean `a` can never move again\n-    ///     let a2 = mem::replace(&mut a, b);\n-    ///     // the address of `a` changed to `a2`'s stack slot, so `a` got moved even\n+    ///     mem::swap(&mut a, &mut b);\n+    ///     // the address of `a` changed to `b`'s stack slot, so `a` got moved even\n     ///     // though we have previously pinned it!\n     /// }\n     /// ```\n     ///\n     /// If `pointer` dereferences to an `Unpin` type, `Pin::new` should be used\n     /// instead.\n     ///\n-    /// [`replace`]: ../../std/mem/fn.replace.html\n+    /// [`mem::swap`]: ../../std/mem/fn.swap.html\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub unsafe fn new_unchecked(pointer: P) -> Pin<P> {"}]}