{"sha": "7c3d55150dc09494fda56814ff1bd529d72b6afb", "node_id": "C_kwDOAAsO6NoAKDdjM2Q1NTE1MGRjMDk0OTRmZGE1NjgxNGZmMWJkNTI5ZDcyYjZhZmI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-22T13:06:28Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-05-09T17:27:58Z"}, "message": "Create tracked places breadth first.", "tree": {"sha": "8f599e9f70d0c252bae4f367fc2a5d5d1bae65a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f599e9f70d0c252bae4f367fc2a5d5d1bae65a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c3d55150dc09494fda56814ff1bd529d72b6afb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c3d55150dc09494fda56814ff1bd529d72b6afb", "html_url": "https://github.com/rust-lang/rust/commit/7c3d55150dc09494fda56814ff1bd529d72b6afb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c3d55150dc09494fda56814ff1bd529d72b6afb/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71138e99337e791eb73d73d8a2cf8aaef29960b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/71138e99337e791eb73d73d8a2cf8aaef29960b1", "html_url": "https://github.com/rust-lang/rust/commit/71138e99337e791eb73d73d8a2cf8aaef29960b1"}], "stats": {"total": 114, "additions": 49, "deletions": 65}, "files": [{"sha": "7d8fc5ffeec850ac27cb97b52183957b42cceb64", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 49, "deletions": 65, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/7c3d55150dc09494fda56814ff1bd529d72b6afb/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3d55150dc09494fda56814ff1bd529d72b6afb/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=7c3d55150dc09494fda56814ff1bd529d72b6afb", "patch": "@@ -32,6 +32,7 @@\n //! Because of that, we can assume that the only way to change the value behind a tracked place is\n //! by direct assignment.\n \n+use std::collections::VecDeque;\n use std::fmt::{Debug, Formatter};\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -608,7 +609,7 @@ impl Map {\n     pub fn from_filter<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n-        filter: impl FnMut(Ty<'tcx>) -> bool,\n+        filter: impl Fn(Ty<'tcx>) -> bool,\n         place_limit: Option<usize>,\n     ) -> Self {\n         let mut map = Self::new();\n@@ -623,51 +624,67 @@ impl Map {\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n-        mut filter: impl FnMut(Ty<'tcx>) -> bool,\n+        filter: impl Fn(Ty<'tcx>) -> bool,\n         exclude: BitSet<Local>,\n         place_limit: Option<usize>,\n     ) {\n         // We use this vector as stack, pushing and popping projections.\n-        let mut projection = Vec::new();\n+        let mut worklist = VecDeque::with_capacity(place_limit.unwrap_or(body.local_decls.len()));\n+        self.locals = IndexVec::from_elem(None, &body.local_decls);\n         for (local, decl) in body.local_decls.iter_enumerated() {\n-            if !exclude.contains(local) {\n-                self.register_with_filter_rec(\n-                    tcx,\n-                    local,\n-                    &mut projection,\n-                    decl.ty,\n-                    &mut filter,\n-                    place_limit,\n-                );\n+            if exclude.contains(local) {\n+                continue;\n             }\n+\n+            // Create a place for the local.\n+            debug_assert!(self.locals[local].is_none());\n+            let place = self.places.push(PlaceInfo::new(None));\n+            self.locals[local] = Some(place);\n+\n+            // And push the eventual children places to the worklist.\n+            self.register_children(tcx, place, decl.ty, &filter, &mut worklist);\n+        }\n+\n+        // `place.elem1.elem2` with type `ty`.\n+        while let Some((mut place, elem1, elem2, ty)) = worklist.pop_front() {\n+            if let Some(place_limit) = place_limit && self.value_count >= place_limit {\n+                break\n+            }\n+\n+            // Create a place for this projection.\n+            for elem in [elem1, Some(elem2)].into_iter().flatten() {\n+                place = *self.projections.entry((place, elem)).or_insert_with(|| {\n+                    // Prepend new child to the linked list.\n+                    let next = self.places.push(PlaceInfo::new(Some(elem)));\n+                    self.places[next].next_sibling = self.places[place].first_child;\n+                    self.places[place].first_child = Some(next);\n+                    next\n+                });\n+            }\n+\n+            // And push the eventual children places to the worklist.\n+            self.register_children(tcx, place, ty, &filter, &mut worklist);\n         }\n     }\n \n     /// Potentially register the (local, projection) place and its fields, recursively.\n     ///\n     /// Invariant: The projection must only contain trackable elements.\n-    fn register_with_filter_rec<'tcx>(\n+    fn register_children<'tcx>(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        local: Local,\n-        projection: &mut Vec<PlaceElem<'tcx>>,\n+        place: PlaceIndex,\n         ty: Ty<'tcx>,\n-        filter: &mut impl FnMut(Ty<'tcx>) -> bool,\n-        place_limit: Option<usize>,\n+        filter: &impl Fn(Ty<'tcx>) -> bool,\n+        worklist: &mut VecDeque<(PlaceIndex, Option<TrackElem>, TrackElem, Ty<'tcx>)>,\n     ) {\n-        if let Some(place_limit) = place_limit && self.value_count >= place_limit {\n-            return\n-        }\n-\n-        // We know that the projection only contains trackable elements.\n-        let place = self.make_place(local, projection).unwrap();\n-\n         // Allocate a value slot if it doesn't have one, and the user requested one.\n         if self.places[place].value_index.is_none() && filter(ty) {\n             self.places[place].value_index = Some(self.value_count.into());\n             self.value_count += 1;\n         }\n \n+        // For enums, directly create the `Discriminant`, as that's their main use.\n         if ty.is_enum() {\n             let discr_ty = ty.discriminant_ty(tcx);\n             if filter(discr_ty) {\n@@ -692,48 +709,15 @@ impl Map {\n \n         // Recurse with all fields of this place.\n         iter_fields(ty, tcx, ty::ParamEnv::reveal_all(), |variant, field, ty| {\n-            if let Some(variant) = variant {\n-                projection.push(PlaceElem::Downcast(None, variant));\n-                let _ = self.make_place(local, projection);\n-                projection.push(PlaceElem::Field(field, ty));\n-                self.register_with_filter_rec(tcx, local, projection, ty, filter, place_limit);\n-                projection.pop();\n-                projection.pop();\n-                return;\n-            }\n-            projection.push(PlaceElem::Field(field, ty));\n-            self.register_with_filter_rec(tcx, local, projection, ty, filter, place_limit);\n-            projection.pop();\n+            worklist.push_back((\n+                place,\n+                variant.map(TrackElem::Variant),\n+                TrackElem::Field(field),\n+                ty,\n+            ))\n         });\n     }\n \n-    /// Tries to add the place to the map, without allocating a value slot.\n-    ///\n-    /// Can fail if the projection contains non-trackable elements.\n-    fn make_place<'tcx>(\n-        &mut self,\n-        local: Local,\n-        projection: &[PlaceElem<'tcx>],\n-    ) -> Result<PlaceIndex, ()> {\n-        // Get the base index of the local.\n-        let mut index =\n-            *self.locals.get_or_insert_with(local, || self.places.push(PlaceInfo::new(None)));\n-\n-        // Apply the projection.\n-        for &elem in projection {\n-            let elem = elem.try_into()?;\n-            index = *self.projections.entry((index, elem)).or_insert_with(|| {\n-                // Prepend new child to the linked list.\n-                let next = self.places.push(PlaceInfo::new(Some(elem)));\n-                self.places[next].next_sibling = self.places[index].first_child;\n-                self.places[index].first_child = Some(next);\n-                next\n-            });\n-        }\n-\n-        Ok(index)\n-    }\n-\n     /// Returns the number of tracked places, i.e., those for which a value can be stored.\n     pub fn tracked_places(&self) -> usize {\n         self.value_count\n@@ -750,7 +734,7 @@ impl Map {\n         place: PlaceRef<'_>,\n         extra: impl IntoIterator<Item = TrackElem>,\n     ) -> Option<PlaceIndex> {\n-        let mut index = *self.locals.get(place.local)?.as_ref()?;\n+        let mut index = *self.locals[place.local].as_ref()?;\n \n         for &elem in place.projection {\n             index = self.apply(index, elem.try_into().ok()?)?;\n@@ -794,7 +778,7 @@ impl Map {\n             // We do not track indirect places.\n             return;\n         }\n-        let Some(&Some(mut index)) = self.locals.get(place.local) else {\n+        let Some(mut index) = self.locals[place.local] else {\n             // The local is not tracked at all, so it does not alias anything.\n             return;\n         };"}]}