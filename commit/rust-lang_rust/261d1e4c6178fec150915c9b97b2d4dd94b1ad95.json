{"sha": "261d1e4c6178fec150915c9b97b2d4dd94b1ad95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MWQxZTRjNjE3OGZlYzE1MDkxNWM5Yjk3YjJkNGRkOTRiMWFkOTU=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-03-17T01:49:15Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-22T15:04:38Z"}, "message": "Add codegen for ports and chans", "tree": {"sha": "a9e3ddf2fc0d3131d1b6317222dd6fa406945af6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9e3ddf2fc0d3131d1b6317222dd6fa406945af6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/261d1e4c6178fec150915c9b97b2d4dd94b1ad95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/261d1e4c6178fec150915c9b97b2d4dd94b1ad95", "html_url": "https://github.com/rust-lang/rust/commit/261d1e4c6178fec150915c9b97b2d4dd94b1ad95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/261d1e4c6178fec150915c9b97b2d4dd94b1ad95/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ac885ee8cb18fc2cb974cff06190532680cf29b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ac885ee8cb18fc2cb974cff06190532680cf29b", "html_url": "https://github.com/rust-lang/rust/commit/7ac885ee8cb18fc2cb974cff06190532680cf29b"}], "stats": {"total": 120, "additions": 120, "deletions": 0}, "files": [{"sha": "d4b4923e363c6b5e90dbbd8fe3dde5f4e43a43f1", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/261d1e4c6178fec150915c9b97b2d4dd94b1ad95/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/261d1e4c6178fec150915c9b97b2d4dd94b1ad95/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=261d1e4c6178fec150915c9b97b2d4dd94b1ad95", "patch": "@@ -339,6 +339,14 @@ fn T_box(TypeRef t) -> TypeRef {\n     ret T_struct(vec(T_int(), t));\n }\n \n+fn T_port(TypeRef t) -> TypeRef {\n+    ret T_struct(vec(T_int())); // Refcount\n+}\n+\n+fn T_chan(TypeRef t) -> TypeRef {\n+    ret T_struct(vec(T_int())); // Refcount\n+}\n+\n fn T_crate(type_names tn) -> TypeRef {\n     auto s = \"crate\";\n     if (tn.name_has_type(s)) {\n@@ -623,6 +631,12 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t, bool boxed) -> TypeRef {\n         case (ty.ty_vec(?mt)) {\n             llty = T_ptr(T_vec(type_of_inner(cx, mt.ty, true)));\n         }\n+        case (ty.ty_port(?t)) {\n+            llty = T_ptr(T_port(type_of_inner(cx, t, true)));\n+        }\n+        case (ty.ty_chan(?t)) {\n+            llty = T_ptr(T_chan(type_of_inner(cx, t, true)));\n+        }\n         case (ty.ty_tup(?elts)) {\n             let vec[TypeRef] tys = vec();\n             for (ty.mt elt in elts) {\n@@ -1609,6 +1623,28 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                                         T_int(), C_int(0));\n         }\n \n+        case (ty.ty_port(_)) {\n+            fn hit_zero(@block_ctxt cx, ValueRef v) -> result {\n+                ret trans_upcall(cx, \"upcall_del_port\",\n+                                 vec(vp2i(cx, v)));\n+            }\n+            ret decr_refcnt_and_if_zero(cx, v,\n+                                        bind hit_zero(_, v),\n+                                        \"free port\",\n+                                        T_int(), C_int(0));\n+        }\n+\n+        case (ty.ty_chan(_)) {\n+            fn hit_zero(@block_ctxt cx, ValueRef v) -> result {\n+                ret trans_upcall(cx, \"upcall_del_chan\",\n+                                 vec(vp2i(cx, v)));\n+            }\n+            ret decr_refcnt_and_if_zero(cx, v,\n+                                        bind hit_zero(_, v),\n+                                        \"free chan\",\n+                                        T_int(), C_int(0));\n+        }\n+\n         case (ty.ty_obj(_)) {\n             fn hit_zero(@block_ctxt cx, ValueRef v) -> result {\n \n@@ -4496,6 +4532,22 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             ret trans_be(cx, e);\n         }\n \n+        case (ast.expr_port(?ann)) {\n+            ret trans_port(cx, ann);\n+        }\n+\n+        case (ast.expr_chan(?e, ?ann)) {\n+            ret trans_chan(cx, e, ann);\n+        }\n+\n+        case (ast.expr_send(?lhs, ?rhs, ?ann)) {\n+            ret trans_send(cx, lhs, rhs, ann);\n+        }\n+\n+        case (ast.expr_recv(?lhs, ?rhs, ?ann)) {\n+            ret trans_recv(cx, lhs, rhs, ann);\n+        }\n+\n         // lval cases fall through to trans_lval and then\n         // possibly load the result (if it's non-structural).\n \n@@ -4667,6 +4719,68 @@ fn trans_be(@block_ctxt cx, @ast.expr e) -> result {\n     ret trans_ret(cx, some(e));\n }\n \n+fn trans_port(@block_ctxt cx, ast.ann ann) -> result {\n+\n+    auto t = node_ann_type(cx.fcx.ccx, ann);\n+    auto unit_ty;\n+    alt (t.struct) {\n+        case (ty.ty_port(?t)) {\n+            unit_ty = t;\n+        }\n+        case (_) {\n+            cx.fcx.ccx.sess.bug(\"non-port type in trans_port\");\n+            fail;\n+        }\n+    }\n+\n+    auto llunit_ty = type_of(cx.fcx.ccx, unit_ty);\n+\n+    auto bcx = cx;\n+    auto unit_sz = size_of(bcx, unit_ty);\n+    bcx = unit_sz.bcx;\n+    auto sub = trans_upcall(bcx, \"upcall_new_port\", vec(unit_sz.val));\n+    bcx = sub.bcx;\n+    auto llty = type_of(cx.fcx.ccx, t);\n+    auto port_val = vi2p(bcx, sub.val, llty);\n+    auto dropref = clean(bind drop_ty(_, port_val, t));\n+    find_scope_cx(bcx).cleanups += vec(dropref);\n+\n+    ret res(bcx, port_val);\n+}\n+\n+fn trans_chan(@block_ctxt cx, @ast.expr e, ast.ann ann) -> result {\n+\n+    auto bcx = cx;\n+    auto prt = trans_expr(bcx, e);\n+    bcx = prt.bcx;\n+\n+    auto prt_ty = ty.expr_ty(e);\n+    auto prt_llty = type_of(bcx.fcx.ccx, prt_ty);\n+    auto prt_val = vp2i(bcx, prt.val);\n+    auto sub = trans_upcall(bcx, \"upcall_new_chan\", vec(prt_val));\n+    bcx = sub.bcx;\n+\n+    auto chan_ty = node_ann_type(bcx.fcx.ccx, ann);\n+    auto chan_llty = type_of(bcx.fcx.ccx, chan_ty);\n+    auto chan_val = vi2p(bcx, sub.val, chan_llty);\n+    auto dropref = clean(bind drop_ty(_, chan_val, chan_ty));\n+    find_scope_cx(bcx).cleanups += vec(dropref);\n+\n+    // TODO: Do I need to do anything with the port's refcount?\n+\n+    ret res(bcx, chan_val);\n+}\n+\n+fn trans_send(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n+              ast.ann ann) -> result {\n+    fail;\n+}\n+\n+fn trans_recv(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n+              ast.ann ann) -> result {\n+    fail;\n+}\n+\n fn init_local(@block_ctxt cx, @ast.local local) -> result {\n \n     // Make a note to drop this slot on the way out."}, {"sha": "72564078e4d6bb313bd113996f73aa2a13b69038", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/261d1e4c6178fec150915c9b97b2d4dd94b1ad95/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/261d1e4c6178fec150915c9b97b2d4dd94b1ad95/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=261d1e4c6178fec150915c9b97b2d4dd94b1ad95", "patch": "@@ -411,6 +411,8 @@ fn type_is_boxed(@t ty) -> bool {\n         case (ty_str) { ret true; }\n         case (ty_vec(_)) { ret true; }\n         case (ty_box(_)) { ret true; }\n+        case (ty_port(_)) { ret true; }\n+        case (ty_chan(_)) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n@@ -759,6 +761,10 @@ fn expr_ty(@ast.expr expr) -> @t {\n         case (ast.expr_index(_, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_path(_, _, ?ann))      { ret ann_to_type(ann); }\n         case (ast.expr_ext(_, _, _, _, ?ann)) { ret ann_to_type(ann); }\n+        case (ast.expr_port(?ann))            { ret ann_to_type(ann); }\n+        case (ast.expr_chan(_, ?ann))         { ret ann_to_type(ann); }\n+        case (ast.expr_send(_, _, ?ann))      { ret ann_to_type(ann); }\n+        case (ast.expr_recv(_, _, ?ann))      { ret ann_to_type(ann); }\n \n         case (ast.expr_fail)                  { ret plain_ty(ty_nil); }\n         case (ast.expr_log(_))                { ret plain_ty(ty_nil); }"}]}