{"sha": "47d4089e100f6a1e19e8687158cc1e0c71ac2ae3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZDQwODllMTAwZjZhMWUxOWU4Njg3MTU4Y2MxZTBjNzFhYzJhZTM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-05T18:09:41Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-15T20:24:16Z"}, "message": "TokenTree: Op -> Punct, Term -> Ident", "tree": {"sha": "d77a4fe36c4623d5478833b3fba649f49eb976f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d77a4fe36c4623d5478833b3fba649f49eb976f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3", "html_url": "https://github.com/rust-lang/rust/commit/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "decc619a1f0b84e0c3ab44d72621120886e71271", "url": "https://api.github.com/repos/rust-lang/rust/commits/decc619a1f0b84e0c3ab44d72621120886e71271", "html_url": "https://github.com/rust-lang/rust/commit/decc619a1f0b84e0c3ab44d72621120886e71271"}], "stats": {"total": 246, "additions": 115, "deletions": 131}, "files": [{"sha": "6512145141e411f5782462c569c37868198788b2", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 70, "deletions": 86, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=47d4089e100f6a1e19e8687158cc1e0c71ac2ae3", "patch": "@@ -246,7 +246,7 @@ pub mod token_stream {\n \n /// `quote!(..)` accepts arbitrary tokens and expands into a `TokenStream` describing the input.\n /// For example, `quote!(a + b)` will produce a expression, that, when evaluated, constructs\n-/// the `TokenStream` `[Word(\"a\"), Op('+', Alone), Word(\"b\")]`.\n+/// the `TokenStream` `[Word(\"a\"), Punct('+', Alone), Word(\"b\")]`.\n ///\n /// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n /// To quote `$` itself, use `$$`.\n@@ -499,17 +499,9 @@ pub enum TokenTree {\n     /// A token stream surrounded by bracket delimiters.\n     Group(Group),\n     /// An identifier or lifetime identifier.\n-    ///\n-    /// REVIEW Maybe let's name it `Ident` instead of inventing a new term, it's named \"identifier\"\n-    /// REVIEW everywhere in the compiler, including `ident` in `macro`/`macro_rules!` DSL.\n-    Term(Term),\n+    Ident(Ident),\n     /// A single punctuation character (`+`, `,`, `$`, etc.).\n-    ///\n-    /// REVIEW This is not an operator, operators are more narrow set, they also can be\n-    /// REVIEW multicharacter, this is punctuation, even the comment says so!\n-    /// REVIEW @dtolnay suggested `Punct` in the original implementation PR too, and it was\n-    /// REVIEW received positively, but the renaming never actually happened.\n-    Op(Op),\n+    Punct(Punct),\n     /// A literal character (`'a'`), string (`\"hello\"`), number (`2.3`), etc.\n     Literal(Literal),\n }\n@@ -526,8 +518,8 @@ impl TokenTree {\n     pub fn span(&self) -> Span {\n         match *self {\n             TokenTree::Group(ref t) => t.span(),\n-            TokenTree::Term(ref t) => t.span(),\n-            TokenTree::Op(ref t) => t.span(),\n+            TokenTree::Ident(ref t) => t.span(),\n+            TokenTree::Punct(ref t) => t.span(),\n             TokenTree::Literal(ref t) => t.span(),\n         }\n     }\n@@ -541,8 +533,8 @@ impl TokenTree {\n     pub fn set_span(&mut self, span: Span) {\n         match *self {\n             TokenTree::Group(ref mut t) => t.set_span(span),\n-            TokenTree::Term(ref mut t) => t.set_span(span),\n-            TokenTree::Op(ref mut t) => t.set_span(span),\n+            TokenTree::Ident(ref mut t) => t.set_span(span),\n+            TokenTree::Punct(ref mut t) => t.set_span(span),\n             TokenTree::Literal(ref mut t) => t.set_span(span),\n         }\n     }\n@@ -556,16 +548,16 @@ impl fmt::Debug for TokenTree {\n         // so don't bother with an extra layer of indirection\n         match *self {\n             TokenTree::Group(ref tt) => tt.fmt(f),\n-            TokenTree::Term(ref tt) => tt.fmt(f),\n-            TokenTree::Op(ref tt) => tt.fmt(f),\n+            TokenTree::Ident(ref tt) => tt.fmt(f),\n+            TokenTree::Punct(ref tt) => tt.fmt(f),\n             TokenTree::Literal(ref tt) => tt.fmt(f),\n         }\n     }\n }\n \n /// REVIEW the impls below are kind of `From<T> for Option<T>`, not strictly necessary,\n /// REVIEW but convenient. No harm, I guess. I'd actually like to see impls\n-/// REVIEW `From<Group/Term/Op/Literal> for TokenStream` to avoid stuttering like\n+/// REVIEW `From<Group/Ident/Punct/Literal> for TokenStream` to avoid stuttering like\n /// REVIEW `TokenTree::Literal(Literal::string(\"lalala\")).into()`.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl From<Group> for TokenTree {\n@@ -575,16 +567,16 @@ impl From<Group> for TokenTree {\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl From<Term> for TokenTree {\n-    fn from(g: Term) -> TokenTree {\n-        TokenTree::Term(g)\n+impl From<Ident> for TokenTree {\n+    fn from(g: Ident) -> TokenTree {\n+        TokenTree::Ident(g)\n     }\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl From<Op> for TokenTree {\n-    fn from(g: Op) -> TokenTree {\n-        TokenTree::Op(g)\n+impl From<Punct> for TokenTree {\n+    fn from(g: Punct) -> TokenTree {\n+        TokenTree::Punct(g)\n     }\n }\n \n@@ -603,8 +595,8 @@ impl fmt::Display for TokenTree {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             TokenTree::Group(ref t) => t.fmt(f),\n-            TokenTree::Term(ref t) => t.fmt(f),\n-            TokenTree::Op(ref t) => t.fmt(f),\n+            TokenTree::Ident(ref t) => t.fmt(f),\n+            TokenTree::Punct(ref t) => t.fmt(f),\n             TokenTree::Literal(ref t) => t.fmt(f),\n         }\n     }\n@@ -703,37 +695,32 @@ impl fmt::Display for Group {\n     }\n }\n \n-/// An `Op` is an single punctuation character like `+`, `-` or `#`.\n+/// An `Punct` is an single punctuation character like `+`, `-` or `#`.\n ///\n-/// Multicharacter operators like `+=` are represented as two instances of `Op` with different\n+/// Multicharacter operators like `+=` are represented as two instances of `Punct` with different\n /// forms of `Spacing` returned.\n ///\n-/// REVIEW This is not an operator, operators are more narrow set, they also can be\n-/// REVIEW multicharacter, this is punctuation, even the comment says so!\n-/// REVIEW @dtolnay suggested `Punct` in the original implementation PR too, and it was\n-/// REVIEW received positively, but the renaming never actually happened.\n-///\n-/// REVIEW We should guarantee that `Op` contains a valid punctuation character permitted by\n+/// REVIEW We should guarantee that `Punct` contains a valid punctuation character permitted by\n /// REVIEW the language and not a random unicode code point. The check is already performed in\n /// REVIEW `TokenTree::to_internal`, but we should do it on construction.\n-/// REVIEW `Op` can also avoid using `char` internally and keep an u8-like enum.\n+/// REVIEW `Punct` can also avoid using `char` internally and keep an u8-like enum.\n ///\n /// REVIEW ATTENTION: `Copy` impl on a struct with private fields.\n-/// REVIEW Do we want to guarantee `Op` to be `Copy`?\n+/// REVIEW Do we want to guarantee `Punct` to be `Copy`?\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n #[derive(Copy, Clone, Debug)]\n-pub struct Op {\n-    op: char,\n+pub struct Punct {\n+    ch: char,\n     spacing: Spacing,\n     span: Span,\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl !Send for Op {}\n+impl !Send for Punct {}\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl !Sync for Op {}\n+impl !Sync for Punct {}\n \n-/// Whether an `Op` is followed immediately by another `Op` or\n+/// Whether an `Punct` is followed immediately by another `Punct` or\n /// followed by another token or whitespace.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n@@ -744,10 +731,10 @@ pub enum Spacing {\n     Joint,\n }\n \n-impl Op {\n-    /// Creates a new `Op` from the given character and spacing.\n+impl Punct {\n+    /// Creates a new `Punct` from the given character and spacing.\n     ///\n-    /// The returned `Op` will have the default span of `Span::call_site()`\n+    /// The returned `Punct` will have the default span of `Span::call_site()`\n     /// which can be further configured with the `set_span` method below.\n     ///\n     /// REVIEW Why we even use `char` here? There's no reason to use unicode here.\n@@ -756,9 +743,9 @@ impl Op {\n     /// REVIEW TO_DO Do input validation on construction, the argument should be a valid punctuation\n     /// REVIEW character permitted by the language.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn new(op: char, spacing: Spacing) -> Op {\n-        Op {\n-            op: op,\n+    pub fn new(ch: char, spacing: Spacing) -> Punct {\n+        Punct {\n+            ch: ch,\n             spacing: spacing,\n             span: Span::call_site(),\n         }\n@@ -770,12 +757,12 @@ impl Op {\n     /// REVIEW except for maybe future compatibility in case Rust turns into APL,\n     /// REVIEW but if it's more convenient to use `char` then that's okay.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn op(&self) -> char {\n-        self.op\n+    pub fn as_char(&self) -> char {\n+        self.ch\n     }\n \n     /// Returns the spacing of this punctuation character, indicating whether it's immediately\n-    /// followed by another `Op` in the token stream, so they can potentially be combined into\n+    /// followed by another `Punct` in the token stream, so they can potentially be combined into\n     /// a multicharacter operator (`Joint`), or it's followed by some other token or whitespace\n     /// (`Alone`) so the operator has certainly ended.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n@@ -799,43 +786,40 @@ impl Op {\n /// Prints the punctuation character as a string that should be losslessly convertible\n /// back into the same character.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl fmt::Display for Op {\n+impl fmt::Display for Punct {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n     }\n }\n \n /// An identifier (`ident`) or lifetime identifier (`'ident`).\n ///\n-/// REVIEW We should guarantee that `Term` contains a valid identifier permitted by\n+/// REVIEW We should guarantee that `Ident` contains a valid identifier permitted by\n /// REVIEW the language and not a random unicode string, at least for a start.\n ///\n-/// REVIEW Maybe let's name it `Ident` instead of inventing a new term, it's named \"identifier\"\n-/// REVIEW everywhere in the compiler, including `ident` in `macro`/`macro_rules!` DSL.\n-///\n /// REVIEW We need to support raw identifiers here (`r#ident`) or at least be future compatible\n /// REVIEW with them. Currently they are supported using \"string typing\" - if string \"r#ident\" is\n-/// REVIEW passed to `Term::new` it will be interpreted as a raw identifier later on, we should add\n-/// REVIEW a field `is_raw` and a separate constructor for it (`Term::new_raw` or something) and\n+/// REVIEW passed to `Ident::new` it will be interpreted as a raw identifier later on, we should add\n+/// REVIEW a field `is_raw` and a separate constructor for it (`Ident::new_raw` or something) and\n /// REVIEW keep it unstable until raw identifiers are stabilized.\n ///\n /// REVIEW ATTENTION: `Copy` impl on a struct with private fields.\n-/// REVIEW Do we want to guarantee `Term` to be `Copy`?\n+/// REVIEW Do we want to guarantee `Ident` to be `Copy`?\n #[derive(Copy, Clone, Debug)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-pub struct Term {\n+pub struct Ident {\n     // REVIEW(INTERNAL) Symbol + Span is actually `ast::Ident`! We can use it here.\n     sym: Symbol,\n     span: Span,\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl !Send for Term {}\n+impl !Send for Ident {}\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl !Sync for Term {}\n+impl !Sync for Ident {}\n \n-impl Term {\n-    /// Creates a new `Term` with the given `string` as well as the specified\n+impl Ident {\n+    /// Creates a new `Ident` with the given `string` as well as the specified\n     /// `span`.\n     ///\n     /// Note that `span`, currently in rustc, configures the hygiene information\n@@ -856,8 +840,8 @@ impl Term {\n     /// REVIEW TO_DO Do input validation, the argument should be a valid identifier or\n     /// REVIEW lifetime identifier.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn new(string: &str, span: Span) -> Term {\n-        Term {\n+    pub fn new(string: &str, span: Span) -> Ident {\n+        Ident {\n             sym: Symbol::intern(string),\n             span,\n         }\n@@ -870,14 +854,14 @@ impl Term {\n         unsafe { &*(&*self.sym.as_str() as *const str) }\n     }\n \n-    /// Returns the span of this `Term`, encompassing the entire string returned\n+    /// Returns the span of this `Ident`, encompassing the entire string returned\n     /// by `as_str`.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn span(&self) -> Span {\n         self.span\n     }\n \n-    /// Configures the span of this `Term`, possibly changing its hygiene context.\n+    /// Configures the span of this `Ident`, possibly changing its hygiene context.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn set_span(&mut self, span: Span) {\n         self.span = span;\n@@ -887,7 +871,7 @@ impl Term {\n /// Prints the identifier as a string that should be losslessly convertible\n /// back into the same identifier.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl fmt::Display for Term {\n+impl fmt::Display for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.sym.as_str().fmt(f)\n     }\n@@ -896,7 +880,7 @@ impl fmt::Display for Term {\n /// A literal string (`\"hello\"`), byte string (`b\"hello\"`),\n /// character (`'a'`), byte character (`b'a'`), an integer or floating point number\n /// with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`).\n-/// Boolean literals like `true` and `false` do not belong here, they are `Term`s.\n+/// Boolean literals like `true` and `false` do not belong here, they are `Ident`s.\n #[derive(Clone, Debug)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub struct Literal {\n@@ -1182,15 +1166,15 @@ impl TokenTree {\n             })\n         }\n         macro_rules! op {\n-            ($a:expr) => (tt!(Op::new($a, op_kind)));\n+            ($a:expr) => (tt!(Punct::new($a, op_kind)));\n             ($a:expr, $b:expr) => ({\n-                stack.push(tt!(Op::new($b, op_kind)));\n-                tt!(Op::new($a, Spacing::Joint))\n+                stack.push(tt!(Punct::new($b, op_kind)));\n+                tt!(Punct::new($a, Spacing::Joint))\n             });\n             ($a:expr, $b:expr, $c:expr) => ({\n-                stack.push(tt!(Op::new($c, op_kind)));\n-                stack.push(tt!(Op::new($b, Spacing::Joint)));\n-                tt!(Op::new($a, Spacing::Joint))\n+                stack.push(tt!(Punct::new($c, op_kind)));\n+                stack.push(tt!(Punct::new($b, Spacing::Joint)));\n+                tt!(Punct::new($a, Spacing::Joint))\n             })\n         }\n \n@@ -1243,25 +1227,25 @@ impl TokenTree {\n             Question => op!('?'),\n \n             Ident(ident, false) | Lifetime(ident) => {\n-                tt!(Term::new(&ident.name.as_str(), Span(span)))\n+                tt!(self::Ident::new(&ident.name.as_str(), Span(span)))\n             }\n             Ident(ident, true) => {\n-                tt!(Term::new(&format!(\"r#{}\", ident), Span(span)))\n+                tt!(self::Ident::new(&format!(\"r#{}\", ident), Span(span)))\n             }\n             Literal(lit, suffix) => tt!(self::Literal { lit, suffix, span: Span(span) }),\n             DocComment(c) => {\n                 let style = comments::doc_comment_style(&c.as_str());\n                 let stripped = comments::strip_doc_comment_decoration(&c.as_str());\n                 let stream = vec![\n-                    tt!(Term::new(\"doc\", Span(span))),\n-                    tt!(Op::new('=', Spacing::Alone)),\n+                    tt!(self::Ident::new(\"doc\", Span(span))),\n+                    tt!(Punct::new('=', Spacing::Alone)),\n                     tt!(self::Literal::string(&stripped)),\n                 ].into_iter().collect();\n                 stack.push(tt!(Group::new(Delimiter::Bracket, stream)));\n                 if style == ast::AttrStyle::Inner {\n-                    stack.push(tt!(Op::new('!', Spacing::Alone)));\n+                    stack.push(tt!(Punct::new('!', Spacing::Alone)));\n                 }\n-                tt!(Op::new('#', Spacing::Alone))\n+                tt!(Punct::new('#', Spacing::Alone))\n             }\n \n             Interpolated(_) => {\n@@ -1281,15 +1265,15 @@ impl TokenTree {\n         use syntax::parse::token::*;\n         use syntax::tokenstream::{TokenTree, Delimited};\n \n-        let (op, kind, span) = match self {\n-            self::TokenTree::Op(tt) => (tt.op(), tt.spacing(), tt.span()),\n+        let (ch, kind, span) = match self {\n+            self::TokenTree::Punct(tt) => (tt.as_char(), tt.spacing(), tt.span()),\n             self::TokenTree::Group(tt) => {\n                 return TokenTree::Delimited(tt.span.0, Delimited {\n                     delim: tt.delimiter.to_internal(),\n                     tts: tt.stream.0.into(),\n                 }).into();\n             },\n-            self::TokenTree::Term(tt) => {\n+            self::TokenTree::Ident(tt) => {\n                 let ident = ast::Ident::new(tt.sym, tt.span.0);\n                 let sym_str = tt.sym.to_string();\n                 let token = if sym_str.starts_with(\"'\") {\n@@ -1337,7 +1321,7 @@ impl TokenTree {\n             }\n         };\n \n-        let token = match op {\n+        let token = match ch {\n             '=' => Eq,\n             '<' => Lt,\n             '>' => Gt,\n@@ -1359,7 +1343,7 @@ impl TokenTree {\n             '#' => Pound,\n             '$' => Dollar,\n             '?' => Question,\n-            _ => panic!(\"unsupported character {}\", op),\n+            _ => panic!(\"unsupported character {}\", ch),\n         };\n \n         let tree = TokenTree::Token(span.0, token);"}, {"sha": "8fbd9b640c526a7496359676d932be9a04a13812", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=47d4089e100f6a1e19e8687158cc1e0c71ac2ae3", "patch": "@@ -14,7 +14,7 @@\n //! This quasiquoter uses macros 2.0 hygiene to reliably access\n //! items from `proc_macro`, to build a `proc_macro::TokenStream`.\n \n-use {Delimiter, Literal, Spacing, Span, Term, Op, Group, TokenStream, TokenTree};\n+use {Delimiter, Literal, Spacing, Span, Ident, Punct, Group, TokenStream, TokenTree};\n \n use syntax::ext::base::{ExtCtxt, ProcMacro};\n use syntax::parse::token;\n@@ -35,14 +35,14 @@ macro_rules! tt2ts {\n }\n \n macro_rules! quote_tok {\n-    (,) => { tt2ts!(Op::new(',', Spacing::Alone)) };\n-    (.) => { tt2ts!(Op::new('.', Spacing::Alone)) };\n-    (:) => { tt2ts!(Op::new(':', Spacing::Alone)) };\n-    (|) => { tt2ts!(Op::new('|', Spacing::Alone)) };\n+    (,) => { tt2ts!(Punct::new(',', Spacing::Alone)) };\n+    (.) => { tt2ts!(Punct::new('.', Spacing::Alone)) };\n+    (:) => { tt2ts!(Punct::new(':', Spacing::Alone)) };\n+    (|) => { tt2ts!(Punct::new('|', Spacing::Alone)) };\n     (::) => {\n         [\n-            TokenTree::from(Op::new(':', Spacing::Joint)),\n-            TokenTree::from(Op::new(':', Spacing::Alone)),\n+            TokenTree::from(Punct::new(':', Spacing::Joint)),\n+            TokenTree::from(Punct::new(':', Spacing::Alone)),\n         ].iter()\n             .cloned()\n             .map(|mut x| {\n@@ -51,13 +51,13 @@ macro_rules! quote_tok {\n             })\n             .collect::<TokenStream>()\n     };\n-    (!) => { tt2ts!(Op::new('!', Spacing::Alone)) };\n-    (<) => { tt2ts!(Op::new('<', Spacing::Alone)) };\n-    (>) => { tt2ts!(Op::new('>', Spacing::Alone)) };\n-    (_) => { tt2ts!(Op::new('_', Spacing::Alone)) };\n+    (!) => { tt2ts!(Punct::new('!', Spacing::Alone)) };\n+    (<) => { tt2ts!(Punct::new('<', Spacing::Alone)) };\n+    (>) => { tt2ts!(Punct::new('>', Spacing::Alone)) };\n+    (_) => { tt2ts!(Punct::new('_', Spacing::Alone)) };\n     (0) => { tt2ts!(Literal::i8_unsuffixed(0)) };\n-    (&) => { tt2ts!(Op::new('&', Spacing::Alone)) };\n-    ($i:ident) => { tt2ts!(Term::new(stringify!($i), Span::def_site())) };\n+    (&) => { tt2ts!(Punct::new('&', Spacing::Alone)) };\n+    ($i:ident) => { tt2ts!(Ident::new(stringify!($i), Span::def_site())) };\n }\n \n macro_rules! quote_tree {\n@@ -110,15 +110,15 @@ impl Quote for TokenStream {\n             if after_dollar {\n                 after_dollar = false;\n                 match tree {\n-                    TokenTree::Term(_) => {\n+                    TokenTree::Ident(_) => {\n                         let tree = TokenStream::from(tree);\n                         return Some(quote!(::__internal::unquote(&(unquote tree)),));\n                     }\n-                    TokenTree::Op(ref tt) if tt.op() == '$' => {}\n+                    TokenTree::Punct(ref tt) if tt.as_char() == '$' => {}\n                     _ => panic!(\"`$` must be followed by an ident or `$` in `quote!`\"),\n                 }\n-            } else if let TokenTree::Op(tt) = tree {\n-                if tt.op() == '$' {\n+            } else if let TokenTree::Punct(tt) = tree {\n+                if tt.as_char() == '$' {\n                     after_dollar = true;\n                     return None;\n                 }\n@@ -143,9 +143,9 @@ impl Quote for TokenStream {\n impl Quote for TokenTree {\n     fn quote(self) -> TokenStream {\n         match self {\n-            TokenTree::Op(tt) => quote!(::TokenTree::Op( (quote tt) )),\n+            TokenTree::Punct(tt) => quote!(::TokenTree::Punct( (quote tt) )),\n             TokenTree::Group(tt) => quote!(::TokenTree::Group( (quote tt) )),\n-            TokenTree::Term(tt) => quote!(::TokenTree::Term( (quote tt) )),\n+            TokenTree::Ident(tt) => quote!(::TokenTree::Ident( (quote tt) )),\n             TokenTree::Literal(tt) => quote!(::TokenTree::Literal( (quote tt) )),\n         }\n     }\n@@ -175,15 +175,15 @@ impl Quote for Group {\n     }\n }\n \n-impl Quote for Op {\n+impl Quote for Punct {\n     fn quote(self) -> TokenStream {\n-        quote!(::Op::new((quote self.op()), (quote self.spacing())))\n+        quote!(::Punct::new((quote self.as_char()), (quote self.spacing())))\n     }\n }\n \n-impl Quote for Term {\n+impl Quote for Ident {\n     fn quote(self) -> TokenStream {\n-        quote!(::Term::new((quote self.sym.as_str()), (quote self.span())))\n+        quote!(::Ident::new((quote self.sym.as_str()), (quote self.span())))\n     }\n }\n \n@@ -201,7 +201,7 @@ macro_rules! literals {\n         }\n \n         impl LiteralKind {\n-            pub fn with_contents_and_suffix(self, contents: Term, suffix: Option<Term>)\n+            pub fn with_contents_and_suffix(self, contents: Ident, suffix: Option<Ident>)\n                                             -> Literal {\n                 let sym = contents.sym;\n                 let suffix = suffix.map(|t| t.sym);\n@@ -225,13 +225,13 @@ macro_rules! literals {\n         }\n \n         impl Literal {\n-            fn kind_contents_and_suffix(self) -> (LiteralKind, Term, Option<Term>) {\n+            fn kind_contents_and_suffix(self) -> (LiteralKind, Ident, Option<Ident>) {\n                 let (kind, contents) = match self.lit {\n                     $(token::Lit::$i(contents) => (LiteralKind::$i, contents),)*\n                     $(token::Lit::$raw(contents, n) => (LiteralKind::$raw(n), contents),)*\n                 };\n-                let suffix = self.suffix.map(|sym| Term::new(&sym.as_str(), self.span()));\n-                (kind, Term::new(&contents.as_str(), self.span()), suffix)\n+                let suffix = self.suffix.map(|sym| Ident::new(&sym.as_str(), self.span()));\n+                (kind, Ident::new(&contents.as_str(), self.span()), suffix)\n             }\n         }\n "}, {"sha": "f3f7cb1406cbd26359449f582cc13f78040d4492", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/attributes-included.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs?ref=47d4089e100f6a1e19e8687158cc1e0c71ac2ae3", "patch": "@@ -53,7 +53,7 @@ pub fn bar(attr: TokenStream, input: TokenStream) -> TokenStream {\n \n fn assert_inline(slice: &mut &[TokenTree]) {\n     match &slice[0] {\n-        TokenTree::Op(tt) => assert_eq!(tt.op(), '#'),\n+        TokenTree::Punct(tt) => assert_eq!(tt.as_char(), '#'),\n         _ => panic!(\"expected '#' char\"),\n     }\n     match &slice[1] {\n@@ -65,8 +65,8 @@ fn assert_inline(slice: &mut &[TokenTree]) {\n \n fn assert_doc(slice: &mut &[TokenTree]) {\n     match &slice[0] {\n-        TokenTree::Op(tt) => {\n-            assert_eq!(tt.op(), '#');\n+        TokenTree::Punct(tt) => {\n+            assert_eq!(tt.as_char(), '#');\n             assert_eq!(tt.spacing(), Spacing::Alone);\n         }\n         _ => panic!(\"expected #\"),\n@@ -86,12 +86,12 @@ fn assert_doc(slice: &mut &[TokenTree]) {\n     }\n \n     match &tokens[0] {\n-        TokenTree::Term(tt) => assert_eq!(\"doc\", &*tt.to_string()),\n+        TokenTree::Ident(tt) => assert_eq!(\"doc\", &*tt.to_string()),\n         _ => panic!(\"expected `doc`\"),\n     }\n     match &tokens[1] {\n-        TokenTree::Op(tt) => {\n-            assert_eq!(tt.op(), '=');\n+        TokenTree::Punct(tt) => {\n+            assert_eq!(tt.as_char(), '=');\n             assert_eq!(tt.spacing(), Spacing::Alone);\n         }\n         _ => panic!(\"expected equals\"),\n@@ -106,7 +106,7 @@ fn assert_doc(slice: &mut &[TokenTree]) {\n \n fn assert_invoc(slice: &mut &[TokenTree]) {\n     match &slice[0] {\n-        TokenTree::Op(tt) => assert_eq!(tt.op(), '#'),\n+        TokenTree::Punct(tt) => assert_eq!(tt.as_char(), '#'),\n         _ => panic!(\"expected '#' char\"),\n     }\n     match &slice[1] {\n@@ -118,11 +118,11 @@ fn assert_invoc(slice: &mut &[TokenTree]) {\n \n fn assert_foo(slice: &mut &[TokenTree]) {\n     match &slice[0] {\n-        TokenTree::Term(tt) => assert_eq!(&*tt.to_string(), \"fn\"),\n+        TokenTree::Ident(tt) => assert_eq!(&*tt.to_string(), \"fn\"),\n         _ => panic!(\"expected fn\"),\n     }\n     match &slice[1] {\n-        TokenTree::Term(tt) => assert_eq!(&*tt.to_string(), \"foo\"),\n+        TokenTree::Ident(tt) => assert_eq!(&*tt.to_string(), \"foo\"),\n         _ => panic!(\"expected foo\"),\n     }\n     match &slice[2] {\n@@ -148,8 +148,8 @@ fn fold_tree(input: TokenTree) -> TokenTree {\n         TokenTree::Group(b) => {\n             TokenTree::Group(Group::new(b.delimiter(), fold_stream(b.stream())))\n         }\n-        TokenTree::Op(b) => TokenTree::Op(b),\n-        TokenTree::Term(a) => TokenTree::Term(a),\n+        TokenTree::Punct(b) => TokenTree::Punct(b),\n+        TokenTree::Ident(a) => TokenTree::Ident(a),\n         TokenTree::Literal(a) => {\n             if a.to_string() != \"\\\"foo\\\"\" {\n                 TokenTree::Literal(a)"}, {"sha": "d669138e320692c7e45e5c7305caacb28b6bfe97", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs?ref=47d4089e100f6a1e19e8687158cc1e0c71ac2ae3", "patch": "@@ -33,7 +33,7 @@ pub fn cond(input: TokenStream) -> TokenStream {\n             panic!(\"Invalid macro usage in cond: {}\", cond);\n         }\n         let is_else = match test {\n-            TokenTree::Term(word) => &*word.to_string() == \"else\",\n+            TokenTree::Ident(word) => &*word.to_string() == \"else\",\n             _ => false,\n         };\n         conds.push(if is_else || input.peek().is_none() {"}, {"sha": "55c4c32a94d80c8e85610cac5db99fa98cec606c", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/count_compound_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcount_compound_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcount_compound_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcount_compound_ops.rs?ref=47d4089e100f6a1e19e8687158cc1e0c71ac2ae3", "patch": "@@ -28,7 +28,7 @@ fn count_compound_ops_helper(input: TokenStream) -> u32 {\n     let mut count = 0;\n     for token in input {\n         match &token {\n-            TokenTree::Op(tt) if tt.spacing() == Spacing::Alone => {\n+            TokenTree::Punct(tt) if tt.spacing() == Spacing::Alone => {\n                 count += 1;\n             }\n             TokenTree::Group(tt) => {"}, {"sha": "fb505755792321d7d3b156816daca4d96d8a449a", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/modify-ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fmodify-ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fmodify-ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fmodify-ast.rs?ref=47d4089e100f6a1e19e8687158cc1e0c71ac2ae3", "patch": "@@ -38,14 +38,14 @@ fn assert_eq(a: TokenStream, b: TokenStream) {\n                 assert_eq!(a.delimiter(), b.delimiter());\n                 assert_eq(a.stream(), b.stream());\n             }\n-            (TokenTree::Op(a), TokenTree::Op(b)) => {\n-                assert_eq!(a.op(), b.op());\n+            (TokenTree::Punct(a), TokenTree::Punct(b)) => {\n+                assert_eq!(a.as_char(), b.as_char());\n                 assert_eq!(a.spacing(), b.spacing());\n             }\n             (TokenTree::Literal(a), TokenTree::Literal(b)) => {\n                 assert_eq!(a.to_string(), b.to_string());\n             }\n-            (TokenTree::Term(a), TokenTree::Term(b)) => {\n+            (TokenTree::Ident(a), TokenTree::Ident(b)) => {\n                 assert_eq!(a.to_string(), b.to_string());\n             }\n             (a, b) => panic!(\"{:?} != {:?}\", a, b),"}, {"sha": "c6ce26aaa851b09bda0bb2bd21be0a57fc6659dd", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/three-equals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d4089e100f6a1e19e8687158cc1e0c71ac2ae3/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs?ref=47d4089e100f6a1e19e8687158cc1e0c71ac2ae3", "patch": "@@ -27,8 +27,8 @@ fn parse(input: TokenStream) -> Result<(), Diagnostic> {\n                            .help(\"input must be: `===`\"))\n         }\n \n-        if let TokenTree::Op(tt) = tree {\n-            if tt.op() == '=' {\n+        if let TokenTree::Punct(tt) = tree {\n+            if tt.as_char() == '=' {\n                 count += 1;\n                 last_span = span;\n                 continue"}]}