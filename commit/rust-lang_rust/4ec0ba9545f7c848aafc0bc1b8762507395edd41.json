{"sha": "4ec0ba9545f7c848aafc0bc1b8762507395edd41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYzBiYTk1NDVmN2M4NDhhYWZjMGJjMWI4NzYyNTA3Mzk1ZWRkNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-15T01:12:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-15T01:12:01Z"}, "message": "Auto merge of #55716 - RalfJung:escape-to-raw, r=oli-obk\n\nAdd escape-to-raw MIR statement\n\nAdd a new MIR \"ghost state statement\": Escaping a ptr to permit raw accesses.\n\n~~This includes #55549, [click here](https://github.com/RalfJung/rust/compare/miri-visitor...RalfJung:escape-to-raw) for just the new commits.~~", "tree": {"sha": "f4ba507ff41add222bcb5d2d34c25cef07817630", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4ba507ff41add222bcb5d2d34c25cef07817630"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ec0ba9545f7c848aafc0bc1b8762507395edd41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ec0ba9545f7c848aafc0bc1b8762507395edd41", "html_url": "https://github.com/rust-lang/rust/commit/4ec0ba9545f7c848aafc0bc1b8762507395edd41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ec0ba9545f7c848aafc0bc1b8762507395edd41/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d3b9b1640611c52eb949dd60e8b9565997c6cea", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d3b9b1640611c52eb949dd60e8b9565997c6cea", "html_url": "https://github.com/rust-lang/rust/commit/7d3b9b1640611c52eb949dd60e8b9565997c6cea"}, {"sha": "b891a81164e86fa21f55607bc56b0b8e04083936", "url": "https://api.github.com/repos/rust-lang/rust/commits/b891a81164e86fa21f55607bc56b0b8e04083936", "html_url": "https://github.com/rust-lang/rust/commit/b891a81164e86fa21f55607bc56b0b8e04083936"}], "stats": {"total": 430, "additions": 267, "deletions": 163}, "files": [{"sha": "d6ad74f16a92b25811a613f1f98856961820bca3", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -220,6 +220,9 @@ for mir::StatementKind<'gcx> {\n             mir::StatementKind::EndRegion(ref region_scope) => {\n                 region_scope.hash_stable(hcx, hasher);\n             }\n+            mir::StatementKind::EscapeToRaw(ref place) => {\n+                place.hash_stable(hcx, hasher);\n+            }\n             mir::StatementKind::Retag { fn_entry, ref place } => {\n                 fn_entry.hash_stable(hcx, hasher);\n                 place.hash_stable(hcx, hasher);"}, {"sha": "d8e45c881f5551541e35418a9b4591fc05adeb42", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -1782,6 +1782,13 @@ pub enum StatementKind<'tcx> {\n         place: Place<'tcx>,\n     },\n \n+    /// Escape the given reference to a raw pointer, so that it can be accessed\n+    /// without precise provenance tracking. These statements are currently only interpreted\n+    /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n+    /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n+    /// for more details.\n+    EscapeToRaw(Operand<'tcx>),\n+\n     /// Mark one terminating point of a region scope (i.e. static region).\n     /// (The starting point(s) arise implicitly from borrows.)\n     EndRegion(region::Scope),\n@@ -1843,6 +1850,7 @@ impl<'tcx> Debug for Statement<'tcx> {\n             EndRegion(ref ce) => write!(fmt, \"EndRegion({})\", ty::ReScope(*ce)),\n             Retag { fn_entry, ref place } =>\n                 write!(fmt, \"Retag({}{:?})\", if fn_entry { \"[fn entry] \" } else { \"\" }, place),\n+            EscapeToRaw(ref place) => write!(fmt, \"EscapeToRaw({:?})\", place),\n             StorageLive(ref place) => write!(fmt, \"StorageLive({:?})\", place),\n             StorageDead(ref place) => write!(fmt, \"StorageDead({:?})\", place),\n             SetDiscriminant {\n@@ -3019,6 +3027,7 @@ EnumTypeFoldableImpl! {\n         (StatementKind::StorageDead)(a),\n         (StatementKind::InlineAsm) { asm, outputs, inputs },\n         (StatementKind::Retag) { fn_entry, place },\n+        (StatementKind::EscapeToRaw)(place),\n         (StatementKind::EndRegion)(a),\n         (StatementKind::AscribeUserType)(a, v, b),\n         (StatementKind::Nop),"}, {"sha": "2a994ee0509c26acb7584994e649beb34632fddc", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -385,6 +385,9 @@ macro_rules! make_mir_visitor {\n                             location\n                         );\n                     }\n+                    StatementKind::EscapeToRaw(ref $($mutability)* op) => {\n+                        self.visit_operand(op, location);\n+                    }\n                     StatementKind::StorageLive(ref $($mutability)* local) => {\n                         self.visit_local(\n                             local,\n@@ -1022,7 +1025,7 @@ pub enum MutatingUseContext<'tcx> {\n     ///     f(&mut x.y);\n     ///\n     Projection,\n-    /// Retagging (updating the \"Stacked Borrows\" tag)\n+    /// Retagging, a \"Stacked Borrows\" shadow state operation\n     Retag,\n }\n "}, {"sha": "8bda2c98594e500e7b3844d7648c56f4a22e016a", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -105,8 +105,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 bx\n             }\n             mir::StatementKind::FakeRead(..) |\n-            mir::StatementKind::EndRegion(_) |\n+            mir::StatementKind::EndRegion(..) |\n             mir::StatementKind::Retag { .. } |\n+            mir::StatementKind::EscapeToRaw { .. } |\n             mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => bx,\n         }"}, {"sha": "f0d3b863f78b287e66c2d8ec20efaa604dca9333", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -599,6 +599,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             StatementKind::Nop\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Retag { .. }\n+            | StatementKind::EscapeToRaw { .. }\n             | StatementKind::StorageLive(..) => {\n                 // `Nop`, `AscribeUserType`, `Retag`, and `StorageLive` are irrelevant\n                 // to borrow check."}, {"sha": "576509c0fddda371290730177de46ab8a879fb68", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -137,6 +137,7 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n             StatementKind::Nop |\n             StatementKind::AscribeUserType(..) |\n             StatementKind::Retag { .. } |\n+            StatementKind::EscapeToRaw { .. } |\n             StatementKind::StorageLive(..) => {\n                 // `Nop`, `AscribeUserType`, `Retag`, and `StorageLive` are irrelevant\n                 // to borrow check."}, {"sha": "cd814de10c3657dbce9fe0242846b24444924e22", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -1311,11 +1311,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             StatementKind::FakeRead(..)\n-            | StatementKind::StorageLive(_)\n-            | StatementKind::StorageDead(_)\n+            | StatementKind::StorageLive(..)\n+            | StatementKind::StorageDead(..)\n             | StatementKind::InlineAsm { .. }\n             | StatementKind::EndRegion(_)\n             | StatementKind::Retag { .. }\n+            | StatementKind::EscapeToRaw { .. }\n             | StatementKind::Nop => {}\n         }\n     }"}, {"sha": "cb3c88876a3a803b7d5a327c3bccd37db88f34ab", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -86,6 +86,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // region_scope=None so place indexes live forever. They are scalars so they\n                 // do not need storage annotations, and they are often copied between\n                 // places.\n+                // Making this a *fresh* temporary also means we do not have to worry about\n+                // the index changing later: Nothing will ever change this temporary.\n+                // The \"retagging\" transformation (for Stacked Borrows) relies on this.\n                 let idx = unpack!(block = this.as_temp(block, None, index, Mutability::Mut));\n \n                 // bounds check:"}, {"sha": "7bff76f948e57b8ed123684996f5d693061a51aa", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -351,7 +351,6 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n \n     const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n-    const ENABLE_PTR_TRACKING_HOOKS: bool = false; // we don't have no provenance\n \n     #[inline(always)]\n     fn enforce_validity(_ecx: &EvalContext<'a, 'mir, 'tcx, Self>) -> bool {"}, {"sha": "811da9e1acca7eacc50d3aa050c4435509ba006e", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -339,6 +339,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::SetDiscriminant { .. } |\n             mir::StatementKind::StorageLive(..) |\n             mir::StatementKind::Retag { .. } |\n+            mir::StatementKind::EscapeToRaw { .. } |\n             mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => {}\n "}, {"sha": "0e2376d201fd6bfccf2efaa1701af55f26f00400", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -301,8 +301,9 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                 span_bug!(stmt.source_info.span,\n                           \"SetDiscriminant should not exist during borrowck\");\n             }\n-            StatementKind::EndRegion(_) |\n+            StatementKind::EndRegion(..) |\n             StatementKind::Retag { .. } |\n+            StatementKind::EscapeToRaw { .. } |\n             StatementKind::AscribeUserType(..) |\n             StatementKind::Nop => {}\n         }"}, {"sha": "118539fc58ebf2bb2299390554e8adf41bd52f94", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -44,40 +44,28 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n \n             Misc => {\n-                let src_layout = src.layout;\n                 let src = self.read_immediate(src)?;\n \n-                let src = if M::ENABLE_PTR_TRACKING_HOOKS && src_layout.ty.is_region_ptr() {\n-                    // The only `Misc` casts on references are those creating raw pointers.\n-                    assert!(dest.layout.ty.is_unsafe_ptr());\n-                    // For the purpose of the \"ptr tag hooks\", treat this as creating\n-                    // a new, raw reference.\n-                    let place = self.ref_to_mplace(src)?;\n-                    self.create_ref(place, None)?\n-                } else {\n-                    *src\n-                };\n-\n-                if self.type_is_fat_ptr(src_layout.ty) {\n-                    match (src, self.type_is_fat_ptr(dest.layout.ty)) {\n+                if self.type_is_fat_ptr(src.layout.ty) {\n+                    match (*src, self.type_is_fat_ptr(dest.layout.ty)) {\n                         // pointers to extern types\n                         (Immediate::Scalar(_),_) |\n                         // slices and trait objects to other slices/trait objects\n                         (Immediate::ScalarPair(..), true) => {\n                             // No change to immediate\n-                            self.write_immediate(src, dest)?;\n+                            self.write_immediate(*src, dest)?;\n                         }\n                         // slices and trait objects to thin pointers (dropping the metadata)\n                         (Immediate::ScalarPair(data, _), false) => {\n                             self.write_scalar(data, dest)?;\n                         }\n                     }\n                 } else {\n-                    match src_layout.variants {\n+                    match src.layout.variants {\n                         layout::Variants::Single { index } => {\n-                            if let Some(def) = src_layout.ty.ty_adt_def() {\n+                            if let Some(def) = src.layout.ty.ty_adt_def() {\n                                 // Cast from a univariant enum\n-                                assert!(src_layout.is_zst());\n+                                assert!(src.layout.is_zst());\n                                 let discr_val = def\n                                     .discriminant_for_variant(*self.tcx, index)\n                                     .val;\n@@ -90,8 +78,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         layout::Variants::NicheFilling { .. } => {},\n                     }\n \n-                    let src = src.to_scalar()?;\n-                    let dest_val = self.cast_scalar(src, src_layout, dest.layout)?;\n+                    let dest_val = self.cast_scalar(src.to_scalar()?, src.layout, dest.layout)?;\n                     self.write_scalar(dest_val, dest)?;\n                 }\n             }"}, {"sha": "7ef940059705ce39cb8ffe543fdee2ef06e35269", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -201,18 +201,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         } else if Some(def_id) == self.tcx.lang_items().panic_fn() {\n             assert!(args.len() == 1);\n             // &(&'static str, &'static str, u32, u32)\n-            let ptr = self.read_immediate(args[0])?;\n-            let place = self.ref_to_mplace(ptr)?;\n+            let place = self.deref_operand(args[0])?;\n             let (msg, file, line, col) = (\n                 self.mplace_field(place, 0)?,\n                 self.mplace_field(place, 1)?,\n                 self.mplace_field(place, 2)?,\n                 self.mplace_field(place, 3)?,\n             );\n \n-            let msg_place = self.ref_to_mplace(self.read_immediate(msg.into())?)?;\n+            let msg_place = self.deref_operand(msg.into())?;\n             let msg = Symbol::intern(self.read_str(msg_place)?);\n-            let file_place = self.ref_to_mplace(self.read_immediate(file.into())?)?;\n+            let file_place = self.deref_operand(file.into())?;\n             let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;\n             let col = self.read_scalar(col.into())?.to_u32()?;\n@@ -221,17 +220,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             assert!(args.len() == 2);\n             // &'static str, &(&'static str, u32, u32)\n             let msg = args[0];\n-            let ptr = self.read_immediate(args[1])?;\n-            let place = self.ref_to_mplace(ptr)?;\n+            let place = self.deref_operand(args[1])?;\n             let (file, line, col) = (\n                 self.mplace_field(place, 0)?,\n                 self.mplace_field(place, 1)?,\n                 self.mplace_field(place, 2)?,\n             );\n \n-            let msg_place = self.ref_to_mplace(self.read_immediate(msg.into())?)?;\n+            let msg_place = self.deref_operand(msg.into())?;\n             let msg = Symbol::intern(self.read_str(msg_place)?);\n-            let file_place = self.ref_to_mplace(self.read_immediate(file.into())?)?;\n+            let file_place = self.deref_operand(file.into())?;\n             let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;\n             let col = self.read_scalar(col.into())?.to_u32()?;"}, {"sha": "57640dc48f13fa1c3fda683e360f1048ebbaa205", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -95,11 +95,6 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// that is added to the memory so that the work is not done twice.\n     const STATIC_KIND: Option<Self::MemoryKinds>;\n \n-    /// As an optimization, you can prevent the pointer tracking hooks from ever being\n-    /// called.  You should only do this if you do not care about provenance tracking.\n-    /// This controls the `tag_reference` and `tag_dereference` hooks.\n-    const ENABLE_PTR_TRACKING_HOOKS: bool;\n-\n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &EvalContext<'a, 'mir, 'tcx, Self>) -> bool;\n \n@@ -181,18 +176,6 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         kind: MemoryKind<Self::MemoryKinds>,\n     ) -> EvalResult<'tcx, Pointer<Self::PointerTag>>;\n \n-    /// Executed when evaluating the `&` operator: Creating a new reference.\n-    /// This has the chance to adjust the tag.  It should not change anything else!\n-    /// `mutability` can be `None` in case a raw ptr is being created.\n-    #[inline]\n-    fn tag_reference(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        place: MPlaceTy<'tcx, Self::PointerTag>,\n-        _mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Scalar<Self::PointerTag>> {\n-        Ok(place.ptr)\n-    }\n-\n     /// Executed when evaluating the `*` operator: Following a reference.\n     /// This has the chance to adjust the tag.  It should not change anything else!\n     /// `mutability` can be `None` in case a raw ptr is being dereferenced.\n@@ -205,7 +188,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         Ok(place.ptr)\n     }\n \n-    /// Execute a validation operation\n+    /// Execute a retagging operation\n     #[inline]\n     fn retag(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n@@ -214,4 +197,13 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     ) -> EvalResult<'tcx> {\n         Ok(())\n     }\n+\n+    /// Execute an escape-to-raw operation\n+    #[inline]\n+    fn escape_to_raw(\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ptr: OpTy<'tcx, Self::PointerTag>,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n }"}, {"sha": "578bcdc09295dd4e28304c5807be9d3610c1fcca", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -431,17 +431,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         })\n     }\n \n-    // Take an operand, representing a pointer, and dereference it to a place -- that\n-    // will always be a MemPlace.\n-    pub(super) fn deref_operand(\n-        &self,\n-        src: OpTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        let val = self.read_immediate(src)?;\n-        trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n-        Ok(self.ref_to_mplace(val)?)\n-    }\n-\n     pub fn operand_projection(\n         &self,\n         base: OpTy<'tcx, M::PointerTag>,"}, {"sha": "201d320dcd85812c50791d826a4b352713af1de4", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -151,6 +151,16 @@ impl<Tag> MemPlace<Tag> {\n         // it now must be aligned.\n         self.to_scalar_ptr_align().0.to_ptr()\n     }\n+\n+    /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n+    /// This is the inverse of `ref_to_mplace`.\n+    #[inline(always)]\n+    pub fn to_ref(self) -> Immediate<Tag> {\n+        match self.meta {\n+            None => Immediate::Scalar(self.ptr.into()),\n+            Some(meta) => Immediate::ScalarPair(self.ptr.into(), meta.into()),\n+        }\n+    }\n }\n \n impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n@@ -267,50 +277,45 @@ where\n     M::AllocExtra: AllocationExtra<Tag>,\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n-    /// Alignment is just based on the type.  This is the inverse of `create_ref`.\n+    /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n+    /// This does NOT call the \"deref\" machine hook, so it does NOT count as a\n+    /// deref as far as Stacked Borrows is concerned.  Use `deref_operand` for that!\n     pub fn ref_to_mplace(\n         &self,\n         val: ImmTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n         let layout = self.layout_of(pointee_type)?;\n \n-        let align = layout.align;\n-        let meta = val.to_meta()?;\n-        let ptr = val.to_scalar_ptr()?;\n-        let mplace = MemPlace { ptr, align, meta };\n-        let mut mplace = MPlaceTy { mplace, layout };\n-        // Pointer tag tracking might want to adjust the tag.\n-        if M::ENABLE_PTR_TRACKING_HOOKS {\n-            let mutbl = match val.layout.ty.sty {\n-                // `builtin_deref` considers boxes immutable, that's useless for our purposes\n-                ty::Ref(_, _, mutbl) => Some(mutbl),\n-                ty::Adt(def, _) if def.is_box() => Some(hir::MutMutable),\n-                ty::RawPtr(_) => None,\n-                _ => bug!(\"Unexpected pointer type {}\", val.layout.ty.sty),\n-            };\n-            mplace.mplace.ptr = M::tag_dereference(self, mplace, mutbl)?;\n-        }\n-        // Done\n-        Ok(mplace)\n+        let mplace = MemPlace {\n+            ptr: val.to_scalar_ptr()?,\n+            align: layout.align,\n+            meta: val.to_meta()?,\n+        };\n+        Ok(MPlaceTy { mplace, layout })\n     }\n \n-    /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n-    /// This is the inverse of `ref_to_mplace`.\n-    /// `mutbl` indicates whether we are create a shared or mutable ref, or a raw pointer (`None`).\n-    pub fn create_ref(\n-        &mut self,\n-        mut place: MPlaceTy<'tcx, M::PointerTag>,\n-        mutbl: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Immediate<M::PointerTag>> {\n-        // Pointer tag tracking might want to adjust the tag\n-        if M::ENABLE_PTR_TRACKING_HOOKS {\n-            place.mplace.ptr = M::tag_reference(self, place, mutbl)?\n-        }\n-        Ok(match place.meta {\n-            None => Immediate::Scalar(place.ptr.into()),\n-            Some(meta) => Immediate::ScalarPair(place.ptr.into(), meta.into()),\n-        })\n+    // Take an operand, representing a pointer, and dereference it to a place -- that\n+    // will always be a MemPlace.  Lives in `place.rs` because it creates a place.\n+    // This calls the \"deref\" machine hook, and counts as a deref as far as\n+    // Stacked Borrows is concerned.\n+    pub fn deref_operand(\n+        &self,\n+        src: OpTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        let val = self.read_immediate(src)?;\n+        trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n+        let mut place = self.ref_to_mplace(val)?;\n+        // Pointer tag tracking might want to adjust the tag.\n+        let mutbl = match val.layout.ty.sty {\n+            // `builtin_deref` considers boxes immutable, that's useless for our purposes\n+            ty::Ref(_, _, mutbl) => Some(mutbl),\n+            ty::Adt(def, _) if def.is_box() => Some(hir::MutMutable),\n+            ty::RawPtr(_) => None,\n+            _ => bug!(\"Unexpected pointer type {}\", val.layout.ty.sty),\n+        };\n+        place.mplace.ptr = M::tag_dereference(self, place, mutbl)?;\n+        Ok(place)\n     }\n \n     /// Offset a pointer to project to a field. Unlike place_field, this is always"}, {"sha": "ac13e5982dae38549edd61a80b21579904807d41", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -12,7 +12,7 @@\n //!\n //! The main entry point is the `step` method.\n \n-use rustc::{hir, mir};\n+use rustc::mir;\n use rustc::ty::layout::LayoutOf;\n use rustc::mir::interpret::{EvalResult, Scalar, PointerArithmetic};\n \n@@ -118,12 +118,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             // interpreter is solely intended for borrowck'ed code.\n             FakeRead(..) => {}\n \n-            // Retagging.\n+            // Stacked Borrows.\n             Retag { fn_entry, ref place } => {\n                 let dest = self.eval_place(place)?;\n                 M::retag(self, fn_entry, dest)?;\n             }\n+            EscapeToRaw(ref op) => {\n+                let op = self.eval_operand(op, None)?;\n+                M::escape_to_raw(self, op)?;\n+            }\n \n+            // Statements we do not track.\n             EndRegion(..) => {}\n             AscribeUserType(..) => {}\n \n@@ -247,19 +252,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 )?;\n             }\n \n-            Ref(_, borrow_kind, ref place) => {\n+            Ref(_, _, ref place) => {\n                 let src = self.eval_place(place)?;\n                 let val = self.force_allocation(src)?;\n-                let mutbl = match borrow_kind {\n-                    mir::BorrowKind::Mut { .. } |\n-                    mir::BorrowKind::Unique =>\n-                        hir::MutMutable,\n-                    mir::BorrowKind::Shared |\n-                    mir::BorrowKind::Shallow =>\n-                        hir::MutImmutable,\n-                };\n-                let val = self.create_ref(val, Some(mutbl))?;\n-                self.write_immediate(val, dest)?;\n+                self.write_immediate(val.to_ref(), dest)?;\n             }\n \n             NullaryOp(mir::NullOp::Box, _) => {"}, {"sha": "6070b31d3e7a3f7d67c6926223acb2e183f8ffeb", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -402,7 +402,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.pointer_size();\n                 let ptr_align = self.tcx.data_layout.pointer_align;\n-                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let ptr = self.deref_operand(args[0])?;\n                 let vtable = ptr.vtable()?;\n                 let fn_ptr = self.memory.read_ptr_sized(\n                     vtable.offset(ptr_size * (idx as u64 + 3), self)?,\n@@ -447,10 +447,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         };\n \n         let arg = OpTy {\n-            op: Operand::Immediate(self.create_ref(\n-                place,\n-                None // this is a \"raw reference\"\n-            )?),\n+            op: Operand::Immediate(place.to_ref()),\n             layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         };\n "}, {"sha": "c3554512806b34257391c4be2cfc94970f9c7558", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -373,13 +373,10 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                         }\n                     }\n                 }\n-                // Turn ptr into place.\n-                // `ref_to_mplace` also calls the machine hook for (re)activating the tag,\n-                // which in turn will (in full miri) check if the pointer is dereferencable.\n-                let place = self.ecx.ref_to_mplace(value)?;\n                 // Recursive checking\n                 if let Some(ref mut ref_tracking) = self.ref_tracking {\n                     assert!(self.const_mode, \"We should only do recursie checking in const mode\");\n+                    let place = self.ecx.ref_to_mplace(value)?;\n                     if size != Size::ZERO {\n                         // Non-ZST also have to be dereferencable\n                         let ptr = try_validation!(place.ptr.to_ptr(),"}, {"sha": "93bf1b3e36e38a8c7ce5f48b69b244062e663ffa", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -223,6 +223,15 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     );\n \n     if let Some(..) = ty {\n+        // The first argument (index 0), but add 1 for the return value.\n+        let dropee_ptr = Place::Local(Local::new(1+0));\n+        if tcx.sess.opts.debugging_opts.mir_emit_retag {\n+            // We use raw ptr operations, better prepare the alias tracking for that\n+            mir.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n+                source_info,\n+                kind: StatementKind::EscapeToRaw(Operand::Copy(dropee_ptr.clone())),\n+            })\n+        }\n         let patch = {\n             let param_env = tcx.param_env(def_id).with_reveal_all();\n             let mut elaborator = DropShimElaborator {\n@@ -231,7 +240,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 tcx,\n                 param_env\n             };\n-            let dropee = Place::Local(Local::new(1+0)).deref();\n+            let dropee = dropee_ptr.deref();\n             let resume_block = elaborator.patch.resume_block();\n             elaborate_drops::elaborate_drop(\n                 &mut elaborator,"}, {"sha": "be7e34e2dcb3cf595d776fdab3178ffb32ccdace", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 70, "deletions": 36, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -20,42 +20,46 @@ use transform::{MirPass, MirSource};\n \n pub struct AddRetag;\n \n-/// Determines whether this place is local: If it is part of a local variable.\n-/// We do not consider writes to pointers local, only writes that immediately assign\n-/// to a local variable.\n-/// One important property here is that evaluating the place immediately after\n-/// the assignment must produce the same place as what was used during the assignment.\n-fn is_local<'tcx>(\n+/// Determines whether this place is \"stable\": Whether, if we evaluate it again\n+/// after the assignment, we can be sure to obtain the same place value.\n+/// (Concurrent accesses by other threads are no problem as these are anyway non-atomic\n+/// copies.  Data races are UB.)\n+fn is_stable<'tcx>(\n     place: &Place<'tcx>,\n ) -> bool {\n     use rustc::mir::Place::*;\n \n     match *place {\n-        Local { .. } => true,\n-        Promoted(_) |\n-        Static(_) => false,\n+        // Locals and statics have stable addresses, for sure\n+        Local { .. } |\n+        Promoted { .. } |\n+        Static { .. } =>\n+            true,\n+        // Recurse for projections\n         Projection(ref proj) => {\n             match proj.elem {\n-                ProjectionElem::Deref |\n-                ProjectionElem::Index(_) =>\n-                    // Which place these point to depends on external circumstances\n-                    // (a local storing the array index, the current value of\n-                    // the projection base), so we stop tracking here.\n+                // Which place this evaluates to can change with any memory write,\n+                // so cannot assume this to be stable.\n+                ProjectionElem::Deref =>\n                     false,\n+                // Array indices are intersting, but MIR building generates a *fresh*\n+                // temporary for every array access, so the index cannot be changed as\n+                // a side-effect.\n+                ProjectionElem::Index { .. } |\n+                // The rest is completely boring, they just offset by a constant.\n                 ProjectionElem::Field { .. } |\n                 ProjectionElem::ConstantIndex { .. } |\n                 ProjectionElem::Subslice { .. } |\n                 ProjectionElem::Downcast { .. } =>\n-                    // These just offset by a constant, entirely independent of everything else.\n-                    is_local(&proj.base),\n+                    is_stable(&proj.base),\n             }\n         }\n     }\n }\n \n-/// Determine whether this type has a reference in it, recursing below compound types but\n+/// Determine whether this type may have a reference in it, recursing below compound types but\n /// not below references.\n-fn has_reference<'a, 'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+fn may_have_reference<'a, 'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n     match ty.sty {\n         // Primitive types that are not references\n         ty::Bool | ty::Char |\n@@ -68,12 +72,12 @@ fn has_reference<'a, 'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> b\n         ty::Adt(..) if ty.is_box() => true,\n         // Compound types\n         ty::Array(ty, ..) | ty::Slice(ty) =>\n-            has_reference(ty, tcx),\n+            may_have_reference(ty, tcx),\n         ty::Tuple(tys) =>\n-            tys.iter().any(|ty| has_reference(ty, tcx)),\n+            tys.iter().any(|ty| may_have_reference(ty, tcx)),\n         ty::Adt(adt, substs) =>\n             adt.variants.iter().any(|v| v.fields.iter().any(|f|\n-                has_reference(f.ty(tcx, substs), tcx)\n+                may_have_reference(f.ty(tcx, substs), tcx)\n             )),\n         // Conservative fallback\n         _ => true,\n@@ -92,7 +96,9 @@ impl MirPass for AddRetag {\n         let (span, arg_count) = (mir.span, mir.arg_count);\n         let (basic_blocks, local_decls) = mir.basic_blocks_and_local_decls_mut();\n         let needs_retag = |place: &Place<'tcx>| {\n-            is_local(place) && has_reference(place.ty(&*local_decls, tcx).to_ty(tcx), tcx)\n+            // FIXME: Instead of giving up for unstable places, we should introduce\n+            // a temporary and retag on that.\n+            is_stable(place) && may_have_reference(place.ty(&*local_decls, tcx).to_ty(tcx), tcx)\n         };\n \n         // PART 1\n@@ -118,23 +124,29 @@ impl MirPass for AddRetag {\n         }\n \n         // PART 2\n-        // Retag return values of functions.\n+        // Retag return values of functions.  Also escape-to-raw the argument of `drop`.\n         // We collect the return destinations because we cannot mutate while iterating.\n         let mut returns: Vec<(SourceInfo, Place<'tcx>, BasicBlock)> = Vec::new();\n         for block_data in basic_blocks.iter_mut() {\n-            match block_data.terminator {\n-                Some(Terminator { kind: TerminatorKind::Call { ref destination, .. },\n-                                  source_info }) => {\n+            match block_data.terminator().kind {\n+                TerminatorKind::Call { ref destination, .. } => {\n                     // Remember the return destination for later\n                     if let Some(ref destination) = destination {\n                         if needs_retag(&destination.0) {\n-                            returns.push((source_info, destination.0.clone(), destination.1));\n+                            returns.push((\n+                                block_data.terminator().source_info,\n+                                destination.0.clone(),\n+                                destination.1,\n+                            ));\n                         }\n                     }\n                 }\n+                TerminatorKind::Drop { .. } |\n+                TerminatorKind::DropAndReplace { .. } => {\n+                    // `Drop` is also a call, but it doesn't return anything so we are good.\n+                }\n                 _ => {\n                     // Not a block ending in a Call -> ignore.\n-                    // `Drop` is also a call, but it doesn't return anything so we are good.\n                 }\n             }\n         }\n@@ -153,21 +165,43 @@ impl MirPass for AddRetag {\n             // iterate backwards using indices.\n             for i in (0..block_data.statements.len()).rev() {\n                 match block_data.statements[i].kind {\n-                    // Assignments can make values obtained elsewhere \"local\".\n-                    // We could try to be smart here and e.g. only retag if the assignment\n-                    // loaded from memory, but that seems risky: We might miss a subtle corner\n-                    // case.\n-                    StatementKind::Assign(ref place, box Rvalue::Use(..))\n-                    if needs_retag(place) => {\n+                    // If we are casting *from* a reference, we may have to escape-to-raw.\n+                    StatementKind::Assign(_, box Rvalue::Cast(\n+                        CastKind::Misc,\n+                        ref src,\n+                        dest_ty,\n+                    )) => {\n+                        let src_ty = src.ty(&*local_decls, tcx);\n+                        if src_ty.is_region_ptr() {\n+                            // The only `Misc` casts on references are those creating raw pointers.\n+                            assert!(dest_ty.is_unsafe_ptr());\n+                            // Insert escape-to-raw before the cast.  We are not concerned\n+                            // with stability here: Our EscapeToRaw will not change the value\n+                            // that the cast will then use.\n+                            // `src` might be a \"move\", but we rely on this not actually moving\n+                            // but just doing a memcpy.  It is crucial that we do EscapeToRaw\n+                            // on the src because we need it with its original type.\n+                            let source_info = block_data.statements[i].source_info;\n+                            block_data.statements.insert(i, Statement {\n+                                source_info,\n+                                kind: StatementKind::EscapeToRaw(src.clone()),\n+                            });\n+                        }\n+                    }\n+                    // Assignments of reference or ptr type are the ones where we may have\n+                    // to update tags.  This includes `x = &[mut] ...` and hence\n+                    // we also retag after taking a reference!\n+                    StatementKind::Assign(ref place, _) if needs_retag(place) => {\n                         // Insert a retag after the assignment.\n                         let source_info = block_data.statements[i].source_info;\n-                        block_data.statements.insert(i+1,Statement {\n+                        block_data.statements.insert(i+1, Statement {\n                             source_info,\n                             kind: StatementKind::Retag { fn_entry: false, place: place.clone() },\n                         });\n                     }\n+                    // Do nothing for the rest\n                     _ => {},\n-                }\n+                };\n             }\n         }\n     }"}, {"sha": "4ebeebca2273bbf48034609258f5df5dcaaf83d8", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -114,6 +114,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             StatementKind::StorageDead(..) |\n             StatementKind::EndRegion(..) |\n             StatementKind::Retag { .. } |\n+            StatementKind::EscapeToRaw { .. } |\n             StatementKind::AscribeUserType(..) |\n             StatementKind::Nop => {\n                 // safe (at least as emitted during MIR construction)"}, {"sha": "24cc4cce747e0fdb906b7f54501500041e0de5bc", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -685,6 +685,13 @@ fn create_generator_drop_shim<'a, 'tcx>(\n         is_block_tail: None,\n         is_user_variable: None,\n     };\n+    if tcx.sess.opts.debugging_opts.mir_emit_retag {\n+        // Alias tracking must know we changed the type\n+        mir.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n+            source_info,\n+            kind: StatementKind::EscapeToRaw(Operand::Copy(Place::Local(self_arg()))),\n+        })\n+    }\n \n     no_landing_pads(tcx, &mut mir);\n "}, {"sha": "00309b0a3e905229c364e4829e004389e1bde13e", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -1170,6 +1170,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 StatementKind::InlineAsm {..} |\n                 StatementKind::EndRegion(_) |\n                 StatementKind::Retag { .. } |\n+                StatementKind::EscapeToRaw { .. } |\n                 StatementKind::AscribeUserType(..) |\n                 StatementKind::Nop => {}\n             }"}, {"sha": "ed13063cfdf1700d3abd4a64eaff14a5cd200f59", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -242,6 +242,7 @@ fn check_statement(\n         | StatementKind::StorageLive(_)\n         | StatementKind::StorageDead(_)\n         | StatementKind::Retag { .. }\n+        | StatementKind::EscapeToRaw { .. }\n         | StatementKind::EndRegion(_)\n         | StatementKind::AscribeUserType(..)\n         | StatementKind::Nop => Ok(()),"}, {"sha": "445ffbbcf3407b0d56ee25e5842412c343e9c3ec", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -65,10 +65,11 @@ impl RemoveNoopLandingPads {\n                     // turn a landing pad to a non-nop\n                 }\n \n-                StatementKind::Assign(_, _) |\n+                StatementKind::Assign { .. } |\n                 StatementKind::SetDiscriminant { .. } |\n                 StatementKind::InlineAsm { .. } |\n-                StatementKind::Retag { .. } => {\n+                StatementKind::Retag { .. } |\n+                StatementKind::EscapeToRaw { .. } => {\n                     return false;\n                 }\n             }"}, {"sha": "8f026c706fdf7522b1aa3acbf427b5e8a9aac952", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -163,6 +163,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::EndRegion(_) |\n             mir::StatementKind::Retag { .. } |\n+            mir::StatementKind::EscapeToRaw { .. } |\n             mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => continue,\n             mir::StatementKind::SetDiscriminant{ .. } =>"}, {"sha": "68840ed4a480476ad0cb1e29a46b55d01cbd68c4", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -85,6 +85,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n             StatementKind::FakeRead(..) => \"StatementKind::FakeRead\",\n             StatementKind::EndRegion(..) => \"StatementKind::EndRegion\",\n             StatementKind::Retag { .. } => \"StatementKind::Retag\",\n+            StatementKind::EscapeToRaw { .. } => \"StatementKind::EscapeToRaw\",\n             StatementKind::SetDiscriminant { .. } => \"StatementKind::SetDiscriminant\",\n             StatementKind::StorageLive(..) => \"StatementKind::StorageLive\",\n             StatementKind::StorageDead(..) => \"StatementKind::StorageDead\","}, {"sha": "856e1063f60019fe1b6578601ecb44b789265170", "filename": "src/test/mir-opt/array-index-is-temporary.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Ftest%2Fmir-opt%2Farray-index-is-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Ftest%2Fmir-opt%2Farray-index-is-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Farray-index-is-temporary.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -0,0 +1,43 @@\n+// Retagging (from Stacked Borrows) relies on the array index being a fresh\n+// temporary, so that side-effects cannot change it.\n+// Test that this is indeed the case.\n+\n+unsafe fn foo(z: *mut usize) -> u32 {\n+    *z = 2;\n+    99\n+}\n+\n+fn main() {\n+    let mut x = [42, 43, 44];\n+    let mut y = 1;\n+    let z: *mut usize = &mut y;\n+    x[y] = unsafe { foo(z) };\n+}\n+\n+// END RUST SOURCE\n+// START rustc.main.EraseRegions.after.mir\n+//     bb0: {\n+//         ...\n+//         _6 = &mut _2;\n+//         _5 = &mut (*_6);\n+//         _4 = move _5 as *mut usize (Misc);\n+//         _3 = move _4;\n+//         ...\n+//         _8 = _3;\n+//         _7 = const foo(move _8) -> bb1;\n+//     }\n+//\n+//     bb1: {\n+//         ...\n+//         _9 = _2;\n+//         _10 = Len(_1);\n+//         _11 = Lt(_9, _10);\n+//         assert(move _11, \"index out of bounds: the len is move _10 but the index is _9\") -> bb2;\n+//     }\n+//\n+//     bb2: {\n+//         _1[_9] = move _7;\n+//         ...\n+//         return;\n+//     }\n+// END rustc.main.EraseRegions.after.mir"}, {"sha": "1e5e1ad5ed1c55fddb6c9e3ae8d72453cc6819cf", "filename": "src/test/mir-opt/inline-retag.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Ftest%2Fmir-opt%2Finline-retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Ftest%2Fmir-opt%2Finline-retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-retag.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -32,6 +32,8 @@ fn bar() -> bool {\n //     bb0: {\n //         ...\n //         Retag(_3);\n+//         ...\n+//         Retag(_3);\n //         Retag(_6);\n //         StorageLive(_9);\n //         _9 = (*_3);"}, {"sha": "7da55c0868cd2bf6d5a3611dd1482f706dc88ff4", "filename": "src/test/mir-opt/retag.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Ftest%2Fmir-opt%2Fretag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec0ba9545f7c848aafc0bc1b8762507395edd41/src%2Ftest%2Fmir-opt%2Fretag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.rs?ref=4ec0ba9545f7c848aafc0bc1b8762507395edd41", "patch": "@@ -26,7 +26,9 @@ fn main() {\n     {\n         let v = Test(0).foo(&mut x); // just making sure we do not panic when there is a tuple struct ctor\n         let w = { v }; // assignment\n-        let _w = w; // reborrow\n+        let w = w; // reborrow\n+        // escape-to-raw (mut)\n+        let _w = w as *mut _;\n     }\n \n     // Also test closures\n@@ -35,6 +37,9 @@ fn main() {\n \n     // need to call `foo_shr` or it doesn't even get generated\n     Test(0).foo_shr(&0);\n+\n+    // escape-to-raw (shr)\n+    let _w = _w as *const _;\n }\n \n // END RUST SOURCE\n@@ -44,6 +49,7 @@ fn main() {\n //         Retag([fn entry] _2);\n //         ...\n //         _0 = &mut (*_3);\n+//         Retag(_0);\n //         ...\n //         return;\n //     }\n@@ -73,23 +79,36 @@ fn main() {\n //         _9 = move _3;\n //         Retag(_9);\n //         _8 = &mut (*_9);\n+//         Retag(_8);\n //         StorageDead(_9);\n //         StorageLive(_10);\n //         _10 = move _8;\n //         Retag(_10);\n //         ...\n-//         _13 = move _14(move _15) -> bb2;\n+//         _14 = &mut (*_10);\n+//         Retag(_14);\n+//         EscapeToRaw(move _14);\n+//         _13 = move _14 as *mut i32 (Misc);\n+//         ...\n+//         _17 = move _18(move _19) -> bb2;\n //     }\n //\n //     bb2: {\n-//         Retag(_13);\n+//         Retag(_17);\n+//         ...\n+//         _21 = const Test::foo_shr(move _22, move _24) -> bb3;\n+//     }\n+//\n+//     bb3: {\n //         ...\n+//         return;\n //     }\n+//\n //     ...\n // }\n // END rustc.main.EraseRegions.after.mir\n // START rustc.main-{{closure}}.EraseRegions.after.mir\n-// fn main::{{closure}}(_1: &[closure@NodeId(117)], _2: &i32) -> &i32 {\n+// fn main::{{closure}}(_1: &[closure@NodeId(124)], _2: &i32) -> &i32 {\n //     ...\n //     bb0: {\n //         Retag([fn entry] _1);"}]}