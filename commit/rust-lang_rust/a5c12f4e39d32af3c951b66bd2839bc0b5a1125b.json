{"sha": "a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YzEyZjRlMzlkMzJhZjNjOTUxYjY2YmQyODM5YmMwYjVhMTEyNWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-26T10:39:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-26T10:39:18Z"}, "message": "Auto merge of #26870 - jroesch:default-typaram-fallback, r=nikomatsakis\n\nThis PR completes [RFC 213](https://github.com/rust-lang/rfcs/blob/master/text/0213-defaulted-type-params.md) by allowing default type parameters to influence inference. This is almost certainly a breaking change due to interactions between default type parameters and the old fallback algorithm used for integral and floating point literals.\r\n\r\nThe error messages still require polish but I wanted to get early review and feedback from others on the the changes, error messages, and test cases. I also imagine we will want to run anywhere from 1-3 versions of this on crater and evaluate the impact, and it would be best to get that ball rolling. \r\n\r\nThe only outstanding issue I'm aware of is that type alias defaults don't work. It seems this may require significant restructuring, since during inference type aliases have already been expanded. @nikomatsakis might be able to provide some clarity here.\r\n\r\nr? @nikomatsakis \r\n\r\ncc @eddyb @Gankro @aturon @brson", "tree": {"sha": "afb98f99301745cd34143473f2b43573f0100863", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afb98f99301745cd34143473f2b43573f0100863"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "html_url": "https://github.com/rust-lang/rust/commit/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a196aa173c7d08dc865c1814647b2c9f4d9f68a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a196aa173c7d08dc865c1814647b2c9f4d9f68a", "html_url": "https://github.com/rust-lang/rust/commit/9a196aa173c7d08dc865c1814647b2c9f4d9f68a"}, {"sha": "5ad36cb887dadc7fe564cfed1ccac52d009a59c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ad36cb887dadc7fe564cfed1ccac52d009a59c8", "html_url": "https://github.com/rust-lang/rust/commit/5ad36cb887dadc7fe564cfed1ccac52d009a59c8"}], "stats": {"total": 1066, "additions": 949, "deletions": 117}, "files": [{"sha": "59721edda707b391943255650a6f2e5bc97072d9", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -2368,6 +2368,8 @@ The currently implemented features of the reference compiler are:\n                               internally without imposing on callers\n                               (i.e. making them behave like function calls in\n                               terms of encapsulation).\n+* - `default_type_parameter_fallback` - Allows type parameter defaults to\n+                                        influence type inference.\n \n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled"}, {"sha": "10552791d8b86731d2098d9f03c0a37c3884a0fa", "filename": "src/librustc/ast_map/mod.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fast_map%2Fmod.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -119,6 +119,7 @@ pub enum Node<'ast> {\n     NodeStructCtor(&'ast StructDef),\n \n     NodeLifetime(&'ast Lifetime),\n+    NodeTyParam(&'ast TyParam)\n }\n \n /// Represents an entry and its parent NodeID.\n@@ -142,6 +143,7 @@ enum MapEntry<'ast> {\n     EntryBlock(NodeId, &'ast Block),\n     EntryStructCtor(NodeId, &'ast StructDef),\n     EntryLifetime(NodeId, &'ast Lifetime),\n+    EntryTyParam(NodeId, &'ast TyParam),\n \n     /// Roots for node trees.\n     RootCrate,\n@@ -175,7 +177,8 @@ impl<'ast> MapEntry<'ast> {\n             NodePat(n) => EntryPat(p, n),\n             NodeBlock(n) => EntryBlock(p, n),\n             NodeStructCtor(n) => EntryStructCtor(p, n),\n-            NodeLifetime(n) => EntryLifetime(p, n)\n+            NodeLifetime(n) => EntryLifetime(p, n),\n+            NodeTyParam(n) => EntryTyParam(p, n),\n         }\n     }\n \n@@ -194,6 +197,7 @@ impl<'ast> MapEntry<'ast> {\n             EntryBlock(id, _) => id,\n             EntryStructCtor(id, _) => id,\n             EntryLifetime(id, _) => id,\n+            EntryTyParam(id, _) => id,\n             _ => return None\n         })\n     }\n@@ -213,6 +217,7 @@ impl<'ast> MapEntry<'ast> {\n             EntryBlock(_, n) => NodeBlock(n),\n             EntryStructCtor(_, n) => NodeStructCtor(n),\n             EntryLifetime(_, n) => NodeLifetime(n),\n+            EntryTyParam(_, n) => NodeTyParam(n),\n             _ => return None\n         })\n     }\n@@ -573,6 +578,7 @@ impl<'ast> Map<'ast> {\n             Some(NodePat(pat)) => pat.span,\n             Some(NodeBlock(block)) => block.span,\n             Some(NodeStructCtor(_)) => self.expect_item(self.get_parent(id)).span,\n+            Some(NodeTyParam(ty_param)) => ty_param.span,\n             _ => return None,\n         };\n         Some(sp)\n@@ -815,6 +821,14 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.parent_node = parent_node;\n     }\n \n+    fn visit_generics(&mut self, generics: &'ast Generics) {\n+        for ty_param in generics.ty_params.iter() {\n+            self.insert(ty_param.id, NodeTyParam(ty_param));\n+        }\n+\n+        visit::walk_generics(self, generics);\n+    }\n+\n     fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n         let parent_node = self.parent_node;\n         self.parent_node = ti.id;\n@@ -1015,7 +1029,7 @@ impl<'a> NodePrinter for pprust::State<'a> {\n             NodePat(a)         => self.print_pat(&*a),\n             NodeBlock(a)       => self.print_block(&*a),\n             NodeLifetime(a)    => self.print_lifetime(&*a),\n-\n+            NodeTyParam(_)     => panic!(\"cannot print TyParam\"),\n             // these cases do not carry enough information in the\n             // ast_map to reconstruct their full structure for pretty\n             // printing.\n@@ -1123,6 +1137,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n             format!(\"lifetime {}{}\",\n                     pprust::lifetime_to_string(&**l), id_str)\n         }\n+        Some(NodeTyParam(ref ty_param)) => {\n+            format!(\"typaram {:?}{}\", ty_param, id_str)\n+        }\n         None => {\n             format!(\"unknown node{}\", id_str)\n         }"}, {"sha": "fb11aaed6195825b2ce9801207c46367b8bf2dbb", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -56,6 +56,7 @@\n #![feature(slice_splits)]\n #![feature(slice_patterns)]\n #![feature(slice_position_elem)]\n+#![feature(slice_concat_ext)]\n #![feature(staged_api)]\n #![feature(str_char)]\n #![feature(str_match_indices)]"}, {"sha": "54c55d76a8270215f1e76c1244938447dfde530c", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -833,6 +833,7 @@ fn parse_type_param_def_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n     assert_eq!(next(st), '|');\n     let index = parse_u32(st);\n     assert_eq!(next(st), '|');\n+    let default_def_id = parse_def_(st, NominalType, conv);\n     let default = parse_opt(st, |st| parse_ty_(st, conv));\n     let object_lifetime_default = parse_object_lifetime_default(st, conv);\n \n@@ -841,6 +842,7 @@ fn parse_type_param_def_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n         def_id: def_id,\n         space: space,\n         index: index,\n+        default_def_id: default_def_id,\n         default: default,\n         object_lifetime_default: object_lifetime_default,\n     }"}, {"sha": "597401daccfd22a2245ce6e562b4e6984cf17adb", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -409,9 +409,9 @@ pub fn enc_region_bounds<'a, 'tcx>(w: &mut Encoder,\n \n pub fn enc_type_param_def<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                                     v: &ty::TypeParameterDef<'tcx>) {\n-    mywrite!(w, \"{}:{}|{}|{}|\",\n+    mywrite!(w, \"{}:{}|{}|{}|{}|\",\n              token::get_name(v.name), (cx.ds)(v.def_id),\n-             v.space.to_uint(), v.index);\n+             v.space.to_uint(), v.index, (cx.ds)(v.default_def_id));\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n     enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n }"}, {"sha": "fbf19a10d93bf025deab497f004d342a9279c779", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -893,8 +893,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             self.report_inference_failure(vo.clone());\n         }\n         self.give_suggestion(same_regions);\n-        for &(ref trace, terr) in trace_origins {\n-            self.report_and_explain_type_error(trace.clone(), &terr);\n+        for &(ref trace, ref terr) in trace_origins {\n+            self.report_and_explain_type_error(trace.clone(), terr);\n         }\n     }\n "}, {"sha": "f63154af724260d2c13d899f490ee632d679dd35", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 119, "deletions": 8, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -653,6 +653,50 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Returns a type variable's default fallback if any exists. A default\n+    /// must be attached to the variable when created, if it is created\n+    /// without a default, this will return None.\n+    ///\n+    /// This code does not apply to integral or floating point variables,\n+    /// only to use declared defaults.\n+    ///\n+    /// See `new_ty_var_with_default` to create a type variable with a default.\n+    /// See `type_variable::Default` for details about what a default entails.\n+    pub fn default(&self, ty: Ty<'tcx>) -> Option<type_variable::Default<'tcx>> {\n+        match ty.sty {\n+            ty::TyInfer(ty::TyVar(vid)) => self.type_variables.borrow().default(vid),\n+            _ => None\n+        }\n+    }\n+\n+    pub fn unsolved_variables(&self) -> Vec<ty::Ty<'tcx>> {\n+        let mut variables = Vec::new();\n+\n+        let unbound_ty_vars = self.type_variables\n+                                  .borrow()\n+                                  .unsolved_variables()\n+                                  .into_iter()\n+                                  .map(|t| self.tcx.mk_var(t));\n+\n+        let unbound_int_vars = self.int_unification_table\n+                                   .borrow_mut()\n+                                   .unsolved_variables()\n+                                   .into_iter()\n+                                   .map(|v| self.tcx.mk_int_var(v));\n+\n+        let unbound_float_vars = self.float_unification_table\n+                                     .borrow_mut()\n+                                     .unsolved_variables()\n+                                     .into_iter()\n+                                     .map(|v| self.tcx.mk_float_var(v));\n+\n+        variables.extend(unbound_ty_vars);\n+        variables.extend(unbound_int_vars);\n+        variables.extend(unbound_float_vars);\n+\n+        return variables;\n+    }\n+\n     fn combine_fields(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n                       -> CombineFields<'a, 'tcx> {\n         CombineFields {infcx: self,\n@@ -956,13 +1000,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn next_ty_var_id(&self, diverging: bool) -> TyVid {\n         self.type_variables\n             .borrow_mut()\n-            .new_var(diverging)\n+            .new_var(diverging, None)\n     }\n \n     pub fn next_ty_var(&self) -> Ty<'tcx> {\n         self.tcx.mk_var(self.next_ty_var_id(false))\n     }\n \n+    pub fn next_ty_var_with_default(&self,\n+                                    default: Option<type_variable::Default<'tcx>>) -> Ty<'tcx> {\n+        let ty_var_id = self.type_variables\n+                            .borrow_mut()\n+                            .new_var(false, default);\n+\n+        self.tcx.mk_var(ty_var_id)\n+    }\n+\n     pub fn next_diverging_ty_var(&self) -> Ty<'tcx> {\n         self.tcx.mk_var(self.next_ty_var_id(true))\n     }\n@@ -996,20 +1049,55 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n+    // We have to take `&mut Substs` in order to provide the correct substitutions for defaults\n+    // along the way, for this reason we don't return them.\n+    pub fn type_vars_for_defs(&self,\n+                              span: Span,\n+                              space: subst::ParamSpace,\n+                              substs: &mut Substs<'tcx>,\n+                              defs: &[ty::TypeParameterDef<'tcx>]) {\n+\n+        let mut vars = Vec::with_capacity(defs.len());\n+\n+        for def in defs.iter() {\n+            let default = def.default.map(|default| {\n+                type_variable::Default {\n+                    ty: default.subst_spanned(self.tcx, substs, Some(span)),\n+                    origin_span: span,\n+                    def_id: def.default_def_id\n+                }\n+            });\n+\n+            let ty_var = self.next_ty_var_with_default(default);\n+            substs.types.push(space, ty_var);\n+            vars.push(ty_var)\n+        }\n+    }\n+\n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n     pub fn fresh_substs_for_generics(&self,\n                                      span: Span,\n                                      generics: &ty::Generics<'tcx>)\n                                      -> subst::Substs<'tcx>\n     {\n-        let type_params =\n-            generics.types.map(\n-                |_| self.next_ty_var());\n+        let type_params = subst::VecPerParamSpace::empty();\n+\n         let region_params =\n             generics.regions.map(\n                 |d| self.next_region_var(EarlyBoundRegion(span, d.name)));\n-        subst::Substs::new(type_params, region_params)\n+\n+        let mut substs = subst::Substs::new(type_params, region_params);\n+\n+        for space in subst::ParamSpace::all().iter() {\n+            self.type_vars_for_defs(\n+                span,\n+                *space,\n+                &mut substs,\n+                generics.types.get_slice(*space));\n+        }\n+\n+        return substs;\n     }\n \n     /// Given a set of generics defined on a trait, returns a substitution mapping each output\n@@ -1027,13 +1115,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         assert!(generics.regions.len(subst::SelfSpace) == 0);\n         assert!(generics.regions.len(subst::FnSpace) == 0);\n \n-        let type_parameter_count = generics.types.len(subst::TypeSpace);\n-        let type_parameters = self.next_ty_vars(type_parameter_count);\n+        let type_params = Vec::new();\n \n         let region_param_defs = generics.regions.get_slice(subst::TypeSpace);\n         let regions = self.region_vars_for_defs(span, region_param_defs);\n \n-        subst::Substs::new_trait(type_parameters, regions, self_ty)\n+        let mut substs = subst::Substs::new_trait(type_params, regions, self_ty);\n+\n+        let type_parameter_defs = generics.types.get_slice(subst::TypeSpace);\n+        self.type_vars_for_defs(span, subst::TypeSpace, &mut substs, type_parameter_defs);\n+\n+        return substs;\n     }\n \n     pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> ty::Region {\n@@ -1268,6 +1360,25 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.report_and_explain_type_error(trace, err);\n     }\n \n+    pub fn report_conflicting_default_types(&self,\n+                                            span: Span,\n+                                            expected: type_variable::Default<'tcx>,\n+                                            actual: type_variable::Default<'tcx>) {\n+        let trace = TypeTrace {\n+            origin: Misc(span),\n+            values: Types(ty::ExpectedFound {\n+                expected: expected.ty,\n+                found: actual.ty\n+            })\n+        };\n+\n+        self.report_and_explain_type_error(trace,\n+            &TypeError::TyParamDefaultMismatch(ty::ExpectedFound {\n+                expected: expected,\n+                found: actual\n+        }));\n+    }\n+\n     pub fn replace_late_bound_regions_with_fresh_var<T>(\n         &self,\n         span: Span,"}, {"sha": "3684651f85be6e0bbf6fadb95d109c60d31e2093", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 55, "deletions": 16, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -11,8 +11,10 @@\n pub use self::RelationDir::*;\n use self::TypeVariableValue::*;\n use self::UndoEntry::*;\n-\n use middle::ty::{self, Ty};\n+use syntax::ast::DefId;\n+use syntax::codemap::Span;\n+\n use std::cmp::min;\n use std::marker::PhantomData;\n use std::mem;\n@@ -30,16 +32,30 @@ struct TypeVariableData<'tcx> {\n \n enum TypeVariableValue<'tcx> {\n     Known(Ty<'tcx>),\n-    Bounded(Vec<Relation>),\n+    Bounded {\n+        relations: Vec<Relation>,\n+        default: Option<Default<'tcx>>\n+    }\n+}\n+\n+// We will use this to store the required information to recapitulate what happened when\n+// an error occurs.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Default<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    /// The span where the default was incurred\n+    pub origin_span: Span,\n+    /// The definition that the default originates from\n+    pub def_id: DefId\n }\n \n pub struct Snapshot {\n     snapshot: sv::Snapshot\n }\n \n-enum UndoEntry {\n+enum UndoEntry<'tcx> {\n     // The type of the var was specified.\n-    SpecifyVar(ty::TyVid, Vec<Relation>),\n+    SpecifyVar(ty::TyVid, Vec<Relation>, Option<Default<'tcx>>),\n     Relate(ty::TyVid, ty::TyVid),\n }\n \n@@ -72,6 +88,13 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         relations(self.values.get_mut(a.index as usize))\n     }\n \n+    pub fn default(&self, vid: ty::TyVid) -> Option<Default<'tcx>> {\n+        match &self.values.get(vid.index as usize).value {\n+            &Known(_) => None,\n+            &Bounded { ref default, .. } => default.clone()\n+        }\n+    }\n+\n     pub fn var_diverges<'a>(&'a self, vid: ty::TyVid) -> bool {\n         self.values.get(vid.index as usize).diverging\n     }\n@@ -101,8 +124,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             mem::replace(value_ptr, Known(ty))\n         };\n \n-        let relations = match old_value {\n-            Bounded(b) => b,\n+        let (relations, default) = match old_value {\n+            Bounded { relations, default } => (relations, default),\n             Known(_) => panic!(\"Asked to instantiate variable that is \\\n                                already instantiated\")\n         };\n@@ -111,20 +134,22 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             stack.push((ty, dir, vid));\n         }\n \n-        self.values.record(SpecifyVar(vid, relations));\n+        self.values.record(SpecifyVar(vid, relations, default));\n     }\n \n-    pub fn new_var(&mut self, diverging: bool) -> ty::TyVid {\n+    pub fn new_var(&mut self,\n+                   diverging: bool,\n+                   default: Option<Default<'tcx>>) -> ty::TyVid {\n         let index = self.values.push(TypeVariableData {\n-            value: Bounded(vec![]),\n+            value: Bounded { relations: vec![], default: default },\n             diverging: diverging\n         });\n         ty::TyVid { index: index as u32 }\n     }\n \n     pub fn probe(&self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n         match self.values.get(vid.index as usize).value {\n-            Bounded(..) => None,\n+            Bounded { .. } => None,\n             Known(t) => Some(t)\n         }\n     }\n@@ -179,7 +204,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                     debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n                 }\n \n-                sv::UndoLog::Other(SpecifyVar(vid, _)) => {\n+                sv::UndoLog::Other(SpecifyVar(vid, _, _)) => {\n                     if vid.index < new_elem_threshold {\n                         // quick check to see if this variable was\n                         // created since the snapshot started or not.\n@@ -195,16 +220,30 @@ impl<'tcx> TypeVariableTable<'tcx> {\n \n         escaping_types\n     }\n+\n+    pub fn unsolved_variables(&self) -> Vec<ty::TyVid> {\n+        self.values\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, value)| match &value.value {\n+                &TypeVariableValue::Known(_) => None,\n+                &TypeVariableValue::Bounded { .. } => Some(ty::TyVid { index: i as u32 })\n+            })\n+            .collect()\n+    }\n }\n \n impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n     type Value = TypeVariableData<'tcx>;\n-    type Undo = UndoEntry;\n+    type Undo = UndoEntry<'tcx>;\n \n-    fn reverse(values: &mut Vec<TypeVariableData<'tcx>>, action: UndoEntry) {\n+    fn reverse(values: &mut Vec<TypeVariableData<'tcx>>, action: UndoEntry<'tcx>) {\n         match action {\n-            SpecifyVar(vid, relations) => {\n-                values[vid.index as usize].value = Bounded(relations);\n+            SpecifyVar(vid, relations, default) => {\n+                values[vid.index as usize].value = Bounded {\n+                    relations: relations,\n+                    default: default\n+                };\n             }\n \n             Relate(a, b) => {\n@@ -218,6 +257,6 @@ impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n fn relations<'a>(v: &'a mut TypeVariableData) -> &'a mut Vec<Relation> {\n     match v.value {\n         Known(_) => panic!(\"var_sub_var: variable is known\"),\n-        Bounded(ref mut relations) => relations\n+        Bounded { ref mut relations, .. } => relations\n     }\n }"}, {"sha": "7d8a20c42e36ecf2800793c5baec0d9c30485574", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -154,7 +154,7 @@ impl<'tcx> Substs<'tcx> {\n }\n \n impl RegionSubsts {\n-    fn map<F>(self, op: F) -> RegionSubsts where\n+    pub fn map<F>(self, op: F) -> RegionSubsts where\n         F: FnOnce(VecPerParamSpace<ty::Region>) -> VecPerParamSpace<ty::Region>,\n     {\n         match self {"}, {"sha": "ea5ca8acb094fbf829078b2d1de69e9ae027edd3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 61, "deletions": 4, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -54,6 +54,7 @@ use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangIte\n use middle::region;\n use middle::resolve_lifetime;\n use middle::infer;\n+use middle::infer::type_variable;\n use middle::pat_util;\n use middle::region::RegionMaps;\n use middle::stability;\n@@ -78,6 +79,7 @@ use std::ops;\n use std::rc::Rc;\n use std::vec::IntoIter;\n use collections::enum_set::{self, EnumSet, CLike};\n+use collections::slice::SliceConcatExt;\n use std::collections::{HashMap, HashSet};\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, ItemImpl, ItemTrait, LOCAL_CRATE};\n@@ -114,8 +116,6 @@ pub struct Field<'tcx> {\n     pub mt: TypeAndMut<'tcx>\n }\n \n-\n-\n // Enum information\n #[derive(Clone)]\n pub struct VariantInfo<'tcx> {\n@@ -2038,7 +2038,7 @@ pub struct ExpectedFound<T> {\n }\n \n // Data structures used in type unification\n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Debug)]\n pub enum TypeError<'tcx> {\n     Mismatch,\n     UnsafetyMismatch(ExpectedFound<ast::Unsafety>),\n@@ -2068,6 +2068,7 @@ pub enum TypeError<'tcx> {\n     ConvergenceMismatch(ExpectedFound<bool>),\n     ProjectionNameMismatched(ExpectedFound<ast::Name>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n+    TyParamDefaultMismatch(ExpectedFound<type_variable::Default<'tcx>>)\n }\n \n /// Bounds suitable for an existentially quantified type parameter\n@@ -2280,6 +2281,7 @@ pub struct TypeParameterDef<'tcx> {\n     pub def_id: ast::DefId,\n     pub space: subst::ParamSpace,\n     pub index: u32,\n+    pub default_def_id: DefId, // for use in error reporing about defaults\n     pub default: Option<Ty<'tcx>>,\n     pub object_lifetime_default: ObjectLifetimeDefault,\n }\n@@ -5080,6 +5082,11 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                 write!(f, \"expected {} associated type bindings, found {}\",\n                        values.expected,\n                        values.found)\n+            },\n+            TyParamDefaultMismatch(ref values) => {\n+                write!(f, \"conflicting type parameter defaults `{}` and `{}`\",\n+                       values.expected.ty,\n+                       values.found.ty)\n             }\n         }\n     }\n@@ -5399,7 +5406,7 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn note_and_explain_type_err(&self, err: &TypeError<'tcx>, sp: Span) {\n         use self::TypeError::*;\n \n-        match *err {\n+        match err.clone() {\n             RegionsDoesNotOutlive(subregion, superregion) => {\n                 self.note_and_explain_region(\"\", subregion, \"...\");\n                 self.note_and_explain_region(\"...does not necessarily outlive \",\n@@ -5437,6 +5444,56 @@ impl<'tcx> ctxt<'tcx> {\n                         &format!(\"consider boxing your closure and/or \\\n                                   using it as a trait object\"));\n                 }\n+            },\n+            TyParamDefaultMismatch(values) => {\n+                let expected = values.expected;\n+                let found = values.found;\n+                self.sess.span_note(sp,\n+                                    &format!(\"conflicting type parameter defaults `{}` and `{}`\",\n+                                             expected.ty,\n+                                             found.ty));\n+\n+                match (expected.def_id.krate == ast::LOCAL_CRATE,\n+                       self.map.opt_span(expected.def_id.node)) {\n+                    (true, Some(span)) => {\n+                        self.sess.span_note(span,\n+                                            &format!(\"a default was defined here...\"));\n+                    }\n+                    (_, _) => {\n+                        let elems = csearch::get_item_path(self, expected.def_id)\n+                                        .into_iter()\n+                                        .map(|p| p.to_string())\n+                                        .collect::<Vec<_>>();\n+                        self.sess.note(\n+                            &format!(\"a default is defined on `{}`\",\n+                                     elems.join(\"::\")));\n+                    }\n+                }\n+\n+                self.sess.span_note(\n+                    expected.origin_span,\n+                    &format!(\"...that was applied to an unconstrained type variable here\"));\n+\n+                match (found.def_id.krate == ast::LOCAL_CRATE,\n+                       self.map.opt_span(found.def_id.node)) {\n+                    (true, Some(span)) => {\n+                        self.sess.span_note(span,\n+                                            &format!(\"a second default was defined here...\"));\n+                    }\n+                    (_, _) => {\n+                        let elems = csearch::get_item_path(self, found.def_id)\n+                                        .into_iter()\n+                                        .map(|p| p.to_string())\n+                                        .collect::<Vec<_>>();\n+\n+                        self.sess.note(\n+                            &format!(\"a second default is defined on `{}`\", elems.join(\" \")));\n+                    }\n+                }\n+\n+                self.sess.span_note(\n+                    found.origin_span,\n+                    &format!(\"...that also applies to the same type variable here\"));\n             }\n             _ => {}\n         }"}, {"sha": "0c694926ba4b5a829e2c775fadaac7be73924e8e", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -340,6 +340,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n             space: self.space,\n             index: self.index,\n             default: self.default.fold_with(folder),\n+            default_def_id: self.default_def_id,\n             object_lifetime_default: self.object_lifetime_default.fold_with(folder),\n         }\n     }"}, {"sha": "7582b7ff61d8830c66b525a9ce6bb654754c5d3c", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -339,5 +339,11 @@ impl<'tcx,K,V> UnificationTable<K>\n     pub fn probe(&mut self, a_id: K) -> Option<V> {\n         self.get(a_id).value.clone()\n     }\n-}\n \n+    pub fn unsolved_variables(&mut self) -> Vec<K> {\n+        self.values\n+            .iter()\n+            .filter_map(|vv| if vv.value.is_some() { None } else { Some(vv.key()) })\n+            .collect()\n+    }\n+}"}, {"sha": "31e4b9c48e20b84dfecab3497676fa91bece31d1", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -266,6 +266,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Ugh -- but this ensures any new variants won't be forgotten\n         ast_map::NodeForeignItem(..) |\n         ast_map::NodeLifetime(..) |\n+        ast_map::NodeTyParam(..) |\n         ast_map::NodeExpr(..) |\n         ast_map::NodeStmt(..) |\n         ast_map::NodeArg(..) |"}, {"sha": "332b84bfc7bfd810fc71bf5857beca4ed8f23b8c", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -55,7 +55,7 @@ use middle::def;\n use middle::implicator::object_region_bounds;\n use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n-use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n+use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs, ParamSpace};\n use middle::traits;\n use middle::ty::{self, RegionEscape, Ty, ToPredicate, HasTypeFlags};\n use middle::ty_fold;\n@@ -111,7 +111,11 @@ pub trait AstConv<'tcx> {\n     }\n \n     /// What type should we use when a type is omitted?\n-    fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n+        fn ty_infer(&self,\n+                    param_and_substs: Option<ty::TypeParameterDef<'tcx>>,\n+                    substs: Option<&mut Substs<'tcx>>,\n+                    space: Option<ParamSpace>,\n+                    span: Span) -> Ty<'tcx>;\n \n     /// Projecting an associated type from a (potentially)\n     /// higher-ranked trait reference is more complicated, because of\n@@ -403,7 +407,11 @@ fn create_substs_for_ast_path<'tcx>(\n     // they were optional (e.g. paths inside expressions).\n     let mut type_substs = if param_mode == PathParamMode::Optional &&\n                              types_provided.is_empty() {\n-        (0..formal_ty_param_count).map(|_| this.ty_infer(span)).collect()\n+        let mut substs = region_substs.clone();\n+        ty_param_defs\n+            .iter()\n+            .map(|p| this.ty_infer(Some(p.clone()), Some(&mut substs), Some(TypeSpace), span))\n+            .collect()\n     } else {\n         types_provided\n     };\n@@ -1654,7 +1662,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             // values in a ExprClosure, or as\n             // the type of local variables. Both of these cases are\n             // handled specially and will not descend into this routine.\n-            this.ty_infer(ast_ty.span)\n+            this.ty_infer(None, None, None, ast_ty.span)\n         }\n     };\n \n@@ -1670,7 +1678,7 @@ pub fn ty_of_arg<'tcx>(this: &AstConv<'tcx>,\n {\n     match a.ty.node {\n         ast::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n-        ast::TyInfer => this.ty_infer(a.ty.span),\n+        ast::TyInfer => this.ty_infer(None, None, None, a.ty.span),\n         _ => ast_ty_to_ty(this, rscope, &*a.ty),\n     }\n }\n@@ -1789,7 +1797,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n \n     let output_ty = match decl.output {\n         ast::Return(ref output) if output.node == ast::TyInfer =>\n-            ty::FnConverging(this.ty_infer(output.span)),\n+            ty::FnConverging(this.ty_infer(None, None, None, output.span)),\n         ast::Return(ref output) =>\n             ty::FnConverging(convert_ty_with_lifetime_elision(this,\n                                                               implied_output_region,\n@@ -1929,7 +1937,7 @@ pub fn ty_of_closure<'tcx>(\n         _ if is_infer && expected_ret_ty.is_some() =>\n             expected_ret_ty.unwrap(),\n         _ if is_infer =>\n-            ty::FnConverging(this.ty_infer(decl.output.span())),\n+            ty::FnConverging(this.ty_infer(None, None, None, decl.output.span())),\n         ast::Return(ref output) =>\n             ty::FnConverging(ast_ty_to_ty(this, &rb, &**output)),\n         ast::DefaultReturn(..) => unreachable!(),"}, {"sha": "e9869e2a00e5d7908aea83fa80e5750bba78cbf1", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 42, "deletions": 23, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -84,9 +84,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // Create substitutions for the method's type parameters.\n         let rcvr_substs = self.fresh_receiver_substs(self_ty, &pick);\n-        let (method_types, method_regions) =\n-            self.instantiate_method_substs(&pick, supplied_method_types);\n-        let all_substs = rcvr_substs.with_method(method_types, method_regions);\n+        let all_substs =\n+            self.instantiate_method_substs(\n+                &pick,\n+                supplied_method_types,\n+                rcvr_substs);\n+\n         debug!(\"all_substs={:?}\", all_substs);\n \n         // Create the final signature for the method, replacing late-bound regions.\n@@ -302,30 +305,18 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n     fn instantiate_method_substs(&mut self,\n                                  pick: &probe::Pick<'tcx>,\n-                                 supplied_method_types: Vec<Ty<'tcx>>)\n-                                 -> (Vec<Ty<'tcx>>, Vec<ty::Region>)\n+                                 supplied_method_types: Vec<Ty<'tcx>>,\n+                                 substs: subst::Substs<'tcx>)\n+                                 -> subst::Substs<'tcx>\n     {\n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let num_supplied_types = supplied_method_types.len();\n-        let num_method_types = pick.item.as_opt_method().unwrap()\n-                                   .generics.types.len(subst::FnSpace);\n-        let method_types = {\n-            if num_supplied_types == 0 {\n-                self.fcx.infcx().next_ty_vars(num_method_types)\n-            } else if num_method_types == 0 {\n-                span_err!(self.tcx().sess, self.span, E0035,\n-                    \"does not take type parameters\");\n-                self.fcx.infcx().next_ty_vars(num_method_types)\n-            } else if num_supplied_types != num_method_types {\n-                span_err!(self.tcx().sess, self.span, E0036,\n-                    \"incorrect number of type parameters given for this method\");\n-                vec![self.tcx().types.err; num_method_types]\n-            } else {\n-                supplied_method_types\n-            }\n-        };\n+        let method = pick.item.as_opt_method().unwrap();\n+        let method_types = method.generics.types.get_slice(subst::FnSpace);\n+        let num_method_types = method_types.len();\n+\n \n         // Create subst for early-bound lifetime parameters, combining\n         // parameters from the type and those from the method.\n@@ -337,7 +328,35 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 pick.item.as_opt_method().unwrap()\n                     .generics.regions.get_slice(subst::FnSpace));\n \n-        (method_types, method_regions)\n+        let subst::Substs { types, regions } = substs;\n+        let regions = regions.map(|r| r.with_vec(subst::FnSpace, method_regions));\n+        let mut final_substs = subst::Substs { types: types, regions: regions };\n+\n+        if num_supplied_types == 0 {\n+            self.fcx.infcx().type_vars_for_defs(\n+                self.span,\n+                subst::FnSpace,\n+                &mut final_substs,\n+                method_types);\n+        } else if num_method_types == 0 {\n+            span_err!(self.tcx().sess, self.span, E0035,\n+                \"does not take type parameters\");\n+            self.fcx.infcx().type_vars_for_defs(\n+                self.span,\n+                subst::FnSpace,\n+                &mut final_substs,\n+                method_types);\n+        } else if num_supplied_types != num_method_types {\n+            span_err!(self.tcx().sess, self.span, E0036,\n+                \"incorrect number of type parameters given for this method\");\n+            final_substs.types.replace(\n+                subst::FnSpace,\n+                vec![self.tcx().types.err; num_method_types]);\n+        } else {\n+            final_substs.types.replace(subst::FnSpace, supplied_method_types);\n+        }\n+\n+        return final_substs;\n     }\n \n     fn unify_receivers(&mut self,"}, {"sha": "e3f55cca9ee514960fa598e2e794529da8fb9bfd", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -167,23 +167,30 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     let trait_def = fcx.tcx().lookup_trait_def(trait_def_id);\n \n-    let expected_number_of_input_types = trait_def.generics.types.len(subst::TypeSpace);\n-    let input_types = match opt_input_types {\n+    let type_parameter_defs = trait_def.generics.types.get_slice(subst::TypeSpace);\n+    let expected_number_of_input_types = type_parameter_defs.len();\n+\n+    assert_eq!(trait_def.generics.types.len(subst::FnSpace), 0);\n+    assert!(trait_def.generics.regions.is_empty());\n+\n+    // Construct a trait-reference `self_ty : Trait<input_tys>`\n+    let mut substs = subst::Substs::new_trait(Vec::new(), Vec::new(), self_ty);\n+\n+    match opt_input_types {\n         Some(input_types) => {\n             assert_eq!(expected_number_of_input_types, input_types.len());\n-            input_types\n+            substs.types.replace(subst::ParamSpace::TypeSpace, input_types);\n         }\n \n         None => {\n-            fcx.inh.infcx.next_ty_vars(expected_number_of_input_types)\n+            fcx.inh.infcx.type_vars_for_defs(\n+                span,\n+                subst::ParamSpace::TypeSpace,\n+                &mut substs,\n+                type_parameter_defs);\n         }\n-    };\n-\n-    assert_eq!(trait_def.generics.types.len(subst::FnSpace), 0);\n-    assert!(trait_def.generics.regions.is_empty());\n+    }\n \n-    // Construct a trait-reference `self_ty : Trait<input_tys>`\n-    let substs = subst::Substs::new_trait(input_types, Vec::new(), self_ty);\n     let trait_ref = ty::TraitRef::new(trait_def_id, fcx.tcx().mk_substs(substs));\n \n     // Construct an obligation"}, {"sha": "44d769a799f1d6db17f8801078eadafcdd345fa3", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -1200,16 +1200,12 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return impl_ty;\n         }\n \n-        let placeholder;\n+        let mut placeholder;\n         let mut substs = substs;\n         if\n             !method.generics.types.is_empty_in(subst::FnSpace) ||\n             !method.generics.regions.is_empty_in(subst::FnSpace)\n         {\n-            let method_types =\n-                self.infcx().next_ty_vars(\n-                    method.generics.types.len(subst::FnSpace));\n-\n             // In general, during probe we erase regions. See\n             // `impl_self_ty()` for an explanation.\n             let method_regions =\n@@ -1218,7 +1214,14 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 .map(|_| ty::ReStatic)\n                 .collect();\n \n-            placeholder = (*substs).clone().with_method(method_types, method_regions);\n+            placeholder = (*substs).clone().with_method(Vec::new(), method_regions);\n+\n+            self.infcx().type_vars_for_defs(\n+                self.span,\n+                subst::FnSpace,\n+                &mut placeholder,\n+                method.generics.types.get_slice(subst::FnSpace));\n+\n             substs = &placeholder;\n         }\n "}, {"sha": "85df5d67ff6eb0e43e4d20b64723e662bbc3dfc7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 282, "deletions": 31, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -87,6 +87,7 @@ use fmt_macros::{Parser, Piece, Position};\n use middle::astconv_util::{check_path_args, NO_TPS, NO_REGIONS};\n use middle::def;\n use middle::infer;\n+use middle::infer::type_variable;\n use middle::pat_util::{self, pat_id_map};\n use middle::privacy::{AllPublic, LastMod};\n use middle::region::{self, CodeExtent};\n@@ -108,6 +109,7 @@ use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use util::lev_distance::lev_distance;\n \n use std::cell::{Cell, Ref, RefCell};\n+use std::collections::HashSet;\n use std::mem::replace;\n use std::slice;\n use syntax::{self, abi, attr};\n@@ -1137,8 +1139,27 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         trait_def.associated_type_names.contains(&assoc_name)\n     }\n \n-    fn ty_infer(&self, _span: Span) -> Ty<'tcx> {\n-        self.infcx().next_ty_var()\n+    fn ty_infer(&self,\n+                ty_param_def: Option<ty::TypeParameterDef<'tcx>>,\n+                substs: Option<&mut subst::Substs<'tcx>>,\n+                space: Option<subst::ParamSpace>,\n+                span: Span) -> Ty<'tcx> {\n+        // Grab the default doing subsitution\n+        let default = ty_param_def.and_then(|def| {\n+            def.default.map(|ty| type_variable::Default {\n+                ty: ty.subst_spanned(self.tcx(), substs.as_ref().unwrap(), Some(span)),\n+                origin_span: span,\n+                def_id: def.default_def_id\n+            })\n+        });\n+\n+        let ty_var = self.infcx().next_ty_var_with_default(default);\n+\n+        // Finally we add the type variable to the substs\n+        match substs {\n+            None => ty_var,\n+            Some(substs) => { substs.types.push(space.unwrap(), ty_var); ty_var }\n+        }\n     }\n \n     fn projected_ty_from_poly_trait_ref(&self,\n@@ -1255,28 +1276,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Apply \"fallbacks\" to some types\n-    /// ! gets replaced with (), unconstrained ints with i32, and unconstrained floats with f64.\n-    pub fn default_type_parameters(&self) {\n-        use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n-        for (_, &mut ref ty) in &mut self.inh.tables.borrow_mut().node_types {\n-            let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n-            if self.infcx().type_var_diverges(resolved) {\n-                demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n-            } else {\n-                match self.infcx().type_is_unconstrained_numeric(resolved) {\n-                    UnconstrainedInt => {\n-                        demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n-                    },\n-                    UnconstrainedFloat => {\n-                        demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n-                    }\n-                    Neither => { }\n-                }\n-            }\n-        }\n-    }\n-\n     #[inline]\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n@@ -1710,14 +1709,260 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Apply \"fallbacks\" to some types\n+    /// ! gets replaced with (), unconstrained ints with i32, and unconstrained floats with f64.\n+    fn default_type_parameters(&self) {\n+        use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n+        for ty in &self.infcx().unsolved_variables() {\n+            let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n+            if self.infcx().type_var_diverges(resolved) {\n+                demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n+            } else {\n+                match self.infcx().type_is_unconstrained_numeric(resolved) {\n+                    UnconstrainedInt => {\n+                        demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n+                    },\n+                    UnconstrainedFloat => {\n+                        demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n+                    }\n+                    Neither => { }\n+                }\n+            }\n+        }\n+    }\n+\n     fn select_all_obligations_and_apply_defaults(&self) {\n-        debug!(\"select_all_obligations_and_apply_defaults\");\n+        if self.tcx().sess.features.borrow().default_type_parameter_fallback {\n+            self.new_select_all_obligations_and_apply_defaults();\n+        } else {\n+            self.old_select_all_obligations_and_apply_defaults();\n+        }\n+    }\n \n+    // Implements old type inference fallback algorithm\n+    fn old_select_all_obligations_and_apply_defaults(&self) {\n         self.select_obligations_where_possible();\n         self.default_type_parameters();\n         self.select_obligations_where_possible();\n     }\n \n+    fn new_select_all_obligations_and_apply_defaults(&self) {\n+        use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n+\n+            // For the time being this errs on the side of being memory wasteful but provides better\n+        // error reporting.\n+        // let type_variables = self.infcx().type_variables.clone();\n+\n+        // There is a possibility that this algorithm will have to run an arbitrary number of times\n+        // to terminate so we bound it by the compiler's recursion limit.\n+        for _ in (0..self.tcx().sess.recursion_limit.get()) {\n+            // First we try to solve all obligations, it is possible that the last iteration\n+            // has made it possible to make more progress.\n+            self.select_obligations_where_possible();\n+\n+            let mut conflicts = Vec::new();\n+\n+            // Collect all unsolved type, integral and floating point variables.\n+            let unsolved_variables = self.inh.infcx.unsolved_variables();\n+\n+            // We must collect the defaults *before* we do any unification. Because we have\n+            // directly attached defaults to the type variables any unification that occurs\n+            // will erase defaults causing conflicting defaults to be completely ignored.\n+            let default_map: FnvHashMap<_, _> =\n+                unsolved_variables\n+                    .iter()\n+                    .filter_map(|t| self.infcx().default(t).map(|d| (t, d)))\n+                    .collect();\n+\n+            let mut unbound_tyvars = HashSet::new();\n+\n+            debug!(\"select_all_obligations_and_apply_defaults: defaults={:?}\", default_map);\n+\n+            // We loop over the unsolved variables, resolving them and if they are\n+            // and unconstrainted numberic type we add them to the set of unbound\n+            // variables. We do this so we only apply literal fallback to type\n+            // variables without defaults.\n+            for ty in &unsolved_variables {\n+                let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n+                if self.infcx().type_var_diverges(resolved) {\n+                    demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n+                } else {\n+                    match self.infcx().type_is_unconstrained_numeric(resolved) {\n+                        UnconstrainedInt | UnconstrainedFloat => {\n+                            unbound_tyvars.insert(resolved);\n+                        },\n+                        Neither => {}\n+                    }\n+                }\n+            }\n+\n+            // We now remove any numeric types that also have defaults, and instead insert\n+            // the type variable with a defined fallback.\n+            for ty in &unsolved_variables {\n+                if let Some(_default) = default_map.get(ty) {\n+                    let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n+\n+                    debug!(\"select_all_obligations_and_apply_defaults: ty: {:?} with default: {:?}\",\n+                             ty, _default);\n+\n+                    match resolved.sty {\n+                        ty::TyInfer(ty::TyVar(_)) => {\n+                            unbound_tyvars.insert(ty);\n+                        }\n+\n+                        ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) => {\n+                            unbound_tyvars.insert(ty);\n+                            if unbound_tyvars.contains(resolved) {\n+                                unbound_tyvars.remove(resolved);\n+                            }\n+                        }\n+\n+                        _ => {}\n+                    }\n+                }\n+            }\n+\n+            // If there are no more fallbacks to apply at this point we have applied all possible\n+            // defaults and type inference will procede as normal.\n+            if unbound_tyvars.is_empty() {\n+                break;\n+            }\n+\n+            // Finally we go through each of the unbound type variables and unify them with\n+            // the proper fallback, reporting a conflicting default error if any of the\n+            // unifications fail. We know it must be a conflicting default because the\n+            // variable would only be in `unbound_tyvars` and have a concrete value if\n+            // it had been solved by previously applying a default.\n+\n+            // We wrap this in a transaction for error reporting, if we detect a conflict\n+            // we will rollback the inference context to its prior state so we can probe\n+            // for conflicts and correctly report them.\n+\n+\n+            let _ = self.infcx().commit_if_ok(|_: &infer::CombinedSnapshot| {\n+                for ty in &unbound_tyvars {\n+                    if self.infcx().type_var_diverges(ty) {\n+                        demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n+                    } else {\n+                        match self.infcx().type_is_unconstrained_numeric(ty) {\n+                            UnconstrainedInt => {\n+                                demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n+                            },\n+                            UnconstrainedFloat => {\n+                                demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n+                            }\n+                            Neither => {\n+                                if let Some(default) = default_map.get(ty) {\n+                                    let default = default.clone();\n+                                    match infer::mk_eqty(self.infcx(), false,\n+                                                         infer::Misc(default.origin_span),\n+                                                         ty, default.ty) {\n+                                        Ok(()) => {}\n+                                        Err(_) => {\n+                                            conflicts.push((*ty, default));\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // If there are conflicts we rollback, otherwise commit\n+                if conflicts.len() > 0 {\n+                    Err(())\n+                } else {\n+                    Ok(())\n+                }\n+            });\n+\n+            if conflicts.len() > 0 {\n+                // Loop through each conflicting default, figuring out the default that caused\n+                // a unification failure and then report an error for each.\n+                for (conflict, default) in conflicts {\n+                    let conflicting_default =\n+                        self.find_conflicting_default(&unbound_tyvars, &default_map, conflict)\n+                            .unwrap_or(type_variable::Default {\n+                                ty: self.infcx().next_ty_var(),\n+                                origin_span: codemap::DUMMY_SP,\n+                                def_id: local_def(0) // what do I put here?\n+                            });\n+\n+                    // This is to ensure that we elimnate any non-determinism from the error\n+                    // reporting by fixing an order, it doesn't matter what order we choose\n+                    // just that it is consistent.\n+                    let (first_default, second_default) =\n+                        if default.def_id < conflicting_default.def_id {\n+                            (default, conflicting_default)\n+                        } else {\n+                            (conflicting_default, default)\n+                        };\n+\n+\n+                    self.infcx().report_conflicting_default_types(\n+                        first_default.origin_span,\n+                        first_default,\n+                        second_default)\n+                }\n+            }\n+        }\n+\n+        self.select_obligations_where_possible();\n+    }\n+\n+    // For use in error handling related to default type parameter fallback. We explicitly\n+    // apply the default that caused conflict first to a local version of the type variable\n+    // table then apply defaults until we find a conflict. That default must be the one\n+    // that caused conflict earlier.\n+    fn find_conflicting_default(&self,\n+                                unbound_vars: &HashSet<Ty<'tcx>>,\n+                                default_map: &FnvHashMap<&Ty<'tcx>, type_variable::Default<'tcx>>,\n+                                conflict: Ty<'tcx>)\n+                                -> Option<type_variable::Default<'tcx>> {\n+        use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n+\n+        // Ensure that we apply the conflicting default first\n+        let mut unbound_tyvars = Vec::with_capacity(unbound_vars.len() + 1);\n+        unbound_tyvars.push(conflict);\n+        unbound_tyvars.extend(unbound_vars.iter());\n+\n+        let mut result = None;\n+        // We run the same code as above applying defaults in order, this time when\n+        // we find the conflict we just return it for error reporting above.\n+\n+        // We also run this inside snapshot that never commits so we can do error\n+        // reporting for more then one conflict.\n+        for ty in &unbound_tyvars {\n+            if self.infcx().type_var_diverges(ty) {\n+                demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n+            } else {\n+                match self.infcx().type_is_unconstrained_numeric(ty) {\n+                    UnconstrainedInt => {\n+                        demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n+                    },\n+                    UnconstrainedFloat => {\n+                        demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n+                    },\n+                    Neither => {\n+                        if let Some(default) = default_map.get(ty) {\n+                            let default = default.clone();\n+                            match infer::mk_eqty(self.infcx(), false,\n+                                                 infer::Misc(default.origin_span),\n+                                                 ty, default.ty) {\n+                                Ok(()) => {}\n+                                Err(_) => {\n+                                    result = Some(default);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n     fn select_all_obligations_or_error(&self) {\n         debug!(\"select_all_obligations_or_error\");\n \n@@ -1726,6 +1971,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         assert!(self.inh.deferred_call_resolutions.borrow().is_empty());\n \n         self.select_all_obligations_and_apply_defaults();\n+\n         let mut fulfillment_cx = self.inh.infcx.fulfillment_cx.borrow_mut();\n         match fulfillment_cx.select_all_or_error(self.infcx()) {\n             Ok(()) => { }\n@@ -2421,14 +2667,18 @@ pub fn impl_self_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let tcx = fcx.tcx();\n \n     let ity = tcx.lookup_item_type(did);\n-    let (n_tps, rps, raw_ty) =\n-        (ity.generics.types.len(subst::TypeSpace),\n+    let (tps, rps, raw_ty) =\n+        (ity.generics.types.get_slice(subst::TypeSpace),\n          ity.generics.regions.get_slice(subst::TypeSpace),\n          ity.ty);\n \n+    debug!(\"impl_self_ty: tps={:?} rps={:?} raw_ty={:?}\", tps, rps, raw_ty);\n+\n     let rps = fcx.inh.infcx.region_vars_for_defs(span, rps);\n-    let tps = fcx.inh.infcx.next_ty_vars(n_tps);\n-    let substs = subst::Substs::new_type(tps, rps);\n+    let mut substs = subst::Substs::new(\n+        VecPerParamSpace::empty(),\n+        VecPerParamSpace::new(rps, Vec::new(), Vec::new()));\n+    fcx.inh.infcx.type_vars_for_defs(span, ParamSpace::TypeSpace, &mut substs, tps);\n     let substd_ty = fcx.instantiate_type_scheme(span, &substs, &raw_ty);\n \n     TypeAndSubsts { substs: substs, ty: substd_ty }\n@@ -4434,7 +4684,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // variables. If the user provided some types, we may still need\n     // to add defaults. If the user provided *too many* types, that's\n     // a problem.\n-    for &space in &ParamSpace::all() {\n+    for &space in &[subst::SelfSpace, subst::TypeSpace, subst::FnSpace] {\n         adjust_type_parameters(fcx, span, space, type_defs,\n                                require_type_space, &mut substs);\n         assert_eq!(substs.types.len(space), type_defs.len(space));\n@@ -4647,7 +4897,8 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // Nothing specified at all: supply inference variables for\n         // everything.\n         if provided_len == 0 && !(require_type_space && space == subst::TypeSpace) {\n-            substs.types.replace(space, fcx.infcx().next_ty_vars(desired.len()));\n+            substs.types.replace(space, Vec::new());\n+            fcx.infcx().type_vars_for_defs(span, space, substs, &desired[..]);\n             return;\n         }\n "}, {"sha": "00537f66bbceee36e783e5b32b1c71e3d58466a7", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -404,7 +404,11 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n+        fn ty_infer(&self,\n+                    _ty_param_def: Option<ty::TypeParameterDef<'tcx>>,\n+                    _substs: Option<&mut Substs<'tcx>>,\n+                    _space: Option<ParamSpace>,\n+                    span: Span) -> Ty<'tcx> {\n         span_err!(self.tcx().sess, span, E0121,\n                   \"the type placeholder `_` is not allowed within types on item signatures\");\n         self.tcx().types.err\n@@ -1643,11 +1647,14 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // the node id for the Self type parameter.\n     let param_id = trait_id;\n \n+    let parent = ccx.tcx.map.get_parent(param_id);\n+\n     let def = ty::TypeParameterDef {\n         space: SelfSpace,\n         index: 0,\n         name: special_idents::type_self.name,\n         def_id: local_def(param_id),\n+        default_def_id: local_def(parent),\n         default: None,\n         object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n     };\n@@ -1916,11 +1923,14 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         compute_object_lifetime_default(ccx, param.id,\n                                         &param.bounds, &ast_generics.where_clause);\n \n+    let parent = tcx.map.get_parent(param.id);\n+\n     let def = ty::TypeParameterDef {\n         space: space,\n         index: index,\n         name: param.ident.name,\n         def_id: local_def(param.id),\n+        default_def_id: local_def(parent),\n         default: default,\n         object_lifetime_default: object_lifetime_default,\n     };"}, {"sha": "c3338f02ee43ca828f39746688215b9b7395215d", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -163,6 +163,8 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n \n     // Allows the definition recursive static items.\n     (\"static_recursion\", \"1.3.0\", Active),\n+// Allows default type parameters to influence type inference.\n+    (\"default_type_parameter_fallback\", \"1.3.0\", Active)\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -341,7 +343,8 @@ pub struct Features {\n     /// #![feature] attrs for non-language (library) features\n     pub declared_lib_features: Vec<(InternedString, Span)>,\n     pub const_fn: bool,\n-    pub static_recursion: bool\n+    pub static_recursion: bool,\n+    pub default_type_parameter_fallback: bool,\n }\n \n impl Features {\n@@ -366,7 +369,8 @@ impl Features {\n             declared_stable_lang_features: Vec::new(),\n             declared_lib_features: Vec::new(),\n             const_fn: false,\n-            static_recursion: false\n+            static_recursion: false,\n+            default_type_parameter_fallback: false,\n         }\n     }\n }\n@@ -864,7 +868,8 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n         declared_stable_lang_features: accepted_features,\n         declared_lib_features: unknown_features,\n         const_fn: cx.has_feature(\"const_fn\"),\n-        static_recursion: cx.has_feature(\"static_recursion\")\n+        static_recursion: cx.has_feature(\"static_recursion\"),\n+        default_type_parameter_fallback: cx.has_feature(\"default_type_parameter_fallback\"),\n     }\n }\n "}, {"sha": "270cfdcb7f651cec9d893d5f9d22da99d97c8719", "filename": "src/test/auxiliary/default_ty_param_cross_crate_crate.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Fauxiliary%2Fdefault_ty_param_cross_crate_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Fauxiliary%2Fdefault_ty_param_cross_crate_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fdefault_ty_param_cross_crate_crate.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+#![crate_name = \"default_param_test\"]\n+\n+use std::marker::PhantomData;\n+\n+pub struct Foo<A, B>(PhantomData<(A, B)>);\n+\n+pub fn bleh<A=i32, X=char>() -> Foo<A, X> { Foo(PhantomData) }\n+"}, {"sha": "48c5cd1ff7706995256927d057080c7ac974e984", "filename": "src/test/compile-fail/default_ty_param_conflict.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(default_type_parameter_fallback)]\n+\n+use std::fmt::Debug;\n+\n+// Example from the RFC\n+fn foo<F:Default=usize>() -> F { F::default() }\n+//~^ NOTE: a default was defined here...\n+\n+fn bar<B:Debug=isize>(b: B) { println!(\"{:?}\", b); }\n+//~^ NOTE: a second default was defined here...\n+\n+fn main() {\n+    // Here, F is instantiated with $0=uint\n+    let x = foo();\n+    //~^ ERROR: mismatched types\n+    //~| NOTE: conflicting type parameter defaults `usize` and `isize`\n+    //~| NOTE: ...that was applied to an unconstrained type variable here\n+\n+    // Here, B is instantiated with $1=uint, and constraint $0 <: $1 is added.\n+    bar(x);\n+    //~^ NOTE: ...that also applies to the same type variable here\n+}"}, {"sha": "4d60724372ada45b2856c09e5d8431408bd193eb", "filename": "src/test/compile-fail/default_ty_param_conflict_cross_crate.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict_cross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict_cross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict_cross_crate.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+//aux-build:default_ty_param_cross_crate_crate.rs\n+\n+#![feature(default_type_parameter_fallback)]\n+\n+extern crate default_param_test;\n+\n+use default_param_test::{Foo, bleh};\n+\n+fn meh<X, B=bool>(x: Foo<X, B>) {}\n+//~^ NOTE: a default was defined here...\n+\n+fn main() {\n+    let foo = bleh();\n+    //~^ NOTE: ...that also applies to the same type variable here\n+\n+    meh(foo);\n+    //~^ ERROR: mismatched types:\n+    //~| NOTE: conflicting type parameter defaults `bool` and `char`\n+}"}, {"sha": "8fc2c2e6bce70009bc949f187d6458ef82f5b1ec", "filename": "src/test/run-pass/default_ty_param_default_dependent_associated_type.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_default_dependent_associated_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_default_dependent_associated_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_default_dependent_associated_type.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+\n+#![feature(default_type_parameter_fallback)]\n+\n+use std::marker::PhantomData;\n+\n+trait Id {\n+    type This;\n+}\n+\n+impl<A> Id for A {\n+    type This = A;\n+}\n+\n+struct Foo<X: Default = usize, Y = <X as Id>::This> {\n+    data: PhantomData<(X, Y)>\n+}\n+\n+impl<X: Default, Y> Foo<X, Y> {\n+    fn new() -> Foo<X, Y> {\n+        Foo { data: PhantomData }\n+    }\n+}\n+\n+fn main() {\n+    let foo = Foo::new();\n+}"}, {"sha": "ac833d0f54744e2a659d0c9738da4695edfe3cc4", "filename": "src/test/run-pass/default_ty_param_dependent_defaults.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_dependent_defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_dependent_defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_dependent_defaults.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+\n+#![feature(default_type_parameter_fallback)]\n+use std::marker::PhantomData;\n+\n+struct Foo<T,U=T> { t: T, data: PhantomData<U> }\n+\n+fn main() {\n+    let foo = Foo { t: 'a', data: PhantomData };\n+}"}, {"sha": "e8d93092ec53d31704a5da06482dd58a9d00a719", "filename": "src/test/run-pass/default_ty_param_method_call_test.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_method_call_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_method_call_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_method_call_test.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(default_type_parameter_fallback)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn method<A:Default=String>(&self) -> A {\n+        A::default()\n+    }\n+}\n+\n+fn main() {\n+    let f = Foo.method();\n+    println!(\"{}\", f);\n+}"}, {"sha": "d9ac51fc23b0281a07a4934f97fda0dec7f7bcf8", "filename": "src/test/run-pass/default_ty_param_struct.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(default_type_parameter_fallback)]\n+\n+struct Foo<A>(A);\n+\n+impl<A:Default=i32> Foo<A> {\n+    fn new() -> Foo<A> {\n+        Foo(A::default())\n+    }\n+}\n+\n+fn main() {\n+    let foo = Foo::new();\n+}"}, {"sha": "6e3e60a02e5e2fee05255c97d237e22428fcaab0", "filename": "src/test/run-pass/default_ty_param_struct_and_type_alias.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct_and_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct_and_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct_and_type_alias.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+\n+#![feature(default_type_parameter_fallback)]\n+\n+use std::marker::PhantomData;\n+\n+struct DeterministicHasher;\n+struct RandomHasher;\n+\n+\n+struct MyHashMap<K, V, H=DeterministicHasher> {\n+    data: PhantomData<(K, V, H)>\n+}\n+\n+impl<K, V, H> MyHashMap<K, V, H> {\n+    fn new() -> MyHashMap<K, V, H> {\n+        MyHashMap { data: PhantomData }\n+    }\n+}\n+\n+mod mystd {\n+    use super::{MyHashMap, RandomHasher};\n+    pub type HashMap<K, V, H=RandomHasher> = MyHashMap<K, V, H>;\n+}\n+\n+fn try_me<H>(hash_map: mystd::HashMap<i32, i32, H>) {}\n+\n+fn main() {\n+    let hash_map = mystd::HashMap::new();\n+    try_me(hash_map);\n+}"}, {"sha": "c67d3a49aff3d01a1288affa33fb307305dd036a", "filename": "src/test/run-pass/default_ty_param_trait_impl.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(default_type_parameter_fallback)]\n+\n+// Another example from the RFC\n+trait Foo { }\n+trait Bar { }\n+\n+impl<T:Bar=usize> Foo for Vec<T> {}\n+impl Bar for usize {}\n+\n+fn takes_foo<F:Foo>(f: F) {}\n+\n+fn main() {\n+    let x = Vec::new(); // x: Vec<$0>\n+    takes_foo(x); // adds oblig Vec<$0> : Foo\n+}"}, {"sha": "067ad524922c0bfa17066c0939457504b321fe1d", "filename": "src/test/run-pass/default_ty_param_trait_impl_simple.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl_simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl_simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl_simple.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(default_type_parameter_fallback)]\n+\n+// An example from the RFC\n+trait Foo { fn takes_foo(&self); }\n+trait Bar { }\n+\n+impl<T:Bar=usize> Foo for Vec<T> {\n+    fn takes_foo(&self) {}\n+}\n+\n+impl Bar for usize {}\n+\n+fn main() {\n+    let x = Vec::new(); // x: Vec<$0>\n+    x.takes_foo(); // adds oblig Vec<$0> : Foo\n+}"}, {"sha": "1b4747406d0c66e948f33b3b9be0773887cab1af", "filename": "src/test/run-pass/default_ty_param_type_alias.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c12f4e39d32af3c951b66bd2839bc0b5a1125b/src%2Ftest%2Frun-pass%2Fdefault_ty_param_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_type_alias.rs?ref=a5c12f4e39d32af3c951b66bd2839bc0b5a1125b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(default_type_parameter_fallback)]\n+\n+use std::collections::HashMap;\n+\n+type IntMap<K=usize> = HashMap<K, usize>;\n+\n+fn main() {\n+    let x = IntMap::new();\n+}"}]}