{"sha": "3328bd9a0f19b4c7bb8932b262583b8edf885338", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMjhiZDlhMGYxOWI0YzdiYjg5MzJiMjYyNTgzYjhlZGY4ODUzMzg=", "commit": {"author": {"name": "Wim Looman", "email": "git@nemo157.com", "date": "2020-08-18T20:19:02Z"}, "committer": {"name": "Wim Looman", "email": "git@nemo157.com", "date": "2020-08-18T20:35:50Z"}, "message": "Add long cfg description to tooltip on short description", "tree": {"sha": "bb00f41c4289bf90898e877318a773d405915007", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb00f41c4289bf90898e877318a773d405915007"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3328bd9a0f19b4c7bb8932b262583b8edf885338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3328bd9a0f19b4c7bb8932b262583b8edf885338", "html_url": "https://github.com/rust-lang/rust/commit/3328bd9a0f19b4c7bb8932b262583b8edf885338", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3328bd9a0f19b4c7bb8932b262583b8edf885338/comments", "author": {"login": "Nemo157", "id": 81079, "node_id": "MDQ6VXNlcjgxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/81079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nemo157", "html_url": "https://github.com/Nemo157", "followers_url": "https://api.github.com/users/Nemo157/followers", "following_url": "https://api.github.com/users/Nemo157/following{/other_user}", "gists_url": "https://api.github.com/users/Nemo157/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nemo157/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nemo157/subscriptions", "organizations_url": "https://api.github.com/users/Nemo157/orgs", "repos_url": "https://api.github.com/users/Nemo157/repos", "events_url": "https://api.github.com/users/Nemo157/events{/privacy}", "received_events_url": "https://api.github.com/users/Nemo157/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nemo157", "id": 81079, "node_id": "MDQ6VXNlcjgxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/81079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nemo157", "html_url": "https://github.com/Nemo157", "followers_url": "https://api.github.com/users/Nemo157/followers", "following_url": "https://api.github.com/users/Nemo157/following{/other_user}", "gists_url": "https://api.github.com/users/Nemo157/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nemo157/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nemo157/subscriptions", "organizations_url": "https://api.github.com/users/Nemo157/orgs", "repos_url": "https://api.github.com/users/Nemo157/repos", "events_url": "https://api.github.com/users/Nemo157/events{/privacy}", "received_events_url": "https://api.github.com/users/Nemo157/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "234ec956ab91d4aef51b63f25b78d176aa364a60", "url": "https://api.github.com/repos/rust-lang/rust/commits/234ec956ab91d4aef51b63f25b78d176aa364a60", "html_url": "https://github.com/rust-lang/rust/commit/234ec956ab91d4aef51b63f25b78d176aa364a60"}], "stats": {"total": 143, "additions": 105, "deletions": 38}, "files": [{"sha": "1839683b61004333156e0f2f4d4a7ca469177051", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 83, "deletions": 32, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/3328bd9a0f19b4c7bb8932b262583b8edf885338/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3328bd9a0f19b4c7bb8932b262583b8edf885338/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=3328bd9a0f19b4c7bb8932b262583b8edf885338", "patch": "@@ -135,7 +135,7 @@ impl Cfg {\n \n     /// Renders the configuration for human display, as a short HTML description.\n     pub(crate) fn render_short_html(&self) -> String {\n-        let mut msg = Html(self, true).to_string();\n+        let mut msg = Display(self, Format::ShortHtml).to_string();\n         if self.should_capitalize_first_letter() {\n             if let Some(i) = msg.find(|c: char| c.is_ascii_alphanumeric()) {\n                 msg[i..i + 1].make_ascii_uppercase();\n@@ -148,14 +148,29 @@ impl Cfg {\n     pub(crate) fn render_long_html(&self) -> String {\n         let on = if self.should_use_with_in_description() { \"with\" } else { \"on\" };\n \n-        let mut msg = format!(\"This is supported {} <strong>{}</strong>\", on, Html(self, false));\n+        let mut msg = format!(\n+            \"This is supported {} <strong>{}</strong>\",\n+            on,\n+            Display(self, Format::LongHtml)\n+        );\n         if self.should_append_only_to_description() {\n             msg.push_str(\" only\");\n         }\n         msg.push('.');\n         msg\n     }\n \n+    /// Renders the configuration for long display, as a long plain text description.\n+    pub(crate) fn render_long_plain(&self) -> String {\n+        let on = if self.should_use_with_in_description() { \"with\" } else { \"on\" };\n+\n+        let mut msg = format!(\"This is supported {} {}\", on, Display(self, Format::LongPlain));\n+        if self.should_append_only_to_description() {\n+            msg.push_str(\" only\");\n+        }\n+        msg\n+    }\n+\n     fn should_capitalize_first_letter(&self) -> bool {\n         match *self {\n             Cfg::False | Cfg::True | Cfg::Not(..) => true,\n@@ -286,9 +301,31 @@ impl ops::BitOr for Cfg {\n     }\n }\n \n-/// Pretty-print wrapper for a `Cfg`. Also indicates whether the \"short-form\" rendering should be\n-/// used.\n-struct Html<'a>(&'a Cfg, bool);\n+#[derive(Clone, Copy)]\n+enum Format {\n+    LongHtml,\n+    LongPlain,\n+    ShortHtml,\n+}\n+\n+impl Format {\n+    fn is_long(self) -> bool {\n+        match self {\n+            Format::LongHtml | Format::LongPlain => true,\n+            Format::ShortHtml => false,\n+        }\n+    }\n+\n+    fn is_html(self) -> bool {\n+        match self {\n+            Format::LongHtml | Format::ShortHtml => true,\n+            Format::LongPlain => false,\n+        }\n+    }\n+}\n+\n+/// Pretty-print wrapper for a `Cfg`. Also indicates what form of rendering should be used.\n+struct Display<'a>(&'a Cfg, Format);\n \n fn write_with_opt_paren<T: fmt::Display>(\n     fmt: &mut fmt::Formatter<'_>,\n@@ -305,7 +342,7 @@ fn write_with_opt_paren<T: fmt::Display>(\n     Ok(())\n }\n \n-impl<'a> fmt::Display for Html<'a> {\n+impl<'a> fmt::Display for Display<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self.0 {\n             Cfg::Not(ref child) => match **child {\n@@ -314,18 +351,18 @@ impl<'a> fmt::Display for Html<'a> {\n                         if sub_cfgs.iter().all(Cfg::is_simple) { \" nor \" } else { \", nor \" };\n                     for (i, sub_cfg) in sub_cfgs.iter().enumerate() {\n                         fmt.write_str(if i == 0 { \"neither \" } else { separator })?;\n-                        write_with_opt_paren(fmt, !sub_cfg.is_all(), Html(sub_cfg, self.1))?;\n+                        write_with_opt_paren(fmt, !sub_cfg.is_all(), Display(sub_cfg, self.1))?;\n                     }\n                     Ok(())\n                 }\n-                ref simple @ Cfg::Cfg(..) => write!(fmt, \"non-{}\", Html(simple, self.1)),\n-                ref c => write!(fmt, \"not ({})\", Html(c, self.1)),\n+                ref simple @ Cfg::Cfg(..) => write!(fmt, \"non-{}\", Display(simple, self.1)),\n+                ref c => write!(fmt, \"not ({})\", Display(c, self.1)),\n             },\n \n             Cfg::Any(ref sub_cfgs) => {\n                 let separator = if sub_cfgs.iter().all(Cfg::is_simple) { \" or \" } else { \", or \" };\n \n-                let short_longhand = !self.1 && {\n+                let short_longhand = self.1.is_long() && {\n                     let all_crate_features = sub_cfgs\n                         .iter()\n                         .all(|sub_cfg| matches!(sub_cfg, Cfg::Cfg(sym::feature, Some(_))));\n@@ -349,16 +386,20 @@ impl<'a> fmt::Display for Html<'a> {\n                         fmt.write_str(separator)?;\n                     }\n                     if let (true, Cfg::Cfg(_, Some(feat))) = (short_longhand, sub_cfg) {\n-                        write!(fmt, \"<code>{}</code>\", feat)?;\n+                        if self.1.is_html() {\n+                            write!(fmt, \"<code>{}</code>\", feat)?;\n+                        } else {\n+                            write!(fmt, \"`{}`\", feat)?;\n+                        }\n                     } else {\n-                        write_with_opt_paren(fmt, !sub_cfg.is_all(), Html(sub_cfg, self.1))?;\n+                        write_with_opt_paren(fmt, !sub_cfg.is_all(), Display(sub_cfg, self.1))?;\n                     }\n                 }\n                 Ok(())\n             }\n \n             Cfg::All(ref sub_cfgs) => {\n-                let short_longhand = !self.1 && {\n+                let short_longhand = self.1.is_long() && {\n                     let all_crate_features = sub_cfgs\n                         .iter()\n                         .all(|sub_cfg| matches!(sub_cfg, Cfg::Cfg(sym::feature, Some(_))));\n@@ -382,9 +423,13 @@ impl<'a> fmt::Display for Html<'a> {\n                         fmt.write_str(\" and \")?;\n                     }\n                     if let (true, Cfg::Cfg(_, Some(feat))) = (short_longhand, sub_cfg) {\n-                        write!(fmt, \"<code>{}</code>\", feat)?;\n+                        if self.1.is_html() {\n+                            write!(fmt, \"<code>{}</code>\", feat)?;\n+                        } else {\n+                            write!(fmt, \"`{}`\", feat)?;\n+                        }\n                     } else {\n-                        write_with_opt_paren(fmt, !sub_cfg.is_simple(), Html(sub_cfg, self.1))?;\n+                        write_with_opt_paren(fmt, !sub_cfg.is_simple(), Display(sub_cfg, self.1))?;\n                     }\n                 }\n                 Ok(())\n@@ -453,33 +498,39 @@ impl<'a> fmt::Display for Html<'a> {\n                     },\n                     (sym::target_endian, Some(endian)) => return write!(fmt, \"{}-endian\", endian),\n                     (sym::target_pointer_width, Some(bits)) => return write!(fmt, \"{}-bit\", bits),\n-                    (sym::target_feature, Some(feat)) => {\n-                        if self.1 {\n-                            return write!(fmt, \"<code>{}</code>\", feat);\n-                        } else {\n+                    (sym::target_feature, Some(feat)) => match self.1 {\n+                        Format::LongHtml => {\n                             return write!(fmt, \"target feature <code>{}</code>\", feat);\n                         }\n-                    }\n-                    (sym::feature, Some(feat)) => {\n-                        if self.1 {\n-                            return write!(fmt, \"<code>{}</code>\", feat);\n-                        } else {\n+                        Format::LongPlain => return write!(fmt, \"target feature `{}`\", feat),\n+                        Format::ShortHtml => return write!(fmt, \"<code>{}</code>\", feat),\n+                    },\n+                    (sym::feature, Some(feat)) => match self.1 {\n+                        Format::LongHtml => {\n                             return write!(fmt, \"crate feature <code>{}</code>\", feat);\n                         }\n-                    }\n+                        Format::LongPlain => return write!(fmt, \"crate feature `{}`\", feat),\n+                        Format::ShortHtml => return write!(fmt, \"<code>{}</code>\", feat),\n+                    },\n                     _ => \"\",\n                 };\n                 if !human_readable.is_empty() {\n                     fmt.write_str(human_readable)\n                 } else if let Some(v) = value {\n-                    write!(\n-                        fmt,\n-                        \"<code>{}=\\\"{}\\\"</code>\",\n-                        Escape(&name.as_str()),\n-                        Escape(&v.as_str())\n-                    )\n-                } else {\n+                    if self.1.is_html() {\n+                        write!(\n+                            fmt,\n+                            r#\"<code>{}=\"{}\"</code>\"#,\n+                            Escape(&name.as_str()),\n+                            Escape(&v.as_str())\n+                        )\n+                    } else {\n+                        write!(fmt, r#\"`{}=\"{}\"`\"#, name, v)\n+                    }\n+                } else if self.1.is_html() {\n                     write!(fmt, \"<code>{}</code>\", Escape(&name.as_str()))\n+                } else {\n+                    write!(fmt, \"`{}`\", name)\n                 }\n             }\n         }"}, {"sha": "de0964f5302003b6a476b543871eed11cb6e9114", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3328bd9a0f19b4c7bb8932b262583b8edf885338/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3328bd9a0f19b4c7bb8932b262583b8edf885338/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=3328bd9a0f19b4c7bb8932b262583b8edf885338", "patch": "@@ -2108,8 +2108,8 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n fn stability_tags(item: &clean::Item) -> String {\n     let mut tags = String::new();\n \n-    fn tag_html(class: &str, contents: &str) -> String {\n-        format!(r#\"<span class=\"stab {}\">{}</span>\"#, class, contents)\n+    fn tag_html(class: &str, title: &str, contents: &str) -> String {\n+        format!(r#\"<span class=\"stab {}\" title=\"{}\">{}</span>\"#, class, Escape(title), contents)\n     }\n \n     // The trailing space after each tag is to space it properly against the rest of the docs.\n@@ -2118,7 +2118,7 @@ fn stability_tags(item: &clean::Item) -> String {\n         if !stability::deprecation_in_effect(depr.is_since_rustc_version, depr.since.as_deref()) {\n             message = \"Deprecation planned\";\n         }\n-        tags += &tag_html(\"deprecated\", message);\n+        tags += &tag_html(\"deprecated\", \"\", message);\n     }\n \n     // The \"rustc_private\" crates are permanently unstable so it makes no sense\n@@ -2129,11 +2129,11 @@ fn stability_tags(item: &clean::Item) -> String {\n         .map(|s| s.level == stability::Unstable && s.feature.as_deref() != Some(\"rustc_private\"))\n         == Some(true)\n     {\n-        tags += &tag_html(\"unstable\", \"Experimental\");\n+        tags += &tag_html(\"unstable\", \"\", \"Experimental\");\n     }\n \n     if let Some(ref cfg) = item.attrs.cfg {\n-        tags += &tag_html(\"portability\", &cfg.render_short_html());\n+        tags += &tag_html(\"portability\", &cfg.render_long_plain(), &cfg.render_short_html());\n     }\n \n     tags"}, {"sha": "47ba362c97789fe481b3d061442624a81cf49454", "filename": "src/test/rustdoc/duplicate-cfg.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3328bd9a0f19b4c7bb8932b262583b8edf885338/src%2Ftest%2Frustdoc%2Fduplicate-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3328bd9a0f19b4c7bb8932b262583b8edf885338/src%2Ftest%2Frustdoc%2Fduplicate-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fduplicate-cfg.rs?ref=3328bd9a0f19b4c7bb8932b262583b8edf885338", "patch": "@@ -3,12 +3,20 @@\n #![crate_name = \"foo\"]\n #![feature(doc_cfg)]\n \n+// @has 'foo/index.html'\n+// @matches '-' '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]' '^sync$'\n+// @has '-' '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]/@title' 'This is supported on crate feature `sync` only'\n+\n // @has 'foo/struct.Foo.html'\n-// @has '-' '//*[@class=\"stab portability\"]' 'This is supported on crate feature sync only.'\n+// @has '-' '//*[@class=\"stab portability\"]' 'sync'\n #[doc(cfg(feature = \"sync\"))]\n #[doc(cfg(feature = \"sync\"))]\n pub struct Foo;\n \n+// @has 'foo/bar/index.html'\n+// @matches '-' '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]' '^sync$'\n+// @has '-' '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]/@title' 'This is supported on crate feature `sync` only'\n+\n // @has 'foo/bar/struct.Bar.html'\n // @has '-' '//*[@class=\"stab portability\"]' 'This is supported on crate feature sync only.'\n #[doc(cfg(feature = \"sync\"))]\n@@ -17,6 +25,10 @@ pub mod bar {\n     pub struct Bar;\n }\n \n+// @has 'foo/baz/index.html'\n+// @matches '-' '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]' '^sync and send$'\n+// @has '-' '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]/@title' 'This is supported on crate features `sync` and `send` only'\n+\n // @has 'foo/baz/struct.Baz.html'\n // @has '-' '//*[@class=\"stab portability\"]' 'This is supported on crate features sync and send only.'\n #[doc(cfg(all(feature = \"sync\", feature = \"send\")))]\n@@ -33,6 +45,10 @@ pub mod qux {\n     pub struct Qux;\n }\n \n+// @has 'foo/quux/index.html'\n+// @matches '-' '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]' '^sync and send and foo and bar$'\n+// @has '-' '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]/@title' 'This is supported on crate feature `sync` and crate feature `send` and `foo` and `bar` only'\n+\n // @has 'foo/quux/struct.Quux.html'\n // @has '-' '//*[@class=\"stab portability\"]' 'This is supported on crate feature sync and crate feature send and foo and bar only.'\n #[doc(cfg(all(feature = \"sync\", feature = \"send\", foo)))]"}]}