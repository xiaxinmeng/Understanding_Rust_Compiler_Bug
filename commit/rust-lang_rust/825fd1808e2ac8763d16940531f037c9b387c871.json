{"sha": "825fd1808e2ac8763d16940531f037c9b387c871", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNWZkMTgwOGUyYWM4NzYzZDE2OTQwNTMxZjAzN2M5YjM4N2M4NzE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-24T22:52:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-26T02:26:56Z"}, "message": "lots of work to make iface/impls parameterized by regions\n\n- paths can now take region parameters, replacing the dirty hack\n  I was doing before of abusing vstores.  vstores are now a bit\n  of a hack though.\n\n- fix various small bugs:\n  - we never checked that iface types were compatible when casting\n    to an iface with `as`\n  - we allowed nonsense like int<int>\n  - and more! (actually that may be it)", "tree": {"sha": "493678053820169e7619bf741fa18fb3dbf72420", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/493678053820169e7619bf741fa18fb3dbf72420"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/825fd1808e2ac8763d16940531f037c9b387c871", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/825fd1808e2ac8763d16940531f037c9b387c871", "html_url": "https://github.com/rust-lang/rust/commit/825fd1808e2ac8763d16940531f037c9b387c871", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/825fd1808e2ac8763d16940531f037c9b387c871/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "458d2ff067261ab646d914123f9c9c496cd612ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/458d2ff067261ab646d914123f9c9c496cd612ae", "html_url": "https://github.com/rust-lang/rust/commit/458d2ff067261ab646d914123f9c9c496cd612ae"}], "stats": {"total": 1396, "additions": 849, "deletions": 547}, "files": [{"sha": "48e8866d3f56d953ba2170b31e5d53848c952673", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -37,7 +37,11 @@ type ident = str;\n type fn_ident = option<ident>;\n \n #[auto_serialize]\n-type path = {span: span, global: bool, idents: [ident], types: [@ty]};\n+type path = {span: span,\n+             global: bool,\n+             idents: [ident],\n+             rp: option<@region>,\n+             types: [@ty]};\n \n #[auto_serialize]\n type crate_num = int;\n@@ -175,7 +179,7 @@ enum vstore {\n     vstore_fixed(option<uint>),   // [1,2,3,4]/_ or 4\n     vstore_uniq,                  // [1,2,3,4]/~\n     vstore_box,                   // [1,2,3,4]/@\n-    vstore_slice(region)          // [1,2,3,4]/&(foo)?\n+    vstore_slice(@region)         // [1,2,3,4]/&(foo)?\n }\n \n pure fn is_blockish(p: ast::proto) -> bool {\n@@ -462,7 +466,7 @@ enum ty_ {\n     ty_uniq(mt),\n     ty_vec(mt),\n     ty_ptr(mt),\n-    ty_rptr(region, mt),\n+    ty_rptr(@region, mt),\n     ty_rec([ty_field]),\n     ty_fn(proto, fn_decl),\n     ty_tup([@ty]),\n@@ -671,8 +675,8 @@ enum item_ {\n                class_ctor,\n                region_param\n                ),\n-    item_iface([ty_param], [ty_method]),\n-    item_impl([ty_param], option<@iface_ref> /* iface */,\n+    item_iface([ty_param], region_param, [ty_method]),\n+    item_impl([ty_param], region_param, option<@iface_ref> /* iface */,\n               @ty /* self */, [@method]),\n }\n "}, {"sha": "49a20393a5d8b412c17cd19b11079d2b275be093", "filename": "src/librustsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast_util.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -248,7 +248,8 @@ fn default_block(stmts1: [@stmt], expr1: option<@expr>, id1: node_id) ->\n }\n \n fn ident_to_path(s: span, i: ident) -> @path {\n-    @{span: s, global: false, idents: [i], types: []}\n+    @{span: s, global: false, idents: [i],\n+      rp: none, types: []}\n }\n \n pure fn is_unguarded(&&a: arm) -> bool {"}, {"sha": "7b90709b118ed28078cdd3a083bc185116e9348e", "filename": "src/librustsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -130,11 +130,11 @@ impl helpers for ext_ctxt {\n     }\n \n     fn path(span: span, strs: [str]) -> @ast::path {\n-        @{span: span, global: false, idents: strs, types: []}\n+        @{span: span, global: false, idents: strs, rp: none, types: []}\n     }\n \n     fn path_tps(span: span, strs: [str], tps: [@ast::ty]) -> @ast::path {\n-        @{span: span, global: false, idents: strs, types: tps}\n+        @{span: span, global: false, idents: strs, rp: none, types: tps}\n     }\n \n     fn ty_path(span: span, strs: [str], tps: [@ast::ty]) -> @ast::ty {\n@@ -193,7 +193,8 @@ impl helpers for ext_ctxt {\n     }\n \n     fn binder_pat(span: span, nm: str) -> @ast::pat {\n-        let path = @{span: span, global: false, idents: [nm], types: []};\n+        let path = @{span: span, global: false, idents: [nm],\n+                     rp: none, types: []};\n         @{id: self.next_id(),\n           node: ast::pat_ident(path, none),\n           span: span}"}, {"sha": "516deb1e7938eb75bd2bf72a1adcc4b057221f53", "filename": "src/librustsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fbuild.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -30,7 +30,8 @@ fn mk_unary(cx: ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n }\n fn mk_path(cx: ext_ctxt, sp: span, idents: [ast::ident]) ->\n     @ast::expr {\n-    let path = @{span: sp, global: false, idents: idents, types: []};\n+    let path = @{span: sp, global: false, idents: idents,\n+                 rp: none, types: []};\n     let pathexpr = ast::expr_path(path);\n     ret @{id: cx.next_id(), node: pathexpr, span: sp};\n }"}, {"sha": "409a38b378d283481aa97d5defed0b5f0bcc55a2", "filename": "src/librustsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fconcat_idents.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -17,6 +17,6 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n \n     ret @{id: cx.next_id(),\n           node: ast::expr_path(@{span: sp, global: false, idents: [res],\n-                                 types: []}),\n+                                 rp: none, types: []}),\n           span: sp};\n }"}, {"sha": "81eaa193f95f4b0181e992097a15c42529d495b6", "filename": "src/librustsyntax/ext/simplext.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fsimplext.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -334,7 +334,8 @@ fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n     if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { ret p; }\n     alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n       some(match_ident(id)) {\n-        {span: id.span, global: false, idents: [id.node], types: []}\n+        {span: id.span, global: false, idents: [id.node],\n+         rp: none, types: []}\n       }\n       some(match_path(a_pth)) { *a_pth }\n       some(m) { match_error(cx, m, \"a path\") }\n@@ -359,6 +360,7 @@ fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n                 (expr_path(@{span: id.span,\n                              global: false,\n                              idents: [id.node],\n+                             rp: none,\n                              types: []}), id.span)\n               }\n               some(match_path(a_pth)) { (expr_path(a_pth), s) }"}, {"sha": "30e8c5173b24559c98954f33eb902f4533411408", "filename": "src/librustsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Ffold.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -287,12 +287,18 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                    with ctor},\n                   rp)\n           }\n-          item_impl(tps, ifce, ty, methods) {\n-              item_impl(tps, option::map(ifce, {|p| fold_iface_ref(p, fld)}),\n+          item_impl(tps, rp, ifce, ty, methods) {\n+              item_impl(fold_ty_params(tps, fld),\n+                        rp,\n+                        ifce.map { |p| fold_iface_ref(p, fld) },\n                         fld.fold_ty(ty),\n-                      vec::map(methods, fld.fold_method))\n+                        vec::map(methods, fld.fold_method))\n+          }\n+          item_iface(tps, rp, methods) {\n+            item_iface(fold_ty_params(tps, fld),\n+                       rp,\n+                       methods)\n           }\n-          item_iface(tps, methods) { item_iface(tps, methods) }\n           item_res(decl, typms, body, did, cid, rp) {\n             item_res(fold_fn_decl(decl, fld),\n                      fold_ty_params(typms, fld),\n@@ -565,6 +571,7 @@ fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident { ret i; }\n fn noop_fold_path(&&p: path, fld: ast_fold) -> path {\n     ret {span: fld.new_span(p.span), global: p.global,\n          idents: vec::map(p.idents, fld.fold_ident),\n+         rp: p.rp,\n          types: vec::map(p.types, fld.fold_ty)};\n }\n "}, {"sha": "53d42038afa838ba4a2e88b28465ea9426bb0ad1", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 139, "deletions": 103, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -175,7 +175,7 @@ fn parse_type_constr_arg(p: parser) -> @ast::ty_constr_arg {\n     if p.token == token::DOT {\n         // \"*...\" notation for record fields\n         p.bump();\n-        let pth = parse_path(p);\n+        let pth = parse_path_without_tps(p);\n         carg = ast::carg_ident(pth);\n     }\n     // No literals yet, I guess?\n@@ -196,7 +196,7 @@ fn parse_constr_arg(args: [ast::arg], p: parser) -> @ast::constr_arg {\n \n fn parse_ty_constr(fn_args: [ast::arg], p: parser) -> @ast::constr {\n     let lo = p.span.lo;\n-    let path = parse_path(p);\n+    let path = parse_path_without_tps(p);\n     let args: {node: [@ast::constr_arg], span: span} =\n         parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n                   {|p| parse_constr_arg(fn_args, p)}, p);\n@@ -206,7 +206,7 @@ fn parse_ty_constr(fn_args: [ast::arg], p: parser) -> @ast::constr {\n \n fn parse_constr_in_type(p: parser) -> @ast::ty_constr {\n     let lo = p.span.lo;\n-    let path = parse_path(p);\n+    let path = parse_path_without_tps(p);\n     let args: [@ast::ty_constr_arg] =\n         parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n                   parse_type_constr_arg, p).node;\n@@ -231,52 +231,6 @@ fn parse_type_constraints(p: parser) -> [@ast::ty_constr] {\n     ret parse_constrs(parse_constr_in_type, p);\n }\n \n-fn parse_ty_postfix(orig_t: ast::ty_, p: parser, colons_before_params: bool,\n-                    lo: uint) -> @ast::ty {\n-\n-\n-    fn mk_ty(p: parser, t: ast::ty_, lo: uint, hi: uint) -> @ast::ty {\n-        @{id: p.get_id(),\n-          node: t,\n-          span: mk_sp(lo, hi)}\n-    }\n-\n-    if p.token == token::BINOP(token::SLASH) {\n-        let orig_hi = p.last_span.hi;\n-        alt maybe_parse_vstore(p) {\n-          none { }\n-          some(v) {\n-            let t = ast::ty_vstore(mk_ty(p, orig_t, lo, orig_hi), v);\n-            ret mk_ty(p, t, lo, p.last_span.hi);\n-          }\n-        }\n-    }\n-\n-    if colons_before_params && p.token == token::MOD_SEP {\n-        p.bump();\n-        expect(p, token::LT);\n-    } else if !colons_before_params && p.token == token::LT {\n-        p.bump();\n-    } else {\n-        ret mk_ty(p, orig_t, lo, p.last_span.hi);\n-    }\n-\n-    // If we're here, we have explicit type parameter instantiation.\n-    let seq = parse_seq_to_gt(some(token::COMMA), {|p| parse_ty(p, false)},\n-                              p);\n-\n-    alt orig_t {\n-      ast::ty_path(pth, ann) {\n-        ret mk_ty(p, ast::ty_path(@{span: mk_sp(lo, p.last_span.hi),\n-                                    global: pth.global,\n-                                    idents: pth.idents,\n-                                    types: seq}, ann),\n-                  lo, p.last_span.hi);\n-      }\n-      _ { p.fatal(\"type parameter instantiation only allowed for paths\"); }\n-    }\n-}\n-\n fn parse_ret_ty(p: parser) -> (ast::ret_style, @ast::ty) {\n     ret if eat(p, token::RARROW) {\n         let lo = p.span.lo;\n@@ -295,7 +249,7 @@ fn parse_ret_ty(p: parser) -> (ast::ret_style, @ast::ty) {\n     }\n }\n \n-fn region_from_name(p: parser, s: option<str>) -> ast::region {\n+fn region_from_name(p: parser, s: option<str>) -> @ast::region {\n     let r = alt s {\n       some (string) {\n         // FIXME: To be consistent with our type resolution, the\n@@ -310,10 +264,26 @@ fn region_from_name(p: parser, s: option<str>) -> ast::region {\n       none { ast::re_anon }\n     };\n \n-    {id: p.get_id(), node: r}\n+    @{id: p.get_id(), node: r}\n+}\n+\n+// Parses something like \"&x\"\n+fn parse_region(p: parser) -> @ast::region {\n+    expect(p, token::BINOP(token::AND));\n+    alt p.token {\n+      token::IDENT(sid, _) {\n+        p.bump();\n+        let n = p.get_str(sid);\n+        region_from_name(p, some(n))\n+      }\n+      _ {\n+        region_from_name(p, none)\n+      }\n+    }\n }\n \n-fn parse_region(p: parser) -> ast::region {\n+// Parses something like \"&x.\" (note the trailing dot)\n+fn parse_region_dot(p: parser) -> @ast::region {\n     let name =\n         alt p.token {\n           token::IDENT(sid, _) if p.look_ahead(1u) == token::DOT {\n@@ -384,7 +354,7 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n         t\n     } else if p.token == token::BINOP(token::AND) {\n         p.bump();\n-        let region = parse_region(p);\n+        let region = parse_region_dot(p);\n         let mt = parse_mt(p);\n         ast::ty_rptr(region, mt)\n     } else if eat_keyword(p, \"fn\") {\n@@ -398,10 +368,28 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n         expect_keyword(p, \"fn\");\n         ast::ty_fn(ast::proto_bare, parse_ty_fn(p))\n     } else if p.token == token::MOD_SEP || is_ident(p.token) {\n-        let path = parse_path(p);\n+        let path = parse_path_with_tps(p, colons_before_params);\n         ast::ty_path(path, p.get_id())\n     } else { p.fatal(\"expecting type\"); };\n-    ret parse_ty_postfix(t, p, colons_before_params, lo);\n+\n+    fn mk_ty(p: parser, t: ast::ty_, lo: uint, hi: uint) -> @ast::ty {\n+        @{id: p.get_id(),\n+          node: t,\n+          span: mk_sp(lo, hi)}\n+    }\n+\n+    let ty = mk_ty(p, t, lo, p.last_span.hi);\n+\n+    // Consider a vstore suffix like /@ or /~\n+    alt maybe_parse_vstore(p) {\n+      none {\n+        ret ty;\n+      }\n+      some(v) {\n+        let t1 = ast::ty_vstore(ty, v);\n+        ret mk_ty(p, t1, lo, p.last_span.hi);\n+      }\n+    }\n }\n \n fn parse_arg_mode(p: parser) -> ast::mode {\n@@ -484,17 +472,7 @@ fn maybe_parse_vstore(p: parser) -> option<ast::vstore> {\n             p.bump(); some(ast::vstore_fixed(some(i as uint)))\n           }\n           token::BINOP(token::AND) {\n-            p.bump();\n-            alt p.token {\n-              token::IDENT(sid, _) {\n-                p.bump();\n-                let n = p.get_str(sid);\n-                some(ast::vstore_slice(region_from_name(p, some(n))))\n-              }\n-              _ {\n-                some(ast::vstore_slice(region_from_name(p, none)))\n-              }\n-            }\n+            some(ast::vstore_slice(parse_region(p)))\n           }\n           _ {\n             none\n@@ -530,35 +508,65 @@ fn parse_lit(p: parser) -> ast::lit {\n     ret {node: lit, span: mk_sp(lo, p.last_span.hi)};\n }\n \n-fn parse_path(p: parser) -> @ast::path {\n+fn parse_path_without_tps(p: parser) -> @ast::path {\n     let lo = p.span.lo;\n     let global = eat(p, token::MOD_SEP);\n     let mut ids = [parse_ident(p)];\n     while p.look_ahead(1u) != token::LT && eat(p, token::MOD_SEP) {\n         ids += [parse_ident(p)];\n     }\n-    @{span: mk_sp(lo, p.last_span.hi), global: global, idents: ids, types: []}\n+    @{span: mk_sp(lo, p.last_span.hi), global: global,\n+      idents: ids, rp: none, types: []}\n }\n \n fn parse_value_path(p: parser) -> @ast::path {\n-    let pt = parse_path(p);\n+    let pt = parse_path_without_tps(p);\n     let last_word = vec::last(pt.idents);\n     if is_restricted_keyword(p, last_word) {\n         p.fatal(\"found \" + last_word + \" in expression position\");\n     }\n     pt\n }\n \n-fn parse_path_and_ty_param_substs(p: parser, colons: bool) -> @ast::path {\n+fn parse_path_with_tps(p: parser, colons: bool) -> @ast::path {\n+    #debug[\"parse_path_with_tps(colons=%b)\", colons];\n+\n     let lo = p.span.lo;\n-    let path = parse_path(p);\n-    let b = if colons { eat(p, token::MOD_SEP) }\n-            else { p.token == token::LT };\n-    if b {\n-        let seq = parse_seq_lt_gt(some(token::COMMA),\n-                                  {|p| parse_ty(p, false)}, p);\n-        @{span: mk_sp(lo, seq.span.hi), types: seq.node with *path}\n-    } else { path }\n+    let path = parse_path_without_tps(p);\n+    if colons && !eat(p, token::MOD_SEP) {\n+        ret path;\n+    }\n+\n+    // Parse the region parameter, if any, which will\n+    // be written \"foo/&x\"\n+    let rp = {\n+        // Hack: avoid parsing vstores like /@ and /~.  This is painful\n+        // because the notation for region bounds and the notation for vstores\n+        // is... um... the same.  I guess that's my fault.  This is still not\n+        // ideal as for str/& we end up parsing more than we ought to and have\n+        // to sort it out later.\n+        if p.token == token::BINOP(token::SLASH)\n+            && p.look_ahead(1u) == token::BINOP(token::AND) {\n+\n+            expect(p, token::BINOP(token::SLASH));\n+            some(parse_region(p))\n+        } else {\n+            none\n+        }\n+    };\n+\n+    // Parse any type parameters which may appear:\n+    let tps = {\n+        if p.token == token::LT {\n+            parse_seq_lt_gt(some(token::COMMA), {|p| parse_ty(p, false)}, p)\n+        } else {\n+            {node: [], span: path.span}\n+        }\n+    };\n+\n+    ret @{span: mk_sp(lo, tps.span.hi),\n+          rp: rp,\n+          types: tps.node with *path};\n }\n \n fn parse_mutability(p: parser) -> ast::mutability {\n@@ -803,7 +811,7 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n                   is_ident(p.token) && !is_keyword(p, \"true\") &&\n                       !is_keyword(p, \"false\") {\n         check_restricted_keywords(p);\n-        let pth = parse_path_and_ty_param_substs(p, true);\n+        let pth = parse_path_with_tps(p, true);\n         hi = pth.span.hi;\n         ex = ast::expr_path(pth);\n     } else {\n@@ -850,7 +858,7 @@ fn parse_syntax_ext_naked(p: parser, lo: uint) -> @ast::expr {\n       token::IDENT(_, _) {}\n       _ { p.fatal(\"expected a syntax expander name\"); }\n     }\n-    let pth = parse_path(p);\n+    let pth = parse_path_without_tps(p);\n     //temporary for a backwards-compatible cycle:\n     let sep = seq_sep(token::COMMA);\n     let mut e = none;\n@@ -1424,7 +1432,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n                       else { none };\n             pat = ast::pat_ident(name, sub);\n         } else {\n-            let enum_path = parse_path_and_ty_param_substs(p, true);\n+            let enum_path = parse_path_with_tps(p, true);\n             hi = enum_path.span.hi;\n             let mut args: [@ast::pat] = [];\n             let mut star_pat = false;\n@@ -1779,24 +1787,39 @@ fn parse_method(p: parser, pr: ast::privacy) -> @ast::method {\n }\n \n fn parse_item_iface(p: parser, attrs: [ast::attribute]) -> @ast::item {\n-    let lo = p.last_span.lo, ident = parse_ident(p),\n-        tps = parse_ty_params(p), meths = parse_ty_methods(p);\n+    let lo = p.last_span.lo, ident = parse_ident(p);\n+    let rp = parse_region_param(p);\n+    let tps = parse_ty_params(p);\n+    let meths = parse_ty_methods(p);\n     ret mk_item(p, lo, p.last_span.hi, ident,\n-                ast::item_iface(tps, meths), attrs);\n+                ast::item_iface(tps, rp, meths), attrs);\n }\n \n-// Parses three variants (with the initial params always optional):\n-//    impl <T: copy> of to_str for [T] { ... }\n-//    impl name<T> of to_str for [T] { ... }\n-//    impl name<T> for [T] { ... }\n+// Parses three variants (with the region/type params always optional):\n+//    impl /&<T: copy> of to_str for [T] { ... }\n+//    impl name/&<T> of to_str for [T] { ... }\n+//    impl name/&<T> for [T] { ... }\n fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n-    let mut (ident, tps) = if !is_keyword(p, \"of\") {\n-        if p.token == token::LT { (none, parse_ty_params(p)) }\n-        else { (some(parse_ident(p)), parse_ty_params(p)) }\n-    } else { (none, []) };\n+    fn wrap_path(p: parser, pt: @ast::path) -> @ast::ty {\n+        @{id: p.get_id(), node: ast::ty_path(pt, p.get_id()), span: pt.span}\n+    }\n+    let mut (ident, rp, tps) = {\n+        if p.token == token::LT {\n+            (none, ast::rp_none, parse_ty_params(p))\n+        } else if p.token == token::BINOP(token::SLASH) {\n+            (none, parse_region_param(p), parse_ty_params(p))\n+        }\n+        else if is_keyword(p, \"of\") {\n+            (none, ast::rp_none, [])\n+        } else {\n+            let id = parse_ident(p);\n+            let rp = parse_region_param(p);\n+            (some(id), rp, parse_ty_params(p))\n+        }\n+    };\n     let ifce = if eat_keyword(p, \"of\") {\n-        let path = parse_path_and_ty_param_substs(p, false);\n+        let path = parse_path_with_tps(p, false);\n         if option::is_none(ident) {\n             ident = some(vec::last(path.idents));\n         }\n@@ -1812,7 +1835,7 @@ fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     expect(p, token::LBRACE);\n     while !eat(p, token::RBRACE) { meths += [parse_method(p, ast::pub)]; }\n     ret mk_item(p, lo, p.last_span.hi, ident,\n-                ast::item_impl(tps, ifce, ty, meths), attrs);\n+                ast::item_impl(tps, rp, ifce, ty, meths), attrs);\n }\n \n fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n@@ -1842,21 +1865,32 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                 attrs);\n }\n \n-// Instantiates ident <i> with references to <typarams> as arguments\n+// Instantiates ident <i> with references to <typarams> as arguments.  Used to\n+// create a path that refers to a class which will be defined as the return\n+// type of the ctor function.\n fn ident_to_path_tys(p: parser, i: ast::ident,\n+                     rp: ast::region_param,\n                      typarams: [ast::ty_param]) -> @ast::path {\n     let s = p.last_span;\n+\n+    // Hack.  But then, this whole function is in service of a hack.\n+    let a_r = alt rp {\n+      ast::rp_none { none }\n+      ast::rp_self { some(region_from_name(p, some(\"self\"))) }\n+    };\n+\n     @{span: s, global: false, idents: [i],\n+      rp: a_r,\n       types: vec::map(typarams, {|tp|\n           @{id: p.get_id(),\n-            node: ast::ty_path(ident_to_path(s, tp.ident),\n-                               p.get_id()),\n+            node: ast::ty_path(ident_to_path(s, tp.ident), p.get_id()),\n             span: s}})\n      }\n }\n \n fn parse_iface_ref(p:parser) -> @ast::iface_ref {\n-    @{path: parse_path(p), id: p.get_id()}\n+    @{path: parse_path_with_tps(p, false),\n+      id: p.get_id()}\n }\n \n fn parse_iface_ref_list(p:parser) -> [@ast::iface_ref] {\n@@ -1869,7 +1903,7 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let class_name = parse_value_ident(p);\n     let rp = parse_region_param(p);\n     let ty_params = parse_ty_params(p);\n-    let class_path = ident_to_path_tys(p, class_name, ty_params);\n+    let class_path = ident_to_path_tys(p, class_name, rp, ty_params);\n     let ifaces : [@ast::iface_ref] = if eat_keyword(p, \"implements\")\n                                        { parse_iface_ref_list(p) }\n                                     else { [] };\n@@ -2240,7 +2274,7 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n             path += [id];\n         }\n         let path = @{span: mk_sp(lo, p.span.hi), global: false,\n-                     idents: path, types: []};\n+                     idents: path, rp: none, types: []};\n         ret @spanned(lo, p.span.hi,\n                      ast::view_path_simple(first_ident, path, p.get_id()));\n       }\n@@ -2264,7 +2298,8 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n                               seq_sep(token::COMMA),\n                               parse_path_list_ident, p).node;\n                 let path = @{span: mk_sp(lo, p.span.hi),\n-                             global: false, idents: path, types: []};\n+                             global: false, idents: path,\n+                             rp: none, types: []};\n                 ret @spanned(lo, p.span.hi,\n                              ast::view_path_list(path, idents, p.get_id()));\n               }\n@@ -2273,7 +2308,8 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n               token::BINOP(token::STAR) {\n                 p.bump();\n                 let path = @{span: mk_sp(lo, p.span.hi),\n-                             global: false, idents: path, types: []};\n+                             global: false, idents: path,\n+                             rp: none, types: []};\n                 ret @spanned(lo, p.span.hi,\n                              ast::view_path_glob(path, p.get_id()));\n               }\n@@ -2286,7 +2322,7 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n     }\n     let last = path[vec::len(path) - 1u];\n     let path = @{span: mk_sp(lo, p.span.hi), global: false,\n-                 idents: path, types: []};\n+                 idents: path, rp: none, types: []};\n     ret @spanned(lo, p.span.hi,\n                  ast::view_path_simple(last, path, p.get_id()));\n }"}, {"sha": "0ccf2399292154d997aa46b0b96e898aba7975e5", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -325,11 +325,14 @@ fn print_native_mod(s: ps, nmod: ast::native_mod, attrs: [ast::attribute]) {\n     for nmod.items.each {|item| print_native_item(s, item); }\n }\n \n-fn print_region(s: ps, region: ast::region) {\n+fn print_region(s: ps, region: @ast::region) {\n     alt region.node {\n-      ast::re_anon { /* no-op */ }\n-      ast::re_named(name) { word(s.s, name); word(s.s, \".\"); }\n-      ast::re_static { word(s.s, \"static\"); word(s.s, \".\"); }\n+      ast::re_anon { word_space(s, \"&\"); }\n+      ast::re_static { word_space(s, \"&static\"); }\n+      ast::re_named(name) {\n+        word(s.s, \"&\");\n+        word_space(s, name);\n+      }\n     }\n }\n \n@@ -353,8 +356,10 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n       }\n       ast::ty_ptr(mt) { word(s.s, \"*\"); print_mt(s, mt); }\n       ast::ty_rptr(region, mt) {\n-        word(s.s, \"&\");\n-        print_region(s, region);\n+        alt region.node {\n+          ast::re_anon { word(s.s, \"&\"); }\n+          _ { print_region(s, region); word(s.s, \".\"); }\n+        }\n         print_mt(s, mt);\n       }\n       ast::ty_rec(fields) {\n@@ -556,9 +561,10 @@ fn print_item(s: ps, &&item: @ast::item) {\n           }\n           bclose(s, item.span);\n        }\n-      ast::item_impl(tps, ifce, ty, methods) {\n+      ast::item_impl(tps, rp, ifce, ty, methods) {\n         head(s, \"impl\");\n         word(s.s, item.ident);\n+        print_region_param(s, rp);\n         print_type_params(s, tps);\n         space(s.s);\n         option::iter(ifce, {|p|\n@@ -575,9 +581,10 @@ fn print_item(s: ps, &&item: @ast::item) {\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_iface(tps, methods) {\n+      ast::item_iface(tps, rp, methods) {\n         head(s, \"iface\");\n         word(s.s, item.ident);\n+        print_region_param(s, rp);\n         print_type_params(s, tps);\n         word(s.s, \" \");\n         bopen(s);\n@@ -831,16 +838,7 @@ fn print_vstore(s: ps, t: ast::vstore) {\n       ast::vstore_fixed(none) { word_space(s, \"/_\"); }\n       ast::vstore_uniq { word_space(s, \"/~\"); }\n       ast::vstore_box { word_space(s, \"/@\"); }\n-      ast::vstore_slice(r) {\n-        alt r.node {\n-          ast::re_anon { word_space(s, \"/&\"); }\n-          ast::re_static { word_space(s, \"/&static\"); }\n-          ast::re_named(name) {\n-            word(s.s, \"/&\");\n-            word_space(s, name);\n-          }\n-        }\n-      }\n+      ast::vstore_slice(r) { word(s.s, \"/\"); print_region(s, r); }\n     }\n }\n \n@@ -1225,11 +1223,22 @@ fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n         if first { first = false; } else { word(s.s, \"::\"); }\n         word(s.s, id);\n     }\n-    if vec::len(path.types) > 0u {\n+    if path.rp.is_some() || !path.types.is_empty() {\n         if colons_before_params { word(s.s, \"::\"); }\n-        word(s.s, \"<\");\n-        commasep(s, inconsistent, path.types, print_type);\n-        word(s.s, \">\");\n+\n+        alt path.rp {\n+          none { /* ok */ }\n+          some(r) {\n+            word(s.s, \"/\");\n+            print_region(s, r);\n+          }\n+        }\n+\n+        if !path.types.is_empty() {\n+            word(s.s, \"<\");\n+            commasep(s, inconsistent, path.types, print_type);\n+            word(s.s, \">\");\n+        }\n     }\n }\n "}, {"sha": "04b6c002cb2bc7d09b8793f62d74071bf5ffed34", "filename": "src/librustsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Flibrustsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fvisit.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -132,7 +132,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n             for vr.node.args.each {|va| v.visit_ty(va.ty, e, v); }\n         }\n       }\n-      item_impl(tps, ifce, ty, methods) {\n+      item_impl(tps, _rp, ifce, ty, methods) {\n         v.visit_ty_params(tps, e, v);\n         option::iter(ifce, {|p| visit_path(p.path, e, v)});\n         v.visit_ty(ty, e, v);\n@@ -149,7 +149,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n           visit_class_ctor_helper(ctor, i.ident, tps,\n                                   ast_util::local_def(i.id), e, v);\n       }\n-      item_iface(tps, methods) {\n+      item_iface(tps, _rp, methods) {\n         v.visit_ty_params(tps, e, v);\n         for methods.each {|m|\n             for m.decl.inputs.each {|a| v.visit_ty(a.ty, e, v); }"}, {"sha": "258c49daa9d0cf26a894932810864e06bc944770", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -207,7 +207,7 @@ fn nospan<T: copy>(t: T) -> ast::spanned<T> {\n }\n \n fn path_node(ids: [ast::ident]) -> @ast::path {\n-    @{span: dummy_sp(), global: false, idents: ids, types: []}\n+    @{span: dummy_sp(), global: false, idents: ids, rp: none, types: []}\n }\n \n fn mk_tests(cx: test_ctxt) -> @ast::item {"}, {"sha": "a1c996dccf1457ff199754c428fd10b04a18d1cf", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -185,14 +185,14 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n             ebml_w.end_tag();\n             encode_enum_variant_paths(ebml_w, variants, path, index);\n           }\n-          item_iface(_, _) {\n+          item_iface(*) {\n             add_to_index(ebml_w, path, index, it.ident);\n             ebml_w.start_tag(tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml_w.end_tag();\n           }\n-          item_impl(_, _, _, _) {}\n+          item_impl(*) {}\n         }\n     }\n }\n@@ -649,11 +649,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n-      item_impl(tps, ifce, _, methods) {\n+      item_impl(tps, rp, ifce, _, methods) {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'i');\n+        encode_region_param(ebml_w, rp);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n@@ -681,11 +682,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                    should_inline(m.attrs), item.id, m, tps + m.tps);\n         }\n       }\n-      item_iface(tps, ms) {\n+      item_iface(tps, rp, ms) {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'I');\n+        encode_region_param(ebml_w, rp);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);"}, {"sha": "46c39256938b9b0075434bbc2155310fca223802", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -104,7 +104,8 @@ fn parse_path(st: @pstate) -> @ast::path {\n           c {\n             if c == '(' {\n                 ret @{span: ast_util::dummy_sp(),\n-                      global: false, idents: idents, types: []};\n+                      global: false, idents: idents,\n+                      rp: none, types: []};\n             } else { idents += [parse_ident_(st, is_last)]; }\n           }\n         }\n@@ -286,23 +287,21 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         ret ty::mk_enum(st.tcx, def, substs);\n       }\n       'x' {\n-        assert (next(st) == '[');\n+        assert next(st) == '[';\n         let def = parse_def(st, conv);\n-        let mut params: [ty::t] = [];\n-        while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n-        st.pos = st.pos + 1u;\n-        ret ty::mk_iface(st.tcx, def, params);\n+        let substs = parse_substs(st, conv);\n+        assert next(st) == ']';\n+        ret ty::mk_iface(st.tcx, def, substs);\n       }\n       'p' {\n         let did = parse_def(st, conv);\n         ret ty::mk_param(st.tcx, parse_int(st) as uint, did);\n       }\n       's' {\n         assert next(st) == '[';\n-        let mut params = [];\n-        while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n-        st.pos += 1u;\n-        ret ty::mk_self(st.tcx, params);\n+        let substs = parse_substs(st, conv);\n+        assert next(st) == ']';\n+        ret ty::mk_self(st.tcx, substs);\n       }\n       '@' { ret ty::mk_box(st.tcx, parse_mt(st, conv)); }\n       '~' { ret ty::mk_uniq(st.tcx, parse_mt(st, conv)); }\n@@ -344,7 +343,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         parse_ty_rust_fn(st, conv, proto)\n       }\n       'r' {\n-        assert (next(st) == '[');\n+        assert next(st) == '[';\n         let def = parse_def(st, conv);\n         let inner = parse_ty(st, conv);\n         let substs = parse_substs(st, conv);"}, {"sha": "130e7f409168f75acdf444e062050a28d1962da8", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -220,11 +220,11 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n-      ty::ty_iface(def, tys) {\n+      ty::ty_iface(def, substs) {\n         w.write_str(\"x[\"/&);\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n-        for tys.each {|t| enc_ty(w, cx, t); }\n+        enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n       ty::ty_tup(ts) {\n@@ -281,9 +281,9 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_char('|');\n         w.write_str(uint::str(id));\n       }\n-      ty::ty_self(tps) {\n+      ty::ty_self(substs) {\n         w.write_str(\"s[\"/&);\n-        for tps.each {|t| enc_ty(w, cx, t); }\n+        enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n       ty::ty_type { w.write_char('Y'); }"}, {"sha": "f2300f9695a55f7baad6daa7589a2d3f1f6e30c8", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -177,7 +177,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n     let item_path = @cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     alt i.node {\n-      item_impl(_, _, _, ms) {\n+      item_impl(_, _, _, _, ms) {\n         let impl_did = ast_util::local_def(i.id);\n         for ms.each {|m|\n             map_method(impl_did, extend(cx, i.ident), m, cx);"}, {"sha": "d5e22815b7b47096956ee2ab7b88158960c1c22b", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -15,6 +15,7 @@ import util::common::{indent, indenter};\n export infer_ctxt;\n export new_infer_ctxt;\n export mk_subty;\n+export mk_subr;\n export mk_eqty;\n export mk_assignty;\n export resolve_shallow;\n@@ -73,6 +74,11 @@ fn mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     indent {|| cx.commit {|| sub(cx).tys(a, b) } }.to_ures()\n }\n \n+fn mk_subr(cx: infer_ctxt, a: ty::region, b: ty::region) -> ures {\n+    #debug[\"mk_subr(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n+    indent {|| cx.commit {|| sub(cx).regions(a, b) } }.to_ures()\n+}\n+\n fn mk_eqty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     #debug[\"mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n     indent {|| cx.commit {|| cx.eq_tys(a, b) } }.to_ures()\n@@ -1120,10 +1126,10 @@ fn super_tys<C:combine>(\n         }\n       }\n \n-      (ty::ty_iface(a_id, a_tps), ty::ty_iface(b_id, b_tps))\n+      (ty::ty_iface(a_id, a_substs), ty::ty_iface(b_id, b_substs))\n       if a_id == b_id {\n-        self.tps(a_tps, b_tps).chain {|tps|\n-            ok(ty::mk_iface(tcx, a_id, tps))\n+        self.substs(a_substs, b_substs).chain {|substs|\n+            ok(ty::mk_iface(tcx, a_id, substs))\n         }\n       }\n "}, {"sha": "150466a70978b96dd1d0a8d0efd6ecb91b8f7028", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -435,14 +435,14 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           non-class items\n          */\n         alt i.node {\n-           ast::item_class(_, ifaces, _, _, _) {\n-             /* visit the iface paths... */\n-              for ifaces.each {|p| resolve_iface_ref(p, sc, e)};\n-           }\n-           ast::item_impl(_, ifce, _, _) {\n-               option::iter(ifce, {|p| resolve_iface_ref(p, sc, e)});\n-           }\n-           _ {}\n+          ast::item_class(_, ifaces, _, _, _) {\n+            /* visit the iface paths... */\n+            for ifaces.each {|p| resolve_iface_ref(p, sc, e) ;}\n+          }\n+          ast::item_impl(_, _, ifce, _, _) {\n+            ifce.iter { |p| resolve_iface_ref(p, sc, e); }\n+          }\n+          _ {}\n         }\n     }\n \n@@ -540,7 +540,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n \n     let sc = cons(scope_item(i), @sc);\n     alt i.node {\n-      ast::item_impl(tps, ifce, sty, methods) {\n+      ast::item_impl(tps, _, ifce, sty, methods) {\n         visit::visit_ty_params(tps, sc, v);\n         option::iter(ifce) {|p| visit::visit_path(p.path, sc, v)};\n         v.visit_ty(sty, sc, v);\n@@ -551,7 +551,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n                        m.decl, m.body, m.span, m.id, msc, v);\n         }\n       }\n-      ast::item_iface(tps, methods) {\n+      ast::item_iface(tps, _, methods) {\n         visit::visit_ty_params(tps, sc, v);\n         for methods.each {|m|\n             let msc = cons(scope_method(i.id, tps + m.tps), @sc);\n@@ -1008,13 +1008,13 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace,\n           }\n           scope_item(it) {\n             alt it.node {\n-              ast::item_impl(tps, _, _, _) {\n+              ast::item_impl(tps, _, _, _, _) {\n                 if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n               }\n               ast::item_enum(_, tps, _) | ast::item_ty(_, tps, _) {\n                 if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n               }\n-              ast::item_iface(tps, _) {\n+              ast::item_iface(tps, _, _) {\n                 if ns == ns_type {\n                     if name == \"self\" {\n                         ret some(def_self(it.id));\n@@ -1286,7 +1286,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n \n fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n     alt i.node {\n-      ast::item_const(_, _) {\n+      ast::item_const(*) {\n         if ns == ns_val {\n             ret some(ast::def_const(local_def(i.id))); }\n       }\n@@ -1301,7 +1301,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n       ast::item_native_mod(_) {\n         if ns == ns_module { ret some(ast::def_native_mod(local_def(i.id))); }\n       }\n-      ast::item_ty(_, _, _) | item_iface(_, _) | item_enum(_, _, _) {\n+      ast::item_ty(*) | item_iface(*) | item_enum(*) {\n         if ns == ns_type { ret some(ast::def_ty(local_def(i.id))); }\n       }\n       ast::item_res(_, _, _, _, ctor_id, _) {\n@@ -1313,12 +1313,12 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n           _ { }\n         }\n       }\n-      ast::item_class(_, _, _, _, _) {\n+      ast::item_class(*) {\n           if ns == ns_type {\n             ret some(ast::def_class(local_def(i.id)));\n           }\n       }\n-      ast::item_impl(_,_,_,_) { /* ??? */ }\n+      ast::item_impl(*) { /* ??? */ }\n     }\n     ret none;\n }\n@@ -1607,8 +1607,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n         alt it.node {\n           ast::item_const(_, _) | ast::item_fn(_, _, _) | ast::item_mod(_) |\n           ast::item_native_mod(_) | ast::item_ty(_, _, _) |\n-          ast::item_res(_, _, _, _, _, _) |\n-          ast::item_impl(_, _, _, _) | ast::item_iface(_, _) {\n+          ast::item_res(*) | ast::item_impl(*) | ast::item_iface(*) {\n             add_to_index(index, it.ident, mie_item(it));\n           }\n           ast::item_enum(variants, _, _) {\n@@ -1753,11 +1752,11 @@ fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n         ensure_unique(*e, i.span, ty_params, {|tp| tp.ident},\n                       \"type parameter\");\n       }\n-      ast::item_iface(_, methods) {\n+      ast::item_iface(_, _, methods) {\n         ensure_unique(*e, i.span, methods, {|m| m.ident},\n                       \"method\");\n       }\n-      ast::item_impl(_, _, _, methods) {\n+      ast::item_impl(_, _, _, _, methods) {\n         ensure_unique(*e, i.span, methods, {|m| m.ident},\n                       \"method\");\n       }\n@@ -1832,13 +1831,13 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n                   ast::item_mod(_) | ast::item_native_mod(_) {\n                     add_name(mods, it.span, it.ident);\n                   }\n-                  ast::item_const(_, _) | ast::item_fn(_, _, _) {\n+                  ast::item_const(_, _) | ast::item_fn(*) {\n                     add_name(values, it.span, it.ident);\n                   }\n-                  ast::item_ty(_, _, _) | ast::item_iface(_, _) {\n+                  ast::item_ty(*) | ast::item_iface(*) {\n                     add_name(types, it.span, it.ident);\n                   }\n-                  ast::item_res(_, _, _, _, _, _) {\n+                  ast::item_res(*) {\n                     add_name(types, it.span, it.ident);\n                     add_name(values, it.span, it.ident);\n                   }\n@@ -2196,7 +2195,7 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl],\n                       name: option<ident>,\n                       ck_exports: option<@indexed_mod>) {\n     alt i.node {\n-      ast::item_impl(_, ifce, _, mthds) {\n+      ast::item_impl(_, _, ifce, _, mthds) {\n         if alt name { some(n) { n == i.ident } _ { true } } &&\n            alt ck_exports {\n              some(m) { is_exported(e, i.ident, m) }"}, {"sha": "6f05a0df434889906322830fa29c6f36d092a887", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -4477,7 +4477,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             }\n         }\n       }\n-      ast::item_impl(tps, _, _, ms) {\n+      ast::item_impl(tps, _rp, _, _, ms) {\n         impl::trans_impl(ccx, *path, item.ident, ms, tps);\n       }\n       ast::item_res(decl, tps, body, dtor_id, ctor_id, _) {"}, {"sha": "b511d653bdf3db5b536a869c60b2944be9cb8646", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -90,7 +90,7 @@ fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n                     name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n         alt check ccx.tcx.items.get(impl_id.node) {\n-          ast_map::node_item(@{node: ast::item_impl(_, _, _, ms), _}, _) {\n+          ast_map::node_item(@{node: ast::item_impl(_, _, _, _, ms), _}, _) {\n             method_from_methods(ms, name)\n           }\n           ast_map::node_item(@{node:"}, {"sha": "bd4800c970abe842edcda944ddda9e9bfced6720", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -94,7 +94,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             traverse_inline_body(cx, blk);\n         }\n       }\n-      item_impl(tps, _, _, ms) {\n+      item_impl(tps, _, _, _, ms) {\n         for vec::each(ms) {|m|\n             if tps.len() > 0u || m.tps.len() > 0u ||\n                attr::find_inline_attr(m.attrs) != attr::ia_none {\n@@ -117,8 +117,8 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             }\n         }\n       }\n-      item_const(_, _) | item_ty(_, _, _) |\n-      item_enum(_, _, _) | item_iface(_, _) {}\n+      item_const(*) | item_ty(*) |\n+      item_enum(*) | item_iface(*) {}\n     }\n }\n "}, {"sha": "4cc00940202da2b6a4a91f49ca03998debc33d4e", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -48,7 +48,7 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n       }\n       item_mod(m) { find_pre_post_mod(m); }\n       item_native_mod(nm) { find_pre_post_native_mod(nm); }\n-      item_ty(_, _, _) | item_enum(_, _, _) | item_iface(_, _) { ret; }\n+      item_ty(*) | item_enum(*) | item_iface(*) { ret; }\n       item_res(_, _, body, dtor_id, _, _) {\n         let fcx =\n             {enclosing: ccx.fm.get(dtor_id),\n@@ -60,7 +60,7 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n       item_class(_,_,_,_,_) {\n           fail \"find_pre_post_item: shouldn't be called on item_class\";\n       }\n-      item_impl(_, _, _, ms) {\n+      item_impl(_, _, _, _, ms) {\n         for ms.each {|m| find_pre_post_method(ccx, m); }\n       }\n     }"}, {"sha": "9830fe9c36b1392001e45ea0a5aba9bd9fdeec7b", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -325,14 +325,14 @@ enum sty {\n     ty_rptr(region, mt),\n     ty_rec([field]),\n     ty_fn(fn_ty),\n-    ty_iface(def_id, [t]),\n+    ty_iface(def_id, substs),\n     ty_class(def_id, substs),\n     ty_res(def_id, t, substs),\n     ty_tup([t]),\n \n     ty_var(ty_vid), // type variable during typechecking\n     ty_param(uint, def_id), // type parameter\n-    ty_self([t]), // interface method self type\n+    ty_self(substs), // interface method self type\n \n     ty_type, // type_desc*\n     ty_opaque_box, // used by monomorphizer to represent any @ box\n@@ -520,16 +520,10 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       ty_opaque_box {}\n       ty_param(_, _) { has_params = true; }\n       ty_var(_) | ty_self(_) { has_vars = true; }\n-      ty_enum(_, substs) | ty_class(_, substs) {\n+      ty_enum(_, substs) | ty_class(_, substs) | ty_iface(_, substs) {\n         derive_sflags(has_params, has_vars, has_regions,\n                       has_resources, substs);\n       }\n-      ty_iface(_, tys) {\n-        for tys.each {|tt|\n-            derive_flags(has_params, has_vars, has_regions,\n-                         has_resources, tt);\n-        }\n-      }\n       ty_box(m) | ty_uniq(m) | ty_vec(m) | ty_evec(m, _) | ty_ptr(m) {\n         derive_flags(has_params, has_vars, has_regions,\n                      has_resources, m.ty);\n@@ -652,8 +646,8 @@ fn mk_tup(cx: ctxt, ts: [t]) -> t { mk_t(cx, ty_tup(ts)) }\n \n fn mk_fn(cx: ctxt, fty: fn_ty) -> t { mk_t(cx, ty_fn(fty)) }\n \n-fn mk_iface(cx: ctxt, did: ast::def_id, tys: [t]) -> t {\n-    mk_t(cx, ty_iface(did, tys))\n+fn mk_iface(cx: ctxt, did: ast::def_id, substs: substs) -> t {\n+    mk_t(cx, ty_iface(did, substs))\n }\n \n fn mk_class(cx: ctxt, class_id: ast::def_id, substs: substs) -> t {\n@@ -667,7 +661,7 @@ fn mk_res(cx: ctxt, did: ast::def_id,\n \n fn mk_var(cx: ctxt, v: ty_vid) -> t { mk_t(cx, ty_var(v)) }\n \n-fn mk_self(cx: ctxt, tps: [t]) -> t { mk_t(cx, ty_self(tps)) }\n+fn mk_self(cx: ctxt, substs: substs) -> t { mk_t(cx, ty_self(substs)) }\n \n fn mk_param(cx: ctxt, n: uint, k: def_id) -> t { mk_t(cx, ty_param(n, k)) }\n \n@@ -712,12 +706,10 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n       ty_ptr(tm) | ty_rptr(_, tm) {\n         maybe_walk_ty(tm.ty, f);\n       }\n-      ty_enum(_, substs) | ty_class(_, substs) {\n+      ty_enum(_, substs) | ty_class(_, substs) |\n+      ty_iface(_, substs) | ty_self(substs) {\n         for substs.tps.each {|subty| maybe_walk_ty(subty, f); }\n       }\n-      ty_iface(_, subtys) |ty_self(subtys) {\n-        for subtys.each {|subty| maybe_walk_ty(subty, f); }\n-      }\n       ty_rec(fields) {\n         for fields.each {|fl| maybe_walk_ty(fl.mt.ty, f); }\n       }\n@@ -764,11 +756,11 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n       ty_enum(tid, substs) {\n         ty_enum(tid, fold_substs(substs, fldop))\n       }\n-      ty_iface(did, subtys) {\n-        ty_iface(did, vec::map(subtys) {|t| fldop(t) })\n+      ty_iface(did, substs) {\n+        ty_iface(did, fold_substs(substs, fldop))\n       }\n-      ty_self(subtys) {\n-        ty_self(vec::map(subtys) {|t| fldop(t) })\n+      ty_self(substs) {\n+        ty_self(fold_substs(substs, fldop))\n       }\n       ty_rec(fields) {\n         let new_fields = vec::map(fields) {|fl|\n@@ -864,6 +856,12 @@ fn fold_regions_and_ty(\n       ty_class(def_id, substs) {\n         ty::mk_class(cx, def_id, fold_substs(substs, fldr, fldt))\n       }\n+      ty_iface(def_id, substs) {\n+        ty::mk_iface(cx, def_id, fold_substs(substs, fldr, fldt))\n+      }\n+      ty_self(substs) {\n+        ty::mk_self(cx, fold_substs(substs, fldr, fldt))\n+      }\n       ty_res(def_id, t, substs) {\n         ty::mk_res(cx, def_id, fldt(t),\n                    fold_substs(substs, fldr, fldt))\n@@ -1828,10 +1826,8 @@ fn hash_type_structure(st: sty) -> uint {\n       }\n       ty_var(v) { hash_uint(30u, v.to_uint()) }\n       ty_param(pid, did) { hash_def(hash_uint(31u, pid), did) }\n-      ty_self(ts) {\n-        let mut h = 28u;\n-        for ts.each {|t| h = hash_subty(h, t); }\n-        h\n+      ty_self(substs) {\n+        hash_substs(28u, substs)\n       }\n       ty_type { 32u }\n       ty_bot { 34u }\n@@ -1850,10 +1846,9 @@ fn hash_type_structure(st: sty) -> uint {\n         h\n       }\n       ty_uniq(mt) { hash_subty(37u, mt.ty) }\n-      ty_iface(did, tys) {\n+      ty_iface(did, substs) {\n         let mut h = hash_def(40u, did);\n-        for tys.each {|typ| h = hash_subty(h, typ); }\n-        h\n+        hash_substs(h, substs)\n       }\n       ty_opaque_closure_ptr(ck_block) { 41u }\n       ty_opaque_closure_ptr(ck_box) { 42u }\n@@ -2286,7 +2281,7 @@ fn impl_iface(cx: ctxt, id: ast::def_id) -> option<t> {\n     if id.crate == ast::local_crate {\n         alt cx.items.find(id.node) {\n            some(ast_map::node_item(@{node: ast::item_impl(\n-              _, some(@{id: id, _}), _, _), _}, _)) {\n+              _, _, some(@{id: id, _}), _, _), _}, _)) {\n               some(node_id_to_type(cx, id))\n            }\n            some(ast_map::node_item(@{node: ast::item_class(_, _, _, _, _),"}, {"sha": "69936c35b601a7698429ce9fc54e541d4c2302e5", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 386, "deletions": 297, "changes": 683, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -22,7 +22,7 @@ import std::serialization::{serialize_uint, deserialize_uint};\n import std::ufind;\n import vec::each;\n import syntax::print::pprust::*;\n-import util::common::indent;\n+import util::common::{indent, indenter};\n import std::list;\n import list::{list, nil, cons};\n \n@@ -472,7 +472,7 @@ fn get_region_reporting_err(tcx: ty::ctxt,\n }\n \n fn ast_region_to_region<AC: ast_conv, RS: region_scope>(\n-    self: AC, rscope: RS, span: span, a_r: ast::region) -> ty::region {\n+    self: AC, rscope: RS, span: span, a_r: @ast::region) -> ty::region {\n \n     let res = alt a_r.node {\n       ast::re_anon { rscope.anon_region() }\n@@ -483,64 +483,93 @@ fn ast_region_to_region<AC: ast_conv, RS: region_scope>(\n     get_region_reporting_err(self.tcx(), span, res)\n }\n \n-fn instantiate<AC: ast_conv, RS: region_scope copy>(\n-        self: AC, rscope: RS, sp: span, id: ast::def_id,\n-        path_id: ast::node_id, args: [@ast::ty]) -> ty::t {\n+fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy>(\n+    self: AC, rscope: RS, did: ast::def_id,\n+    path: @ast::path) -> ty_param_substs_and_ty {\n \n-        let tcx = self.tcx();\n-        let {bounds, rp, ty} = self.get_item_ty(id);\n+    let tcx = self.tcx();\n+    let {bounds: decl_bounds, rp: decl_rp, ty: decl_ty} =\n+        self.get_item_ty(did);\n+\n+    // If the type is parameterized by the self region, then replace self\n+    // region with the current anon region binding (in other words,\n+    // whatever & would get replaced with).\n+    let self_r = alt (decl_rp, path.rp) {\n+      (ast::rp_none, none) {\n+        none\n+      }\n+      (ast::rp_none, some(_)) {\n+        tcx.sess.span_err(\n+            path.span,\n+            #fmt[\"No region bound is permitted on %s, \\\n+                  which is not declared as containing region pointers\",\n+                 ty::item_path_str(tcx, did)]);\n+        none\n+      }\n+      (ast::rp_self, none) {\n+        let res = rscope.anon_region();\n+        let r = get_region_reporting_err(self.tcx(), path.span, res);\n+        some(r)\n+      }\n+      (ast::rp_self, some(r)) {\n+        some(ast_region_to_region(self, rscope, path.span, r))\n+      }\n+    };\n \n-        // If the type is parameterized by the self region, then replace self\n-        // region with the current anon region binding (in other words,\n-        // whatever & would get replaced with).\n-        let self_r = alt rp {\n-          ast::rp_none { none }\n-          ast::rp_self {\n-            let res = rscope.anon_region();\n-            let r = get_region_reporting_err(self.tcx(), sp, res);\n-            some(r)\n-          }\n-        };\n+    // Convert the type parameters supplied by the user.\n+    if !vec::same_length(*decl_bounds, path.types) {\n+        self.tcx().sess.span_fatal(\n+            path.span,\n+            #fmt[\"wrong number of type arguments, expected %u but found %u\",\n+                 (*decl_bounds).len(), path.types.len()]);\n+    }\n+    let tps = path.types.map { |a_t| ast_ty_to_ty(self, rscope, a_t) };\n \n-        // Convert the type parameters supplied by the user.\n-        if vec::len(args) != vec::len(*bounds) {\n-            tcx.sess.span_fatal(\n-                sp, #fmt[\"wrong number of type arguments, \\\n-                          expected %u but found %u\",\n-                         vec::len(*bounds),\n-                         vec::len(args)]);\n-        }\n-        let tps = args.map { |t| ast_ty_to_ty(self, rscope, t) };\n+    let substs = {self_r: self_r, tps: tps};\n+    {substs: substs, ty: ty::subst(tcx, substs, decl_ty)}\n+}\n+\n+fn ast_path_to_ty<AC: ast_conv, RS: region_scope copy>(\n+    self: AC,\n+    rscope: RS,\n+    did: ast::def_id,\n+    path: @ast::path,\n+    path_id: ast::node_id) -> ty_param_substs_and_ty {\n \n-        // Perform the substitution and store the tps for future ref.\n-        let substs = {self_r: self_r, tps: tps};\n-        let ty = ty::subst(tcx, substs, ty);\n-        write_substs_to_tcx(tcx, path_id, substs.tps);\n-        ret ty;\n+    // Lookup the polytype of the item and then substitute the provided types\n+    // for any type/region parameters.\n+    let tcx = self.tcx();\n+    let {substs: substs, ty: ty} =\n+        ast_path_to_substs_and_ty(self, rscope, did, path);\n+    write_ty_to_tcx(tcx, path_id, ty);\n+    write_substs_to_tcx(tcx, path_id, substs.tps);\n+    ret {substs: substs, ty: ty};\n }\n \n /*\n   Instantiates the path for the given iface reference, assuming that\n   it's bound to a valid iface type. Returns the def_id for the defining\n   iface\n  */\n-fn instantiate_iface_ref(ccx: @crate_ctxt, t: @ast::iface_ref)\n-    -> ast::def_id {\n+fn instantiate_iface_ref(ccx: @crate_ctxt, t: @ast::iface_ref,\n+                         rp: ast::region_param)\n+    -> (ast::def_id, ty_param_substs_and_ty) {\n+\n     alt lookup_def_tcx(ccx.tcx, t.path.span, t.id) {\n-       ast::def_ty(t_id) {\n-         // tjc: will probably need to refer to\n-         // impl or class ty params too\n-         instantiate(ccx, empty_rscope, t.path.span, t_id, t.id,\n-                     t.path.types);\n-         t_id\n-       }\n-       _ {\n-          ccx.tcx.sess.span_fatal(t.path.span,\n-                     \"can only implement interface types\");\n-       }\n+      ast::def_ty(t_id) {\n+        (t_id, ast_path_to_ty(ccx, type_rscope(rp), t_id, t.path, t.id))\n+      }\n+      _ {\n+        ccx.tcx.sess.span_fatal(\n+            t.path.span,\n+            \"can only implement interface types\");\n+      }\n     }\n }\n \n+const NO_REGIONS: uint = 1u;\n+const NO_TPS: uint = 2u;\n+\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n@@ -553,7 +582,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n         ret {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl};\n     }\n \n-    fn mk_bounded<AC: ast_conv, RS: region_scope copy>(\n+    fn mk_vstore<AC: ast_conv, RS: region_scope copy>(\n         self: AC, rscope: RS, a_seq_ty: @ast::ty, vst: ty::vstore) -> ty::t {\n \n         let tcx = self.tcx();\n@@ -568,39 +597,6 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n             ret ty::mk_estr(tcx, vst);\n           }\n \n-          ty::ty_enum(_, subst) |\n-          ty::ty_class(_, subst) |\n-          ty::ty_res(_, _, subst) {\n-            // n.b.: This is a hacky abuse of the vstore terminology to also\n-            // make it work for region bounds.  The idea is to allow a type\n-            // Id/&r where Id is an enum, class, or resource, but not Id/@\n-            // etc.  We also do not want to allow Id/&r if the given\n-            // enum/class/resource does not define a region parameter.\n-            //\n-            // Really, these \"/&r\" bounds ought to be part of the path, like\n-            // type parameters.  (In fact, we could generalize to allowing\n-            // multiple such bounds someday)\n-            alt (subst.self_r, vst) {\n-              (some(_), ty::vstore_slice(_)) { /* ok */ }\n-              (none, ty::vstore_slice(_)) {\n-                tcx.sess.span_err(\n-                    a_seq_ty.span,\n-                    #fmt[\"inappropriate bound for %s, \\\n-                          which is not declared as containing \\\n-                          region pointers\",\n-                         ty::ty_sort_str(tcx, seq_ty)]);\n-              }\n-              (_, _) {\n-                tcx.sess.span_err(\n-                    a_seq_ty.span,\n-                    #fmt[\"a %s bound is not appropriate for %s\",\n-                         vstore_to_str(tcx, vst),\n-                         ty::ty_sort_str(tcx, seq_ty)]);\n-              }\n-            }\n-            ret seq_ty;\n-          }\n-\n           _ {\n             tcx.sess.span_err(\n                 a_seq_ty.span,\n@@ -611,6 +607,26 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n         }\n     }\n \n+    fn check_path_args(tcx: ty::ctxt,\n+                       path: @ast::path,\n+                       flags: uint) {\n+        if (flags & NO_TPS) != 0u {\n+            if path.types.len() > 0u {\n+                tcx.sess.span_err(\n+                    path.span,\n+                    \"Type parameters are not allowed on this type.\");\n+            }\n+        }\n+\n+        if (flags & NO_REGIONS) != 0u {\n+            if path.rp.is_some() {\n+                tcx.sess.span_err(\n+                    path.span,\n+                    \"Region parameters are not allowed on this type.\");\n+            }\n+        }\n+    }\n+\n     let tcx = self.tcx();\n \n     alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n@@ -665,37 +681,52 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n           some(d) { d }};\n         alt a_def {\n           ast::def_ty(did) | ast::def_class(did) {\n-            instantiate(self, rscope, ast_ty.span, did, id, path.types)\n+            ast_path_to_ty(self, rscope, did, path, id).ty\n           }\n           ast::def_prim_ty(nty) {\n             alt nty {\n-              ast::ty_bool { ty::mk_bool(tcx) }\n-              ast::ty_int(it) { ty::mk_mach_int(tcx, it) }\n-              ast::ty_uint(uit) { ty::mk_mach_uint(tcx, uit) }\n-              ast::ty_float(ft) { ty::mk_mach_float(tcx, ft) }\n-              ast::ty_str { ty::mk_str(tcx) }\n+              ast::ty_bool {\n+                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                ty::mk_bool(tcx)\n+              }\n+              ast::ty_int(it) {\n+                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                ty::mk_mach_int(tcx, it)\n+              }\n+              ast::ty_uint(uit) {\n+                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                ty::mk_mach_uint(tcx, uit)\n+              }\n+              ast::ty_float(ft) {\n+                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                ty::mk_mach_float(tcx, ft)\n+              }\n+              ast::ty_str {\n+                check_path_args(tcx, path, NO_TPS);\n+                // This is a bit of a hack, but basically str/& needs to be\n+                // converted into a vstore:\n+                alt path.rp {\n+                  none {\n+                    ty::mk_str(tcx)\n+                  }\n+                  some(ast_r) {\n+                    let r = ast_region_to_region(self, rscope,\n+                                                 ast_ty.span, ast_r);\n+                    ty::mk_estr(tcx, ty::vstore_slice(r))\n+                  }\n+                }\n+              }\n             }\n           }\n           ast::def_ty_param(id, n) {\n-            if vec::len(path.types) > 0u {\n-                tcx.sess.span_err(ast_ty.span, \"provided type parameters \\\n-                                                to a type parameter\");\n-            }\n+            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n             ty::mk_param(tcx, n, id)\n           }\n           ast::def_self(self_id) {\n-            alt check tcx.items.get(self_id) {\n-              ast_map::node_item(@{node: ast::item_iface(tps, _), _}, _) {\n-                if vec::len(tps) != vec::len(path.types) {\n-                    tcx.sess.span_err(ast_ty.span, \"incorrect number of \\\n-                                                    type parameters to \\\n-                                                    self type\");\n-                }\n-                ty::mk_self(tcx, vec::map(path.types, {|ast_ty|\n-                    ast_ty_to_ty(self, rscope, ast_ty)\n-                }))\n-              }\n-            }\n+            let {substs, ty: _} =\n+                ast_path_to_substs_and_ty(self, rscope,\n+                                          local_def(self_id), path);\n+            ty::mk_self(tcx, substs)\n           }\n           _ {\n             tcx.sess.span_fatal(ast_ty.span,\n@@ -705,16 +736,16 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n       }\n       ast::ty_vstore(a_t, ast::vstore_slice(a_r)) {\n         let r = ast_region_to_region(self, rscope, ast_ty.span, a_r);\n-        mk_bounded(self, in_anon_rscope(rscope, r), a_t, ty::vstore_slice(r))\n+        mk_vstore(self, in_anon_rscope(rscope, r), a_t, ty::vstore_slice(r))\n       }\n       ast::ty_vstore(a_t, ast::vstore_uniq) {\n-        mk_bounded(self, rscope, a_t, ty::vstore_uniq)\n+        mk_vstore(self, rscope, a_t, ty::vstore_uniq)\n       }\n       ast::ty_vstore(a_t, ast::vstore_box) {\n-        mk_bounded(self, rscope, a_t, ty::vstore_box)\n+        mk_vstore(self, rscope, a_t, ty::vstore_box)\n       }\n       ast::ty_vstore(a_t, ast::vstore_fixed(some(u))) {\n-        mk_bounded(self, rscope, a_t, ty::vstore_fixed(u))\n+        mk_vstore(self, rscope, a_t, ty::vstore_fixed(u))\n       }\n       ast::ty_vstore(_, ast::vstore_fixed(none)) {\n         tcx.sess.span_bug(\n@@ -790,7 +821,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n       }\n       ast::item_res(decl, tps, _, _, _, rp) {\n         let {bounds, substs} = mk_substs(ccx, tps, rp);\n-        let t_arg = ty_of_arg(ccx, empty_rscope, decl.inputs[0]);\n+        let t_arg = ty_of_arg(ccx, type_rscope(rp), decl.inputs[0]);\n         let t = ty::mk_res(tcx, local_def(it.id), t_arg.ty, substs);\n         let t_res = {bounds: bounds, rp: rp, ty: t};\n         tcx.tcache.insert(local_def(it.id), t_res);\n@@ -804,11 +835,10 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_iface(tps, ms) {\n-        let {bounds, params} = mk_ty_params(ccx, tps);\n-        let t = ty::mk_iface(tcx, local_def(it.id), params);\n-        // NDM iface/impl regions\n-        let tpt = {bounds: bounds, rp: ast::rp_none, ty: t};\n+      ast::item_iface(tps, rp, ms) {\n+        let {bounds, substs} = mk_substs(ccx, tps, rp);\n+        let t = ty::mk_iface(tcx, local_def(it.id), substs);\n+        let tpt = {bounds: bounds, rp: rp, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n@@ -819,7 +849,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n           tcx.tcache.insert(local_def(it.id), tpt);\n           ret tpt;\n       }\n-      ast::item_impl(_, _, _, _) | ast::item_mod(_) |\n+      ast::item_impl(*) | ast::item_mod(_) |\n       ast::item_native_mod(_) { fail; }\n     }\n }\n@@ -1040,15 +1070,19 @@ fn ty_param_bounds(ccx: @crate_ctxt,\n fn ty_of_method(ccx: @crate_ctxt,\n                 m: @ast::method,\n                 rp: ast::region_param) -> ty::method {\n-    {ident: m.ident, tps: ty_param_bounds(ccx, m.tps),\n+    {ident: m.ident,\n+     tps: ty_param_bounds(ccx, m.tps),\n      fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare, m.decl),\n-     purity: m.decl.purity, privacy: m.privacy}\n+     purity: m.decl.purity,\n+     privacy: m.privacy}\n }\n \n-fn ty_of_ty_method(self: @crate_ctxt, m: ast::ty_method) -> ty::method {\n+fn ty_of_ty_method(self: @crate_ctxt,\n+                   m: ast::ty_method,\n+                   rp: ast::region_param) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(self, m.tps),\n-     fty: ty_of_fn_decl(self, empty_rscope, ast::proto_bare, m.decl),\n+     fty: ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare, m.decl),\n      // assume public, because this is only invoked on iface methods\n      purity: m.decl.purity, privacy: ast::pub}\n }\n@@ -1180,6 +1214,14 @@ impl methods for @fn_ctxt {\n                  self.ty_to_str(a),\n                  ty::type_err_to_str(self.ccx.tcx, err)]);\n     }\n+\n+    fn mk_subty(sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n+        infer::mk_subty(self.infcx, sub, sup)\n+    }\n+\n+    fn mk_eqty(sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n+        infer::mk_eqty(self.infcx, sub, sup)\n+    }\n }\n \n fn mk_ty_params(ccx: @crate_ctxt, atps: [ast::ty_param])\n@@ -1207,7 +1249,7 @@ fn mk_substs(ccx: @crate_ctxt, atps: [ast::ty_param], rp: ast::region_param)\n }\n \n fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n-                       impl_tps: uint, if_m: ty::method, substs: [ty::t],\n+                       impl_tps: uint, if_m: ty::method, substs: ty::substs,\n                        self_ty: ty::t) -> ty::t {\n \n     if impl_m.tps != if_m.tps {\n@@ -1234,11 +1276,14 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n         let impl_fty = ty::mk_fn(tcx, {inputs: auto_modes with impl_m.fty});\n \n         // Add dummy substs for the parameters of the impl method\n-        let substs = substs + vec::from_fn(vec::len(*if_m.tps), {|i|\n-            ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n-        });\n+        let substs = {\n+            self_r: substs.self_r,\n+            tps: substs.tps + vec::from_fn(vec::len(*if_m.tps), {|i|\n+                ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n+            })\n+        };\n         let mut if_fty = ty::mk_fn(tcx, if_m.fty);\n-        if_fty = ty::subst_tps(tcx, substs, if_fty);\n+        if_fty = ty::subst(tcx, substs, if_fty);\n         if_fty = fixup_self_full(tcx, if_fty, substs, self_ty, impl_tps);\n         require_same_types(\n             tcx, sp, impl_fty, if_fty,\n@@ -1253,38 +1298,45 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n // because the type parameters of ifaces and impls are not required to line up\n // (an impl can have less or more parameters than the iface it implements), so\n // some mangling of the substituted types is required.\n-fn fixup_self_full(cx: ty::ctxt, mty: ty::t, m_substs: [ty::t],\n+fn fixup_self_full(cx: ty::ctxt, mty: ty::t, m_substs: ty::substs,\n                    selfty: ty::t, impl_n_tps: uint) -> ty::t {\n \n     if !ty::type_has_vars(mty) { ret mty; }\n \n     ty::fold_ty(cx, mty) {|t|\n         alt ty::get(t).struct {\n-          ty::ty_self(tps) if vec::len(tps) == 0u { selfty }\n-          ty::ty_self(tps) {\n+          ty::ty_self(substs) if ty::substs_is_noop(substs) {\n+            selfty\n+          }\n+          ty::ty_self(substs) {\n             // Move the substs into the type param system of the\n             // context.\n-            let mut substs = vec::map(tps) {|t|\n+            let mut substs_tps = vec::map(substs.tps) {|t|\n                 let f = fixup_self_full(cx, t, m_substs, selfty, impl_n_tps);\n-                ty::subst_tps(cx, m_substs, f)\n+                ty::subst(cx, m_substs, f)\n             };\n \n             // Add extra substs for impl type parameters.\n-            while vec::len(substs) < impl_n_tps {\n-                substs += [ty::mk_param(cx, vec::len(substs),\n-                                        {crate: 0, node: 0})];\n+            while vec::len(substs_tps) < impl_n_tps {\n+                substs_tps += [ty::mk_param(cx, substs_tps.len(),\n+                                            {crate: 0, node: 0})];\n             }\n \n             // And for method type parameters.\n-            let method_n_tps =\n-                (vec::len(m_substs) - vec::len(tps)) as int;\n+            let method_n_tps = (\n+                m_substs.tps.len() - substs_tps.len()) as int;\n             if method_n_tps > 0 {\n-                substs += vec::tailn(m_substs, vec::len(m_substs)\n-                                     - (method_n_tps as uint));\n+                substs_tps += vec::tailn(\n+                    m_substs.tps,\n+                    m_substs.tps.len() - (method_n_tps as uint));\n             }\n \n             // And then instantiate the self type using all those.\n-            ty::subst_tps(cx, substs, selfty)\n+            let substs_1 = {\n+                self_r: substs.self_r,\n+                tps: substs_tps\n+            };\n+            ty::subst(cx, substs_1, selfty)\n           }\n           _ {\n               t\n@@ -1298,27 +1350,26 @@ fn fixup_self_full(cx: ty::ctxt, mty: ty::t, m_substs: [ty::t],\n // because the type parameters of ifaces and impls are not required to line up\n // (an impl can have less or more parameters than the iface it implements), so\n // some mangling of the substituted types is required.\n-fn fixup_self_param(fcx: @fn_ctxt, mty: ty::t, m_substs: [ty::t],\n+fn fixup_self_param(fcx: @fn_ctxt, mty: ty::t, m_substs: ty::substs,\n                     selfty: ty::t, sp: span) -> ty::t {\n     if !ty::type_has_vars(mty) { ret mty; }\n \n     let tcx = fcx.ccx.tcx;\n     ty::fold_ty(tcx, mty) {|t|\n         alt ty::get(t).struct {\n-          ty::ty_self(tps) if vec::len(tps) == 0u { selfty }\n-          ty::ty_self(tps) {\n-            // Move the substs into the type param system of the\n-            // context.\n-            let mut substs = vec::map(tps) {|t|\n+          ty::ty_self(substs) if ty::substs_is_noop(substs) {\n+            selfty\n+          }\n+          ty::ty_self(substs) {\n+            // Move the substs into the type param system of the context.\n+            let tps_p = vec::map(substs.tps) {|t|\n                 let f = fixup_self_param(fcx, t, m_substs, selfty, sp);\n-                ty::subst_tps(tcx, m_substs, f)\n+                ty::subst(tcx, m_substs, f)\n             };\n-\n-            // Simply ensure that the type parameters for the self\n-            // type match the context.\n-            vec::iter2(substs, m_substs) {|s, ms|\n-                demand::suptype(fcx, sp, s, ms);\n-            }\n+            let substs_p = {self_r: substs.self_r, tps: tps_p};\n+            let self_p = ty::mk_self(tcx, substs_p);\n+            let m_self = ty::mk_self(tcx, m_substs);\n+            demand::suptype(fcx, sp, m_self, self_p);\n             selfty\n           }\n           _ { t }\n@@ -1392,9 +1443,9 @@ mod collect {\n \n         let tcx = ccx.tcx;\n         alt check tcx.items.get(id) {\n-          ast_map::node_item(@{node: ast::item_iface(_, ms), _}, _) {\n+          ast_map::node_item(@{node: ast::item_iface(_, rp, ms), _}, _) {\n               store_methods::<ast::ty_method>(ccx, id, ms) {|m|\n-                  ty_of_ty_method(ccx, m)\n+                  ty_of_ty_method(ccx, m, rp)\n               };\n           }\n           ast_map::node_item(@{node: ast::item_class(_,_,its,_,rp), _}, _) {\n@@ -1412,52 +1463,45 @@ mod collect {\n                                    tps: [ast::ty_param],\n                                    rp: ast::region_param,\n                                    selfty: ty::t,\n-                                   t: @ast::iface_ref,\n-                                   ms: [@ast::method]) -> ast::def_id {\n+                                   a_ifacety: @ast::iface_ref,\n+                                   ms: [@ast::method]) {\n \n         let tcx = ccx.tcx;\n         let i_bounds = ty_param_bounds(ccx, tps);\n         let my_methods = convert_methods(ccx, ms, rp, i_bounds, selfty);\n-        let did = instantiate_iface_ref(ccx, t);\n-        // not sure whether it's correct to use empty_rscope\n-        // -- tjc\n-        let tys = vec::map(t.path.types,\n-                           {|t| ccx.to_ty(empty_rscope,t)});\n-        // Store the iface type in the type node\n-        write_ty_to_tcx(tcx, t.id, ty::mk_iface(ccx.tcx, did, tys));\n+        let (did, tpt) = instantiate_iface_ref(ccx, a_ifacety, rp);\n         if did.crate == ast::local_crate {\n             ensure_iface_methods(ccx, did.node);\n         }\n         for vec::each(*ty::iface_methods(tcx, did)) {|if_m|\n-           alt vec::find(my_methods,\n-              {|m| if_m.ident == m.mty.ident}) {\n-             some({mty: m, id, span}) {\n-                 if m.purity != if_m.purity {\n-                         ccx.tcx.sess.span_err(\n-                           span, #fmt[\"method `%s`'s purity \\\n-                                        not match the iface method's \\\n-                                        purity\", m.ident]);\n-                 }\n-                 let mt = compare_impl_method(\n-                        ccx.tcx, span, m, vec::len(tps),\n-                        if_m, tys, selfty);\n-                 let old = tcx.tcache.get(local_def(id));\n-                 if old.ty != mt {\n-                        tcx.tcache.insert(\n-                            local_def(id),\n-                            {bounds: old.bounds,\n-                             rp: old.rp,\n-                             ty: mt});\n-                        write_ty_to_tcx(tcx, id, mt);\n-                    }\n-                  }\n-             none {\n-               tcx.sess.span_err(t.path.span, \"missing method `\" +\n-                                      if_m.ident + \"`\");\n-             }\n-           } // alt\n+            alt vec::find(my_methods, {|m| if_m.ident == m.mty.ident}) {\n+              some({mty: m, id, span}) {\n+                if m.purity != if_m.purity {\n+                    ccx.tcx.sess.span_err(\n+                        span, #fmt[\"method `%s`'s purity \\\n+                                    not match the iface method's \\\n+                                    purity\", m.ident]);\n+                }\n+                let mt = compare_impl_method(\n+                    ccx.tcx, span, m, vec::len(tps),\n+                    if_m, tpt.substs, selfty);\n+                let old = tcx.tcache.get(local_def(id));\n+                if old.ty != mt {\n+                    tcx.tcache.insert(\n+                        local_def(id),\n+                        {bounds: old.bounds,\n+                         rp: old.rp,\n+                         ty: mt});\n+                    write_ty_to_tcx(tcx, id, mt);\n+                }\n+              }\n+              none {\n+                tcx.sess.span_err(\n+                    a_ifacety.path.span,\n+                    #fmt[\"missing method `%s`\", if_m.ident]);\n+              }\n+            } // alt\n         } // |if_m|\n-        did\n     } // fn\n \n     fn convert_class_item(ccx: @crate_ctxt,\n@@ -1510,26 +1554,25 @@ mod collect {\n             get_enum_variant_types(ccx, tpt.ty, variants,\n                                    ty_params, rp);\n           }\n-          ast::item_impl(tps, ifce, selfty, ms) {\n+          ast::item_impl(tps, rp, ifce, selfty, ms) {\n             let i_bounds = ty_param_bounds(ccx, tps);\n-            // NDM iface/impl regions\n-            let selfty = ccx.to_ty(empty_rscope, selfty);\n+            let selfty = ccx.to_ty(type_rscope(rp), selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n             tcx.tcache.insert(local_def(it.id),\n                               {bounds: i_bounds,\n-                               rp: ast::rp_none, // NDM iface/impl regions\n+                               rp: rp,\n                                ty: selfty});\n             alt ifce {\n               some(t) {\n-                  check_methods_against_iface(\n-                    ccx, tps, ast::rp_none, // NDM iface/impl regions\n+                check_methods_against_iface(\n+                    ccx, tps, rp,\n                     selfty, t, ms);\n               }\n               _ {\n                 // Still have to do this to write method types\n                 // into the table\n                 convert_methods(\n-                    ccx, ms, ast::rp_none, // NDM iface/impl regions\n+                    ccx, ms, rp,\n                     i_bounds, selfty);\n               }\n             }\n@@ -1555,15 +1598,17 @@ mod collect {\n             write_ty_to_tcx(tcx, ctor_id, t_ctor);\n             tcx.tcache.insert(local_def(ctor_id),\n                               {bounds: bounds,\n-                               rp: ast::rp_none,\n+                               rp: rp,\n                                ty: t_ctor});\n             tcx.tcache.insert(def_id, {bounds: bounds,\n-                                       rp: ast::rp_none,\n+                                       rp: rp,\n                                        ty: t_res});\n             write_ty_to_tcx(tcx, dtor_id, t_dtor);\n           }\n-          ast::item_iface(_, ms) {\n+          ast::item_iface(*) {\n             let tpt = ty_of_item(ccx, it);\n+            #debug[\"item_iface(it.id=%d, tpt.ty=%s)\",\n+                   it.id, ty_to_str(tcx, tpt.ty)];\n             write_ty_to_tcx(tcx, it.id, tpt.ty);\n             ensure_iface_methods(ccx, it.id);\n           }\n@@ -1581,7 +1626,7 @@ mod collect {\n             write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n             tcx.tcache.insert(local_def(ctor.node.id),\n                               {bounds: tpt.bounds,\n-                               rp: ast::rp_none, // NDM self->anon\n+                               rp: ast::rp_none,\n                                ty: t_ctor});\n             ensure_iface_methods(ccx, it.id);\n             /* FIXME: check for proper public/privateness */\n@@ -1605,15 +1650,14 @@ mod collect {\n             that it claims to implement.\n             */\n             for ifaces.each { |ifce|\n-                let t_id = check_methods_against_iface(ccx, tps, rp, selfty,\n-                                                       ifce, methods);\n+                check_methods_against_iface(ccx, tps, rp, selfty,\n+                                            ifce, methods);\n+                let t = ty::node_id_to_type(tcx, ifce.id);\n+\n                 // FIXME: This assumes classes only implement\n                 // non-parameterized ifaces. add a test case for\n                 // a class implementing a parameterized iface.\n                 // -- tjc (#1726)\n-                let t = ty::mk_iface(tcx, t_id, []);\n-                write_ty_to_tcx(tcx, ifce.id, t);\n-                // FIXME: likewise, assuming no bounds -- tjc\n                 tcx.tcache.insert(local_def(ifce.id), no_params(t));\n             }\n           }\n@@ -1647,15 +1691,6 @@ mod collect {\n }\n \n \n-// Type unification\n-mod unify {\n-    fn unify(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) ->\n-        result<(), ty::type_err> {\n-        ret infer::mk_subty(fcx.infcx, actual, expected);\n-    }\n-}\n-\n-\n // FIXME This is almost a duplicate of ty::type_autoderef, with structure_of\n // instead of ty::struct.\n fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n@@ -1732,6 +1767,7 @@ mod demand {\n     fn suptype(fcx: @fn_ctxt, sp: span,\n               expected: ty::t, actual: ty::t) {\n \n+        // n.b.: order of actual, expected is reversed\n         alt infer::mk_subty(fcx.infcx, actual, expected) {\n           result::ok(()) { /* ok */ }\n           result::err(err) {\n@@ -1740,6 +1776,17 @@ mod demand {\n         }\n     }\n \n+    fn eqtype(fcx: @fn_ctxt, sp: span,\n+              expected: ty::t, actual: ty::t) {\n+\n+        alt infer::mk_eqty(fcx.infcx, actual, expected) {\n+          result::ok(()) { /* ok */ }\n+          result::err(err) {\n+            fcx.report_mismatched_types(sp, expected, actual, err);\n+          }\n+        }\n+    }\n+\n     // Checks that the type `actual` can be assigned to `expected`.\n     fn assign(fcx: @fn_ctxt, sp: span, expected: ty::t, expr: @ast::expr) {\n         let expr_ty = fcx.expr_ty(expr);\n@@ -1755,7 +1802,7 @@ mod demand {\n \n // Returns true if the two types unify and false if they don't.\n fn are_compatible(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n-    alt unify::unify(fcx, expected, actual) {\n+    alt fcx.mk_eqty(expected, actual) {\n       result::ok(_) { ret true; }\n       result::err(_) { ret false; }\n     }\n@@ -2390,21 +2437,22 @@ fn check_expr(fcx: @fn_ctxt, expr: @ast::expr,\n fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n     let tcx = fcx.ccx.tcx;\n \n-    let {n_tps, raw_ty} = if did.crate == ast::local_crate {\n+    let {n_tps, rp, raw_ty} = if did.crate == ast::local_crate {\n         alt check tcx.items.find(did.node) {\n-          some(ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n-                                _}, _)) {\n+          some(ast_map::node_item(@{node: ast::item_impl(ts, rp, _, st, _),\n+                                  _}, _)) {\n             {n_tps: ts.len(),\n-             raw_ty: fcx.to_ty(st)}\n+             rp: rp,\n+             raw_ty: fcx.ccx.to_ty(type_rscope(rp), st)}\n           }\n-          // Node doesn't map to an impl. It might map to a class.\n           some(ast_map::node_item(@{node: ast::item_class(ts,\n                                     _,_,_,rp), id: class_id, _},_)) {\n               /* If the impl is a class, the self ty is just the class ty\n                  (doing a no-op subst for the ty params; in the next step,\n                  we substitute in fresh vars for them)\n                */\n               {n_tps: ts.len(),\n+               rp: rp,\n                raw_ty: ty::mk_class(tcx, local_def(class_id),\n                       {self_r: alt rp {\n                           ast::rp_self { some(fcx.next_region_var()) }\n@@ -2417,11 +2465,16 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n     } else {\n         let ity = ty::lookup_item_type(tcx, did);\n         {n_tps: vec::len(*ity.bounds),\n+         rp: ity.rp,\n          raw_ty: ity.ty}\n     };\n \n-    let self_r = none; // NDM iface/impl regions\n+    let self_r = alt rp {\n+      ast::rp_none { none }\n+      ast::rp_self { some(fcx.next_region_var()) }\n+    };\n     let tps = fcx.next_ty_vars(n_tps);\n+\n     let substs = {self_r: self_r, tps: tps};\n     let substd_ty = ty::subst(tcx, substs, raw_ty);\n     {substs: substs, ty: substd_ty}\n@@ -2449,8 +2502,8 @@ impl methods for lookup {\n           ty::ty_param(n, did) {\n             self.method_from_param(n, did)\n           }\n-          ty::ty_iface(did, tps) {\n-            self.method_from_iface(did, tps)\n+          ty::ty_iface(did, substs) {\n+            self.method_from_iface(did, substs)\n           }\n           ty::ty_class(did, substs) {\n             self.method_from_class(did, substs)\n@@ -2473,11 +2526,11 @@ impl methods for lookup {\n         let mut iface_bnd_idx = 0u; // count only iface bounds\n         let bounds = tcx.ty_param_bounds.get(did.node);\n         for vec::each(*bounds) {|bound|\n-            let (iid, bound_tps) = alt bound {\n+            let (iid, bound_substs) = alt bound {\n               ty::bound_copy | ty::bound_send { cont; /* ok */ }\n               ty::bound_iface(bound_t) {\n                 alt check ty::get(bound_t).struct {\n-                  ty::ty_iface(i, tps) { (i, tps) }\n+                  ty::ty_iface(i, substs) { (i, substs) }\n                 }\n               }\n             };\n@@ -2490,9 +2543,6 @@ impl methods for lookup {\n               }\n \n               some(pos) {\n-                let bound_substs = { // NDM iface/impl regions\n-                    self_r: none, tps: bound_tps\n-                };\n                 ret some(self.write_mty_from_m(\n                     some(self.self_ty), bound_substs, ifce_methods[pos],\n                     method_param(iid, pos, n, iface_bnd_idx)));\n@@ -2503,7 +2553,7 @@ impl methods for lookup {\n     }\n \n     fn method_from_iface(\n-        did: ast::def_id, iface_tps: [ty::t]) -> option<method_origin> {\n+        did: ast::def_id, iface_substs: ty::substs) -> option<method_origin> {\n \n         let ms = *ty::iface_methods(self.tcx(), did);\n         for ms.eachi {|i, m|\n@@ -2525,10 +2575,6 @@ impl methods for lookup {\n                      boxed iface\");\n             }\n \n-            let iface_substs = { // NDM iface/impl regions\n-                self_r: none, tps: iface_tps\n-            };\n-\n             ret some(self.write_mty_from_m(\n                 none, iface_substs, m,\n                 method_iface(did, i)));\n@@ -2565,6 +2611,12 @@ impl methods for lookup {\n     }\n \n     fn ty_from_did(did: ast::def_id) -> ty::t {\n+        alt check ty::get(ty::lookup_item_type(self.tcx(), did).ty).struct {\n+          ty::ty_fn(fty) {\n+            ty::mk_fn(self.tcx(), {proto: ast::proto_box with fty})\n+          }\n+        }\n+        /*\n         if did.crate == ast::local_crate {\n             alt check self.tcx().items.get(did.node) {\n               ast_map::node_method(m, _, _) {\n@@ -2580,6 +2632,7 @@ impl methods for lookup {\n               }\n             }\n         }\n+        */\n     }\n \n     fn method_from_scope() -> option<method_origin> {\n@@ -2608,7 +2661,7 @@ impl methods for lookup {\n \n                     // if we can assign the caller to the callee, that's a\n                     // potential match.  Collect those in the vector.\n-                    alt unify::unify(self.fcx, self_ty, ty) {\n+                    alt self.fcx.mk_subty(ty, self_ty) {\n                       result::err(_) { /* keep looking */ }\n                       result::ok(_) {\n                         results += [(self_substs, m.n_tps, m.did)];\n@@ -2696,7 +2749,7 @@ impl methods for lookup {\n         if has_self && !option::is_none(self_ty_sub) {\n             let fty = self.fcx.node_ty(self.node_id);\n             let fty = fixup_self_param(\n-                self.fcx, fty, all_substs.tps, self_ty_sub.get(),\n+                self.fcx, fty, all_substs, self_ty_sub.get(),\n                 self.expr.span);\n             self.fcx.write_ty(self.node_id, fty);\n         }\n@@ -3492,9 +3545,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n \n+        #debug[\"t_1=%s\", fcx.ty_to_str(t_1)];\n+        #debug[\"t_e=%s\", fcx.ty_to_str(t_e)];\n+\n         alt ty::get(t_1).struct {\n           // This will be looked up later on\n-          ty::ty_iface(_, _) {}\n+          ty::ty_iface(*) {}\n+\n           _ {\n             if ty::type_is_nil(t_e) {\n                 tcx.sess.span_err(expr.span, \"cast from nil: \" +\n@@ -4075,7 +4132,8 @@ fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n                     ast::carg_ident(i) {\n                       if i < num_args {\n                           let p = @{span: a.span, global: false,\n-                                    idents: [args[i].ident], types: []};\n+                                    idents: [args[i].ident],\n+                                    rp: none, types: []};\n                           let arg_occ_node_id =\n                               fcx.ccx.tcx.sess.next_node_id();\n                           fcx.ccx.tcx.def_map.insert\n@@ -4356,10 +4414,8 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         check_instantiable(ccx.tcx, it.span, it.id);\n         check_bare_fn(ccx, decl, body, dtor_id, none);\n       }\n-      ast::item_impl(tps, _, ty, ms) {\n-        let self_ty = ccx.to_ty(empty_rscope, ty); // NDM iface/impl regions\n-        let self_region = ty::re_free(it.id, ty::br_self);\n-        let self_ty = replace_self_region(ccx.tcx, self_region, self_ty);\n+      ast::item_impl(tps, rp, _, ty, ms) {\n+        let self_ty = ccx.to_ty(type_rscope(rp), ty);\n         for ms.each {|m| check_method(ccx, m, self_ty);}\n       }\n       ast::item_class(tps, ifaces, members, ctor, rp) {\n@@ -4459,15 +4515,15 @@ mod vtable {\n     }\n \n     fn lookup_vtables(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n-                      bounds: @[ty::param_bounds], tys: [ty::t],\n+                      bounds: @[ty::param_bounds], substs: ty::substs,\n                       allow_unsafe: bool) -> vtable_res {\n         let tcx = fcx.ccx.tcx;\n         let mut result = [], i = 0u;\n-        for tys.each {|ty|\n+        for substs.tps.each {|ty|\n             for vec::each(*bounds[i]) {|bound|\n                 alt bound {\n                   ty::bound_iface(i_ty) {\n-                    let i_ty = ty::subst_tps(tcx, tys, i_ty);\n+                    let i_ty = ty::subst(tcx, substs, i_ty);\n                     result += [lookup_vtable(fcx, isc, sp, ty, i_ty,\n                                              allow_unsafe)];\n                   }\n@@ -4479,36 +4535,62 @@ mod vtable {\n         @result\n     }\n \n+    fn fixup_substs(fcx: @fn_ctxt, sp: span,\n+                    substs: ty::substs) -> ty::substs {\n+        let tcx = fcx.ccx.tcx;\n+        // use a dummy type just to package up the substs that need fixing up\n+        let t = ty::mk_self(tcx, substs);\n+        let t_f = fixup_ty(fcx, sp, t);\n+        alt check ty::get(t_f).struct {\n+          ty::ty_self(substs_f) { substs_f }\n+        }\n+    }\n+\n+    fn relate_iface_tys(fcx: @fn_ctxt, sp: span,\n+                        exp_iface_ty: ty::t, act_iface_ty: ty::t) {\n+        demand::suptype(fcx, sp, exp_iface_ty, act_iface_ty)\n+    }\n+\n     /*\n       Look up the vtable to use when treating an item of type <t>\n       as if it has type <iface_ty>\n      */\n     fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n                      ty: ty::t, iface_ty: ty::t, allow_unsafe: bool)\n         -> vtable_origin {\n+\n+        #debug[\"lookup_vtable(ty=%s, iface_ty=%s)\",\n+               fcx.ty_to_str(ty), fcx.ty_to_str(iface_ty)];\n+        let _i = indenter();\n+\n         let tcx = fcx.ccx.tcx;\n-        let (iface_id, iface_tps) = alt check ty::get(iface_ty).struct {\n-            ty::ty_iface(did, tps) { (did, tps) }\n+        let (iface_id, iface_substs) = alt check ty::get(iface_ty).struct {\n+            ty::ty_iface(did, substs) { (did, substs) }\n         };\n         let ty = fixup_ty(fcx, sp, ty);\n         alt ty::get(ty).struct {\n           ty::ty_param(n, did) {\n             let mut n_bound = 0u;\n-            for vec::each(*tcx.ty_param_bounds.get(did.node)) {|bound|\n+            for vec::each(*tcx.ty_param_bounds.get(did.node)) { |bound|\n                 alt bound {\n+                  ty::bound_send | ty::bound_copy { /* ignore */ }\n                   ty::bound_iface(ity) {\n                     alt check ty::get(ity).struct {\n-                      ty::ty_iface(idid, _) {\n-                        if iface_id == idid { ret vtable_param(n, n_bound); }\n+                      ty::ty_iface(idid, substs) {\n+                        if iface_id == idid {\n+                            relate_iface_tys(fcx, sp, iface_ty, ity);\n+                            ret vtable_param(n, n_bound);\n+                        }\n                       }\n                     }\n                     n_bound += 1u;\n                   }\n-                  _ {}\n                 }\n             }\n           }\n-          ty::ty_iface(did, tps) if iface_id == did {\n+\n+          ty::ty_iface(did, substs) if iface_id == did {\n+            relate_iface_tys(fcx, sp, iface_ty, ty);\n             if !allow_unsafe {\n                 for vec::each(*ty::iface_methods(tcx, did)) {|m|\n                     if ty::type_has_vars(ty::mk_fn(tcx, m.fty)) {\n@@ -4523,50 +4605,59 @@ mod vtable {\n                     }\n                 }\n             }\n-            ret vtable_iface(did, tps);\n+            ret vtable_iface(did, substs.tps);\n           }\n+\n           _ {\n+            let mut found = [];\n+\n             for list::each(isc) {|impls|\n-                let mut found = none;\n                 for vec::each(*impls) {|im|\n-                    /* What iface does this item implement? */\n-                    let match = alt ty::impl_iface(tcx, im.did) {\n-                      some(ity) {\n-                        alt check ty::get(ity).struct {\n-                        /* Does it match the one we're searching for? */\n-                          ty::ty_iface(id, _) { id == iface_id }\n-                        }\n-                      }\n-                      _ { false }\n+                    // find the iface that the impl is an impl of (if any)\n+                    let of_ty = alt ty::impl_iface(tcx, im.did) {\n+                      some(of_ty) { of_ty }\n+                      _ { cont; }\n                     };\n-                    /* Found a matching iface */\n-                    if match {\n-                        let {substs: substs, ty: self_ty} =\n-                            impl_self_ty(fcx, im.did);\n-                        let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n-                        alt unify::unify(fcx, ty, self_ty) {\n-                          result::ok(_) {\n-                            if option::is_some(found) {\n-                                tcx.sess.span_err(\n-                                    sp, \"multiple applicable implementations \\\n-                                         in scope\");\n-                            } else {\n-                                let vars = substs.tps;\n-                                connect_iface_tps(fcx, sp, vars,\n-                                                  iface_tps, im.did);\n-                                let params = vec::map(vars, {|t|\n-                                    fixup_ty(fcx, sp, t)});\n-                                let subres = lookup_vtables(\n-                                    fcx, isc, sp, im_bs, params, false);\n-                                found = some(vtable_static(im.did, params,\n-                                                           subres));\n-                            }\n-                          }\n-                          result::err(_) {}\n-                        }\n+\n+                    // it must have the same id as the expected one\n+                    alt ty::get(of_ty).struct {\n+                      ty::ty_iface(id, _) if id != iface_id { cont; }\n+                      _ { /* ok */ }\n+                    }\n+\n+                    // check whether the type unifies with the type\n+                    // that the impl is for, and continue if not\n+                    let {substs: substs, ty: for_ty} =\n+                        impl_self_ty(fcx, im.did);\n+                    let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n+                    alt fcx.mk_subty(ty, for_ty) {\n+                      result::err(_) { cont; }\n+                      result::ok(()) { }\n                     }\n+\n+                    // check that desired iface type unifies\n+                    let of_ty = ty::subst(tcx, substs, of_ty);\n+                    relate_iface_tys(fcx, sp, iface_ty, of_ty);\n+\n+                    // recursively process the bounds\n+                    let iface_tps = iface_substs.tps;\n+                    let substs_f = fixup_substs(fcx, sp, substs);\n+                    connect_iface_tps(fcx, sp, substs_f.tps,\n+                                      iface_tps, im.did);\n+                    let subres = lookup_vtables(fcx, isc, sp,\n+                                                im_bs, substs_f, false);\n+                    found += [vtable_static(im.did, substs_f.tps, subres)];\n+                }\n+\n+                alt found.len() {\n+                  0u { /* fallthrough */ }\n+                  1u { ret found[0]; }\n+                  _ {\n+                    fcx.ccx.tcx.sess.span_err(\n+                        sp, \"multiple applicable methods in scope\");\n+                    ret found[0];\n+                  }\n                 }\n-                alt found { some(x) { ret x; } _ {} }\n             }\n           }\n         }\n@@ -4597,8 +4688,8 @@ mod vtable {\n         let ity = option::get(ty::impl_iface(tcx, impl_did));\n         let iface_ty = ty::subst_tps(tcx, impl_tys, ity);\n         alt check ty::get(iface_ty).struct {\n-          ty::ty_iface(_, tps) {\n-            vec::iter2(tps, iface_tys,\n+          ty::ty_iface(_, substs) {\n+            vec::iter2(substs.tps, iface_tys,\n                        {|a, b| demand::suptype(fcx, sp, a, b);});\n           }\n         }\n@@ -4607,26 +4698,25 @@ mod vtable {\n     fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n         let cx = fcx.ccx;\n         alt ex.node {\n-          ast::expr_path(_) {\n+          ast::expr_path(*) {\n             alt fcx.opt_node_ty_substs(ex.id) {\n               some(substs) {\n-                let ts = substs.tps; // NDM regions for iface/impls\n                 let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n                 let item_ty = ty::lookup_item_type(cx.tcx, did);\n                 if has_iface_bounds(*item_ty.bounds) {\n                     let impls = cx.impl_map.get(ex.id);\n                     cx.vtable_map.insert(ex.id, lookup_vtables(\n                         fcx, impls, ex.span,\n-                        item_ty.bounds, ts, false));\n+                        item_ty.bounds, substs, false));\n                 }\n               }\n               _ {}\n             }\n           }\n           // Must resolve bounds on methods with bounded params\n-          ast::expr_field(_, _, _) | ast::expr_binary(_, _, _) |\n-          ast::expr_unary(_, _) | ast::expr_assign_op(_, _, _) |\n-          ast::expr_index(_, _) {\n+          ast::expr_field(*) | ast::expr_binary(*) |\n+          ast::expr_unary(*) | ast::expr_assign_op(*) |\n+          ast::expr_index(*) {\n             alt cx.method_map.find(ex.id) {\n               some(method_static(did)) {\n                 let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n@@ -4635,11 +4725,10 @@ mod vtable {\n                       ast::expr_field(_, _, _) { ex.id }\n                       _ { ast_util::op_expr_callee_id(ex) }\n                     };\n-                    // NDM iface/impl regions\n-                    let ts = fcx.node_ty_substs(callee_id).tps;\n+                    let substs = fcx.node_ty_substs(callee_id);\n                     let iscs = cx.impl_map.get(ex.id);\n                     cx.vtable_map.insert(callee_id, lookup_vtables(\n-                        fcx, iscs, ex.span, bounds, ts, false));\n+                        fcx, iscs, ex.span, bounds, substs, false));\n                 }\n               }\n               _ {}\n@@ -4648,7 +4737,7 @@ mod vtable {\n           ast::expr_cast(src, _) {\n             let target_ty = fcx.expr_ty(ex);\n             alt ty::get(target_ty).struct {\n-              ty::ty_iface(_, _) {\n+              ty::ty_iface(*) {\n                /* Casting to an interface type.\n                   Look up all impls for the cast expr...\n                */"}, {"sha": "227dc0c8645b5cbbaf27aed9f8f6609086fe8e89", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -134,12 +134,10 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       some(def_id) {\n         let cs = ast_map::path_to_str(ty::item_path(cx, def_id));\n         ret alt ty::get(typ).struct {\n-          ty_enum(_, substs) | ty_res(_, _, substs) | ty_class(_, substs) {\n+          ty_enum(_, substs) | ty_res(_, _, substs) | ty_class(_, substs) |\n+          ty_iface(_, substs) {\n             parameterized(cx, cs, substs.self_r, substs.tps)\n           }\n-          ty_iface(_, tps) {\n-            parameterized(cx, cs, none, tps)\n-          }\n           _ { cs }\n         };\n       }\n@@ -159,7 +157,6 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       ty_float(ast::ty_f) { \"float\" }\n       ty_float(t) { ast_util::float_ty_to_str(t) }\n       ty_str { \"str\" }\n-      ty_self(ts) { parameterized(cx, \"self\", none, ts) }\n       ty_box(tm) { \"@\" + mt_to_str(cx, tm) }\n       ty_uniq(tm) { \"~\" + mt_to_str(cx, tm) }\n       ty_ptr(tm) { \"*\" + mt_to_str(cx, tm) }\n@@ -191,15 +188,18 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       ty_param(id, _) {\n         \"'\" + str::from_bytes([('a' as u8) + (id as u8)])\n       }\n+      ty_self(substs) {\n+        parameterized(cx, \"self\", substs.self_r, substs.tps)\n+      }\n       ty_enum(did, substs) | ty_res(did, _, substs) | ty_class(did, substs) {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path);\n         parameterized(cx, base, substs.self_r, substs.tps)\n       }\n-      ty_iface(did, tps) {\n+      ty_iface(did, substs) {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path);\n-        parameterized(cx, base, none, tps)\n+        parameterized(cx, base, substs.self_r, substs.tps)\n       }\n       ty_evec(mt, vs) {\n         #fmt[\"[%s]/%s\", mt_to_str(cx, mt),"}, {"sha": "71a179e29f0e8eecf63c786069d472e5462843f2", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -204,14 +204,14 @@ fn merge_method_attrs(\n     let attrs: [(str, option<str>)] = astsrv::exec(srv) {|ctxt|\n         alt ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n-            node: ast::item_iface(_, methods), _\n+            node: ast::item_iface(_, _, methods), _\n           }, _) {\n             par::seqmap(methods) {|method|\n                 (method.ident, attr_parser::parse_desc(method.attrs))\n             }\n           }\n           ast_map::node_item(@{\n-            node: ast::item_impl(_, _, _, methods), _\n+            node: ast::item_impl(_, _, _, _, methods), _\n           }, _) {\n             par::seqmap(methods) {|method|\n                 (method.ident, attr_parser::parse_desc(method.attrs))"}, {"sha": "fc54a1ea9f6b19438bc95adaef495eba5642822a", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -88,12 +88,12 @@ fn moddoc_from_mod(\n                     resdoc_from_resource(itemdoc)\n                 ))\n               }\n-              ast::item_iface(_, methods) {\n+              ast::item_iface(_, _, methods) {\n                 some(doc::ifacetag(\n                     ifacedoc_from_iface(itemdoc, methods)\n                 ))\n               }\n-              ast::item_impl(_, _, _, methods) {\n+              ast::item_impl(_, _, _, _, methods) {\n                 some(doc::impltag(\n                     impldoc_from_impl(itemdoc, methods)\n                 ))"}, {"sha": "cfb715d2fe4b5324919ea0cb3ca919f7530b336f", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -292,7 +292,7 @@ fn all_impls(m: ast::_mod) -> map::set<ast::def_id> {\n     let all_impls = common::new_def_hash();\n     for m.items.each {|item|\n         alt item.node {\n-          ast::item_impl(_, _, _, _) {\n+          ast::item_impl(_, _, _, _, _) {\n             all_impls.insert(ast_util::local_def(item.id), ());\n           }\n           _ { }"}, {"sha": "56888758ede89f461b340b8bd32436db57fb957b", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -197,7 +197,7 @@ fn get_method_sig(\n     astsrv::exec(srv) {|ctxt|\n         alt check ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n-            node: ast::item_iface(_, methods), _\n+            node: ast::item_iface(_, _, methods), _\n           }, _) {\n             alt check vec::find(methods) {|method|\n                 method.ident == method_name\n@@ -212,7 +212,7 @@ fn get_method_sig(\n             }\n           }\n           ast_map::node_item(@{\n-            node: ast::item_impl(_, _, _, methods), _\n+            node: ast::item_impl(_, _, _, _, methods), _\n           }, _) {\n             alt check vec::find(methods) {|method|\n                 method.ident == method_name\n@@ -247,7 +247,7 @@ fn fold_impl(\n     let (iface_ty, self_ty) = astsrv::exec(srv) {|ctxt|\n         alt ctxt.ast_map.get(doc.id()) {\n           ast_map::node_item(@{\n-            node: ast::item_impl(_, iface_ty, self_ty, _), _\n+            node: ast::item_impl(_, _, iface_ty, self_ty, _), _\n           }, _) {\n             let iface_ty = option::map(iface_ty) {|p|\n                 pprust::path_to_str(p.path)"}, {"sha": "5c859f21229236cc170844dba998957551d6eb1e", "filename": "src/test/compile-fail/iface-cast.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Fcompile-fail%2Fiface-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Fcompile-fail%2Fiface-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fiface-cast.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -0,0 +1,8 @@\n+iface foo<T> { }\n+\n+fn bar(x: foo<uint>) -> foo<int> {\n+    ret (x as foo::<int>);\n+    //!^ ERROR mismatched types: expected `foo<int>` but found `foo<uint>`\n+}\n+\n+fn main() {}"}, {"sha": "955d17cb33b7e451d62f5d9557a9e1568544bf8e", "filename": "src/test/compile-fail/prim-with-args.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -0,0 +1,29 @@\n+fn main() {\n+\n+let x: int<int>; //! ERROR Type parameters are not allowed on this type.\n+let x: i8<int>; //! ERROR Type parameters are not allowed on this type.\n+let x: i16<int>; //! ERROR Type parameters are not allowed on this type.\n+let x: i32<int>; //! ERROR Type parameters are not allowed on this type.\n+let x: i64<int>; //! ERROR Type parameters are not allowed on this type.\n+let x: uint<int>; //! ERROR Type parameters are not allowed on this type.\n+let x: u8<int>; //! ERROR Type parameters are not allowed on this type.\n+let x: u16<int>; //! ERROR Type parameters are not allowed on this type.\n+let x: u32<int>; //! ERROR Type parameters are not allowed on this type.\n+let x: u64<int>; //! ERROR Type parameters are not allowed on this type.\n+let x: float<int>; //! ERROR Type parameters are not allowed on this type.\n+let x: char<int>; //! ERROR Type parameters are not allowed on this type.\n+\n+let x: int/&; //! ERROR Region parameters are not allowed on this type.\n+let x: i8/&; //! ERROR Region parameters are not allowed on this type.\n+let x: i16/&; //! ERROR Region parameters are not allowed on this type.\n+let x: i32/&; //! ERROR Region parameters are not allowed on this type.\n+let x: i64/&; //! ERROR Region parameters are not allowed on this type.\n+let x: uint/&; //! ERROR Region parameters are not allowed on this type.\n+let x: u8/&; //! ERROR Region parameters are not allowed on this type.\n+let x: u16/&; //! ERROR Region parameters are not allowed on this type.\n+let x: u32/&; //! ERROR Region parameters are not allowed on this type.\n+let x: u64/&; //! ERROR Region parameters are not allowed on this type.\n+let x: float/&; //! ERROR Region parameters are not allowed on this type.\n+let x: char/&; //! ERROR Region parameters are not allowed on this type.\n+\n+}"}, {"sha": "6f9c547d6322a469a47e1e612db1c2141fd30562", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -0,0 +1,32 @@\n+// Check that explicit region bounds are allowed on the various\n+// nominal types (but not on other types) and that they are type\n+// checked.\n+\n+enum an_enum/& { }\n+iface an_iface/& { }\n+class a_class/& { new() { } }\n+resource a_rsrc/&(_x: ()) { }\n+\n+fn a_fn1(e: an_enum/&a) -> an_enum/&b {\n+    ret e; //! ERROR mismatched types: expected `an_enum/&b` but found `an_enum/&a`\n+}\n+\n+fn a_fn2(e: an_iface/&a) -> an_iface/&b {\n+    ret e; //! ERROR mismatched types: expected `an_iface/&b` but found `an_iface/&a`\n+}\n+\n+fn a_fn3(e: a_class/&a) -> a_class/&b {\n+    ret e; //! ERROR mismatched types: expected `a_class/&b` but found `a_class/&a`\n+}\n+\n+fn a_fn4(e: a_rsrc/&a) -> a_rsrc/&b {\n+    ret e; //! ERROR mismatched types: expected `a_rsrc/&b` but found `a_rsrc/&a`\n+}\n+\n+fn a_fn5(e: int/&a) -> int/&b {\n+    //!^ ERROR Region parameters are not allowed on this type.\n+    //!^^ ERROR Region parameters are not allowed on this type.\n+    ret e;\n+}\n+\n+fn main() { }\n\\ No newline at end of file"}, {"sha": "a2a2e39a2f81a7e940287c095cb050ee53342018", "filename": "src/test/compile-fail/regions-iface-1.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Fcompile-fail%2Fregions-iface-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Fcompile-fail%2Fregions-iface-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-iface-1.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -0,0 +1,28 @@\n+type ctxt = { v: uint };\n+\n+iface get_ctxt/& {\n+    // Here the `&` is bound in the method definition:\n+    fn get_ctxt() -> &ctxt;\n+}\n+\n+type has_ctxt/& = { c: &ctxt };\n+\n+impl/& of get_ctxt for has_ctxt {\n+\n+    // Here an error occurs because we used `&self` but\n+    // the definition used `&`:\n+    fn get_ctxt() -> &self.ctxt { //! ERROR method `get_ctxt` has an incompatible type\n+        self.c\n+    }\n+\n+}\n+\n+fn get_v(gc: get_ctxt) -> uint {\n+    gc.get_ctxt().v\n+}\n+\n+fn main() {\n+    let ctxt = { v: 22u };\n+    let hc = { c: &ctxt };\n+    assert get_v(hc as get_ctxt) == 22u;\n+}"}, {"sha": "76f4d24291a60c4c69788fe03b09498a9b328f4a", "filename": "src/test/compile-fail/regions-iface-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Fcompile-fail%2Fregions-iface-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Fcompile-fail%2Fregions-iface-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-iface-2.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -0,0 +1,21 @@\n+type ctxt = { v: uint };\n+\n+iface get_ctxt/& {\n+    fn get_ctxt() -> &self.ctxt;\n+}\n+\n+type has_ctxt/& = { c: &ctxt };\n+\n+impl/& of get_ctxt for has_ctxt {\n+    fn get_ctxt() -> &self.ctxt { self.c }\n+}\n+\n+fn make_gc() -> get_ctxt  {\n+    let ctxt = { v: 22u };\n+    let hc = { c: &ctxt };\n+    ret hc as get_ctxt; //! ERROR mismatched types: expected `get_ctxt/&`\n+}\n+\n+fn main() {\n+    make_gc().get_ctxt().v;\n+}"}, {"sha": "ae8d0130dffea11bc5c76569ce78366ea2fade72", "filename": "src/test/compile-fail/regions-iface-3.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Fcompile-fail%2Fregions-iface-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Fcompile-fail%2Fregions-iface-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-iface-3.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -0,0 +1,14 @@\n+iface get_ctxt/& {\n+    fn get_ctxt() -> &self.uint;\n+}\n+\n+fn make_gc1(gc: get_ctxt/&a) -> get_ctxt/&b  {\n+    ret gc; //! ERROR mismatched types: expected `get_ctxt/&b` but found `get_ctxt/&a`\n+}\n+\n+fn make_gc2(gc: get_ctxt/&a) -> get_ctxt/&b  {\n+    ret gc as get_ctxt; //! ERROR mismatched types: expected `get_ctxt/&b` but found `get_ctxt/&a`\n+}\n+\n+fn main() {\n+}"}, {"sha": "e061f566e12f861d2aacbdc410f8e262b4dbf96b", "filename": "src/test/run-pass/regions-borrow-evec-at.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-at.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-at.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-at.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -1,4 +1,4 @@\n-// xfail-test it don't work yet\n+// xfail-test\n \n fn foo(x: [uint]/&) -> uint {\n     x[0]"}, {"sha": "50306b57139005f2b2d9ad9c69d8c22eaf3bc087", "filename": "src/test/run-pass/regions-borrow-evec-fixed.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-fixed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-fixed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-fixed.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -1,4 +1,5 @@\n // xfail-test\n+\n fn foo(x: [int]/&) -> int {\n     x[0]\n }"}, {"sha": "6bc8f172f98eee5fe81570860f0f15609970021c", "filename": "src/test/run-pass/regions-iface.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Frun-pass%2Fregions-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Frun-pass%2Fregions-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-iface.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -0,0 +1,23 @@\n+type ctxt = { v: uint };\n+\n+iface get_ctxt/& {\n+    fn get_ctxt() -> &self.ctxt;\n+}\n+\n+type has_ctxt/& = { c: &ctxt };\n+\n+impl/& of get_ctxt for has_ctxt {\n+    fn get_ctxt() -> &self.ctxt {\n+        self.c\n+    }\n+}\n+\n+fn get_v(gc: get_ctxt) -> uint {\n+    gc.get_ctxt().v\n+}\n+\n+fn main() {\n+    let ctxt = { v: 22u };\n+    let hc = { c: &ctxt };\n+    assert get_v(hc as get_ctxt) == 22u;\n+}"}, {"sha": "e29d88cc78d6d0f081cb8fded18e4318560c628e", "filename": "src/test/run-pass/regions-self-impls.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -1,9 +1,6 @@\n-// xfail-test\n-// ^ handling of self is currently broken\n+type clam/& = { chowder: &int };\n \n-type clam = { chowder: &int };\n-\n-impl clam for clam {\n+impl clam/& for clam {\n     fn get_chowder() -> &self.int { ret self.chowder; }\n }\n "}, {"sha": "ced26c8c7db3f05076ffd13d0f0351b1643a9fc0", "filename": "src/test/run-pass/regions-self-in-enums.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825fd1808e2ac8763d16940531f037c9b387c871/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs?ref=825fd1808e2ac8763d16940531f037c9b387c871", "patch": "@@ -1,6 +1,4 @@\n-// xfail-test\n-\n-enum int_wrapper {\n+enum int_wrapper/& {\n     int_wrapper_ctor(&int)\n }\n "}]}