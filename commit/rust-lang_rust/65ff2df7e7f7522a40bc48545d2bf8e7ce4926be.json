{"sha": "65ff2df7e7f7522a40bc48545d2bf8e7ce4926be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZmYyZGY3ZTdmNzUyMmE0MGJjNDg1NDVkMmJmOGU3Y2U0OTI2YmU=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-12-02T21:23:24Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-12-02T21:23:24Z"}, "message": "Fix copy lints", "tree": {"sha": "c60d13b60526315e8dd4cb882e72c5cb370609e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c60d13b60526315e8dd4cb882e72c5cb370609e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65ff2df7e7f7522a40bc48545d2bf8e7ce4926be", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCAAGBQJYQeZRAAoJEF5CfHlMukXoqFIQAK414mDXdhNY1lIeoyRJy40G\nYfOUpg4LBMfj4Ow4CZY9tSX6SE604VntspdZlVS6b2ZAjP/rnUrpbP2kLLF/THk4\noFWctXDODA40d9NBMgSo6sqC6e1VySo8KyAwzBsj6nQb+f58O/snN0CiqbWJJHg7\nbR+C4xmkN4PhQT/lS1As+ABwIqw3s1AcF5MG3MVGrRJVgxPdjeT9Ivh2D0JXlDEc\n1mPF1Z76hTfMcpLt6UUHvxNT9DsFHYCDHlcaufY2I6+CK2j9pDg2Spx68M00GUmj\nWNWUAOtVqaVVtyHYp7biJYNvEVpv/2n8TO/jhmL+hqrISgiSySmX8OWI4JnYz4rk\noR6ftw/xef1y5aDSX/wunPihIzHbK7fpiXE2aeGfZe9A2rpwEEcC0/eVakdzHqAN\nmUjQvILs18MzWRKPF6kK2KlE8Y4jQGRGBrYBpuiB/V7Ca6+ts/66vpC6nNoTnjO5\n9K0IZ3ZhlbPfzL/Z1c4ytkAem5Cbm4MMi0T0cy73MuTUGoq4rKmN+ttN+2m3EvcN\nnSEcvuqlmQRzDu9k5+9sUBo4en/qB5/5EatWEnA51VFdcZJTQVYkvaBZFN9DVw0C\nyFo6lz/UvhNfediJ9Lrad9kkMwVCkh9fUAsAplvd4mEAo+sW6ftMthT33/k2cwWQ\noJwAGq4sBfgl9Ae8izXy\n=RFSU\n-----END PGP SIGNATURE-----", "payload": "tree c60d13b60526315e8dd4cb882e72c5cb370609e5\nparent fe15880beb3359bcf6d4d5bd8f527a553e2e86bf\nauthor mcarton <cartonmartin+git@gmail.com> 1480713804 +0100\ncommitter mcarton <cartonmartin+git@gmail.com> 1480713804 +0100\n\nFix copy lints\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65ff2df7e7f7522a40bc48545d2bf8e7ce4926be", "html_url": "https://github.com/rust-lang/rust/commit/65ff2df7e7f7522a40bc48545d2bf8e7ce4926be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65ff2df7e7f7522a40bc48545d2bf8e7ce4926be/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe15880beb3359bcf6d4d5bd8f527a553e2e86bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe15880beb3359bcf6d4d5bd8f527a553e2e86bf", "html_url": "https://github.com/rust-lang/rust/commit/fe15880beb3359bcf6d4d5bd8f527a553e2e86bf"}], "stats": {"total": 60, "additions": 38, "deletions": 22}, "files": [{"sha": "8ac25c233f972af6961cabbfd21ae8fb04288577", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/65ff2df7e7f7522a40bc48545d2bf8e7ce4926be/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ff2df7e7f7522a40bc48545d2bf8e7ce4926be/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=65ff2df7e7f7522a40bc48545d2bf8e7ce4926be", "patch": "@@ -3,7 +3,7 @@ use rustc::lint::*;\n use rustc::hir::*;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n-use syntax::ast::{Name, NodeId};\n+use syntax::ast::Name;\n use syntax::ptr::P;\n use utils::differing_macro_contexts;\n \n@@ -100,13 +100,14 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 self.eq_expr(lc, rc) && self.eq_block(lt, rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             }\n             (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n-            (&ExprLoop(ref lb, ref ll, _), &ExprLoop(ref rb, ref rl, _)) => {\n-                self.eq_block(lb, rb) && both(ll, rl, |l, r| l.node.as_str() == r.node.as_str())\n+            (&ExprLoop(ref lb, ref ll, ref lls), &ExprLoop(ref rb, ref rl, ref rls)) => {\n+                lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.node.as_str() == r.node.as_str())\n             }\n             (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n                 ls == rs && self.eq_expr(le, re) &&\n                 over(la, ra, |l, r| {\n-                    self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n+                    self.eq_expr(&l.body, &r.body) &&\n+                    both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n                     over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n                 })\n             }\n@@ -153,8 +154,8 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             }\n-            (&PatKind::Binding(ref lb, ref ld, ref li, ref lp), &PatKind::Binding(ref rb, ref rd, ref ri, ref rp)) => {\n-                lb == rb && ld == rd && li.node.as_str() == ri.node.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n+            (&PatKind::Binding(ref lb, _, ref li, ref lp), &PatKind::Binding(ref rb, _, ref ri, ref rp)) => {\n+                lb == rb && li.node.as_str() == ri.node.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n             }\n             (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n@@ -456,13 +457,13 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n             ExprPath(ref qpath) => {\n                 let c: fn(_) -> _ = ExprPath;\n                 c.hash(&mut self.s);\n-                self.hash_qpath(qpath, e.id);\n+                self.hash_qpath(qpath);\n             }\n             ExprStruct(ref path, ref fields, ref expr) => {\n                 let c: fn(_, _, _) -> _ = ExprStruct;\n                 c.hash(&mut self.s);\n \n-                self.hash_qpath(path, e.id);\n+                self.hash_qpath(path);\n \n                 for f in fields {\n                     self.hash_name(&f.name.node);\n@@ -527,8 +528,16 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n         n.as_str().hash(&mut self.s);\n     }\n \n-    pub fn hash_qpath(&mut self, p: &QPath, id: NodeId) {\n-        self.cx.tcx.tables().qpath_def(p, id).hash(&mut self.s);\n+    pub fn hash_qpath(&mut self, p: &QPath) {\n+        match *p {\n+            QPath::Resolved(_, ref path) => {\n+                self.hash_path(path);\n+            }\n+            QPath::TypeRelative(_, ref path) => {\n+                self.hash_name(&path.name);\n+            }\n+        }\n+        //self.cx.tcx.tables().qpath_def(p, id).hash(&mut self.s);\n     }\n \n     pub fn hash_path(&mut self, p: &Path) {"}, {"sha": "470284525458337b277644d1fc7c17334b76ed89", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/65ff2df7e7f7522a40bc48545d2bf8e7ce4926be/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ff2df7e7f7522a40bc48545d2bf8e7ce4926be/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=65ff2df7e7f7522a40bc48545d2bf8e7ce4926be", "patch": "@@ -122,22 +122,22 @@ fn if_same_then_else() -> Result<&'static str, ()> {\n     if true {\n         //~^NOTE same as this\n         for _ in &[42] {\n-            let foo: &Option<_> = &Some::<u8>(42);\n-            if true {\n-                break;\n-            } else {\n-                continue;\n-            }\n+            // let foo: &Option<_> = &Some::<u8>(42);\n+            // if true {\n+            //     break;\n+            // } else {\n+            //     continue;\n+            // }\n         }\n     }\n     else { //~ERROR this `if` has identical blocks\n         for _ in &[42] {\n-            let foo: &Option<_> = &Some::<u8>(42);\n-            if true {\n-                break;\n-            } else {\n-                continue;\n-            }\n+            // let foo: &Option<_> = &Some::<u8>(42);\n+            // if true {\n+            //     break;\n+            // } else {\n+            //     continue;\n+            // }\n         }\n     }\n \n@@ -237,6 +237,13 @@ fn if_same_then_else() -> Result<&'static str, ()> {\n         if let Some(42) = None {}\n     }\n \n+    if true {\n+        if let Some(42) = None::<u8> {}\n+    }\n+    else {\n+        if let Some(42) = None::<u32> {}\n+    }\n+\n     if true {\n         if let Some(a) = Some(42) {}\n     }"}]}