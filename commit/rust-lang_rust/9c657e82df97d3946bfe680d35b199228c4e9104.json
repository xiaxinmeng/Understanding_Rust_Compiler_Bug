{"sha": "9c657e82df97d3946bfe680d35b199228c4e9104", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNjU3ZTgyZGY5N2QzOTQ2YmZlNjgwZDM1YjE5OTIyOGM0ZTkxMDQ=", "commit": {"author": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-12-03T15:49:06Z"}, "committer": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-12-04T15:10:24Z"}, "message": "Extract free_worker closure", "tree": {"sha": "0697096a1b841467f331f401c0f8a8ee00412b93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0697096a1b841467f331f401c0f8a8ee00412b93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c657e82df97d3946bfe680d35b199228c4e9104", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c657e82df97d3946bfe680d35b199228c4e9104", "html_url": "https://github.com/rust-lang/rust/commit/9c657e82df97d3946bfe680d35b199228c4e9104", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c657e82df97d3946bfe680d35b199228c4e9104/comments", "author": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "431e0ab62f7730f11db693c23f48403e4c719f82", "url": "https://api.github.com/repos/rust-lang/rust/commits/431e0ab62f7730f11db693c23f48403e4c719f82", "html_url": "https://github.com/rust-lang/rust/commit/431e0ab62f7730f11db693c23f48403e4c719f82"}], "stats": {"total": 41, "additions": 18, "deletions": 23}, "files": [{"sha": "fdd1af00bee5cf7cd0e53a181e270c161c5eefe5", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9c657e82df97d3946bfe680d35b199228c4e9104/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c657e82df97d3946bfe680d35b199228c4e9104/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=9c657e82df97d3946bfe680d35b199228c4e9104", "patch": "@@ -1284,6 +1284,21 @@ fn start_executing_work<B: ExtraBackendMethods>(\n             // Relinquish accidentally acquired extra tokens\n             tokens.truncate(running);\n \n+            // If a thread exits successfully then we drop a token associated\n+            // with that worker and update our `running` count. We may later\n+            // re-acquire a token to continue running more work. We may also not\n+            // actually drop a token here if the worker was running with an\n+            // \"ephemeral token\"\n+            let mut free_worker = |worker_id| {\n+                if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n+                    main_thread_worker_state = MainThreadWorkerState::Idle;\n+                } else {\n+                    running -= 1;\n+                }\n+\n+                free_worker_ids.push(worker_id);\n+            };\n+\n             let msg = coordinator_receive.recv().unwrap();\n             match *msg.downcast::<Message<B>>().ok().unwrap() {\n                 // Save the token locally and the next turn of the loop will use\n@@ -1358,24 +1373,8 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                     assert_eq!(main_thread_worker_state,\n                                MainThreadWorkerState::Codegenning);\n                 }\n-\n-                // If a thread exits successfully then we drop a token associated\n-                // with that worker and update our `running` count. We may later\n-                // re-acquire a token to continue running more work. We may also not\n-                // actually drop a token here if the worker was running with an\n-                // \"ephemeral token\"\n-                //\n-                // Note that if the thread failed that means it panicked, so we\n-                // abort immediately.\n                 Message::Done { result: Ok(compiled_module), worker_id } => {\n-                    if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n-                        main_thread_worker_state = MainThreadWorkerState::Idle;\n-                    } else {\n-                        running -= 1;\n-                    }\n-\n-                    free_worker_ids.push(worker_id);\n-\n+                    free_worker(worker_id);\n                     match compiled_module.kind {\n                         ModuleKind::Regular => {\n                             compiled_modules.push(compiled_module);\n@@ -1392,12 +1391,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                 }\n                 Message::NeedsLTO { result, worker_id } => {\n                     assert!(!started_lto);\n-                    if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n-                        main_thread_worker_state = MainThreadWorkerState::Idle;\n-                    } else {\n-                        running -= 1;\n-                    }\n-                    free_worker_ids.push(worker_id);\n+                    free_worker(worker_id);\n                     needs_lto.push(result);\n                 }\n                 Message::AddImportOnlyModule { module_data, work_product } => {\n@@ -1408,6 +1402,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                     lto_import_only_modules.push((module_data, work_product));\n                     main_thread_worker_state = MainThreadWorkerState::Idle;\n                 }\n+                // If the thread failed that means it panicked, so we abort immediately.\n                 Message::Done { result: Err(()), worker_id: _ } => {\n                     bug!(\"worker thread panicked\");\n                 }"}]}