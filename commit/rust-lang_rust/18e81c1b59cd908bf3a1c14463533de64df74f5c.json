{"sha": "18e81c1b59cd908bf3a1c14463533de64df74f5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZTgxYzFiNTljZDkwOGJmM2ExYzE0NDYzNTMzZGU2NGRmNzRmNWM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-04T10:12:53Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-04T14:53:14Z"}, "message": "Rudimentary escape analysis for Box<T>", "tree": {"sha": "733f9b51f982d8f9d5a0b32985294a58408c9ceb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/733f9b51f982d8f9d5a0b32985294a58408c9ceb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18e81c1b59cd908bf3a1c14463533de64df74f5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18e81c1b59cd908bf3a1c14463533de64df74f5c", "html_url": "https://github.com/rust-lang/rust/commit/18e81c1b59cd908bf3a1c14463533de64df74f5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18e81c1b59cd908bf3a1c14463533de64df74f5c/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e90acaf59629a5997b00f057d8afab67c20b1661", "url": "https://api.github.com/repos/rust-lang/rust/commits/e90acaf59629a5997b00f057d8afab67c20b1661", "html_url": "https://github.com/rust-lang/rust/commit/e90acaf59629a5997b00f057d8afab67c20b1661"}], "stats": {"total": 243, "additions": 242, "deletions": 1}, "files": [{"sha": "e19ab474c5e35b017e5cf4445df11d7f461f392b", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18e81c1b59cd908bf3a1c14463533de64df74f5c/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/18e81c1b59cd908bf3a1c14463533de64df74f5c/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=18e81c1b59cd908bf3a1c14463533de64df74f5c", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 80 lints included in this crate:\n+There are 81 lints included in this crate:\n \n name                                                                                                     | default | meaning\n ---------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -15,6 +15,7 @@ name\n [block_in_if_condition_expr](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr) | warn    | braces can be eliminated in conditions that are expressions, e.g `if { true } ...`\n [block_in_if_condition_stmt](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_stmt) | warn    | avoid complex blocks in conditions, instead move the block higher and bind it with 'let'; e.g: `if { let x = true; x } ...`\n [box_vec](https://github.com/Manishearth/rust-clippy/wiki#box_vec)                                       | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n+[boxed_local](https://github.com/Manishearth/rust-clippy/wiki#boxed_local)                               | warn    | using Box<T> where unnecessary\n [cast_possible_truncation](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_truncation)     | allow   | casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\n [cast_possible_wrap](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_wrap)                 | allow   | casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\n [cast_precision_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_precision_loss)               | allow   | casts that cause loss of precision, e.g `x as f32` where `x: u64`"}, {"sha": "fbd545acc96d9220aec51ef9f34779b4a95bbbdb", "filename": "src/escape.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/18e81c1b59cd908bf3a1c14463533de64df74f5c/src%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18e81c1b59cd908bf3a1c14463533de64df74f5c/src%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fescape.rs?ref=18e81c1b59cd908bf3a1c14463533de64df74f5c", "patch": "@@ -0,0 +1,156 @@\n+use rustc::lint::*;\n+use rustc_front::hir::*;\n+use rustc_front::intravisit as visit;\n+use rustc::front::map::Node;\n+use rustc::middle::ty;\n+use rustc::middle::ty::adjustment::AutoAdjustment;\n+use rustc::middle::expr_use_visitor::*;\n+use rustc::middle::infer;\n+use rustc::middle::mem_categorization::{cmt, Categorization};\n+use rustc::util::nodemap::NodeSet;\n+use syntax::ast::NodeId;\n+use syntax::codemap::Span;\n+use utils::span_lint;\n+\n+pub struct EscapePass;\n+\n+declare_lint!(pub BOXED_LOCAL, Warn, \"using Box<T> where unnecessary\");\n+\n+struct EscapeDelegate<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    set: NodeSet,\n+}\n+\n+impl LintPass for EscapePass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(BOXED_LOCAL)\n+    }\n+}\n+\n+impl LateLintPass for EscapePass {\n+    fn check_fn(&mut self,\n+                cx: &LateContext,\n+                _: visit::FnKind,\n+                decl: &FnDecl,\n+                body: &Block,\n+                _: Span,\n+                id: NodeId) {\n+        let param_env = ty::ParameterEnvironment::for_item(cx.tcx, id);\n+        let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, Some(param_env), false);\n+        let mut v = EscapeDelegate {\n+            cx: cx,\n+            set: NodeSet(),\n+        };\n+        {\n+            let mut vis = ExprUseVisitor::new(&mut v, &infcx);\n+            vis.walk_fn(decl, body);\n+        }\n+        for node in v.set {\n+            span_lint(cx,\n+                      BOXED_LOCAL,\n+                      cx.tcx.map.span(node),\n+                      \"local variable doesn't need to be boxed here\");\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n+    fn consume(&mut self,\n+               _: NodeId,\n+               _: Span,\n+               cmt: cmt<'tcx>,\n+               mode: ConsumeMode) {\n+\n+        if let Categorization::Local(lid) = cmt.cat {\n+            if self.set.contains(&lid) {\n+                if let Move(DirectRefMove) = mode {\n+                    // moved out or in. clearly can't be localized\n+                    self.set.remove(&lid);\n+                }\n+            }\n+        }\n+    }\n+    fn matched_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: MatchMode) {}\n+    fn consume_pat(&mut self, consume_pat: &Pat, cmt: cmt<'tcx>, _: ConsumeMode) {\n+        if let Categorization::Rvalue(..) = cmt.cat {\n+            if let Some(Node::NodeStmt(st)) = self.cx\n+                                                  .tcx\n+                                                  .map\n+                                                  .find(self.cx.tcx.map.get_parent_node(cmt.id)) {\n+                if let StmtDecl(ref decl, _) = st.node {\n+                    if let DeclLocal(ref loc) = decl.node {\n+                        if let Some(ref ex) = loc.init {\n+                            if let ExprBox(..) = ex.node {\n+                                if let ty::TyBox(..) = cmt.ty.sty {\n+                                    // let x = box (...)\n+                                    self.set.insert(consume_pat.id);\n+                                }\n+                                // TODO Box::new\n+                                // TODO vec![]\n+                                // TODO \"foo\".to_owned() and friends\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if let Categorization::Local(lid) = cmt.cat {\n+            if self.set.contains(&lid) {\n+                // let y = x where x is known\n+                // remove x, insert y\n+                self.set.insert(consume_pat.id);\n+                self.set.remove(&lid);\n+            }\n+        }\n+\n+    }\n+    fn borrow(&mut self,\n+              borrow_id: NodeId,\n+              _: Span,\n+              cmt: cmt<'tcx>,\n+              _: ty::Region,\n+              _: ty::BorrowKind,\n+              loan_cause: LoanCause) {\n+\n+        if let Categorization::Local(lid) = cmt.cat {\n+            if self.set.contains(&lid) {\n+                if let Some(&AutoAdjustment::AdjustDerefRef(adj)) = self.cx\n+                                                                        .tcx\n+                                                                        .tables\n+                                                                        .borrow()\n+                                                                        .adjustments\n+                                                                        .get(&borrow_id) {\n+                    if LoanCause::AutoRef == loan_cause {\n+                        // x.foo()\n+                        if adj.autoderefs <= 0 {\n+                            self.set.remove(&lid); // Used without autodereffing (i.e. x.clone())\n+                        }\n+                    } else {\n+                        self.cx.sess().span_bug(cmt.span, \"Unknown adjusted AutoRef\");\n+                    }\n+                } else if LoanCause::AddrOf == loan_cause {\n+                    // &x\n+                    if let Some(&AutoAdjustment::AdjustDerefRef(adj)) =\n+                           self.cx.tcx.tables.borrow().adjustments\n+                               .get(&self.cx.tcx.map.get_parent_node(borrow_id)) {\n+                        if adj.autoderefs <= 1 {\n+                            // foo(&x) where no extra autoreffing is happening\n+                            self.set.remove(&lid);\n+                        }\n+                    }\n+\n+                } else if LoanCause::MatchDiscriminant == loan_cause {\n+                    self.set.remove(&lid); // `match x` can move\n+                }\n+                // do nothing for matches, etc. These can't escape\n+            }\n+        }\n+    }\n+    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+    fn mutate(&mut self,\n+              _: NodeId,\n+              _: Span,\n+              _: cmt<'tcx>,\n+              _: MutateMode) {\n+    }\n+}"}, {"sha": "9ead05b93b2f05c33a63960dba3bb6ed9d1d345d", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18e81c1b59cd908bf3a1c14463533de64df74f5c/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18e81c1b59cd908bf3a1c14463533de64df74f5c/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=18e81c1b59cd908bf3a1c14463533de64df74f5c", "patch": "@@ -64,6 +64,7 @@ pub mod no_effect;\n pub mod temporary_assignment;\n pub mod transmute;\n pub mod cyclomatic_complexity;\n+pub mod escape;\n \n mod reexport {\n     pub use syntax::ast::{Name, Ident, NodeId};\n@@ -116,6 +117,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box temporary_assignment::TemporaryAssignmentPass);\n     reg.register_late_lint_pass(box transmute::UselessTransmute);\n     reg.register_late_lint_pass(box cyclomatic_complexity::CyclomaticComplexity::new(25));\n+    reg.register_late_lint_pass(box escape::EscapePass);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         methods::OPTION_UNWRAP_USED,\n@@ -146,6 +148,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         collapsible_if::COLLAPSIBLE_IF,\n         cyclomatic_complexity::CYCLOMATIC_COMPLEXITY,\n         eq_op::EQ_OP,\n+        escape::BOXED_LOCAL,\n         eta_reduction::REDUNDANT_CLOSURE,\n         identity_op::IDENTITY_OP,\n         len_zero::LEN_WITHOUT_IS_EMPTY,"}, {"sha": "3782cb96da5c44bda1b92ef5ad62eb762b1cd37d", "filename": "tests/compile-fail/escape_analysis.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/18e81c1b59cd908bf3a1c14463533de64df74f5c/tests%2Fcompile-fail%2Fescape_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18e81c1b59cd908bf3a1c14463533de64df74f5c/tests%2Fcompile-fail%2Fescape_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fescape_analysis.rs?ref=18e81c1b59cd908bf3a1c14463533de64df74f5c", "patch": "@@ -0,0 +1,81 @@\n+#![feature(plugin, box_syntax)]\n+#![plugin(clippy)]\n+#![allow(warnings, clippy)]\n+\n+#![deny(boxed_local)]\n+\n+#[derive(Clone)]\n+struct A;\n+\n+impl A {\n+    fn foo(&self){}\n+}\n+\n+fn main() {\n+}\n+\n+fn warn_call() {\n+    let x = box A; //~ ERROR local variable\n+    x.foo(); \n+}\n+\n+fn warn_rename_call() {\n+    let x = box A;\n+\n+    let y = x; //~ ERROR local variable\n+    y.foo(); // via autoderef\n+}\n+\n+fn warn_notuse() {\n+    let bz = box A; //~ ERROR local variable\n+}\n+\n+fn warn_pass() {\n+    let bz = box A; //~ ERROR local variable\n+    take_ref(&bz); // via deref coercion\n+}\n+\n+fn nowarn_return() -> Box<A> {\n+    let fx = box A;\n+    fx // moved out, \"escapes\"\n+}\n+\n+fn nowarn_move() {\n+    let bx = box A;\n+    drop(bx) // moved in, \"escapes\"\n+}\n+fn nowarn_call() {\n+    let bx = box A;\n+    bx.clone(); // method only available to Box, not via autoderef\n+}\n+\n+fn nowarn_pass() {\n+    let bx = box A;\n+    take_box(&bx); // fn needs &Box\n+}\n+\n+\n+fn take_box(x: &Box<A>) {}\n+fn take_ref(x: &A) {}\n+\n+\n+fn nowarn_ref_take() {\n+    // false positive, should actually warn\n+    let x = box A; //~ ERROR local variable\n+    let y = &x;\n+    take_box(y);\n+}\n+\n+fn nowarn_match() {\n+    let x = box A; // moved into a match\n+    match x {\n+        y => drop(y)\n+    }\n+}\n+\n+fn warn_match() {\n+    let x = box A; //~ ERROR local variable\n+    match &x { // not moved\n+        ref y => ()\n+    }\n+}\n\\ No newline at end of file"}]}