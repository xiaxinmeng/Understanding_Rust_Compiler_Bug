{"sha": "e822e62ee80a9108bfdb7d0952c85fab2146f569", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MjJlNjJlZTgwYTkxMDhiZmRiN2QwOTUyYzg1ZmFiMjE0NmY1Njk=", "commit": {"author": {"name": "flip1995", "email": "uwdkn@student.kit.edu", "date": "2018-02-22T14:53:22Z"}, "committer": {"name": "flip1995", "email": "uwdkn@student.kit.edu", "date": "2018-03-01T00:34:25Z"}, "message": "Suggest type for overflowing bin/hex-literals", "tree": {"sha": "bbf35f42329e6859224576b4365c20f4afcf94cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbf35f42329e6859224576b4365c20f4afcf94cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e822e62ee80a9108bfdb7d0952c85fab2146f569", "comment_count": 0, "verification": {"verified": false, "reason": "unverified_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEz66kzxK9mXB0K2lyZ1erJvcvAIQFAlqXSpEACgkQZ1erJvcv\nAITvJBAApNj2Fv06lBCE34D45WmytpELMlVrxfzdyiN3Wl99qJ3cJeOHN/rQInAs\nzvWC4/ED8aAEXL0cUfcRCNl6x3od4k30JjKDSCfDAY3evGCTr50VxtwZ0G0G3vrW\nl5PYAcrRr7U5OZcSOCfP4uWrdFOitfeCaxJPmzk8SbU248nf3lUupWC+S02Q8QFe\n9Ox9JHW8PMgpJKykRjjLb3x/zO9RWETJpm84F51moi5ozLE52MXhjRc4T4SUtAFK\nEMY7fey+XK1GvfLt0uetlb5hKEC8+KVum7rwElyNnNrlqJiC4nort/egL30OsU66\n0FT8xA41vtF70e1x/2lNpt0ZgEI4ETJ8+bs7ke/6TEstaPZBSDu6ICrlkNAVmWy+\n6qpeP7MtkX481dle0MX/eubez/rxt+K2hFMsDPYBeY375FWocwWZI05QsB9OgGT9\n60KswLXra+kxDZemE4Pc1mPpCqGUR6V63SrFJjq91TCBxKTBxv+CzXjpLP/c0yJQ\nHLJ+fY5TBzmZ2mMV9OzUV/fqIAzJpim3PCr880JpjHufuiJqayl03iz1ANpDP69R\n2iNOLv5Np8m42SBxCqSG4VH2CvSycFoxi0GVQVcLe53R+xnX02rtJJs7vKFdZ64G\nWRkMNIxl3tqf6ssv5cjQZKMwUewCkbzBRco7IS7uek4/RK+V6tg=\n=f77H\n-----END PGP SIGNATURE-----", "payload": "tree bbf35f42329e6859224576b4365c20f4afcf94cf\nparent 0ff9872b2280009f094af0df3dcdc542cc46a5fd\nauthor flip1995 <uwdkn@student.kit.edu> 1519311202 +0100\ncommitter flip1995 <uwdkn@student.kit.edu> 1519864465 +0100\n\nSuggest type for overflowing bin/hex-literals\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e822e62ee80a9108bfdb7d0952c85fab2146f569", "html_url": "https://github.com/rust-lang/rust/commit/e822e62ee80a9108bfdb7d0952c85fab2146f569", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e822e62ee80a9108bfdb7d0952c85fab2146f569/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ff9872b2280009f094af0df3dcdc542cc46a5fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ff9872b2280009f094af0df3dcdc542cc46a5fd", "html_url": "https://github.com/rust-lang/rust/commit/0ff9872b2280009f094af0df3dcdc542cc46a5fd"}], "stats": {"total": 299, "additions": 274, "deletions": 25}, "files": [{"sha": "4fabb5bafbf89eb081e52573a3fed0ba3d34b79d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 169, "deletions": 25, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/e822e62ee80a9108bfdb7d0952c85fab2146f569/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e822e62ee80a9108bfdb7d0952c85fab2146f569/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=e822e62ee80a9108bfdb7d0952c85fab2146f569", "patch": "@@ -150,11 +150,52 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n \n                                 // Detect literal value out of range [min, max] inclusive\n                                 // avoiding use of -min to prevent overflow/panic\n-                                if (negative && v > max + 1) ||\n-                                   (!negative && v > max) {\n-                                    cx.span_lint(OVERFLOWING_LITERALS,\n-                                                 e.span,\n-                                                 &format!(\"literal out of range for {:?}\", t));\n+                                if (negative && v > max + 1) || (!negative && v > max) {\n+                                    if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n+                                        let bits = int_ty_bits(t, cx.sess().target.isize_ty);\n+                                        let mut actually = v as i128;\n+                                        if bits < 128 {\n+                                            // v & 0b0..01..1, |1| = bits\n+                                            let trimmed = v & ((1 << bits) - 1);\n+                                            actually = if v & (1 << (bits - 1)) == 0 {\n+                                                // positive\n+                                                trimmed as i128\n+                                            } else {\n+                                                // negative -> two's complement\n+                                                (((-1 as i128 as u128) << bits) | trimmed) as i128\n+                                            };\n+                                        }\n+                                        let mut err = cx.struct_span_lint(\n+                                            OVERFLOWING_LITERALS,\n+                                            e.span,\n+                                            &format!(\"literal out of range for {:?}\", t),\n+                                        );\n+                                        err.note(&format!(\n+                                            \"the literal `{}` (decimal `{}`) does not fit into \\\n+                                             an `{:?}` and will become `{}{:?}`.\",\n+                                            repr_str, v, t, actually, t\n+                                        ));\n+                                        let sugg_ty = get_fitting_type(\n+                                            &cx.tables.node_id_to_type(e.hir_id).sty,\n+                                            v,\n+                                            negative,\n+                                        ).map_or(String::new(), |ty| match ty {\n+                                            ty::TyUint(t) => format!(\"Consider using `{:?}`\", t),\n+                                            ty::TyInt(t) => format!(\"Consider using `{:?}`\", t),\n+                                            _ => String::new(),\n+                                        });\n+                                        if !sugg_ty.is_empty() {\n+                                            err.help(&sugg_ty);\n+                                        }\n+\n+                                        err.emit();\n+                                        return;\n+                                    }\n+                                    cx.span_lint(\n+                                        OVERFLOWING_LITERALS,\n+                                        e.span,\n+                                        &format!(\"literal out of range for {:?}\", t),\n+                                    );\n                                     return;\n                                 }\n                             }\n@@ -180,37 +221,77 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                 if let hir::ExprCast(..) = parent_expr.node {\n                                     if let ty::TyChar = cx.tables.expr_ty(parent_expr).sty {\n                                         let mut err = cx.struct_span_lint(\n-                                                             OVERFLOWING_LITERALS,\n-                                                             parent_expr.span,\n-                                                             \"only u8 can be casted into char\");\n-                                        err.span_suggestion(parent_expr.span,\n-                                                            &\"use a char literal instead\",\n-                                                            format!(\"'\\\\u{{{:X}}}'\", lit_val));\n+                                            OVERFLOWING_LITERALS,\n+                                            parent_expr.span,\n+                                            \"only u8 can be casted into char\",\n+                                        );\n+                                        err.span_suggestion(\n+                                            parent_expr.span,\n+                                            &\"use a char literal instead\",\n+                                            format!(\"'\\\\u{{{:X}}}'\", lit_val),\n+                                        );\n                                         err.emit();\n-                                        return\n+                                        return;\n                                     }\n                                 }\n                             }\n-                            cx.span_lint(OVERFLOWING_LITERALS,\n-                                         e.span,\n-                                         &format!(\"literal out of range for {:?}\", t));\n+                            if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n+                                let bits = uint_ty_bits(t, cx.sess().target.usize_ty);\n+                                // u128 cannot be greater than max -> compiler error\n+                                let actually = lit_val & ((1 << bits) - 1);\n+                                let mut err = cx.struct_span_lint(\n+                                    OVERFLOWING_LITERALS,\n+                                    e.span,\n+                                    &format!(\"literal out of range for {:?}\", t),\n+                                );\n+                                err.note(&format!(\n+                                    \"the literal `{}` (decimal `{}`) does not fit into \\\n+                                     an `{:?}` and will become `{}{:?}`.\",\n+                                    repr_str, lit_val, t, actually, t\n+                                ));\n+                                let sugg_ty = get_fitting_type(\n+                                    &cx.tables.node_id_to_type(e.hir_id).sty,\n+                                    lit_val,\n+                                    false,\n+                                ).map_or(\n+                                    String::new(),\n+                                    |ty| {\n+                                        if let ty::TyUint(t) = ty {\n+                                            format!(\"Consider using `{:?}`\", t)\n+                                        } else {\n+                                            String::new()\n+                                        }\n+                                    },\n+                                );\n+                                if !sugg_ty.is_empty() {\n+                                    err.help(&sugg_ty);\n+                                }\n+\n+                                err.emit();\n+                                return;\n+                            }\n+                            cx.span_lint(\n+                                OVERFLOWING_LITERALS,\n+                                e.span,\n+                                &format!(\"literal out of range for {:?}\", t),\n+                            );\n                         }\n                     }\n                     ty::TyFloat(t) => {\n                         let is_infinite = match lit.node {\n-                            ast::LitKind::Float(v, _) |\n-                            ast::LitKind::FloatUnsuffixed(v) => {\n-                                match t {\n-                                    ast::FloatTy::F32 => v.as_str().parse().map(f32::is_infinite),\n-                                    ast::FloatTy::F64 => v.as_str().parse().map(f64::is_infinite),\n-                                }\n-                            }\n+                            ast::LitKind::Float(v, _) | ast::LitKind::FloatUnsuffixed(v) => match t\n+                            {\n+                                ast::FloatTy::F32 => v.as_str().parse().map(f32::is_infinite),\n+                                ast::FloatTy::F64 => v.as_str().parse().map(f64::is_infinite),\n+                            },\n                             _ => bug!(),\n                         };\n                         if is_infinite == Ok(true) {\n-                            cx.span_lint(OVERFLOWING_LITERALS,\n-                                         e.span,\n-                                         &format!(\"literal out of range for {:?}\", t));\n+                            cx.span_lint(\n+                                OVERFLOWING_LITERALS,\n+                                e.span,\n+                                &format!(\"literal out of range for {:?}\", t),\n+                            );\n                         }\n                     }\n                     _ => (),\n@@ -338,6 +419,69 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 _ => false,\n             }\n         }\n+\n+        fn get_bin_hex_repr(cx: &LateContext, lit: &ast::Lit) -> Option<String> {\n+            if let Some(src) = cx.sess().codemap().span_to_snippet(lit.span).ok() {\n+                if let Some(firstch) = src.chars().next() {\n+                    if let Some(0) = char::to_digit(firstch, 10) {\n+                        if let Some(base) = src.chars().nth(1) {\n+                            if base == 'x' || base == 'b' {\n+                                return Some(src);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            None\n+        }\n+\n+        fn get_fitting_type<'a>(\n+            t: &ty::TypeVariants,\n+            val: u128,\n+            negative: bool,\n+        ) -> Option<ty::TypeVariants<'a>> {\n+            use syntax::ast::IntTy::*;\n+            use syntax::ast::UintTy::*;\n+            macro_rules! find_fit {\n+                ($ty:expr, $val:expr, $negative:expr,\n+                 $($type:ident => [$($utypes:expr),*] => [$($itypes:expr),*]),+) => {\n+                    {\n+                        let _neg = if negative { 1 } else { 0 };\n+                        match $ty {\n+                            $($type => {\n+                                $(if !negative && val <= uint_ty_range($utypes).1 {\n+                                    return Some(ty::TyUint($utypes))\n+                                })*\n+                                $(if val <= int_ty_range($itypes).1 as u128 + _neg {\n+                                    return Some(ty::TyInt($itypes))\n+                                })*\n+                                None\n+                            },)*\n+                            _ => None\n+                        }\n+                    }\n+                }\n+            }\n+            if let &ty::TyInt(i) = t {\n+                return find_fit!(i, val, negative,\n+                                 I8 => [U8] => [I16, I32, I64, I128],\n+                                 I16 => [U16] => [I32, I64, I128],\n+                                 I32 => [U32] => [I64, I128],\n+                                 I64 => [U64] => [I128],\n+                                 I128 => [U128] => []);\n+            }\n+            if let &ty::TyUint(u) = t {\n+                return find_fit!(u, val, negative,\n+                                 U8 => [U8, U16, U32, U64, U128] => [],\n+                                 U16 => [U16, U32, U64, U128] => [],\n+                                 U32 => [U32, U64, U128] => [],\n+                                 U64 => [U64, U128] => [],\n+                                 U128 => [U128] => []);\n+            }\n+\n+            None\n+        }\n     }\n }\n "}, {"sha": "e414f43b3ffd7c888cc4e69039d0d2d0583525b6", "filename": "src/test/ui/lint/type-overflow.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e822e62ee80a9108bfdb7d0952c85fab2146f569/src%2Ftest%2Fui%2Flint%2Ftype-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e822e62ee80a9108bfdb7d0952c85fab2146f569/src%2Ftest%2Fui%2Flint%2Ftype-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ftype-overflow.rs?ref=e822e62ee80a9108bfdb7d0952c85fab2146f569", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+#![feature(i128_type)]\n+\n+fn main() {\n+    let error = 255i8; //~WARNING literal out of range for i8\n+\n+    let ok = 0b1000_0001; // should be ok -> i32\n+    let ok = 0b0111_1111i8; // should be ok -> 127i8\n+\n+    let fail = 0b1000_0001i8; //~WARNING literal out of range for i8\n+\n+    let fail = 0x8000_0000_0000_0000i64; //~WARNING literal out of range for i64\n+\n+    let fail = 0x1_FFFF_FFFFu32; //~WARNING literal out of range for u32\n+\n+    let fail: i128 = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n+    //~^ WARNING literal out of range for i128\n+\n+    let fail = 0x8FFF_FFFF_FFFF_FFFE; //~WARNING literal out of range for i32\n+\n+    let fail: isize = 0x8000_0000_0000_0000; //~WARNING literal out of range for isize\n+\n+    let fail = -0b1111_1111i8; //~WARNING literal out of range for i8\n+}"}, {"sha": "425f76da5cb4ed594a805c84fbac79b38b62ed27", "filename": "src/test/ui/lint/type-overflow.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e822e62ee80a9108bfdb7d0952c85fab2146f569/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e822e62ee80a9108bfdb7d0952c85fab2146f569/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr?ref=e822e62ee80a9108bfdb7d0952c85fab2146f569", "patch": "@@ -0,0 +1,70 @@\n+warning: literal out of range for i8\n+  --> $DIR/type-overflow.rs:16:17\n+   |\n+16 |     let error = 255i8; //~WARNING literal out of range for i8\n+   |                 ^^^^^\n+   |\n+   = note: #[warn(overflowing_literals)] on by default\n+\n+warning: literal out of range for i8\n+  --> $DIR/type-overflow.rs:21:16\n+   |\n+21 |     let fail = 0b1000_0001i8; //~WARNING literal out of range for i8\n+   |                ^^^^^^^^^^^^^\n+   |\n+   = note: the literal `0b1000_0001i8` (decimal `129`) does not fit into an `i8` and will become `-127i8`.\n+   = help: Consider using `u8`\n+\n+warning: literal out of range for i64\n+  --> $DIR/type-overflow.rs:23:16\n+   |\n+23 |     let fail = 0x8000_0000_0000_0000i64; //~WARNING literal out of range for i64\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the literal `0x8000_0000_0000_0000i64` (decimal `9223372036854775808`) does not fit into an `i64` and will become `-9223372036854775808i64`.\n+   = help: Consider using `u64`\n+\n+warning: literal out of range for u32\n+  --> $DIR/type-overflow.rs:25:16\n+   |\n+25 |     let fail = 0x1_FFFF_FFFFu32; //~WARNING literal out of range for u32\n+   |                ^^^^^^^^^^^^^^^^\n+   |\n+   = note: the literal `0x1_FFFF_FFFFu32` (decimal `8589934591`) does not fit into an `u32` and will become `4294967295u32`.\n+   = help: Consider using `u64`\n+\n+warning: literal out of range for i128\n+  --> $DIR/type-overflow.rs:27:22\n+   |\n+27 |     let fail: i128 = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the literal `0x8000_0000_0000_0000_0000_0000_0000_0000` (decimal `170141183460469231731687303715884105728`) does not fit into an `i128` and will become `-170141183460469231731687303715884105728i128`.\n+   = help: Consider using `u128`\n+\n+warning: literal out of range for i32\n+  --> $DIR/type-overflow.rs:30:16\n+   |\n+30 |     let fail = 0x8FFF_FFFF_FFFF_FFFE; //~WARNING literal out of range for i32\n+   |                ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the literal `0x8FFF_FFFF_FFFF_FFFE` (decimal `10376293541461622782`) does not fit into an `i32` and will become `-2i32`.\n+   = help: Consider using `i128`\n+\n+warning: literal out of range for isize\n+  --> $DIR/type-overflow.rs:32:23\n+   |\n+32 |     let fail: isize = 0x8000_0000_0000_0000; //~WARNING literal out of range for isize\n+   |                       ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the literal `0x8000_0000_0000_0000` (decimal `9223372036854775808`) does not fit into an `isize` and will become `-9223372036854775808isize`.\n+\n+warning: literal out of range for i8\n+  --> $DIR/type-overflow.rs:34:17\n+   |\n+34 |     let fail = -0b1111_1111i8; //~WARNING literal out of range for i8\n+   |                 ^^^^^^^^^^^^^\n+   |\n+   = note: the literal `0b1111_1111i8` (decimal `255`) does not fit into an `i8` and will become `-1i8`.\n+   = help: Consider using `i16`\n+"}]}