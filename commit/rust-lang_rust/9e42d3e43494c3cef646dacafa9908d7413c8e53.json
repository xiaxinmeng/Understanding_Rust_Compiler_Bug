{"sha": "9e42d3e43494c3cef646dacafa9908d7413c8e53", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllNDJkM2U0MzQ5NGMzY2VmNjQ2ZGFjYWZhOTkwOGQ3NDEzYzhlNTM=", "commit": {"author": {"name": "Steven Malis", "email": "smmalis37@gmail.com", "date": "2020-07-25T09:03:50Z"}, "committer": {"name": "Steven Malis", "email": "smmalis37@gmail.com", "date": "2020-07-25T09:09:00Z"}, "message": "Pull out some shared code into a new function", "tree": {"sha": "95a4baeecae560b7bab744ed6d4a981ab709a964", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95a4baeecae560b7bab744ed6d4a981ab709a964"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e42d3e43494c3cef646dacafa9908d7413c8e53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e42d3e43494c3cef646dacafa9908d7413c8e53", "html_url": "https://github.com/rust-lang/rust/commit/9e42d3e43494c3cef646dacafa9908d7413c8e53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e42d3e43494c3cef646dacafa9908d7413c8e53/comments", "author": {"login": "smmalis37", "id": 4054472, "node_id": "MDQ6VXNlcjQwNTQ0NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/4054472?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smmalis37", "html_url": "https://github.com/smmalis37", "followers_url": "https://api.github.com/users/smmalis37/followers", "following_url": "https://api.github.com/users/smmalis37/following{/other_user}", "gists_url": "https://api.github.com/users/smmalis37/gists{/gist_id}", "starred_url": "https://api.github.com/users/smmalis37/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smmalis37/subscriptions", "organizations_url": "https://api.github.com/users/smmalis37/orgs", "repos_url": "https://api.github.com/users/smmalis37/repos", "events_url": "https://api.github.com/users/smmalis37/events{/privacy}", "received_events_url": "https://api.github.com/users/smmalis37/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smmalis37", "id": 4054472, "node_id": "MDQ6VXNlcjQwNTQ0NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/4054472?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smmalis37", "html_url": "https://github.com/smmalis37", "followers_url": "https://api.github.com/users/smmalis37/followers", "following_url": "https://api.github.com/users/smmalis37/following{/other_user}", "gists_url": "https://api.github.com/users/smmalis37/gists{/gist_id}", "starred_url": "https://api.github.com/users/smmalis37/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smmalis37/subscriptions", "organizations_url": "https://api.github.com/users/smmalis37/orgs", "repos_url": "https://api.github.com/users/smmalis37/repos", "events_url": "https://api.github.com/users/smmalis37/events{/privacy}", "received_events_url": "https://api.github.com/users/smmalis37/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e11fc8053d32c44e7152865852acc5c3c54efb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e11fc8053d32c44e7152865852acc5c3c54efb3", "html_url": "https://github.com/rust-lang/rust/commit/0e11fc8053d32c44e7152865852acc5c3c54efb3"}], "stats": {"total": 84, "additions": 44, "deletions": 40}, "files": [{"sha": "ccacd7a6aba6a177f18dd0636c0cd17d49da1be5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9e42d3e43494c3cef646dacafa9908d7413c8e53/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e42d3e43494c3cef646dacafa9908d7413c8e53/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9e42d3e43494c3cef646dacafa9908d7413c8e53", "patch": "@@ -1483,36 +1483,25 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(ty));\n                 debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n                 debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n-                for br in late_bound_in_ty.difference(&late_bound_in_trait_ref) {\n-                    let br_name = match *br {\n-                        ty::BrNamed(_, name) => format!(\"lifetime `{}`\", name),\n-                        _ => \"an anonymous lifetime\".to_string(),\n-                    };\n-                    // FIXME: point at the type params that don't have appropriate lifetimes:\n-                    // struct S1<F: for<'a> Fn(&i32, &i32) -> &'a i32>(F);\n-                    //                         ----  ----     ^^^^^^^\n-                    let mut err = struct_span_err!(\n-                        tcx.sess,\n-                        binding.span,\n-                        E0582,\n-                        \"binding for associated type `{}` references {}, \\\n-                         which does not appear in the trait input types\",\n-                        binding.item_name,\n-                        br_name\n-                    );\n-\n-                    if let ty::BrAnon(_) = *br {\n-                        // The only way for an anonymous lifetime to wind up\n-                        // in the return type but **also** be unconstrained is\n-                        // if it only appears in \"associated types\" in the\n-                        // input. See #62200 for an example. In this case,\n-                        // though we can easily give a hint that ought to be\n-                        // relevant.\n-                        err.note(\"lifetimes appearing in an associated type are not considered constrained\");\n-                    }\n \n-                    err.emit();\n-                }\n+                // FIXME: point at the type params that don't have appropriate lifetimes:\n+                // struct S1<F: for<'a> Fn(&i32, &i32) -> &'a i32>(F);\n+                //                         ----  ----     ^^^^^^^\n+                self.validate_late_bound_regions(\n+                    late_bound_in_trait_ref,\n+                    late_bound_in_ty,\n+                    |br_name| {\n+                        struct_span_err!(\n+                            tcx.sess,\n+                            binding.span,\n+                            E0582,\n+                            \"binding for associated type `{}` references {}, \\\n+                             which does not appear in the trait input types\",\n+                            binding.item_name,\n+                            br_name\n+                        )\n+                    },\n+                );\n             }\n         }\n \n@@ -3085,33 +3074,48 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             tcx.collect_constrained_late_bound_regions(&inputs.map_bound(|i| i.to_owned()));\n         let output = bare_fn_ty.output();\n         let late_bound_in_ret = tcx.collect_referenced_late_bound_regions(&output);\n-        for br in late_bound_in_ret.difference(&late_bound_in_args) {\n-            let lifetime_name = match *br {\n-                ty::BrNamed(_, name) => format!(\"lifetime `{}`,\", name),\n-                ty::BrAnon(_) | ty::BrEnv => \"an anonymous lifetime\".to_string(),\n-            };\n-            let mut err = struct_span_err!(\n+\n+        self.validate_late_bound_regions(late_bound_in_args, late_bound_in_ret, |br_name| {\n+            struct_span_err!(\n                 tcx.sess,\n                 decl.output.span(),\n                 E0581,\n                 \"return type references {} which is not constrained by the fn input types\",\n-                lifetime_name\n-            );\n+                br_name\n+            )\n+        });\n+\n+        bare_fn_ty\n+    }\n+\n+    fn validate_late_bound_regions(\n+        &self,\n+        constrained_regions: FxHashSet<ty::BoundRegion>,\n+        referenced_regions: FxHashSet<ty::BoundRegion>,\n+        generate_err: impl Fn(&str) -> rustc_errors::DiagnosticBuilder<'tcx>,\n+    ) {\n+        for br in referenced_regions.difference(&constrained_regions) {\n+            let br_name = match *br {\n+                ty::BrNamed(_, name) => format!(\"lifetime `{}`\", name),\n+                ty::BrAnon(_) | ty::BrEnv => \"an anonymous lifetime\".to_string(),\n+            };\n+\n+            let mut err = generate_err(&br_name);\n+\n             if let ty::BrAnon(_) = *br {\n                 // The only way for an anonymous lifetime to wind up\n                 // in the return type but **also** be unconstrained is\n                 // if it only appears in \"associated types\" in the\n-                // input. See #47511 for an example. In this case,\n+                // input. See #47511 and #62200 for examples. In this case,\n                 // though we can easily give a hint that ought to be\n                 // relevant.\n                 err.note(\n                     \"lifetimes appearing in an associated type are not considered constrained\",\n                 );\n             }\n+\n             err.emit();\n         }\n-\n-        bare_fn_ty\n     }\n \n     /// Given the bounds on an object, determines what single region bound (if any) we can"}]}