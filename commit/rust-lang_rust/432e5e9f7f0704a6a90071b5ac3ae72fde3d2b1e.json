{"sha": "432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMmU1ZTlmN2YwNzA0YTZhOTAwNzFiNWFjM2FlNzJmZGUzZDJiMWU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-01T11:57:03Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-01T15:51:47Z"}, "message": "Allow dereferencing of single-variant, single-argument tag values\n\n(Using the * operator.)\n\nThis makes tags more useful as nominal 'newtype' types, since you no\nlonger have to copy out their contents (or construct a cumbersome\nboilerplate alt) to access them.\n\nI could have gone with a scheme where you could dereference individual\narguments of an n-ary variant with ._0, ._1, etc, but opted not to,\nsince we plan to move to a system where all variants are unary (or, I\nguess, nullary).", "tree": {"sha": "1611974a6baa6d13b29e74a943c875d0f95628e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1611974a6baa6d13b29e74a943c875d0f95628e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e", "html_url": "https://github.com/rust-lang/rust/commit/432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57e63402530611733842f0b6acb246de238f86da", "url": "https://api.github.com/repos/rust-lang/rust/commits/57e63402530611733842f0b6acb246de238f86da", "html_url": "https://github.com/rust-lang/rust/commit/57e63402530611733842f0b6acb246de238f86da"}], "stats": {"total": 222, "additions": 141, "deletions": 81}, "files": [{"sha": "7bab6269af92e32c3ac063c79bd41f13c13bb8ac", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e", "patch": "@@ -549,18 +549,13 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n             case (ast::expr_unary(?op, ?base)) {\n                 if (op == ast::deref) {\n                     auto base_t = ty::expr_ty(*cx.tcx, base);\n+                    auto mut = false;\n                     alt (ty::struct(*cx.tcx, base_t)) {\n-                        case (ty::ty_box(?mt)) {\n-                            vec::push(ds, rec(mut=mt.mut != ast::imm,\n-                                              kind=unbox,\n-                                              outer_t=base_t));\n-                        }\n-                        case (ty::ty_res(_, ?inner, _)) {\n-                            vec::push(ds, rec(mut=false,\n-                                              kind=unbox,\n-                                              outer_t=base_t));\n-                        }\n+                        case (ty::ty_box(?mt)) { mut = mt.mut != ast::imm; }\n+                        case (ty::ty_res(_, _, _)) {}\n+                        case (ty::ty_tag(_, _)) {}\n                     }\n+                    vec::push(ds, rec(mut=mut, kind=unbox, outer_t=base_t));\n                     ex = base;\n                 } else { break; }\n             }"}, {"sha": "b72289c717f970bbb4777cace938687cd0843fe0", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 85, "deletions": 57, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e", "patch": "@@ -329,6 +329,7 @@ type block_ctxt =\n tag block_parent { parent_none; parent_some(@block_ctxt); }\n \n type result = rec(@block_ctxt bcx, ValueRef val);\n+type result_t = rec(@block_ctxt bcx, ValueRef val, ty::t ty);\n \n fn extend_path(@local_ctxt cx, &str name) -> @local_ctxt {\n     ret @rec(path=cx.path + [name] with *cx);\n@@ -3320,18 +3321,16 @@ fn trans_unary(&@block_ctxt cx, ast::unop op, &@ast::expr e,\n     auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n     alt (op) {\n         case (ast::not) {\n-            sub =\n-                autoderef(sub.bcx, sub.val,\n-                          ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n-            ret rslt(sub.bcx, sub.bcx.build.Not(sub.val));\n+            auto dr = autoderef(sub.bcx, sub.val,\n+                                ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n+            ret rslt(dr.bcx, dr.bcx.build.Not(dr.val));\n         }\n         case (ast::neg) {\n-            sub =\n-                autoderef(sub.bcx, sub.val,\n-                          ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n+            auto dr = autoderef(sub.bcx, sub.val,\n+                                ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n             if (ty::struct(cx.fcx.lcx.ccx.tcx, e_ty) == ty::ty_float) {\n-                ret rslt(sub.bcx, sub.bcx.build.FNeg(sub.val));\n-            } else { ret rslt(sub.bcx, sub.bcx.build.Neg(sub.val)); }\n+                ret rslt(dr.bcx, dr.bcx.build.FNeg(dr.val));\n+            } else { ret rslt(dr.bcx, sub.bcx.build.Neg(dr.val)); }\n         }\n         case (ast::box(_)) {\n             auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n@@ -3380,7 +3379,6 @@ fn trans_compare(&@block_ctxt cx0, ast::binop op, &ty::t t0, ValueRef lhs0,\n     auto rhs_r = autoderef(cx, rhs0, t0);\n     auto rhs = rhs_r.val;\n     cx = rhs_r.bcx;\n-    auto t = ty::type_autoderef(cx.fcx.lcx.ccx.tcx, t0);\n     // Determine the operation we need.\n     // FIXME: Use or-patterns when we have them.\n \n@@ -3393,7 +3391,7 @@ fn trans_compare(&@block_ctxt cx0, ast::binop op, &ty::t t0, ValueRef lhs0,\n         case (ast::ge) { llop = C_u8(abi::cmp_glue_op_lt); }\n         case (ast::gt) { llop = C_u8(abi::cmp_glue_op_le); }\n     }\n-    auto rs = compare(cx, lhs, rhs, t, llop);\n+    auto rs = compare(cx, lhs, rhs, rhs_r.ty, llop);\n \n     // Invert the result if necessary.\n     // FIXME: Use or-patterns when we have them.\n@@ -4113,11 +4111,12 @@ fn trans_eager_binop(&@block_ctxt cx, ast::binop op, &ty::t intype,\n }\n \n fn autoderef_lval(&@block_ctxt cx, ValueRef v, &ty::t t, bool is_lval)\n-    -> result {\n+    -> result_t {\n     let ValueRef v1 = v;\n     let ty::t t1 = t;\n+    auto ccx = cx.fcx.lcx.ccx;\n     while (true) {\n-        alt (ty::struct(cx.fcx.lcx.ccx.tcx, t1)) {\n+        alt (ty::struct(ccx.tcx, t1)) {\n             case (ty::ty_box(?mt)) {\n                 // If we are working with an lval, we want to\n                 // unconditionally load at the top of the loop\n@@ -4132,24 +4131,41 @@ fn autoderef_lval(&@block_ctxt cx, ValueRef v, &ty::t t, bool is_lval)\n                 // to cast this pointer, since statically-sized tag types have\n                 // different types depending on whether they're behind a box\n                 // or not.\n-\n-                if (!ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, mt.ty)) {\n-                    auto llty = type_of(cx.fcx.lcx.ccx, cx.sp, mt.ty);\n+                if (!ty::type_has_dynamic_size(ccx.tcx, mt.ty)) {\n+                    auto llty = type_of(ccx, cx.sp, mt.ty);\n                     v1 = cx.build.PointerCast(body, T_ptr(llty));\n                 } else { v1 = body; }\n-\n-                // But if we aren't working with an lval, we get rid of\n-                // a layer of indirection at the bottom of the loop so\n-                // that it is gone when we return...\n-                if (!is_lval) { v1 = load_if_immediate(cx, v1, t1); }\n+            }\n+            case (ty::ty_res(?did, ?inner, ?tps)) {\n+                if (is_lval) { v1 = cx.build.Load(v1); }\n+                t1 = ty::substitute_type_params(ccx.tcx, tps, inner);\n+                v1 = cx.build.GEP(v1, [C_int(0), C_int(1)]);\n+            }\n+            case (ty::ty_tag(?did, ?tps)) {\n+                auto variants = ty::tag_variants(ccx.tcx, did);\n+                if (vec::len(variants) != 1u ||\n+                    vec::len(variants.(0).args) != 1u) {\n+                    break;\n+                }\n+                if (is_lval) { v1 = cx.build.Load(v1); }\n+                t1 = ty::substitute_type_params\n+                    (ccx.tcx, tps, variants.(0).args.(0));\n+                if (!ty::type_has_dynamic_size(ccx.tcx, t1)) {\n+                    v1 = cx.build.PointerCast\n+                        (v1, T_ptr(type_of(ccx, cx.sp, t1)));\n+                }\n             }\n             case (_) { break; }\n         }\n+        // But if we aren't working with an lval, we get rid of\n+        // a layer of indirection at the bottom of the loop so\n+        // that it is gone when we return...\n+        if (!is_lval) { v1 = load_if_immediate(cx, v1, t1); }\n     }\n-    ret rslt(cx, v1);\n+    ret rec(bcx=cx, val=v1, ty=t1);\n }\n \n-fn autoderef(&@block_ctxt cx, ValueRef v, &ty::t t) -> result {\n+fn autoderef(&@block_ctxt cx, ValueRef v, &ty::t t) -> result_t {\n     ret autoderef_lval(cx, v, t, false);\n }\n \n@@ -4160,15 +4176,14 @@ fn trans_binary(&@block_ctxt cx, ast::binop op, &@ast::expr a, &@ast::expr b)\n     alt (op) {\n         case (ast::and) {\n             // Lazy-eval and\n-\n-            auto lhs_res = trans_expr(cx, a);\n-            lhs_res =\n-                autoderef(lhs_res.bcx, lhs_res.val,\n+            auto lhs_expr = trans_expr(cx, a);\n+            auto lhs_res =\n+                autoderef(lhs_expr.bcx, lhs_expr.val,\n                           ty::expr_ty(cx.fcx.lcx.ccx.tcx, a));\n             auto rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n-            auto rhs_res = trans_expr(rhs_cx, b);\n-            rhs_res =\n-                autoderef(rhs_res.bcx, rhs_res.val,\n+            auto rhs_expr = trans_expr(rhs_cx, b);\n+            auto rhs_res =\n+                autoderef(rhs_expr.bcx, rhs_expr.val,\n                           ty::expr_ty(cx.fcx.lcx.ccx.tcx, b));\n             auto lhs_false_cx = new_scope_block_ctxt(cx, \"lhs false\");\n             auto lhs_false_res = rslt(lhs_false_cx, C_bool(false));\n@@ -4181,20 +4196,18 @@ fn trans_binary(&@block_ctxt cx, ast::binop op, &@ast::expr a, &@ast::expr b)\n             lhs_res.bcx.build.CondBr(lhs_res.val, rhs_cx.llbb,\n                                      lhs_false_cx.llbb);\n             ret join_results(cx, T_bool(),\n-                             [lhs_false_res, rec(bcx=rhs_bcx with rhs_res)]);\n+                             [lhs_false_res, rec(bcx=rhs_bcx,\n+                                                 val=rhs_res.val)]);\n         }\n         case (ast::or) {\n             // Lazy-eval or\n-\n-            auto lhs_res = trans_expr(cx, a);\n-            lhs_res =\n-                autoderef(lhs_res.bcx, lhs_res.val,\n-                          ty::expr_ty(cx.fcx.lcx.ccx.tcx, a));\n+            auto lhs_expr = trans_expr(cx, a);\n+            auto lhs_res = autoderef(lhs_expr.bcx, lhs_expr.val,\n+                                     ty::expr_ty(cx.fcx.lcx.ccx.tcx, a));\n             auto rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n-            auto rhs_res = trans_expr(rhs_cx, b);\n-            rhs_res =\n-                autoderef(rhs_res.bcx, rhs_res.val,\n-                          ty::expr_ty(cx.fcx.lcx.ccx.tcx, b));\n+            auto rhs_expr = trans_expr(rhs_cx, b);\n+            auto rhs_res = autoderef(rhs_expr.bcx, rhs_expr.val,\n+                                     ty::expr_ty(cx.fcx.lcx.ccx.tcx, b));\n             auto lhs_true_cx = new_scope_block_ctxt(cx, \"lhs true\");\n             auto lhs_true_res = rslt(lhs_true_cx, C_bool(true));\n             // see the and case for an explanation\n@@ -4203,19 +4216,19 @@ fn trans_binary(&@block_ctxt cx, ast::binop op, &@ast::expr a, &@ast::expr b)\n             lhs_res.bcx.build.CondBr(lhs_res.val, lhs_true_cx.llbb,\n                                      rhs_cx.llbb);\n             ret join_results(cx, T_bool(),\n-                             [lhs_true_res, rec(bcx=rhs_bcx with rhs_res)]);\n+                             [lhs_true_res, rec(bcx=rhs_bcx,\n+                                                val=rhs_res.val)]);\n         }\n         case (_) {\n             // Remaining cases are eager:\n \n-            auto lhs = trans_expr(cx, a);\n+            auto lhs_expr = trans_expr(cx, a);\n             auto lhty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, a);\n-            lhs = autoderef(lhs.bcx, lhs.val, lhty);\n-            auto rhs = trans_expr(lhs.bcx, b);\n+            auto lhs = autoderef(lhs_expr.bcx, lhs_expr.val, lhty);\n+            auto rhs_expr = trans_expr(lhs.bcx, b);\n             auto rhty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, b);\n-            rhs = autoderef(rhs.bcx, rhs.val, rhty);\n-            ret trans_eager_binop(rhs.bcx, op,\n-                                  ty::type_autoderef(cx.fcx.lcx.ccx.tcx,lhty),\n+            auto rhs = autoderef(rhs_expr.bcx, rhs_expr.val, rhty);\n+            ret trans_eager_binop(rhs.bcx, op, lhs.ty,\n                                   lhs.val, rhs.val);\n         }\n     }\n@@ -4931,7 +4944,7 @@ fn trans_path(&@block_ctxt cx, &ast::path p, ast::node_id id) -> lval_result {\n fn trans_field(&@block_ctxt cx, &span sp, ValueRef v, &ty::t t0,\n                &ast::ident field, ast::node_id id) -> lval_result {\n     auto r = autoderef(cx, v, t0);\n-    auto t = ty::type_autoderef(cx.fcx.lcx.ccx.tcx, t0);\n+    auto t = r.ty;\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty::ty_tup(_)) {\n             let uint ix = ty::field_num(cx.fcx.lcx.ccx.sess, sp, field);\n@@ -4971,11 +4984,11 @@ fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base, &@ast::expr idx,\n     // Is this an interior vector?\n \n     auto base_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, base);\n-    auto base_ty_no_boxes = ty::strip_boxes(cx.fcx.lcx.ccx.tcx, base_ty);\n+    auto exp = trans_expr(cx, base);\n+    auto lv = autoderef(exp.bcx, exp.val, base_ty);\n+    auto base_ty_no_boxes = lv.ty;\n     auto is_interior =\n         ty::sequence_is_interior(cx.fcx.lcx.ccx.tcx, base_ty_no_boxes);\n-    auto lv = trans_expr(cx, base);\n-    lv = autoderef(lv.bcx, lv.val, base_ty);\n     auto ix = trans_expr(lv.bcx, idx);\n     auto v = lv.val;\n     auto bcx = ix.bcx;\n@@ -5056,14 +5069,29 @@ fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n             ret trans_index(cx, e.span, base, idx, e.id);\n         }\n         case (ast::expr_unary(?unop, ?base)) {\n+            auto ccx = cx.fcx.lcx.ccx;\n             assert (unop == ast::deref);\n             auto sub = trans_expr(cx, base);\n-            auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, base);\n-            auto offset = alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n-                case (ty::ty_box(_)) { abi::box_rc_field_body }\n-                case (ty::ty_res(_, _, _)) { 1 }\n+            auto t = ty::expr_ty(ccx.tcx, base);\n+            auto val = alt (ty::struct(ccx.tcx, t)) {\n+                case (ty::ty_box(_)) {\n+                    sub.bcx.build.GEP\n+                    (sub.val, [C_int(0), C_int(abi::box_rc_field_body)])\n+                }\n+                case (ty::ty_res(_, _, _)) {\n+                    sub.bcx.build.GEP(sub.val, [C_int(0), C_int(1)])\n+                }\n+                case (ty::ty_tag(_, _)) {\n+                    auto ety = ty::expr_ty(ccx.tcx, e);\n+                    auto ellty;\n+                    if (ty::type_has_dynamic_size(ccx.tcx, ety)) {\n+                        ellty = T_typaram_ptr(ccx.tn);\n+                    } else {\n+                        ellty = T_ptr(type_of(ccx, e.span, ety));\n+                    };\n+                    sub.bcx.build.PointerCast(sub.val, ellty)\n+                }\n             };\n-            auto val = sub.bcx.build.GEP(sub.val, [C_int(0), C_int(offset)]);\n             ret lval_mem(sub.bcx, val);\n         }\n         case (ast::expr_self_method(?ident)) {\n@@ -5692,7 +5720,7 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n             // It's a closure. We have to autoderef.\n             auto res = autoderef_lval(bcx, f_res.res.val, fn_ty, true);\n             bcx = res.bcx;\n-            fn_ty = ty::type_autoderef(bcx.fcx.lcx.ccx.tcx, fn_ty);\n+            fn_ty = res.ty;\n \n             auto pair = res.val;\n             faddr ="}, {"sha": "c4247b25104ad55624a743b66560e13de32434f1", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e", "patch": "@@ -111,7 +111,6 @@ export sequence_is_interior;\n export struct;\n export sort_methods;\n export stmt_node_id;\n-export strip_boxes;\n export sty;\n export substitute_type_params;\n export t;\n@@ -1287,6 +1286,17 @@ fn type_autoderef(&ctxt cx, &ty::t t) -> ty::t {\n     while (true) {\n         alt (struct(cx, t1)) {\n             case (ty::ty_box(?mt)) { t1 = mt.ty; }\n+            case (ty::ty_res(_, ?inner, ?tps)) {\n+                t1 = substitute_type_params(cx, tps, inner);\n+            }\n+            case (ty::ty_tag(?did, ?tps)) {\n+                auto variants = tag_variants(cx, did);\n+                if (vec::len(variants) != 1u ||\n+                    vec::len(variants.(0).args) != 1u) {\n+                    break;\n+                }\n+                t1 = substitute_type_params(cx, tps, variants.(0).args.(0));\n+            }\n             case (_) { break; }\n         }\n     }\n@@ -2891,7 +2901,7 @@ fn ret_ty_of_fn(ctxt cx, ast::node_id id) -> t {\n \n \n // NB: This function requires that the given type has no variables. So, inside\n-// typeck, you should use typeck::strip_boxes() instead.\n+// typeck, you should use typeck::do_autoderef() instead.\n fn strip_boxes(&ctxt cx, &ty::t t) -> ty::t {\n     auto t1 = t;\n     while (true) {"}, {"sha": "d57e2cf579726721bda058e66cbf6b13e6f9502c", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=432e5e9f7f0704a6a90071b5ac3ae72fde3d2b1e", "patch": "@@ -819,11 +819,25 @@ mod unify {\n \n tag autoderef_kind { AUTODEREF_OK; NO_AUTODEREF; }\n \n-fn strip_boxes(&@fn_ctxt fcx, &span sp, &ty::t t) -> ty::t {\n+// FIXME This is almost a duplicate of ty::type_autoderef, with structure_of\n+// instead of ty::struct.\n+fn do_autoderef(&@fn_ctxt fcx, &span sp, &ty::t t) -> ty::t {\n     auto t1 = t;\n     while (true) {\n         alt (structure_of(fcx, sp, t1)) {\n             case (ty::ty_box(?inner)) { t1 = inner.ty; }\n+            case (ty::ty_res(_, ?inner, ?tps)) {\n+                t1 = ty::substitute_type_params(fcx.ccx.tcx, tps, inner);\n+            }\n+            case (ty::ty_tag(?did, ?tps)) {\n+                auto variants = ty::tag_variants(fcx.ccx.tcx, did);\n+                if (vec::len(variants) != 1u ||\n+                    vec::len(variants.(0).args) != 1u) {\n+                    ret t1;\n+                }\n+                t1 = ty::substitute_type_params(fcx.ccx.tcx, tps,\n+                                                variants.(0).args.(0));\n+            }\n             case (_) { ret t1; }\n         }\n     }\n@@ -881,8 +895,8 @@ mod demand {\n         auto actual_1 = actual;\n         auto implicit_boxes = 0u;\n         if (adk == AUTODEREF_OK) {\n-            expected_1 = strip_boxes(fcx, sp, expected_1);\n-            actual_1 = strip_boxes(fcx, sp, actual_1);\n+            expected_1 = do_autoderef(fcx, sp, expected_1);\n+            actual_1 = do_autoderef(fcx, sp, actual_1);\n             implicit_boxes = count_boxes(fcx, sp, actual);\n         }\n         let vec[mutable ty::t] ty_param_substs = [mutable ];\n@@ -1346,7 +1360,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n         // We want to autoderef calls but not binds\n         auto fty_stripped =\n-            if (is_call) { strip_boxes(fcx, sp, fty) } else { fty };\n+            if (is_call) { do_autoderef(fcx, sp, fty) } else { fty };\n \n         // Grab the argument types and the return type.\n         auto arg_tys;\n@@ -1534,7 +1548,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 case (ast::ne) { ty::mk_bool(fcx.ccx.tcx) }\n                 case (ast::ge) { ty::mk_bool(fcx.ccx.tcx) }\n                 case (ast::gt) { ty::mk_bool(fcx.ccx.tcx) }\n-                case (_) { strip_boxes(fcx, expr.span, lhs_t) }\n+                case (_) { do_autoderef(fcx, expr.span, lhs_t) }\n             };\n             write::ty_only_fixup(fcx, id, t);\n         }\n@@ -1549,10 +1563,23 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     alt (structure_of(fcx, expr.span, oper_t)) {\n                         case (ty::ty_box(?inner)) { oper_t = inner.ty; }\n                         case (ty::ty_res(_, ?inner, _)) { oper_t = inner; }\n+                        case (ty::ty_tag(?id, ?tps)) {\n+                            auto variants = ty::tag_variants(fcx.ccx.tcx, id);\n+                            if (vec::len(variants) != 1u ||\n+                                vec::len(variants.(0).args) != 1u) {\n+                                fcx.ccx.tcx.sess.span_fatal\n+                                    (expr.span, \"can only dereference tags \" +\n+                                     \"with a single variant which has a \" +\n+                                     \"single argument\");\n+                            }\n+                            oper_t = ty::substitute_type_params\n+                                (fcx.ccx.tcx, tps, variants.(0).args.(0));\n+                        }\n                         case (_) {\n-                            auto s = \"dereferencing non-box type: \" +\n-                                ty_to_str(fcx.ccx.tcx, oper_t);\n-                            fcx.ccx.tcx.sess.span_fatal(expr.span, s);\n+                            fcx.ccx.tcx.sess.span_fatal\n+                                (expr.span, \"dereferencing non-\" + \n+                                 \"dereferenceable type: \" +\n+                                 ty_to_str(fcx.ccx.tcx, oper_t));\n                         }\n                     }\n                 }\n@@ -1568,7 +1595,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                                                  oper_t)));\n                     }\n                 }\n-                case (_) { oper_t = strip_boxes(fcx, expr.span, oper_t); }\n+                case (_) { oper_t = do_autoderef(fcx, expr.span, oper_t); }\n             }\n             write::ty_only_fixup(fcx, id, oper_t);\n         }\n@@ -1859,7 +1886,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             // Pull the return type out of the type of the function.\n \n             auto rt_1;\n-            auto fty = strip_boxes(fcx, expr.span,\n+            auto fty = do_autoderef(fcx, expr.span,\n                                    ty::expr_ty(fcx.ccx.tcx, f));\n             alt (structure_of(fcx, expr.span, fty)) {\n                 case (ty::ty_fn(_, _, ?rt, _, _)) { rt_1 = rt; }\n@@ -2017,7 +2044,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         case (ast::expr_field(?base, ?field)) {\n             check_expr(fcx, base);\n             auto base_t = expr_ty(fcx.ccx.tcx, base);\n-            base_t = strip_boxes(fcx, expr.span, base_t);\n+            base_t = do_autoderef(fcx, expr.span, base_t);\n             alt (structure_of(fcx, expr.span, base_t)) {\n                 case (ty::ty_tup(?args)) {\n                     let uint ix =\n@@ -2063,7 +2090,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         case (ast::expr_index(?base, ?idx)) {\n             check_expr(fcx, base);\n             auto base_t = expr_ty(fcx.ccx.tcx, base);\n-            base_t = strip_boxes(fcx, expr.span, base_t);\n+            base_t = do_autoderef(fcx, expr.span, base_t);\n             check_expr(fcx, idx);\n             auto idx_t = expr_ty(fcx.ccx.tcx, idx);\n             if (!type_is_integral(fcx, idx.span, idx_t)) {"}]}