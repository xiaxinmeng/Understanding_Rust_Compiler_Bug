{"sha": "ea8a5df431bfdea5c82d380f5832ab89a9f8fa03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhOGE1ZGY0MzFiZmRlYTVjODJkMzgwZjU4MzJhYjg5YTlmOGZhMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-15T04:12:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-15T04:12:16Z"}, "message": "auto merge of #18044 : aturon/rust/lint-conventions, r=pcwalton\n\n[RFC 344](https://github.com/rust-lang/rfcs/pull/344) proposes a set of naming conventions for lints. This PR\r\nrenames existing lints to follow the conventions.\r\n\r\nUse the following sed script to bring your code up to date:\r\n\r\n```\r\ns/unnecessary_typecast/unused_typecasts/g\r\ns/unsigned_negate/unsigned_negation/g\r\ns/type_limits/unused_comparisons/g\r\ns/type_overflow/overflowing_literals/g\r\ns/ctypes/improper_ctypes/g\r\ns/owned_heap_memory/box_pointers/g\r\ns/unused_attribute/unused_attributes/g\r\ns/path_statement/path_statements/g\r\ns/unused_must_use/unused_must_use/g\r\ns/unused_result/unused_results/g\r\ns/non_uppercase_statics/non_upper_case_globals/g\r\ns/unnecessary_parens/unused_parens/g\r\ns/unnecessary_import_braces/unused_import_braces/g\r\ns/unused_unsafe/unused_unsafe/g\r\ns/unsafe_block/unsafe_blocks/g\r\ns/unused_mut/unused_mut/g\r\ns/unnecessary_allocation/unused_allocation/g\r\ns/missing_doc/missing_docs/g\r\ns/unused_imports/unused_imports/g\r\ns/unused_extern_crate/unused_extern_crates/g\r\ns/unnecessary_qualification/unused_qualifications/g\r\ns/unrecognized_lint/unknown_lints/g\r\ns/unused_variable/unused_variables/g\r\ns/dead_assignment/unused_assignments/g\r\ns/unknown_crate_type/unknown_crate_types/g\r\ns/variant_size_difference/variant_size_differences/g\r\ns/transmute_fat_ptr/fat_ptr_transmutes/g\r\n```\r\n\r\nSince a large number of lints are being renamed for RFC 344, this PR\r\nadds some basic deprecation/renaming functionality to the pluggable lint\r\nsystem. It allows a simple mapping of old to new names, and can warn\r\nwhen old names are being used.\r\n\r\nThis change needs to be rolled out in stages. In this PR, the\r\ndeprecation warning is commented out, but the old name is forwarded to\r\nthe new one.\r\n\r\nOnce the PR lands and we have generated a new snapshot of the\r\ncompiler, we can add the deprecation warning and rename all uses of the\r\nlints in the rust codebase. I will file a PR to do so.\r\n\r\nCloses #16545\r\nCloses #17932\r\n\r\nr? @pcwalton", "tree": {"sha": "8f5bc6108f562cfc6efdc73f8869d64728341fef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f5bc6108f562cfc6efdc73f8869d64728341fef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03", "html_url": "https://github.com/rust-lang/rust/commit/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af991574890820b178faef9764c51da72cde236d", "url": "https://api.github.com/repos/rust-lang/rust/commits/af991574890820b178faef9764c51da72cde236d", "html_url": "https://github.com/rust-lang/rust/commit/af991574890820b178faef9764c51da72cde236d"}, {"sha": "31b7d64fdc11090b18666c190cf136549158644f", "url": "https://api.github.com/repos/rust-lang/rust/commits/31b7d64fdc11090b18666c190cf136549158644f", "html_url": "https://github.com/rust-lang/rust/commit/31b7d64fdc11090b18666c190cf136549158644f"}], "stats": {"total": 317, "additions": 191, "deletions": 126}, "files": [{"sha": "ba9ec904bae4caba87dfd70229fac948bd1149ec", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=ea8a5df431bfdea5c82d380f5832ab89a9f8fa03", "patch": "@@ -704,15 +704,15 @@ pub fn collect_crate_types(session: &Session,\n                 }\n                 Some(ref n) if n.equiv(&(\"bin\")) => Some(config::CrateTypeExecutable),\n                 Some(_) => {\n-                    session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPE,\n+                    session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPES,\n                                      ast::CRATE_NODE_ID,\n                                      a.span,\n                                      \"invalid `crate_type` \\\n                                       value\".to_string());\n                     None\n                 }\n                 _ => {\n-                    session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPE,\n+                    session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPES,\n                                      ast::CRATE_NODE_ID,\n                                      a.span,\n                                      \"`crate_type` requires a \\"}, {"sha": "76234c41637210b76bc3550963e1253249bf6a18", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 95, "deletions": 94, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=ea8a5df431bfdea5c82d380f5832ab89a9f8fa03", "patch": "@@ -81,36 +81,36 @@ impl LintPass for WhileTrue {\n     }\n }\n \n-declare_lint!(UNNECESSARY_TYPECAST, Allow,\n+declare_lint!(UNUSED_TYPECASTS, Allow,\n               \"detects unnecessary type casts, that can be removed\")\n \n pub struct UnusedCasts;\n \n impl LintPass for UnusedCasts {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNECESSARY_TYPECAST)\n+        lint_array!(UNUSED_TYPECASTS)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n             ast::ExprCast(ref expr, ref ty) => {\n                 let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &**ty);\n                 if ty::get(ty::expr_ty(cx.tcx, &**expr)).sty == ty::get(t_t).sty {\n-                    cx.span_lint(UNNECESSARY_TYPECAST, ty.span, \"unnecessary type cast\");\n+                    cx.span_lint(UNUSED_TYPECASTS, ty.span, \"unnecessary type cast\");\n                 }\n             }\n             _ => ()\n         }\n     }\n }\n \n-declare_lint!(UNSIGNED_NEGATE, Warn,\n+declare_lint!(UNSIGNED_NEGATION, Warn,\n               \"using an unary minus operator on unsigned type\")\n \n-declare_lint!(TYPE_LIMITS, Warn,\n+declare_lint!(UNUSED_COMPARISONS, Warn,\n               \"comparisons made useless by limits of the types involved\")\n \n-declare_lint!(TYPE_OVERFLOW, Warn,\n+declare_lint!(OVERFLOWING_LITERALS, Warn,\n               \"literal out of range for its type\")\n \n pub struct TypeLimits {\n@@ -128,7 +128,7 @@ impl TypeLimits {\n \n impl LintPass for TypeLimits {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNSIGNED_NEGATE, TYPE_LIMITS, TYPE_OVERFLOW)\n+        lint_array!(UNSIGNED_NEGATION, UNUSED_COMPARISONS, OVERFLOWING_LITERALS)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n@@ -138,7 +138,7 @@ impl LintPass for TypeLimits {\n                     ast::ExprLit(ref lit) => {\n                         match lit.node {\n                             ast::LitInt(_, ast::UnsignedIntLit(_)) => {\n-                                cx.span_lint(UNSIGNED_NEGATE, e.span,\n+                                cx.span_lint(UNSIGNED_NEGATION, e.span,\n                                              \"negation of unsigned int literal may \\\n                                              be unintentional\");\n                             },\n@@ -149,7 +149,7 @@ impl LintPass for TypeLimits {\n                         let t = ty::expr_ty(cx.tcx, &**expr);\n                         match ty::get(t).sty {\n                             ty::ty_uint(_) => {\n-                                cx.span_lint(UNSIGNED_NEGATE, e.span,\n+                                cx.span_lint(UNSIGNED_NEGATION, e.span,\n                                              \"negation of unsigned int variable may \\\n                                              be unintentional\");\n                             },\n@@ -167,7 +167,7 @@ impl LintPass for TypeLimits {\n             },\n             ast::ExprBinary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx.tcx, binop, &**l, &**r) {\n-                    cx.span_lint(TYPE_LIMITS, e.span,\n+                    cx.span_lint(UNUSED_COMPARISONS, e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n             },\n@@ -185,7 +185,7 @@ impl LintPass for TypeLimits {\n \n                                 if (negative && v > (min.abs() as u64)) ||\n                                    (!negative && v > (max.abs() as u64)) {\n-                                    cx.span_lint(TYPE_OVERFLOW, e.span,\n+                                    cx.span_lint(OVERFLOWING_LITERALS, e.span,\n                                                  \"literal out of range for its type\");\n                                     return;\n                                 }\n@@ -204,7 +204,7 @@ impl LintPass for TypeLimits {\n                             _ => fail!()\n                         };\n                         if  lit_val < min || lit_val > max {\n-                            cx.span_lint(TYPE_OVERFLOW, e.span,\n+                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n                                          \"literal out of range for its type\");\n                         }\n                     },\n@@ -219,7 +219,7 @@ impl LintPass for TypeLimits {\n                             _ => fail!()\n                         };\n                         if lit_val < min || lit_val > max {\n-                            cx.span_lint(TYPE_OVERFLOW, e.span,\n+                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n                                          \"literal out of range for its type\");\n                         }\n                     },\n@@ -330,23 +330,23 @@ impl LintPass for TypeLimits {\n     }\n }\n \n-declare_lint!(CTYPES, Warn,\n+declare_lint!(IMPROPER_CTYPES, Warn,\n               \"proper use of libc types in foreign modules\")\n \n-struct CTypesVisitor<'a, 'tcx: 'a> {\n+struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n     cx: &'a Context<'a, 'tcx>\n }\n \n-impl<'a, 'tcx> CTypesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_def(&mut self, sp: Span, ty_id: ast::NodeId, path_id: ast::NodeId) {\n         match self.cx.tcx.def_map.borrow().get_copy(&path_id) {\n             def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n-                self.cx.span_lint(CTYPES, sp,\n+                self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `int` in foreign module, while \\\n                                    libc::c_int or libc::c_long should be used\");\n             }\n             def::DefPrimTy(ast::TyUint(ast::TyU)) => {\n-                self.cx.span_lint(CTYPES, sp,\n+                self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `uint` in foreign module, while \\\n                                    libc::c_uint or libc::c_ulong should be used\");\n             }\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> CTypesVisitor<'a, 'tcx> {\n                 };\n \n                 if !ty::is_ffi_safe(self.cx.tcx, tty) {\n-                    self.cx.span_lint(CTYPES, sp,\n+                    self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                       \"found type without foreign-function-safe\n                                       representation annotation in foreign module, consider \\\n                                       adding a #[repr(...)] attribute to the type\");\n@@ -368,7 +368,7 @@ impl<'a, 'tcx> CTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for CTypesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for ImproperCTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty) {\n         match ty.node {\n             ast::TyPath(_, _, id) => self.check_def(ty.span, ty.id, id),\n@@ -378,16 +378,16 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-pub struct CTypes;\n+pub struct ImproperCTypes;\n \n-impl LintPass for CTypes {\n+impl LintPass for ImproperCTypes {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(CTYPES)\n+        lint_array!(IMPROPER_CTYPES)\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         fn check_ty(cx: &Context, ty: &ast::Ty) {\n-            let mut vis = CTypesVisitor { cx: cx };\n+            let mut vis = ImproperCTypesVisitor { cx: cx };\n             vis.visit_ty(ty);\n         }\n \n@@ -412,12 +412,12 @@ impl LintPass for CTypes {\n     }\n }\n \n-declare_lint!(OWNED_HEAP_MEMORY, Allow,\n+declare_lint!(BOX_POINTERS, Allow,\n               \"use of owned (Box type) heap memory\")\n \n-pub struct HeapMemory;\n+pub struct BoxPointers;\n \n-impl HeapMemory {\n+impl BoxPointers {\n     fn check_heap_type(&self, cx: &Context, span: Span, ty: ty::t) {\n         let mut n_uniq = 0i;\n         ty::fold_ty(cx.tcx, ty, |t| {\n@@ -438,14 +438,14 @@ impl HeapMemory {\n         if n_uniq > 0 {\n             let s = ty_to_string(cx.tcx, ty);\n             let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(OWNED_HEAP_MEMORY, span, m.as_slice());\n+            cx.span_lint(BOX_POINTERS, span, m.as_slice());\n         }\n     }\n }\n \n-impl LintPass for HeapMemory {\n+impl LintPass for BoxPointers {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(OWNED_HEAP_MEMORY)\n+        lint_array!(BOX_POINTERS)\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n@@ -545,14 +545,14 @@ impl LintPass for RawPointerDeriving {\n     }\n }\n \n-declare_lint!(UNUSED_ATTRIBUTE, Warn,\n+declare_lint!(UNUSED_ATTRIBUTES, Warn,\n               \"detects attributes that were not used by the compiler\")\n \n-pub struct UnusedAttribute;\n+pub struct UnusedAttributes;\n \n-impl LintPass for UnusedAttribute {\n+impl LintPass for UnusedAttributes {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_ATTRIBUTE)\n+        lint_array!(UNUSED_ATTRIBUTES)\n     }\n \n     fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n@@ -618,35 +618,35 @@ impl LintPass for UnusedAttribute {\n         }\n \n         if !attr::is_used(attr) {\n-            cx.span_lint(UNUSED_ATTRIBUTE, attr.span, \"unused attribute\");\n+            cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             if CRATE_ATTRS.contains(&attr.name().get()) {\n                 let msg = match attr.node.style {\n                     ast::AttrOuter => \"crate-level attribute should be an inner \\\n                                        attribute: add an exclamation mark: #![foo]\",\n                     ast::AttrInner => \"crate-level attribute should be in the \\\n                                        root module\",\n                 };\n-                cx.span_lint(UNUSED_ATTRIBUTE, attr.span, msg);\n+                cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n             }\n         }\n     }\n }\n \n-declare_lint!(pub PATH_STATEMENT, Warn,\n+declare_lint!(pub PATH_STATEMENTS, Warn,\n               \"path statements with no effect\")\n \n-pub struct PathStatement;\n+pub struct PathStatements;\n \n-impl LintPass for PathStatement {\n+impl LintPass for PathStatements {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(PATH_STATEMENT)\n+        lint_array!(PATH_STATEMENTS)\n     }\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n         match s.node {\n             ast::StmtSemi(ref expr, _) => {\n                 match expr.node {\n-                    ast::ExprPath(_) => cx.span_lint(PATH_STATEMENT, s.span,\n+                    ast::ExprPath(_) => cx.span_lint(PATH_STATEMENTS, s.span,\n                                                      \"path statement with no effect\"),\n                     _ => ()\n                 }\n@@ -659,14 +659,14 @@ impl LintPass for PathStatement {\n declare_lint!(pub UNUSED_MUST_USE, Warn,\n               \"unused result of a type flagged as #[must_use]\")\n \n-declare_lint!(pub UNUSED_RESULT, Allow,\n+declare_lint!(pub UNUSED_RESULTS, Allow,\n               \"unused result of an expression in a statement\")\n \n-pub struct UnusedResult;\n+pub struct UnusedResults;\n \n-impl LintPass for UnusedResult {\n+impl LintPass for UnusedResults {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_MUST_USE, UNUSED_RESULT)\n+        lint_array!(UNUSED_MUST_USE, UNUSED_RESULTS)\n     }\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n@@ -702,7 +702,7 @@ impl LintPass for UnusedResult {\n             _ => {}\n         }\n         if !warned {\n-            cx.span_lint(UNUSED_RESULT, s.span, \"unused result\");\n+            cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n         }\n \n         fn check_must_use(cx: &Context, attrs: &[ast::Attribute], sp: Span) -> bool {\n@@ -966,14 +966,14 @@ impl LintPass for NonSnakeCase {\n     }\n }\n \n-declare_lint!(pub NON_UPPERCASE_STATICS, Warn,\n+declare_lint!(pub NON_UPPER_CASE_GLOBALS, Warn,\n               \"static constants should have uppercase identifiers\")\n \n-pub struct NonUppercaseStatics;\n+pub struct NonUpperCaseGlobals;\n \n-impl LintPass for NonUppercaseStatics {\n+impl LintPass for NonUpperCaseGlobals {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_UPPERCASE_STATICS)\n+        lint_array!(NON_UPPER_CASE_GLOBALS)\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n@@ -986,7 +986,7 @@ impl LintPass for NonUppercaseStatics {\n                 // ones (some scripts don't have a concept of\n                 // upper/lowercase)\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n-                    cx.span_lint(NON_UPPERCASE_STATICS, it.span,\n+                    cx.span_lint(NON_UPPER_CASE_GLOBALS, it.span,\n                         format!(\"static constant `{}` should have an uppercase name \\\n                                  such as `{}`\",\n                                 s.get(), s.get().chars().map(|c| c.to_uppercase())\n@@ -1003,7 +1003,7 @@ impl LintPass for NonUppercaseStatics {\n             (&ast::PatIdent(_, ref path1, _), Some(&def::DefConst(..))) => {\n                 let s = token::get_ident(path1.node);\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n-                    cx.span_lint(NON_UPPERCASE_STATICS, path1.span,\n+                    cx.span_lint(NON_UPPER_CASE_GLOBALS, path1.span,\n                         format!(\"static constant in pattern `{}` should have an uppercase \\\n                                  name such as `{}`\",\n                                 s.get(), s.get().chars().map(|c| c.to_uppercase())\n@@ -1015,19 +1015,19 @@ impl LintPass for NonUppercaseStatics {\n     }\n }\n \n-declare_lint!(UNNECESSARY_PARENS, Warn,\n+declare_lint!(UNUSED_PARENS, Warn,\n               \"`if`, `match`, `while` and `return` do not need parentheses\")\n \n-pub struct UnnecessaryParens;\n+pub struct UnusedParens;\n \n-impl UnnecessaryParens {\n+impl UnusedParens {\n     fn check_unnecessary_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str,\n                                      struct_lit_needs_parens: bool) {\n         match value.node {\n             ast::ExprParen(ref inner) => {\n                 let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n                 if !necessary {\n-                    cx.span_lint(UNNECESSARY_PARENS, value.span,\n+                    cx.span_lint(UNUSED_PARENS, value.span,\n                                  format!(\"unnecessary parentheses around {}\",\n                                          msg).as_slice())\n                 }\n@@ -1071,9 +1071,9 @@ impl UnnecessaryParens {\n     }\n }\n \n-impl LintPass for UnnecessaryParens {\n+impl LintPass for UnusedParens {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNECESSARY_PARENS)\n+        lint_array!(UNUSED_PARENS)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n@@ -1108,14 +1108,14 @@ impl LintPass for UnnecessaryParens {\n     }\n }\n \n-declare_lint!(UNNECESSARY_IMPORT_BRACES, Allow,\n+declare_lint!(UNUSED_IMPORT_BRACES, Allow,\n               \"unnecessary braces around an imported item\")\n \n-pub struct UnnecessaryImportBraces;\n+pub struct UnusedImportBraces;\n \n-impl LintPass for UnnecessaryImportBraces {\n+impl LintPass for UnusedImportBraces {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNECESSARY_IMPORT_BRACES)\n+        lint_array!(UNUSED_IMPORT_BRACES)\n     }\n \n     fn check_view_item(&mut self, cx: &Context, view_item: &ast::ViewItem) {\n@@ -1128,7 +1128,7 @@ impl LintPass for UnnecessaryImportBraces {\n                                 ast::PathListIdent {ref name, ..} => {\n                                     let m = format!(\"braces around {} is unnecessary\",\n                                                     token::get_ident(*name).get());\n-                                    cx.span_lint(UNNECESSARY_IMPORT_BRACES, view_item.span,\n+                                    cx.span_lint(UNUSED_IMPORT_BRACES, view_item.span,\n                                                  m.as_slice());\n                                 },\n                                 _ => ()\n@@ -1167,21 +1167,21 @@ impl LintPass for UnusedUnsafe {\n     }\n }\n \n-declare_lint!(UNSAFE_BLOCK, Allow,\n+declare_lint!(UNSAFE_BLOCKS, Allow,\n               \"usage of an `unsafe` block\")\n \n-pub struct UnsafeBlock;\n+pub struct UnsafeBlocks;\n \n-impl LintPass for UnsafeBlock {\n+impl LintPass for UnsafeBlocks {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNSAFE_BLOCK)\n+        lint_array!(UNSAFE_BLOCKS)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) => {\n-                cx.span_lint(UNSAFE_BLOCK, blk.span, \"usage of an `unsafe` block\");\n+                cx.span_lint(UNSAFE_BLOCKS, blk.span, \"usage of an `unsafe` block\");\n             }\n             _ => ()\n         }\n@@ -1266,14 +1266,14 @@ impl LintPass for UnusedMut {\n     }\n }\n \n-declare_lint!(UNNECESSARY_ALLOCATION, Warn,\n+declare_lint!(UNUSED_ALLOCATION, Warn,\n               \"detects unnecessary allocations that can be eliminated\")\n \n-pub struct UnnecessaryAllocation;\n+pub struct UnusedAllocation;\n \n-impl LintPass for UnnecessaryAllocation {\n+impl LintPass for UnusedAllocation {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNECESSARY_ALLOCATION)\n+        lint_array!(UNUSED_ALLOCATION)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n@@ -1288,11 +1288,11 @@ impl LintPass for UnnecessaryAllocation {\n                     ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) => {\n                         match autoref {\n                             &Some(ty::AutoPtr(_, ast::MutImmutable, None)) => {\n-                                cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n+                                cx.span_lint(UNUSED_ALLOCATION, e.span,\n                                              \"unnecessary allocation, use & instead\");\n                             }\n                             &Some(ty::AutoPtr(_, ast::MutMutable, None)) => {\n-                                cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n+                                cx.span_lint(UNUSED_ALLOCATION, e.span,\n                                              \"unnecessary allocation, use &mut instead\");\n                             }\n                             _ => ()\n@@ -1306,7 +1306,7 @@ impl LintPass for UnnecessaryAllocation {\n     }\n }\n \n-declare_lint!(MISSING_DOC, Allow,\n+declare_lint!(MISSING_DOCS, Allow,\n               \"detects missing documentation for public members\")\n \n pub struct MissingDoc {\n@@ -1358,15 +1358,15 @@ impl MissingDoc {\n             }\n         });\n         if !has_doc {\n-            cx.span_lint(MISSING_DOC, sp,\n+            cx.span_lint(MISSING_DOCS, sp,\n                 format!(\"missing documentation for {}\", desc).as_slice());\n         }\n     }\n }\n \n impl LintPass for MissingDoc {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(MISSING_DOC)\n+        lint_array!(MISSING_DOCS)\n     }\n \n     fn enter_lint_attrs(&mut self, _: &Context, attrs: &[ast::Attribute]) {\n@@ -1569,40 +1569,40 @@ impl LintPass for Stability {\n declare_lint!(pub UNUSED_IMPORTS, Warn,\n               \"imports that are never used\")\n \n-declare_lint!(pub UNUSED_EXTERN_CRATE, Allow,\n+declare_lint!(pub UNUSED_EXTERN_CRATES, Allow,\n               \"extern crates that are never used\")\n \n-declare_lint!(pub UNNECESSARY_QUALIFICATION, Allow,\n+declare_lint!(pub UNUSED_QUALIFICATIONS, Allow,\n               \"detects unnecessarily qualified names\")\n \n-declare_lint!(pub UNRECOGNIZED_LINT, Warn,\n+declare_lint!(pub UNKNOWN_LINTS, Warn,\n               \"unrecognized lint attribute\")\n \n-declare_lint!(pub UNUSED_VARIABLE, Warn,\n+declare_lint!(pub UNUSED_VARIABLES, Warn,\n               \"detect variables which are not used in any way\")\n \n-declare_lint!(pub DEAD_ASSIGNMENT, Warn,\n+declare_lint!(pub UNUSED_ASSIGNMENTS, Warn,\n               \"detect assignments that will never be read\")\n \n declare_lint!(pub DEAD_CODE, Warn,\n-              \"detect piece of code that will never be used\")\n+              \"detect unused, unexported items\")\n \n declare_lint!(pub UNREACHABLE_CODE, Warn,\n-              \"detects unreachable code\")\n+              \"detects unreachable code paths\")\n \n declare_lint!(pub WARNINGS, Warn,\n               \"mass-change the level for lints which produce warnings\")\n \n declare_lint!(pub UNKNOWN_FEATURES, Deny,\n               \"unknown features found in crate-level #[feature] directives\")\n \n-declare_lint!(pub UNKNOWN_CRATE_TYPE, Deny,\n+declare_lint!(pub UNKNOWN_CRATE_TYPES, Deny,\n               \"unknown crate type found in #[crate_type] directive\")\n \n-declare_lint!(pub VARIANT_SIZE_DIFFERENCE, Allow,\n+declare_lint!(pub VARIANT_SIZE_DIFFERENCES, Allow,\n               \"detects enums with widely varying variant sizes\")\n \n-declare_lint!(pub TRANSMUTE_FAT_PTR, Allow,\n+declare_lint!(pub FAT_PTR_TRANSMUTES, Allow,\n               \"detects transmutes of fat pointers\")\n \n /// Does nothing as a lint pass, but registers some `Lint`s\n@@ -1613,17 +1613,18 @@ impl LintPass for HardwiredLints {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n             UNUSED_IMPORTS,\n-            UNUSED_EXTERN_CRATE,\n-            UNNECESSARY_QUALIFICATION,\n-            UNRECOGNIZED_LINT,\n-            UNUSED_VARIABLE,\n-            DEAD_ASSIGNMENT,\n+            UNUSED_EXTERN_CRATES,\n+            UNUSED_QUALIFICATIONS,\n+            UNKNOWN_LINTS,\n+            UNUSED_VARIABLES,\n+            UNUSED_ASSIGNMENTS,\n             DEAD_CODE,\n             UNREACHABLE_CODE,\n             WARNINGS,\n             UNKNOWN_FEATURES,\n-            UNKNOWN_CRATE_TYPE,\n-            VARIANT_SIZE_DIFFERENCE\n+            UNKNOWN_CRATE_TYPES,\n+            VARIANT_SIZE_DIFFERENCES,\n+            FAT_PTR_TRANSMUTES\n         )\n     }\n }"}, {"sha": "0f63000bff113b9bb038851ed193888e5f6399ea", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 86, "deletions": 22, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=ea8a5df431bfdea5c82d380f5832ab89a9f8fa03", "patch": "@@ -63,7 +63,7 @@ pub struct LintStore {\n     passes: Option<Vec<LintPassObject>>,\n \n     /// Lints indexed by name.\n-    by_name: HashMap<String, LintId>,\n+    by_name: HashMap<String, TargetLint>,\n \n     /// Current levels of each lint, and where they were set.\n     levels: HashMap<LintId, LevelSource>,\n@@ -73,6 +73,15 @@ pub struct LintStore {\n     lint_groups: HashMap<&'static str, (Vec<LintId>, bool)>,\n }\n \n+/// The targed of the `by_name` map, which accounts for renaming/deprecation.\n+enum TargetLint {\n+    /// A direct lint target\n+    Id(LintId),\n+\n+    /// Temporary renaming, used for easing migration pain; see #16545\n+    Renamed(String, LintId),\n+}\n+\n impl LintStore {\n     fn get_level_source(&self, lint: LintId) -> LevelSource {\n         match self.levels.find(&lint) {\n@@ -115,7 +124,7 @@ impl LintStore {\n             self.lints.push((*lint, from_plugin));\n \n             let id = LintId::of(*lint);\n-            if !self.by_name.insert(lint.name_lower(), id) {\n+            if !self.by_name.insert(lint.name_lower(), Id(id)) {\n                 let msg = format!(\"duplicate specification of lint {}\", lint.name_lower());\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n@@ -154,6 +163,14 @@ impl LintStore {\n         }\n     }\n \n+    fn register_renamed(&mut self, old_name: &str, new_name: &str) {\n+        let target = match self.by_name.find_equiv(&new_name) {\n+            Some(&Id(lint_id)) => lint_id.clone(),\n+            _ => fail!(\"invalid lint renaming of {} to {}\", old_name, new_name)\n+        };\n+        self.by_name.insert(old_name.to_string(), Renamed(new_name.to_string(), target));\n+    }\n+\n     pub fn register_builtin(&mut self, sess: Option<&Session>) {\n         macro_rules! add_builtin ( ( $sess:ident, $($name:ident),*, ) => (\n             {$(\n@@ -175,20 +192,20 @@ impl LintStore {\n                      HardwiredLints,\n                      WhileTrue,\n                      UnusedCasts,\n-                     CTypes,\n-                     HeapMemory,\n-                     UnusedAttribute,\n-                     PathStatement,\n-                     UnusedResult,\n+                     ImproperCTypes,\n+                     BoxPointers,\n+                     UnusedAttributes,\n+                     PathStatements,\n+                     UnusedResults,\n                      NonCamelCaseTypes,\n                      NonSnakeCase,\n-                     NonUppercaseStatics,\n-                     UnnecessaryParens,\n-                     UnnecessaryImportBraces,\n+                     NonUpperCaseGlobals,\n+                     UnusedParens,\n+                     UnusedImportBraces,\n                      UnusedUnsafe,\n-                     UnsafeBlock,\n+                     UnsafeBlocks,\n                      UnusedMut,\n-                     UnnecessaryAllocation,\n+                     UnusedAllocation,\n                      Stability,\n         )\n \n@@ -199,21 +216,68 @@ impl LintStore {\n         )\n \n         add_lint_group!(sess, \"bad_style\",\n-                        NON_CAMEL_CASE_TYPES, NON_SNAKE_CASE, NON_UPPERCASE_STATICS)\n+                        NON_CAMEL_CASE_TYPES, NON_SNAKE_CASE, NON_UPPER_CASE_GLOBALS)\n \n         add_lint_group!(sess, \"unused\",\n-                        UNUSED_IMPORTS, UNUSED_VARIABLE, DEAD_ASSIGNMENT, DEAD_CODE,\n-                        UNUSED_MUT, UNREACHABLE_CODE, UNUSED_EXTERN_CRATE, UNUSED_MUST_USE,\n-                        UNUSED_UNSAFE, UNUSED_RESULT, PATH_STATEMENT)\n+                        UNUSED_IMPORTS, UNUSED_VARIABLES, UNUSED_ASSIGNMENTS, DEAD_CODE,\n+                        UNUSED_MUT, UNREACHABLE_CODE, UNUSED_EXTERN_CRATES, UNUSED_MUST_USE,\n+                        UNUSED_UNSAFE, UNUSED_RESULTS, PATH_STATEMENTS)\n \n         // We have one lint pass defined in this module.\n         self.register_pass(sess, false, box GatherNodeLevels as LintPassObject);\n+\n+        // Insert temporary renamings for a one-time deprecation (#16545)\n+        self.register_renamed(\"unnecessary_typecast\", \"unused_typecasts\");\n+        self.register_renamed(\"unsigned_negate\", \"unsigned_negation\");\n+        self.register_renamed(\"type_limits\", \"unused_comparisons\");\n+        self.register_renamed(\"type_overflow\", \"overflowing_literals\");\n+        self.register_renamed(\"ctypes\", \"improper_ctypes\");\n+        self.register_renamed(\"owned_heap_memory\", \"box_pointers\");\n+        self.register_renamed(\"unused_attribute\", \"unused_attributes\");\n+        self.register_renamed(\"path_statement\", \"path_statements\");\n+        self.register_renamed(\"unused_result\", \"unused_results\");\n+        self.register_renamed(\"non_uppercase_statics\", \"non_upper_case_globals\");\n+        self.register_renamed(\"unnecessary_parens\", \"unused_parens\");\n+        self.register_renamed(\"unnecessary_import_braces\", \"unused_import_braces\");\n+        self.register_renamed(\"unsafe_block\", \"unsafe_blocks\");\n+        self.register_renamed(\"unnecessary_allocation\", \"unused_allocation\");\n+        self.register_renamed(\"missing_doc\", \"missing_docs\");\n+        self.register_renamed(\"unused_extern_crate\", \"unused_extern_crates\");\n+        self.register_renamed(\"unnecessary_qualification\", \"unused_qualifications\");\n+        self.register_renamed(\"unrecognized_lint\", \"unknown_lints\");\n+        self.register_renamed(\"unused_variable\", \"unused_variables\");\n+        self.register_renamed(\"dead_assignment\", \"unused_assignments\");\n+        self.register_renamed(\"unknown_crate_type\", \"unknown_crate_types\");\n+        self.register_renamed(\"variant_size_difference\", \"variant_size_differences\");\n+        self.register_renamed(\"transmute_fat_ptr\", \"fat_ptr_transmutes\");\n+\n+    }\n+\n+    #[allow(unused_variable)]\n+    fn find_lint(&self, lint_name: &str, sess: &Session, span: Option<Span>)\n+                 -> Option<LintId>\n+    {\n+        match self.by_name.find_equiv(&lint_name) {\n+            Some(&Id(lint_id)) => Some(lint_id),\n+            Some(&Renamed(ref new_name, lint_id)) => {\n+                // NOTE(stage0): add the following code after the next snapshot\n+\n+                // let warning = format!(\"lint {} has been renamed to {}\",\n+                //                       lint_name, new_name);\n+                // match span {\n+                //     Some(span) => sess.span_warn(span, warning.as_slice()),\n+                //     None => sess.warn(warning.as_slice()),\n+                // };\n+                Some(lint_id)\n+            }\n+            None => None\n+        }\n     }\n \n     pub fn process_command_line(&mut self, sess: &Session) {\n         for &(ref lint_name, level) in sess.opts.lint_opts.iter() {\n-            match self.by_name.find_equiv(&lint_name.as_slice()) {\n-                Some(&lint_id) => self.set_level(lint_id, (level, CommandLine)),\n+            match self.find_lint(lint_name.as_slice(), sess, None) {\n+                Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.ref0().clone()))\n                                                  .collect::<HashMap<&'static str, Vec<LintId>>>()\n@@ -421,16 +485,16 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                     continue;\n                 }\n                 Ok((lint_name, level, span)) => {\n-                    match self.lints.by_name.find_equiv(&lint_name.get()) {\n-                        Some(&lint_id) => vec![(lint_id, level, span)],\n+                    match self.lints.find_lint(lint_name.get(), &self.tcx.sess, Some(span)) {\n+                        Some(lint_id) => vec![(lint_id, level, span)],\n                         None => {\n                             match self.lints.lint_groups.find_equiv(&lint_name.get()) {\n                                 Some(&(ref v, _)) => v.iter()\n                                                       .map(|lint_id: &LintId|\n                                                            (*lint_id, level, span))\n                                                       .collect(),\n                                 None => {\n-                                    self.span_lint(builtin::UNRECOGNIZED_LINT, span,\n+                                    self.span_lint(builtin::UNKNOWN_LINTS, span,\n                                                format!(\"unknown `{}` attribute: `{}`\",\n                                                        level.as_str(), lint_name).as_slice());\n                                     continue;\n@@ -713,7 +777,7 @@ impl LintPass for GatherNodeLevels {\n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         match it.node {\n             ast::ItemEnum(..) => {\n-                let lint_id = LintId::of(builtin::VARIANT_SIZE_DIFFERENCE);\n+                let lint_id = LintId::of(builtin::VARIANT_SIZE_DIFFERENCES);\n                 let lvlsrc = cx.lints.get_level_source(lint_id);\n                 match lvlsrc {\n                     (lvl, _) if lvl != Allow => {"}, {"sha": "ac9df3597705078fe35852f85236cbfcaa3573d6", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=ea8a5df431bfdea5c82d380f5832ab89a9f8fa03", "patch": "@@ -1629,11 +1629,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 };\n \n                 if is_assigned {\n-                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLE, id, sp,\n+                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLES, id, sp,\n                         format!(\"variable `{}` is assigned to, but never used\",\n                                 *name));\n                 } else {\n-                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLE, id, sp,\n+                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLES, id, sp,\n                         format!(\"unused variable: `{}`\", *name));\n                 }\n             }\n@@ -1651,7 +1651,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         if self.live_on_exit(ln, var).is_none() {\n             let r = self.should_warn(var);\n             for name in r.iter() {\n-                self.ir.tcx.sess.add_lint(lint::builtin::DEAD_ASSIGNMENT, id, sp,\n+                self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_ASSIGNMENTS, id, sp,\n                     format!(\"value assigned to `{}` is never read\", *name));\n             }\n         }"}, {"sha": "06ebd70977ff88fda693bcb523548daa8d37d26c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=ea8a5df431bfdea5c82d380f5832ab89a9f8fa03", "patch": "@@ -5232,7 +5232,7 @@ impl<'a> Resolver<'a> {\n             match (def, unqualified_def) {\n                 (Some((ref d, _)), Some((ref ud, _))) if *d == *ud => {\n                     self.session\n-                        .add_lint(lint::builtin::UNNECESSARY_QUALIFICATION,\n+                        .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                                   id,\n                                   path.span,\n                                   \"unnecessary qualification\".to_string());\n@@ -6125,7 +6125,7 @@ impl<'a> Resolver<'a> {\n                 match self.session.cstore.find_extern_mod_stmt_cnum(id)\n                 {\n                     Some(crate_num) => if !self.used_crates.contains(&crate_num) {\n-                    self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATE,\n+                    self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n                                           id,\n                                           vi.span,\n                                           \"unused extern crate\".to_string());"}, {"sha": "ebc46bb2bfc945d39370d1ac12fd66fb1078d7f1", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ea8a5df431bfdea5c82d380f5832ab89a9f8fa03", "patch": "@@ -2078,7 +2078,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n     let mut sizes = Vec::new(); // does no allocation if no pushes, thankfully\n \n     let levels = ccx.tcx().node_lint_levels.borrow();\n-    let lint_id = lint::LintId::of(lint::builtin::VARIANT_SIZE_DIFFERENCE);\n+    let lint_id = lint::LintId::of(lint::builtin::VARIANT_SIZE_DIFFERENCES);\n     let lvlsrc = match levels.find(&(id, lint_id)) {\n         None | Some(&(lint::Allow, _)) => return,\n         Some(&lvlsrc) => lvlsrc,\n@@ -2115,7 +2115,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n     if largest > slargest * 3 && slargest > 0 {\n         // Use lint::raw_emit_lint rather than sess.add_lint because the lint-printing\n         // pass for the latter already ran.\n-        lint::raw_emit_lint(&ccx.tcx().sess, lint::builtin::VARIANT_SIZE_DIFFERENCE,\n+        lint::raw_emit_lint(&ccx.tcx().sess, lint::builtin::VARIANT_SIZE_DIFFERENCES,\n                             lvlsrc, Some(sp),\n                             format!(\"enum variant is more than three times larger \\\n                                      ({} bytes) than the next largest (ignoring padding)\","}, {"sha": "f463f258ad550765e15abb0951f24e465cd036a6", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8a5df431bfdea5c82d380f5832ab89a9f8fa03/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=ea8a5df431bfdea5c82d380f5832ab89a9f8fa03", "patch": "@@ -122,7 +122,7 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n         if ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.to) ||\n            ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.from) {\n             ccx.sess()\n-               .add_lint(::lint::builtin::TRANSMUTE_FAT_PTR,\n+               .add_lint(::lint::builtin::FAT_PTR_TRANSMUTES,\n                          transmute_restriction.id,\n                          transmute_restriction.span,\n                          format!(\"Transmuting fat pointer types; {} to {}.\\"}]}