{"sha": "7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32", "node_id": "C_kwDOAAsO6NoAKDdhYTVlYTlhNGExMGE2NTdkYmZhNThjMTJhMTFhYTJjZDBiNWJjMzI", "commit": {"author": {"name": "Caio", "email": "c410.f3r@gmail.com", "date": "2022-03-01T10:43:12Z"}, "committer": {"name": "Caio", "email": "c410.f3r@gmail.com", "date": "2022-03-01T10:43:12Z"}, "message": "7 - Make more use of `let_chains`\n\nContinuation of #94376.\n\ncc #53667", "tree": {"sha": "a16ff2183eeabf950eb3ac769ad98187edc08466", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a16ff2183eeabf950eb3ac769ad98187edc08466"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32", "html_url": "https://github.com/rust-lang/rust/commit/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/comments", "author": {"login": "c410-f3r", "id": 17877264, "node_id": "MDQ6VXNlcjE3ODc3MjY0", "avatar_url": "https://avatars.githubusercontent.com/u/17877264?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c410-f3r", "html_url": "https://github.com/c410-f3r", "followers_url": "https://api.github.com/users/c410-f3r/followers", "following_url": "https://api.github.com/users/c410-f3r/following{/other_user}", "gists_url": "https://api.github.com/users/c410-f3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/c410-f3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c410-f3r/subscriptions", "organizations_url": "https://api.github.com/users/c410-f3r/orgs", "repos_url": "https://api.github.com/users/c410-f3r/repos", "events_url": "https://api.github.com/users/c410-f3r/events{/privacy}", "received_events_url": "https://api.github.com/users/c410-f3r/received_events", "type": "User", "site_admin": false}, "committer": {"login": "c410-f3r", "id": 17877264, "node_id": "MDQ6VXNlcjE3ODc3MjY0", "avatar_url": "https://avatars.githubusercontent.com/u/17877264?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c410-f3r", "html_url": "https://github.com/c410-f3r", "followers_url": "https://api.github.com/users/c410-f3r/followers", "following_url": "https://api.github.com/users/c410-f3r/following{/other_user}", "gists_url": "https://api.github.com/users/c410-f3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/c410-f3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c410-f3r/subscriptions", "organizations_url": "https://api.github.com/users/c410-f3r/orgs", "repos_url": "https://api.github.com/users/c410-f3r/repos", "events_url": "https://api.github.com/users/c410-f3r/events{/privacy}", "received_events_url": "https://api.github.com/users/c410-f3r/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e5a6ffb14fc47051b0a23410c681ad6e4af045f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e5a6ffb14fc47051b0a23410c681ad6e4af045f", "html_url": "https://github.com/rust-lang/rust/commit/6e5a6ffb14fc47051b0a23410c681ad6e4af045f"}], "stats": {"total": 212, "additions": 100, "deletions": 112}, "files": [{"sha": "ef4b27a15d8b80bb96a010c3c16c263d74c64be0", "filename": "compiler/rustc_mir_transform/src/const_debuginfo.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_debuginfo.rs?ref=7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32", "patch": "@@ -55,10 +55,8 @@ fn find_optimization_oportunities<'tcx>(body: &Body<'tcx>) -> Vec<(Local, Consta\n \n     let mut locals_to_debuginfo = BitSet::new_empty(body.local_decls.len());\n     for debuginfo in &body.var_debug_info {\n-        if let VarDebugInfoContents::Place(p) = debuginfo.value {\n-            if let Some(l) = p.as_local() {\n-                locals_to_debuginfo.insert(l);\n-            }\n+        if let VarDebugInfoContents::Place(p) = debuginfo.value && let Some(l) = p.as_local() {\n+            locals_to_debuginfo.insert(l);\n         }\n     }\n "}, {"sha": "c5ef1e101460ff7aebbb759a1f0b54bb2b09da79", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32", "patch": "@@ -633,24 +633,22 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn propagate_operand(&mut self, operand: &mut Operand<'tcx>) {\n         match *operand {\n             Operand::Copy(l) | Operand::Move(l) => {\n-                if let Some(value) = self.get_const(l) {\n-                    if self.should_const_prop(&value) {\n-                        // FIXME(felix91gr): this code only handles `Scalar` cases.\n-                        // For now, we're not handling `ScalarPair` cases because\n-                        // doing so here would require a lot of code duplication.\n-                        // We should hopefully generalize `Operand` handling into a fn,\n-                        // and use it to do const-prop here and everywhere else\n-                        // where it makes sense.\n-                        if let interpret::Operand::Immediate(interpret::Immediate::Scalar(\n-                            ScalarMaybeUninit::Scalar(scalar),\n-                        )) = *value\n-                        {\n-                            *operand = self.operand_from_scalar(\n-                                scalar,\n-                                value.layout.ty,\n-                                self.source_info.unwrap().span,\n-                            );\n-                        }\n+                if let Some(value) = self.get_const(l) && self.should_const_prop(&value) {\n+                    // FIXME(felix91gr): this code only handles `Scalar` cases.\n+                    // For now, we're not handling `ScalarPair` cases because\n+                    // doing so here would require a lot of code duplication.\n+                    // We should hopefully generalize `Operand` handling into a fn,\n+                    // and use it to do const-prop here and everywhere else\n+                    // where it makes sense.\n+                    if let interpret::Operand::Immediate(interpret::Immediate::Scalar(\n+                        ScalarMaybeUninit::Scalar(scalar),\n+                    )) = *value\n+                    {\n+                        *operand = self.operand_from_scalar(\n+                            scalar,\n+                            value.layout.ty,\n+                            self.source_info.unwrap().span,\n+                        );\n                     }\n                 }\n             }\n@@ -1086,15 +1084,13 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                 // This will return None if the above `const_prop` invocation only \"wrote\" a\n                 // type whose creation requires no write. E.g. a generator whose initial state\n                 // consists solely of uninitialized memory (so it doesn't capture any locals).\n-                if let Some(ref value) = self.get_const(place) {\n-                    if self.should_const_prop(value) {\n-                        trace!(\"replacing {:?} with {:?}\", rval, value);\n-                        self.replace_with_const(rval, value, source_info);\n-                        if can_const_prop == ConstPropMode::FullConstProp\n-                            || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n-                        {\n-                            trace!(\"propagated into {:?}\", place);\n-                        }\n+                if let Some(ref value) = self.get_const(place) && self.should_const_prop(value) {\n+                    trace!(\"replacing {:?} with {:?}\", rval, value);\n+                    self.replace_with_const(rval, value, source_info);\n+                    if can_const_prop == ConstPropMode::FullConstProp\n+                        || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n+                    {\n+                        trace!(\"propagated into {:?}\", place);\n                     }\n                 }\n                 match can_const_prop {"}, {"sha": "8e28ed2426bbb0fa99083e079c9cc1fd8889eb1a", "filename": "compiler/rustc_mir_transform/src/coverage/debug.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs?ref=7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32", "patch": "@@ -357,14 +357,12 @@ impl DebugCounters {\n         if let Some(counters) = &self.some_counters {\n             if let Some(DebugCounter { counter_kind, some_block_label }) = counters.get(&operand) {\n                 if let CoverageKind::Expression { .. } = counter_kind {\n-                    if let Some(block_label) = some_block_label {\n-                        if debug_options().counter_format.block {\n-                            return format!(\n-                                \"{}:({})\",\n-                                block_label,\n-                                self.format_counter_kind(counter_kind)\n-                            );\n-                        }\n+                    if let Some(label) = some_block_label && debug_options().counter_format.block {\n+                        return format!(\n+                            \"{}:({})\",\n+                            label,\n+                            self.format_counter_kind(counter_kind)\n+                        );\n                     }\n                     return format!(\"({})\", self.format_counter_kind(counter_kind));\n                 }"}, {"sha": "a36ba9300e4ff9bbbd9a97a31664c0aa0ebceee3", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32", "patch": "@@ -191,16 +191,13 @@ impl CoverageSpan {\n     /// If the span is part of a macro, and the macro is visible (expands directly to the given\n     /// body_span), returns the macro name symbol.\n     pub fn visible_macro(&self, body_span: Span) -> Option<Symbol> {\n-        if let Some(current_macro) = self.current_macro() {\n-            if self\n-                .expn_span\n-                .parent_callsite()\n-                .unwrap_or_else(|| bug!(\"macro must have a parent\"))\n-                .ctxt()\n-                == body_span.ctxt()\n-            {\n-                return Some(current_macro);\n-            }\n+        if let Some(current_macro) = self.current_macro() && self\n+            .expn_span\n+            .parent_callsite()\n+            .unwrap_or_else(|| bug!(\"macro must have a parent\"))\n+            .ctxt() == body_span.ctxt()\n+        {\n+            return Some(current_macro);\n         }\n         None\n     }\n@@ -584,21 +581,19 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     /// In either case, no more spans will match the span of `pending_dups`, so\n     /// add the `pending_dups` if they don't overlap `curr`, and clear the list.\n     fn check_pending_dups(&mut self) {\n-        if let Some(dup) = self.pending_dups.last() {\n-            if dup.span != self.prev().span {\n-                debug!(\n-                    \"    SAME spans, but pending_dups are NOT THE SAME, so BCBs matched on \\\n-                    previous iteration, or prev started a new disjoint span\"\n-                );\n-                if dup.span.hi() <= self.curr().span.lo() {\n-                    let pending_dups = self.pending_dups.split_off(0);\n-                    for dup in pending_dups.into_iter() {\n-                        debug!(\"    ...adding at least one pending={:?}\", dup);\n-                        self.push_refined_span(dup);\n-                    }\n-                } else {\n-                    self.pending_dups.clear();\n+        if let Some(dup) = self.pending_dups.last() && dup.span != self.prev().span {\n+            debug!(\n+                \"    SAME spans, but pending_dups are NOT THE SAME, so BCBs matched on \\\n+                previous iteration, or prev started a new disjoint span\"\n+            );\n+            if dup.span.hi() <= self.curr().span.lo() {\n+                let pending_dups = self.pending_dups.split_off(0);\n+                for dup in pending_dups.into_iter() {\n+                    debug!(\"    ...adding at least one pending={:?}\", dup);\n+                    self.push_refined_span(dup);\n                 }\n+            } else {\n+                self.pending_dups.clear();\n             }\n         }\n     }"}, {"sha": "5d0b58e9c53604cf00035359ca4a29c8c24f805f", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32", "patch": "@@ -549,14 +549,15 @@ impl<'a> Conflicts<'a> {\n                 target: _,\n                 unwind: _,\n             } => {\n-                if let Some(place) = value.place() {\n-                    if !place.is_indirect() && !dropped_place.is_indirect() {\n-                        self.record_local_conflict(\n-                            place.local,\n-                            dropped_place.local,\n-                            \"DropAndReplace operand overlap\",\n-                        );\n-                    }\n+                if let Some(place) = value.place()\n+                    && !place.is_indirect()\n+                    && !dropped_place.is_indirect()\n+                {\n+                    self.record_local_conflict(\n+                        place.local,\n+                        dropped_place.local,\n+                        \"DropAndReplace operand overlap\",\n+                    );\n                 }\n             }\n             TerminatorKind::Yield { value, resume: _, resume_arg, drop: _ } => {\n@@ -614,14 +615,15 @@ impl<'a> Conflicts<'a> {\n                             for op in operands {\n                                 match op {\n                                     InlineAsmOperand::In { reg: _, value } => {\n-                                        if let Some(p) = value.place() {\n-                                            if !p.is_indirect() && !dest_place.is_indirect() {\n-                                                self.record_local_conflict(\n-                                                    p.local,\n-                                                    dest_place.local,\n-                                                    \"asm! operand overlap\",\n-                                                );\n-                                            }\n+                                        if let Some(p) = value.place()\n+                                            && !p.is_indirect()\n+                                            && !dest_place.is_indirect()\n+                                        {\n+                                            self.record_local_conflict(\n+                                                p.local,\n+                                                dest_place.local,\n+                                                \"asm! operand overlap\",\n+                                            );\n                                         }\n                                     }\n                                     InlineAsmOperand::Out {\n@@ -643,24 +645,26 @@ impl<'a> Conflicts<'a> {\n                                         in_value,\n                                         out_place,\n                                     } => {\n-                                        if let Some(place) = in_value.place() {\n-                                            if !place.is_indirect() && !dest_place.is_indirect() {\n-                                                self.record_local_conflict(\n-                                                    place.local,\n-                                                    dest_place.local,\n-                                                    \"asm! operand overlap\",\n-                                                );\n-                                            }\n+                                        if let Some(place) = in_value.place()\n+                                            && !place.is_indirect()\n+                                            && !dest_place.is_indirect()\n+                                        {\n+                                            self.record_local_conflict(\n+                                                place.local,\n+                                                dest_place.local,\n+                                                \"asm! operand overlap\",\n+                                            );\n                                         }\n \n-                                        if let Some(place) = out_place {\n-                                            if !place.is_indirect() && !dest_place.is_indirect() {\n-                                                self.record_local_conflict(\n-                                                    place.local,\n-                                                    dest_place.local,\n-                                                    \"asm! operand overlap\",\n-                                                );\n-                                            }\n+                                        if let Some(place) = out_place\n+                                            && !place.is_indirect()\n+                                            && !dest_place.is_indirect()\n+                                        {\n+                                            self.record_local_conflict(\n+                                                place.local,\n+                                                dest_place.local,\n+                                                \"asm! operand overlap\",\n+                                            );\n                                         }\n                                     }\n                                     InlineAsmOperand::Out { reg: _, late: _, place: None }"}, {"sha": "23e5f0b4f30c3a394de5fab5b0f449b472fd1661", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32", "patch": "@@ -724,12 +724,11 @@ impl<'tcx> Inliner<'tcx> {\n         caller_body: &mut Body<'tcx>,\n     ) -> Local {\n         // Reuse the operand if it is a moved temporary.\n-        if let Operand::Move(place) = &arg {\n-            if let Some(local) = place.as_local() {\n-                if caller_body.local_kind(local) == LocalKind::Temp {\n-                    return local;\n-                }\n-            }\n+        if let Operand::Move(place) = &arg\n+            && let Some(local) = place.as_local()\n+            && caller_body.local_kind(local) == LocalKind::Temp\n+        {\n+            return local;\n         }\n \n         // Otherwise, create a temporary for the argument."}, {"sha": "385fcc43496e3695d635d57eac0ff712939defa4", "filename": "compiler/rustc_mir_transform/src/instcombine.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs?ref=7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32", "patch": "@@ -77,10 +77,8 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n                     _ => None,\n                 };\n \n-                if let Some(new) = new {\n-                    if self.should_combine(source_info, rvalue) {\n-                        *rvalue = new;\n-                    }\n+                if let Some(new) = new && self.should_combine(source_info, rvalue) {\n+                    *rvalue = new;\n                 }\n             }\n "}, {"sha": "3b2332a6e31422bcfdb5b06b213900ce8aef1fea", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32", "patch": "@@ -1,16 +1,17 @@\n+#![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n-#![feature(option_get_or_insert_default)]\n-#![feature(once_cell)]\n #![feature(never_type)]\n+#![feature(once_cell)]\n+#![feature(option_get_or_insert_default)]\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "b87220a3aa4f38eafce201c7711025d2d6ad3c5f", "filename": "compiler/rustc_mir_transform/src/required_consts.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs?ref=7aa5ea9a4a10a657dbfa58c12a11aa2cd0b5bc32", "patch": "@@ -14,10 +14,9 @@ impl<'a, 'tcx> RequiredConstsVisitor<'a, 'tcx> {\n \n impl<'tcx> Visitor<'tcx> for RequiredConstsVisitor<'_, 'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, _: Location) {\n-        if let Some(ct) = constant.literal.const_for_ty() {\n-            if let ConstKind::Unevaluated(_) = ct.val() {\n-                self.required_consts.push(*constant);\n-            }\n+        let literal = constant.literal;\n+        if let Some(ct) = literal.const_for_ty() && let ConstKind::Unevaluated(_) = ct.val() {\n+            self.required_consts.push(*constant);\n         }\n     }\n }"}]}