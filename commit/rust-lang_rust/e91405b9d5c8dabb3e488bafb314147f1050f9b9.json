{"sha": "e91405b9d5c8dabb3e488bafb314147f1050f9b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MTQwNWI5ZDVjOGRhYmIzZTQ4OGJhZmIzMTQxNDdmMTA1MGY5Yjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-03T04:50:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-03T04:50:28Z"}, "message": "Auto merge of #87262 - dtolnay:negative, r=Aaron1011\n\nSupport negative numbers in Literal::from_str\n\nproc_macro::Literal has allowed negative numbers in a single literal token ever since Rust 1.29, using https://doc.rust-lang.org/stable/proc_macro/struct.Literal.html#method.isize_unsuffixed and similar constructors.\n\n```rust\nlet lit = proc_macro::Literal::isize_unsuffixed(-10);\n```\n\nHowever, the suite of constructors on Literal is not sufficient for all use cases, for example arbitrary precision floats, or custom suffixes in FFI macros.\n\n```rust\nlet lit = proc_macro::Literal::f64_unsuffixed(0.101001000100001000001000000100000001); // :(\nlet lit = proc_macro::Literal::i???_suffixed(10ulong); // :(\n```\n\nFor those, macros construct the literal using from_str instead, which preserves arbitrary precision, custom suffixes, base, and digit grouping.\n\n```rust\nlet lit = \"0.101001000100001000001000000100000001\".parse::<Literal>().unwrap();\nlet lit = \"10ulong\".parse::<Literal>().unwrap();\nlet lit = \"0b1000_0100_0010_0001\".parse::<Literal>().unwrap();\n```\n\nHowever, until this PR it was not possible to construct a literal token that is **both** negative **and** preserving of arbitrary precision etc.\n\nThis PR fixes `Literal::from_str` to recognize negative integer and float literals.", "tree": {"sha": "e685ca7d120d1d9e26e06a1c4a64142c9f9da488", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e685ca7d120d1d9e26e06a1c4a64142c9f9da488"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e91405b9d5c8dabb3e488bafb314147f1050f9b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e91405b9d5c8dabb3e488bafb314147f1050f9b9", "html_url": "https://github.com/rust-lang/rust/commit/e91405b9d5c8dabb3e488bafb314147f1050f9b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e91405b9d5c8dabb3e488bafb314147f1050f9b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "810b9267f38a398c28dd213bad4acc58dce0199a", "url": "https://api.github.com/repos/rust-lang/rust/commits/810b9267f38a398c28dd213bad4acc58dce0199a", "html_url": "https://github.com/rust-lang/rust/commit/810b9267f38a398c28dd213bad4acc58dce0199a"}, {"sha": "55ff45a5c25c49e665a9459b8d6ea03ae2c44476", "url": "https://api.github.com/repos/rust-lang/rust/commits/55ff45a5c25c49e665a9459b8d6ea03ae2c44476", "html_url": "https://github.com/rust-lang/rust/commit/55ff45a5c25c49e665a9459b8d6ea03ae2c44476"}], "stats": {"total": 78, "additions": 56, "deletions": 22}, "files": [{"sha": "47cc2ecb4bfdd8267155485639f8ca0eae7b454b", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e91405b9d5c8dabb3e488bafb314147f1050f9b9/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91405b9d5c8dabb3e488bafb314147f1050f9b9/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=e91405b9d5c8dabb3e488bafb314147f1050f9b9", "patch": "@@ -1,7 +1,7 @@\n use crate::base::{ExtCtxt, ResolverExpand};\n \n use rustc_ast as ast;\n-use rustc_ast::token::{self, Nonterminal, NtIdent, TokenKind};\n+use rustc_ast::token::{self, Nonterminal, NtIdent};\n use rustc_ast::tokenstream::{self, CanSynthesizeMissingTokens};\n use rustc_ast::tokenstream::{DelimSpan, Spacing::*, TokenStream, TreeAndSpacing};\n use rustc_ast_pretty::pprust;\n@@ -537,30 +537,49 @@ impl server::Ident for Rustc<'_> {\n \n impl server::Literal for Rustc<'_> {\n     fn from_str(&mut self, s: &str) -> Result<Self::Literal, ()> {\n-        let override_span = None;\n-        let stream = parse_stream_from_source_str(\n-            FileName::proc_macro_source_code(s),\n-            s.to_owned(),\n-            self.sess,\n-            override_span,\n-        );\n-        if stream.len() != 1 {\n-            return Err(());\n-        }\n-        let tree = stream.into_trees().next().unwrap();\n-        let token = match tree {\n-            tokenstream::TokenTree::Token(token) => token,\n-            tokenstream::TokenTree::Delimited { .. } => return Err(()),\n+        let name = FileName::proc_macro_source_code(s);\n+        let mut parser = rustc_parse::new_parser_from_source_str(self.sess, name, s.to_owned());\n+\n+        let first_span = parser.token.span.data();\n+        let minus_present = parser.eat(&token::BinOp(token::Minus));\n+\n+        let lit_span = parser.token.span.data();\n+        let mut lit = match parser.token.kind {\n+            token::Literal(lit) => lit,\n+            _ => return Err(()),\n         };\n-        let span_data = token.span.data();\n-        if (span_data.hi.0 - span_data.lo.0) as usize != s.len() {\n-            // There is a comment or whitespace adjacent to the literal.\n+\n+        // Check no comment or whitespace surrounding the (possibly negative)\n+        // literal, or more tokens after it.\n+        if (lit_span.hi.0 - first_span.lo.0) as usize != s.len() {\n             return Err(());\n         }\n-        let lit = match token.kind {\n-            TokenKind::Literal(lit) => lit,\n-            _ => return Err(()),\n-        };\n+\n+        if minus_present {\n+            // If minus is present, check no comment or whitespace in between it\n+            // and the literal token.\n+            if first_span.hi.0 != lit_span.lo.0 {\n+                return Err(());\n+            }\n+\n+            // Check literal is a kind we allow to be negated in a proc macro token.\n+            match lit.kind {\n+                token::LitKind::Bool\n+                | token::LitKind::Byte\n+                | token::LitKind::Char\n+                | token::LitKind::Str\n+                | token::LitKind::StrRaw(_)\n+                | token::LitKind::ByteStr\n+                | token::LitKind::ByteStrRaw(_)\n+                | token::LitKind::Err => return Err(()),\n+                token::LitKind::Integer | token::LitKind::Float => {}\n+            }\n+\n+            // Synthesize a new symbol that includes the minus sign.\n+            let symbol = Symbol::intern(&s[..1 + lit.symbol.len()]);\n+            lit = token::Lit::new(lit.kind, symbol, lit.suffix);\n+        }\n+\n         Ok(Literal { lit, span: self.call_site })\n     }\n     fn debug_kind(&mut self, literal: &Self::Literal) -> String {"}, {"sha": "3f5d8273b38b8829bf5b216fc9ad2f1943465f88", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e91405b9d5c8dabb3e488bafb314147f1050f9b9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91405b9d5c8dabb3e488bafb314147f1050f9b9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=e91405b9d5c8dabb3e488bafb314147f1050f9b9", "patch": "@@ -1600,6 +1600,10 @@ impl Symbol {\n         self.0.as_u32()\n     }\n \n+    pub fn len(self) -> usize {\n+        with_interner(|interner| interner.get(self).len())\n+    }\n+\n     pub fn is_empty(self) -> bool {\n         self == kw::Empty\n     }"}, {"sha": "a304c5e81a4bbba07c8bcdf6562d7d423bdcc4fa", "filename": "src/test/ui/proc-macro/auxiliary/api/parse.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e91405b9d5c8dabb3e488bafb314147f1050f9b9/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91405b9d5c8dabb3e488bafb314147f1050f9b9/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fapi%2Fparse.rs?ref=e91405b9d5c8dabb3e488bafb314147f1050f9b9", "patch": "@@ -1,9 +1,15 @@\n use proc_macro::Literal;\n \n pub fn test() {\n+    test_display_literal();\n     test_parse_literal();\n }\n \n+fn test_display_literal() {\n+    assert_eq!(Literal::isize_unsuffixed(-10).to_string(), \"- 10\");\n+    assert_eq!(Literal::isize_suffixed(-10).to_string(), \"- 10isize\");\n+}\n+\n fn test_parse_literal() {\n     assert_eq!(\"1\".parse::<Literal>().unwrap().to_string(), \"1\");\n     assert_eq!(\"1.0\".parse::<Literal>().unwrap().to_string(), \"1.0\");\n@@ -12,12 +18,17 @@ fn test_parse_literal() {\n     assert_eq!(\"b\\\"\\\"\".parse::<Literal>().unwrap().to_string(), \"b\\\"\\\"\");\n     assert_eq!(\"r##\\\"\\\"##\".parse::<Literal>().unwrap().to_string(), \"r##\\\"\\\"##\");\n     assert_eq!(\"10ulong\".parse::<Literal>().unwrap().to_string(), \"10ulong\");\n+    assert_eq!(\"-10ulong\".parse::<Literal>().unwrap().to_string(), \"- 10ulong\");\n \n+    assert!(\"true\".parse::<Literal>().is_err());\n+    assert!(\".8\".parse::<Literal>().is_err());\n     assert!(\"0 1\".parse::<Literal>().is_err());\n     assert!(\"'a\".parse::<Literal>().is_err());\n     assert!(\" 0\".parse::<Literal>().is_err());\n     assert!(\"0 \".parse::<Literal>().is_err());\n     assert!(\"/* comment */0\".parse::<Literal>().is_err());\n     assert!(\"0/* comment */\".parse::<Literal>().is_err());\n     assert!(\"0// comment\".parse::<Literal>().is_err());\n+    assert!(\"- 10\".parse::<Literal>().is_err());\n+    assert!(\"-'x'\".parse::<Literal>().is_err());\n }"}]}