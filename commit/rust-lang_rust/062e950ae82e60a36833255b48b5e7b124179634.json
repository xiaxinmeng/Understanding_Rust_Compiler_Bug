{"sha": "062e950ae82e60a36833255b48b5e7b124179634", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MmU5NTBhZTgyZTYwYTM2ODMzMjU1YjQ4YjVlN2IxMjQxNzk2MzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-04T06:01:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-04T06:01:40Z"}, "message": "auto merge of #12672 : korenchkin/rust/checked-bigint, r=alexcrichton", "tree": {"sha": "ba6cb1ecd4b433f51d3de353529ced71ee19fb2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba6cb1ecd4b433f51d3de353529ced71ee19fb2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/062e950ae82e60a36833255b48b5e7b124179634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/062e950ae82e60a36833255b48b5e7b124179634", "html_url": "https://github.com/rust-lang/rust/commit/062e950ae82e60a36833255b48b5e7b124179634", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/062e950ae82e60a36833255b48b5e7b124179634/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c0d0987be7967bef3f6a368452a7b65038dbf17", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c0d0987be7967bef3f6a368452a7b65038dbf17", "html_url": "https://github.com/rust-lang/rust/commit/3c0d0987be7967bef3f6a368452a7b65038dbf17"}, {"sha": "47cff94ab9b80d09753bc18bd305ee87493add2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/47cff94ab9b80d09753bc18bd305ee87493add2b", "html_url": "https://github.com/rust-lang/rust/commit/47cff94ab9b80d09753bc18bd305ee87493add2b"}], "stats": {"total": 233, "additions": 233, "deletions": 0}, "files": [{"sha": "71545e381515284df49c3c0a5db1fb48b83ee61d", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/062e950ae82e60a36833255b48b5e7b124179634/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062e950ae82e60a36833255b48b5e7b124179634/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=062e950ae82e60a36833255b48b5e7b124179634", "patch": "@@ -21,6 +21,7 @@ use Integer;\n use std::cmp;\n use std::fmt;\n use std::from_str::FromStr;\n+use std::num::CheckedDiv;\n use std::num::{Bitwise, ToPrimitive, FromPrimitive};\n use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n use std::rand::Rng;\n@@ -338,6 +339,40 @@ impl Neg<BigUint> for BigUint {\n     fn neg(&self) -> BigUint { fail!() }\n }\n \n+impl CheckedAdd for BigUint {\n+    #[inline]\n+    fn checked_add(&self, v: &BigUint) -> Option<BigUint> {\n+        return Some(self.add(v));\n+    }\n+}\n+\n+impl CheckedSub for BigUint {\n+    #[inline]\n+    fn checked_sub(&self, v: &BigUint) -> Option<BigUint> {\n+        if *self < *v {\n+            return None;\n+        }\n+        return Some(self.sub(v));\n+    }\n+}\n+\n+impl CheckedMul for BigUint {\n+    #[inline]\n+    fn checked_mul(&self, v: &BigUint) -> Option<BigUint> {\n+        return Some(self.mul(v));\n+    }\n+}\n+\n+impl CheckedDiv for BigUint {\n+    #[inline]\n+    fn checked_div(&self, v: &BigUint) -> Option<BigUint> {\n+        if v.is_zero() {\n+            return None;\n+        }\n+        return Some(self.div(v));\n+    }\n+}\n+\n impl Integer for BigUint {\n     #[inline]\n     fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n@@ -1053,6 +1088,38 @@ impl Neg<BigInt> for BigInt {\n     }\n }\n \n+impl CheckedAdd for BigInt {\n+    #[inline]\n+    fn checked_add(&self, v: &BigInt) -> Option<BigInt> {\n+        return Some(self.add(v));\n+    }\n+}\n+\n+impl CheckedSub for BigInt {\n+    #[inline]\n+    fn checked_sub(&self, v: &BigInt) -> Option<BigInt> {\n+        return Some(self.sub(v));\n+    }\n+}\n+\n+impl CheckedMul for BigInt {\n+    #[inline]\n+    fn checked_mul(&self, v: &BigInt) -> Option<BigInt> {\n+        return Some(self.mul(v));\n+    }\n+}\n+\n+impl CheckedDiv for BigInt {\n+    #[inline]\n+    fn checked_div(&self, v: &BigInt) -> Option<BigInt> {\n+        if v.is_zero() {\n+            return None;\n+        }\n+        return Some(self.div(v));\n+    }\n+}\n+\n+\n impl Integer for BigInt {\n     #[inline]\n     fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n@@ -1402,6 +1469,7 @@ mod biguint_tests {\n     use std::i64;\n     use std::num::{Zero, One, FromStrRadix, ToStrRadix};\n     use std::num::{ToPrimitive, FromPrimitive};\n+    use std::num::CheckedDiv;\n     use std::rand::{task_rng};\n     use std::str;\n     use std::u64;\n@@ -1822,6 +1890,82 @@ mod biguint_tests {\n         }\n     }\n \n+    #[test]\n+    fn test_checked_add() {\n+        for elm in sum_triples.iter() {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            assert!(a.checked_add(&b).unwrap() == c);\n+            assert!(b.checked_add(&a).unwrap() == c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_checked_sub() {\n+        for elm in sum_triples.iter() {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            assert!(c.checked_sub(&a).unwrap() == b);\n+            assert!(c.checked_sub(&b).unwrap() == a);\n+\n+            if a > c {\n+                assert!(a.checked_sub(&c).is_none());\n+            }\n+            if b > c {\n+                assert!(b.checked_sub(&c).is_none());\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_checked_mul() {\n+        for elm in mul_triples.iter() {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            assert!(a.checked_mul(&b).unwrap() == c);\n+            assert!(b.checked_mul(&a).unwrap() == c);\n+        }\n+\n+        for elm in div_rem_quadruples.iter() {\n+            let (aVec, bVec, cVec, dVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+            let d = BigUint::from_slice(dVec);\n+\n+            assert!(a == b.checked_mul(&c).unwrap() + d);\n+            assert!(a == c.checked_mul(&b).unwrap() + d);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_checked_div() {\n+        for elm in mul_triples.iter() {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            if !a.is_zero() {\n+                assert!(c.checked_div(&a).unwrap() == b);\n+            }\n+            if !b.is_zero() {\n+                assert!(c.checked_div(&b).unwrap() == a);\n+            }\n+\n+            assert!(c.checked_div(&Zero::zero()).is_none());\n+        }\n+    }\n+\n     #[test]\n     fn test_gcd() {\n         fn check(a: uint, b: uint, c: uint) {\n@@ -2058,6 +2202,7 @@ mod bigint_tests {\n \n     use std::cmp::{Less, Equal, Greater};\n     use std::i64;\n+    use std::num::CheckedDiv;\n     use std::num::{Zero, One, FromStrRadix, ToStrRadix};\n     use std::num::{ToPrimitive, FromPrimitive};\n     use std::rand::{task_rng};\n@@ -2399,6 +2544,94 @@ mod bigint_tests {\n         }\n     }\n \n+    #[test]\n+    fn test_checked_add() {\n+        for elm in sum_triples.iter() {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+\n+            assert!(a.checked_add(&b).unwrap() == c);\n+            assert!(b.checked_add(&a).unwrap() == c);\n+            assert!(c.checked_add(&(-a)).unwrap() == b);\n+            assert!(c.checked_add(&(-b)).unwrap() == a);\n+            assert!(a.checked_add(&(-c)).unwrap() == (-b));\n+            assert!(b.checked_add(&(-c)).unwrap() == (-a));\n+            assert!((-a).checked_add(&(-b)).unwrap() == (-c))\n+            assert!(a.checked_add(&(-a)).unwrap() == Zero::zero());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_checked_sub() {\n+        for elm in sum_triples.iter() {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+\n+            assert!(c.checked_sub(&a).unwrap() == b);\n+            assert!(c.checked_sub(&b).unwrap() == a);\n+            assert!((-b).checked_sub(&a).unwrap() == (-c))\n+            assert!((-a).checked_sub(&b).unwrap() == (-c))\n+            assert!(b.checked_sub(&(-a)).unwrap() == c);\n+            assert!(a.checked_sub(&(-b)).unwrap() == c);\n+            assert!((-c).checked_sub(&(-a)).unwrap() == (-b));\n+            assert!(a.checked_sub(&a).unwrap() == Zero::zero());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_checked_mul() {\n+        for elm in mul_triples.iter() {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+\n+            assert!(a.checked_mul(&b).unwrap() == c);\n+            assert!(b.checked_mul(&a).unwrap() == c);\n+\n+            assert!((-a).checked_mul(&b).unwrap() == -c);\n+            assert!((-b).checked_mul(&a).unwrap() == -c);\n+        }\n+\n+        for elm in div_rem_quadruples.iter() {\n+            let (aVec, bVec, cVec, dVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+            let d = BigInt::from_slice(Plus, dVec);\n+\n+            assert!(a == b.checked_mul(&c).unwrap() + d);\n+            assert!(a == c.checked_mul(&b).unwrap() + d);\n+        }\n+    }\n+    #[test]\n+    fn test_checked_div() {\n+        for elm in mul_triples.iter() {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+\n+            if !a.is_zero() {\n+                assert!(c.checked_div(&a).unwrap() == b);\n+                assert!((-c).checked_div(&(-a)).unwrap() == b);\n+                assert!((-c).checked_div(&a).unwrap() == -b);\n+            }\n+            if !b.is_zero() {\n+                assert!(c.checked_div(&b).unwrap() == a);\n+                assert!((-c).checked_div(&(-b)).unwrap() == a);\n+                assert!((-c).checked_div(&b).unwrap() == -a);\n+            }\n+\n+            assert!(c.checked_div(&Zero::zero()).is_none());\n+            assert!((-c).checked_div(&Zero::zero()).is_none());\n+        }\n+    }\n+\n     #[test]\n     fn test_gcd() {\n         fn check(a: int, b: int, c: int) {"}]}