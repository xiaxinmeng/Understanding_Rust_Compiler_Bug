{"sha": "92b04129fe6b1931f14199b01a5bfc78edb66a72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYjA0MTI5ZmU2YjE5MzFmMTQxOTliMDFhNWJmYzc4ZWRiNjZhNzI=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-06-29T21:16:44Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-07-01T15:12:49Z"}, "message": "Move `unsugar_range` to `utils::higher`", "tree": {"sha": "fec910654a98a97906a7dcfb1b71f3b586266870", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fec910654a98a97906a7dcfb1b71f3b586266870"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92b04129fe6b1931f14199b01a5bfc78edb66a72", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJXdohxAAoJEF5CfHlMukXoc+EP/iElR5oBUAkThbf4R2RBUs3N\ntZEuiEGr68YqDUReXgxN9Pewb4W7y/du+o+d/+5s5GCbpazvBRkjgPnLQTSvhlXI\nCf7GOAzpCnaparCZcuJvIAGJVuzMnQj/d/HXoWdc2O+qoLA2LhiKI6vg6ghSFxrH\nhgApaHFmuZYTN/xPXuBJt9v6dxYMbybW0NbfZrrCfiTJO1adWyAF2KdJ40EqbhXf\nRwQpG86cW+npVIPTzntsh0+he/5ynD9zNrAUerMqAYxPUGEyPAjrlmKoAZcjdBVY\nt7qu7aWNptp5byR/U8W7HdpjkMVMP37YL79JST0rYbbRXDKoFq/2q3YwEqO3Ezgu\nlAu3/fZbLcCB4XUBPSbNIwyCJtU5wrbURn95/oz+y1DkaeAuF1QiU1vPMe2IKWrx\nrEb8jyuAemToQFgSYOBZmoxvh8zt8cELlfS3R7k/ZMJFai1Yj3xqXv9mqqtpS9PH\n2H6xLQP2OWMLoI7MCaWSePhtetWfS40S1VpvZynYTuyxNRiX29+WJDqM6wVzqDkK\n7cuYpF/y9tjLqvrjXfmLKOqL4VgcRrJJxqO7ogOJfqSDenpirNbRThzKs85k59zO\n0YCnsaIBtskn2uMJIqlIiPFtPMPUNaNus/Tv85UVmMxbJxW66pN915xKX5lubzZO\n2UHTKJKMvHFv6mc/19dE\n=y+kd\n-----END PGP SIGNATURE-----", "payload": "tree fec910654a98a97906a7dcfb1b71f3b586266870\nparent ebf72cb67f3dcdd05ce812b020346dc318624b8a\nauthor mcarton <cartonmartin+git@gmail.com> 1467235004 +0200\ncommitter mcarton <cartonmartin+git@gmail.com> 1467385969 +0200\n\nMove `unsugar_range` to `utils::higher`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92b04129fe6b1931f14199b01a5bfc78edb66a72", "html_url": "https://github.com/rust-lang/rust/commit/92b04129fe6b1931f14199b01a5bfc78edb66a72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92b04129fe6b1931f14199b01a5bfc78edb66a72/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebf72cb67f3dcdd05ce812b020346dc318624b8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebf72cb67f3dcdd05ce812b020346dc318624b8a", "html_url": "https://github.com/rust-lang/rust/commit/ebf72cb67f3dcdd05ce812b020346dc318624b8a"}], "stats": {"total": 196, "additions": 99, "deletions": 97}, "files": [{"sha": "2c84c7cc13213fcf3bb00f76a3e8eb7386c4c5ef", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92b04129fe6b1931f14199b01a5bfc78edb66a72/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b04129fe6b1931f14199b01a5bfc78edb66a72/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=92b04129fe6b1931f14199b01a5bfc78edb66a72", "patch": "@@ -6,7 +6,7 @@ use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_math::ConstInt;\n use rustc::hir::*;\n use syntax::ast::RangeLimits;\n-use utils;\n+use utils::{self, higher};\n \n /// **What it does:** Check for out of bounds array indexing with a constant index.\n ///\n@@ -77,7 +77,7 @@ impl LateLintPass for ArrayIndexing {\n                 }\n \n                 // Index is a constant range\n-                if let Some(range) = utils::unsugar_range(index) {\n+                if let Some(range) = higher::range(index) {\n                     let start = range.start\n                         .map(|start| eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None))\n                         .map(|v| v.ok());\n@@ -94,7 +94,7 @@ impl LateLintPass for ArrayIndexing {\n                 }\n             }\n \n-            if let Some(range) = utils::unsugar_range(index) {\n+            if let Some(range) = higher::range(index) {\n                 // Full ranges are always valid\n                 if range.start.is_none() && range.end.is_none() {\n                     return;"}, {"sha": "e945afbf659e72f4a67511b0fb4cb4cb7927ccc8", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92b04129fe6b1931f14199b01a5bfc78edb66a72/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b04129fe6b1931f14199b01a5bfc78edb66a72/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=92b04129fe6b1931f14199b01a5bfc78edb66a72", "patch": "@@ -14,10 +14,9 @@ use std::collections::HashMap;\n use syntax::ast;\n \n use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, in_external_macro,\n-            span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then, unsugar_range,\n+            span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then, higher,\n             walk_ptrs_ty, recover_for_loop};\n use utils::paths;\n-use utils::UnsugaredRange;\n \n /// **What it does:** This lint checks for looping over the range of `0..len` of some collection just to get the values by index.\n ///\n@@ -333,7 +332,7 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n /// Check for looping over a range and then indexing a sequence with it.\n /// The iteratee must be a range literal.\n fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n-    if let Some(UnsugaredRange { start: Some(ref start), ref end, .. }) = unsugar_range(arg) {\n+    if let Some(higher::Range { start: Some(ref start), ref end, .. }) = higher::range(arg) {\n         // the var must be a single name\n         if let PatKind::Binding(_, ref ident, _) = pat.node {\n             let mut visitor = VarVisitor {\n@@ -427,7 +426,7 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n \n fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n     // if this for loop is iterating over a two-sided range...\n-    if let Some(UnsugaredRange { start: Some(ref start), end: Some(ref end), limits }) = unsugar_range(arg) {\n+    if let Some(higher::Range { start: Some(ref start), end: Some(ref end), limits }) = higher::range(arg) {\n         // ...and both sides are compile-time constant integers...\n         if let Ok(start_idx) = eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None) {\n             if let Ok(end_idx) = eval_const_expr_partial(cx.tcx, end, ExprTypeChecked, None) {"}, {"sha": "a042c966d942d9e41f8c57b7ee39200d0d23bc72", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92b04129fe6b1931f14199b01a5bfc78edb66a72/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b04129fe6b1931f14199b01a5bfc78edb66a72/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=92b04129fe6b1931f14199b01a5bfc78edb66a72", "patch": "@@ -1,7 +1,8 @@\n use rustc::lint::*;\n use rustc::hir::*;\n use syntax::codemap::Spanned;\n-use utils::{is_integer_literal, match_type, paths, snippet, span_lint, unsugar_range, UnsugaredRange};\n+use utils::{is_integer_literal, match_type, paths, snippet, span_lint};\n+use utils::higher;\n \n /// **What it does:** This lint checks for iterating over ranges with a `.step_by(0)`, which never terminates.\n ///\n@@ -54,7 +55,7 @@ impl LateLintPass for StepByZero {\n                     let ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = *iter,\n                     iter_name.as_str() == \"iter\",\n                     // range expression in .zip() call: 0..x.len()\n-                    let Some(UnsugaredRange { start: Some(ref start), end: Some(ref end), .. }) = unsugar_range(zip_arg),\n+                    let Some(higher::Range { start: Some(ref start), end: Some(ref end), .. }) = higher::range(zip_arg),\n                     is_integer_literal(start, 0),\n                     // .len() call\n                     let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,"}, {"sha": "979c044cdbf9c92dc96a9993d1724284722ee4f1", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/92b04129fe6b1931f14199b01a5bfc78edb66a72/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b04129fe6b1931f14199b01a5bfc78edb66a72/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=92b04129fe6b1931f14199b01a5bfc78edb66a72", "patch": "@@ -2,6 +2,7 @@\n \n use rustc::hir;\n use syntax::ast;\n+use utils::{match_path, paths};\n \n /// Convert a hir binary operator to the corresponding `ast` type.\n pub fn binop(op: hir::BinOp_) -> ast::BinOpKind {\n@@ -26,3 +27,91 @@ pub fn binop(op: hir::BinOp_) -> ast::BinOpKind {\n         hir::BiSub => ast::BinOpKind::Sub,\n     }\n }\n+\n+/// Represent a range akin to `ast::ExprKind::Range`.\n+#[derive(Debug, Copy, Clone)]\n+pub struct Range<'a> {\n+    pub start: Option<&'a hir::Expr>,\n+    pub end: Option<&'a hir::Expr>,\n+    pub limits: ast::RangeLimits,\n+}\n+\n+/// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n+pub fn range(expr: &hir::Expr) -> Option<Range> {\n+    // To be removed when ranges get stable.\n+    fn unwrap_unstable(expr: &hir::Expr) -> &hir::Expr {\n+        if let hir::ExprBlock(ref block) = expr.node {\n+            if block.rules == hir::BlockCheckMode::PushUnstableBlock || block.rules == hir::BlockCheckMode::PopUnstableBlock {\n+                if let Some(ref expr) = block.expr {\n+                    return expr;\n+                }\n+            }\n+        }\n+\n+        expr\n+    }\n+\n+    fn get_field<'a>(name: &str, fields: &'a [hir::Field]) -> Option<&'a hir::Expr> {\n+        let expr = &fields.iter()\n+                          .find(|field| field.name.node.as_str() == name)\n+                          .unwrap_or_else(|| panic!(\"missing {} field for range\", name))\n+                          .expr;\n+\n+        Some(unwrap_unstable(expr))\n+    }\n+\n+    // The range syntax is expanded to literal paths starting with `core` or `std` depending on\n+    // `#[no_std]`. Testing both instead of resolving the paths.\n+\n+    match unwrap_unstable(expr).node {\n+        hir::ExprPath(None, ref path) => {\n+            if match_path(path, &paths::RANGE_FULL_STD) || match_path(path, &paths::RANGE_FULL) {\n+                Some(Range {\n+                    start: None,\n+                    end: None,\n+                    limits: ast::RangeLimits::HalfOpen,\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+        hir::ExprStruct(ref path, ref fields, None) => {\n+            if match_path(path, &paths::RANGE_FROM_STD) || match_path(path, &paths::RANGE_FROM) {\n+                Some(Range {\n+                    start: get_field(\"start\", fields),\n+                    end: None,\n+                    limits: ast::RangeLimits::HalfOpen,\n+                })\n+            } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY_STD) ||\n+               match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n+                Some(Range {\n+                    start: get_field(\"start\", fields),\n+                    end: get_field(\"end\", fields),\n+                    limits: ast::RangeLimits::Closed,\n+                })\n+            } else if match_path(path, &paths::RANGE_STD) || match_path(path, &paths::RANGE) {\n+                Some(Range {\n+                    start: get_field(\"start\", fields),\n+                    end: get_field(\"end\", fields),\n+                    limits: ast::RangeLimits::HalfOpen,\n+                })\n+            } else if match_path(path, &paths::RANGE_TO_INCLUSIVE_STD) || match_path(path, &paths::RANGE_TO_INCLUSIVE) {\n+                Some(Range {\n+                    start: None,\n+                    end: get_field(\"end\", fields),\n+                    limits: ast::RangeLimits::Closed,\n+                })\n+            } else if match_path(path, &paths::RANGE_TO_STD) || match_path(path, &paths::RANGE_TO) {\n+                Some(Range {\n+                    start: None,\n+                    end: get_field(\"end\", fields),\n+                    limits: ast::RangeLimits::HalfOpen,\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+        _ => None,\n+    }\n+}\n+"}, {"sha": "3ceae788a4d0890d1371df9464b48ea7986667f7", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 88, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/92b04129fe6b1931f14199b01a5bfc78edb66a72/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b04129fe6b1931f14199b01a5bfc78edb66a72/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=92b04129fe6b1931f14199b01a5bfc78edb66a72", "patch": "@@ -13,7 +13,7 @@ use std::borrow::Cow;\n use std::env;\n use std::mem;\n use std::str::FromStr;\n-use syntax::ast::{self, LitKind, RangeLimits};\n+use syntax::ast::{self, LitKind};\n use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n@@ -683,93 +683,6 @@ pub fn camel_case_from(s: &str) -> usize {\n     last_i\n }\n \n-/// Represent a range akin to `ast::ExprKind::Range`.\n-#[derive(Debug, Copy, Clone)]\n-pub struct UnsugaredRange<'a> {\n-    pub start: Option<&'a Expr>,\n-    pub end: Option<&'a Expr>,\n-    pub limits: RangeLimits,\n-}\n-\n-/// Unsugar a `hir` range.\n-pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n-    // To be removed when ranges get stable.\n-    fn unwrap_unstable(expr: &Expr) -> &Expr {\n-        if let ExprBlock(ref block) = expr.node {\n-            if block.rules == BlockCheckMode::PushUnstableBlock || block.rules == BlockCheckMode::PopUnstableBlock {\n-                if let Some(ref expr) = block.expr {\n-                    return expr;\n-                }\n-            }\n-        }\n-\n-        expr\n-    }\n-\n-    fn get_field<'a>(name: &str, fields: &'a [Field]) -> Option<&'a Expr> {\n-        let expr = &fields.iter()\n-                          .find(|field| field.name.node.as_str() == name)\n-                          .unwrap_or_else(|| panic!(\"missing {} field for range\", name))\n-                          .expr;\n-\n-        Some(unwrap_unstable(expr))\n-    }\n-\n-    // The range syntax is expanded to literal paths starting with `core` or `std` depending on\n-    // `#[no_std]`. Testing both instead of resolving the paths.\n-\n-    match unwrap_unstable(expr).node {\n-        ExprPath(None, ref path) => {\n-            if match_path(path, &paths::RANGE_FULL_STD) || match_path(path, &paths::RANGE_FULL) {\n-                Some(UnsugaredRange {\n-                    start: None,\n-                    end: None,\n-                    limits: RangeLimits::HalfOpen,\n-                })\n-            } else {\n-                None\n-            }\n-        }\n-        ExprStruct(ref path, ref fields, None) => {\n-            if match_path(path, &paths::RANGE_FROM_STD) || match_path(path, &paths::RANGE_FROM) {\n-                Some(UnsugaredRange {\n-                    start: get_field(\"start\", fields),\n-                    end: None,\n-                    limits: RangeLimits::HalfOpen,\n-                })\n-            } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY_STD) ||\n-               match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n-                Some(UnsugaredRange {\n-                    start: get_field(\"start\", fields),\n-                    end: get_field(\"end\", fields),\n-                    limits: RangeLimits::Closed,\n-                })\n-            } else if match_path(path, &paths::RANGE_STD) || match_path(path, &paths::RANGE) {\n-                Some(UnsugaredRange {\n-                    start: get_field(\"start\", fields),\n-                    end: get_field(\"end\", fields),\n-                    limits: RangeLimits::HalfOpen,\n-                })\n-            } else if match_path(path, &paths::RANGE_TO_INCLUSIVE_STD) || match_path(path, &paths::RANGE_TO_INCLUSIVE) {\n-                Some(UnsugaredRange {\n-                    start: None,\n-                    end: get_field(\"end\", fields),\n-                    limits: RangeLimits::Closed,\n-                })\n-            } else if match_path(path, &paths::RANGE_TO_STD) || match_path(path, &paths::RANGE_TO) {\n-                Some(UnsugaredRange {\n-                    start: None,\n-                    end: get_field(\"end\", fields),\n-                    limits: RangeLimits::HalfOpen,\n-                })\n-            } else {\n-                None\n-            }\n-        }\n-        _ => None,\n-    }\n-}\n-\n /// Convenience function to get the return type of a function or `None` if the function diverges.\n pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> Option<ty::Ty<'tcx>> {\n     let parameter_env = ty::ParameterEnvironment::for_item(cx.tcx, fn_item);"}]}