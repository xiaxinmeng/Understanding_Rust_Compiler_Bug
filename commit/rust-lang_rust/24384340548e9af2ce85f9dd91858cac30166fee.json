{"sha": "24384340548e9af2ce85f9dd91858cac30166fee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0Mzg0MzQwNTQ4ZTlhZjJjZTg1ZjlkZDkxODU4Y2FjMzAxNjZmZWU=", "commit": {"author": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2018-04-26T22:16:27Z"}, "committer": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2018-05-17T05:00:30Z"}, "message": "compiletest: rustfmt", "tree": {"sha": "18901a51d68a3829e0cebb053b03c97a8df0949a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18901a51d68a3829e0cebb053b03c97a8df0949a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24384340548e9af2ce85f9dd91858cac30166fee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24384340548e9af2ce85f9dd91858cac30166fee", "html_url": "https://github.com/rust-lang/rust/commit/24384340548e9af2ce85f9dd91858cac30166fee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24384340548e9af2ce85f9dd91858cac30166fee/comments", "author": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b559710e58427213d6f82008206c22cf3d76b4c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b559710e58427213d6f82008206c22cf3d76b4c4", "html_url": "https://github.com/rust-lang/rust/commit/b559710e58427213d6f82008206c22cf3d76b4c4"}], "stats": {"total": 479, "additions": 247, "deletions": 232}, "files": [{"sha": "508cbbc7634a28d3cff9a8114bf21dab0259c77b", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=24384340548e9af2ce85f9dd91858cac30166fee", "patch": "@@ -10,8 +10,8 @@\n pub use self::Mode::*;\n \n use std::fmt;\n-use std::str::FromStr;\n use std::path::PathBuf;\n+use std::str::FromStr;\n \n use test::ColorConfig;\n \n@@ -103,7 +103,7 @@ pub enum CompareMode {\n impl CompareMode {\n     pub(crate) fn to_str(&self) -> &'static str {\n         match *self {\n-            CompareMode::Nll => \"nll\"\n+            CompareMode::Nll => \"nll\",\n         }\n     }\n \n@@ -253,16 +253,21 @@ pub struct TestPaths {\n }\n \n /// Used by `ui` tests to generate things like `foo.stderr` from `foo.rs`.\n-pub fn expected_output_path(testpaths: &TestPaths,\n-                            revision: Option<&str>,\n-                            compare_mode: &Option<CompareMode>,\n-                            kind: &str) -> PathBuf {\n-\n+pub fn expected_output_path(\n+    testpaths: &TestPaths,\n+    revision: Option<&str>,\n+    compare_mode: &Option<CompareMode>,\n+    kind: &str,\n+) -> PathBuf {\n     assert!(UI_EXTENSIONS.contains(&kind));\n     let mut parts = Vec::new();\n \n-    if let Some(x) = revision { parts.push(x); }\n-    if let Some(ref x) = *compare_mode { parts.push(x.to_str()); }\n+    if let Some(x) = revision {\n+        parts.push(x);\n+    }\n+    if let Some(ref x) = *compare_mode {\n+        parts.push(x.to_str());\n+    }\n     parts.push(kind);\n \n     let extension = parts.join(\".\");"}, {"sha": "dd2e5557c16d48190f8839b2ee87c0311460fc63", "filename": "src/tools/compiletest/src/errors.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs?ref=24384340548e9af2ce85f9dd91858cac30166fee", "patch": "@@ -11,8 +11,8 @@ use self::WhichLine::*;\n \n use std::fmt;\n use std::fs::File;\n-use std::io::BufReader;\n use std::io::prelude::*;\n+use std::io::BufReader;\n use std::path::Path;\n use std::str::FromStr;\n \n@@ -35,8 +35,7 @@ impl FromStr for ErrorKind {\n             \"ERROR\" => Ok(ErrorKind::Error),\n             \"NOTE\" => Ok(ErrorKind::Note),\n             \"SUGGESTION\" => Ok(ErrorKind::Suggestion),\n-            \"WARN\" |\n-            \"WARNING\" => Ok(ErrorKind::Warning),\n+            \"WARN\" | \"WARNING\" => Ok(ErrorKind::Warning),\n             _ => Err(()),\n         }\n     }\n@@ -101,61 +100,74 @@ pub fn load_errors(testfile: &Path, cfg: Option<&str>) -> Vec<Error> {\n     rdr.lines()\n         .enumerate()\n         .filter_map(|(line_num, line)| {\n-            parse_expected(last_nonfollow_error, line_num + 1, &line.unwrap(), &tag)\n-                .map(|(which, error)| {\n+            parse_expected(last_nonfollow_error, line_num + 1, &line.unwrap(), &tag).map(\n+                |(which, error)| {\n                     match which {\n                         FollowPrevious(_) => {}\n                         _ => last_nonfollow_error = Some(error.line_num),\n                     }\n                     error\n-                })\n+                },\n+            )\n         })\n         .collect()\n }\n \n-fn parse_expected(last_nonfollow_error: Option<usize>,\n-                  line_num: usize,\n-                  line: &str,\n-                  tag: &str)\n-                  -> Option<(WhichLine, Error)> {\n+fn parse_expected(\n+    last_nonfollow_error: Option<usize>,\n+    line_num: usize,\n+    line: &str,\n+    tag: &str,\n+) -> Option<(WhichLine, Error)> {\n     let start = match line.find(tag) {\n         Some(i) => i,\n         None => return None,\n     };\n     let (follow, adjusts) = if line[start + tag.len()..].chars().next().unwrap() == '|' {\n         (true, 0)\n     } else {\n-        (false, line[start + tag.len()..].chars().take_while(|c| *c == '^').count())\n+        (\n+            false,\n+            line[start + tag.len()..]\n+                .chars()\n+                .take_while(|c| *c == '^')\n+                .count(),\n+        )\n     };\n     let kind_start = start + tag.len() + adjusts + (follow as usize);\n     let (kind, msg);\n     match line[kind_start..]\n         .split_whitespace()\n         .next()\n         .expect(\"Encountered unexpected empty comment\")\n-        .parse::<ErrorKind>() {\n+        .parse::<ErrorKind>()\n+    {\n         Ok(k) => {\n             // If we find `//~ ERROR foo` or something like that:\n             kind = Some(k);\n             let letters = line[kind_start..].chars();\n-            msg = letters.skip_while(|c| c.is_whitespace())\n+            msg = letters\n+                .skip_while(|c| c.is_whitespace())\n                 .skip_while(|c| !c.is_whitespace())\n                 .collect::<String>();\n         }\n         Err(_) => {\n             // Otherwise we found `//~ foo`:\n             kind = None;\n             let letters = line[kind_start..].chars();\n-            msg = letters.skip_while(|c| c.is_whitespace())\n+            msg = letters\n+                .skip_while(|c| c.is_whitespace())\n                 .collect::<String>();\n         }\n     }\n     let msg = msg.trim().to_owned();\n \n     let (which, line_num) = if follow {\n         assert_eq!(adjusts, 0, \"use either //~| or //~^, not both.\");\n-        let line_num = last_nonfollow_error.expect(\"encountered //~| without \\\n-                                                    preceding //~^ line.\");\n+        let line_num = last_nonfollow_error.expect(\n+            \"encountered //~| without \\\n+             preceding //~^ line.\",\n+        );\n         (FollowPrevious(line_num), line_num)\n     } else {\n         let which = if adjusts > 0 {\n@@ -167,16 +179,16 @@ fn parse_expected(last_nonfollow_error: Option<usize>,\n         (which, line_num)\n     };\n \n-    debug!(\"line={} tag={:?} which={:?} kind={:?} msg={:?}\",\n-           line_num,\n-           tag,\n-           which,\n-           kind,\n-           msg);\n-    Some((which,\n-          Error {\n-        line_num,\n-        kind,\n-        msg,\n-    }))\n+    debug!(\n+        \"line={} tag={:?} which={:?} kind={:?} msg={:?}\",\n+        line_num, tag, which, kind, msg\n+    );\n+    Some((\n+        which,\n+        Error {\n+            line_num,\n+            kind,\n+            msg,\n+        },\n+    ))\n }"}, {"sha": "06ec9e893f0685b7147911834f02010317323998", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 29, "deletions": 42, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=24384340548e9af2ce85f9dd91858cac30166fee", "patch": "@@ -10,12 +10,12 @@\n \n use std::env;\n use std::fs::File;\n-use std::io::BufReader;\n use std::io::prelude::*;\n+use std::io::BufReader;\n use std::path::{Path, PathBuf};\n \n-use common::Config;\n use common;\n+use common::Config;\n use util;\n \n use extract_gdb_version;\n@@ -38,19 +38,14 @@ impl EarlyProps {\n             revisions: vec![],\n         };\n \n-        iter_header(testfile,\n-                    None,\n-                    &mut |ln| {\n+        iter_header(testfile, None, &mut |ln| {\n             // we should check if any only-<platform> exists and if it exists\n             // and does not matches the current platform, skip the test\n-            props.ignore =\n-                props.ignore ||\n-                config.parse_cfg_name_directive(ln, \"ignore\") ||\n-                (config.has_cfg_prefix(ln, \"only\") &&\n-                !config.parse_cfg_name_directive(ln, \"only\")) ||\n-                ignore_gdb(config, ln) ||\n-                ignore_lldb(config, ln) ||\n-                ignore_llvm(config, ln);\n+            props.ignore = props.ignore || config.parse_cfg_name_directive(ln, \"ignore\")\n+                || (config.has_cfg_prefix(ln, \"only\")\n+                    && !config.parse_cfg_name_directive(ln, \"only\"))\n+                || ignore_gdb(config, ln) || ignore_lldb(config, ln)\n+                || ignore_llvm(config, ln);\n \n             if let Some(s) = config.parse_aux_build(ln) {\n                 props.aux.push(s);\n@@ -149,7 +144,7 @@ impl EarlyProps {\n \n         fn ignore_llvm(config: &Config, line: &str) -> bool {\n             if config.system_llvm && line.starts_with(\"no-system-llvm\") {\n-                    return true;\n+                return true;\n             }\n             if let Some(ref actual_version) = config.llvm_version {\n                 if line.starts_with(\"min-llvm-version\") {\n@@ -272,11 +267,7 @@ impl TestProps {\n         }\n     }\n \n-    pub fn from_aux_file(&self,\n-                         testfile: &Path,\n-                         cfg: Option<&str>,\n-                         config: &Config)\n-                         -> Self {\n+    pub fn from_aux_file(&self, testfile: &Path, cfg: Option<&str>, config: &Config) -> Self {\n         let mut props = TestProps::new();\n \n         // copy over select properties to the aux build:\n@@ -296,20 +287,15 @@ impl TestProps {\n     /// tied to a particular revision `foo` (indicated by writing\n     /// `//[foo]`), then the property is ignored unless `cfg` is\n     /// `Some(\"foo\")`.\n-    fn load_from(&mut self,\n-                 testfile: &Path,\n-                 cfg: Option<&str>,\n-                 config: &Config) {\n-        iter_header(testfile,\n-                    cfg,\n-                    &mut |ln| {\n+    fn load_from(&mut self, testfile: &Path, cfg: Option<&str>, config: &Config) {\n+        iter_header(testfile, cfg, &mut |ln| {\n             if let Some(ep) = config.parse_error_pattern(ln) {\n                 self.error_patterns.push(ep);\n             }\n \n             if let Some(flags) = config.parse_compile_flags(ln) {\n-                self.compile_flags.extend(flags.split_whitespace()\n-                    .map(|s| s.to_owned()));\n+                self.compile_flags\n+                    .extend(flags.split_whitespace().map(|s| s.to_owned()));\n             }\n \n             if let Some(r) = config.parse_revisions(ln) {\n@@ -382,8 +368,7 @@ impl TestProps {\n \n             if !self.compile_pass {\n                 // run-pass implies must_compile_sucessfully\n-                self.compile_pass =\n-                    config.parse_compile_pass(ln) || self.run_pass;\n+                self.compile_pass = config.parse_compile_pass(ln) || self.run_pass;\n             }\n \n                         if !self.skip_trans {\n@@ -453,7 +438,7 @@ fn iter_header(testfile: &Path, cfg: Option<&str>, it: &mut FnMut(&str)) {\n                     None => false,\n                 };\n                 if matches {\n-                    it(ln[(close_brace + 1) ..].trim_left());\n+                    it(ln[(close_brace + 1)..].trim_left());\n                 }\n             } else {\n                 panic!(\"malformed condition directive: expected `{}foo]`, found `{}`\",\n@@ -554,9 +539,7 @@ impl Config {\n     fn parse_env(&self, line: &str, name: &str) -> Option<(String, String)> {\n         self.parse_name_value_directive(line, name).map(|nv| {\n             // nv is either FOO or FOO=BAR\n-            let mut strs: Vec<String> = nv.splitn(2, '=')\n-                .map(str::to_owned)\n-                .collect();\n+            let mut strs: Vec<String> = nv.splitn(2, '=').map(str::to_owned).collect();\n \n             match strs.len() {\n                 1 => (strs.pop().unwrap(), \"\".to_owned()),\n@@ -599,7 +582,10 @@ impl Config {\n     /// or `normalize-stderr-32bit`. Returns `true` if the line matches it.\n     fn parse_cfg_name_directive(&self, line: &str, prefix: &str) -> bool {\n         if line.starts_with(prefix) && line.as_bytes().get(prefix.len()) == Some(&b'-') {\n-            let name = line[prefix.len()+1 ..].split(&[':', ' '][..]).next().unwrap();\n+            let name = line[prefix.len() + 1..]\n+                .split(&[':', ' '][..])\n+                .next()\n+                .unwrap();\n \n             name == \"test\" ||\n                 util::matches_os(&self.target, name) ||             // target\n@@ -612,8 +598,7 @@ impl Config {\n                     common::DebugInfoLldb => name == \"lldb\",\n                     common::Pretty => name == \"pretty\",\n                     _ => false,\n-                } ||\n-                (self.target != self.host && name == \"cross-compile\")\n+                } || (self.target != self.host && name == \"cross-compile\")\n         } else {\n             false\n         }\n@@ -631,14 +616,14 @@ impl Config {\n         // the line says \"ignore-x86_64\".\n         line.starts_with(directive) && match line.as_bytes().get(directive.len()) {\n             None | Some(&b' ') | Some(&b':') => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n     pub fn parse_name_value_directive(&self, line: &str, directive: &str) -> Option<String> {\n         let colon = directive.len();\n         if line.starts_with(directive) && line.as_bytes().get(colon) == Some(&b':') {\n-            let value = line[(colon + 1) ..].to_owned();\n+            let value = line[(colon + 1)..].to_owned();\n             debug!(\"{}: {}\", directive, value);\n             Some(expand_variables(value, self))\n         } else {\n@@ -665,8 +650,10 @@ impl Config {\n }\n \n pub fn lldb_version_to_int(version_string: &str) -> isize {\n-    let error_string = format!(\"Encountered LLDB version string with unexpected format: {}\",\n-                               version_string);\n+    let error_string = format!(\n+        \"Encountered LLDB version string with unexpected format: {}\",\n+        version_string\n+    );\n     version_string.parse().expect(&error_string)\n }\n \n@@ -713,6 +700,6 @@ fn parse_normalization_string(line: &mut &str) -> Option<String> {\n         None => return None,\n     };\n     let result = line[begin..end].to_owned();\n-    *line = &line[end+1..];\n+    *line = &line[end + 1..];\n     Some(result)\n }"}, {"sha": "165f2914ae246d7eba8bf24b964b24d5f7fed0b9", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=24384340548e9af2ce85f9dd91858cac30166fee", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n use errors::{Error, ErrorKind};\n+use runtest::ProcRes;\n use serde_json;\n-use std::str::FromStr;\n use std::path::Path;\n-use runtest::ProcRes;\n+use std::str::FromStr;\n \n // These structs are a subset of the ones found in\n // `syntax::json`.\n@@ -58,26 +58,30 @@ struct DiagnosticCode {\n }\n \n pub fn extract_rendered(output: &str, proc_res: &ProcRes) -> String {\n-    output.lines()\n-        .filter_map(|line| if line.starts_with('{') {\n-            match serde_json::from_str::<Diagnostic>(line) {\n-                Ok(diagnostic) => diagnostic.rendered,\n-                Err(error) => {\n-                    proc_res.fatal(Some(&format!(\"failed to decode compiler output as json: \\\n-                                                  `{}`\\noutput: {}\\nline: {}\",\n-                                                 error,\n-                                                 line,\n-                                                 output)));\n+    output\n+        .lines()\n+        .filter_map(|line| {\n+            if line.starts_with('{') {\n+                match serde_json::from_str::<Diagnostic>(line) {\n+                    Ok(diagnostic) => diagnostic.rendered,\n+                    Err(error) => {\n+                        proc_res.fatal(Some(&format!(\n+                            \"failed to decode compiler output as json: \\\n+                             `{}`\\noutput: {}\\nline: {}\",\n+                            error, line, output\n+                        )));\n+                    }\n                 }\n+            } else {\n+                None\n             }\n-        } else {\n-            None\n         })\n         .collect()\n }\n \n pub fn parse_output(file_name: &str, output: &str, proc_res: &ProcRes) -> Vec<Error> {\n-    output.lines()\n+    output\n+        .lines()\n         .flat_map(|line| parse_line(file_name, line, output, proc_res))\n         .collect()\n }\n@@ -93,23 +97,26 @@ fn parse_line(file_name: &str, line: &str, output: &str, proc_res: &ProcRes) ->\n                 expected_errors\n             }\n             Err(error) => {\n-                proc_res.fatal(Some(&format!(\"failed to decode compiler output as json: \\\n-                                              `{}`\\noutput: {}\\nline: {}\",\n-                                             error,\n-                                             line,\n-                                             output)));\n+                proc_res.fatal(Some(&format!(\n+                    \"failed to decode compiler output as json: \\\n+                     `{}`\\noutput: {}\\nline: {}\",\n+                    error, line, output\n+                )));\n             }\n         }\n     } else {\n         vec![]\n     }\n }\n \n-fn push_expected_errors(expected_errors: &mut Vec<Error>,\n-                        diagnostic: &Diagnostic,\n-                        default_spans: &[&DiagnosticSpan],\n-                        file_name: &str) {\n-    let spans_in_this_file: Vec<_> = diagnostic.spans\n+fn push_expected_errors(\n+    expected_errors: &mut Vec<Error>,\n+    diagnostic: &Diagnostic,\n+    default_spans: &[&DiagnosticSpan],\n+    file_name: &str,\n+) {\n+    let spans_in_this_file: Vec<_> = diagnostic\n+        .spans\n         .iter()\n         .filter(|span| Path::new(&span.file_name) == Path::new(&file_name))\n         .collect();\n@@ -204,8 +211,10 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n     }\n \n     // Add notes for any labels that appear in the message.\n-    for span in spans_in_this_file.iter()\n-        .filter(|span| span.label.is_some()) {\n+    for span in spans_in_this_file\n+        .iter()\n+        .filter(|span| span.label.is_some())\n+    {\n         expected_errors.push(Error {\n             line_num: span.line_start,\n             kind: Some(ErrorKind::Note),\n@@ -219,9 +228,11 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n     }\n }\n \n-fn push_backtrace(expected_errors: &mut Vec<Error>,\n-                  expansion: &DiagnosticSpanMacroExpansion,\n-                  file_name: &str) {\n+fn push_backtrace(\n+    expected_errors: &mut Vec<Error>,\n+    expansion: &DiagnosticSpanMacroExpansion,\n+    file_name: &str,\n+) {\n     if Path::new(&expansion.span.file_name) == Path::new(&file_name) {\n         expected_errors.push(Error {\n             line_num: expansion.span.line_start,"}, {"sha": "0fd7567d4f21d04bbf3cedd9a465ae3d84da8bf8", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=24384340548e9af2ce85f9dd91858cac30166fee", "patch": "@@ -31,31 +31,31 @@ extern crate serde_json;\n extern crate test;\n extern crate rustfix;\n \n+use common::CompareMode;\n+use common::{expected_output_path, UI_EXTENSIONS};\n+use common::{Config, TestPaths};\n+use common::{DebugInfoGdb, DebugInfoLldb, Mode, Pretty};\n+use filetime::FileTime;\n+use getopts::Options;\n use std::env;\n use std::ffi::OsString;\n use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n-use filetime::FileTime;\n-use getopts::Options;\n-use common::{Config, TestPaths};\n-use common::{DebugInfoGdb, DebugInfoLldb, Mode, Pretty};\n-use common::{expected_output_path, UI_EXTENSIONS};\n-use common::CompareMode;\n use test::ColorConfig;\n use util::logv;\n \n use self::header::EarlyProps;\n \n-pub mod util;\n-mod json;\n-pub mod header;\n-pub mod runtest;\n pub mod common;\n pub mod errors;\n+pub mod header;\n+mod json;\n mod raise_fd_limit;\n mod read2;\n+pub mod runtest;\n+pub mod util;\n \n fn main() {\n     env_logger::init();\n@@ -236,7 +236,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n             \"\",\n             \"compare-mode\",\n             \"mode describing what file the actual ui output will be compared to\",\n-            \"COMPARE MODE\"\n+            \"COMPARE MODE\",\n         )\n         .optflag(\"h\", \"help\", \"show this message\");\n \n@@ -501,7 +501,11 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         filter: config.filter.clone(),\n         filter_exact: config.filter_exact,\n         run_ignored: config.run_ignored,\n-        format: if config.quiet { test::OutputFormat::Terse } else { test::OutputFormat::Pretty },\n+        format: if config.quiet {\n+            test::OutputFormat::Terse\n+        } else {\n+            test::OutputFormat::Pretty\n+        },\n         logfile: config.logfile.clone(),\n         run_tests: true,\n         bench_benchmarks: true,\n@@ -634,8 +638,7 @@ pub fn make_test(config: &Config, testpaths: &TestPaths) -> test::TestDescAndFn\n     };\n \n     // Debugging emscripten code doesn't make sense today\n-    let ignore = early_props.ignore\n-        || !up_to_date(config, testpaths, &early_props)\n+    let ignore = early_props.ignore || !up_to_date(config, testpaths, &early_props)\n         || (config.mode == DebugInfoGdb || config.mode == DebugInfoLldb)\n             && config.target.contains(\"emscripten\");\n \n@@ -694,8 +697,7 @@ fn up_to_date(config: &Config, testpaths: &TestPaths, props: &EarlyProps) -> boo\n     for pretty_printer_file in &pretty_printer_files {\n         inputs.push(mtime(&rust_src_dir.join(pretty_printer_file)));\n     }\n-    let mut entries = config.run_lib_path.read_dir().unwrap()\n-        .collect::<Vec<_>>();\n+    let mut entries = config.run_lib_path.read_dir().unwrap().collect::<Vec<_>>();\n     while let Some(entry) = entries.pop() {\n         let entry = entry.unwrap();\n         let path = entry.path();\n@@ -713,10 +715,8 @@ fn up_to_date(config: &Config, testpaths: &TestPaths, props: &EarlyProps) -> boo\n     // UI test files.\n     for extension in UI_EXTENSIONS {\n         for revision in &props.revisions {\n-            let path = &expected_output_path(testpaths,\n-                                             Some(revision),\n-                                             &config.compare_mode,\n-                                             extension);\n+            let path =\n+                &expected_output_path(testpaths, Some(revision), &config.compare_mode, extension);\n             inputs.push(mtime(path));\n         }\n \n@@ -746,7 +746,12 @@ pub fn make_test_name(config: &Config, testpaths: &TestPaths) -> test::TestName\n         Some(ref mode) => format!(\" ({})\", mode.to_str()),\n         None => format!(\"\"),\n     };\n-    test::DynTestName(format!(\"[{}{}] {}\", config.mode, mode_suffix, path.display()))\n+    test::DynTestName(format!(\n+        \"[{}{}] {}\",\n+        config.mode,\n+        mode_suffix,\n+        path.display()\n+    ))\n }\n \n pub fn make_test_closure(config: &Config, testpaths: &TestPaths) -> test::TestFn {"}, {"sha": "220082799a8b081430a128853a63d10482ebb520", "filename": "src/tools/compiletest/src/raise_fd_limit.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs?ref=24384340548e9af2ce85f9dd91858cac30166fee", "patch": "@@ -34,12 +34,15 @@ pub unsafe fn raise_fd_limit() {\n     let mut mib: [libc::c_int; 2] = [CTL_KERN, KERN_MAXFILESPERPROC];\n     let mut maxfiles: libc::c_int = 0;\n     let mut size: libc::size_t = size_of_val(&maxfiles) as libc::size_t;\n-    if libc::sysctl(&mut mib[0],\n-                    2,\n-                    &mut maxfiles as *mut _ as *mut _,\n-                    &mut size,\n-                    null_mut(),\n-                    0) != 0 {\n+    if libc::sysctl(\n+        &mut mib[0],\n+        2,\n+        &mut maxfiles as *mut _ as *mut _,\n+        &mut size,\n+        null_mut(),\n+        0,\n+    ) != 0\n+    {\n         let err = io::Error::last_os_error();\n         panic!(\"raise_fd_limit: error calling sysctl: {}\", err);\n     }"}, {"sha": "5bf898f5f1bafc3a637a59fb734e76ff123422a6", "filename": "src/tools/compiletest/src/read2.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs?ref=24384340548e9af2ce85f9dd91858cac30166fee", "patch": "@@ -16,11 +16,13 @@ pub use self::imp::read2;\n #[cfg(not(any(unix, windows)))]\n mod imp {\n     use std::io::{self, Read};\n-    use std::process::{ChildStdout, ChildStderr};\n+    use std::process::{ChildStderr, ChildStdout};\n \n-    pub fn read2(out_pipe: ChildStdout,\n-                 err_pipe: ChildStderr,\n-                 data: &mut FnMut(bool, &mut Vec<u8>, bool)) -> io::Result<()> {\n+    pub fn read2(\n+        out_pipe: ChildStdout,\n+        err_pipe: ChildStderr,\n+        data: &mut FnMut(bool, &mut Vec<u8>, bool),\n+    ) -> io::Result<()> {\n         let mut buffer = Vec::new();\n         out_pipe.read_to_end(&mut buffer)?;\n         data(true, &mut buffer, true);\n@@ -33,16 +35,18 @@ mod imp {\n \n #[cfg(unix)]\n mod imp {\n-    use std::io::prelude::*;\n+    use libc;\n     use std::io;\n+    use std::io::prelude::*;\n     use std::mem;\n     use std::os::unix::prelude::*;\n-    use std::process::{ChildStdout, ChildStderr};\n-    use libc;\n+    use std::process::{ChildStderr, ChildStdout};\n \n-    pub fn read2(mut out_pipe: ChildStdout,\n-                 mut err_pipe: ChildStderr,\n-                 data: &mut FnMut(bool, &mut Vec<u8>, bool)) -> io::Result<()> {\n+    pub fn read2(\n+        mut out_pipe: ChildStdout,\n+        mut err_pipe: ChildStderr,\n+        data: &mut FnMut(bool, &mut Vec<u8>, bool),\n+    ) -> io::Result<()> {\n         unsafe {\n             libc::fcntl(out_pipe.as_raw_fd(), libc::F_SETFL, libc::O_NONBLOCK);\n             libc::fcntl(err_pipe.as_raw_fd(), libc::F_SETFL, libc::O_NONBLOCK);\n@@ -67,25 +71,23 @@ mod imp {\n             if r == -1 {\n                 let err = io::Error::last_os_error();\n                 if err.kind() == io::ErrorKind::Interrupted {\n-                    continue\n+                    continue;\n                 }\n-                return Err(err)\n+                return Err(err);\n             }\n \n             // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n             // EAGAIN. If we hit EOF, then this will happen because the underlying\n             // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n             // this case we flip the other fd back into blocking mode and read\n             // whatever's leftover on that file descriptor.\n-            let handle = |res: io::Result<_>| {\n-                match res {\n-                    Ok(_) => Ok(true),\n-                    Err(e) => {\n-                        if e.kind() == io::ErrorKind::WouldBlock {\n-                            Ok(false)\n-                        } else {\n-                            Err(e)\n-                        }\n+            let handle = |res: io::Result<_>| match res {\n+                Ok(_) => Ok(true),\n+                Err(e) => {\n+                    if e.kind() == io::ErrorKind::WouldBlock {\n+                        Ok(false)\n+                    } else {\n+                        Err(e)\n                     }\n                 }\n             };\n@@ -113,7 +115,7 @@ mod imp {\n \n     use std::io;\n     use std::os::windows::prelude::*;\n-    use std::process::{ChildStdout, ChildStderr};\n+    use std::process::{ChildStderr, ChildStdout};\n     use std::slice;\n \n     use self::miow::iocp::{CompletionPort, CompletionStatus};\n@@ -128,9 +130,11 @@ mod imp {\n         done: bool,\n     }\n \n-    pub fn read2(out_pipe: ChildStdout,\n-                 err_pipe: ChildStderr,\n-                 data: &mut FnMut(bool, &mut Vec<u8>, bool)) -> io::Result<()> {\n+    pub fn read2(\n+        out_pipe: ChildStdout,\n+        err_pipe: ChildStderr,\n+        data: &mut FnMut(bool, &mut Vec<u8>, bool),\n+    ) -> io::Result<()> {\n         let mut out = Vec::new();\n         let mut err = Vec::new();\n \n@@ -206,7 +210,9 @@ mod imp {\n         if v.capacity() == v.len() {\n             v.reserve(1);\n         }\n-        slice::from_raw_parts_mut(v.as_mut_ptr().offset(v.len() as isize),\n-                                  v.capacity() - v.len())\n+        slice::from_raw_parts_mut(\n+            v.as_mut_ptr().offset(v.len() as isize),\n+            v.capacity() - v.len(),\n+        )\n     }\n }"}, {"sha": "a3ce4d490713c809e16fa490311b364e7a86cc0e", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 52, "deletions": 66, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=24384340548e9af2ce85f9dd91858cac30166fee", "patch": "@@ -8,28 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use common::{Config, TestPaths};\n-use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind};\n+use common::CompareMode;\n+use common::{expected_output_path, UI_STDERR, UI_STDOUT, UI_FIXED};\n use common::{Codegen, CodegenUnits, DebugInfoGdb, DebugInfoLldb, Rustdoc};\n+use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind};\n+use common::{Config, TestPaths};\n use common::{Incremental, MirOpt, RunMake, Ui};\n-use common::{expected_output_path, UI_STDERR, UI_STDOUT, UI_FIXED};\n-use common::CompareMode;\n use diff;\n use errors::{self, Error, ErrorKind};\n use filetime::FileTime;\n-use json;\n use header::TestProps;\n-use util::logv;\n+use json;\n use regex::Regex;\n use rustfix::{apply_suggestions, get_suggestions_from_json};\n+use util::logv;\n \n-use std::collections::VecDeque;\n use std::collections::HashMap;\n use std::collections::HashSet;\n+use std::collections::VecDeque;\n use std::env;\n use std::ffi::{OsStr, OsString};\n-use std::fs::{self, create_dir_all, File};\n use std::fmt;\n+use std::fs::{self, create_dir_all, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n@@ -355,9 +355,10 @@ impl<'test> TestCx<'test> {\n \n         if expected_status != received_status {\n             self.fatal_proc_rec(\n-                &format!(\"Error: expected failure status ({:?}) but received status {:?}.\",\n-                         expected_status,\n-                         received_status),\n+                &format!(\n+                    \"Error: expected failure status ({:?}) but received status {:?}.\",\n+                    expected_status, received_status\n+                ),\n                 proc_res,\n             );\n         }\n@@ -440,8 +441,7 @@ impl<'test> TestCx<'test> {\n                 self.config,\n                 format!(\n                     \"pretty-printing round {} revision {:?}\",\n-                    round,\n-                    self.revision\n+                    round, self.revision\n                 ),\n             );\n             let proc_res = self.print_source(srcs[round].to_owned(), &self.props.pretty_mode);\n@@ -450,8 +450,7 @@ impl<'test> TestCx<'test> {\n                 self.fatal_proc_rec(\n                     &format!(\n                         \"pretty-printing failed in round {} revision {:?}\",\n-                        round,\n-                        self.revision\n+                        round, self.revision\n                     ),\n                     &proc_res,\n                 );\n@@ -555,8 +554,7 @@ impl<'test> TestCx<'test> {\n                  {}\\n\\\n                  ------------------------------------------\\n\\\n                  \\n\",\n-                expected,\n-                actual\n+                expected, actual\n             );\n         }\n     }\n@@ -661,8 +659,7 @@ impl<'test> TestCx<'test> {\n                 script_str.push_str(&format!(\n                     \"set solib-search-path \\\n                      ./{}/stage2/lib/rustlib/{}/lib/\\n\",\n-                    self.config.host,\n-                    self.config.target\n+                    self.config.host, self.config.target\n                 ));\n                 for line in &breakpoint_lines {\n                     script_str.push_str(\n@@ -881,7 +878,6 @@ impl<'test> TestCx<'test> {\n             ..self.config.clone()\n         };\n \n-\n         let test_cx = TestCx {\n             config: &config,\n             ..*self\n@@ -952,8 +948,7 @@ impl<'test> TestCx<'test> {\n         for line in &breakpoint_lines {\n             script_str.push_str(&format!(\n                 \"breakpoint set --file '{}' --line {}\\n\",\n-                source_file_name,\n-                line\n+                source_file_name, line\n             ));\n         }\n \n@@ -1028,9 +1023,7 @@ impl<'test> TestCx<'test> {\n     fn parse_debugger_commands(&self, debugger_prefixes: &[&str]) -> DebuggerCommands {\n         let directives = debugger_prefixes\n             .iter()\n-            .map(|prefix| {\n-                (format!(\"{}-command\", prefix), format!(\"{}-check\", prefix))\n-            })\n+            .map(|prefix| (format!(\"{}-command\", prefix), format!(\"{}-check\", prefix)))\n             .collect::<Vec<_>>();\n \n         let mut breakpoint_lines = vec![];\n@@ -1041,12 +1034,11 @@ impl<'test> TestCx<'test> {\n         for line in reader.lines() {\n             match line {\n                 Ok(line) => {\n-                    let line =\n-                        if line.starts_with(\"//\") {\n-                            line[2..].trim_left()\n-                        } else {\n-                            line.as_str()\n-                        };\n+                    let line = if line.starts_with(\"//\") {\n+                        line[2..].trim_left()\n+                    } else {\n+                        line.as_str()\n+                    };\n \n                     if line.contains(\"#break\") {\n                         breakpoint_lines.push(counter);\n@@ -1645,7 +1637,10 @@ impl<'test> TestCx<'test> {\n         let mut rustc = if !is_rustdoc {\n             Command::new(&self.config.rustc_path)\n         } else {\n-            Command::new(&self.config.rustdoc_path.clone().expect(\"no rustdoc built yet\"))\n+            Command::new(&self.config\n+                .rustdoc_path\n+                .clone()\n+                .expect(\"no rustdoc built yet\"))\n         };\n         rustc.arg(input_file).arg(\"-L\").arg(&self.config.build_base);\n \n@@ -1671,10 +1666,7 @@ impl<'test> TestCx<'test> {\n \n         if !is_rustdoc {\n             if let Some(ref incremental_dir) = self.props.incremental_dir {\n-                rustc.args(&[\n-                    \"-C\",\n-                    &format!(\"incremental={}\", incremental_dir.display()),\n-                ]);\n+                rustc.args(&[\"-C\", &format!(\"incremental={}\", incremental_dir.display())]);\n                 rustc.args(&[\"-Z\", \"incremental-verify-ich\"]);\n                 rustc.args(&[\"-Z\", \"incremental-queries\"]);\n             }\n@@ -1697,7 +1689,11 @@ impl<'test> TestCx<'test> {\n                 }\n             }\n             Ui => {\n-                if !self.props.compile_flags.iter().any(|s| s.starts_with(\"--error-format\")) {\n+                if !self.props\n+                    .compile_flags\n+                    .iter()\n+                    .any(|s| s.starts_with(\"--error-format\"))\n+                {\n                     rustc.args(&[\"--error-format\", \"json\"]);\n                 }\n                 if !self.props.disable_ui_testing_normalization {\n@@ -1720,16 +1716,8 @@ impl<'test> TestCx<'test> {\n \n                 rustc.arg(dir_opt);\n             }\n-            RunPass |\n-            RunFail |\n-            RunPassValgrind |\n-            Pretty |\n-            DebugInfoGdb |\n-            DebugInfoLldb |\n-            Codegen |\n-            Rustdoc |\n-            RunMake |\n-            CodegenUnits => {\n+            RunPass | RunFail | RunPassValgrind | Pretty | DebugInfoGdb | DebugInfoLldb\n+            | Codegen | Rustdoc | RunMake | CodegenUnits => {\n                 // do not use JSON output\n             }\n         }\n@@ -1759,8 +1747,8 @@ impl<'test> TestCx<'test> {\n         match self.config.compare_mode {\n             Some(CompareMode::Nll) => {\n                 rustc.args(&[\"-Zborrowck=mir\", \"-Ztwo-phase-borrows\"]);\n-            },\n-            None => {},\n+            }\n+            None => {}\n         }\n \n         if self.props.force_host {\n@@ -1923,7 +1911,8 @@ impl<'test> TestCx<'test> {\n     /// Same as `output_base_name`, but includes the stage ID as an extension,\n     /// such as: `.../compile-fail/foo/bar.stage1-<triple>`\n     fn output_base_name_stage(&self) -> PathBuf {\n-        self.output_base_name().with_extension(&self.config.stage_id)\n+        self.output_base_name()\n+            .with_extension(&self.config.stage_id)\n     }\n \n     fn maybe_dump_to_stdout(&self, out: &str, err: &str) {\n@@ -2417,8 +2406,7 @@ impl<'test> TestCx<'test> {\n         if self.config.verbose {\n             print!(\n                 \"revision={:?} revision_props={:#?}\",\n-                revision,\n-                revision_props\n+                revision, revision_props\n             );\n         }\n \n@@ -2731,8 +2719,7 @@ impl<'test> TestCx<'test> {\n         if source_time > output_time {\n             debug!(\n                 \"source file time: {:?} output file time: {:?}\",\n-                source_time,\n-                output_time\n+                source_time, output_time\n             );\n             panic!(\n                 \"test source file `{}` is newer than potentially stale output file `{}`.\",\n@@ -2906,10 +2893,12 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn expected_output_path(&self, kind: &str) -> PathBuf {\n-        let mut path = expected_output_path(&self.testpaths,\n-                                            self.revision,\n-                                            &self.config.compare_mode,\n-                                            kind);\n+        let mut path = expected_output_path(\n+            &self.testpaths,\n+            self.revision,\n+            &self.config.compare_mode,\n+            kind,\n+        );\n         if !path.exists() && self.config.compare_mode.is_some() {\n             // fallback!\n             path = expected_output_path(&self.testpaths, self.revision, &None, kind);\n@@ -2959,14 +2948,14 @@ impl<'test> TestCx<'test> {\n                         DiffLine::Expected(e) => {\n                             println!(\"-\\t{}\", e);\n                             line_number += 1;\n-                        },\n+                        }\n                         DiffLine::Context(c) => {\n                             println!(\"{}\\t{}\", line_number, c);\n                             line_number += 1;\n-                        },\n+                        }\n                         DiffLine::Resulting(r) => {\n                             println!(\"+\\t{}\", r);\n-                        },\n+                        }\n                     }\n                 }\n                 println!(\"\");\n@@ -3025,10 +3014,7 @@ impl ProcRes {\n              {}\\n\\\n              ------------------------------------------\\n\\\n              \\n\",\n-            self.status,\n-            self.cmdline,\n-            self.stdout,\n-            self.stderr\n+            self.status, self.cmdline, self.stdout, self.stderr\n         );\n         panic!();\n     }\n@@ -3072,8 +3058,8 @@ fn nocomment_mir_line(line: &str) -> &str {\n }\n \n fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n-    use std::mem::replace;\n     use read2::read2;\n+    use std::mem::replace;\n \n     const HEAD_LEN: usize = 160 * 1024;\n     const TAIL_LEN: usize = 256 * 1024;"}, {"sha": "77b991ae3c3fd3cb60721180e69f9c27e1d09e16", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24384340548e9af2ce85f9dd91858cac30166fee/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=24384340548e9af2ce85f9dd91858cac30166fee", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::env;\n use common::Config;\n+use std::env;\n \n /// Conversion table from triple OS name to Rust SYSNAME\n const OS_TABLE: &'static [(&'static str, &'static str)] = &[\n@@ -73,7 +73,7 @@ pub fn matches_os(triple: &str, name: &str) -> bool {\n     // For the wasm32 bare target we ignore anything also ignored on emscripten\n     // and then we also recognize `wasm32-bare` as the os for the target\n     if triple == \"wasm32-unknown-unknown\" {\n-        return name == \"emscripten\" || name == \"wasm32-bare\"\n+        return name == \"emscripten\" || name == \"wasm32-bare\";\n     }\n     let triple: Vec<_> = triple.split('-').collect();\n     for &(triple_os, os) in OS_TABLE {"}]}