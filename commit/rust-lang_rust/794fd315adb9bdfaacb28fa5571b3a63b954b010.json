{"sha": "794fd315adb9bdfaacb28fa5571b3a63b954b010", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5NGZkMzE1YWRiOWJkZmFhY2IyOGZhNTU3MWIzYTYzYjk1NGIwMTA=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-08-22T17:01:46Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-08-29T18:27:40Z"}, "message": "incr.comp.: Move lock files out of directory being locked", "tree": {"sha": "a464e6da1470c60c6ded9dff24ffcbff929681a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a464e6da1470c60c6ded9dff24ffcbff929681a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/794fd315adb9bdfaacb28fa5571b3a63b954b010", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/794fd315adb9bdfaacb28fa5571b3a63b954b010", "html_url": "https://github.com/rust-lang/rust/commit/794fd315adb9bdfaacb28fa5571b3a63b954b010", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/794fd315adb9bdfaacb28fa5571b3a63b954b010/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e9bed92da499d7905232d47d54300134fca13b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e9bed92da499d7905232d47d54300134fca13b5", "html_url": "https://github.com/rust-lang/rust/commit/3e9bed92da499d7905232d47d54300134fca13b5"}], "stats": {"total": 489, "additions": 302, "deletions": 187}, "files": [{"sha": "338c65637995919216cd0bb5148e091fe4452cd2", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/794fd315adb9bdfaacb28fa5571b3a63b954b010/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794fd315adb9bdfaacb28fa5571b3a63b954b010/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=794fd315adb9bdfaacb28fa5571b3a63b954b010", "patch": "@@ -366,25 +366,31 @@ impl Session {\n     pub fn mark_incr_comp_session_as_invalid(&self) {\n         let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n \n-        if let IncrCompSession::Active { .. } = *incr_comp_session { } else {\n-            bug!(\"Trying to invalidate IncrCompSession `{:?}`\", *incr_comp_session)\n-        }\n+        let session_directory = match *incr_comp_session {\n+            IncrCompSession::Active { ref session_directory, .. } => {\n+                session_directory.clone()\n+            }\n+            _ => bug!(\"Trying to invalidate IncrCompSession `{:?}`\",\n+                      *incr_comp_session),\n+        };\n \n         // Note: This will also drop the lock file, thus unlocking the directory\n-        *incr_comp_session = IncrCompSession::InvalidBecauseOfErrors;\n+        *incr_comp_session = IncrCompSession::InvalidBecauseOfErrors {\n+            session_directory: session_directory\n+        };\n     }\n \n     pub fn incr_comp_session_dir(&self) -> cell::Ref<PathBuf> {\n         let incr_comp_session = self.incr_comp_session.borrow();\n         cell::Ref::map(incr_comp_session, |incr_comp_session| {\n             match *incr_comp_session {\n-                IncrCompSession::NotInitialized |\n-                IncrCompSession::InvalidBecauseOfErrors => {\n+                IncrCompSession::NotInitialized => {\n                     bug!(\"Trying to get session directory from IncrCompSession `{:?}`\",\n                         *incr_comp_session)\n                 }\n                 IncrCompSession::Active { ref session_directory, .. } |\n-                IncrCompSession::Finalized { ref session_directory } => {\n+                IncrCompSession::Finalized { ref session_directory } |\n+                IncrCompSession::InvalidBecauseOfErrors { ref session_directory } => {\n                     session_directory\n                 }\n             }\n@@ -541,7 +547,9 @@ pub enum IncrCompSession {\n     // This is an error state that is reached when some compilation error has\n     // occurred. It indicates that the contents of the session directory must\n     // not be used, since they might be invalid.\n-    InvalidBecauseOfErrors,\n+    InvalidBecauseOfErrors {\n+        session_directory: PathBuf,\n+    }\n }\n \n fn init_llvm(sess: &Session) {"}, {"sha": "4a184d3174dff51deb5918b57604988f703050d7", "filename": "src/librustc_data_structures/flock.rs", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/794fd315adb9bdfaacb28fa5571b3a63b954b010/src%2Flibrustc_data_structures%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794fd315adb9bdfaacb28fa5571b3a63b954b010/src%2Flibrustc_data_structures%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fflock.rs?ref=794fd315adb9bdfaacb28fa5571b3a63b954b010", "patch": "@@ -220,19 +220,18 @@ mod imp {\n     use std::path::Path;\n     use std::fs::{File, OpenOptions};\n     use std::os::raw::{c_ulong, c_ulonglong, c_int};\n-    use std::os::windows::fs::OpenOptionsExt;\n \n-    pub type DWORD = c_ulong;\n-    pub type BOOL = c_int;\n-    pub type ULONG_PTR = c_ulonglong;\n+    type DWORD = c_ulong;\n+    type BOOL = c_int;\n+    type ULONG_PTR = c_ulonglong;\n \n     type LPOVERLAPPED = *mut OVERLAPPED;\n     const LOCKFILE_EXCLUSIVE_LOCK: DWORD = 0x00000002;\n     const LOCKFILE_FAIL_IMMEDIATELY: DWORD = 0x00000001;\n \n-    pub const FILE_SHARE_DELETE: DWORD = 0x4;\n-    pub const FILE_SHARE_READ: DWORD = 0x1;\n-    pub const FILE_SHARE_WRITE: DWORD = 0x2;\n+    const FILE_SHARE_DELETE: DWORD = 0x4;\n+    const FILE_SHARE_READ: DWORD = 0x1;\n+    const FILE_SHARE_WRITE: DWORD = 0x2;\n \n     #[repr(C)]\n     struct OVERLAPPED {\n@@ -263,19 +262,30 @@ mod imp {\n                    create: bool,\n                    exclusive: bool)\n                    -> io::Result<Lock> {\n+            assert!(p.parent().unwrap().exists(),\n+                \"Parent directory of lock-file must exist: {}\",\n+                p.display());\n \n             let share_mode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE;\n \n-            let f = {\n-                let mut open_options = OpenOptions::new().read(true)\n-                                                         .share_mode(share_mode);\n-                if create {\n-                    open_options.create(true);\n-                }\n+            let mut open_options = OpenOptions::new();\n+            open_options.read(true)\n+                        .share_mode(share_mode);\n+\n+            if create {\n+                open_options.create(true)\n+                            .write(true);\n+            }\n \n-                match open_options.open(p) {\n-                    Ok(file) => file,\n-                    Err(err) => return Err(err),\n+            debug!(\"Attempting to open lock file `{}`\", p.display());\n+            let file = match open_options.open(p) {\n+                Ok(file) => {\n+                    debug!(\"Lock file opened successfully\");\n+                    file\n+                }\n+                Err(err) => {\n+                    debug!(\"Error opening lock file: {}\", err);\n+                    return Err(err)\n                 }\n             };\n \n@@ -291,17 +301,22 @@ mod imp {\n                     dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n                 }\n \n-                LockFileEx(f.as_raw_handle(),\n+                debug!(\"Attempting to acquire lock on lock file `{}`\",\n+                       p.display());\n+                LockFileEx(file.as_raw_handle(),\n                            dwFlags,\n                            0,\n                            0xFFFF_FFFF,\n                            0xFFFF_FFFF,\n                            &mut overlapped)\n             };\n             if ret == 0 {\n-                Err(io::Error::last_os_error())\n+                let err = io::Error::last_os_error();\n+                debug!(\"Failed acquiring file lock: {}\", err);\n+                Err(err)\n             } else {\n-                Ok(Lock { _file: f })\n+                debug!(\"Successfully acquired lock.\");\n+                Ok(Lock { _file: file })\n             }\n         }\n     }"}, {"sha": "e7da18cef10f967eb83b78a74d187241c23b7d64", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/794fd315adb9bdfaacb28fa5571b3a63b954b010/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794fd315adb9bdfaacb28fa5571b3a63b954b010/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=794fd315adb9bdfaacb28fa5571b3a63b954b010", "patch": "@@ -30,8 +30,8 @@\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(fn_traits)]\n-#![feature(libc)]\n \n+#![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]\n \n extern crate core;"}, {"sha": "6eb3124e08eecbd601a149acc5152d408901f83b", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 251, "deletions": 158, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/794fd315adb9bdfaacb28fa5571b3a63b954b010/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794fd315adb9bdfaacb28fa5571b3a63b954b010/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=794fd315adb9bdfaacb28fa5571b3a63b954b010", "patch": "@@ -65,7 +65,7 @@\n //!\n //! There is some synchronization needed in order for the compiler to be able to\n //! determine whether a given private session directory is not in used any more.\n-//! This is done by creating a lock file within each session directory and\n+//! This is done by creating a lock file for each session directory and\n //! locking it while the directory is still being used. Since file locks have\n //! operating system support, we can rely on the lock being released if the\n //! compiler process dies for some unexpected reason. Thus, when garbage\n@@ -131,7 +131,7 @@ use std::time::{UNIX_EPOCH, SystemTime, Duration};\n use std::__rand::{thread_rng, Rng};\n use syntax::ast;\n \n-const LOCK_FILE_NAME: &'static str = \".lock_file\";\n+const LOCK_FILE_EXT: &'static str = \".lock\";\n const DEP_GRAPH_FILENAME: &'static str = \"dep-graph.bin\";\n const WORK_PRODUCTS_FILENAME: &'static str = \"work-products.bin\";\n const METADATA_HASHES_FILENAME: &'static str = \"metadata.bin\";\n@@ -153,7 +153,22 @@ pub fn metadata_hash_import_path(import_session_dir: &Path) -> PathBuf {\n }\n \n pub fn lock_file_path(session_dir: &Path) -> PathBuf {\n-    session_dir.join(LOCK_FILE_NAME)\n+    let crate_dir = session_dir.parent().unwrap();\n+\n+    let directory_name = session_dir.file_name().unwrap().to_string_lossy();\n+    assert_no_characters_lost(&directory_name);\n+\n+    let dash_indices: Vec<_> = directory_name.match_indices(\"-\")\n+                                             .map(|(idx, _)| idx)\n+                                             .collect();\n+    if dash_indices.len() != 3 {\n+        bug!(\"Encountered incremental compilation session directory with \\\n+              malformed name: {}\",\n+             session_dir.display())\n+    }\n+\n+    crate_dir.join(&directory_name[0 .. dash_indices[2]])\n+             .with_extension(&LOCK_FILE_EXT[1..])\n }\n \n pub fn in_incr_comp_dir_sess(sess: &Session, file_name: &str) -> PathBuf {\n@@ -179,23 +194,24 @@ pub fn prepare_session_directory(tcx: TyCtxt) -> Result<bool, ()> {\n     // {incr-comp-dir}/{crate-name-and-disambiguator}\n     let crate_dir = crate_path_tcx(tcx, LOCAL_CRATE);\n     debug!(\"crate-dir: {}\", crate_dir.display());\n+    try!(create_dir(tcx.sess, &crate_dir, \"crate\"));\n \n     let mut source_directories_already_tried = FnvHashSet();\n \n     loop {\n-        // Allocate a session directory of the form:\n+        // Generate a session directory of the form:\n         //\n         // {incr-comp-dir}/{crate-name-and-disambiguator}/sess-{timestamp}-{random}-working\n-        //\n-        // If this fails, return an error, don't retry\n-        let session_dir = try!(alloc_session_dir(tcx.sess, &crate_dir));\n+        let session_dir = generate_session_dir_path(&crate_dir);\n         debug!(\"session-dir: {}\", session_dir.display());\n \n-        // Lock the newly created session directory. If this fails, return an\n+        // Lock the new session directory. If this fails, return an\n         // error without retrying\n-        let directory_lock = try!(lock_directory(tcx.sess, &session_dir));\n+        let (directory_lock, lock_file_path) = try!(lock_directory(tcx.sess, &session_dir));\n \n-        let print_file_copy_stats = tcx.sess.opts.debugging_opts.incremental_info;\n+        // Now that we have the lock, we can actually create the session\n+        // directory\n+        try!(create_dir(tcx.sess, &session_dir, \"session\"));\n \n         // Find a suitable source directory to copy from. Ignore those that we\n         // have already tried before.\n@@ -216,6 +232,8 @@ pub fn prepare_session_directory(tcx: TyCtxt) -> Result<bool, ()> {\n         debug!(\"attempting to copy data from source: {}\",\n                source_directory.display());\n \n+        let print_file_copy_stats = tcx.sess.opts.debugging_opts.incremental_info;\n+\n         // Try copying over all files from the source directory\n         if copy_files(&session_dir, &source_directory, print_file_copy_stats).is_ok() {\n             debug!(\"successfully copied data from: {}\",\n@@ -233,15 +251,19 @@ pub fn prepare_session_directory(tcx: TyCtxt) -> Result<bool, ()> {\n             // Try to remove the session directory we just allocated. We don't\n             // know if there's any garbage in it from the failed copy action.\n             if let Err(err) = std_fs::remove_dir_all(&session_dir) {\n-                debug!(\"Failed to delete partly initialized session dir `{}`: {}\",\n-                       session_dir.display(),\n-                       err);\n+                tcx.sess.warn(&format!(\"Failed to delete partly initialized \\\n+                                        session dir `{}`: {}\",\n+                                       session_dir.display(),\n+                                       err));\n             }\n+\n+            delete_session_dir_lock_file(tcx.sess, &lock_file_path);\n             mem::drop(directory_lock);\n         }\n     }\n }\n \n+\n /// This function finalizes and thus 'publishes' the session directory by\n /// renaming it to `sess-{timestamp}-{svh}` and releasing the file lock.\n /// If there have been compilation errors, however, this function will just\n@@ -262,10 +284,13 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n \n         if let Err(err) = std_fs::remove_dir_all(&*incr_comp_session_dir) {\n             sess.warn(&format!(\"Error deleting incremental compilation \\\n-                               session directory `{}`: {}\",\n+                                session directory `{}`: {}\",\n                                incr_comp_session_dir.display(),\n                                err));\n         }\n+\n+        let lock_file_path = lock_file_path(&*incr_comp_session_dir);\n+        delete_session_dir_lock_file(sess, &lock_file_path);\n         sess.mark_incr_comp_session_as_invalid();\n     }\n \n@@ -277,8 +302,8 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n                                                 .to_string_lossy();\n     assert_no_characters_lost(&old_sub_dir_name);\n \n-    // Keep the 'sess-{timestamp}' prefix, but replace the\n-    // '-{random-number}-working' part with the SVH of the crate\n+    // Keep the 'sess-{timestamp}-{random-number}' prefix, but replace the\n+    // '-working' part with the SVH of the crate\n     let dash_indices: Vec<_> = old_sub_dir_name.match_indices(\"-\")\n                                                .map(|(idx, _)| idx)\n                                                .collect();\n@@ -288,8 +313,8 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n              incr_comp_session_dir.display())\n     }\n \n-    // State: \"sess-{timestamp}-\"\n-    let mut new_sub_dir_name = String::from(&old_sub_dir_name[.. dash_indices[1] + 1]);\n+    // State: \"sess-{timestamp}-{random-number}-\"\n+    let mut new_sub_dir_name = String::from(&old_sub_dir_name[.. dash_indices[2] + 1]);\n \n     // Append the svh\n     new_sub_dir_name.push_str(&svh.to_string());\n@@ -327,7 +352,7 @@ fn copy_files(target_dir: &Path,\n               -> Result<(), ()> {\n     // We acquire a shared lock on the lock file of the directory, so that\n     // nobody deletes it out from under us while we are reading from it.\n-    let lock_file_path = source_dir.join(LOCK_FILE_NAME);\n+    let lock_file_path = lock_file_path(source_dir);\n     let _lock = if let Ok(lock) = flock::Lock::new(&lock_file_path,\n                                                    false,   // don't wait,\n                                                    false,   // don't create\n@@ -351,10 +376,6 @@ fn copy_files(target_dir: &Path,\n             Ok(entry) => {\n                 let file_name = entry.file_name();\n \n-                if file_name.to_string_lossy() == LOCK_FILE_NAME {\n-                    continue;\n-                }\n-\n                 let target_file_path = target_dir.join(file_name);\n                 let source_path = entry.path();\n \n@@ -383,30 +404,32 @@ fn copy_files(target_dir: &Path,\n     Ok(())\n }\n \n-/// Create a directory with a path of the form:\n+/// Generate unique directory path of the form:\n /// {crate_dir}/sess-{timestamp}-{random-number}-working\n-fn alloc_session_dir(sess: &Session,\n-                     crate_dir: &Path)\n-                     -> Result<PathBuf, ()> {\n+fn generate_session_dir_path(crate_dir: &Path) -> PathBuf {\n     let timestamp = timestamp_to_string(SystemTime::now());\n-    debug!(\"alloc_session_dir: timestamp = {}\", timestamp);\n+    debug!(\"generate_session_dir_path: timestamp = {}\", timestamp);\n     let random_number = thread_rng().next_u32();\n-    debug!(\"alloc_session_dir: random_number = {}\", random_number);\n+    debug!(\"generate_session_dir_path: random_number = {}\", random_number);\n \n     let directory_name = format!(\"sess-{}-{:x}-working\", timestamp, random_number);\n-    debug!(\"alloc_session_dir: directory_name = {}\", directory_name);\n+    debug!(\"generate_session_dir_path: directory_name = {}\", directory_name);\n     let directory_path = crate_dir.join(directory_name);\n-    debug!(\"alloc_session_dir: directory_path = {}\", directory_path.display());\n+    debug!(\"generate_session_dir_path: directory_path = {}\", directory_path.display());\n+    directory_path\n+}\n \n-    match fs_util::create_dir_racy(&directory_path) {\n+fn create_dir(sess: &Session, path: &Path, dir_tag: &str) -> Result<(),()> {\n+    match fs_util::create_dir_racy(path) {\n         Ok(()) => {\n-            debug!(\"alloc_session_dir: directory created successfully\");\n-            Ok(directory_path)\n+            debug!(\"{} directory created successfully\", dir_tag);\n+            Ok(())\n         }\n         Err(err) => {\n-            sess.err(&format!(\"incremental compilation: could not create \\\n-                               session directory `{}`: {}\",\n-                              directory_path.display(),\n+            sess.err(&format!(\"Could not create incremental compilation {} \\\n+                               directory `{}`: {}\",\n+                              dir_tag,\n+                              path.display(),\n                               err));\n             Err(())\n         }\n@@ -416,15 +439,15 @@ fn alloc_session_dir(sess: &Session,\n /// Allocate a the lock-file and lock it.\n fn lock_directory(sess: &Session,\n                   session_dir: &Path)\n-                  -> Result<flock::Lock, ()> {\n-    let lock_file_path = session_dir.join(LOCK_FILE_NAME);\n+                  -> Result<(flock::Lock, PathBuf), ()> {\n+    let lock_file_path = lock_file_path(session_dir);\n     debug!(\"lock_directory() - lock_file: {}\", lock_file_path.display());\n \n     match flock::Lock::new(&lock_file_path,\n                            false, // don't wait\n                            true,  // create the lock file\n                            true) { // the lock should be exclusive\n-        Ok(lock) => Ok(lock),\n+        Ok(lock) => Ok((lock, lock_file_path)),\n         Err(err) => {\n             sess.err(&format!(\"incremental compilation: could not create \\\n                                session directory lock file: {}\", err));\n@@ -433,6 +456,16 @@ fn lock_directory(sess: &Session,\n     }\n }\n \n+fn delete_session_dir_lock_file(sess: &Session,\n+                                lock_file_path: &Path) {\n+    if let Err(err) = std_fs::remove_file(&lock_file_path) {\n+        sess.warn(&format!(\"Error deleting lock file for incremental \\\n+                            compilation session directory `{}`: {}\",\n+                           lock_file_path.display(),\n+                           err));\n+    }\n+}\n+\n /// Find the most recent published session directory that is not in the\n /// ignore-list.\n fn find_source_directory(crate_dir: &Path,\n@@ -453,23 +486,26 @@ fn find_source_directory_in_iter<I>(iter: I,\n     let mut best_candidate = (UNIX_EPOCH, None);\n \n     for session_dir in iter {\n+        debug!(\"find_source_directory_in_iter - inspecting `{}`\",\n+               session_dir.display());\n+\n+        let directory_name = session_dir.file_name().unwrap().to_string_lossy();\n+        assert_no_characters_lost(&directory_name);\n+\n         if source_directories_already_tried.contains(&session_dir) ||\n-           !is_finalized(&session_dir.to_string_lossy()) {\n+           !is_session_directory(&directory_name) ||\n+           !is_finalized(&directory_name) {\n+            debug!(\"find_source_directory_in_iter - ignoring.\");\n             continue\n         }\n \n-        let timestamp = {\n-            let directory_name = session_dir.file_name().unwrap().to_string_lossy();\n-            assert_no_characters_lost(&directory_name);\n-\n-            extract_timestamp_from_session_dir(&directory_name)\n-                .unwrap_or_else(|_| {\n-                    bug!(\"unexpected incr-comp session dir: {}\", session_dir.display())\n-                })\n-        };\n+        let timestamp = extract_timestamp_from_session_dir(&directory_name)\n+            .unwrap_or_else(|_| {\n+                bug!(\"unexpected incr-comp session dir: {}\", session_dir.display())\n+            });\n \n         if timestamp > best_candidate.0 {\n-            best_candidate = (timestamp, Some(session_dir));\n+            best_candidate = (timestamp, Some(session_dir.clone()));\n         }\n     }\n \n@@ -481,7 +517,12 @@ fn is_finalized(directory_name: &str) -> bool {\n }\n \n fn is_session_directory(directory_name: &str) -> bool {\n-    directory_name.starts_with(\"sess-\")\n+    directory_name.starts_with(\"sess-\") &&\n+    !directory_name.ends_with(LOCK_FILE_EXT)\n+}\n+\n+fn is_session_directory_lock_file(file_name: &str) -> bool {\n+    file_name.starts_with(\"sess-\") && file_name.ends_with(LOCK_FILE_EXT)\n }\n \n fn extract_timestamp_from_session_dir(directory_name: &str)\n@@ -493,7 +534,7 @@ fn extract_timestamp_from_session_dir(directory_name: &str)\n     let dash_indices: Vec<_> = directory_name.match_indices(\"-\")\n                                              .map(|(idx, _)| idx)\n                                              .collect();\n-    if dash_indices.len() < 2 {\n+    if dash_indices.len() != 3 {\n         return Err(())\n     }\n \n@@ -502,22 +543,22 @@ fn extract_timestamp_from_session_dir(directory_name: &str)\n \n fn timestamp_to_string(timestamp: SystemTime) -> String {\n     let duration = timestamp.duration_since(UNIX_EPOCH).unwrap();\n-    let nanos = duration.as_secs() * 1_000_000_000 +\n-                (duration.subsec_nanos() as u64);\n-    format!(\"{:x}\", nanos)\n+    let micros = duration.as_secs() * 1_000_000 +\n+                (duration.subsec_nanos() as u64) / 1000;\n+    format!(\"{:x}\", micros)\n }\n \n fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n-    let nanos_since_unix_epoch = u64::from_str_radix(s, 16);\n+    let micros_since_unix_epoch = u64::from_str_radix(s, 16);\n \n-    if nanos_since_unix_epoch.is_err() {\n+    if micros_since_unix_epoch.is_err() {\n         return Err(())\n     }\n \n-    let nanos_since_unix_epoch = nanos_since_unix_epoch.unwrap();\n+    let micros_since_unix_epoch = micros_since_unix_epoch.unwrap();\n \n-    let duration = Duration::new(nanos_since_unix_epoch / 1_000_000_000,\n-                                 (nanos_since_unix_epoch % 1_000_000_000) as u32);\n+    let duration = Duration::new(micros_since_unix_epoch / 1_000_000,\n+                                 1000 * (micros_since_unix_epoch % 1_000_000) as u32);\n     Ok(UNIX_EPOCH + duration)\n }\n \n@@ -607,6 +648,10 @@ fn assert_no_characters_lost(s: &str) {\n     }\n }\n \n+fn is_old_enough_to_be_collected(timestamp: SystemTime) -> bool {\n+    timestamp < SystemTime::now() - Duration::from_secs(10)\n+}\n+\n pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n     debug!(\"garbage_collect_session_directories() - begin\");\n \n@@ -618,8 +663,10 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n     debug!(\"garbage_collect_session_directories() - crate directory: {}\",\n         crate_directory.display());\n \n-    let mut deletion_candidates = vec![];\n-    let mut definitely_delete = vec![];\n+    // First do a pass over the crate directory, collecting lock files and\n+    // session directories\n+    let mut session_directories = FnvHashSet();\n+    let mut lock_files = FnvHashSet();\n \n     for dir_entry in try!(crate_directory.read_dir()) {\n         let dir_entry = match dir_entry {\n@@ -630,102 +677,143 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n             }\n         };\n \n-        let directory_name = dir_entry.file_name();\n-        let directory_name = directory_name.to_string_lossy();\n+        let entry_name = dir_entry.file_name();\n+        let entry_name = entry_name.to_string_lossy();\n \n-        if !is_session_directory(&directory_name) {\n-            // This is something we don't know, leave it alone...\n-            continue\n+        if is_session_directory_lock_file(&entry_name) {\n+            assert_no_characters_lost(&entry_name);\n+            lock_files.insert(entry_name.into_owned());\n+        } else if is_session_directory(&entry_name) {\n+            assert_no_characters_lost(&entry_name);\n+            session_directories.insert(entry_name.into_owned());\n+        } else {\n+            // This is something we don't know, leave it alone\n         }\n-        assert_no_characters_lost(&directory_name);\n+    }\n \n-        if let Ok(file_type) = dir_entry.file_type() {\n-            if !file_type.is_dir() {\n-                // This is not a directory, skip it\n-                continue\n+    // Now map from lock files to session directories\n+    let lock_file_to_session_dir: FnvHashMap<String, Option<String>> =\n+        lock_files.into_iter()\n+                  .map(|lock_file_name| {\n+                        assert!(lock_file_name.ends_with(LOCK_FILE_EXT));\n+                        let dir_prefix_end = lock_file_name.len() - LOCK_FILE_EXT.len();\n+                        let session_dir = {\n+                            let dir_prefix = &lock_file_name[0 .. dir_prefix_end];\n+                            session_directories.iter()\n+                                               .find(|dir_name| dir_name.starts_with(dir_prefix))\n+                        };\n+                        (lock_file_name, session_dir.map(String::clone))\n+                    })\n+                  .collect();\n+\n+    // Delete all lock files, that don't have an associated directory. They must\n+    // be some kind of leftover\n+    for (lock_file_name, directory_name) in &lock_file_to_session_dir {\n+        if directory_name.is_none() {\n+            let timestamp = match extract_timestamp_from_session_dir(lock_file_name) {\n+                Ok(timestamp) => timestamp,\n+                Err(()) => {\n+                    debug!(\"Found lock-file with malformed timestamp: {}\",\n+                        crate_directory.join(&lock_file_name).display());\n+                    // Ignore it\n+                    continue\n+                }\n+            };\n+\n+            let lock_file_path = crate_directory.join(&**lock_file_name);\n+\n+            if is_old_enough_to_be_collected(timestamp) {\n+                debug!(\"garbage_collect_session_directories() - deleting \\\n+                        garbage lock file: {}\", lock_file_path.display());\n+                delete_session_dir_lock_file(sess, &lock_file_path);\n+            } else {\n+                debug!(\"garbage_collect_session_directories() - lock file with \\\n+                        no session dir not old enough to be collected: {}\",\n+                       lock_file_path.display());\n             }\n-        } else {\n-            // Some error occurred while trying to determine the file type,\n-            // skip it\n-            continue\n         }\n+    }\n+\n+    // Filter out `None` directories\n+    let lock_file_to_session_dir: FnvHashMap<String, String> =\n+        lock_file_to_session_dir.into_iter()\n+                                .filter_map(|(lock_file_name, directory_name)| {\n+                                    directory_name.map(|n| (lock_file_name, n))\n+                                })\n+                                .collect();\n+\n+    let mut deletion_candidates = vec![];\n+    let mut definitely_delete = vec![];\n \n+    for (lock_file_name, directory_name) in &lock_file_to_session_dir {\n         debug!(\"garbage_collect_session_directories() - inspecting: {}\",\n                 directory_name);\n \n-        match extract_timestamp_from_session_dir(&directory_name) {\n-            Ok(timestamp) => {\n-                let lock_file_path = crate_directory.join(&*directory_name)\n-                                                    .join(LOCK_FILE_NAME);\n-\n-                if !is_finalized(&directory_name) {\n-                    let ten_seconds = Duration::from_secs(10);\n-\n-                    // When cleaning out \"-working\" session directories, i.e.\n-                    // session directories that might still be in use by another\n-                    // compiler instance, we only look a directories that are\n-                    // at least ten seconds old. This is supposed to reduce the\n-                    // chance of deleting a directory in the time window where\n-                    // the process has allocated the directory but has not yet\n-                    // acquired the file-lock on it.\n-                    if timestamp < SystemTime::now() - ten_seconds {\n-                        debug!(\"garbage_collect_session_directories() - \\\n-                                attempting to collect\");\n-\n-                        // Try to acquire the directory lock. If we can't, it\n-                        // means that the owning process is still alive and we\n-                        // leave this directory alone.\n-                        match flock::Lock::new(&lock_file_path,\n-                                               false,  // don't wait\n-                                               false,  // don't create the lock-file\n-                                               true) { // get an exclusive lock\n-                            Ok(lock) => {\n-                                debug!(\"garbage_collect_session_directories() - \\\n-                                        successfully acquired lock\");\n-\n-                                // Note that we are holding on to the lock\n-                                definitely_delete.push((dir_entry.path(),\n-                                                        Some(lock)));\n-                            }\n-                            Err(_) => {\n-                                debug!(\"garbage_collect_session_directories() - \\\n-                                not collecting, still in use\");\n-                            }\n-                        }\n-                    } else {\n-                        debug!(\"garbage_collect_session_directories() - \\\n-                                private session directory too new\");\n-                    }\n-                } else {\n-                    match flock::Lock::new(&lock_file_path,\n-                                           false,  // don't wait\n-                                           false,  // don't create the lock-file\n-                                           true) { // get an exclusive lock\n-                        Ok(lock) => {\n-                            debug!(\"garbage_collect_session_directories() - \\\n-                                    successfully acquired lock\");\n-                            debug!(\"garbage_collect_session_directories() - adding \\\n-                                    deletion candidate: {}\", directory_name);\n-\n-                            // Note that we are holding on to the lock\n-                            deletion_candidates.push((timestamp,\n-                                                      dir_entry.path(),\n-                                                      Some(lock)));\n-                        }\n-                        Err(_) => {\n-                            debug!(\"garbage_collect_session_directories() - \\\n+        let timestamp = match extract_timestamp_from_session_dir(directory_name) {\n+            Ok(timestamp) => timestamp,\n+            Err(()) => {\n+                debug!(\"Found session-dir with malformed timestamp: {}\",\n+                        crate_directory.join(directory_name).display());\n+                // Ignore it\n+                continue\n+            }\n+        };\n+\n+        if is_finalized(directory_name) {\n+            let lock_file_path = crate_directory.join(lock_file_name);\n+            match flock::Lock::new(&lock_file_path,\n+                                   false,  // don't wait\n+                                   false,  // don't create the lock-file\n+                                   true) { // get an exclusive lock\n+                Ok(lock) => {\n+                    debug!(\"garbage_collect_session_directories() - \\\n+                            successfully acquired lock\");\n+                    debug!(\"garbage_collect_session_directories() - adding \\\n+                            deletion candidate: {}\", directory_name);\n+\n+                    // Note that we are holding on to the lock\n+                    deletion_candidates.push((timestamp,\n+                                              crate_directory.join(directory_name),\n+                                              Some(lock)));\n+                }\n+                Err(_) => {\n+                    debug!(\"garbage_collect_session_directories() - \\\n                             not collecting, still in use\");\n-                        }\n-                    }\n                 }\n             }\n-            Err(_) => {\n-                // Malformed timestamp in directory, delete it\n-                definitely_delete.push((dir_entry.path(), None));\n-\n-                debug!(\"garbage_collect_session_directories() - encountered \\\n-                        malformed session directory: {}\", directory_name);\n+        } else if is_old_enough_to_be_collected(timestamp) {\n+            // When cleaning out \"-working\" session directories, i.e.\n+            // session directories that might still be in use by another\n+            // compiler instance, we only look a directories that are\n+            // at least ten seconds old. This is supposed to reduce the\n+            // chance of deleting a directory in the time window where\n+            // the process has allocated the directory but has not yet\n+            // acquired the file-lock on it.\n+\n+            // Try to acquire the directory lock. If we can't, it\n+            // means that the owning process is still alive and we\n+            // leave this directory alone.\n+            let lock_file_path = crate_directory.join(lock_file_name);\n+            match flock::Lock::new(&lock_file_path,\n+                                   false,  // don't wait\n+                                   false,  // don't create the lock-file\n+                                   true) { // get an exclusive lock\n+                Ok(lock) => {\n+                    debug!(\"garbage_collect_session_directories() - \\\n+                            successfully acquired lock\");\n+\n+                    // Note that we are holding on to the lock\n+                    definitely_delete.push((crate_directory.join(directory_name),\n+                                            Some(lock)));\n+                }\n+                Err(_) => {\n+                    debug!(\"garbage_collect_session_directories() - \\\n+                            not collecting, still in use\");\n+                }\n             }\n+        } else {\n+            debug!(\"garbage_collect_session_directories() - not finalized, not \\\n+                    old enough\");\n         }\n     }\n \n@@ -739,8 +827,11 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n                                 compilation session directory `{}`: {}\",\n                                path.display(),\n                                err));\n+        } else {\n+            delete_session_dir_lock_file(sess, &lock_file_path(&path));\n         }\n \n+\n         // Let's make it explicit that the file lock is released at this point,\n         // or rather, that we held on to it until here\n         mem::drop(lock);\n@@ -755,6 +846,8 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n                                 compilation session directory `{}`: {}\",\n                                path.display(),\n                                err));\n+        } else {\n+            delete_session_dir_lock_file(sess, &lock_file_path(&path));\n         }\n \n         // Let's make it explicit that the file lock is released at this point,\n@@ -809,7 +902,7 @@ fn test_all_except_most_recent() {\n #[test]\n fn test_timestamp_serialization() {\n     for i in 0 .. 1_000u64 {\n-        let time = UNIX_EPOCH + Duration::new(i * 3_434_578, (i as u32) * 239_676);\n+        let time = UNIX_EPOCH + Duration::new(i * 3_434_578, (i as u32) * 239_000);\n         let s = timestamp_to_string(time);\n         assert_eq!(time, string_to_timestamp(&s).unwrap());\n     }\n@@ -821,27 +914,27 @@ fn test_find_source_directory_in_iter() {\n \n     // Find newest\n     assert_eq!(find_source_directory_in_iter(\n-        vec![PathBuf::from(\"./sess-3234-0000\"),\n-             PathBuf::from(\"./sess-2234-0000\"),\n-             PathBuf::from(\"./sess-1234-0000\")].into_iter(), &already_visited),\n-        Some(PathBuf::from(\"./sess-3234-0000\")));\n+        vec![PathBuf::from(\"crate-dir/sess-3234-0000-svh\"),\n+             PathBuf::from(\"crate-dir/sess-2234-0000-svh\"),\n+             PathBuf::from(\"crate-dir/sess-1234-0000-svh\")].into_iter(), &already_visited),\n+        Some(PathBuf::from(\"crate-dir/sess-3234-0000-svh\")));\n \n     // Filter out \"-working\"\n     assert_eq!(find_source_directory_in_iter(\n-        vec![PathBuf::from(\"./sess-3234-0000-working\"),\n-             PathBuf::from(\"./sess-2234-0000\"),\n-             PathBuf::from(\"./sess-1234-0000\")].into_iter(), &already_visited),\n-        Some(PathBuf::from(\"./sess-2234-0000\")));\n+        vec![PathBuf::from(\"crate-dir/sess-3234-0000-working\"),\n+             PathBuf::from(\"crate-dir/sess-2234-0000-svh\"),\n+             PathBuf::from(\"crate-dir/sess-1234-0000-svh\")].into_iter(), &already_visited),\n+        Some(PathBuf::from(\"crate-dir/sess-2234-0000-svh\")));\n \n     // Handle empty\n     assert_eq!(find_source_directory_in_iter(vec![].into_iter(), &already_visited),\n                None);\n \n     // Handle only working\n     assert_eq!(find_source_directory_in_iter(\n-        vec![PathBuf::from(\"./sess-3234-0000-working\"),\n-             PathBuf::from(\"./sess-2234-0000-working\"),\n-             PathBuf::from(\"./sess-1234-0000-working\")].into_iter(), &already_visited),\n+        vec![PathBuf::from(\"crate-dir/sess-3234-0000-working\"),\n+             PathBuf::from(\"crate-dir/sess-2234-0000-working\"),\n+             PathBuf::from(\"crate-dir/sess-1234-0000-working\")].into_iter(), &already_visited),\n         None);\n }\n "}, {"sha": "48f95430f26b6f47c650bb003b07924a0dee6c56", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/794fd315adb9bdfaacb28fa5571b3a63b954b010/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794fd315adb9bdfaacb28fa5571b3a63b954b010/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=794fd315adb9bdfaacb28fa5571b3a63b954b010", "patch": "@@ -59,7 +59,6 @@ pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         Err(()) => {\n             // Something went wrong while trying to allocate the session\n             // directory. Don't try to use it any further.\n-            let _ = garbage_collect_session_directories(tcx.sess);\n             return\n         }\n     }"}]}