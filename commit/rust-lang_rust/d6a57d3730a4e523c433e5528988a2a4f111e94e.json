{"sha": "d6a57d3730a4e523c433e5528988a2a4f111e94e", "node_id": "C_kwDOAAsO6NoAKGQ2YTU3ZDM3MzBhNGU1MjNjNDMzZTU1Mjg5ODhhMmE0ZjExMWU5NGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-26T07:29:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-26T07:29:15Z"}, "message": "Auto merge of #94034 - willcrichton:fix-trait-suggestion-for-binops, r=estebank\n\nFix incorrect suggestion for trait bounds involving binary operators\n\nThis PR fixes #93927, #92347, #93744 by replacing the bespoke trait-suggestion logic in `op.rs` with a more common code path.\n\nThe downside is that this fix causes some suggestions to not include an `Output=` type, reducing their usefulness.\n\nNote that this causes one case in the `missing-bounds.rs` test to fail rustfix. So I would need to move that code into a separate non-fix test if this PR is otherwise acceptable.", "tree": {"sha": "fd54467a11fa702f622154e07dacea9e572adb45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd54467a11fa702f622154e07dacea9e572adb45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6a57d3730a4e523c433e5528988a2a4f111e94e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6a57d3730a4e523c433e5528988a2a4f111e94e", "html_url": "https://github.com/rust-lang/rust/commit/d6a57d3730a4e523c433e5528988a2a4f111e94e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6a57d3730a4e523c433e5528988a2a4f111e94e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c988cfa0b7f4d3bc5b1cb40dc5002f5adbfb9ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c988cfa0b7f4d3bc5b1cb40dc5002f5adbfb9ad", "html_url": "https://github.com/rust-lang/rust/commit/1c988cfa0b7f4d3bc5b1cb40dc5002f5adbfb9ad"}, {"sha": "dc41dbaf8eec1ff144f45c8a3c65b7514aa70895", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc41dbaf8eec1ff144f45c8a3c65b7514aa70895", "html_url": "https://github.com/rust-lang/rust/commit/dc41dbaf8eec1ff144f45c8a3c65b7514aa70895"}], "stats": {"total": 270, "additions": 109, "deletions": 161}, "files": [{"sha": "1ae53a77adc566589bc4a489c78903e9a54549ef", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 47, "deletions": 90, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/d6a57d3730a4e523c433e5528988a2a4f111e94e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6a57d3730a4e523c433e5528988a2a4f111e94e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=d6a57d3730a4e523c433e5528988a2a4f111e94e", "patch": "@@ -11,13 +11,12 @@ use rustc_middle::ty::adjustment::{\n };\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple, Uint};\n-use rustc_middle::ty::{\n-    self, suggest_constraining_type_param, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n-};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt as _;\n use rustc_trait_selection::traits::{FulfillmentError, TraitEngine, TraitEngineExt};\n \n use std::ops::ControlFlow;\n@@ -266,7 +265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(_) if lhs_ty.references_error() || rhs_ty.references_error() => self.tcx.ty_error(),\n             Err(errors) => {\n                 let source_map = self.tcx.sess.source_map();\n-                let (mut err, missing_trait, use_output) = match is_assign {\n+                let (mut err, missing_trait, _use_output) = match is_assign {\n                     IsAssign::Yes => {\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n@@ -449,39 +448,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                         // we don't want the note in the else clause to be emitted\n                     } else if let [ty] = &visitor.0[..] {\n-                        if let ty::Param(p) = *ty.kind() {\n-                            // Check if the method would be found if the type param wasn't\n-                            // involved. If so, it means that adding a trait bound to the param is\n-                            // enough. Otherwise we do not give the suggestion.\n-                            let mut eraser = TypeParamEraser(self, expr.span);\n-                            let needs_bound = self\n-                                .lookup_op_method(\n-                                    eraser.fold_ty(lhs_ty),\n-                                    Some(eraser.fold_ty(rhs_ty)),\n-                                    Some(rhs_expr),\n-                                    Op::Binary(op, is_assign),\n-                                )\n-                                .is_ok();\n-                            if needs_bound {\n-                                suggest_constraining_param(\n-                                    self.tcx,\n-                                    self.body_id,\n+                        // Look for a TraitPredicate in the Fulfillment errors,\n+                        // and use it to generate a suggestion.\n+                        //\n+                        // Note that lookup_op_method must be called again but\n+                        // with a specific rhs_ty instead of a placeholder so\n+                        // the resulting predicate generates a more specific\n+                        // suggestion for the user.\n+                        let errors = self\n+                            .lookup_op_method(\n+                                lhs_ty,\n+                                Some(rhs_ty),\n+                                Some(rhs_expr),\n+                                Op::Binary(op, is_assign),\n+                            )\n+                            .unwrap_err();\n+                        let predicates = errors\n+                            .into_iter()\n+                            .filter_map(|error| error.obligation.predicate.to_opt_poly_trait_pred())\n+                            .collect::<Vec<_>>();\n+                        if !predicates.is_empty() {\n+                            for pred in predicates {\n+                                self.infcx.suggest_restricting_param_bound(\n                                     &mut err,\n-                                    *ty,\n-                                    rhs_ty,\n-                                    missing_trait,\n-                                    p,\n-                                    use_output,\n+                                    pred,\n+                                    self.body_id,\n                                 );\n-                            } else if *ty != lhs_ty {\n-                                // When we know that a missing bound is responsible, we don't show\n-                                // this note as it is redundant.\n-                                err.note(&format!(\n-                                    \"the trait `{missing_trait}` is not implemented for `{lhs_ty}`\"\n-                                ));\n                             }\n-                        } else {\n-                            bug!(\"type param visitor stored a non type param: {:?}\", ty.kind());\n+                        } else if *ty != lhs_ty {\n+                            // When we know that a missing bound is responsible, we don't show\n+                            // this note as it is redundant.\n+                            err.note(&format!(\n+                                \"the trait `{missing_trait}` is not implemented for `{lhs_ty}`\"\n+                            ));\n                         }\n                     }\n                 }\n@@ -671,24 +670,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ex.span,\n                         format!(\"cannot apply unary operator `{}`\", op.as_str()),\n                     );\n-                    let missing_trait = match op {\n-                        hir::UnOp::Deref => unreachable!(\"check unary op `-` or `!` only\"),\n-                        hir::UnOp::Not => \"std::ops::Not\",\n-                        hir::UnOp::Neg => \"std::ops::Neg\",\n-                    };\n+\n                     let mut visitor = TypeParamVisitor(vec![]);\n                     visitor.visit_ty(operand_ty);\n-                    if let [ty] = &visitor.0[..] && let ty::Param(p) = *operand_ty.kind() {\n-                        suggest_constraining_param(\n-                            self.tcx,\n-                            self.body_id,\n-                            &mut err,\n-                            *ty,\n-                            operand_ty,\n-                            missing_trait,\n-                            p,\n-                            true,\n-                        );\n+                    if let [_] = &visitor.0[..] && let ty::Param(_) = *operand_ty.kind() {\n+                        let predicates = errors\n+                            .iter()\n+                            .filter_map(|error| {\n+                                error.obligation.predicate.clone().to_opt_poly_trait_pred()\n+                            });\n+                        for pred in predicates {\n+                            self.infcx.suggest_restricting_param_bound(\n+                                &mut err,\n+                                pred,\n+                                self.body_id,\n+                            );\n+                        }\n                     }\n \n                     let sp = self.tcx.sess.source_map().start_point(ex.span);\n@@ -973,46 +970,6 @@ fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>, rhs: Ty<'tcx>, op: hir::BinOp) -> bool\n     }\n }\n \n-fn suggest_constraining_param(\n-    tcx: TyCtxt<'_>,\n-    body_id: hir::HirId,\n-    mut err: &mut Diagnostic,\n-    lhs_ty: Ty<'_>,\n-    rhs_ty: Ty<'_>,\n-    missing_trait: &str,\n-    p: ty::ParamTy,\n-    set_output: bool,\n-) {\n-    let hir = tcx.hir();\n-    let msg = &format!(\"`{lhs_ty}` might need a bound for `{missing_trait}`\");\n-    // Try to find the def-id and details for the parameter p. We have only the index,\n-    // so we have to find the enclosing function's def-id, then look through its declared\n-    // generic parameters to get the declaration.\n-    let def_id = hir.body_owner_def_id(hir::BodyId { hir_id: body_id });\n-    let generics = tcx.generics_of(def_id);\n-    let param_def_id = generics.type_param(&p, tcx).def_id;\n-    if let Some(generics) = param_def_id\n-        .as_local()\n-        .map(|id| hir.local_def_id_to_hir_id(id))\n-        .and_then(|id| hir.find_by_def_id(hir.get_parent_item(id)))\n-        .as_ref()\n-        .and_then(|node| node.generics())\n-    {\n-        let output = if set_output { format!(\"<Output = {rhs_ty}>\") } else { String::new() };\n-        suggest_constraining_type_param(\n-            tcx,\n-            generics,\n-            &mut err,\n-            &lhs_ty.to_string(),\n-            &format!(\"{missing_trait}{output}\"),\n-            None,\n-        );\n-    } else {\n-        let span = tcx.def_span(param_def_id);\n-        err.span_label(span, msg);\n-    }\n-}\n-\n struct TypeParamVisitor<'tcx>(Vec<Ty<'tcx>>);\n \n impl<'tcx> TypeVisitor<'tcx> for TypeParamVisitor<'tcx> {"}, {"sha": "de27c9785e65a40f65270fc63cee1a59263a830b", "filename": "src/test/ui/binop/issue-93927.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Fbinop%2Fissue-93927.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Fbinop%2Fissue-93927.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-93927.rs?ref=d6a57d3730a4e523c433e5528988a2a4f111e94e", "patch": "@@ -0,0 +1,20 @@\n+// Regression test for #93927: suggested trait bound for T should be Eq, not PartialEq\n+struct MyType<T>(T);\n+\n+impl<T> PartialEq for MyType<T>\n+where\n+    T: Eq,\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        true\n+    }\n+}\n+\n+fn cond<T: PartialEq>(val: MyType<T>) -> bool {\n+    val == val\n+    //~^ ERROR binary operation `==` cannot be applied to type `MyType<T>`\n+}\n+\n+fn main() {\n+    cond(MyType(0));\n+}"}, {"sha": "75558b502f9dc6e057e0e56dedd680c065ec0d34", "filename": "src/test/ui/binop/issue-93927.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Fbinop%2Fissue-93927.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Fbinop%2Fissue-93927.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-93927.stderr?ref=d6a57d3730a4e523c433e5528988a2a4f111e94e", "patch": "@@ -0,0 +1,16 @@\n+error[E0369]: binary operation `==` cannot be applied to type `MyType<T>`\n+  --> $DIR/issue-93927.rs:14:9\n+   |\n+LL |     val == val\n+   |     --- ^^ --- MyType<T>\n+   |     |\n+   |     MyType<T>\n+   |\n+help: consider further restricting this bound\n+   |\n+LL | fn cond<T: PartialEq + std::cmp::Eq>(val: MyType<T>) -> bool {\n+   |                      ++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "0e234120a51c5840a5a903c84772647bca701425", "filename": "src/test/ui/generic-associated-types/missing-bounds.fixed", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1c988cfa0b7f4d3bc5b1cb40dc5002f5adbfb9ad/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1c988cfa0b7f4d3bc5b1cb40dc5002f5adbfb9ad/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed?ref=1c988cfa0b7f4d3bc5b1cb40dc5002f5adbfb9ad", "patch": "@@ -1,46 +0,0 @@\n-// run-rustfix\n-\n-use std::ops::Add;\n-\n-struct A<B>(B);\n-\n-impl<B> Add for A<B> where B: Add + Add<Output = B> {\n-    type Output = Self;\n-\n-    fn add(self, rhs: Self) -> Self {\n-        A(self.0 + rhs.0) //~ ERROR mismatched types\n-    }\n-}\n-\n-struct C<B>(B);\n-\n-impl<B: Add + Add<Output = B>> Add for C<B> {\n-    type Output = Self;\n-\n-    fn add(self, rhs: Self) -> Self {\n-        Self(self.0 + rhs.0) //~ ERROR mismatched types\n-    }\n-}\n-\n-struct D<B>(B);\n-\n-impl<B: std::ops::Add<Output = B>> Add for D<B> {\n-    type Output = Self;\n-\n-    fn add(self, rhs: Self) -> Self {\n-        Self(self.0 + rhs.0) //~ ERROR cannot add `B` to `B`\n-    }\n-}\n-\n-struct E<B>(B);\n-\n-impl<B: Add> Add for E<B> where B: Add<Output = B>, B: Add<Output = B> {\n-    //~^ ERROR equality constraints are not yet supported in `where` clauses\n-    type Output = Self;\n-\n-    fn add(self, rhs: Self) -> Self {\n-        Self(self.0 + rhs.0) //~ ERROR mismatched types\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "b3661ba3744eec99eb11d3495e79f9b6bd25325e", "filename": "src/test/ui/generic-associated-types/missing-bounds.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs?ref=d6a57d3730a4e523c433e5528988a2a4f111e94e", "patch": "@@ -1,5 +1,3 @@\n-// run-rustfix\n-\n use std::ops::Add;\n \n struct A<B>(B);"}, {"sha": "aaeec920527edfbc43ee3ceacc0a107d6790567e", "filename": "src/test/ui/generic-associated-types/missing-bounds.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr?ref=d6a57d3730a4e523c433e5528988a2a4f111e94e", "patch": "@@ -1,5 +1,5 @@\n error: equality constraints are not yet supported in `where` clauses\n-  --> $DIR/missing-bounds.rs:37:33\n+  --> $DIR/missing-bounds.rs:35:33\n    |\n LL | impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^ not supported\n@@ -11,7 +11,7 @@ LL | impl<B: Add> Add for E<B> where B: Add<Output = B> {\n    |                                 ~~~~~~~~~~~~~~~~~~\n \n error[E0308]: mismatched types\n-  --> $DIR/missing-bounds.rs:11:11\n+  --> $DIR/missing-bounds.rs:9:11\n    |\n LL | impl<B> Add for A<B> where B: Add {\n    |      - this type parameter\n@@ -24,7 +24,7 @@ LL |         A(self.0 + rhs.0)\n    = note: expected type parameter `B`\n              found associated type `<B as Add>::Output`\n note: tuple struct defined here\n-  --> $DIR/missing-bounds.rs:5:8\n+  --> $DIR/missing-bounds.rs:3:8\n    |\n LL | struct A<B>(B);\n    |        ^\n@@ -34,7 +34,7 @@ LL | impl<B> Add for A<B> where B: Add + Add<Output = B> {\n    |                                   +++++++++++++++++\n \n error[E0308]: mismatched types\n-  --> $DIR/missing-bounds.rs:21:14\n+  --> $DIR/missing-bounds.rs:19:14\n    |\n LL | impl<B: Add> Add for C<B> {\n    |      - this type parameter\n@@ -47,7 +47,7 @@ LL |         Self(self.0 + rhs.0)\n    = note: expected type parameter `B`\n              found associated type `<B as Add>::Output`\n note: tuple struct defined here\n-  --> $DIR/missing-bounds.rs:15:8\n+  --> $DIR/missing-bounds.rs:13:8\n    |\n LL | struct C<B>(B);\n    |        ^\n@@ -57,7 +57,7 @@ LL | impl<B: Add + Add<Output = B>> Add for C<B> {\n    |             +++++++++++++++++\n \n error[E0369]: cannot add `B` to `B`\n-  --> $DIR/missing-bounds.rs:31:21\n+  --> $DIR/missing-bounds.rs:29:21\n    |\n LL |         Self(self.0 + rhs.0)\n    |              ------ ^ ----- B\n@@ -66,11 +66,11 @@ LL |         Self(self.0 + rhs.0)\n    |\n help: consider restricting type parameter `B`\n    |\n-LL | impl<B: std::ops::Add<Output = B>> Add for D<B> {\n-   |       +++++++++++++++++++++++++++\n+LL | impl<B: std::ops::Add> Add for D<B> {\n+   |       +++++++++++++++\n \n error[E0308]: mismatched types\n-  --> $DIR/missing-bounds.rs:42:14\n+  --> $DIR/missing-bounds.rs:40:14\n    |\n LL | impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n    |      - this type parameter\n@@ -83,7 +83,7 @@ LL |         Self(self.0 + rhs.0)\n    = note: expected type parameter `B`\n              found associated type `<B as Add>::Output`\n note: tuple struct defined here\n-  --> $DIR/missing-bounds.rs:35:8\n+  --> $DIR/missing-bounds.rs:33:8\n    |\n LL | struct E<B>(B);\n    |        ^"}, {"sha": "07409e9834a4642a903373d3221ac5a89a31736c", "filename": "src/test/ui/issues/issue-35668.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr?ref=d6a57d3730a4e523c433e5528988a2a4f111e94e", "patch": "@@ -6,10 +6,10 @@ LL |     a.iter().map(|a| a*a)\n    |                      |\n    |                      &T\n    |\n-help: consider restricting type parameter `T`\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n    |\n-LL | fn func<'a, T: std::ops::Mul<Output = &T>>(a: &'a [T]) -> impl Iterator<Item=&'a T> {\n-   |              ++++++++++++++++++++++++++++\n+LL | fn func<'a, T>(a: &'a [T]) -> impl Iterator<Item=&'a T> where &T: Mul<&T> {\n+   |                                                         +++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "fe5e2b5816fdfe7ce79a78919610f398e2801a12", "filename": "src/test/ui/suggestions/invalid-bin-op.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr?ref=d6a57d3730a4e523c433e5528988a2a4f111e94e", "patch": "@@ -11,11 +11,14 @@ note: an implementation of `PartialEq<_>` might be missing for `S<T>`\n    |\n LL | struct S<T>(T);\n    | ^^^^^^^^^^^^^^^ must implement `PartialEq<_>`\n-   = note: the trait `std::cmp::PartialEq` is not implemented for `S<T>`\n help: consider annotating `S<T>` with `#[derive(PartialEq)]`\n    |\n LL | #[derive(PartialEq)]\n    |\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+   |\n+LL | pub fn foo<T>(s: S<T>, t: S<T>) where S<T>: PartialEq {\n+   |                                 +++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "3ae6bf130cc7e8b9cb95dad9ca88685183f1a6ba", "filename": "src/test/ui/traits/resolution-in-overloaded-op.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr?ref=d6a57d3730a4e523c433e5528988a2a4f111e94e", "patch": "@@ -6,10 +6,10 @@ LL |     a * b\n    |     |\n    |     &T\n    |\n-help: consider further restricting this bound\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n    |\n-LL | fn foo<T: MyMul<f64, f64> + std::ops::Mul<Output = f64>>(a: &T, b: f64) -> f64 {\n-   |                           +++++++++++++++++++++++++++++\n+LL | fn foo<T: MyMul<f64, f64>>(a: &T, b: f64) -> f64 where &T: Mul<f64> {\n+   |                                                  ++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "2b58cd4180bd337dbe1587faa416e5a971f7601b", "filename": "src/test/ui/type/type-check/missing_trait_impl.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6a57d3730a4e523c433e5528988a2a4f111e94e/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr?ref=d6a57d3730a4e523c433e5528988a2a4f111e94e", "patch": "@@ -8,8 +8,8 @@ LL |     let z = x + y;\n    |\n help: consider restricting type parameter `T`\n    |\n-LL | fn foo<T: std::ops::Add<Output = T>>(x: T, y: T) {\n-   |         +++++++++++++++++++++++++++\n+LL | fn foo<T: std::ops::Add>(x: T, y: T) {\n+   |         +++++++++++++++\n \n error[E0368]: binary assignment operation `+=` cannot be applied to type `T`\n   --> $DIR/missing_trait_impl.rs:9:5\n@@ -32,8 +32,8 @@ LL |     let y = -x;\n    |\n help: consider restricting type parameter `T`\n    |\n-LL | fn baz<T: std::ops::Neg<Output = T>>(x: T) {\n-   |         +++++++++++++++++++++++++++\n+LL | fn baz<T: std::ops::Neg>(x: T) {\n+   |         +++++++++++++++\n \n error[E0600]: cannot apply unary operator `!` to type `T`\n   --> $DIR/missing_trait_impl.rs:14:13\n@@ -43,8 +43,8 @@ LL |     let y = !x;\n    |\n help: consider restricting type parameter `T`\n    |\n-LL | fn baz<T: std::ops::Not<Output = T>>(x: T) {\n-   |         +++++++++++++++++++++++++++\n+LL | fn baz<T: std::ops::Not>(x: T) {\n+   |         +++++++++++++++\n \n error[E0614]: type `T` cannot be dereferenced\n   --> $DIR/missing_trait_impl.rs:15:13"}]}