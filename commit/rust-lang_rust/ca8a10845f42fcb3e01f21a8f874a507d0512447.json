{"sha": "ca8a10845f42fcb3e01f21a8f874a507d0512447", "node_id": "C_kwDOAAsO6NoAKGNhOGExMDg0NWY0MmZjYjNlMDFmMjFhOGY4NzRhNTA3ZDA1MTI0NDc", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-10-04T20:58:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-04T20:58:07Z"}, "message": "Rollup merge of #87091 - the8472:more-advance-by-impls, r=joshtriplett\n\nimplement advance_(back_)_by on more iterators\n\nAdd more efficient, non-default implementations for `feature(iter_advance_by)` (#77404) on more iterators and adapters.\n\nThis PR only contains implementations where skipping over items doesn't elide any observable side-effects such as user-provided closures or `clone()` functions. I'll put those in a separate PR.", "tree": {"sha": "7e9d65d2bdff8cf75d7e8a33d1b16bde113d4404", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e9d65d2bdff8cf75d7e8a33d1b16bde113d4404"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca8a10845f42fcb3e01f21a8f874a507d0512447", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhW2rfCRBK7hj4Ov3rIwAAiagIAD0g2rdJfh/fghvSd0FgZhbM\nsPEXYm35rTeqcShtqUC02PGsF7ns/AySq/idnBmuvhipHYiWlLKhIe6/MYsTERDB\n5tOo7k7NEYXk1zEzWChqp+vU0fZf15IqtRlfY+AnQYGRxqo68DyZfYOP+QKsqxwN\n1zHorvqD1ehs8ayyEynHKr0LCJ8zrdh8hs04c2cwQdW6r8axxtQI5Whz1fVmG2Zn\nwpJeNcppcXmJpyKx2tj8o79lbNCFfj3SrDi3zIsXw9umEjY5OB9P1X4dY86+16Ls\nfSxtSXzwiwW2NsryBeF3rWWPHYJ4gbLzqzst4XICp+jX3XHXNW8VggjuzQh6u8I=\n=C8Je\n-----END PGP SIGNATURE-----\n", "payload": "tree 7e9d65d2bdff8cf75d7e8a33d1b16bde113d4404\nparent 4e9cf04c98dd65a7f4baedc2984fae18d5fecfd1\nparent ffd7ade2035eb92c77421ca7dcde4cf40c863c7b\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1633381087 -0700\ncommitter GitHub <noreply@github.com> 1633381087 -0700\n\nRollup merge of #87091 - the8472:more-advance-by-impls, r=joshtriplett\n\nimplement advance_(back_)_by on more iterators\n\nAdd more efficient, non-default implementations for `feature(iter_advance_by)` (#77404) on more iterators and adapters.\n\nThis PR only contains implementations where skipping over items doesn't elide any observable side-effects such as user-provided closures or `clone()` functions. I'll put those in a separate PR.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca8a10845f42fcb3e01f21a8f874a507d0512447", "html_url": "https://github.com/rust-lang/rust/commit/ca8a10845f42fcb3e01f21a8f874a507d0512447", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca8a10845f42fcb3e01f21a8f874a507d0512447/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e9cf04c98dd65a7f4baedc2984fae18d5fecfd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e9cf04c98dd65a7f4baedc2984fae18d5fecfd1", "html_url": "https://github.com/rust-lang/rust/commit/4e9cf04c98dd65a7f4baedc2984fae18d5fecfd1"}, {"sha": "ffd7ade2035eb92c77421ca7dcde4cf40c863c7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffd7ade2035eb92c77421ca7dcde4cf40c863c7b", "html_url": "https://github.com/rust-lang/rust/commit/ffd7ade2035eb92c77421ca7dcde4cf40c863c7b"}], "stats": {"total": 402, "additions": 399, "deletions": 3}, "files": [{"sha": "ca41ce975e4fe421c042c039e2821039624617a1", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -111,6 +111,7 @@\n // that the feature-gate isn't enabled. Ideally, it wouldn't check for the feature gate for docs\n // from other crates, but since this can only appear for lang items, it doesn't seem worth fixing.\n #![feature(intra_doc_pointers)]\n+#![feature(iter_advance_by)]\n #![feature(iter_zip)]\n #![feature(lang_items)]\n #![feature(layout_for_ptr)]"}, {"sha": "8a2d254a83451a7f554e97b2f2cb647949530512", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -161,6 +161,29 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n         (exact, Some(exact))\n     }\n \n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let step_size = self.len().min(n);\n+        let to_drop = ptr::slice_from_raw_parts_mut(self.ptr as *mut T, step_size);\n+        if mem::size_of::<T>() == 0 {\n+            // SAFETY: due to unchecked casts of unsigned amounts to signed offsets the wraparound\n+            // effectively results in unsigned pointers representing positions 0..usize::MAX,\n+            // which is valid for ZSTs.\n+            self.ptr = unsafe { arith_offset(self.ptr as *const i8, step_size as isize) as *mut T }\n+        } else {\n+            // SAFETY: the min() above ensures that step_size is in bounds\n+            self.ptr = unsafe { self.ptr.add(step_size) };\n+        }\n+        // SAFETY: the min() above ensures that step_size is in bounds\n+        unsafe {\n+            ptr::drop_in_place(to_drop);\n+        }\n+        if step_size < n {\n+            return Err(step_size);\n+        }\n+        Ok(())\n+    }\n+\n     #[inline]\n     fn count(self) -> usize {\n         self.len()\n@@ -203,6 +226,29 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n             Some(unsafe { ptr::read(self.end) })\n         }\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let step_size = self.len().min(n);\n+        if mem::size_of::<T>() == 0 {\n+            // SAFETY: same as for advance_by()\n+            self.end = unsafe {\n+                arith_offset(self.end as *const i8, step_size.wrapping_neg() as isize) as *mut T\n+            }\n+        } else {\n+            // SAFETY: same as for advance_by()\n+            self.end = unsafe { self.end.offset(step_size.wrapping_neg() as isize) };\n+        }\n+        let to_drop = ptr::slice_from_raw_parts_mut(self.end as *mut T, step_size);\n+        // SAFETY: same as for advance_by()\n+        unsafe {\n+            ptr::drop_in_place(to_drop);\n+        }\n+        if step_size < n {\n+            return Err(step_size);\n+        }\n+        Ok(())\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "c6159539b48d0e2d51dae49869c521f413f70a92", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -18,6 +18,7 @@\n #![feature(binary_heap_retain)]\n #![feature(binary_heap_as_slice)]\n #![feature(inplace_iteration)]\n+#![feature(iter_advance_by)]\n #![feature(slice_group_by)]\n #![feature(slice_partition_dedup)]\n #![feature(vec_spare_capacity)]"}, {"sha": "00a878c079480b0e1a50f140d82b7ce9df157ec8", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -970,6 +970,24 @@ fn test_into_iter_leak() {\n     assert_eq!(unsafe { DROPS }, 3);\n }\n \n+#[test]\n+fn test_into_iter_advance_by() {\n+    let mut i = vec![1, 2, 3, 4, 5].into_iter();\n+    i.advance_by(0).unwrap();\n+    i.advance_back_by(0).unwrap();\n+    assert_eq!(i.as_slice(), [1, 2, 3, 4, 5]);\n+\n+    i.advance_by(1).unwrap();\n+    i.advance_back_by(1).unwrap();\n+    assert_eq!(i.as_slice(), [2, 3, 4]);\n+\n+    assert_eq!(i.advance_back_by(usize::MAX), Err(3));\n+\n+    assert_eq!(i.advance_by(usize::MAX), Err(0));\n+\n+    assert_eq!(i.len(), 0);\n+}\n+\n #[test]\n fn test_from_iter_specialization() {\n     let src: Vec<usize> = vec![0usize; 1];"}, {"sha": "e5f2886dcafadad5712125962ca5f9418fce1fa2", "filename": "library/core/src/iter/adapters/copied.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -76,6 +76,11 @@ where\n         self.it.count()\n     }\n \n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.it.advance_by(n)\n+    }\n+\n     #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n     where\n@@ -112,6 +117,11 @@ where\n     {\n         self.it.rfold(init, copy_fold(f))\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.it.advance_back_by(n)\n+    }\n }\n \n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]"}, {"sha": "02b5939072ef07afe06bde0a614c171c70ec6d42", "filename": "library/core/src/iter/adapters/cycle.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -79,6 +79,27 @@ where\n         }\n     }\n \n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let mut rem = n;\n+        match self.iter.advance_by(rem) {\n+            ret @ Ok(_) => return ret,\n+            Err(advanced) => rem -= advanced,\n+        }\n+\n+        while rem > 0 {\n+            self.iter = self.orig.clone();\n+            match self.iter.advance_by(rem) {\n+                ret @ Ok(_) => return ret,\n+                Err(0) => return Err(n - rem),\n+                Err(advanced) => rem -= advanced,\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     // No `fold` override, because `fold` doesn't make much sense for `Cycle`,\n     // and we can't do anything better than the default.\n }"}, {"sha": "c877b45095ace91f4a2ce8d507447f9ba000b55f", "filename": "library/core/src/iter/adapters/enumerate.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -112,6 +112,21 @@ where\n         self.iter.fold(init, enumerate(self.count, fold))\n     }\n \n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        match self.iter.advance_by(n) {\n+            ret @ Ok(_) => {\n+                self.count += n;\n+                ret\n+            }\n+            ret @ Err(advanced) => {\n+                self.count += advanced;\n+                ret\n+            }\n+        }\n+    }\n+\n     #[rustc_inherit_overflow_checks]\n     #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item\n@@ -191,6 +206,13 @@ where\n         let count = self.count + self.iter.len();\n         self.iter.rfold(init, enumerate(count, fold))\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        // we do not need to update the count since that only tallies the number of items\n+        // consumed from the front. consuming items from the back can never reduce that.\n+        self.iter.advance_back_by(n)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "351fd569d8acf98d99d2cfcef4ec2d4c8900ec05", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -391,6 +391,41 @@ where\n \n         init\n     }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let mut rem = n;\n+        loop {\n+            if let Some(ref mut front) = self.frontiter {\n+                match front.advance_by(rem) {\n+                    ret @ Ok(_) => return ret,\n+                    Err(advanced) => rem -= advanced,\n+                }\n+            }\n+            self.frontiter = match self.iter.next() {\n+                Some(iterable) => Some(iterable.into_iter()),\n+                _ => break,\n+            }\n+        }\n+\n+        self.frontiter = None;\n+\n+        if let Some(ref mut back) = self.backiter {\n+            match back.advance_by(rem) {\n+                ret @ Ok(_) => return ret,\n+                Err(advanced) => rem -= advanced,\n+            }\n+        }\n+\n+        if rem > 0 {\n+            return Err(n - rem);\n+        }\n+\n+        self.backiter = None;\n+\n+        Ok(())\n+    }\n }\n \n impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n@@ -486,6 +521,41 @@ where\n \n         init\n     }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let mut rem = n;\n+        loop {\n+            if let Some(ref mut back) = self.backiter {\n+                match back.advance_back_by(rem) {\n+                    ret @ Ok(_) => return ret,\n+                    Err(advanced) => rem -= advanced,\n+                }\n+            }\n+            match self.iter.next_back() {\n+                Some(iterable) => self.backiter = Some(iterable.into_iter()),\n+                _ => break,\n+            }\n+        }\n+\n+        self.backiter = None;\n+\n+        if let Some(ref mut front) = self.frontiter {\n+            match front.advance_back_by(rem) {\n+                ret @ Ok(_) => return ret,\n+                Err(advanced) => rem -= advanced,\n+            }\n+        }\n+\n+        if rem > 0 {\n+            return Err(n - rem);\n+        }\n+\n+        self.frontiter = None;\n+\n+        Ok(())\n+    }\n }\n \n trait ConstSizeIntoIterator: IntoIterator {"}, {"sha": "9b89ca5a9479dfb201e11306ee12374709abfd47", "filename": "library/core/src/iter/adapters/skip.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -114,6 +114,38 @@ where\n         }\n         self.iter.fold(init, fold)\n     }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let mut rem = n;\n+\n+        let step_one = self.n.saturating_add(rem);\n+        match self.iter.advance_by(step_one) {\n+            Ok(_) => {\n+                rem -= step_one - self.n;\n+                self.n = 0;\n+            }\n+            Err(advanced) => {\n+                let advanced_without_skip = advanced.saturating_sub(self.n);\n+                self.n = self.n.saturating_sub(advanced);\n+                return Err(advanced_without_skip);\n+            }\n+        }\n+\n+        // step_one calculation may have saturated\n+        if unlikely(rem > 0) {\n+            return match self.iter.advance_by(rem) {\n+                ret @ Ok(_) => ret,\n+                Err(advanced) => {\n+                    rem -= advanced;\n+                    Err(n - rem)\n+                }\n+            };\n+        }\n+\n+        Ok(())\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -174,6 +206,16 @@ where\n \n         self.try_rfold(init, ok(fold)).unwrap()\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let min = crate::cmp::min(self.len(), n);\n+        return match self.iter.advance_back_by(min) {\n+            ret @ Ok(_) if n <= min => ret,\n+            Ok(_) => Err(min),\n+            _ => panic!(\"ExactSizeIterator contract violation\"),\n+        };\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]"}, {"sha": "d0d0128c82b84cd36b6162a6c9cc8a93b2b4c771", "filename": "library/core/src/iter/adapters/take.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -111,6 +111,22 @@ where\n \n         self.try_fold(init, ok(fold)).unwrap()\n     }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let min = self.n.min(n);\n+        match self.iter.advance_by(min) {\n+            Ok(_) => {\n+                self.n -= min;\n+                if min < n { Err(min) } else { Ok(()) }\n+            }\n+            ret @ Err(advanced) => {\n+                self.n -= advanced;\n+                ret\n+            }\n+        }\n+    }\n }\n \n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n@@ -197,6 +213,24 @@ where\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let inner_len = self.iter.len();\n+        let len = self.n;\n+        let remainder = len.saturating_sub(n);\n+        let to_advance = inner_len - remainder;\n+        match self.iter.advance_back_by(to_advance) {\n+            Ok(_) => {\n+                self.n = remainder;\n+                if n > len {\n+                    return Err(len);\n+                }\n+                return Ok(());\n+            }\n+            _ => panic!(\"ExactSizeIterator contract violation\"),\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "06733a1b50b9198cf88c66ae0fb99e7848229523", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -521,10 +521,12 @@ trait RangeIteratorImpl {\n     // Iterator\n     fn spec_next(&mut self) -> Option<Self::Item>;\n     fn spec_nth(&mut self, n: usize) -> Option<Self::Item>;\n+    fn spec_advance_by(&mut self, n: usize) -> Result<(), usize>;\n \n     // DoubleEndedIterator\n     fn spec_next_back(&mut self) -> Option<Self::Item>;\n     fn spec_nth_back(&mut self, n: usize) -> Option<Self::Item>;\n+    fn spec_advance_back_by(&mut self, n: usize) -> Result<(), usize>;\n }\n \n impl<A: Step> RangeIteratorImpl for ops::Range<A> {\n@@ -555,6 +557,22 @@ impl<A: Step> RangeIteratorImpl for ops::Range<A> {\n         None\n     }\n \n+    #[inline]\n+    default fn spec_advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let available = if self.start <= self.end {\n+            Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)\n+        } else {\n+            0\n+        };\n+\n+        let taken = available.min(n);\n+\n+        self.start =\n+            Step::forward_checked(self.start.clone(), taken).expect(\"`Step` invariants not upheld\");\n+\n+        if taken < n { Err(taken) } else { Ok(()) }\n+    }\n+\n     #[inline]\n     default fn spec_next_back(&mut self) -> Option<A> {\n         if self.start < self.end {\n@@ -579,6 +597,22 @@ impl<A: Step> RangeIteratorImpl for ops::Range<A> {\n         self.end = self.start.clone();\n         None\n     }\n+\n+    #[inline]\n+    default fn spec_advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let available = if self.start <= self.end {\n+            Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)\n+        } else {\n+            0\n+        };\n+\n+        let taken = available.min(n);\n+\n+        self.end =\n+            Step::backward_checked(self.end.clone(), taken).expect(\"`Step` invariants not upheld\");\n+\n+        if taken < n { Err(taken) } else { Ok(()) }\n+    }\n }\n \n impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n@@ -607,6 +641,25 @@ impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n         None\n     }\n \n+    #[inline]\n+    fn spec_advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let available = if self.start <= self.end {\n+            Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)\n+        } else {\n+            0\n+        };\n+\n+        let taken = available.min(n);\n+\n+        // SAFETY: the conditions above ensure that the count is in bounds. If start <= end\n+        // then steps_between either returns a bound to which we clamp or returns None which\n+        // together with the initial inequality implies more than usize::MAX steps.\n+        // Otherwise 0 is returned which always safe to use.\n+        self.start = unsafe { Step::forward_unchecked(self.start.clone(), taken) };\n+\n+        if taken < n { Err(taken) } else { Ok(()) }\n+    }\n+\n     #[inline]\n     fn spec_next_back(&mut self) -> Option<T> {\n         if self.start < self.end {\n@@ -631,6 +684,22 @@ impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n         self.end = self.start.clone();\n         None\n     }\n+\n+    #[inline]\n+    fn spec_advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let available = if self.start <= self.end {\n+            Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)\n+        } else {\n+            0\n+        };\n+\n+        let taken = available.min(n);\n+\n+        // SAFETY: same as the spec_advance_by() implementation\n+        self.end = unsafe { Step::backward_unchecked(self.end.clone(), taken) };\n+\n+        if taken < n { Err(taken) } else { Ok(()) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -677,6 +746,11 @@ impl<A: Step> Iterator for ops::Range<A> {\n         true\n     }\n \n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.spec_advance_by(n)\n+    }\n+\n     #[inline]\n     #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item\n@@ -750,6 +824,11 @@ impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n     fn nth_back(&mut self, n: usize) -> Option<A> {\n         self.spec_nth_back(n)\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.spec_advance_back_by(n)\n+    }\n }\n \n // Safety:"}, {"sha": "9a589c1f3b55c3fac8911291c5b8427a813b4fc1", "filename": "library/core/src/iter/traits/double_ended.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -103,9 +103,15 @@ pub trait DoubleEndedIterator: Iterator {\n     /// elements the iterator is advanced by before running out of elements (i.e. the length\n     /// of the iterator). Note that `k` is always less than `n`.\n     ///\n-    /// Calling `advance_back_by(0)` does not consume any elements and always returns [`Ok(())`].\n+    /// Calling `advance_back_by(0)` can do meaningful work, for example [`Flatten`] can advance its\n+    /// outer iterator until it finds an inner iterator that is not empty, which then often\n+    /// allows it to return a more accurate `size_hint()` than in its initial state.\n+    /// `advance_back_by(0)` may either return `Ok()` or `Err(0)`. The former conveys no information\n+    /// whether the iterator is or is not exhausted, the latter can be treated as if [`next_back`]\n+    /// had returned `None`. Replacing a `Err(0)` with `Ok` is only correct for `n = 0`.\n     ///\n     /// [`advance_by`]: Iterator::advance_by\n+    /// [`Flatten`]: crate::iter::Flatten\n     /// [`next_back`]: DoubleEndedIterator::next_back\n     ///\n     /// # Examples"}, {"sha": "e6b6aec7d943103353f03dd356911b5bda2d85bc", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -246,8 +246,14 @@ pub trait Iterator {\n     /// of elements the iterator is advanced by before running out of elements (i.e. the\n     /// length of the iterator). Note that `k` is always less than `n`.\n     ///\n-    /// Calling `advance_by(0)` does not consume any elements and always returns [`Ok(())`][Ok].\n-    ///\n+    /// Calling `advance_by(0)` can do meaningful work, for example [`Flatten`]\n+    /// can advance its outer iterator until it finds an inner iterator that is not empty, which\n+    /// then often allows it to return a more accurate `size_hint()` than in its initial state.\n+    /// `advance_by(0)` may either return `Ok()` or `Err(0)`. The former conveys no information\n+    /// whether the iterator is or is not exhausted, the latter can be treated as if [`next`]\n+    /// had returned `None`. Replacing a `Err(0)` with `Ok` is only correct for `n = 0`.\n+    ///\n+    /// [`Flatten`]: crate::iter::Flatten\n     /// [`next`]: Iterator::next\n     ///\n     /// # Examples"}, {"sha": "4ae50a2f06681582046d0add9cc74c250e9b6ec1", "filename": "library/core/tests/iter/adapters/flatten.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -58,6 +58,23 @@ fn test_flatten_try_folds() {\n     assert_eq!(iter.next_back(), Some(35));\n }\n \n+#[test]\n+fn test_flatten_advance_by() {\n+    let mut it = once(0..10).chain(once(10..30)).chain(once(30..40)).flatten();\n+    it.advance_by(5).unwrap();\n+    assert_eq!(it.next(), Some(5));\n+    it.advance_by(9).unwrap();\n+    assert_eq!(it.next(), Some(15));\n+    it.advance_back_by(4).unwrap();\n+    assert_eq!(it.next_back(), Some(35));\n+    it.advance_back_by(9).unwrap();\n+    assert_eq!(it.next_back(), Some(25));\n+\n+    assert_eq!(it.advance_by(usize::MAX), Err(9));\n+    assert_eq!(it.advance_back_by(usize::MAX), Err(0));\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+}\n+\n #[test]\n fn test_flatten_non_fused_outer() {\n     let mut iter = NonFused::new(once(0..2)).flatten();"}, {"sha": "6b4cf33efe1ff4574e6c9a3d376d3594da71caad", "filename": "library/core/tests/iter/range.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Ftests%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8a10845f42fcb3e01f21a8f874a507d0512447/library%2Fcore%2Ftests%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Frange.rs?ref=ca8a10845f42fcb3e01f21a8f874a507d0512447", "patch": "@@ -285,6 +285,29 @@ fn test_range_step() {\n     assert_eq!((isize::MIN..isize::MAX).step_by(1).size_hint(), (usize::MAX, Some(usize::MAX)));\n }\n \n+#[test]\n+fn test_range_advance_by() {\n+    let mut r = 0..usize::MAX;\n+    r.advance_by(0).unwrap();\n+    r.advance_back_by(0).unwrap();\n+\n+    assert_eq!(r.len(), usize::MAX);\n+\n+    r.advance_by(1).unwrap();\n+    r.advance_back_by(1).unwrap();\n+\n+    assert_eq!((r.start, r.end), (1, usize::MAX - 1));\n+\n+    assert_eq!(r.advance_by(usize::MAX), Err(usize::MAX - 2));\n+\n+    let mut r = 0u128..u128::MAX;\n+\n+    r.advance_by(usize::MAX).unwrap();\n+    r.advance_back_by(usize::MAX).unwrap();\n+\n+    assert_eq!((r.start, r.end), (0u128 + usize::MAX as u128, u128::MAX - usize::MAX as u128));\n+}\n+\n #[test]\n fn test_range_inclusive_step() {\n     assert_eq!((0..=50).step_by(10).collect::<Vec<_>>(), [0, 10, 20, 30, 40, 50]);"}]}