{"sha": "e98897e5dc9898707bf4331c43b2e76ab7e282fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5ODg5N2U1ZGM5ODk4NzA3YmY0MzMxYzQzYjJlNzZhYjdlMjgyZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-29T15:52:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-29T15:52:21Z"}, "message": "Auto merge of #86475 - crlf0710:miri_vtable_refactor, r=bjorn3\n\nChange vtable memory representation to use tcx allocated allocations.\n\nThis fixes https://github.com/rust-lang/rust/issues/86324. However i suspect there's more to change before it can land.\n\nr? `@bjorn3`\ncc `@rust-lang/miri`", "tree": {"sha": "b676c09db0f7bbb80996a1e354dc58cc4ec010d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b676c09db0f7bbb80996a1e354dc58cc4ec010d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e98897e5dc9898707bf4331c43b2e76ab7e282fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e98897e5dc9898707bf4331c43b2e76ab7e282fe", "html_url": "https://github.com/rust-lang/rust/commit/e98897e5dc9898707bf4331c43b2e76ab7e282fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e98897e5dc9898707bf4331c43b2e76ab7e282fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8971fff984e7a45ca6cdcd146816b4896a4ab1ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/8971fff984e7a45ca6cdcd146816b4896a4ab1ea", "html_url": "https://github.com/rust-lang/rust/commit/8971fff984e7a45ca6cdcd146816b4896a4ab1ea"}, {"sha": "97772bb1f230f4981c9af6614df1ebc09b12c4f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/97772bb1f230f4981c9af6614df1ebc09b12c4f6", "html_url": "https://github.com/rust-lang/rust/commit/97772bb1f230f4981c9af6614df1ebc09b12c4f6"}], "stats": {"total": 399, "additions": 150, "deletions": 249}, "files": [{"sha": "a8a0bb52a246e728041afe7ba14593b76db0cafb", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -233,7 +233,7 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n     pub(crate) module: &'m mut dyn Module,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) pointer_type: Type, // Cached from module\n-    pub(crate) vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), DataId>,\n+    pub(crate) vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), Pointer>,\n     pub(crate) constants_cx: ConstantCx,\n \n     pub(crate) instance: Instance<'tcx>,"}, {"sha": "a87b3703949f9aebc5ec69e6e3a2bbb4cfd9b3fe", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -249,7 +249,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n     }\n }\n \n-fn pointer_for_allocation<'tcx>(\n+pub(crate) fn pointer_for_allocation<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     alloc: &'tcx Allocation,\n ) -> crate::pointer::Pointer {"}, {"sha": "b817bf4aff7718c89e424c14c6039457287ff251", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -98,7 +98,7 @@ mod prelude {\n     pub(crate) use cranelift_codegen::isa::{self, CallConv};\n     pub(crate) use cranelift_codegen::Context;\n     pub(crate) use cranelift_frontend::{FunctionBuilder, FunctionBuilderContext, Variable};\n-    pub(crate) use cranelift_module::{self, DataContext, DataId, FuncId, Linkage, Module};\n+    pub(crate) use cranelift_module::{self, DataContext, FuncId, Linkage, Module};\n \n     pub(crate) use crate::abi::*;\n     pub(crate) use crate::base::{codegen_operand, codegen_place};"}, {"sha": "b9d379c6117c91d846e3620649c2e40f951daf9f", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -31,9 +31,7 @@ pub(crate) fn unsized_info<'tcx>(\n             // change to the vtable.\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n-        (_, &ty::Dynamic(ref data, ..)) => {\n-            crate::vtable::get_vtable(fx, fx.layout_of(source), data.principal())\n-        }\n+        (_, &ty::Dynamic(ref data, ..)) => crate::vtable::get_vtable(fx, source, data.principal()),\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }"}, {"sha": "12f7092d935a33732d858ddad42e2eff87f93b66", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 10, "deletions": 96, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -4,7 +4,7 @@\n // FIXME dedup this logic between miri, cg_llvm and cg_clif\n \n use crate::prelude::*;\n-use ty::VtblEntry;\n+use super::constant::pointer_for_allocation;\n \n fn vtable_memflags() -> MemFlags {\n     let mut flags = MemFlags::trusted(); // A vtable access is always aligned and will never trap.\n@@ -66,105 +66,19 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n \n pub(crate) fn get_vtable<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    layout: TyAndLayout<'tcx>,\n+    ty: Ty<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Value {\n-    let data_id = if let Some(data_id) = fx.vtables.get(&(layout.ty, trait_ref)) {\n-        *data_id\n+    let vtable_ptr = if let Some(vtable_ptr) = fx.vtables.get(&(ty, trait_ref)) {\n+        *vtable_ptr\n     } else {\n-        let data_id = build_vtable(fx, layout, trait_ref);\n-        fx.vtables.insert((layout.ty, trait_ref), data_id);\n-        data_id\n-    };\n-\n-    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n-}\n-\n-fn build_vtable<'tcx>(\n-    fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    layout: TyAndLayout<'tcx>,\n-    trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n-) -> DataId {\n-    let tcx = fx.tcx;\n-    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n+        let vtable_alloc_id = fx.tcx.vtable_allocation(ty, trait_ref);\n+        let vtable_allocation = fx.tcx.global_alloc(vtable_alloc_id).unwrap_memory();\n+        let vtable_ptr = pointer_for_allocation(fx, vtable_allocation);\n \n-    let drop_in_place_fn = import_function(\n-        tcx,\n-        fx.module,\n-        Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n-    );\n-\n-    let vtable_entries = if let Some(trait_ref) = trait_ref {\n-        tcx.vtable_entries(trait_ref.with_self_ty(tcx, layout.ty))\n-    } else {\n-        ty::COMMON_VTABLE_ENTRIES\n+        fx.vtables.insert((ty, trait_ref), vtable_ptr);\n+        vtable_ptr\n     };\n \n-    let mut data_ctx = DataContext::new();\n-    let mut data = ::std::iter::repeat(0u8)\n-        .take(vtable_entries.len() * usize_size)\n-        .collect::<Vec<u8>>()\n-        .into_boxed_slice();\n-\n-    for (idx, entry) in vtable_entries.iter().enumerate() {\n-        match entry {\n-            VtblEntry::MetadataSize => {\n-                write_usize(fx.tcx, &mut data, idx, layout.size.bytes());\n-            }\n-            VtblEntry::MetadataAlign => {\n-                write_usize(fx.tcx, &mut data, idx, layout.align.abi.bytes());\n-            }\n-            VtblEntry::MetadataDropInPlace | VtblEntry::Vacant | VtblEntry::Method(_, _) => {}\n-        }\n-    }\n-    data_ctx.define(data);\n-\n-    for (idx, entry) in vtable_entries.iter().enumerate() {\n-        match entry {\n-            VtblEntry::MetadataDropInPlace => {\n-                let func_ref = fx.module.declare_func_in_data(drop_in_place_fn, &mut data_ctx);\n-                data_ctx.write_function_addr((idx * usize_size) as u32, func_ref);\n-            }\n-            VtblEntry::Method(def_id, substs) => {\n-                let func_id = import_function(\n-                    tcx,\n-                    fx.module,\n-                    Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), *def_id, substs)\n-                        .unwrap()\n-                        .polymorphize(fx.tcx),\n-                );\n-                let func_ref = fx.module.declare_func_in_data(func_id, &mut data_ctx);\n-                data_ctx.write_function_addr((idx * usize_size) as u32, func_ref);\n-            }\n-            VtblEntry::MetadataSize | VtblEntry::MetadataAlign | VtblEntry::Vacant => {}\n-        }\n-    }\n-\n-    data_ctx.set_align(fx.tcx.data_layout.pointer_align.pref.bytes());\n-\n-    let data_id = fx.module.declare_anonymous_data(false, false).unwrap();\n-\n-    fx.module.define_data(data_id, &data_ctx).unwrap();\n-\n-    data_id\n-}\n-\n-fn write_usize(tcx: TyCtxt<'_>, buf: &mut [u8], idx: usize, num: u64) {\n-    let pointer_size =\n-        tcx.layout_of(ParamEnv::reveal_all().and(tcx.types.usize)).unwrap().size.bytes() as usize;\n-    let target = &mut buf[idx * pointer_size..(idx + 1) * pointer_size];\n-\n-    match tcx.data_layout.endian {\n-        rustc_target::abi::Endian::Little => match pointer_size {\n-            4 => target.copy_from_slice(&(num as u32).to_le_bytes()),\n-            8 => target.copy_from_slice(&(num as u64).to_le_bytes()),\n-            _ => todo!(\"pointer size {} is not yet supported\", pointer_size),\n-        },\n-        rustc_target::abi::Endian::Big => match pointer_size {\n-            4 => target.copy_from_slice(&(num as u32).to_be_bytes()),\n-            8 => target.copy_from_slice(&(num as u64).to_be_bytes()),\n-            _ => todo!(\"pointer size {} is not yet supported\", pointer_size),\n-        },\n-    }\n+    vtable_ptr.get_addr(fx)\n }"}, {"sha": "df5ad8ecc271dc01fd49198ac882fc98427249c5", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -282,6 +282,10 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n+    fn const_data_from_alloc(&self, alloc: &Allocation) -> Self::Value {\n+        const_alloc_to_llvm(self, alloc)\n+    }\n+\n     fn from_const_alloc(\n         &self,\n         layout: TyAndLayout<'tcx>,"}, {"sha": "63245a94c8e3d8fb9388d85e948e8347c53865a5", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 4, "deletions": 39, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -1,6 +1,6 @@\n use crate::traits::*;\n \n-use rustc_middle::ty::{self, Instance, Ty, VtblEntry, COMMON_VTABLE_ENTRIES};\n+use rustc_middle::ty::{self, Ty};\n use rustc_target::abi::call::FnAbi;\n \n #[derive(Copy, Clone, Debug)]\n@@ -70,48 +70,13 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n         return val;\n     }\n \n-    // Not in the cache; build it.\n-    let nullptr = cx.const_null(cx.type_i8p_ext(cx.data_layout().instruction_address_space));\n-\n-    let vtable_entries = if let Some(trait_ref) = trait_ref {\n-        tcx.vtable_entries(trait_ref.with_self_ty(tcx, ty))\n-    } else {\n-        COMMON_VTABLE_ENTRIES\n-    };\n-\n-    let layout = cx.layout_of(ty);\n-    // /////////////////////////////////////////////////////////////////////////////////////////////\n-    // If you touch this code, be sure to also make the corresponding changes to\n-    // `get_vtable` in `rust_mir/interpret/traits.rs`.\n-    // /////////////////////////////////////////////////////////////////////////////////////////////\n-    let components: Vec<_> = vtable_entries\n-        .iter()\n-        .map(|entry| match entry {\n-            VtblEntry::MetadataDropInPlace => {\n-                cx.get_fn_addr(Instance::resolve_drop_in_place(cx.tcx(), ty))\n-            }\n-            VtblEntry::MetadataSize => cx.const_usize(layout.size.bytes()),\n-            VtblEntry::MetadataAlign => cx.const_usize(layout.align.abi.bytes()),\n-            VtblEntry::Vacant => nullptr,\n-            VtblEntry::Method(def_id, substs) => cx.get_fn_addr(\n-                ty::Instance::resolve_for_vtable(\n-                    cx.tcx(),\n-                    ty::ParamEnv::reveal_all(),\n-                    *def_id,\n-                    substs,\n-                )\n-                .unwrap()\n-                .polymorphize(cx.tcx()),\n-            ),\n-        })\n-        .collect();\n-\n-    let vtable_const = cx.const_struct(&components, false);\n+    let vtable_alloc_id = tcx.vtable_allocation(ty, trait_ref);\n+    let vtable_allocation = tcx.global_alloc(vtable_alloc_id).unwrap_memory();\n+    let vtable_const = cx.const_data_from_alloc(vtable_allocation);\n     let align = cx.data_layout().pointer_align.abi;\n     let vtable = cx.static_addr_of(vtable_const, align, Some(\"vtable\"));\n \n     cx.create_vtable_metadata(ty, vtable);\n-\n     cx.vtables().borrow_mut().insert((ty, trait_ref), vtable);\n     vtable\n }"}, {"sha": "20f6618712327870212d734e8ca15062b03aacbf", "filename": "compiler/rustc_codegen_ssa/src/traits/consts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -26,6 +26,8 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn const_to_opt_uint(&self, v: Self::Value) -> Option<u64>;\n     fn const_to_opt_u128(&self, v: Self::Value, sign_ext: bool) -> Option<u128>;\n \n+    fn const_data_from_alloc(&self, alloc: &Allocation) -> Self::Value;\n+\n     fn scalar_to_backend(&self, cv: Scalar, layout: &abi::Scalar, llty: Self::Type) -> Self::Value;\n     fn from_const_alloc(\n         &self,"}, {"sha": "16d2ac262d00425264ebe3c598f53ae434c670c8", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -11,7 +11,7 @@ use crate::middle;\n use crate::middle::cstore::{CrateStoreDyn, EncodedMetadata};\n use crate::middle::resolve_lifetime::{self, LifetimeScopeForPath, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::interpret::{self, Allocation, ConstValue, Scalar};\n+use crate::mir::interpret::{self, AllocId, Allocation, ConstValue, Scalar};\n use crate::mir::{Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::thir::Thir;\n use crate::traits;\n@@ -1044,6 +1044,9 @@ pub struct GlobalCtxt<'tcx> {\n     output_filenames: Arc<OutputFilenames>,\n \n     pub main_def: Option<MainDefinition>,\n+\n+    pub(super) vtables_cache:\n+        Lock<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), AllocId>>,\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -1201,6 +1204,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n             output_filenames: Arc::new(output_filenames),\n             main_def: resolutions.main_def,\n+            vtables_cache: Default::default(),\n         }\n     }\n "}, {"sha": "859a940a62526f6a0c63c3873f688a869fc4bd4e", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -18,6 +18,7 @@ pub use adt::*;\n pub use assoc::*;\n pub use closure::*;\n pub use generics::*;\n+pub use vtable::*;\n \n use crate::hir::exports::ExportMap;\n use crate::ich::StableHashingContext;\n@@ -94,6 +95,7 @@ pub mod relate;\n pub mod subst;\n pub mod trait_def;\n pub mod util;\n+pub mod vtable;\n pub mod walk;\n \n mod adt;\n@@ -2009,19 +2011,3 @@ impl<'tcx> fmt::Debug for SymbolName<'tcx> {\n         fmt::Display::fmt(&self.name, fmt)\n     }\n }\n-\n-#[derive(Clone, Copy, Debug, PartialEq, HashStable)]\n-pub enum VtblEntry<'tcx> {\n-    MetadataDropInPlace,\n-    MetadataSize,\n-    MetadataAlign,\n-    Vacant,\n-    Method(DefId, SubstsRef<'tcx>),\n-}\n-\n-pub const COMMON_VTABLE_ENTRIES: &[VtblEntry<'_>] =\n-    &[VtblEntry::MetadataDropInPlace, VtblEntry::MetadataSize, VtblEntry::MetadataAlign];\n-\n-pub const COMMON_VTABLE_ENTRIES_DROPINPLACE: usize = 0;\n-pub const COMMON_VTABLE_ENTRIES_SIZE: usize = 1;\n-pub const COMMON_VTABLE_ENTRIES_ALIGN: usize = 2;"}, {"sha": "3a35d8c88a47890089bd681f5c00a6f151ba8529", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -0,0 +1,106 @@\n+use std::convert::TryFrom;\n+\n+use crate::mir::interpret::{alloc_range, AllocId, Allocation, Pointer, Scalar};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::{self, DefId, SubstsRef, Ty, TyCtxt};\n+use rustc_ast::Mutability;\n+\n+#[derive(Clone, Copy, Debug, PartialEq, HashStable)]\n+pub enum VtblEntry<'tcx> {\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Vacant,\n+    Method(DefId, SubstsRef<'tcx>),\n+}\n+\n+pub const COMMON_VTABLE_ENTRIES: &[VtblEntry<'_>] =\n+    &[VtblEntry::MetadataDropInPlace, VtblEntry::MetadataSize, VtblEntry::MetadataAlign];\n+\n+pub const COMMON_VTABLE_ENTRIES_DROPINPLACE: usize = 0;\n+pub const COMMON_VTABLE_ENTRIES_SIZE: usize = 1;\n+pub const COMMON_VTABLE_ENTRIES_ALIGN: usize = 2;\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    /// Retrieves an allocation that represents the contents of a vtable.\n+    /// There's a cache within `TyCtxt` so it will be deduplicated.\n+    pub fn vtable_allocation(\n+        self,\n+        ty: Ty<'tcx>,\n+        poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n+    ) -> AllocId {\n+        let tcx = self;\n+        let vtables_cache = tcx.vtables_cache.lock();\n+        if let Some(alloc_id) = vtables_cache.get(&(ty, poly_trait_ref)).cloned() {\n+            return alloc_id;\n+        }\n+        drop(vtables_cache);\n+\n+        // See https://github.com/rust-lang/rust/pull/86475#discussion_r655162674\n+        assert!(\n+            !ty.needs_subst() && !poly_trait_ref.map_or(false, |trait_ref| trait_ref.needs_subst())\n+        );\n+        let param_env = ty::ParamEnv::reveal_all();\n+        let vtable_entries = if let Some(poly_trait_ref) = poly_trait_ref {\n+            let trait_ref = poly_trait_ref.with_self_ty(tcx, ty);\n+            let trait_ref = tcx.erase_regions(trait_ref);\n+\n+            tcx.vtable_entries(trait_ref)\n+        } else {\n+            COMMON_VTABLE_ENTRIES\n+        };\n+\n+        let layout =\n+            tcx.layout_of(param_env.and(ty)).expect(\"failed to build vtable representation\");\n+        assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");\n+        let size = layout.size.bytes();\n+        let align = layout.align.abi.bytes();\n+\n+        let ptr_size = tcx.data_layout.pointer_size;\n+        let ptr_align = tcx.data_layout.pointer_align.abi;\n+\n+        let vtable_size = ptr_size * u64::try_from(vtable_entries.len()).unwrap();\n+        let mut vtable = Allocation::uninit(vtable_size, ptr_align);\n+\n+        // No need to do any alignment checks on the memory accesses below, because we know the\n+        // allocation is correctly aligned as we created it above. Also we're only offsetting by\n+        // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n+\n+        for (idx, entry) in vtable_entries.iter().enumerate() {\n+            let idx: u64 = u64::try_from(idx).unwrap();\n+            let scalar = match entry {\n+                VtblEntry::MetadataDropInPlace => {\n+                    let instance = ty::Instance::resolve_drop_in_place(tcx, ty);\n+                    let fn_alloc_id = tcx.create_fn_alloc(instance);\n+                    let fn_ptr = Pointer::from(fn_alloc_id);\n+                    fn_ptr.into()\n+                }\n+                VtblEntry::MetadataSize => Scalar::from_uint(size, ptr_size).into(),\n+                VtblEntry::MetadataAlign => Scalar::from_uint(align, ptr_size).into(),\n+                VtblEntry::Vacant => continue,\n+                VtblEntry::Method(def_id, substs) => {\n+                    // See https://github.com/rust-lang/rust/pull/86475#discussion_r655162674\n+                    assert!(!substs.needs_subst());\n+\n+                    // Prepare the fn ptr we write into the vtable.\n+                    let instance =\n+                        ty::Instance::resolve_for_vtable(tcx, param_env, *def_id, substs)\n+                            .expect(\"resolution failed during building vtable representation\")\n+                            .polymorphize(tcx);\n+                    let fn_alloc_id = tcx.create_fn_alloc(instance);\n+                    let fn_ptr = Pointer::from(fn_alloc_id);\n+                    fn_ptr.into()\n+                }\n+            };\n+            vtable\n+                .write_scalar(&tcx, alloc_range(ptr_size * idx, ptr_size), scalar)\n+                .expect(\"failed to build vtable representation\");\n+        }\n+\n+        vtable.mutability = Mutability::Not;\n+        let alloc_id = tcx.create_memory_alloc(tcx.intern_const_alloc(vtable));\n+        let mut vtables_cache = self.vtables_cache.lock();\n+        vtables_cache.insert((ty, poly_trait_ref), alloc_id);\n+        alloc_id\n+    }\n+}"}, {"sha": "801e4b1e47850c5f99e9f0c09645eb8c8daba9f3", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -2,7 +2,6 @@ use std::cell::Cell;\n use std::fmt;\n use std::mem;\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::{self as hir, def_id::DefId, definitions::DefPathData};\n use rustc_index::vec::IndexVec;\n@@ -40,10 +39,6 @@ pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n \n     /// The virtual memory system.\n     pub memory: Memory<'mir, 'tcx, M>,\n-\n-    /// A cache for deduplicating vtables\n-    pub(super) vtables:\n-        FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), Pointer<M::PointerTag>>,\n }\n \n // The Phantomdata exists to prevent this type from being `Send`. If it were sent across a thread\n@@ -393,7 +388,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             tcx: tcx.at(root_span),\n             param_env,\n             memory: Memory::new(tcx, memory_extra),\n-            vtables: FxHashMap::default(),\n         }\n     }\n "}, {"sha": "d5fec457fa19eb3d067f6247c4236d06991dcd7d", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -107,7 +107,6 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n     match kind {\n         MemoryKind::Stack\n         | MemoryKind::Machine(const_eval::MemoryKind::Heap)\n-        | MemoryKind::Vtable\n         | MemoryKind::CallerLocation => {}\n     }\n     // Set allocation mutability as appropriate. This is used by LLVM to put things into"}, {"sha": "94506808a68c3fffd64c2222028a32160947b36b", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -27,8 +27,6 @@ use crate::util::pretty;\n pub enum MemoryKind<T> {\n     /// Stack memory. Error if deallocated except during a stack pop.\n     Stack,\n-    /// Memory backing vtables. Error if ever deallocated.\n-    Vtable,\n     /// Memory allocated by `caller_location` intrinsic. Error if ever deallocated.\n     CallerLocation,\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones.\n@@ -40,7 +38,6 @@ impl<T: MayLeak> MayLeak for MemoryKind<T> {\n     fn may_leak(self) -> bool {\n         match self {\n             MemoryKind::Stack => false,\n-            MemoryKind::Vtable => true,\n             MemoryKind::CallerLocation => true,\n             MemoryKind::Machine(k) => k.may_leak(),\n         }\n@@ -51,7 +48,6 @@ impl<T: fmt::Display> fmt::Display for MemoryKind<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             MemoryKind::Stack => write!(f, \"stack variable\"),\n-            MemoryKind::Vtable => write!(f, \"vtable\"),\n             MemoryKind::CallerLocation => write!(f, \"caller location\"),\n             MemoryKind::Machine(m) => write!(f, \"{}\", m),\n         }"}, {"sha": "aea9933b337c995398f15f243a0ebd1673a19919", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -459,7 +459,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 // Find and consult vtable\n                 let vtable = receiver_place.vtable();\n-                let drop_fn = self.get_vtable_slot(vtable, u64::try_from(idx).unwrap())?;\n+                let fn_val = self.get_vtable_slot(vtable, u64::try_from(idx).unwrap())?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n                 // want for args[0]: We have to project to field 0 because we want\n@@ -472,7 +472,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     OpTy::from(ImmTy::from_immediate(receiver_place.ptr.into(), this_receiver_ptr));\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(drop_fn, caller_abi, &args, ret, unwind)\n+                self.eval_fn_call(fn_val, caller_abi, &args, ret, unwind)\n             }\n         }\n     }"}, {"sha": "5332e615bc8eacaec143f53c02343b4f79bb1fe9", "filename": "compiler/rustc_mir/src/interpret/traits.rs", "status": "modified", "additions": 6, "deletions": 73, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -2,13 +2,13 @@ use std::convert::TryFrom;\n \n use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n use rustc_middle::ty::{\n-    self, Instance, Ty, VtblEntry, COMMON_VTABLE_ENTRIES, COMMON_VTABLE_ENTRIES_ALIGN,\n+    self, Ty, COMMON_VTABLE_ENTRIES, COMMON_VTABLE_ENTRIES_ALIGN,\n     COMMON_VTABLE_ENTRIES_DROPINPLACE, COMMON_VTABLE_ENTRIES_SIZE,\n };\n-use rustc_target::abi::{Align, LayoutOf, Size};\n+use rustc_target::abi::{Align, Size};\n \n use super::util::ensure_monomorphic_enough;\n-use super::{FnVal, InterpCx, Machine, MemoryKind};\n+use super::{FnVal, InterpCx, Machine};\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n@@ -30,78 +30,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ensure_monomorphic_enough(*self.tcx, ty)?;\n         ensure_monomorphic_enough(*self.tcx, poly_trait_ref)?;\n \n-        if let Some(&vtable) = self.vtables.get(&(ty, poly_trait_ref)) {\n-            // This means we guarantee that there are no duplicate vtables, we will\n-            // always use the same vtable for the same (Type, Trait) combination.\n-            // That's not what happens in rustc, but emulating per-crate deduplication\n-            // does not sound like it actually makes anything any better.\n-            return Ok(vtable);\n-        }\n-\n-        let vtable_entries = if let Some(poly_trait_ref) = poly_trait_ref {\n-            let trait_ref = poly_trait_ref.with_self_ty(*self.tcx, ty);\n-            let trait_ref = self.tcx.erase_regions(trait_ref);\n-\n-            self.tcx.vtable_entries(trait_ref)\n-        } else {\n-            COMMON_VTABLE_ENTRIES\n-        };\n-\n-        let layout = self.layout_of(ty)?;\n-        assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");\n-        let size = layout.size.bytes();\n-        let align = layout.align.abi.bytes();\n-\n-        let tcx = *self.tcx;\n-        let ptr_size = self.pointer_size();\n-        let ptr_align = tcx.data_layout.pointer_align.abi;\n-        // /////////////////////////////////////////////////////////////////////////////////////////\n-        // If you touch this code, be sure to also make the corresponding changes to\n-        // `get_vtable` in `rust_codegen_llvm/meth.rs`.\n-        // /////////////////////////////////////////////////////////////////////////////////////////\n-        let vtable_size = ptr_size * u64::try_from(vtable_entries.len()).unwrap();\n-        let vtable = self.memory.allocate(vtable_size, ptr_align, MemoryKind::Vtable);\n-\n-        let drop = Instance::resolve_drop_in_place(tcx, ty);\n-        let drop = self.memory.create_fn_alloc(FnVal::Instance(drop));\n-\n-        // No need to do any alignment checks on the memory accesses below, because we know the\n-        // allocation is correctly aligned as we created it above. Also we're only offsetting by\n-        // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n-        let scalars = vtable_entries\n-            .iter()\n-            .map(|entry| -> InterpResult<'tcx, _> {\n-                match entry {\n-                    VtblEntry::MetadataDropInPlace => Ok(Some(drop.into())),\n-                    VtblEntry::MetadataSize => Ok(Some(Scalar::from_uint(size, ptr_size).into())),\n-                    VtblEntry::MetadataAlign => Ok(Some(Scalar::from_uint(align, ptr_size).into())),\n-                    VtblEntry::Vacant => Ok(None),\n-                    VtblEntry::Method(def_id, substs) => {\n-                        // Prepare the fn ptr we write into the vtable.\n-                        let instance =\n-                            ty::Instance::resolve_for_vtable(tcx, self.param_env, *def_id, substs)\n-                                .ok_or_else(|| err_inval!(TooGeneric))?;\n-                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n-                        Ok(Some(fn_ptr.into()))\n-                    }\n-                }\n-            })\n-            .collect::<Result<Vec<_>, _>>()?;\n-        let mut vtable_alloc =\n-            self.memory.get_mut(vtable.into(), vtable_size, ptr_align)?.expect(\"not a ZST\");\n-        for (idx, scalar) in scalars.into_iter().enumerate() {\n-            if let Some(scalar) = scalar {\n-                let idx: u64 = u64::try_from(idx).unwrap();\n-                vtable_alloc.write_ptr_sized(ptr_size * idx, scalar)?;\n-            }\n-        }\n-\n-        M::after_static_mem_initialized(self, vtable, vtable_size)?;\n+        let vtable_allocation = self.tcx.vtable_allocation(ty, poly_trait_ref);\n \n-        self.memory.mark_immutable(vtable.alloc_id)?;\n-        assert!(self.vtables.insert((ty, poly_trait_ref), vtable).is_none());\n+        let vtable_ptr = self.memory.global_base_pointer(Pointer::from(vtable_allocation))?;\n \n-        Ok(vtable)\n+        Ok(vtable_ptr)\n     }\n \n     /// Resolves the function at the specified slot in the provided"}, {"sha": "0818d7fbf88bc6c80412bc7b39cb9fb716b2ecb5", "filename": "src/test/ui/consts/const-eval/ub-upvars.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -10,7 +10,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500alloc2\u2500\u2500\u257c \u257e\u2500alloc3\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc2\u2500\u2500\u257c \u257e\u2500alloc5\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error: aborting due to previous error"}, {"sha": "59dcf7aefe41fd1d7b17b64d876f98434ad5a8e5", "filename": "src/test/ui/consts/const-eval/ub-upvars.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -10,7 +10,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc5\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: aborting due to previous error"}, {"sha": "cab111ab69cdc298c4dc770b35806c818ac7180d", "filename": "src/test/ui/consts/issue-79690.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/src%2Ftest%2Fui%2Fconsts%2Fissue-79690.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/src%2Ftest%2Fui%2Fconsts%2Fissue-79690.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-79690.64bit.stderr?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -6,7 +6,7 @@ LL | const G: Fat = unsafe { Transmute { t: FOO }.u };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc5\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: aborting due to previous error"}, {"sha": "e6db2eef955e028e1cbc811f083a8226a1c3faf6", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.32bit.stderr?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -19,7 +19,7 @@ LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500alloc6\u2500\u2500\u257c \u257e\u2500alloc7\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc6\u2500\u2500\u257c \u257e\u2500alloc8\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value"}, {"sha": "f48978d4af6b0dc53465fbb2acadf56aeac58902", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e98897e5dc9898707bf4331c43b2e76ab7e282fe/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e98897e5dc9898707bf4331c43b2e76ab7e282fe/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.64bit.stderr?ref=e98897e5dc9898707bf4331c43b2e76ab7e282fe", "patch": "@@ -19,7 +19,7 @@ LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc6\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc6\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value"}]}