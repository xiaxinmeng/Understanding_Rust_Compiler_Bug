{"sha": "04497ea7b9b9598faa7456e7de1304e9118d2bb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NDk3ZWE3YjliOTU5OGZhYTc0NTZlN2RlMTMwNGU5MTE4ZDJiYjA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-05T23:55:42Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-05T23:57:13Z"}, "message": "rustc: Implement simple uses of &trait", "tree": {"sha": "9ee04dec89c90fbbba0ef544a24e0f0f887c902c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ee04dec89c90fbbba0ef544a24e0f0f887c902c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04497ea7b9b9598faa7456e7de1304e9118d2bb0", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04497ea7b9b9598faa7456e7de1304e9118d2bb0", "html_url": "https://github.com/rust-lang/rust/commit/04497ea7b9b9598faa7456e7de1304e9118d2bb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04497ea7b9b9598faa7456e7de1304e9118d2bb0/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8bc0d25455d7bfb299cd0e7693ee575f5dbce21", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8bc0d25455d7bfb299cd0e7693ee575f5dbce21", "html_url": "https://github.com/rust-lang/rust/commit/f8bc0d25455d7bfb299cd0e7693ee575f5dbce21"}], "stats": {"total": 270, "additions": 201, "deletions": 69}, "files": [{"sha": "597640ef4109ca209b3bf2c54d9dea0b6c664ef6", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -34,6 +34,7 @@ export metadata_encoding_version;\n export def_to_str;\n export encode_ctxt;\n export write_type;\n+export write_vstore;\n export encode_def_id;\n \n type abbrev_map = map::HashMap<ty::t, tyencode::ty_abbrev>;\n@@ -180,6 +181,16 @@ fn write_type(ecx: @encode_ctxt, ebml_w: ebml::Writer, typ: ty::t) {\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n+fn write_vstore(ecx: @encode_ctxt, ebml_w: ebml::Writer, vstore: ty::vstore) {\n+    let ty_str_ctxt =\n+        @{diag: ecx.diag,\n+          ds: def_to_str,\n+          tcx: ecx.tcx,\n+          reachable: |a| reachable(ecx, a),\n+          abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+    tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n+}\n+\n fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::Writer, typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);"}, {"sha": "611ffb598ae5c5f384ced02414ae24fea1e6be98", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -16,6 +16,7 @@ export enc_ty;\n export enc_bounds;\n export enc_mode;\n export enc_arg;\n+export enc_vstore;\n \n type ctxt = {\n     diag: span_handler,"}, {"sha": "f2ee3df6610631890ecfedc11fa74bb59b46e9d9", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -490,8 +490,8 @@ impl method_origin: tr {\n           typeck::method_param(mp) => {\n             typeck::method_param({trait_id:mp.trait_id.tr(xcx),.. mp})\n           }\n-          typeck::method_trait(did, m) => {\n-            typeck::method_trait(did.tr(xcx), m)\n+          typeck::method_trait(did, m, vstore) => {\n+            typeck::method_trait(did.tr(xcx), m, vstore)\n           }\n         }\n     }\n@@ -631,6 +631,7 @@ impl @e::encode_ctxt: get_ty_str_ctxt {\n trait ebml_writer_helpers {\n     fn emit_arg(ecx: @e::encode_ctxt, arg: ty::arg);\n     fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t);\n+    fn emit_vstore(ecx: @e::encode_ctxt, vstore: ty::vstore);\n     fn emit_tys(ecx: @e::encode_ctxt, tys: ~[ty::t]);\n     fn emit_bounds(ecx: @e::encode_ctxt, bs: ty::param_bounds);\n     fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty);\n@@ -643,6 +644,12 @@ impl ebml::Writer: ebml_writer_helpers {\n         }\n     }\n \n+    fn emit_vstore(ecx: @e::encode_ctxt, vstore: ty::vstore) {\n+        do self.emit_opaque {\n+            e::write_vstore(ecx, self, vstore)\n+        }\n+    }\n+\n     fn emit_arg(ecx: @e::encode_ctxt, arg: ty::arg) {\n         do self.emit_opaque {\n             tyencode::enc_arg(self.writer, ecx.ty_str_ctxt(), arg);"}, {"sha": "f15ace40d3092016e1733284845df9132270c157", "filename": "src/rustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fprivacy.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -81,7 +81,7 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n                 }\n             }\n             method_param({trait_id: trait_id, method_num: method_num, _}) |\n-            method_trait(trait_id, method_num) => {\n+            method_trait(trait_id, method_num, _) => {\n                 if trait_id.crate == local_crate {\n                     match tcx.items.find(trait_id.node) {\n                         Some(node_item(item, _)) => {"}, {"sha": "68e957bfe709974e05faf000a46e6ff29d18fd92", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -963,8 +963,13 @@ fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n     return T_struct(vec::from_elem::<TypeRef>(n, T_ptr(cx.tydesc_type)));\n }\n \n-fn T_opaque_trait(cx: @crate_ctxt) -> TypeRef {\n-    T_struct(~[T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)])\n+fn T_opaque_trait(cx: @crate_ctxt, vstore: ty::vstore) -> TypeRef {\n+    match vstore {\n+        ty::vstore_box =>\n+            T_struct(~[T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)]),\n+        _ =>\n+            T_struct(~[T_ptr(cx.tydesc_type), T_ptr(T_i8())])\n+    }\n }\n \n fn T_opaque_port_ptr() -> TypeRef { return T_ptr(T_i8()); }"}, {"sha": "d60a5a0bd7dfd222132ed562a7dffa229d146251", "filename": "src/rustc/middle/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -477,10 +477,13 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_fn(_) => {\n         closure::make_fn_glue(bcx, v0, t, drop_ty)\n       }\n-      ty::ty_trait(_, _, _) => {\n+      ty::ty_trait(_, _, ty::vstore_box) => {\n         let llbox = Load(bcx, GEPi(bcx, v0, [0u, 1u]));\n         decr_refcnt_maybe_free(bcx, llbox, ty::mk_opaque_box(ccx.tcx))\n       }\n+      ty::ty_trait(_, _, ty::vstore_uniq) => {\n+        ccx.tcx.sess.unimpl(~\"drop of unique trait\");\n+      }\n       ty::ty_opaque_closure_ptr(ck) => {\n         closure::make_opaque_cbox_drop_glue(bcx, ck, v0)\n       }"}, {"sha": "6710a64054db73b9466132172e2cc50aa90fc945", "filename": "src/rustc/middle/trans/meth.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -142,8 +142,8 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n                 None => fail ~\"trans_method_callee: missing param_substs\"\n             }\n         }\n-        typeck::method_trait(_, off) => {\n-            trans_trait_callee(bcx, callee_id, off, self)\n+        typeck::method_trait(_, off, vstore) => {\n+            trans_trait_callee(bcx, callee_id, off, self, vstore)\n         }\n     }\n }\n@@ -288,8 +288,8 @@ fn trans_monomorphized_callee(bcx: block,\n               })\n           }\n       }\n-      typeck::vtable_trait(*) => {\n-          trans_trait_callee(bcx, callee_id, n_method, base)\n+      typeck::vtable_trait(_, _) => {\n+          trans_trait_callee(bcx, callee_id, n_method, base, ty::vstore_box)\n       }\n       typeck::vtable_param(*) => {\n           fail ~\"vtable_param left in monomorphized function's vtable substs\";\n@@ -390,30 +390,32 @@ fn combine_impl_and_methods_origins(bcx: block,\n fn trans_trait_callee(bcx: block,\n                       callee_id: ast::node_id,\n                       n_method: uint,\n-                      self_expr: @ast::expr)\n+                      self_expr: @ast::expr,\n+                      vstore: ty::vstore)\n     -> Callee\n {\n     //!\n     //\n     // Create a method callee where the method is coming from a trait\n     // instance (e.g., @Trait type).  In this case, we must pull the\n     // fn pointer out of the vtable that is packaged up with the\n-    // @Trait instance.  @Traits are represented as a pair, so we first\n-    // evaluate the self expression (expected a by-ref result) and then\n+    // @/~/&Trait instance.  @/~/&Traits are represented as a pair, so we\n+    // first evaluate the self expression (expected a by-ref result) and then\n     // extract the self data and vtable out of the pair.\n \n     let _icx = bcx.insn_ctxt(\"impl::trans_trait_callee\");\n     let mut bcx = bcx;\n     let self_datum = unpack_datum!(bcx, expr::trans_to_datum(bcx, self_expr));\n     let llpair = self_datum.to_ref_llval(bcx);\n     let callee_ty = node_id_type(bcx, callee_id);\n-    trans_trait_callee_from_llval(bcx, callee_ty, n_method, llpair)\n+    trans_trait_callee_from_llval(bcx, callee_ty, n_method, llpair, vstore)\n }\n \n fn trans_trait_callee_from_llval(bcx: block,\n                                  callee_ty: ty::t,\n                                  n_method: uint,\n-                                 llpair: ValueRef)\n+                                 llpair: ValueRef,\n+                                 vstore: ty::vstore)\n     -> Callee\n {\n     //!\n@@ -431,9 +433,21 @@ fn trans_trait_callee_from_llval(bcx: block,\n                                   GEPi(bcx, llpair, [0u, 0u]),\n                                   T_ptr(T_ptr(T_vtable()))));\n \n-    // Load the box from the @Trait pair and GEP over the box header:\n+    // Load the box from the @Trait pair and GEP over the box header if\n+    // necessary:\n+    let llself;\n     let llbox = Load(bcx, GEPi(bcx, llpair, [0u, 1u]));\n-    let llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+    match vstore {\n+        ty::vstore_box | ty::vstore_uniq => {\n+            llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+        }\n+        ty::vstore_slice(_) => {\n+            llself = llbox;\n+        }\n+        ty::vstore_fixed(*) => {\n+            bcx.tcx().sess.bug(~\"vstore_fixed trait\");\n+        }\n+    }\n \n     // Load the function from the vtable and cast it to the expected type.\n     let llcallee_ty = type_of::type_of_fn_from_ty(ccx, callee_ty);\n@@ -503,7 +517,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n     // XXX: This should support multiple traits.\n     let trt_id = driver::session::expect(\n         tcx.sess,\n-        ty::ty_to_def_id(ty::impl_traits(tcx, impl_id)[0]),\n+        ty::ty_to_def_id(ty::impl_traits(tcx, impl_id, ty::vstore_box)[0]),\n         || ~\"make_impl_vtable: non-trait-type implemented\");\n \n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;"}, {"sha": "3996f0ff5ee2ca51ea406df37dbde733ee83f072", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -70,10 +70,12 @@ impl reflector {\n         }\n         let bool_ty = ty::mk_bool(tcx);\n         let scratch = scratch_datum(bcx, bool_ty, false);\n+        // XXX: Should not be vstore_box!\n         let bcx = callee::trans_call_inner(\n             self.bcx, None, mth_ty, bool_ty,\n             |bcx| meth::trans_trait_callee_from_llval(bcx, mth_ty,\n-                                                      mth_idx, v),\n+                                                      mth_idx, v,\n+                                                      ty::vstore_box),\n             ArgVals(args), SaveIn(scratch.val), DontAutorefArg);\n         let result = scratch.to_value_llval(bcx);\n         let next_bcx = sub_block(bcx, ~\"next\");"}, {"sha": "7b5a912ed7f239b199174a0f0dd6babfbdca8f90", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -159,7 +159,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         T_struct(~[T_struct(tys)])\n       }\n       ty::ty_fn(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n-      ty::ty_trait(_, _, _) => T_opaque_trait(cx),\n+      ty::ty_trait(_, _, vstore) => T_opaque_trait(cx, vstore),\n       ty::ty_type => T_ptr(cx.tydesc_type),\n       ty::ty_tup(elts) => {\n         let mut tys = ~[];"}, {"sha": "8bd5bd7afc7883ea62a8f8ad580d7aca36fd1e2d", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -247,7 +247,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n               typeck::method_param({param_num: param, _}) => {\n                 cx.uses[param] |= use_tydesc;\n               }\n-              typeck::method_trait(_, _) => (),\n+              typeck::method_trait(*) => (),\n             }\n         }\n       }"}, {"sha": "78949ec5f794b38a243c4cb0ccac09ad9605fb33", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -90,6 +90,7 @@ export ty_estr, mk_estr, type_is_str;\n export ty_evec, mk_evec, type_is_vec;\n export ty_unboxed_vec, mk_unboxed_vec, mk_mut_unboxed_vec;\n export vstore, vstore_fixed, vstore_uniq, vstore_box, vstore_slice;\n+export serialize_vstore, deserialize_vstore;\n export ty_nil, mk_nil, type_is_nil;\n export ty_trait, mk_trait;\n export ty_param, mk_param, ty_params_to_tys;\n@@ -217,6 +218,7 @@ type method = {ident: ast::ident,\n \n type mt = {ty: t, mutbl: ast::mutability};\n \n+#[auto_serialize]\n enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n@@ -1624,7 +1626,10 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n       ty_evec(_, vstore_uniq) |\n       ty_evec(_, vstore_box) => true,\n \n-      ty_trait(*) => true,\n+      ty_trait(_, _, vstore_box) |\n+      ty_trait(_, _, vstore_uniq) => true,\n+      ty_trait(_, _, vstore_fixed(_)) |\n+      ty_trait(_, _, vstore_slice(_)) => false,\n \n       ty_param(*) | ty_infer(*) => true,\n \n@@ -2821,7 +2826,7 @@ fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n           }\n           typeck::method_param({trait_id:trt_id,\n                                 method_num:n_mth, _}) |\n-          typeck::method_trait(trt_id, n_mth) => {\n+          typeck::method_trait(trt_id, n_mth, _) => {\n             // ...trait methods bounds, in contrast, include only the\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n@@ -3362,7 +3367,15 @@ fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n /*\n   Could this return a list of (def_id, substs) pairs?\n  */\n-fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n+fn impl_traits(cx: ctxt, id: ast::def_id, vstore: vstore) -> ~[t] {\n+    fn vstoreify(cx: ctxt, ty: t, vstore: vstore) -> t {\n+        match ty::get(ty).sty {\n+            ty::ty_trait(_, _, trait_vstore) if vstore == trait_vstore => ty,\n+            ty::ty_trait(did, substs, _) => mk_trait(cx, did, substs, vstore),\n+            _ => cx.sess.bug(~\"impl_traits: not a trait\")\n+        }\n+    }\n+\n     if id.crate == ast::local_crate {\n         debug!(\"(impl_traits) searching for trait impl %?\", id);\n         match cx.items.find(id.node) {\n@@ -3372,19 +3385,23 @@ fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n                     _)) => {\n \n                do option::map_default(&opt_trait, ~[]) |trait_ref| {\n-                       ~[node_id_to_type(cx, trait_ref.ref_id)]\n+                       ~[vstoreify(cx,\n+                                   node_id_to_type(cx, trait_ref.ref_id),\n+                                   vstore)]\n                    }\n            }\n            Some(ast_map::node_item(@{node: ast::item_class(sd,_),\n                            _},_)) => {\n                do vec::map(sd.traits) |trait_ref| {\n-                    node_id_to_type(cx, trait_ref.ref_id)\n+                    vstoreify(cx, node_id_to_type(cx, trait_ref.ref_id),\n+                              vstore)\n                 }\n            }\n            _ => ~[]\n         }\n     } else {\n-        csearch::get_impl_traits(cx, id)\n+        vec::map(csearch::get_impl_traits(cx, id),\n+                 |x| vstoreify(cx, *x, vstore))\n     }\n }\n "}, {"sha": "6c461126853f5fde19547aa8ea15df2a798382e9", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -86,7 +86,7 @@ enum method_origin {\n     method_param(method_param),\n \n     // method invoked on a trait instance\n-    method_trait(ast::def_id, uint),\n+    method_trait(ast::def_id, uint, ty::vstore),\n }\n \n // details for a method invoked with a receiver whose type is a type parameter"}, {"sha": "14797fcdd6bb1c38e8675f3cc09c82a3d0492959", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -189,16 +189,19 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n                                                        type_def_id, path);\n                 match ty::get(result.ty).sty {\n                     ty::ty_trait(trait_def_id, substs, _) => {\n-                        if vst != ty::vstore_box {\n-                            tcx.sess.span_unimpl(path.span,\n-                                                 ~\"`~trait` and `&trait` are \\\n-                                                   unimplemented; use \\\n-                                                   `@trait` instead for now\");\n+                        match vst {\n+                            ty::vstore_box | ty::vstore_slice(*) => {}\n+                            _ => {\n+                                tcx.sess.span_unimpl(path.span,\n+                                                     ~\"`~trait` is \\\n+                                                       unimplemented; use \\\n+                                                       `@trait` instead for \\\n+                                                       now\");\n+                            }\n                         }\n                         return ty::mk_trait(tcx, trait_def_id, substs, vst);\n                     }\n-                    _ =>\n-                        {}\n+                    _ => {}\n                 }\n               }\n               _ => ()"}, {"sha": "d55f9facc62625e26afca34c14b917a8fb78ca9b", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -221,9 +221,9 @@ impl LookupContext {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(p);\n                 }\n-                ty_trait(did, ref substs, _) => {\n+                ty_trait(did, ref substs, vstore) => {\n                     self.push_inherent_candidates_from_trait(\n-                        self_ty, did, substs);\n+                        self_ty, did, substs, vstore);\n                     self.push_inherent_impl_candidates_for_type(did);\n                 }\n                 ty_self => {\n@@ -233,7 +233,8 @@ impl LookupContext {\n                         ~\"unexpected `none` for self_impl_def_id\");\n                     let substs = {self_r: None, self_ty: None, tps: ~[]};\n                     self.push_inherent_candidates_from_trait(\n-                        self_ty, self_did, &substs);\n+                        self_ty, self_did, &substs,\n+                        ty::vstore_slice(ty::re_static));   // XXX: Wrong!\n                 }\n                 ty_enum(did, _) | ty_class(did, _) => {\n                     self.push_inherent_impl_candidates_for_type(did);\n@@ -347,7 +348,8 @@ impl LookupContext {\n     fn push_inherent_candidates_from_trait(&self,\n                                            self_ty: ty::t,\n                                            did: def_id,\n-                                           substs: &ty::substs)\n+                                           substs: &ty::substs,\n+                                           vstore: ty::vstore)\n     {\n         debug!(\"push_inherent_candidates_from_trait(did=%s, substs=%s)\",\n                self.did_to_str(did),\n@@ -391,7 +393,7 @@ impl LookupContext {\n             rcvr_substs: move rcvr_substs,\n             num_method_tps: method.tps.len(),\n             self_mode: get_mode_from_self_type(method.self_ty),\n-            origin: method_trait(did, index)\n+            origin: method_trait(did, index, vstore)\n         });\n     }\n \n@@ -770,7 +772,7 @@ impl LookupContext {\n             method_param(ref mp) => {\n                 type_of_trait_method(self.tcx(), mp.trait_id, mp.method_num)\n             }\n-            method_trait(did, idx) => {\n+            method_trait(did, idx, _) => {\n                 type_of_trait_method(self.tcx(), did, idx)\n             }\n         };\n@@ -791,7 +793,7 @@ impl LookupContext {\n             method_param(mp) => {\n                 self.report_param_candidate(idx, mp.trait_id)\n             }\n-            method_trait(trait_did, _) => {\n+            method_trait(trait_did, _, _) => {\n                 self.report_param_candidate(idx, trait_did)\n             }\n         }"}, {"sha": "0b258da5672dbdfa0df9e2512e42292e930d0529", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -221,11 +221,7 @@ fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n                 result::Err(_) => { return; /*typeck will fail anyhow*/ }\n                 result::Ok(target_ty) => {\n                     match ty::get(target_ty).sty {\n-                        ty::ty_trait(_, substs, _) => {\n-                            let trait_region = match substs.self_r {\n-                                Some(r) => {r}\n-                                None => {ty::re_static}\n-                            };\n+                        ty::ty_trait(_, _, vstore_slice(trait_region)) => {\n                             let source_ty = rcx.fcx.expr_ty(source);\n                             constrain_regions_in_type(rcx, trait_region,\n                                                       expr.span, source_ty);"}, {"sha": "00fb134f2be556b71f8b4f4419b73abac181d24e", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 72, "deletions": 22, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -156,8 +156,8 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n     let _i = indenter();\n \n     let tcx = fcx.ccx.tcx;\n-    let (trait_id, trait_substs) = match ty::get(trait_ty).sty {\n-        ty::ty_trait(did, substs, _) => (did, substs),\n+    let (trait_id, trait_substs, trait_vstore) = match ty::get(trait_ty).sty {\n+        ty::ty_trait(did, substs, vstore) => (did, substs, vstore),\n         _ => tcx.sess.impossible_case(expr.span,\n                                       \"lookup_vtable_invariant: \\\n                                        don't know how to handle a non-trait\")\n@@ -270,7 +270,8 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                         // it's the same trait as trait_ty, we need to\n                         // unify it with trait_ty in order to get all\n                         // the ty vars sorted out.\n-                        for vec::each(ty::impl_traits(tcx, im.did)) |of_ty| {\n+                        for vec::each(ty::impl_traits(tcx, im.did,\n+                                                      trait_vstore)) |of_ty| {\n                             match ty::get(*of_ty).sty {\n                                 ty::ty_trait(id, _, _) => {\n                                     // Not the trait we're looking for\n@@ -378,7 +379,8 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                             // lists of types to unify pairwise.\n \n                             connect_trait_tps(fcx, expr, substs_f.tps,\n-                                              trait_tps, im.did);\n+                                              trait_tps, im.did,\n+                                              trait_vstore);\n                             let subres = lookup_vtables(\n                                 fcx, expr, im_bs, &substs_f,\n                                 false, is_early);\n@@ -436,11 +438,12 @@ fn fixup_ty(fcx: @fn_ctxt,\n }\n \n fn connect_trait_tps(fcx: @fn_ctxt, expr: @ast::expr, impl_tys: ~[ty::t],\n-                     trait_tys: ~[ty::t], impl_did: ast::def_id) {\n+                     trait_tys: ~[ty::t], impl_did: ast::def_id,\n+                     vstore: ty::vstore) {\n     let tcx = fcx.ccx.tcx;\n \n     // XXX: This should work for multiple traits.\n-    let ity = ty::impl_traits(tcx, impl_did)[0];\n+    let ity = ty::impl_traits(tcx, impl_did, vstore)[0];\n     let trait_ty = ty::subst_tps(tcx, impl_tys, ity);\n     debug!(\"(connect trait tps) trait type is %?, impl did is %?\",\n            ty::get(trait_ty).sty, impl_did);\n@@ -508,7 +511,7 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n       ast::expr_cast(src, _) => {\n         let target_ty = fcx.expr_ty(ex);\n         match ty::get(target_ty).sty {\n-          ty::ty_trait(*) => {\n+          ty::ty_trait(_, _, vstore) => {\n             // Look up vtables for the type we're casting to, passing in the\n             // source and target type.\n             //\n@@ -520,26 +523,73 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n             match vtable_opt {\n                 None => {\n                     // Try the new-style boxed trait; \"@int as @Trait\".\n+                    // Or the new-style region trait; \"&int as &Trait\".\n                     let mut err = false;\n                     let ty = structurally_resolved_type(fcx, ex.span, ty);\n                     match ty::get(ty).sty {\n-                        ty::ty_box(boxed_ty) => {\n-                            let vtable_opt =\n-                                lookup_vtable_invariant(fcx, ex, boxed_ty.ty,\n-                                                        target_ty, true,\n-                                                        is_early);\n-                            match vtable_opt {\n-                                Some(vtable) => {\n-                                    /*\n-                                    Map this expression to that vtable (that\n-                                    is: \"ex has vtable <vtable>\")\n-                                    */\n-                                    if !is_early {\n-                                        cx.vtable_map.insert(ex.id,\n-                                                             @~[vtable]);\n+                        ty::ty_box(mt) | ty::ty_rptr(_, mt) => {\n+                            // Ensure that the trait vstore and the pointer\n+                            // type match.\n+                            match (ty::get(ty).sty, vstore) {\n+                                (ty::ty_box(_), ty::vstore_box) |\n+                                (ty::ty_rptr(*), ty::vstore_slice(*)) => {\n+                                    let vtable_opt =\n+                                        lookup_vtable_invariant(fcx,\n+                                                                ex,\n+                                                                mt.ty,\n+                                                                target_ty,\n+                                                                true,\n+                                                                is_early);\n+                                    match vtable_opt {\n+                                        Some(vtable) => {\n+                                            // Map this expression to that\n+                                            // vtable (that is: \"ex has vtable\n+                                            // <vtable>\")\n+                                            if !is_early {\n+                                                cx.vtable_map.insert(\n+                                                    ex.id, @~[vtable]);\n+                                            }\n+                                        }\n+                                        None => err = true\n                                     }\n+\n+                                    // Now, if this is &trait, we need to link\n+                                    // the regions.\n+                                    match (ty::get(ty).sty, vstore) {\n+                                        (ty::ty_rptr(ra, _),\n+                                         ty::vstore_slice(rb)) => {\n+                                            infer::mk_subr(fcx.infcx(),\n+                                                           false,\n+                                                           ex.span,\n+                                                           rb,\n+                                                           ra);\n+                                        }\n+                                        _ => {}\n+                                    }\n+                                }\n+                                (ty::ty_box(_), _) => {\n+                                    fcx.ccx.tcx.sess.span_err(ex.span,\n+                                                              ~\"must cast \\\n+                                                                a boxed \\\n+                                                                pointer to \\\n+                                                                a boxed\n+                                                                trait\");\n+                                    err = true;\n+                                }\n+                                (ty::ty_rptr(*), _) => {\n+                                    fcx.ccx.tcx.sess.span_err(ex.span,\n+                                                              ~\"must cast \\\n+                                                                a borrowed \\\n+                                                                pointer to \\\n+                                                                a borrowed \\\n+                                                                trait\");\n+                                }\n+                                _ => {\n+                                    fcx.ccx.tcx.sess.impossible_case(\n+                                        ex.span,\n+                                        ~\"impossible combination of type and \\\n+                                          trait vstore\");\n                                 }\n-                                None => err = true\n                             }\n                         }\n                         _ => err = true"}, {"sha": "dfcbfc3993f16dbcf8216df174c72f77410994c4", "filename": "src/test/run-pass/trait-region-pointer-simple.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Ftest%2Frun-pass%2Ftrait-region-pointer-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04497ea7b9b9598faa7456e7de1304e9118d2bb0/src%2Ftest%2Frun-pass%2Ftrait-region-pointer-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-region-pointer-simple.rs?ref=04497ea7b9b9598faa7456e7de1304e9118d2bb0", "patch": "@@ -0,0 +1,21 @@\n+trait Foo {\n+    fn f() -> int;\n+}\n+\n+struct A {\n+    x: int\n+}\n+\n+impl A : Foo {\n+    fn f() -> int {\n+        io::println(~\"Today's number is \" + self.x.to_str());\n+        return self.x;\n+    }\n+}\n+\n+fn main() {\n+    let a = A { x: 3 };\n+    let b = (&a) as &Foo;\n+    assert b.f() == 3;\n+}\n+"}]}