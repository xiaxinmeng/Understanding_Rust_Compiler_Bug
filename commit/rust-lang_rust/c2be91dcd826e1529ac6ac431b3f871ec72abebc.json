{"sha": "c2be91dcd826e1529ac6ac431b3f871ec72abebc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYmU5MWRjZDgyNmUxNTI5YWM2YWM0MzFiM2Y4NzFlYzcyYWJlYmM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-05T12:30:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-05T12:30:20Z"}, "message": "Merge #8245\n\n8245: Properly resolve intra doc links in hover and goto_definition r=matklad a=Veykril\n\nUnfortunately involves a bit of weird workarounds due to pulldown_cmark's incorrect lifetimes on `BrokenLinkCallback`... I should probably open an issue there asking for the fixes to be pushed to a release since they already exist in the repo for quite some time it seems.\r\n\r\nFixes #8258, Fixes #8238\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "e267eed3fc8966093fbd79389e47a051c435cd7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e267eed3fc8966093fbd79389e47a051c435cd7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2be91dcd826e1529ac6ac431b3f871ec72abebc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgawLcCRBK7hj4Ov3rIwAAdHIIAFVDHNw1sYByWgMPe6V1CXV8\nFgu8jGXX/ar6LC0S/ilQBWnxFPQhxWT8RQ4A37xAk+e5NsNkkyNWSAN6G4wXhH4o\nCk6sx5LsyvKjXoxvY9yZEVEsCiPVm5i3UVnW/UT+PcYrhIyV15cOQ5YdMV5czczb\nVuXdo1prAA+yEyrUqRZKsHTo2qKb7nDghbDdaTb1M1ytIN2T//4F0uYagoYgamEJ\nEZSwmL7RpzUg18gJDBZ3C42v0rREMQSdnrXb0yDaw3P0SuWkrlDkzaYQqpe2wq0J\ndOUjcd7FeKjzPCRpadNM4Q07AItgsBtg/wAbACVPISXhjR1n2T/WQnUQs88VtOo=\n=Y/TM\n-----END PGP SIGNATURE-----\n", "payload": "tree e267eed3fc8966093fbd79389e47a051c435cd7d\nparent d8ee25bb976f50c0c0c8c247ca8bb030d9167bdb\nparent 8d786dc4c3ce26dbb3432023c7461bd879993bfd\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617625820 +0000\ncommitter GitHub <noreply@github.com> 1617625820 +0000\n\nMerge #8245\n\n8245: Properly resolve intra doc links in hover and goto_definition r=matklad a=Veykril\n\nUnfortunately involves a bit of weird workarounds due to pulldown_cmark's incorrect lifetimes on `BrokenLinkCallback`... I should probably open an issue there asking for the fixes to be pushed to a release since they already exist in the repo for quite some time it seems.\r\n\r\nFixes #8258, Fixes #8238\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2be91dcd826e1529ac6ac431b3f871ec72abebc", "html_url": "https://github.com/rust-lang/rust/commit/c2be91dcd826e1529ac6ac431b3f871ec72abebc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2be91dcd826e1529ac6ac431b3f871ec72abebc/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8ee25bb976f50c0c0c8c247ca8bb030d9167bdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8ee25bb976f50c0c0c8c247ca8bb030d9167bdb", "html_url": "https://github.com/rust-lang/rust/commit/d8ee25bb976f50c0c0c8c247ca8bb030d9167bdb"}, {"sha": "8d786dc4c3ce26dbb3432023c7461bd879993bfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d786dc4c3ce26dbb3432023c7461bd879993bfd", "html_url": "https://github.com/rust-lang/rust/commit/8d786dc4c3ce26dbb3432023c7461bd879993bfd"}], "stats": {"total": 417, "additions": 260, "deletions": 157}, "files": [{"sha": "ab77d924a4c000d1f20341bb4e6c3ac721569f27", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 93, "deletions": 2, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91dcd826e1529ac6ac431b3f871ec72abebc/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91dcd826e1529ac6ac431b3f871ec72abebc/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=c2be91dcd826e1529ac6ac431b3f871ec72abebc", "patch": "@@ -1,6 +1,10 @@\n //! A higher level attributes based on TokenTree, with also some shortcuts.\n \n-use std::{ops, sync::Arc};\n+use std::{\n+    convert::{TryFrom, TryInto},\n+    ops,\n+    sync::Arc,\n+};\n \n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n@@ -12,7 +16,7 @@ use mbe::ast_to_token_tree;\n use smallvec::{smallvec, SmallVec};\n use syntax::{\n     ast::{self, AstNode, AttrsOwner},\n-    match_ast, AstToken, SmolStr, SyntaxNode,\n+    match_ast, AstToken, SmolStr, SyntaxNode, TextRange, TextSize,\n };\n use tt::Subtree;\n \n@@ -452,6 +456,55 @@ impl AttrsWithOwner {\n                 .collect(),\n         }\n     }\n+\n+    pub fn docs_with_rangemap(\n+        &self,\n+        db: &dyn DefDatabase,\n+    ) -> Option<(Documentation, DocsRangeMap)> {\n+        // FIXME: code duplication in `docs` above\n+        let docs = self.by_key(\"doc\").attrs().flat_map(|attr| match attr.input.as_ref()? {\n+            AttrInput::Literal(s) => Some((s, attr.index)),\n+            AttrInput::TokenTree(_) => None,\n+        });\n+        let indent = docs\n+            .clone()\n+            .flat_map(|(s, _)| s.lines())\n+            .filter(|line| !line.chars().all(|c| c.is_whitespace()))\n+            .map(|line| line.chars().take_while(|c| c.is_whitespace()).count())\n+            .min()\n+            .unwrap_or(0);\n+        let mut buf = String::new();\n+        let mut mapping = Vec::new();\n+        for (doc, idx) in docs {\n+            // str::lines doesn't yield anything for the empty string\n+            if !doc.is_empty() {\n+                for line in doc.split('\\n') {\n+                    let line = line.trim_end();\n+                    let line_len = line.len();\n+                    let (offset, line) = match line.char_indices().nth(indent) {\n+                        Some((offset, _)) => (offset, &line[offset..]),\n+                        None => (0, line),\n+                    };\n+                    let buf_offset = buf.len();\n+                    buf.push_str(line);\n+                    mapping.push((\n+                        TextRange::new(buf_offset.try_into().ok()?, buf.len().try_into().ok()?),\n+                        idx,\n+                        TextRange::new(offset.try_into().ok()?, line_len.try_into().ok()?),\n+                    ));\n+                    buf.push('\\n');\n+                }\n+            } else {\n+                buf.push('\\n');\n+            }\n+        }\n+        buf.pop();\n+        if buf.is_empty() {\n+            None\n+        } else {\n+            Some((Documentation(buf), DocsRangeMap { mapping, source: self.source_map(db).attrs }))\n+        }\n+    }\n }\n \n fn inner_attributes(\n@@ -508,6 +561,44 @@ impl AttrSourceMap {\n     }\n }\n \n+/// A struct to map text ranges from [`Documentation`] back to TextRanges in the syntax tree.\n+pub struct DocsRangeMap {\n+    source: Vec<InFile<Either<ast::Attr, ast::Comment>>>,\n+    // (docstring-line-range, attr_index, attr-string-range)\n+    // a mapping from the text range of a line of the [`Documentation`] to the attribute index and\n+    // the original (untrimmed) syntax doc line\n+    mapping: Vec<(TextRange, u32, TextRange)>,\n+}\n+\n+impl DocsRangeMap {\n+    pub fn map(&self, range: TextRange) -> Option<InFile<TextRange>> {\n+        let found = self.mapping.binary_search_by(|(probe, ..)| probe.ordering(range)).ok()?;\n+        let (line_docs_range, idx, original_line_src_range) = self.mapping[found].clone();\n+        if !line_docs_range.contains_range(range) {\n+            return None;\n+        }\n+\n+        let relative_range = range - line_docs_range.start();\n+\n+        let &InFile { file_id, value: ref source } = &self.source[idx as usize];\n+        match source {\n+            Either::Left(_) => None, // FIXME, figure out a nice way to handle doc attributes here\n+            // as well as for whats done in syntax highlight doc injection\n+            Either::Right(comment) => {\n+                let text_range = comment.syntax().text_range();\n+                let range = TextRange::at(\n+                    text_range.start()\n+                        + TextSize::try_from(comment.prefix().len()).ok()?\n+                        + original_line_src_range.start()\n+                        + relative_range.start(),\n+                    text_range.len().min(range.len()),\n+                );\n+                Some(InFile { file_id, value: range })\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Attr {\n     index: u32,"}, {"sha": "c5dc14a237acc45d463a94a44af7a82cac9e297a", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 59, "deletions": 73, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91dcd826e1529ac6ac431b3f871ec72abebc/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91dcd826e1529ac6ac431b3f871ec72abebc/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=c2be91dcd826e1529ac6ac431b3f871ec72abebc", "patch": "@@ -1,6 +1,9 @@\n //! Extracts, resolves and rewrites links and intra-doc links in markdown documentation.\n \n-use std::{convert::TryFrom, iter::once, ops::Range};\n+use std::{\n+    convert::{TryFrom, TryInto},\n+    iter::once,\n+};\n \n use itertools::Itertools;\n use pulldown_cmark::{BrokenLink, CowStr, Event, InlineStr, LinkType, Options, Parser, Tag};\n@@ -16,8 +19,7 @@ use ide_db::{\n     RootDatabase,\n };\n use syntax::{\n-    ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxNode, SyntaxToken, TextRange, TextSize,\n-    TokenAtOffset, T,\n+    ast, match_ast, AstNode, SyntaxKind::*, SyntaxNode, SyntaxToken, TextRange, TokenAtOffset, T,\n };\n \n use crate::{FilePosition, Semantics};\n@@ -26,12 +28,7 @@ pub(crate) type DocumentationLink = String;\n \n /// Rewrite documentation links in markdown to point to an online host (e.g. docs.rs)\n pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) -> String {\n-    let mut cb = |link: BrokenLink| {\n-        Some((\n-            /*url*/ link.reference.to_owned().into(),\n-            /*title*/ link.reference.to_owned().into(),\n-        ))\n-    };\n+    let mut cb = broken_link_clone_cb;\n     let doc = Parser::new_with_broken_link_callback(markdown, Options::empty(), Some(&mut cb));\n \n     let doc = map_links(doc, |target, title: &str| {\n@@ -123,74 +120,27 @@ pub(crate) fn external_docs(\n /// Extracts all links from a given markdown text.\n pub(crate) fn extract_definitions_from_markdown(\n     markdown: &str,\n-) -> Vec<(Range<usize>, String, Option<hir::Namespace>)> {\n-    let mut res = vec![];\n-    let mut cb = |link: BrokenLink| {\n-        // These allocations are actually unnecessary but the lifetimes on BrokenLinkCallback are wrong\n-        // this is fixed in the repo but not on the crates.io release yet\n-        Some((\n-            /*url*/ link.reference.to_owned().into(),\n-            /*title*/ link.reference.to_owned().into(),\n-        ))\n-    };\n-    let doc = Parser::new_with_broken_link_callback(markdown, Options::empty(), Some(&mut cb));\n-    for (event, range) in doc.into_offset_iter() {\n+) -> Vec<(TextRange, String, Option<hir::Namespace>)> {\n+    Parser::new_with_broken_link_callback(\n+        markdown,\n+        Options::empty(),\n+        Some(&mut broken_link_clone_cb),\n+    )\n+    .into_offset_iter()\n+    .filter_map(|(event, range)| {\n         if let Event::Start(Tag::Link(_, target, title)) = event {\n             let link = if target.is_empty() { title } else { target };\n             let (link, ns) = parse_intra_doc_link(&link);\n-            res.push((range, link.to_string(), ns));\n-        }\n-    }\n-    res\n-}\n-\n-/// Extracts a link from a comment at the given position returning the spanning range, link and\n-/// optionally it's namespace.\n-pub(crate) fn extract_positioned_link_from_comment(\n-    position: TextSize,\n-    comment: &ast::Comment,\n-) -> Option<(TextRange, String, Option<hir::Namespace>)> {\n-    let doc_comment = comment.doc_comment()?;\n-    let comment_start =\n-        comment.syntax().text_range().start() + TextSize::from(comment.prefix().len() as u32);\n-    let def_links = extract_definitions_from_markdown(doc_comment);\n-    let (range, def_link, ns) =\n-        def_links.into_iter().find_map(|(Range { start, end }, def_link, ns)| {\n-            let range = TextRange::at(\n-                comment_start + TextSize::from(start as u32),\n-                TextSize::from((end - start) as u32),\n-            );\n-            range.contains(position).then(|| (range, def_link, ns))\n-        })?;\n-    Some((range, def_link, ns))\n-}\n-\n-/// Turns a syntax node into it's [`Definition`] if it can hold docs.\n-pub(crate) fn doc_owner_to_def(\n-    sema: &Semantics<RootDatabase>,\n-    item: &SyntaxNode,\n-) -> Option<Definition> {\n-    let res: hir::ModuleDef = match_ast! {\n-        match item {\n-            ast::SourceFile(_it) => sema.scope(item).module()?.into(),\n-            ast::Fn(it) => sema.to_def(&it)?.into(),\n-            ast::Struct(it) => sema.to_def(&it)?.into(),\n-            ast::Enum(it) => sema.to_def(&it)?.into(),\n-            ast::Union(it) => sema.to_def(&it)?.into(),\n-            ast::Trait(it) => sema.to_def(&it)?.into(),\n-            ast::Const(it) => sema.to_def(&it)?.into(),\n-            ast::Static(it) => sema.to_def(&it)?.into(),\n-            ast::TypeAlias(it) => sema.to_def(&it)?.into(),\n-            ast::Variant(it) => sema.to_def(&it)?.into(),\n-            ast::Trait(it) => sema.to_def(&it)?.into(),\n-            ast::Impl(it) => return sema.to_def(&it).map(Definition::SelfType),\n-            ast::Macro(it) => return sema.to_def(&it).map(Definition::Macro),\n-            ast::TupleField(it) => return sema.to_def(&it).map(Definition::Field),\n-            ast::RecordField(it) => return sema.to_def(&it).map(Definition::Field),\n-            _ => return None,\n+            Some((\n+                TextRange::new(range.start.try_into().ok()?, range.end.try_into().ok()?),\n+                link.to_string(),\n+                ns,\n+            ))\n+        } else {\n+            None\n         }\n-    };\n-    Some(Definition::ModuleDef(res))\n+    })\n+    .collect()\n }\n \n pub(crate) fn resolve_doc_path_for_def(\n@@ -220,6 +170,42 @@ pub(crate) fn resolve_doc_path_for_def(\n     }\n }\n \n+pub(crate) fn doc_attributes(\n+    sema: &Semantics<RootDatabase>,\n+    node: &SyntaxNode,\n+) -> Option<(hir::AttrsWithOwner, Definition)> {\n+    match_ast! {\n+        match node {\n+            ast::SourceFile(it)  => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n+            ast::Module(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n+            ast::Fn(it)          => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Function(def)))),\n+            ast::Struct(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(def))))),\n+            ast::Union(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Union(def))))),\n+            ast::Enum(it)        => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(def))))),\n+            ast::Variant(it)     => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Variant(def)))),\n+            ast::Trait(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Trait(def)))),\n+            ast::Static(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Static(def)))),\n+            ast::Const(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Const(def)))),\n+            ast::TypeAlias(it)   => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::TypeAlias(def)))),\n+            ast::Impl(it)        => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::SelfType(def))),\n+            ast::RecordField(it) => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Field(def))),\n+            ast::TupleField(it)  => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Field(def))),\n+            ast::Macro(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Macro(def))),\n+            // ast::Use(it) => sema.to_def(&it).map(|def| (Box::new(it) as _, def.attrs(sema.db))),\n+            _ => return None\n+        }\n+    }\n+}\n+\n+fn broken_link_clone_cb<'a, 'b>(link: BrokenLink<'a>) -> Option<(CowStr<'b>, CowStr<'b>)> {\n+    // These allocations are actually unnecessary but the lifetimes on BrokenLinkCallback are wrong\n+    // this is fixed in the repo but not on the crates.io release yet\n+    Some((\n+        /*url*/ link.reference.to_owned().into(),\n+        /*title*/ link.reference.to_owned().into(),\n+    ))\n+}\n+\n // FIXME:\n // BUG: For Option::Some\n // Returns https://doc.rust-lang.org/nightly/core/prelude/v1/enum.Option.html#variant.Some"}, {"sha": "ca8ccb2da1f5e6dc40b927ff03828f4ca06be9b5", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91dcd826e1529ac6ac431b3f871ec72abebc/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91dcd826e1529ac6ac431b3f871ec72abebc/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=c2be91dcd826e1529ac6ac431b3f871ec72abebc", "patch": "@@ -1,5 +1,5 @@\n use either::Either;\n-use hir::Semantics;\n+use hir::{InFile, Semantics};\n use ide_db::{\n     defs::{NameClass, NameRefClass},\n     RootDatabase,\n@@ -8,7 +8,7 @@ use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, Toke\n \n use crate::{\n     display::TryToNav,\n-    doc_links::{doc_owner_to_def, extract_positioned_link_from_comment, resolve_doc_path_for_def},\n+    doc_links::{doc_attributes, extract_definitions_from_markdown, resolve_doc_path_for_def},\n     FilePosition, NavigationTarget, RangeInfo,\n };\n \n@@ -32,9 +32,16 @@ pub(crate) fn goto_definition(\n     let original_token = pick_best(file.token_at_offset(position.offset))?;\n     let token = sema.descend_into_macros(original_token.clone());\n     let parent = token.parent()?;\n-    if let Some(comment) = ast::Comment::cast(token) {\n-        let (_, link, ns) = extract_positioned_link_from_comment(position.offset, &comment)?;\n-        let def = doc_owner_to_def(&sema, &parent)?;\n+    if let Some(_) = ast::Comment::cast(token) {\n+        let (attributes, def) = doc_attributes(&sema, &parent)?;\n+\n+        let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n+        let (_, link, ns) =\n+            extract_definitions_from_markdown(docs.as_str()).into_iter().find(|(range, ..)| {\n+                doc_mapping.map(range.clone()).map_or(false, |InFile { file_id, value: range }| {\n+                    file_id == position.file_id.into() && range.contains(position.offset)\n+                })\n+            })?;\n         let nav = resolve_doc_path_for_def(db, def, &link, ns)?.try_to_nav(db)?;\n         return Some(RangeInfo::new(original_token.text_range(), vec![nav]));\n     }\n@@ -1160,4 +1167,25 @@ fn fn_macro() {}\n             \"#,\n         )\n     }\n+\n+    #[test]\n+    fn goto_intra_doc_links() {\n+        check(\n+            r#\"\n+\n+pub mod theitem {\n+    /// This is the item. Cool!\n+    pub struct TheItem;\n+             //^^^^^^^\n+}\n+\n+/// Gives you a [`TheItem$0`].\n+///\n+/// [`TheItem`]: theitem::TheItem\n+pub fn gimme() -> theitem::TheItem {\n+    theitem::TheItem\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "9de65373995223499ca6a3a6c39f42071910278c", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91dcd826e1529ac6ac431b3f871ec72abebc/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91dcd826e1529ac6ac431b3f871ec72abebc/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=c2be91dcd826e1529ac6ac431b3f871ec72abebc", "patch": "@@ -1,6 +1,6 @@\n use either::Either;\n use hir::{\n-    AsAssocItem, AssocItemContainer, GenericParam, HasAttrs, HasSource, HirDisplay, Module,\n+    AsAssocItem, AssocItemContainer, GenericParam, HasAttrs, HasSource, HirDisplay, InFile, Module,\n     ModuleDef, Semantics,\n };\n use ide_db::{\n@@ -16,8 +16,8 @@ use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, Toke\n use crate::{\n     display::{macro_label, TryToNav},\n     doc_links::{\n-        doc_owner_to_def, extract_positioned_link_from_comment, remove_links,\n-        resolve_doc_path_for_def, rewrite_links,\n+        doc_attributes, extract_definitions_from_markdown, remove_links, resolve_doc_path_for_def,\n+        rewrite_links,\n     },\n     markdown_remove::remove_markdown,\n     markup::Markup,\n@@ -116,11 +116,19 @@ pub(crate) fn hover(\n             ),\n \n             _ => ast::Comment::cast(token.clone())\n-                .and_then(|comment| {\n+                .and_then(|_| {\n+                    let (attributes, def) = doc_attributes(&sema, &node)?;\n+                    let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n                     let (idl_range, link, ns) =\n-                        extract_positioned_link_from_comment(position.offset, &comment)?;\n+                        extract_definitions_from_markdown(docs.as_str()).into_iter().find_map(|(range, link, ns)| {\n+                            let InFile { file_id, value: range } = doc_mapping.map(range.clone())?;\n+                            if file_id == position.file_id.into() && range.contains(position.offset) {\n+                                Some((range, link, ns))\n+                            } else {\n+                                None\n+                            }\n+                        })?;\n                     range = Some(idl_range);\n-                    let def = doc_owner_to_def(&sema, &node)?;\n                     resolve_doc_path_for_def(db, def, &link, ns)\n                 })\n                 .map(Definition::ModuleDef),\n@@ -3814,23 +3822,33 @@ fn main() {\n     fn hover_intra_doc_links() {\n         check(\n             r#\"\n-/// This is the [`foo`](foo$0) function.\n-fn foo() {}\n+\n+pub mod theitem {\n+    /// This is the item. Cool!\n+    pub struct TheItem;\n+}\n+\n+/// Gives you a [`TheItem$0`].\n+///\n+/// [`TheItem`]: theitem::TheItem\n+pub fn gimme() -> theitem::TheItem {\n+    theitem::TheItem\n+}\n \"#,\n             expect![[r#\"\n-                *[`foo`](foo)*\n+                *[`TheItem`]*\n \n                 ```rust\n-                test\n+                test::theitem\n                 ```\n \n                 ```rust\n-                fn foo()\n+                pub struct TheItem\n                 ```\n \n                 ---\n \n-                This is the [`foo`](https://docs.rs/test/*/test/fn.foo.html) function.\n+                This is the item. Cool!\n             \"#]],\n         );\n     }"}, {"sha": "04fafd244f847b10b6b933c568cd34d113a4adc8", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 27, "deletions": 63, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91dcd826e1529ac6ac431b3f871ec72abebc/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91dcd826e1529ac6ac431b3f871ec72abebc/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=c2be91dcd826e1529ac6ac431b3f871ec72abebc", "patch": "@@ -1,17 +1,17 @@\n //! \"Recursive\" Syntax highlighting for code in doctests and fixtures.\n \n-use std::{mem, ops::Range};\n+use std::mem;\n \n use either::Either;\n-use hir::{HasAttrs, InFile, Semantics};\n-use ide_db::{call_info::ActiveParameter, defs::Definition, SymbolKind};\n+use hir::{InFile, Semantics};\n+use ide_db::{call_info::ActiveParameter, SymbolKind};\n use syntax::{\n     ast::{self, AstNode},\n-    match_ast, AstToken, NodeOrToken, SyntaxNode, SyntaxToken, TextRange, TextSize,\n+    AstToken, NodeOrToken, SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::{\n-    doc_links::{extract_definitions_from_markdown, resolve_doc_path_for_def},\n+    doc_links::{doc_attributes, extract_definitions_from_markdown, resolve_doc_path_for_def},\n     Analysis, HlMod, HlRange, HlTag, RootDatabase,\n };\n \n@@ -90,33 +90,6 @@ const RUSTDOC_FENCE_TOKENS: &[&'static str] = &[\n     \"edition2021\",\n ];\n \n-fn doc_attributes<'node>(\n-    sema: &Semantics<RootDatabase>,\n-    node: &'node SyntaxNode,\n-) -> Option<(hir::AttrsWithOwner, Definition)> {\n-    match_ast! {\n-        match node {\n-            ast::SourceFile(it)  => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n-            ast::Module(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n-            ast::Fn(it)          => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Function(def)))),\n-            ast::Struct(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(def))))),\n-            ast::Union(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Union(def))))),\n-            ast::Enum(it)        => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(def))))),\n-            ast::Variant(it)     => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Variant(def)))),\n-            ast::Trait(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Trait(def)))),\n-            ast::Static(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Static(def)))),\n-            ast::Const(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Const(def)))),\n-            ast::TypeAlias(it)   => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::TypeAlias(def)))),\n-            ast::Impl(it)        => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::SelfType(def))),\n-            ast::RecordField(it) => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Field(def))),\n-            ast::TupleField(it)  => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Field(def))),\n-            ast::Macro(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Macro(def))),\n-            // ast::Use(it) => sema.to_def(&it).map(|def| (Box::new(it) as _, def.attrs(sema.db))),\n-            _ => return None\n-        }\n-    }\n-}\n-\n /// Injection of syntax highlighting of doctests.\n pub(super) fn doc_comment(\n     hl: &mut Highlights,\n@@ -139,8 +112,28 @@ pub(super) fn doc_comment(\n     // Replace the original, line-spanning comment ranges by new, only comment-prefix\n     // spanning comment ranges.\n     let mut new_comments = Vec::new();\n-    let mut intra_doc_links = Vec::new();\n     let mut string;\n+\n+    if let Some((docs, doc_mapping)) = attributes.docs_with_rangemap(sema.db) {\n+        extract_definitions_from_markdown(docs.as_str())\n+            .into_iter()\n+            .filter_map(|(range, link, ns)| {\n+                let def = resolve_doc_path_for_def(sema.db, def, &link, ns)?;\n+                let InFile { file_id, value: range } = doc_mapping.map(range)?;\n+                (file_id == node.file_id).then(|| (range, def))\n+            })\n+            .for_each(|(range, def)| {\n+                hl.add(HlRange {\n+                    range,\n+                    highlight: module_def_to_hl_tag(def)\n+                        | HlMod::Documentation\n+                        | HlMod::Injected\n+                        | HlMod::IntraDocLink,\n+                    binding_hash: None,\n+                })\n+            });\n+    }\n+\n     for attr in attributes.by_key(\"doc\").attrs() {\n         let InFile { file_id, value: src } = attrs_source_map.source_of(&attr);\n         if file_id != node.file_id {\n@@ -186,25 +179,7 @@ pub(super) fn doc_comment(\n                     is_doctest = is_codeblock && is_rust;\n                     continue;\n                 }\n-                None if !is_doctest => {\n-                    intra_doc_links.extend(\n-                        extract_definitions_from_markdown(line)\n-                            .into_iter()\n-                            .filter_map(|(range, link, ns)| {\n-                                Some(range).zip(resolve_doc_path_for_def(sema.db, def, &link, ns))\n-                            })\n-                            .map(|(Range { start, end }, def)| {\n-                                (\n-                                    def,\n-                                    TextRange::at(\n-                                        prev_range_start + TextSize::from(start as u32),\n-                                        TextSize::from((end - start) as u32),\n-                                    ),\n-                                )\n-                            }),\n-                    );\n-                    continue;\n-                }\n+                None if !is_doctest => continue,\n                 None => (),\n             }\n \n@@ -223,17 +198,6 @@ pub(super) fn doc_comment(\n         }\n     }\n \n-    for (def, range) in intra_doc_links {\n-        hl.add(HlRange {\n-            range,\n-            highlight: module_def_to_hl_tag(def)\n-                | HlMod::Documentation\n-                | HlMod::Injected\n-                | HlMod::IntraDocLink,\n-            binding_hash: None,\n-        });\n-    }\n-\n     if new_comments.is_empty() {\n         return; // no need to run an analysis on an empty file\n     }"}, {"sha": "b6d1cac4ea90aa0af07ba17d6dbbd2f99848b4ec", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_doctest.html", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91dcd826e1529ac6ac431b3f871ec72abebc/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91dcd826e1529ac6ac431b3f871ec72abebc/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html?ref=c2be91dcd826e1529ac6ac431b3f871ec72abebc", "patch": "@@ -100,10 +100,18 @@\n <span class=\"brace\">}</span>\n \n <span class=\"comment documentation\">/// </span><span class=\"struct documentation intra_doc_link injected\">[`Foo`](Foo)</span><span class=\"comment documentation\"> is a struct</span>\n-<span class=\"comment documentation\">/// </span><span class=\"function documentation intra_doc_link injected\">[`all_the_links`](all_the_links)</span><span class=\"comment documentation\"> is this function</span>\n+<span class=\"comment documentation\">/// This function is &gt; </span><span class=\"function documentation intra_doc_link injected\">[`all_the_links`](all_the_links)</span><span class=\"comment documentation\"> &lt;</span>\n <span class=\"comment documentation\">/// [`noop`](noop) is a macro below</span>\n+<span class=\"comment documentation\">/// </span><span class=\"struct documentation intra_doc_link injected\">[`Item`]</span><span class=\"comment documentation\"> is a struct in the module </span><span class=\"module documentation intra_doc_link injected\">[`module`]</span>\n+<span class=\"comment documentation\">///</span>\n+<span class=\"comment documentation\">/// [`Item`]: module::Item</span>\n+<span class=\"comment documentation\">/// [mix_and_match]: ThisShouldntResolve</span>\n <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function declaration\">all_the_links</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>\n \n+<span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> <span class=\"module declaration\">module</span> <span class=\"brace\">{</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">struct</span> <span class=\"struct declaration\">Item</span><span class=\"semicolon\">;</span>\n+<span class=\"brace\">}</span>\n+\n <span class=\"comment documentation\">/// ```</span>\n <span class=\"comment documentation\">/// </span><span class=\"macro injected\">noop!</span><span class=\"parenthesis injected\">(</span><span class=\"numeric_literal injected\">1</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n <span class=\"comment documentation\">/// ```</span>"}, {"sha": "1b02857ecb93a2c39d0097df2ff517bd50bbb27f", "filename": "crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91dcd826e1529ac6ac431b3f871ec72abebc/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91dcd826e1529ac6ac431b3f871ec72abebc/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=c2be91dcd826e1529ac6ac431b3f871ec72abebc", "patch": "@@ -544,10 +544,18 @@ impl Foo {\n }\n \n /// [`Foo`](Foo) is a struct\n-/// [`all_the_links`](all_the_links) is this function\n+/// This function is > [`all_the_links`](all_the_links) <\n /// [`noop`](noop) is a macro below\n+/// [`Item`] is a struct in the module [`module`]\n+///\n+/// [`Item`]: module::Item\n+/// [mix_and_match]: ThisShouldntResolve\n pub fn all_the_links() {}\n \n+pub mod module {\n+    pub struct Item;\n+}\n+\n /// ```\n /// noop!(1);\n /// ```"}]}