{"sha": "8b5a9836be5b115f27f48406f68bf64d931ceabc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiNWE5ODM2YmU1YjExNWYyN2Y0ODQwNmY2OGJmNjRkOTMxY2VhYmM=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "vastrauskas@gmail.com", "date": "2020-05-19T14:47:25Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "vastrauskas@gmail.com", "date": "2020-05-24T22:02:54Z"}, "message": "Small changes.", "tree": {"sha": "76a5afb2742a0b4bb0b2261bf9764955a49185b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76a5afb2742a0b4bb0b2261bf9764955a49185b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b5a9836be5b115f27f48406f68bf64d931ceabc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b5a9836be5b115f27f48406f68bf64d931ceabc", "html_url": "https://github.com/rust-lang/rust/commit/8b5a9836be5b115f27f48406f68bf64d931ceabc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b5a9836be5b115f27f48406f68bf64d931ceabc/comments", "author": {"login": "vakaras", "id": 75347, "node_id": "MDQ6VXNlcjc1MzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/75347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vakaras", "html_url": "https://github.com/vakaras", "followers_url": "https://api.github.com/users/vakaras/followers", "following_url": "https://api.github.com/users/vakaras/following{/other_user}", "gists_url": "https://api.github.com/users/vakaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/vakaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vakaras/subscriptions", "organizations_url": "https://api.github.com/users/vakaras/orgs", "repos_url": "https://api.github.com/users/vakaras/repos", "events_url": "https://api.github.com/users/vakaras/events{/privacy}", "received_events_url": "https://api.github.com/users/vakaras/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vakaras", "id": 75347, "node_id": "MDQ6VXNlcjc1MzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/75347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vakaras", "html_url": "https://github.com/vakaras", "followers_url": "https://api.github.com/users/vakaras/followers", "following_url": "https://api.github.com/users/vakaras/following{/other_user}", "gists_url": "https://api.github.com/users/vakaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/vakaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vakaras/subscriptions", "organizations_url": "https://api.github.com/users/vakaras/orgs", "repos_url": "https://api.github.com/users/vakaras/repos", "events_url": "https://api.github.com/users/vakaras/events{/privacy}", "received_events_url": "https://api.github.com/users/vakaras/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0838347d8f77091ffb5a30606010d0bbedda22a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0838347d8f77091ffb5a30606010d0bbedda22a4", "html_url": "https://github.com/rust-lang/rust/commit/0838347d8f77091ffb5a30606010d0bbedda22a4"}], "stats": {"total": 75, "additions": 30, "deletions": 45}, "files": [{"sha": "f34799f74251fe8772495e5ff539a943d07381ea", "filename": "src/shims/sync.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8b5a9836be5b115f27f48406f68bf64d931ceabc/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b5a9836be5b115f27f48406f68bf64d931ceabc/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=8b5a9836be5b115f27f48406f68bf64d931ceabc", "patch": "@@ -254,7 +254,8 @@ fn cond_set_clock_id<'mir, 'tcx: 'mir>(\n     set_at_offset(ecx, cond_op, 8, clock_id, ecx.machine.layouts.i32, PTHREAD_COND_T_MIN_SIZE)\n }\n \n-/// Try to reacquire the mutex associated with the condition variable after we were signaled.\n+/// Try to reacquire the mutex associated with the condition variable after we\n+/// were signaled.\n fn reacquire_cond_mutex<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     thread: ThreadId,\n@@ -269,6 +270,17 @@ fn reacquire_cond_mutex<'mir, 'tcx: 'mir>(\n     Ok(())\n }\n \n+/// Reacquire the conditional variable and remove the timeout callback if any\n+/// was registered.\n+fn post_cond_signal<'mir, 'tcx: 'mir>(\n+    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    thread: ThreadId,\n+    mutex: MutexId,\n+) -> InterpResult<'tcx> {\n+    reacquire_cond_mutex(ecx, thread, mutex)?;\n+    ecx.unregister_timeout_callback_if_exists(thread)\n+}\n+\n /// Release the mutex associated with the condition variable because we are\n /// entering the waiting state.\n fn release_cond_mutex<'mir, 'tcx: 'mir>(\n@@ -648,8 +660,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let id = cond_get_or_create_id(this, cond_op)?;\n         if let Some((thread, mutex)) = this.condvar_signal(id) {\n-            reacquire_cond_mutex(this, thread, mutex)?;\n-            this.unregister_timeout_callback_if_exists(thread)?;\n+            post_cond_signal(this, thread, mutex)?;\n         }\n \n         Ok(0)\n@@ -660,8 +671,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let id = cond_get_or_create_id(this, cond_op)?;\n \n         while let Some((thread, mutex)) = this.condvar_signal(id) {\n-            reacquire_cond_mutex(this, thread, mutex)?;\n-            this.unregister_timeout_callback_if_exists(thread)?;\n+            post_cond_signal(this, thread, mutex)?;\n         }\n \n         Ok(0)\n@@ -730,21 +740,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         } else if clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")? {\n             Time::Monotonic(this.machine.time_anchor.checked_add(duration).unwrap())\n         } else {\n-            throw_ub_format!(\"Unsupported clock id.\");\n+            throw_unsup_format!(\"Unsupported clock id.\");\n         };\n \n         // Register the timeout callback.\n         this.register_timeout_callback(\n             active_thread,\n             timeout_time,\n             Box::new(move |ecx| {\n-                // Try to reacquire the mutex.\n+                // We are not waiting for the condvar any more, wait for the\n+                // mutex instead.\n                 reacquire_cond_mutex(ecx, active_thread, mutex_id)?;\n \n                 // Remove the thread from the conditional variable.\n                 ecx.condvar_remove_waiter(id, active_thread);\n \n-                // Set the timeout value.\n+                // Set the return value: we timed out.\n                 let timeout = ecx.eval_libc_i32(\"ETIMEDOUT\")?;\n                 ecx.write_scalar(Scalar::from_i32(timeout), dest)?;\n "}, {"sha": "cbae29bdbb3674392dd723900e293f7c149acb82", "filename": "src/sync.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b5a9836be5b115f27f48406f68bf64d931ceabc/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b5a9836be5b115f27f48406f68bf64d931ceabc/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=8b5a9836be5b115f27f48406f68bf64d931ceabc", "patch": "@@ -179,6 +179,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Put the thread into the queue waiting for the lock.\n     fn mutex_enqueue(&mut self, id: MutexId, thread: ThreadId) {\n         let this = self.eval_context_mut();\n+        assert!(this.mutex_is_locked(id), \"queing on unlocked mutex\");\n         this.machine.threads.sync.mutexes[id].queue.push_back(thread);\n     }\n "}, {"sha": "39b6a7e4ef803d3b073295139dd6dcf30f10aeaf", "filename": "tests/run-pass/concurrency/libc_pthread_cond.rs", "status": "modified", "additions": 7, "deletions": 35, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8b5a9836be5b115f27f48406f68bf64d931ceabc/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b5a9836be5b115f27f48406f68bf64d931ceabc/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flibc_pthread_cond.rs?ref=8b5a9836be5b115f27f48406f68bf64d931ceabc", "patch": "@@ -11,11 +11,11 @@ extern crate libc;\n use std::mem;\n use std::time::Instant;\n \n-fn test_timed_wait_timeout_monotonic() {\n+fn test_timed_wait_timeout(clock_id: i32) {\n     unsafe {\n         let mut attr: libc::pthread_condattr_t = mem::zeroed();\n         assert_eq!(libc::pthread_condattr_init(&mut attr as *mut _), 0);\n-        assert_eq!(libc::pthread_condattr_setclock(&mut attr as *mut _, libc::CLOCK_MONOTONIC), 0);\n+        assert_eq!(libc::pthread_condattr_setclock(&mut attr as *mut _, clock_id), 0);\n \n         let mut cond: libc::pthread_cond_t = mem::zeroed();\n         assert_eq!(libc::pthread_cond_init(&mut cond as *mut _, &attr as *const _), 0);\n@@ -24,7 +24,7 @@ fn test_timed_wait_timeout_monotonic() {\n         let mut mutex: libc::pthread_mutex_t = mem::zeroed();\n \n         let mut now: libc::timespec = mem::zeroed();\n-        assert_eq!(libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now), 0);\n+        assert_eq!(libc::clock_gettime(clock_id, &mut now), 0);\n         let timeout = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: now.tv_nsec };\n \n         assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n@@ -33,43 +33,15 @@ fn test_timed_wait_timeout_monotonic() {\n             libc::pthread_cond_timedwait(&mut cond as *mut _, &mut mutex as *mut _, &timeout),\n             libc::ETIMEDOUT\n         );\n-        assert!(current_time.elapsed().as_millis() >= 900);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_cond_destroy(&mut cond as *mut _), 0);\n-    }\n-}\n-\n-fn test_timed_wait_timeout_realtime() {\n-    unsafe {\n-        let mut attr: libc::pthread_condattr_t = mem::zeroed();\n-        assert_eq!(libc::pthread_condattr_init(&mut attr as *mut _), 0);\n-        assert_eq!(libc::pthread_condattr_setclock(&mut attr as *mut _, libc::CLOCK_REALTIME), 0);\n-\n-        let mut cond: libc::pthread_cond_t = mem::zeroed();\n-        assert_eq!(libc::pthread_cond_init(&mut cond as *mut _, &attr as *const _), 0);\n-        assert_eq!(libc::pthread_condattr_destroy(&mut attr as *mut _), 0);\n-\n-        let mut mutex: libc::pthread_mutex_t = mem::zeroed();\n-\n-        let mut now: libc::timespec = mem::zeroed();\n-        assert_eq!(libc::clock_gettime(libc::CLOCK_REALTIME, &mut now), 0);\n-        let timeout = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: now.tv_nsec };\n-\n-        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n-        let current_time = Instant::now();\n-        assert_eq!(\n-            libc::pthread_cond_timedwait(&mut cond as *mut _, &mut mutex as *mut _, &timeout),\n-            libc::ETIMEDOUT\n-        );\n-        assert!(current_time.elapsed().as_millis() >= 900);\n+        let elapsed_time = current_time.elapsed().as_millis();\n+        assert!(900 <= elapsed_time && elapsed_time <= 1100);\n         assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n         assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n         assert_eq!(libc::pthread_cond_destroy(&mut cond as *mut _), 0);\n     }\n }\n \n fn main() {\n-    test_timed_wait_timeout_monotonic();\n-    test_timed_wait_timeout_realtime();\n+    test_timed_wait_timeout(libc::CLOCK_MONOTONIC);\n+    test_timed_wait_timeout(libc::CLOCK_REALTIME);\n }"}, {"sha": "5c19eee342f115250ad9d466016cb29a770aafd0", "filename": "tests/run-pass/concurrency/sync.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b5a9836be5b115f27f48406f68bf64d931ceabc/tests%2Frun-pass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b5a9836be5b115f27f48406f68bf64d931ceabc/tests%2Frun-pass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsync.rs?ref=8b5a9836be5b115f27f48406f68bf64d931ceabc", "patch": "@@ -35,16 +35,17 @@ fn check_conditional_variables_notify_one() {\n     let pair = Arc::new((Mutex::new(false), Condvar::new()));\n     let pair2 = pair.clone();\n \n-    // Inside of our lock, spawn a new thread, and then wait for it to start.\n+    // Spawn a new thread.\n     thread::spawn(move || {\n+        thread::yield_now();\n         let (lock, cvar) = &*pair2;\n         let mut started = lock.lock().unwrap();\n         *started = true;\n         // We notify the condvar that the value has changed.\n         cvar.notify_one();\n     });\n \n-    // Wait for the thread to start up.\n+    // Wait for the thread to fully start up.\n     let (lock, cvar) = &*pair;\n     let mut started = lock.lock().unwrap();\n     while !*started {"}]}