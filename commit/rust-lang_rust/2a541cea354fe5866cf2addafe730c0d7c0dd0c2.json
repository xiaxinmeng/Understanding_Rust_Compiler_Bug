{"sha": "2a541cea354fe5866cf2addafe730c0d7c0dd0c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNTQxY2VhMzU0ZmU1ODY2Y2YyYWRkYWZlNzMwYzBkN2MwZGQwYzI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-20T13:29:39Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-22T15:20:23Z"}, "message": "Completely rework the explanation of the algorithm", "tree": {"sha": "fb35f253e6c4d5611ee106584f958c06c911a13a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb35f253e6c4d5611ee106584f958c06c911a13a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a541cea354fe5866cf2addafe730c0d7c0dd0c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a541cea354fe5866cf2addafe730c0d7c0dd0c2", "html_url": "https://github.com/rust-lang/rust/commit/2a541cea354fe5866cf2addafe730c0d7c0dd0c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a541cea354fe5866cf2addafe730c0d7c0dd0c2/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43d445c8d1ae9c6ecb8203dd97d96f0e245b042d", "url": "https://api.github.com/repos/rust-lang/rust/commits/43d445c8d1ae9c6ecb8203dd97d96f0e245b042d", "html_url": "https://github.com/rust-lang/rust/commit/43d445c8d1ae9c6ecb8203dd97d96f0e245b042d"}], "stats": {"total": 609, "additions": 324, "deletions": 285}, "files": [{"sha": "f71a4829e8a29466db1952beb5fe983cd21cb060", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 113, "deletions": 51, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/2a541cea354fe5866cf2addafe730c0d7c0dd0c2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a541cea354fe5866cf2addafe730c0d7c0dd0c2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=2a541cea354fe5866cf2addafe730c0d7c0dd0c2", "patch": "@@ -1,6 +1,47 @@\n-//! This module provides functions to deconstruct and reconstruct patterns into a constructor\n-//! applied to some fields. This is used by the `_match` module to compute pattern\n-//! usefulness/exhaustiveness.\n+//! [`super::usefulness`] explains most of what is happening in this file. As explained there,\n+//! values and patterns are made from constructors applied to fields. This file defines a\n+//! `Constructor` enum, a `Fields` struct, and various operations to manipulate them and convert\n+//! them from/to patterns.\n+//!\n+//! There's one idea that is not detailed in [`super::usefulness`] because the details are not\n+//! needed there: _constructor splitting_.\n+//!\n+//! # Constructor splitting\n+//!\n+//! The idea is as follows: given a constructor `c` and a matrix, we want to specialize in turn\n+//! with all the value constructors that are covered by `c`, and compute usefulness for each.\n+//! Instead of listing all those constructors (which is intractable), we group those value\n+//! constructors together as much as possible. Example:\n+//!\n+//! ```\n+//! match (0, false) {\n+//!     (0 ..=100, true) => {} // `p_1`\n+//!     (50..=150, false) => {} // `p_2`\n+//!     (0 ..=200, _) => {} // `q`\n+//! }\n+//! ```\n+//!\n+//! The naive approach would try all numbers in the range `0..=200`. But we can be a lot more\n+//! clever: `0` and `1` for example will match the exact same rows, and return equivalent\n+//! witnesses. In fact all of `0..50` would. We can thus restrict our exploration to 4\n+//! constructors: `0..50`, `50..=100`, `101..=150` and `151..=200`. That is enough and infinitely\n+//! more tractable.\n+//!\n+//! We capture this idea in a function `split(p_1 ... p_n, c)` which returns a list of constructors\n+//! `c'` covered by `c`. Given such a `c'`, we require that all value ctors `c''` covered by `c'`\n+//! return an equivalent set of witnesses after specializing and computing usefulness.\n+//! In the example above, witnesses for specializing by `c''` covered by `0..50` will only differ\n+//! in their first element.\n+//!\n+//! We usually also ask that the `c'` together cover all of the original `c`. However we allow\n+//! skipping some constructors as long as it doesn't change whether the resulting list of witnesses\n+//! is empty of not. We use this in the wildcard `_` case.\n+//!\n+//! Splitting is implemented in the [`Constructor::split`] function. We don't do splitting for\n+//! or-patterns; instead we just try the alternatives one-by-one. For details on splitting\n+//! wildcards, see [`SplitWildcard`]; for integer ranges, see [`SplitIntRange`]; for slices, see\n+//! [`SplitVarLenSlice`].\n+\n use self::Constructor::*;\n use self::SliceKind::*;\n \n@@ -260,13 +301,13 @@ enum IntBorder {\n     AfterMax,\n }\n \n-/// A range of integers that is partitioned into disjoint subranges.\n-///\n-/// This is fed an input of multiple ranges, and returns an output that covers the union of the\n-/// inputs but is split so that an output range only intersects an input range by being a subrange\n-/// of it. No output range straddles the boundary of one of the inputs. This does constructor\n+/// A range of integers that is partitioned into disjoint subranges. This does constructor\n /// splitting for integer ranges as explained at the top of the file.\n ///\n+/// This is fed multiple ranges, and returns an output that covers the input, but is split so that\n+/// the only intersections between an output range and a seen range are inclusions. No output range\n+/// straddles the boundary of one of the inputs.\n+///\n /// The following input:\n /// ```\n ///   |-------------------------| // `self`\n@@ -405,54 +446,67 @@ impl Slice {\n     }\n }\n \n-/// The exhaustiveness-checking paper does not include any details on checking variable-length\n-/// slice patterns. However, they may be matched by an infinite collection of fixed-length array\n-/// patterns.\n-///\n-/// Checking the infinite set directly would take an infinite amount of time. However, it turns out\n-/// that for each finite set of patterns `P`, all sufficiently large array lengths are equivalent:\n-///\n-/// Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies to exactly the subset\n-/// `P\u209c` of `P` can be transformed to a slice `s\u2098` for each sufficiently-large length `m` that\n-/// applies to exactly the same subset of `P`.\n-///\n-/// Because of that, each witness for reachability-checking of one of the sufficiently-large\n-/// lengths can be transformed to an equally-valid witness of any other length, so we only have to\n-/// check slices of the \"minimal sufficiently-large length\" and less.\n-///\n-/// Note that the fact that there is a *single* `s\u2098` for each `m` not depending on the specific\n-/// pattern in `P` is important: if you look at the pair of patterns `[true, ..]` `[.., false]`\n-/// Then any slice of length \u22651 that matches one of these two patterns can be trivially turned to a\n-/// slice of any other length \u22651 that matches them and vice-versa, but the slice of length 2\n-/// `[false, true]` that matches neither of these patterns can't be turned to a slice from length 1\n-/// that matches neither of these patterns, so we have to consider slices from length 2 there.\n+/// This computes constructor splitting for variable-length slices, as explained at the top of the\n+/// file.\n ///\n-/// Now, to see that that length exists and find it, observe that slice patterns are either\n-/// \"fixed-length\" patterns (`[_, _, _]`) or \"variable-length\" patterns (`[_, .., _]`).\n+/// A slice pattern `[x, .., y]` behaves like the infinite or-pattern `[x, y] | [x, _, y] | [x, _,\n+/// _, y] | ...`. The corresponding value constructors are fixed-length array constructors above a\n+/// given minimum length. We obviously can't list all of this infinity of constructors. Thankfully,\n+/// it turns out that for each finite set of slice patterns, all sufficiently large array lengths\n+/// are equivalent.\n ///\n-/// For fixed-length patterns, all slices with lengths *longer* than the pattern's length have the\n-/// same outcome (of not matching), so as long as `L` is greater than the pattern's length we can\n-/// pick any `s\u2098` from that length and get the same result.\n+/// Let's look at an example, where we are trying to split the last pattern:\n+/// ```\n+/// match x {\n+///     [true, true, ..] => {}\n+///     [.., false, false] => {}\n+///     [..] => {}\n+/// }\n+/// ```\n+/// Here are the results of specialization for the first few lengths:\n+/// ```\n+/// // length 0\n+/// [] => {}\n+/// // length 1\n+/// [_] => {}\n+/// // length 2\n+/// [true, true] => {}\n+/// [false, false] => {}\n+/// [_, _] => {}\n+/// // length 3\n+/// [true, true,  _    ] => {}\n+/// [_,    false, false] => {}\n+/// [_,    _,     _    ] => {}\n+/// // length 4\n+/// [true, true, _,     _    ] => {}\n+/// [_,    _,    false, false] => {}\n+/// [_,    _,    _,     _    ] => {}\n+/// // length 5\n+/// [true, true, _, _,     _    ] => {}\n+/// [_,    _,    _, false, false] => {}\n+/// [_,    _,    _, _,     _    ] => {}\n+/// ```\n ///\n-/// For variable-length patterns, the situation is more complicated, because as seen above the\n-/// precise value of `s\u2098` matters.\n+/// If we went above length 5, we would simply be inserting more columns full of wildcards in the\n+/// middle. This means that the set of witnesses for length `l >= 5` if equivalent to the set for\n+/// any other `l' >= 5`: simply add or remove wildcards in the middle to convert between them.\n ///\n-/// However, for each variable-length pattern `p` with a prefix of length `pl\u209a` and suffix of\n-/// length `sl\u209a`, only the first `pl\u209a` and the last `sl\u209a` elements are examined.\n+/// This applies to any set of slice patterns: there will be a length `L` above which all length\n+/// behave the same. This is exactly what we need for constructor splitting. Therefore a\n+/// variable-length slice can be split into a variable-length slice of minimal length `L`, and many\n+/// fixed-length slices of lengths `< L`.\n ///\n-/// Therefore, as long as `L` is positive (to avoid concerns about empty types), all elements after\n-/// the maximum prefix length and before the maximum suffix length are not examined by any\n-/// variable-length pattern, and therefore can be added/removed without affecting them - creating\n-/// equivalent patterns from any sufficiently-large length.\n+/// For each variable-length pattern `p` with a prefix of length `pl\u209a` and suffix of length `sl\u209a`,\n+/// only the first `pl\u209a` and the last `sl\u209a` elements are examined. Therefore, as long as `L` is\n+/// positive (to avoid concerns about empty types), all elements after the maximum prefix length\n+/// and before the maximum suffix length are not examined by any variable-length pattern, and\n+/// therefore can be added/removed without affecting them - creating equivalent patterns from any\n+/// sufficiently-large length.\n ///\n /// Of course, if fixed-length patterns exist, we must be sure that our length is large enough to\n /// miss them all, so we can pick `L = max(max(FIXED_LEN)+1, max(PREFIX_LEN) + max(SUFFIX_LEN))`\n ///\n /// `max_slice` below will be made to have arity `L`.\n-///\n-/// For example, with the above pair of patterns, all elements but the first and last can be\n-/// added/removed, so any witness of length \u22652 (say, `[false, false, true]`) can be turned to a\n-/// witness from any other length \u22652.\n #[derive(Debug)]\n struct SplitVarLenSlice {\n     /// If the type is an array, this is its size.\n@@ -787,11 +841,19 @@ impl<'tcx> Constructor<'tcx> {\n \n /// A wildcard constructor that we split relative to the constructors in the matrix, as explained\n /// at the top of the file.\n-/// For splitting wildcards, there are two groups of constructors: there are the constructors\n-/// actually present in the matrix (`matrix_ctors`), and the constructors not present. Two\n-/// constructors that are not in the matrix will either both be covered (by a wildcard), or both\n-/// not be covered by any given row. Therefore we can keep the missing constructors grouped\n-/// together.\n+///\n+/// A constructor that is not present in the matrix rows will only be covered by the rows that have\n+/// wildcards. Thus we can group all of those constructors together; we call them \"missing\n+/// constructors\". Splitting a wildcard would therefore list all present constructors individually\n+/// (or grouped if they are integers or slices), and then all missing constructors together as a\n+/// group.\n+///\n+/// However we can go further: since any constructor will match the wildcard rows, and having more\n+/// rows can only reduce the amount of usefulness witnesses, we can skip the present constructors\n+/// and only try the missing ones.\n+/// This will not preserve the whole list of witnesses, but will preserve whether the list is empty\n+/// or not. In fact this is quite natural from the point of view of diagnostics too. This is done\n+/// in `to_ctors`: in some cases we only return `Missing`.\n #[derive(Debug)]\n pub(super) struct SplitWildcard<'tcx> {\n     /// Constructors seen in the matrix."}, {"sha": "424310842307267e50ffa262cf7273a6899cc57d", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 211, "deletions": 234, "changes": 445, "blob_url": "https://github.com/rust-lang/rust/blob/2a541cea354fe5866cf2addafe730c0d7c0dd0c2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a541cea354fe5866cf2addafe730c0d7c0dd0c2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=2a541cea354fe5866cf2addafe730c0d7c0dd0c2", "patch": "@@ -12,296 +12,272 @@\n //!\n //! -----\n //!\n-//! This file includes the logic for exhaustiveness and usefulness checking for\n-//! pattern-matching. Specifically, given a list of patterns for a type, we can\n-//! tell whether:\n-//! (a) the patterns cover every possible constructor for the type (exhaustiveness)\n-//! (b) each pattern is necessary (usefulness)\n+//! This file includes the logic for exhaustiveness and reachability checking for pattern-matching.\n+//! Specifically, given a list of patterns for a type, we can tell whether:\n+//! (a) each pattern is reachable (reachability)\n+//! (b) the patterns cover every possible value for the type (exhaustiveness)\n //!\n-//! The algorithm implemented here is a modified version of the one described in\n-//! [this paper](http://moscova.inria.fr/~maranget/papers/warn/index.html).\n-//! However, to save future implementors from reading the original paper, we\n-//! summarise the algorithm here to hopefully save time and be a little clearer\n-//! (without being so rigorous).\n+//! The algorithm implemented here is a modified version of the one described in [this\n+//! paper](http://moscova.inria.fr/~maranget/papers/warn/index.html). We have however generalized\n+//! it to accomodate the variety of patterns that rust supports. We thus explain our version here,\n+//! without being as rigorous.\n //!\n-//! # Premise\n //!\n-//! The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n-//! are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n-//! a matrix). `U(P, p)` represents whether, given an existing list of patterns\n-//! `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n-//! uncovered values of the type).\n+//! # Summary\n //!\n-//! If we have this predicate, then we can easily compute both exhaustiveness of an\n-//! entire set of patterns and the individual usefulness of each one.\n-//! (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n-//! match doesn't increase the number of values we're matching)\n-//! (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n-//! pattern to those that have come before it doesn't increase the number of values\n-//! we're matching).\n+//! The core of the algorithm is the notion of \"usefulness\". A pattern `q` is said to be *useful*\n+//! relative to another pattern `p` of the same type if there is a value that is matched by `q` and\n+//! not matched by `p`. This generalizes to many `p`s: `q` is useful wrt a list of patterns `p_1 ..\n+//! p_n` if there is a value that is matched by `q` and by none of the `p_i`. We write\n+//! `usefulness(p_1 .. p_n, q)` for a function that returns a list of such values. The aim of this\n+//! file is to compute it efficiently.\n //!\n-//! # Core concept\n+//! This is enough to compute reachability: a pattern in a `match` expression is reachable iff it\n+//! is useful wrt the patterns above it:\n+//! ```rust\n+//! match x {\n+//!     Some(_) => ...,\n+//!     None => ..., // reachable: `None` is matched by this but not the branch above\n+//!     Some(0) => ..., // unreachable: all the values this matches are already matched by\n+//!                     // `Some(_)` above\n+//! }\n+//! ```\n+//!\n+//! This is also enough to compute exhaustiveness: a match is exhaustive iff the wildcard `_`\n+//! pattern is _not_ useful wrt the patterns in the match. The values returned by `usefulness` are\n+//! used to tell the user which values are missing.\n+//! ```rust\n+//! match x {\n+//!     Some(0) => ...,\n+//!     None => ...,\n+//!     // not exhaustive: `_` is useful because it matches `Some(1)`\n+//! }\n+//! ```\n+//!\n+//! The entrypoint of this file is the [`compute_match_usefulness`] function, which computes\n+//! reachability for each match branch and exhaustiveness for the whole match.\n+//!\n+//!\n+//! # Constructors and fields\n+//!\n+//! Note: we will often abbreviate \"constructor\" as \"ctor\".\n //!\n-//! The idea that powers everything that is done in this file is the following: a value is made\n-//! from a constructor applied to some fields. Examples of constructors are `Some`, `None`, `(,)`\n-//! (the 2-tuple constructor), `Foo {..}` (the constructor for a struct `Foo`), and `2` (the\n-//! constructor for the number `2`). Fields are just a (possibly empty) list of values.\n+//! The idea that powers everything that is done in this file is the following: a (matcheable)\n+//! value is made from a constructor applied to a number of subvalues. Examples of constructors are\n+//! `Some`, `None`, `(,)` (the 2-tuple constructor), `Foo {..}` (the constructor for a struct\n+//! `Foo`), and `2` (the constructor for the number `2`). This is natural when we think of\n+//! pattern-matching, and this is the basis for what follows.\n //!\n-//! Some of the constructors listed above might feel weird: `None` and `2` don't take any\n-//! arguments. This is part of what makes constructors so general: we will consider plain values\n-//! like numbers and string literals to be constructors that take no arguments, also called \"0-ary\n-//! constructors\"; they are the simplest case of constructors. This allows us to see any value as\n-//! made up from a tree of constructors, each having a given number of children. For example:\n-//! `(None, Ok(0))` is made from 4 different constructors.\n+//! Some of the ctors listed above might feel weird: `None` and `2` don't take any arguments.\n+//! That's ok: those are ctors that take a list of 0 arguments; they are the simplest case of\n+//! ctors. We treat `2` as a ctor because `u64` and other number types behave exactly like a huge\n+//! `enum`, with one variant for each number. This allows us to see any matcheable value as made up\n+//! from a tree of ctors, each having a set number of children. For example: `Foo { bar: None,\n+//! baz: Ok(0) }` is made from 4 different ctors, namely `Foo{..}`, `None`, `Ok` and `0`.\n //!\n-//! This idea can be extended to patterns: a pattern captures a set of possible values, and we can\n-//! describe this set using constructors. For example, `Err(_)` captures all values of the type\n-//! `Result<T, E>` that start with the `Err` constructor (for some choice of `T` and `E`). The\n-//! wildcard `_` captures all values of the given type starting with any of the constructors for\n-//! that type.\n+//! This idea can be extended to patterns: they are also made from constructors applied to fields.\n+//! A pattern for a given type is allowed to use all the ctors for values of that type (which we\n+//! call \"value constructors\"), but there are also pattern-only ctors. The most important one is\n+//! the wildcard (`_`), and the others are integer ranges (`0..=10`), variable-length slices (`[x,\n+//! ..]`), and or-patterns (`Ok(0) | Err(_)`). Examples of valid patterns are `42`, `Some(_)`, `Foo\n+//! { bar: Some(0) | None, baz: _ }`. Note that a binder in a pattern (e.g. `Some(x)`) matches the\n+//! same values as a wildcard (e.g. `Some(_)`), so we treat both as wildcards.\n //!\n-//! We use this to compute whether different patterns might capture a same value. Do the patterns\n-//! `Ok(\"foo\")` and `Err(_)` capture a common value? The answer is no, because the first pattern\n-//! captures only values starting with the `Ok` constructor and the second only values starting\n-//! with the `Err` constructor. Do the patterns `Some(42)` and `Some(1..10)` intersect? They might,\n-//! since they both capture values starting with `Some`. To be certain, we need to dig under the\n-//! `Some` constructor and continue asking the question. This is the main idea behind the\n-//! exhaustiveness algorithm: by looking at patterns constructor-by-constructor, we can efficiently\n-//! figure out if some new pattern might capture a value that hadn't been captured by previous\n-//! patterns.\n+//! From this deconstruction we can compute whether a given value matches a given pattern; we\n+//! simply look at ctors one at a time. Given a pattern `p` and a value `v`, we want to compute\n+//! `matches!(v, p)`. It's mostly straightforward: we compare the head ctors and when they match\n+//! we compare their fields recursively. A few representative examples:\n //!\n-//! Constructors are represented by the `Constructor` enum, and its fields by the `Fields` enum.\n-//! Most of the complexity of this file resides in transforming between patterns and\n-//! (`Constructor`, `Fields`) pairs, handling all the special cases correctly.\n+//! - `matches!(v, _) := true`\n+//! - `matches!((v0,  v1), (p0,  p1)) := matches!(v0, p0) && matches!(v1, p1)`\n+//! - `matches!(Foo { bar: v0, baz: v1 }, Foo { bar: p0, baz: p1 }) := matches!(v0, p0) && matches!(v1, p1)`\n+//! - `matches!(Ok(v0), Ok(p0)) := matches!(v0, p0)`\n+//! - `matches!(Ok(v0), Err(p0)) := false` (incompatible variants)\n+//! - `matches!(v, 1..=100) := matches!(v, 1) || ... || matches!(v, 100)`\n+//! - `matches!([v0], [p0, .., p1]) := false` (incompatible lengths)\n+//! - `matches!([v0, v1, v2], [p0, .., p1]) := matches!(v0, p0) && matches!(v2, p1)`\n+//! - `matches!(v, p0 | p1) := matches!(v, p0) || matches!(v, p1)`\n //!\n-//! Caveat: this constructors/fields distinction doesn't quite cover every Rust value. For example\n-//! a value of type `Rc<u64>` doesn't fit this idea very well, nor do various other things.\n-//! However, this idea covers most of the cases that are relevant to exhaustiveness checking.\n+//! Constructors, fields and relevant operations are defined in the [`super::deconstruct_pat`] module.\n //!\n+//! Note: this constructors/fields distinction may not straightforwardly apply to every Rust type.\n+//! For example a value of type `Rc<u64>` can't be deconstructed that way, and `&str` has an\n+//! infinity of constructors. There are also subtleties with visibility of fields and\n+//! uninhabitedness and various other things. The constructors idea can be extended to handle most\n+//! of these subtleties though; caveats are documented where relevant throughout the code.\n //!\n-//! # Algorithm\n+//! Whether constructors cover each other is computed by [`Constructor::is_covered_by`].\n //!\n-//! Recall that `U(P, p)` represents whether, given an existing list of patterns (aka matrix) `P`,\n-//! adding a new pattern `p` will cover previously-uncovered values of the type.\n-//! During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n-//! but rather partially-deconstructed patterns in the form of a list of fields. The paper\n-//! calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n-//! new pattern `p`.\n //!\n-//! For example, say we have the following:\n+//! # Specialization\n //!\n+//! Recall that we wish to compute `usefulness(p_1 .. p_n, q)`: given a list of patterns `p_1 ..\n+//! p_n` and a pattern `q`, all of the same type, we want to find a list of values (called\n+//! \"witnesses\") that are matched by `q` and by none of the `p_i`. We obviously don't just\n+//! enumerate all possible values. From the discussion above we see that we can proceed\n+//! ctor-by-ctor: for each value ctor of the given type, we ask \"is there a value that starts with\n+//! this constructor and matches `q` and none of the `p_i`?\". As we saw above, there's a lot we can\n+//! say from knowing only the first constructor of our candidate value.\n+//!\n+//! Let's take the following example:\n //! ```\n-//! // x: (Option<bool>, Result<()>)\n //! match x {\n-//!     (Some(true), _) => {}\n-//!     (None, Err(())) => {}\n-//!     (None, Err(_)) => {}\n+//!     Enum::Variant1(_) => {} // `p1`\n+//!     Enum::Variant2(None, 0) => {} // `p2`\n+//!     Enum::Variant2(Some(_), 0) => {} // `q`\n //! }\n //! ```\n //!\n-//! Here, the matrix `P` starts as:\n+//! We can easily see that if our candidate value `v` starts with `Variant1` it will not match `q`.\n+//! If `v = Variant2(v0, v1)` however, whether or not it matches `p2` and `q` will depend on `v0`\n+//! and `v1`. In fact, such a `v` will be a witness of usefulness of `q` exactly when the tuple\n+//! `(v0, v1)` is a witness of usefulness of `q'` in the following reduced match:\n //!\n //! ```\n-//! [\n-//!     [(Some(true), _)],\n-//!     [(None, Err(()))],\n-//!     [(None, Err(_))],\n-//! ]\n+//! match x {\n+//!     (None, 0) => {} // `p2'`\n+//!     (Some(_), 0) => {} // `q'`\n+//! }\n //! ```\n //!\n-//! We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n-//! `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n-//! all the values it covers are already covered by row 2.\n+//! This motivates a new step in computing usefulness, that we call _specialization_.\n+//! Specialization consist of filtering a list of patterns for those that match a constructor, and\n+//! then looking into the constructor's fields. This enables usefulness to be computed recursively.\n //!\n-//! A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n-//! the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n-//! To match the paper, the top of the stack is at the beginning / on the left.\n+//! Instead of acting on a single pattern in each row, we will consider a list of patterns for each\n+//! row, and we call such a list a _pattern-stack_. The idea is that we will specialize the\n+//! leftmost pattern, which amounts to popping the constructor and pushing its fields, which feels\n+//! like a stack. We note a pattern-stack simply with `[p_1 ... p_n]`.\n+//! Here's a sequence of specializations of a list of pattern-stacks, to illustrate what's\n+//! happening:\n+//! ```\n+//! [Enum::Variant1(_)]\n+//! [Enum::Variant2(None, 0)]\n+//! [Enum::Variant2(Some(_), 0)]\n+//! //==>> specialize with `Variant2`\n+//! [None, 0]\n+//! [Some(_), 0]\n+//! //==>> specialize with `Some`\n+//! [_, 0]\n+//! //==>> specialize with `true` (say the type was `bool`)\n+//! [0]\n+//! //==>> specialize with `0`\n+//! []\n+//! ```\n //!\n-//! There are two important operations on pattern-stacks necessary to understand the algorithm:\n+//! The function `specialize(c, p)` takes a value constructor `c` and a pattern `p`, and returns 0\n+//! or more pattern-stacks. If `c` does not match the head constructor of `p`, it returns nothing;\n+//! otherwise if returns the fields of the constructor. This only returns more than one\n+//! pattern-stack if `p` has a pattern-only constructor.\n //!\n-//! 1. We can pop a given constructor off the top of a stack. This operation is called\n-//!    `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n-//!    `None`) and `p` a pattern-stack.\n-//!    If the pattern on top of the stack can cover `c`, this removes the constructor and\n-//!    pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n-//!    Otherwise the pattern-stack is discarded.\n-//!    This essentially filters those pattern-stacks whose top covers the constructor `c` and\n-//!    discards the others.\n+//! - Specializing for the wrong constructor returns nothing\n //!\n-//!    For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n-//!    pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n-//!    `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n-//!    nothing back.\n+//!   `specialize(None, Some(p0)) := []`\n //!\n-//!    This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n-//!    on top of the stack, and we have four cases:\n+//! - Specializing for the correct constructor returns a single row with the fields\n //!\n-//!      1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n-//!           push onto the stack the arguments of this constructor, and return the result:\n-//!              `r_1, .., r_a, p_2, .., p_n`\n+//!   `specialize(Variant1, Variant1(p0, p1, p2)) := [[p0, p1, p2]]`\n //!\n-//!      1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n-//!           return nothing.\n+//!   `specialize(Foo{..}, Foo { bar: p0, baz: p1 }) := [[p0, p1]]`\n //!\n-//!         1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n-//!              arguments (its arity), and return the resulting stack:\n-//!                 `_, .., _, p_2, .., p_n`\n+//! - For or-patterns, we specialize each branch and concatenate the results\n //!\n-//!         1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-//!              stack:\n-//!                 - `S(c, (r_1, p_2, .., p_n))`\n-//!                 - `S(c, (r_2, p_2, .., p_n))`\n+//!   `specialize(c, p0 | p1) := specialize(c, p0) ++ specialize(c, p1)`\n //!\n-//! 2. We can pop a wildcard off the top of the stack. This is called `S(_, p)`, where `p` is\n-//!    a pattern-stack. Note: the paper calls this `D(p)`.\n-//!    This is used when we know there are missing constructor cases, but there might be\n-//!    existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n-//!    all its *other* components.\n+//! - We treat the other pattern constructors lik big or-patterns of all the possibilities:\n //!\n-//!    It is computed as follows. We look at the pattern `p_1` on top of the stack,\n-//!    and we have three cases:\n-//!         2.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n-//!         2.2. `p_1 = _`. We return the rest of the stack:\n-//!                 p_2, .., p_n\n-//!         2.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-//!           stack.\n-//!                 - `S(_, (r_1, p_2, .., p_n))`\n-//!                 - `S(_, (r_2, p_2, .., p_n))`\n+//!   `specialize(c, _) := specialize(c, Variant1(_) | Variant2(_, _) | ...)`\n //!\n-//! Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n-//! exhaustive integer matching rules, so they're written here for posterity.\n+//!   `specialize(c, 1..=100) := specialize(c, 1 | ... | 100)`\n //!\n-//! Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n-//! working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n-//! the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n+//!   `specialize(c, [p0, .., p1]) := specialize(c, [p0, p1] | [p0, _, p1] | [p0, _, _, p1] | ...)`\n //!\n+//! - If `c` is a pattern-only constructor, `specialize` is defined on a case-by-case basis. See\n+//!   the discussion abount constructor splitting in [`super::deconstruct_pat`].\n //!\n-//! The algorithm for computing `U`\n-//! -------------------------------\n-//! The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n-//! That means we're going to check the components from left-to-right, so the algorithm\n-//! operates principally on the first component of the matrix and new pattern-stack `p`.\n-//! This algorithm is realised in the `is_useful` function.\n //!\n-//! Base case. (`n = 0`, i.e., an empty tuple pattern)\n-//!     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n-//!       then `U(P, p)` is false.\n-//!     - Otherwise, `P` must be empty, so `U(P, p)` is true.\n+//! We then extend this function to work with pattern-stacks as input, by acting on the first\n+//! column and keeping the other columns untouched.\n //!\n-//! Inductive step. (`n > 0`, i.e., whether there's at least one column\n-//!                  [which may then be expanded into further columns later])\n-//! We're going to match on the top of the new pattern-stack, `p_1`.\n-//!     - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n-//! Then, the usefulness of `p_1` can be reduced to whether it is useful when\n-//! we ignore all the patterns in the first column of `P` that involve other constructors.\n-//! This is where `S(c, P)` comes in:\n-//! `U(P, p) := U(S(c, P), S(c, p))`\n+//! Specialization for the whole matrix is done in [`Matrix::specialize_constructor`]. Note that\n+//! or-patterns in the first column are expanded before being stored in the matrix. Specialization\n+//! for a single patstack is done from a combination of [`Constructor::is_covered_by`] and\n+//! [`PatStack::pop_head_constructor`]. The internals of how it's done mostly live in the\n+//! [`Fields`] struct.\n //!\n-//! For example, if `P` is:\n //!\n-//! ```\n-//! [\n-//!     [Some(true), _],\n-//!     [None, 0],\n-//! ]\n-//! ```\n+//! # Computing usefulness\n //!\n-//! and `p` is `[Some(false), 0]`, then we don't care about row 2 since we know `p` only\n-//! matches values that row 2 doesn't. For row 1 however, we need to dig into the\n-//! arguments of `Some` to know whether some new value is covered. So we compute\n-//! `U([[true, _]], [false, 0])`.\n+//! We now have all we need to compute usefulness. The inputs to usefulness are a list of\n+//! pattern-stacks `p_1 ... p_n` (one per row), and a new pattern_stack `q`. The paper and this\n+//! file calls the list of patstacks a _matrix_. They must all have the same number of columns and\n+//! the patterns in a given column must all have the same type. `usefulness` returns a (possibly\n+//! empty) list of witnesses of usefulness. These witnesses will also be pattern-stacks.\n //!\n-//!   - If `p_1 == _`, then we look at the list of constructors that appear in the first\n-//! component of the rows of `P`:\n-//!   + If there are some constructors that aren't present, then we might think that the\n-//! wildcard `_` is useful, since it covers those constructors that weren't covered\n-//! before.\n-//! That's almost correct, but only works if there were no wildcards in those first\n-//! components. So we need to check that `p` is useful with respect to the rows that\n-//! start with a wildcard, if there are any. This is where `S(_, x)` comes in:\n-//! `U(P, p) := U(S(_, P), S(_, p))`\n+//! - base case: `n_columns == 0`.\n+//!     Since a pattern-stack functions like a tuple of patterns, an empty one functions like the\n+//!     unit type. Thus `q` is useful iff there are no rows above it, i.e. if `n == 0`.\n //!\n-//! For example, if `P` is:\n+//! - inductive case: `n_columns > 0`.\n+//!     We need a way to list the constructors we want to try. We will be more clever in the next\n+//!     section but for now assume we list all value constructors for the type of the first column.\n //!\n-//! ```\n-//! [\n-//!     [_, true, _],\n-//!     [None, false, 1],\n-//! ]\n-//! ```\n+//!     - for each such ctor `c`:\n //!\n-//! and `p` is `[_, false, _]`, the `Some` constructor doesn't appear in `P`. So if we\n-//! only had row 2, we'd know that `p` is useful. However row 1 starts with a\n-//! wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n+//!         - for each `q'` returned by `specialize(c, q)`:\n //!\n-//!   + Otherwise, all possible constructors (for the relevant type) are present. In this\n-//! case we must check whether the wildcard pattern covers any unmatched value. For\n-//! that, we can think of the `_` pattern as a big OR-pattern that covers all\n-//! possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n-//! example. The wildcard pattern is useful in this case if it is useful when\n-//! specialized to one of the possible constructors. So we compute:\n-//! `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n+//!             - we compute `usefulness(specialize(c, p_1) ... specialize(c, p_n), q')`\n //!\n-//! For example, if `P` is:\n+//!         - for each witness found, we revert specialization by pushing the constructor `c` on top.\n //!\n+//!     - We return the concatenation of all the witnesses found, if any.\n+//!\n+//! Example:\n //! ```\n-//! [\n-//!     [Some(true), _],\n-//!     [None, false],\n-//! ]\n+//! [Some(true)] // p_1\n+//! [None] // p_2\n+//! [Some(_)] // q\n+//! //==>> try `None`: `specialize(None, q)` returns nothing\n+//! //==>> try `Some`: `specialize(Some, q)` returns a single row\n+//! [true] // p_1'\n+//! [_] // q'\n+//! //==>> try `true`: `specialize(true, q')` returns a single row\n+//! [] // p_1''\n+//! [] // q''\n+//! //==>> base case; `n != 0` so `q''` is not useful.\n+//! //==>> go back up a step\n+//! [true] // p_1'\n+//! [_] // q'\n+//! //==>> try `false`: `specialize(false, q')` returns a single row\n+//! [] // q''\n+//! //==>> base case; `n == 0` so `q''` is useful. We return the single witness `[]`\n+//! witnesses:\n+//! []\n+//! //==>> undo the specialization with `false`\n+//! witnesses:\n+//! [false]\n+//! //==>> undo the specialization with `Some`\n+//! witnesses:\n+//! [Some(false)]\n+//! //==>> we have tried all the constructors. The output is the single witness `[Some(false)]`.\n //! ```\n //!\n-//! and `p` is `[_, false]`, both `None` and `Some` constructors appear in the first\n-//! components of `P`. We will therefore try popping both constructors in turn: we\n-//! compute `U([[true, _]], [_, false])` for the `Some` constructor, and `U([[false]],\n-//! [false])` for the `None` constructor. The first case returns true, so we know that\n-//! `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n-//! before.\n+//! This computation is done in [`is_useful`]. In practice we don't care about the list of\n+//! witnesses when computing reachability; we only need to know whether any exist. We do keep the\n+//! witnesses when computing exhaustiveness to report them to the user.\n+//!\n //!\n-//!   - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n-//! `U(P, p) := U(P, (r_1, p_2, .., p_n))\n-//!  || U(P, (r_2, p_2, .., p_n))`\n+//! # Making usefulness tractable: constructor splitting\n //!\n-//! Modifications to the algorithm\n-//! ------------------------------\n-//! The algorithm in the paper doesn't cover some of the special cases that arise in Rust, for\n-//! example uninhabited types and variable-length slice patterns. These are drawn attention to\n-//! throughout the code below. I'll make a quick note here about how exhaustive integer matching is\n-//! accounted for, though.\n+//! We're missing one last detail: which constructors do we list? Naively listing all value\n+//! constructors cannot work for types like `u64` or `&str`, so we need to be more clever. The\n+//! first obvious insight is that we only want to list constructors that are covered by the head\n+//! constructor of `q`. If it's a value constructor, we only try that one. If it's a pattern-only\n+//! constructor, we use the final clever idea for this algorithm: _constructor splitting_, where we\n+//! group together constructors that behave the same.\n //!\n-//! Exhaustive integer matching\n-//! ---------------------------\n-//! An integer type can be thought of as a (huge) sum type: 1 | 2 | 3 | ...\n-//! So to support exhaustive integer matching, we can make use of the logic in the paper for\n-//! OR-patterns. However, we obviously can't just treat ranges x..=y as individual sums, because\n-//! they are likely gigantic. So we instead treat ranges as constructors of the integers. This means\n-//! that we have a constructor *of* constructors (the integers themselves). We then need to work\n-//! through all the inductive step rules above, deriving how the ranges would be treated as\n-//! OR-patterns, and making sure that they're treated in the same way even when they're ranges.\n-//! There are really only four special cases here:\n-//! - When we match on a constructor that's actually a range, we have to treat it as if we would\n-//!   an OR-pattern.\n-//!     + It turns out that we can simply extend the case for single-value patterns in\n-//!      `specialize` to either be *equal* to a value constructor, or *contained within* a range\n-//!      constructor.\n-//!     + When the pattern itself is a range, you just want to tell whether any of the values in\n-//!       the pattern range coincide with values in the constructor range, which is precisely\n-//!       intersection.\n-//!   Since when encountering a range pattern for a value constructor, we also use inclusion, it\n-//!   means that whenever the constructor is a value/range and the pattern is also a value/range,\n-//!   we can simply use intersection to test usefulness.\n-//! - When we're testing for usefulness of a pattern and the pattern's first component is a\n-//!   wildcard.\n-//!     + If all the constructors appear in the matrix, we have a slight complication. By default,\n-//!       the behaviour (i.e., a disjunction over specialised matrices for each constructor) is\n-//!       invalid, because we want a disjunction over every *integer* in each range, not just a\n-//!       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n-//!       to form equivalence classes of subranges of the constructor range for which the behaviour\n-//!       of the matrix `P` and new pattern `p` are the same. This is described in more\n-//!       detail in `Constructor::split`.\n-//!     + If some constructors are missing from the matrix, it turns out we don't need to do\n-//!       anything special (because we know none of the integers are actually wildcards: i.e., we\n-//!       can't span wildcards using ranges).\n+//! The details are not necessary to understand this file, so we explain them in\n+//! [`super::deconstruct_pat`]. Splitting is done by the [`Constructor::split`] function.\n \n use self::Usefulness::*;\n use self::WitnessPreference::*;\n@@ -1025,7 +1001,7 @@ fn is_useful<'p, 'tcx>(\n /// The arm of a match expression.\n #[derive(Clone, Copy)]\n crate struct MatchArm<'p, 'tcx> {\n-    /// The pattern must have been lowered through `MatchVisitor::lower_pattern`.\n+    /// The pattern must have been lowered through `check_match::MatchVisitor::lower_pattern`.\n     crate pat: &'p super::Pat<'tcx>,\n     crate hir_id: HirId,\n     crate has_guard: bool,\n@@ -1043,7 +1019,8 @@ crate struct UsefulnessReport<'p, 'tcx> {\n /// The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which\n /// of its arms are reachable.\n ///\n-/// Note: the input patterns must have been lowered through `MatchVisitor::lower_pattern`.\n+/// Note: the input patterns must have been lowered through\n+/// `check_match::MatchVisitor::lower_pattern`.\n crate fn compute_match_usefulness<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     arms: &[MatchArm<'p, 'tcx>],"}]}