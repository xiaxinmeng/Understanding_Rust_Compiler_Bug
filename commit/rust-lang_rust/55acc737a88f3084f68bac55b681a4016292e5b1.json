{"sha": "55acc737a88f3084f68bac55b681a4016292e5b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1YWNjNzM3YTg4ZjMwODRmNjhiYWM1NWI2ODFhNDAxNjI5MmU1YjE=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-21T22:08:15Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-21T22:12:27Z"}, "message": "Remove vestiges of typarams from anon objs.", "tree": {"sha": "53fe6f97a5bd930897722845412444aa72c802b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53fe6f97a5bd930897722845412444aa72c802b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55acc737a88f3084f68bac55b681a4016292e5b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55acc737a88f3084f68bac55b681a4016292e5b1", "html_url": "https://github.com/rust-lang/rust/commit/55acc737a88f3084f68bac55b681a4016292e5b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55acc737a88f3084f68bac55b681a4016292e5b1/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f33309502a10bc41685e08a23f282b74f61b7f89", "url": "https://api.github.com/repos/rust-lang/rust/commits/f33309502a10bc41685e08a23f282b74f61b7f89", "html_url": "https://github.com/rust-lang/rust/commit/f33309502a10bc41685e08a23f282b74f61b7f89"}], "stats": {"total": 112, "additions": 35, "deletions": 77}, "files": [{"sha": "abde1ebc9a8f7aa7eb01ddd4392053977374f9a0", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 22, "deletions": 59, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=55acc737a88f3084f68bac55b681a4016292e5b1", "patch": "@@ -5847,8 +5847,8 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n         case (ast::expr_spawn(?dom, ?name, ?func, ?args)) {\n             ret trans_spawn(cx, dom, name, func, args, e.id);\n         }\n-        case (ast::expr_anon_obj(?anon_obj, ?tps)) {\n-            ret trans_anon_obj(cx, e.span, anon_obj, tps, e.id);\n+        case (ast::expr_anon_obj(?anon_obj)) {\n+            ret trans_anon_obj(cx, e.span, anon_obj, e.id);\n         }\n         case (_) {\n             // The expression is an lvalue. Fall through.\n@@ -6222,15 +6222,9 @@ fn trans_be(&@block_ctxt cx, &@ast::expr e) -> result {\n // instead \"inlining\" the construction of the object and returning the object\n // itself.\n fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n-                  &ast::ty_param[] ty_params, ast::node_id id) -> result {\n+                  ast::node_id id) -> result {\n \n-    // Right now, we're assuming that anon objs don't take ty params, even\n-    // though the AST supports it.  It's nonsensical to write an expression\n-    // like \"obj[T](){ ... with ... }\", since T is never instantiated;\n-    // nevertheless, such an expression will parse.  Idea for the future:\n-    // support typarams.\n \n-    assert (std::ivec::len(ty_params) == 0u);\n     auto ccx = bcx.fcx.lcx.ccx;\n \n     // Fields.\n@@ -6286,7 +6280,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n             // is that, since *all* of the methods are \"additional\", we can\n             // get away with acting like none of them are.\n             vtbl = create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty,\n-                               wrapper_obj, ty_params, none,\n+                               wrapper_obj, ~[], none,\n                                additional_field_tys);\n         }\n         case (some(?e)) {\n@@ -6304,8 +6298,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n             // create a forwarding slot.  And, of course, we need to create a\n             // normal vtable entry for every method being added.\n             vtbl = create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty,\n-                               wrapper_obj, ty_params,\n-                               some(with_obj_ty),\n+                               wrapper_obj, ~[], some(with_obj_ty),\n                                additional_field_tys);\n         }\n     }\n@@ -6333,27 +6326,22 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     // typarams, fields, and a pointer to our with_obj.\n     let TypeRef llbox_ty = T_ptr(T_empty_struct());\n \n-    if (std::ivec::len[ast::ty_param](ty_params) == 0u &&\n-        std::ivec::len[ast::anon_obj_field](additional_fields) == 0u &&\n+    if (std::ivec::len[ast::anon_obj_field](additional_fields) == 0u &&\n         anon_obj.with_obj == none) {\n-        // If the object we're translating has no fields or type parameters\n-        // and no with_obj, there's not much to do.\n+        // If the object we're translating has no fields and no with_obj,\n+        // there's not much to do.\n         bcx.build.Store(C_null(llbox_ty), pair_box);\n     } else {\n \n         // Synthesize a tuple type for fields: [field, ...]\n         let ty::t fields_ty = ty::mk_imm_tup(ccx.tcx, additional_field_tys);\n \n-        // Tydescs are run-time instantiations of typarams.  We're not\n-        // actually supporting typarams for anon objs yet, but let's\n-        // create space for them in case we ever want them.\n+        // Type for tydescs.\n         let ty::t tydesc_ty = ty::mk_type(ccx.tcx);\n-        let ty::t[] tps = ~[];\n-        for (ast::ty_param tp in ty_params) {\n-            tps += ~[tydesc_ty];\n-        }\n-        // Synthesize a tuple type for typarams: [typaram, ...]\n-        let ty::t typarams_ty = ty::mk_imm_tup(ccx.tcx, tps);\n+\n+        // Placeholder for non-existent typarams, since anon objs don't have\n+        // them.\n+        let ty::t typarams_ty = ty::mk_imm_tup(ccx.tcx, ~[]);\n \n         // Tuple type for body:\n         // [tydesc_ty, [typaram, ...], [field, ...], with_obj]\n@@ -6402,35 +6390,15 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n         bcx = body_td.bcx;\n         bcx.build.Store(body_td.val, body_tydesc.val);\n \n-        // Copy the object's type parameters and fields into the space we\n-        // allocated for the object body.  (This is something like saving the\n-        // lexical environment of a function in its closure: the \"captured\n-        // typarams\" are any type parameters that are passed to the object\n-        // constructor and are then available to the object's methods.\n-        // Likewise for the object's fields.)\n-\n-        // Copy typarams into captured typarams.\n-        auto body_typarams =\n-            GEP_tup_like(bcx, body_ty, body.val,\n-                         ~[0, abi::obj_body_elt_typarams]);\n-        bcx = body_typarams.bcx;\n-        let int i = 0;\n-        for (ast::ty_param tp in ty_params) {\n-            auto typaram = bcx.fcx.lltydescs.(i);\n-            auto capture =\n-                GEP_tup_like(bcx, typarams_ty, body_typarams.val, ~[0, i]);\n-            bcx = capture.bcx;\n-            bcx = copy_val(bcx, INIT, capture.val, typaram,\n-                           tydesc_ty).bcx;\n-            i += 1;\n-        }\n-\n-        // Copy additional fields into the object's body.\n+        // Copy the object's fields into the space we allocated for the object\n+        // body.  (This is something like saving the lexical environment of a\n+        // function in its closure: the fields were passed to the object\n+        // constructor and are now available to the object's methods.\n         auto body_fields =\n             GEP_tup_like(bcx, body_ty, body.val,\n                          ~[0, abi::obj_body_elt_fields]);\n         bcx = body_fields.bcx;\n-        i = 0;\n+        let int i = 0;\n         for (ast::anon_obj_field f in additional_fields) {\n             // FIXME (part of issue #538): make this work eventually, when we\n             // have additional field exprs in the AST.\n@@ -7182,16 +7150,11 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n     // Synthesize a tuple type for fields: [field, ...]\n     let ty::t fields_ty = ty::mk_imm_tup(cx.ccx.tcx, additional_field_tys);\n \n-    // Tydescs are run-time instantiations of typarams.  We're not\n-    // actually supporting typarams for anon objs yet, but let's\n-    // create space for them in case we ever want them.\n+    // Type for tydescs.\n     let ty::t tydesc_ty = ty::mk_type(cx.ccx.tcx);\n-    let ty::t[] tps = ~[];\n-    for (ast::ty_param tp in ty_params) {\n-        tps += ~[tydesc_ty];\n-    }\n-    // Synthesize a tuple type for typarams: [typaram, ...]\n-    let ty::t typarams_ty = ty::mk_imm_tup(cx.ccx.tcx, tps);\n+\n+    // Placeholder for non-existent typarams, since anon objs don't have them.\n+    let ty::t typarams_ty = ty::mk_imm_tup(cx.ccx.tcx, ~[]);\n \n     // Tuple type for body:\n     // [tydesc_ty, [typaram, ...], [field, ...], with_obj]"}, {"sha": "6065b5fa2b23d167f51f70295bd63659a1f3c9c3", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=55acc737a88f3084f68bac55b681a4016292e5b1", "patch": "@@ -567,7 +567,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n         case (expr_mac(_)) {\n             fcx.ccx.tcx.sess.bug(\"unexpanded macro\");\n         }\n-        case (expr_anon_obj(?anon_obj, _)) {\n+        case (expr_anon_obj(?anon_obj)) {\n             alt (anon_obj.with_obj) {\n                 case (some(?ex)) {\n                     find_pre_post_expr(fcx, ex);"}, {"sha": "88b21748a3f1d1571f94a8af287c74ccf80c793b", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=55acc737a88f3084f68bac55b681a4016292e5b1", "patch": "@@ -564,7 +564,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         case (expr_cont) { ret pure_exp(fcx.ccx, e.id, pres); }\n         case (expr_port(_)) { ret pure_exp(fcx.ccx, e.id, pres); }\n         case (expr_self_method(_)) { ret pure_exp(fcx.ccx, e.id, pres); }\n-        case (expr_anon_obj(?anon_obj, _)) {\n+        case (expr_anon_obj(?anon_obj)) {\n             alt (anon_obj.with_obj) {\n                 case (some(?wt)) {\n                     ret find_pre_post_state_sub(fcx, pres, wt, e.id, none);"}, {"sha": "e76bef2cf0ce446ee6c8c6bbf696d0859462a6da", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=55acc737a88f3084f68bac55b681a4016292e5b1", "patch": "@@ -2395,7 +2395,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n         }\n-        case (ast::expr_anon_obj(?ao, ?tps)) {\n+        case (ast::expr_anon_obj(?ao)) {\n \n             let ast::anon_obj_field[] fields = ~[];\n             alt (ao.fields) {\n@@ -2432,8 +2432,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n             fn get_anon_obj_method_types(@fn_ctxt fcx,\n                                          &ast::anon_obj ao,\n-                                         &ast::anon_obj_field[] fields,\n-                                         &ast::ty_param[] tps)\n+                                         &ast::anon_obj_field[] fields)\n                 -> ty::method[] {\n \n                 let ty::method[] methods = ~[];\n@@ -2495,7 +2494,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n \n             auto method_types = get_anon_obj_method_types(fcx, ao,\n-                                                          fields, tps);\n+                                                          fields);\n             auto ot = ty::mk_obj(fcx.ccx.tcx, ty::sort_methods(method_types));\n \n             write::ty_only_fixup(fcx, id, ot);"}, {"sha": "e710a8b2b849128c2a70b1ed54467281bbd4842e", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=55acc737a88f3084f68bac55b681a4016292e5b1", "patch": "@@ -325,7 +325,7 @@ tag expr_ {\n     expr_if_check(@expr, block, option::t[@expr]);\n     expr_port(option::t[@ty]);\n     expr_chan(@expr);\n-    expr_anon_obj(anon_obj, ty_param[]);\n+    expr_anon_obj(anon_obj);\n     expr_mac(mac);\n }\n "}, {"sha": "812542bb114416ae85ef7774dfe5c34923522798", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=55acc737a88f3084f68bac55b681a4016292e5b1", "patch": "@@ -458,8 +458,8 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n                 })\n                 }\n         case (expr_chan(?e)) { expr_chan(fld.fold_expr(e)) }\n-        case (expr_anon_obj(?ao, ?typms)) {\n-            expr_anon_obj(fold_anon_obj(ao), typms)\n+        case (expr_anon_obj(?ao)) {\n+            expr_anon_obj(fold_anon_obj(ao))\n                 }\n         case (expr_mac(?mac)) {\n             expr_mac(fold_mac(mac))"}, {"sha": "a0863319b8ddf387a90a7489a85932735fbade02", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=55acc737a88f3084f68bac55b681a4016292e5b1", "patch": "@@ -833,9 +833,6 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n     } else if (eat_word(p, \"obj\")) {\n         // Anonymous object\n \n-        // FIXME: Can anonymous objects have ty params?\n-        auto ty_params = parse_ty_params(p);\n-\n         // Only make people type () if they're actually adding new fields\n         let option::t[ast::anon_obj_field[]] fields = none;\n         if (p.peek() == token::LPAREN) {\n@@ -864,7 +861,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         // \"spanned\".\n         let ast::anon_obj ob =\n             rec(fields=fields, methods=meths, with_obj=with_obj);\n-        ex = ast::expr_anon_obj(ob, ty_params);\n+        ex = ast::expr_anon_obj(ob);\n     } else if (eat_word(p, \"rec\")) {\n         expect(p, token::LPAREN);\n         auto fields = ~[parse_field(p)];\n@@ -1686,7 +1683,7 @@ fn stmt_ends_with_semi(&ast::stmt stmt) -> bool {\n                 case (ast::expr_if_check(_, _, _)) { false }\n                 case (ast::expr_port(_)) { true }\n                 case (ast::expr_chan(_)) { true }\n-                case (ast::expr_anon_obj(_,_)) { false }\n+                case (ast::expr_anon_obj(_)) { false }\n                 case (ast::expr_assert(_)) { true }\n             }\n         }"}, {"sha": "32ef2e2f4716b57ab67cc99479a37a8ed73c51e7", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=55acc737a88f3084f68bac55b681a4016292e5b1", "patch": "@@ -986,9 +986,8 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             print_expr(s, expr);\n             pclose(s);\n         }\n-        case (ast::expr_anon_obj(?anon_obj, ?tps)) {\n+        case (ast::expr_anon_obj(?anon_obj)) {\n             head(s, \"obj\");\n-            print_type_params(s, tps);\n \n             // Fields\n             popen(s);"}, {"sha": "6893250ac0096fcef097f6fc730cc5a9d8ded51b", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=55acc737a88f3084f68bac55b681a4016292e5b1", "patch": "@@ -395,7 +395,7 @@ fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n         case (expr_assert(?x)) { v.visit_expr(x, e, v); }\n         case (expr_port(?t)) { visit_ty_opt(t, e, v); }\n         case (expr_chan(?x)) { v.visit_expr(x, e, v); }\n-        case (expr_anon_obj(?anon_obj, _)) {\n+        case (expr_anon_obj(?anon_obj)) {\n             alt (anon_obj.fields) {\n                 case (none) { }\n                 case (some(?fields)) {"}, {"sha": "6f993f960a910846bd7e15ddff378416279c85fe", "filename": "src/comp/syntax/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fsyntax%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55acc737a88f3084f68bac55b681a4016292e5b1/src%2Fcomp%2Fsyntax%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fwalk.rs?ref=55acc737a88f3084f68bac55b681a4016292e5b1", "patch": "@@ -388,7 +388,7 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n         case (ast::expr_assert(?x)) { walk_expr(v, x); }\n         case (ast::expr_port(_)) { }\n         case (ast::expr_chan(?x)) { walk_expr(v, x); }\n-        case (ast::expr_anon_obj(?anon_obj, _)) {\n+        case (ast::expr_anon_obj(?anon_obj)) {\n             // Fields\n \n             alt (anon_obj.fields) {"}]}