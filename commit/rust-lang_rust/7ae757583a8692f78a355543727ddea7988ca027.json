{"sha": "7ae757583a8692f78a355543727ddea7988ca027", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhZTc1NzU4M2E4NjkyZjc4YTM1NTU0MzcyN2RkZWE3OTg4Y2EwMjc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-24T22:25:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-26T01:01:52Z"}, "message": "Begin documenting std and add doc generation using naturaldocs\n\nNaturaldocs isn't really that great but it seems easier to get\nsomething working than with doxygen, for which we would need to\nconvert rust code to something C++ish. We probably want to just\nwrite a rustdoc utility at some point.", "tree": {"sha": "7a4f49f5d1e41150d048bcb57f50d8c1007ecd6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a4f49f5d1e41150d048bcb57f50d8c1007ecd6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ae757583a8692f78a355543727ddea7988ca027", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ae757583a8692f78a355543727ddea7988ca027", "html_url": "https://github.com/rust-lang/rust/commit/7ae757583a8692f78a355543727ddea7988ca027", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ae757583a8692f78a355543727ddea7988ca027/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "013107a25c92262f515b1da8a473c7fad32269df", "url": "https://api.github.com/repos/rust-lang/rust/commits/013107a25c92262f515b1da8a473c7fad32269df", "html_url": "https://github.com/rust-lang/rust/commit/013107a25c92262f515b1da8a473c7fad32269df"}], "stats": {"total": 1522, "additions": 1412, "deletions": 110}, "files": [{"sha": "a27aa9b7ecc0f538d8f539cf0982186f8ab5dd2a", "filename": "configure", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/configure", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -387,7 +387,8 @@ rm -f config.mk.bak\n \n step_msg \"making directories\"\n for i in \\\n-    doc \\\n+    doc doc/std \\\n+    nd nd/std \\\n     rt rt/isaac rt/bigint rt/sync rt/test rt/arch/i386 \\\n     rt/libuv rt/libuv/src/ares rt/libuv/src/eio rt/libuv/src/ev \\\n     rustllvm dl \\"}, {"sha": "b1453d4488bf292ff5587b15beca20802732a364", "filename": "doc/Languages.txt", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/doc%2FLanguages.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/doc%2FLanguages.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2FLanguages.txt?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -0,0 +1,124 @@\n+Format: 1.51\n+\n+# This is the Natural Docs languages file for this project.  If you change\n+# anything here, it will apply to THIS PROJECT ONLY.  If you'd like to change\n+# something for all your projects, edit the Languages.txt in Natural Docs'\n+# Config directory instead.\n+\n+\n+# You can prevent certain file extensions from being scanned like this:\n+# Ignore Extensions: [extension] [extension] ...\n+\n+\n+#-------------------------------------------------------------------------------\n+# SYNTAX:\n+#\n+# Unlike other Natural Docs configuration files, in this file all comments\n+# MUST be alone on a line.  Some languages deal with the # character, so you\n+# cannot put comments on the same line as content.\n+#\n+# Also, all lists are separated with spaces, not commas, again because some\n+# languages may need to use them.\n+#\n+# Language: [name]\n+# Alter Language: [name]\n+#    Defines a new language or alters an existing one.  Its name can use any\n+#    characters.  If any of the properties below have an add/replace form, you\n+#    must use that when using Alter Language.\n+#\n+#    The language Shebang Script is special.  It's entry is only used for\n+#    extensions, and files with those extensions have their shebang (#!) lines\n+#    read to determine the real language of the file.  Extensionless files are\n+#    always treated this way.\n+#\n+#    The language Text File is also special.  It's treated as one big comment\n+#    so you can put Natural Docs content in them without special symbols.  Also,\n+#    if you don't specify a package separator, ignored prefixes, or enum value\n+#    behavior, it will copy those settings from the language that is used most\n+#    in the source tree.\n+#\n+# Extensions: [extension] [extension] ...\n+# [Add/Replace] Extensions: [extension] [extension] ...\n+#    Defines the file extensions of the language's source files.  You can\n+#    redefine extensions found in the main languages file.  You can use * to\n+#    mean any undefined extension.\n+#\n+# Shebang Strings: [string] [string] ...\n+# [Add/Replace] Shebang Strings: [string] [string] ...\n+#    Defines a list of strings that can appear in the shebang (#!) line to\n+#    designate that it's part of the language.  You can redefine strings found\n+#    in the main languages file.\n+#\n+# Ignore Prefixes in Index: [prefix] [prefix] ...\n+# [Add/Replace] Ignored Prefixes in Index: [prefix] [prefix] ...\n+#\n+# Ignore [Topic Type] Prefixes in Index: [prefix] [prefix] ...\n+# [Add/Replace] Ignored [Topic Type] Prefixes in Index: [prefix] [prefix] ...\n+#    Specifies prefixes that should be ignored when sorting symbols in an\n+#    index.  Can be specified in general or for a specific topic type.\n+#\n+#------------------------------------------------------------------------------\n+# For basic language support only:\n+#\n+# Line Comments: [symbol] [symbol] ...\n+#    Defines a space-separated list of symbols that are used for line comments,\n+#    if any.\n+#\n+# Block Comments: [opening sym] [closing sym] [opening sym] [closing sym] ...\n+#    Defines a space-separated list of symbol pairs that are used for block\n+#    comments, if any.\n+#\n+# Package Separator: [symbol]\n+#    Defines the default package separator symbol.  The default is a dot.\n+#\n+# [Topic Type] Prototype Enders: [symbol] [symbol] ...\n+#    When defined, Natural Docs will attempt to get a prototype from the code\n+#    immediately following the topic type.  It stops when it reaches one of\n+#    these symbols.  Use \\n for line breaks.\n+#\n+# Line Extender: [symbol]\n+#    Defines the symbol that allows a prototype to span multiple lines if\n+#    normally a line break would end it.\n+#\n+# Enum Values: [global|under type|under parent]\n+#    Defines how enum values are referenced.  The default is global.\n+#    global       - Values are always global, referenced as 'value'.\n+#    under type   - Values are under the enum type, referenced as\n+#               'package.enum.value'.\n+#    under parent - Values are under the enum's parent, referenced as\n+#               'package.value'.\n+#\n+# Perl Package: [perl package]\n+#    Specifies the Perl package used to fine-tune the language behavior in ways\n+#    too complex to do in this file.\n+#\n+#------------------------------------------------------------------------------\n+# For full language support only:\n+#\n+# Full Language Support: [perl package]\n+#    Specifies the Perl package that has the parsing routines necessary for full\n+#    language support.\n+#\n+#-------------------------------------------------------------------------------\n+\n+# The following languages are defined in the main file, if you'd like to alter\n+# them:\n+#\n+#    Text File, Shebang Script, C/C++, C#, Java, JavaScript, Perl, Python,\n+#    PHP, SQL, Visual Basic, Pascal, Assembly, Ada, Tcl, Ruby, Makefile,\n+#    ActionScript, ColdFusion, R, Fortran\n+\n+# If you add a language that you think would be useful to other developers\n+# and should be included in Natural Docs by default, please e-mail it to\n+# languages [at] naturaldocs [dot] org.\n+\n+\n+Language: Rust\n+\n+   Extensions: rc rs\n+   Line Comment: //\n+   Block Comment: /* */\n+   Package Separator: ::\n+   Function Prototype Enders: ; {\n+   Type Prototype Enders: ; }\n+   Class Prototype Enders: {"}, {"sha": "24557eea9f0c7027a3e30ad54b3c2b7c78bdeb5c", "filename": "doc/Topics.txt", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/doc%2FTopics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/doc%2FTopics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2FTopics.txt?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -0,0 +1,159 @@\n+Format: 1.51\n+\n+# This is the Natural Docs topics file for this project.  If you change anything\n+# here, it will apply to THIS PROJECT ONLY.  If you'd like to change something\n+# for all your projects, edit the Topics.txt in Natural Docs' Config directory\n+# instead.\n+\n+\n+# If you'd like to prevent keywords from being recognized by Natural Docs, you\n+# can do it like this:\n+# Ignore Keywords: [keyword], [keyword], ...\n+#\n+# Or you can use the list syntax like how they are defined:\n+# Ignore Keywords:\n+#    [keyword]\n+#    [keyword], [plural keyword]\n+#    ...\n+\n+\n+#-------------------------------------------------------------------------------\n+# SYNTAX:\n+#\n+# Topic Type: [name]\n+# Alter Topic Type: [name]\n+#    Creates a new topic type or alters one from the main file.  Each type gets\n+#    its own index and behavior settings.  Its name can have letters, numbers,\n+#    spaces, and these charaters: - / . '\n+#\n+# Plural: [name]\n+#    Sets the plural name of the topic type, if different.\n+#\n+# Keywords:\n+#    [keyword]\n+#    [keyword], [plural keyword]\n+#    ...\n+#    Defines or adds to the list of keywords for the topic type.  They may only\n+#    contain letters, numbers, and spaces and are not case sensitive.  Plural\n+#    keywords are used for list topics.  You can redefine keywords found in the\n+#    main topics file.\n+#\n+# Index: [yes|no]\n+#    Whether the topics get their own index.  Defaults to yes.  Everything is\n+#    included in the general index regardless of this setting.\n+#\n+# Scope: [normal|start|end|always global]\n+#    How the topics affects scope.  Defaults to normal.\n+#    normal        - Topics stay within the current scope.\n+#    start         - Topics start a new scope for all the topics beneath it,\n+#                    like class topics.\n+#    end           - Topics reset the scope back to global for all the topics\n+#                    beneath it.\n+#    always global - Topics are defined as global, but do not change the scope\n+#                    for any other topics.\n+#\n+# Class Hierarchy: [yes|no]\n+#    Whether the topics are part of the class hierarchy.  Defaults to no.\n+#\n+# Page Title If First: [yes|no]\n+#    Whether the topic's title becomes the page title if it's the first one in\n+#    a file.  Defaults to no.\n+#\n+# Break Lists: [yes|no]\n+#    Whether list topics should be broken into individual topics in the output.\n+#    Defaults to no.\n+#\n+# Can Group With: [type], [type], ...\n+#    Defines a list of topic types that this one can possibly be grouped with.\n+#    Defaults to none.\n+#-------------------------------------------------------------------------------\n+\n+# The following topics are defined in the main file, if you'd like to alter\n+# their behavior or add keywords:\n+#\n+#    Generic, Class, Interface, Section, File, Group, Function, Variable,\n+#    Property, Type, Constant, Enumeration, Event, Delegate, Macro,\n+#    Database, Database Table, Database View, Database Index, Database\n+#    Cursor, Database Trigger, Cookie, Build Target\n+\n+# If you add something that you think would be useful to other developers\n+# and should be included in Natural Docs by default, please e-mail it to\n+# topics [at] naturaldocs [dot] org.\n+\n+\n+#Topic Type: Crate\n+\n+#   Plural: Crates\n+#   Scope: Always Global\n+\n+#   Keywords:\n+#      crate, crates\n+\n+Topic Type: Syntax Extension\n+\n+   Plural: Syntax Extensions\n+   Scope: Always Global\n+\n+   Keywords:\n+      syntax extension, syntax extensions\n+\n+#Alter Topic Type: Class\n+\n+#   Keywords:\n+#      object, objects\n+#      tag, tags\n+#      resource, resources\n+\n+Topic Type: Module\n+   Plural: Modules\n+   Scope: Start\n+   Class Hierarchy: Yes\n+   Page Title If First: Yes\n+\n+   Keywords:\n+      module, modules\n+\n+Topic Type: Object\n+   Plural: Objects\n+   Scope: Start\n+   Class Hierarchy: Yes\n+\n+   Keywords:\n+      obj, objs\n+\n+Topic Type: Tag\n+   Plural: Tags\n+   Scope: Start\n+   Class Hierarchy: Yes\n+\n+   Keywords:\n+      tag, tags\n+\n+#Alter Topic Type: Function\n+\n+#   Scope: Start\n+#      predicate, predicates\n+\n+#   Ignore Keywords:\n+#      method, methods\n+#   Keywords:\n+#      variant, variants\n+\n+Topic Type: Variant\n+\n+   Plural: Variants\n+   Keywords:\n+      variant, variants\n+\n+#Alter Topic Type: Type\n+\n+#    Keywords:\n+#       tag, tags\n+\n+Topic Type: Predicate\n+\n+   Plural: Predicates\n+   Break Lists: Yes\n+\n+   Keywords:\n+      predicate, predicates"}, {"sha": "72e549bec28f82d5d4b276b72b93876c649bb82a", "filename": "mk/docs.mk", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -19,3 +19,16 @@ doc/%.html: %.texi doc/version.texi\n docsnap: doc/rust.pdf\n \t@$(call E, snap: doc/rust-$(shell date +\"%Y-%m-%d\")-snap.pdf)\n \t$(Q)mv $< doc/rust-$(shell date +\"%Y-%m-%d\")-snap.pdf\n+\n+doc/std/index.html: nd/std/Languages.txt nd/std/Topics.txt \\\n+                    $(STDLIB_CRATE) $(STDLIB_INPUTS)\n+\t@$(call E, naturaldocs: $@)\n+\tnaturaldocs -i $(S)src/lib -o HTML doc/std -p nd/std -r\n+\n+nd/std/Languages.txt: $(S)doc/Languages.txt\n+\t@$(call E, cp: $@)\n+\t$(Q)cp $< $@\n+\n+nd/std/Topics.txt: $(S)doc/Topics.txt\n+\t@$(call E, cp: $@)\n+\t$(Q)cp $< $@"}, {"sha": "023450ec97b02e109d8bace4e23b7e90b5b793a7", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,3 +1,8 @@\n+/*\n+Module: bitv\n+\n+Bitvectors.\n+*/\n \n export t;\n export create;\n@@ -23,12 +28,26 @@ export eq_vec;\n //        an optimizing version of this module that produces a different obj\n //        for the case where nbits <= 32.\n \n+/*\n+Type: t\n+\n+The bitvector type.\n+*/\n type t = @{storage: [mutable uint], nbits: uint};\n \n \n // FIXME: this should be a constant once they work\n fn uint_bits() -> uint { ret 32u + (1u << 32u >> 27u); }\n \n+/*\n+Function: create\n+\n+Constructs a bitvector.\n+\n+Parameters:\n+nbits - The number of bits in the bitvector\n+init - If true then the bits are initialized to 1, otherwise 0\n+*/\n fn create(nbits: uint, init: bool) -> t {\n     let elt = if init { !0u } else { 0u };\n     let storage = vec::init_elt_mut::<uint>(elt, nbits / uint_bits() + 1u);"}, {"sha": "821a8428d2c9df56e29a04047f9c4b72c73a564e", "filename": "src/lib/box.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbox.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,6 +1,15 @@\n+/*\n+Module: box\n+*/\n+\n \n export ptr_eq;\n \n+/*\n+Function: ptr_eq\n+\n+Determine if two shared boxes point to the same object\n+*/\n fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     let a_ptr: uint = unsafe::reinterpret_cast(a);\n     let b_ptr: uint = unsafe::reinterpret_cast(b);"}, {"sha": "e91e8697dd86e7a459cf0b50e58ebfde43eed98f", "filename": "src/lib/char.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fchar.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,3 +1,18 @@\n+/*\n+Module: char\n+\n+Utilities for manipulating the char type\n+*/\n+\n+/*\n+Function: is_whitespace\n+\n+Indicates whether a character is whitespace.\n+\n+Whitespace characters include space (U+0020), tab (U+0009), line feed\n+(U+000A), carriage return (U+000D), and a number of less common\n+ASCII and unicode characters.\n+*/\n pure fn is_whitespace(c: char) -> bool {\n     const ch_space: char = '\\u0020';\n     const ch_ogham_space_mark: char = '\\u1680';"}, {"sha": "dca101b4e59ae5823da35e30ffb00bd4d1244b51", "filename": "src/lib/comm.rs", "status": "modified", "additions": 66, "deletions": 8, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fcomm.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,3 +1,26 @@\n+/*\n+Module: comm\n+\n+Communication between tasks\n+\n+Communication between tasks is facilitated by ports (in the receiving task),\n+and channels (in the sending task). Any number of channels may feed into a\n+single port.\n+\n+Example:\n+\n+> use std::task;\n+> use std::comm;\n+>\n+> let p = comm::port();\n+> task::spawn(comm::chan(p), fn (c: chan<str>) {\n+>   comm::send(c, \"Hello, World\");\n+> });\n+>\n+> log comm::recv(p);\n+\n+*/\n+\n import sys;\n import ptr;\n import unsafe;\n@@ -30,31 +53,66 @@ type port_id = int;\n \n // It's critical that this only have one variant, so it has a record\n // layout, and will work in the rust_task structure in task.rs.\n-tag chan<unique T> { chan_t(task::task, port_id); }\n+/*\n+Type: chan\n+\n+A handle through which data may be sent.\n+\n+Each channel is associated with a single <port>.\n+*/\n+tag chan<unique T> {\n+    chan_t(task::task, port_id);\n+}\n \n resource port_ptr(po: *rustrt::rust_port) {\n     rustrt::drop_port(po);\n     rustrt::del_port(po);\n }\n \n+/*\n+Type: port\n+\n+A handle through which data may be received.\n+\n+Ports may be associated with multiple <chan>s.\n+*/\n tag port<unique T> { port_t(@port_ptr); }\n \n+/*\n+Function: send\n+\n+Sends data over a channel.\n+\n+The sent data is moved into the channel, whereupon the caller loses access\n+to it.\n+*/\n fn send<unique T>(ch: chan<T>, -data: T) {\n     let chan_t(t, p) = ch;\n     rustrt::chan_id_send(sys::get_type_desc::<T>(), t, p, data);\n     task::yield();\n }\n \n+/*\n+Function: port\n+\n+Constructs a port.\n+*/\n fn port<unique T>() -> port<T> {\n-    let p = rustrt::new_port(sys::size_of::<T>());\n-    ret port_t(@port_ptr(p));\n+    port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>())))\n }\n \n-fn recv<unique T>(p: port<T>) -> T {\n-    ret rusti::recv(***p);\n-}\n+/*\n+Function: recv\n+\n+Receive from a port.\n+*/\n+fn recv<unique T>(p: port<T>) -> T { ret rusti::recv(***p) }\n+\n+/*\n+Function: chan\n \n+Constructs a channel.\n+*/\n fn chan<unique T>(p: port<T>) -> chan<T> {\n-    let id = rustrt::get_port_id(***p);\n-    ret chan_t(task::get_task_id(), id);\n+    chan_t(task::get_task_id(), rustrt::get_port_id(***p))\n }"}, {"sha": "5f4c999126e1368132bc45a648301848d6dec735", "filename": "src/lib/ctypes.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fctypes.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,5 +1,12 @@\n-// FIXME: This can't be right\n+/*\n+Module: ctypes\n+\n+Definitions useful for C interop\n+*/\n+\n+/* Type: size_t */\n type size_t = uint;\n+/* Type: ssize_t */\n type ssize_t = int;\n-\n+/* Type: uint32_t */\n type uint32_t = u32;"}, {"sha": "213003e52644226fb8a625f7eb71be387c82f0d1", "filename": "src/lib/deque.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,21 +1,38 @@\n+/*\n+Module: deque\n \n+A deque.  Untested as of yet.  Likely buggy.\n+*/\n \n-\n-/**\n- * A deque, for fun.  Untested as of yet.  Likely buggy.\n- */\n-type t<T> =\n-    obj {\n-        fn size() -> uint;\n-        fn add_front(T);\n-        fn add_back(T);\n-        fn pop_front() -> T;\n-        fn pop_back() -> T;\n-        fn peek_front() -> T;\n-        fn peek_back() -> T;\n-        fn get(int) -> T;\n+/*\n+Object: t\n+*/\n+type t<T> = obj {\n+    // Method: size\n+    fn size() -> uint;\n+    // Method: add_front\n+    fn add_front(T);\n+    // Method: add_back\n+    fn add_back(T);\n+    // Method: pop_front\n+    fn pop_front() -> T;\n+    // Method: pop_back\n+    fn pop_back() -> T;\n+    // Method: peek_front\n+    fn peek_front() -> T;\n+    // Method: peek_back\n+    fn peek_back() -> T;\n+    // Method: get\n+    fn get(int) -> T;\n     };\n \n+/*\n+Section: Functions\n+*/\n+\n+/*\n+Function: create\n+*/\n fn create<T>() -> t<T> {\n     type cell<T> = option::t<T>;\n "}, {"sha": "a6774144599699fded2410a5369223cf00e83534", "filename": "src/lib/either.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Feither.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,15 +1,46 @@\n+/*\n+Module: either\n+\n+A type that represents one of two alternatives\n+*/\n \n import option;\n import option::{some, none};\n \n-tag t<T, U> { left(T); right(U); }\n+/*\n+Tag: t\n+\n+The either type\n+*/\n+tag t<T, U> {\n+    /* Variant: left */\n+    left(T);\n+    /* Variant: right */\n+    right(U);\n+}\n+\n+/* Section: Operations */\n+\n+/*\n+Function: either\n+\n+Applies a function based on the given either value\n \n+If `value` is left(T) then `f_left` is applied to its contents, if\n+`value` is right(U) then `f_right` is applied to its contents, and\n+the result is returned.\n+*/\n fn either<T, U,\n           V>(f_left: block(T) -> V, f_right: block(U) -> V, value: t<T, U>) ->\n    V {\n     alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n }\n \n+/*\n+Function: lefts\n+\n+Extracts from a vector of either all the left values.\n+*/\n fn lefts<T, U>(eithers: [t<T, U>]) -> [T] {\n     let result: [T] = [];\n     for elt: t<T, U> in eithers {\n@@ -18,6 +49,11 @@ fn lefts<T, U>(eithers: [t<T, U>]) -> [T] {\n     ret result;\n }\n \n+/*\n+Function: rights\n+\n+Extracts from a vector of either all the right values\n+*/\n fn rights<T, U>(eithers: [t<T, U>]) -> [U] {\n     let result: [U] = [];\n     for elt: t<T, U> in eithers {\n@@ -26,6 +62,14 @@ fn rights<T, U>(eithers: [t<T, U>]) -> [U] {\n     ret result;\n }\n \n+/*\n+Function: partition\n+\n+Extracts from a vector of either all the left values and right values\n+\n+Returns a structure containing a vector of left values and a vector of\n+right values.\n+*/\n fn partition<T, U>(eithers: [t<T, U>]) -> {lefts: [T], rights: [U]} {\n     let lefts: [T] = [];\n     let rights: [U] = [];\n@@ -34,6 +78,7 @@ fn partition<T, U>(eithers: [t<T, U>]) -> {lefts: [T], rights: [U]} {\n     }\n     ret {lefts: lefts, rights: rights};\n }\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "b6d04397711d4a77e491a8e129adb6df9b6e787b", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,19 +1,28 @@\n+/*\n+Syntax Extension: fmt\n \n+Format a string\n+\n+The 'fmt' extension is modeled on the posix printf system.\n+\n+A posix conversion ostensibly looks like this\n+\n+> %[parameter][flags][width][.precision][length]type\n+\n+Given the different numeric type bestiary we have, we omit the 'length'\n+parameter and support slightly different conversions for 'type'\n+\n+> %[parameter][flags][width][.precision]type\n+\n+we also only support translating-to-rust a tiny subset of the possible\n+combinations at the moment.\n+\n+Example:\n+\n+log #fmt(\"hello, %s!\", \"world\");\n+\n+*/\n \n-/* The 'fmt' extension is modeled on the posix printf system.\n- *\n- * A posix conversion ostensibly looks like this:\n- *\n- * %[parameter][flags][width][.precision][length]type\n- *\n- * Given the different numeric type bestiary we have, we omit the 'length'\n- * parameter and support slightly different conversions for 'type':\n- *\n- * %[parameter][flags][width][.precision]type\n- *\n- * we also only support translating-to-rust a tiny subset of the possible\n- * combinations at the moment.\n- */\n import option::{some, none};\n \n "}, {"sha": "04960c193b33b9028fb98e59206ee5a0ded2971f", "filename": "src/lib/float.rs", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffloat.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,7 +1,21 @@\n+/*\n+Module: float\n+*/\n+\n /**\n- * String conversions\n+ * Section: String Conversions\n  */\n \n+/*\n+Function: to_str\n+\n+Converts a float to a string\n+\n+Parameters:\n+\n+num - The float value\n+digits: The number of significant digits\n+*/\n fn to_str(num: float, digits: uint) -> str {\n     let accum = if num < 0.0 { num = -num; \"-\" } else { \"\" };\n     let trunc = num as uint;\n@@ -19,23 +33,30 @@ fn to_str(num: float, digits: uint) -> str {\n     ret accum;\n }\n \n-/**\n- * Convert a string to a float\n- *\n- * This function accepts strings such as\n- * * \"3.14\"\n- * * \"+3.14\", equivalent to \"3.14\"\n- * * \"-3.14\"\n- * * \"2.5E10\", or equivalently, \"2.5e10\"\n- * * \"2.5E-10\"\n- * * \"\", or, equivalently, \".\" (understood as 0)\n- * * \"5.\"\n- * * \".5\", or, equivalently,  \"0.5\"\n- *\n- * @param num A string, possibly empty.\n- * @return [NaN] if the string did not represent a valid number.\n- * @return Otherwise, the floating-point number represented [num].\n- */\n+/*\n+Function: from_str\n+\n+Convert a string to a float\n+\n+This function accepts strings such as\n+* \"3.14\"\n+* \"+3.14\", equivalent to \"3.14\"\n+* \"-3.14\"\n+* \"2.5E10\", or equivalently, \"2.5e10\"\n+* \"2.5E-10\"\n+* \"\", or, equivalently, \".\" (understood as 0)\n+* \"5.\"\n+* \".5\", or, equivalently,  \"0.5\"\n+\n+Parameters:\n+\n+num - A string, possibly empty.\n+\n+Returns:\n+\n+<NaN> If the string did not represent a valid number.\n+Otherwise, the floating-point number represented [num].\n+*/\n fn from_str(num: str) -> float {\n    let pos = 0u;                  //Current byte position in the string.\n                                   //Used to walk the string in O(n).\n@@ -144,17 +165,21 @@ fn from_str(num: str) -> float {\n }\n \n /**\n- * Arithmetics\n+ * Section: Arithmetics\n  */\n \n-/**\n- * Compute the exponentiation of an integer by another integer as a float.\n- *\n- *\n- * @param x The base.\n- * @param pow The exponent.\n- * @return [NaN] of both [x] and [pow] are [0u], otherwise [x^pow].\n- */\n+/*\n+Function: pow_uint_to_uint_as_float\n+\n+Compute the exponentiation of an integer by another integer as a float.\n+\n+Parameters:\n+x - The base.\n+pow - The exponent.\n+\n+Returns:\n+<NaN> of both `x` and `pow` are `0u`, otherwise `x^pow`.\n+*/\n fn pow_uint_to_uint_as_float(x: uint, pow: uint) -> float {\n    if x == 0u {\n       if pow == 0u {\n@@ -177,20 +202,23 @@ fn pow_uint_to_uint_as_float(x: uint, pow: uint) -> float {\n \n \n /**\n- * Constants\n+ * Section: Constants\n  */\n \n //TODO: Once this is possible, replace the body of these functions\n //by an actual constant.\n \n+/* Function: NaN */\n fn NaN() -> float {\n    ret 0./0.;\n }\n \n+/* Function: infinity */\n fn infinity() -> float {\n    ret 1./0.;\n }\n \n+/* Function: neg_infinity */\n fn neg_infinity() -> float {\n    ret -1./0.;\n }"}, {"sha": "5787e9c510c3f2a5b222f8a555f02edc1037fb44", "filename": "src/lib/fs.rs", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,3 +1,8 @@\n+/*\n+Module: fs\n+\n+File system manipulation\n+*/\n \n import os::getcwd;\n import os_fs;\n@@ -6,10 +11,32 @@ native \"c-stack-cdecl\" mod rustrt {\n     fn rust_file_is_dir(path: str::sbuf) -> int;\n }\n \n+/*\n+Function: path_sep\n+\n+Get the default path separator for the host platform\n+*/\n fn path_sep() -> str { ret str::from_char(os_fs::path_sep); }\n \n+// FIXME: This type should probably be constrained\n+/*\n+Type: path\n+\n+A path or fragment of a filesystem path\n+*/\n type path = str;\n \n+/*\n+Function: dirname\n+\n+Get the directory portion of a path\n+\n+Returns all of the path up to, but excluding, the final path separator.\n+The dirname of \"/usr/share\" will be \"/usr\", but the dirname of\n+\"/usr/share/\" is \"/usr/share\".\n+\n+If the path is not prefixed with a directory, then \".\" is returned.\n+*/\n fn dirname(p: path) -> path {\n     let i: int = str::rindex(p, os_fs::path_sep as u8);\n     if i == -1 {\n@@ -19,6 +46,17 @@ fn dirname(p: path) -> path {\n     ret str::substr(p, 0u, i as uint);\n }\n \n+/*\n+Function: basename\n+\n+Get the file name portion of a path\n+\n+Returns the portion of the path after the final path separator.\n+The basename of \"/usr/share\" will be \"share\". If there are no\n+path separators in the path then the returned path is identical to\n+the provided path. If an empty path is provided or the path ends\n+with a path separator then an empty path is returned.\n+*/\n fn basename(p: path) -> path {\n     let i: int = str::rindex(p, os_fs::path_sep as u8);\n     if i == -1 {\n@@ -32,6 +70,15 @@ fn basename(p: path) -> path {\n \n \n // FIXME: Need some typestate to avoid bounds check when len(pre) == 0\n+/*\n+Function: connect\n+\n+Connects to path segments\n+\n+Given paths `pre` and `post` this function will return a path\n+that is equal to `post` appended to `pre`, inserting a path separator\n+between the two as needed.\n+*/\n fn connect(pre: path, post: path) -> path {\n     let len = str::byte_len(pre);\n     ret if pre[len - 1u] == os_fs::path_sep as u8 {\n@@ -41,6 +88,13 @@ fn connect(pre: path, post: path) -> path {\n         } else { pre + path_sep() + post };\n }\n \n+/*\n+Function: connect_many\n+\n+Connects a vector of path segments into a single path.\n+\n+Inserts path separators as needed.\n+*/\n fn connect_many(paths: [path]) : vec::is_not_empty(paths) -> path {\n     ret if vec::len(paths) == 1u {\n         paths[0]\n@@ -51,10 +105,20 @@ fn connect_many(paths: [path]) : vec::is_not_empty(paths) -> path {\n     }\n }\n \n+/*\n+Function: file_id_dir\n+\n+Indicates whether a path represents a directory.\n+*/\n fn file_is_dir(p: path) -> bool {\n     ret str::as_buf(p, {|buf| rustrt::rust_file_is_dir(buf) != 0 });\n }\n \n+/*\n+Function: list_dir\n+\n+Lists the contents of a directory.\n+*/\n fn list_dir(p: path) -> [str] {\n     let p = p;\n     let pl = str::byte_len(p);\n@@ -68,14 +132,41 @@ fn list_dir(p: path) -> [str] {\n     ret full_paths;\n }\n \n+/*\n+Function: path_is_absolute\n+\n+Indicates whether a path is absolute.\n+\n+A path is considered absolute if it begins at the filesystem root (\"/\") or,\n+on Windows, begins with a drive letter.\n+*/\n fn path_is_absolute(p: path) -> bool { ret os_fs::path_is_absolute(p); }\n \n // FIXME: under Windows, we should prepend the current drive letter to paths\n // that start with a slash.\n+/*\n+Function: make_absolute\n+\n+Convert a relative path to an absolute path\n+\n+If the given path is relative, return it prepended with the current working\n+directory. If the given path is already an absolute path, return it\n+as is.\n+*/\n fn make_absolute(p: path) -> path {\n     if path_is_absolute(p) { ret p; } else { ret connect(getcwd(), p); }\n }\n \n+/*\n+Function: split\n+\n+Split a path into it's individual components\n+\n+Splits a given path by path separators and returns a vector containing\n+each piece of the path. On Windows, if the path is absolute then\n+the first element of the returned vector will be the drive letter\n+followed by a colon.\n+*/\n fn split(p: path) -> [path] {\n     let split1 = str::split(p, os_fs::path_sep as u8);\n     let split2 = [];\n@@ -85,6 +176,13 @@ fn split(p: path) -> [path] {\n     ret split2;\n }\n \n+/*\n+Function: normalize\n+\n+Removes extra \".\" and \"..\" entries from paths.\n+\n+Does not follow symbolic links.\n+*/\n fn normalize(p: path) -> path {\n     let s = split(p);\n     let s = strip_dots(s);"}, {"sha": "4e0aea3f31922ca1dc7aa0b74cafea70fecf8aaa", "filename": "src/lib/fun_treemap.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffun_treemap.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,4 +1,6 @@\n /*\n+Module: fun_treemap\n+\n A functional key,value store that works on anything.\n \n This works using a binary search tree. In the first version, it's a\n@@ -19,15 +21,35 @@ export insert;\n export find;\n export traverse;\n \n+/* Section: Types */\n+\n+/*\n+Type: treemap\n+*/\n+type treemap<K, V> = @tree_node<K, V>;\n+\n+/*\n+Tag: tree_node\n+*/\n tag tree_node<K, V> {\n     empty;\n     node(@K, @V, @tree_node<K, V>, @tree_node<K, V>);\n }\n \n-type treemap<K, V> = @tree_node<K, V>;\n+/* Section: Operations */\n+\n+/*\n+Function: init\n \n+Create a treemap\n+*/\n fn init<K, V>() -> treemap<K, V> { @empty }\n \n+/*\n+Function: insert\n+\n+Insert a value into the map\n+*/\n fn insert<K, V>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n     @alt m {\n        @empty. { node(@k, @v, @empty, @empty) }\n@@ -41,6 +63,11 @@ fn insert<K, V>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n      }\n }\n \n+/*\n+Function: find\n+\n+Find a value based on the key\n+*/\n fn find<K, V>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n       empty. { none }\n@@ -52,8 +79,11 @@ fn find<K, V>(m: treemap<K, V>, k: K) -> option<V> {\n     }\n }\n \n+/*\n+Function: traverse\n \n-// Performs an in-order traversal\n+Visit all pairs in the map in order.\n+*/\n fn traverse<K, V>(m: treemap<K, V>, f: fn(K, V)) {\n     alt *m {\n       empty. { }"}, {"sha": "ebb157c621cd590ac2c9b46c4daaed2d92d571ce", "filename": "src/lib/generic_os.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgeneric_os.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,5 +1,30 @@\n+/*\n+Module: generic_os\n+\n+Some miscellaneous platform functions.\n+\n+These should be rolled into another module.\n+*/\n+\n import str::sbuf;\n \n+// Wow, this is an ugly way to write doc comments\n+\n+#[cfg(bogus)]\n+/*\n+Function: getenv\n+\n+Get the value of an environment variable\n+*/\n+fn getenv(n: str) -> option::t<str> { }\n+\n+#[cfg(bogus)]\n+/*\n+Function: setenv\n+\n+Set the value of an environment variable\n+*/\n+fn setenv(n: str, v: str) { }\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]"}, {"sha": "b4f9dee8e7228b41879891f02f5f306fe732a7f2", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 149, "deletions": 11, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,13 +1,50 @@\n+/*\n+Module: getopts\n \n+Simple getopt alternative. Construct a vector of options, either by using\n+reqopt, optopt, and optflag or by building them from components yourself, and\n+pass them to getopts, along with a vector of actual arguments (not including\n+argv[0]). You'll either get a failure code back, or a match.  You'll have to\n+verify whether the amount of 'free' arguments in the match is what you\n+expect. Use opt_* accessors to get argument values out of the match object.\n+\n+Single-character options are expected to appear on the command line with a\n+single preceeding dash; multiple-character options are expected to be\n+proceeded by two dashes. Options that expect an argument accept their argument\n+following either a space or an equals sign.\n+\n+Example:\n+\n+The following example shows simple command line parsing for an application\n+that requires an input file to be specified, accepts an optional output file\n+name following -o, and accepts both -h and --help as optional flags.\n+\n+> fn main(args: [str]) {\n+>   let opts = [\n+>     optopt(\"o\"),\n+>     optflag(\"h\"),\n+>     optflag(\"help\")\n+>   ];\n+>   let match = alt getopts(vec::shift(args), opts) {\n+>     success(m) { m }\n+>     failure(f) { fail fail_str(f) }\n+>   };\n+>   if opt_present(match, \"h\") || opt_present(match, \"help\") {\n+>     print_usage();\n+>     ret;\n+>   }\n+>   let output = opt_maybe_str(match, \"o\");\n+>   let input = if !vec::is_empty(match.free) {\n+>     match.free[0]\n+>   } else {\n+>     print_usage();\n+>     ret;\n+>   }\n+>   do_work(input, output);\n+> }\n+\n+*/\n \n-/* Simple getopt alternative. Construct a vector of options, either by using\n- * reqopt, optopt, and optflag or by building them from components yourself,\n- * and pass them to getopts, along with a vector of actual arguments (not\n- * including argv[0]). You'll either get a failure code back, or a match.\n- * You'll have to verify whether the amount of 'free' arguments in the match\n- * is what you expect. Use opt_* accessors (bottom of the file) to get\n- * argument values out of the match object.\n- */\n import option::{some, none};\n export opt;\n export reqopt;\n@@ -34,6 +71,11 @@ tag hasarg { yes; no; maybe; }\n \n tag occur { req; optional; multi; }\n \n+/*\n+Type: opt\n+\n+A description of a possible option\n+*/\n type opt = {name: name, hasarg: hasarg, occur: occur};\n \n fn mkname(nm: str) -> name {\n@@ -42,28 +84,60 @@ fn mkname(nm: str) -> name {\n         } else { long(nm) };\n }\n \n+/*\n+Function: reqopt\n+\n+Create an option that is required and takes an argument\n+*/\n fn reqopt(name: str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: req};\n }\n \n+/*\n+Function: optopt\n+\n+Create an option that is optional and takes an argument\n+*/\n fn optopt(name: str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: optional};\n }\n \n+/*\n+Function: optflag\n+\n+Create an option that is optional and does not take an argument\n+*/\n fn optflag(name: str) -> opt {\n     ret {name: mkname(name), hasarg: no, occur: optional};\n }\n \n+/*\n+Function: optflagopt\n+\n+Create an option that is optional and takes an optional argument\n+*/\n fn optflagopt(name: str) -> opt {\n     ret {name: mkname(name), hasarg: maybe, occur: optional};\n }\n \n+/*\n+Function: optmulti\n+\n+Create an option that is optional, takes an argument, and may occur\n+multiple times\n+*/\n fn optmulti(name: str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: multi};\n }\n \n tag optval { val(str); given; }\n \n+/*\n+Type: match\n+\n+The result of checking command line arguments. Contains a vector\n+of matches and a vector of free strings.\n+*/\n type match = {opts: [opt], vals: [mutable [optval]], free: [str]};\n \n fn is_arg(arg: str) -> bool {\n@@ -81,6 +155,12 @@ fn find_opt(opts: [opt], nm: name) -> option::t<uint> {\n     ret none::<uint>;\n }\n \n+/*\n+Type: fail_\n+\n+The type returned when the command line does not conform to the\n+expected format. Pass this value to <fail_str> to get an error message.\n+*/\n tag fail_ {\n     argument_missing(str);\n     unrecognized_option(str);\n@@ -89,6 +169,11 @@ tag fail_ {\n     unexpected_argument(str);\n }\n \n+/*\n+Function: fail_str\n+\n+Convert a <fail_> tag into an error string\n+*/\n fn fail_str(f: fail_) -> str {\n     ret alt f {\n           argument_missing(nm) { \"Argument to option '\" + nm + \"' missing.\" }\n@@ -103,8 +188,29 @@ fn fail_str(f: fail_) -> str {\n         };\n }\n \n+/*\n+Type: result\n+\n+The result of parsing a command line with a set of options\n+\n+Variants:\n+\n+success(match) - Returned from getopts on success\n+failure(fail_) - Returned from getopts on failure\n+*/\n tag result { success(match); failure(fail_); }\n \n+/*\n+Function: getopts\n+\n+Parse command line arguments according to the provided options\n+\n+Returns:\n+\n+success(match) - On success. Use functions such as <opt_present>\n+                 <opt_str>, etc. to interrogate results.\n+failure(fail_) - On failure. Use <fail_str> to get an error message.\n+*/\n fn getopts(args: [str], opts: [opt]) -> result {\n     let n_opts = vec::len::<opt>(opts);\n     fn f(_x: uint) -> [optval] { ret []; }\n@@ -208,14 +314,35 @@ fn opt_vals(m: match, nm: str) -> [optval] {\n \n fn opt_val(m: match, nm: str) -> optval { ret opt_vals(m, nm)[0]; }\n \n+/*\n+Function: opt_present\n+\n+Returns true if an option was matched\n+*/\n fn opt_present(m: match, nm: str) -> bool {\n     ret vec::len::<optval>(opt_vals(m, nm)) > 0u;\n }\n \n+/*\n+Function: opt_str\n+\n+Returns the string argument supplied to a matching option\n+\n+Failure:\n+\n+- If the option was not matched\n+- If the match did not take an argument\n+*/\n fn opt_str(m: match, nm: str) -> str {\n     ret alt opt_val(m, nm) { val(s) { s } _ { fail } };\n }\n \n+/*\n+Function: opt_str\n+\n+Returns a vector of the arguments provided to all matches of the given option.\n+Used when an option accepts multiple values.\n+*/\n fn opt_strs(m: match, nm: str) -> [str] {\n     let acc: [str] = [];\n     for v: optval in opt_vals(m, nm) {\n@@ -224,16 +351,27 @@ fn opt_strs(m: match, nm: str) -> [str] {\n     ret acc;\n }\n \n+/*\n+Function: opt_str\n+\n+Returns the string argument supplied to a matching option or none\n+*/\n fn opt_maybe_str(m: match, nm: str) -> option::t<str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n     ret alt vals[0] { val(s) { some::<str>(s) } _ { none::<str> } };\n }\n \n \n-/// Returns none if the option was not present, `def` if the option was\n-/// present but no argument was provided, and the argument if the option was\n-/// present and an argument was provided.\n+/*\n+Function: opt_default\n+\n+Returns the matching string, a default, or none\n+\n+Returns none if the option was not present, `def` if the option was\n+present but no argument was provided, and the argument if the option was\n+present and an argument was provided.\n+*/\n fn opt_default(m: match, nm: str, def: str) -> option::t<str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { ret none::<str>; }"}, {"sha": "464ac9deea50c3b8575addda8162417182f0a7be", "filename": "src/lib/int.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fint.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,52 +1,105 @@\n+/*\n+Module: int\n+*/\n+\n+/*\n+Function: max_value\n+\n+The maximum value of an integer\n+*/\n fn max_value() -> int {\n   ret min_value() - 1;\n }\n \n+/*\n+Function: min_value\n+\n+The minumum value of an integer\n+*/\n fn min_value() -> int {\n   ret (-1 << (sys::size_of::<int>()  * 8u as int - 1)) as int;\n }\n \n-\n+/* Function: add */\n pure fn add(x: int, y: int) -> int { ret x + y; }\n \n+/* Function: sub */\n pure fn sub(x: int, y: int) -> int { ret x - y; }\n \n+/* Function: mul */\n pure fn mul(x: int, y: int) -> int { ret x * y; }\n \n+/* Function: div */\n pure fn div(x: int, y: int) -> int { ret x / y; }\n \n+/* Function: rem */\n pure fn rem(x: int, y: int) -> int { ret x % y; }\n \n+/* Predicate: lt */\n pure fn lt(x: int, y: int) -> bool { ret x < y; }\n \n+/* Predicate: le */\n pure fn le(x: int, y: int) -> bool { ret x <= y; }\n \n+/* Predicate: eq */\n pure fn eq(x: int, y: int) -> bool { ret x == y; }\n \n+/* Predicate: ne */\n pure fn ne(x: int, y: int) -> bool { ret x != y; }\n \n+/* Predicate: ge */\n pure fn ge(x: int, y: int) -> bool { ret x >= y; }\n \n+/* Predicate: gt */\n pure fn gt(x: int, y: int) -> bool { ret x > y; }\n \n+/* Predicate: positive */\n pure fn positive(x: int) -> bool { ret x > 0; }\n \n+/* Predicate: negative */\n pure fn negative(x: int) -> bool { ret x < 0; }\n \n+/* Predicate: nonpositive */\n pure fn nonpositive(x: int) -> bool { ret x <= 0; }\n \n+/* Predicate: nonnegative */\n pure fn nonnegative(x: int) -> bool { ret x >= 0; }\n \n \n // FIXME: Make sure this works with negative integers.\n+/*\n+Function: hash\n+\n+Produce a uint suitable for use in a hash table\n+*/\n fn hash(x: int) -> uint { ret x as uint; }\n \n+// FIXME: This is redundant\n fn eq_alias(x: int, y: int) -> bool { ret x == y; }\n \n+/*\n+Function: range\n+\n+Iterate over the range [`lo`..`hi`)\n+*/\n fn range(lo: int, hi: int, it: block(int)) {\n     while lo < hi { it(lo); lo += 1; }\n }\n \n+/*\n+Function: parse_buf\n+\n+Parse a buffer of bytes\n+\n+Parameters:\n+\n+buf - A byte buffer\n+radix - The base of the number\n+\n+Failure:\n+\n+buf must not be empty\n+*/\n fn parse_buf(buf: [u8], radix: uint) -> int {\n     if vec::len::<u8>(buf) == 0u {\n         log_err \"parse_buf(): buf is empty\";\n@@ -68,16 +121,41 @@ fn parse_buf(buf: [u8], radix: uint) -> int {\n     fail;\n }\n \n+/*\n+Function: from_str\n+\n+Parse a string to an int\n+\n+Failure:\n+\n+s must not be empty\n+*/\n fn from_str(s: str) -> int { parse_buf(str::bytes(s), 10u) }\n \n+/*\n+Function: to_str\n+\n+Convert to a string in a given base\n+*/\n fn to_str(n: int, radix: uint) -> str {\n     assert (0u < radix && radix <= 16u);\n     ret if n < 0 {\n             \"-\" + uint::to_str(-n as uint, radix)\n         } else { uint::to_str(n as uint, radix) };\n }\n+\n+/*\n+Function: str\n+\n+Convert to a string\n+*/\n fn str(i: int) -> str { ret to_str(i, 10u); }\n \n+/*\n+Function: pow\n+\n+Returns `base` raised to the power of `exponent`\n+*/\n fn pow(base: int, exponent: uint) -> int {\n     if exponent == 0u { ret 1; } //Not mathemtically true if [base == 0]\n     if base     == 0  { ret 0; }"}, {"sha": "ab93699f8e53f39c0d0bf0f8e38b8651cba36e73", "filename": "src/lib/io.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,4 +1,3 @@\n-\n import os::libc;\n \n native \"c-stack-cdecl\" mod rustrt {"}, {"sha": "970349c7d31a3a6798a2f82e749032233a9f7206", "filename": "src/lib/option.rs", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,30 +1,85 @@\n-// lib/option::rs\n+/*\n+Module: option\n \n-tag t<T> { none; some(T); }\n+Represents the presence or absence of a value.\n \n+Every option<T> value can either be some(T) or none. Where in other languages\n+you might use a nullable type, in Rust you would use an option type.\n+*/\n+\n+/*\n+Tag: t\n+\n+The option type\n+*/\n+tag t<T> {\n+    /* Variant: none */\n+    none;\n+    /* Variant: some */\n+    some(T);\n+}\n+\n+/* Section: Operations */\n+\n+/*\n+Function: get\n+\n+Gets the value out of an option\n+\n+Failure:\n+\n+Fails if the value equals `none`.\n+*/\n fn get<T>(opt: t<T>) -> &T {\n     alt opt { some(x) { ret x; } none. { fail \"option none\"; } }\n }\n \n+/*\n+*/\n fn map<T, U>(f: block(T) -> U, opt: t<T>) -> t<U> {\n     alt opt { some(x) { some(f(x)) } none. { none } }\n }\n \n+/*\n+Function: is_none\n+\n+Returns true if the option equals none\n+*/\n fn is_none<T>(opt: t<T>) -> bool {\n     alt opt { none. { true } some(_) { false } }\n }\n \n+/*\n+Function: is_some\n+\n+Returns true if the option contains some value\n+*/\n fn is_some<T>(opt: t<T>) -> bool { !is_none(opt) }\n \n+/*\n+Function: from_maybe\n+\n+Returns the contained value or a default\n+*/\n fn from_maybe<T>(def: T, opt: t<T>) -> T {\n     alt opt { some(x) { x } none. { def } }\n }\n \n+/*\n+Function: maybe\n+\n+Applies a function to the contained value or returns a default\n+*/\n fn maybe<T, U>(def: U, f: block(T) -> U, opt: t<T>) -> U {\n     alt opt { none. { def } some(t) { f(t) } }\n }\n \n-// Can be defined in terms of the above when/if we have const bind.\n+// FIXME: Can be defined in terms of the above when/if we have const bind.\n+/*\n+Function: may\n+\n+Performs an operation on the contained value or does nothing\n+*/\n fn may<T>(f: block(T), opt: t<T>) {\n     alt opt { none. {/* nothing */ } some(t) { f(t); } }\n }"}, {"sha": "7f2539fd4c594f6de2632bdc5b51b371e043bc30", "filename": "src/lib/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,4 +1,3 @@\n-\n #[link(name = \"std\",\n        vers = \"0.1\",\n        uuid = \"122bed0b-c19b-4b82-b0b7-7ae8aead7297\","}, {"sha": "68d732449c65b821ebb156dc63b1f5f213179db7", "filename": "src/lib/treemap.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftreemap.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,4 +1,6 @@\n /*\n+Module: treemap\n+\n A key,value store that works on anything.\n \n This works using a binary search tree. In the first version, it's a\n@@ -16,12 +18,32 @@ export insert;\n export find;\n export traverse;\n \n-tag tree_node<K, V> { empty; node(@K, @V, treemap<K, V>, treemap<K, V>); }\n+/* Section: Types */\n \n+/*\n+Type: treemap\n+*/\n type treemap<K, V> = @mutable tree_node<K, V>;\n \n+/*\n+Tag: tree_node\n+*/\n+tag tree_node<K, V> { empty; node(@K, @V, treemap<K, V>, treemap<K, V>); }\n+\n+/* Section: Operations */\n+\n+/*\n+Function: init\n+\n+Create a treemap\n+*/\n fn init<K, V>() -> treemap<K, V> { @mutable empty }\n \n+/*\n+Function: insert\n+\n+Insert a value into the map\n+*/\n fn insert<K, V>(m: treemap<K, V>, k: K, v: V) {\n     alt m {\n       @empty. { *m = node(@k, @v, @mutable empty, @mutable empty); }\n@@ -36,6 +58,11 @@ fn insert<K, V>(m: treemap<K, V>, k: K, v: V) {\n     }\n }\n \n+/*\n+Function: find\n+\n+Find a value based on the key\n+*/\n fn find<K, V>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n       empty. { none }\n@@ -51,7 +78,11 @@ fn find<K, V>(m: treemap<K, V>, k: K) -> option<V> {\n     }\n }\n \n-// Performs an in-order traversal\n+/*\n+Function: traverse\n+\n+Visit all pairs in the map in order.\n+*/\n fn traverse<K, V>(m: treemap<K, V>, f: fn@(K, V)) {\n     alt *m {\n       empty. { }"}, {"sha": "08c8aa52a8a56056e16b7a80b5e32c145f2b3fa5", "filename": "src/lib/vec.rs", "status": "modified", "additions": 366, "deletions": 21, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ae757583a8692f78a355543727ddea7988ca027/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=7ae757583a8692f78a355543727ddea7988ca027", "patch": "@@ -1,4 +1,6 @@\n-// Interior vector utility functions.\n+/*\n+Module: vec\n+*/\n \n import option::{some, none};\n import uint::next_power_of_two;\n@@ -17,15 +19,40 @@ native \"c-stack-cdecl\" mod rustrt {\n                               count: uint) -> [T];\n }\n \n-/// Reserves space for `n` elements in the given vector.\n+/*\n+Function: reserve\n+\n+Reserves capacity for `n` elements in the given vector.\n+\n+If the capacity for `v` is already equal to or greater than the requested\n+capacity, then no action is taken.\n+\n+Parameters:\n+\n+v - A vector\n+n - The number of elements to reserve space for\n+*/\n fn reserve<T>(&v: [mutable? T], n: uint) {\n     rustrt::vec_reserve_shared(sys::get_type_desc::<T>(), v, n);\n }\n \n pure fn len<T>(v: [mutable? T]) -> uint { unchecked { rusti::vec_len(v) } }\n \n+/*\n+Type: init_op\n+\n+A function used to initialize the elements of a vector.\n+*/\n type init_op<T> = fn@(uint) -> T;\n \n+/*\n+Function: init_fn\n+\n+Creates and initializes an immutable vector.\n+\n+Creates an immutable vector of size `n_elts` and initializes the elements\n+to the value returned by the function `op`.\n+*/\n fn init_fn<T>(op: init_op<T>, n_elts: uint) -> [T] {\n     let v = [];\n     reserve(v, n_elts);\n@@ -35,6 +62,14 @@ fn init_fn<T>(op: init_op<T>, n_elts: uint) -> [T] {\n }\n \n // TODO: Remove me once we have slots.\n+/*\n+Function: init_fn\n+\n+Creates and initializes a mutable vector.\n+\n+Creates a mutable vector of size `n_elts` and initializes the elements to\n+the value returned by the function `op`.\n+*/\n fn init_fn_mut<T>(op: init_op<T>, n_elts: uint) -> [mutable T] {\n     let v = [mutable];\n     reserve(v, n_elts);\n@@ -43,6 +78,14 @@ fn init_fn_mut<T>(op: init_op<T>, n_elts: uint) -> [mutable T] {\n     ret v;\n }\n \n+/*\n+Function: init_elt\n+\n+Creates and initializes an immutable vector.\n+\n+Creates an immutable vector of size `n_elts` and initializes the elements\n+to the value `t`.\n+*/\n fn init_elt<T>(t: T, n_elts: uint) -> [T] {\n     let v = [];\n     reserve(v, n_elts);\n@@ -52,6 +95,14 @@ fn init_elt<T>(t: T, n_elts: uint) -> [T] {\n }\n \n // TODO: Remove me once we have slots.\n+/*\n+Function: init_elt_mut\n+\n+Creates and initializes a mutable vector.\n+\n+Creates a mutable vector of size `n_elts` and initializes the elements\n+to the value `t`.\n+*/\n fn init_elt_mut<T>(t: T, n_elts: uint) -> [mutable T] {\n     let v = [mutable];\n     reserve(v, n_elts);\n@@ -62,50 +113,103 @@ fn init_elt_mut<T>(t: T, n_elts: uint) -> [mutable T] {\n \n // FIXME: Possible typestate postcondition:\n // len(result) == len(v) (needs issue #586)\n+/*\n+Function: to_mut\n+\n+Produces a mutable vector from an immutable vector.\n+*/\n fn to_mut<T>(v: [T]) -> [mutable T] {\n     let vres = [mutable];\n     for t: T in v { vres += [mutable t]; }\n     ret vres;\n }\n \n // Same comment as from_mut\n+/*\n+Function: from_mut\n+\n+Produces an immutable vector from a mutable vector.\n+*/\n fn from_mut<T>(v: [mutable T]) -> [T] {\n     let vres = [];\n     for t: T in v { vres += [t]; }\n     ret vres;\n }\n \n-// Predicates\n+/*\n+Predicate: is_empty\n+\n+Returns true if a vector contains no elements.\n+*/\n pure fn is_empty<T>(v: [mutable? T]) -> bool {\n     // FIXME: This would be easier if we could just call len\n     for t: T in v { ret false; }\n     ret true;\n }\n \n+/*\n+Predicate: is_not_empty\n+\n+Returns true if a vector contains some elements.\n+*/\n pure fn is_not_empty<T>(v: [mutable? T]) -> bool { ret !is_empty(v); }\n \n // Accessors\n \n-/// Returns the first element of a vector\n+/*\n+Function: head\n+\n+Returns the first element of a vector\n+\n+Predicates:\n+<is_not_empty> (v)\n+*/\n fn head<T>(v: [mutable? T]) : is_not_empty(v) -> T { ret v[0]; }\n \n-/// Returns all but the first element of a vector\n+/*\n+Function: tail\n+\n+Returns all but the first element of a vector\n+\n+Predicates:\n+<is_not_empty> (v)\n+*/\n fn tail<T>(v: [mutable? T]) : is_not_empty(v) -> [T] {\n     ret slice(v, 1u, len(v));\n }\n \n-/// Returns the last element of `v`.\n+/*\n+Function: last\n+\n+Returns the last element of `v`\n+\n+Returns:\n+\n+An option containing the last element of `v` if `v` is not empty, or\n+none if `v` is empty.\n+*/\n fn last<T>(v: [mutable? T]) -> option::t<T> {\n     if len(v) == 0u { ret none; }\n     ret some(v[len(v) - 1u]);\n }\n \n-/// Returns the last element of a non-empty vector `v`.\n+/*\n+Function: last_total\n+\n+Returns the last element of a non-empty vector `v`\n+\n+Predicates:\n+<is_not_empty> (v)\n+*/\n fn last_total<T>(v: [mutable? T]) : is_not_empty(v) -> T {\n     ret v[len(v) - 1u];\n }\n \n-/// Returns a copy of the elements from [`start`..`end`) from `v`.\n+/*\n+Function: slice\n+\n+Returns a copy of the elements from [`start`..`end`) from `v`.\n+*/\n fn slice<T>(v: [mutable? T], start: uint, end: uint) -> [T] {\n     assert (start <= end);\n     assert (end <= len(v));\n@@ -117,6 +221,11 @@ fn slice<T>(v: [mutable? T], start: uint, end: uint) -> [T] {\n }\n \n // TODO: Remove me once we have slots.\n+/*\n+Function: slice_mut\n+\n+Returns a copy of the elements from [`start`..`end`) from `v`.\n+*/\n fn slice_mut<T>(v: [mutable? T], start: uint, end: uint) -> [mutable T] {\n     assert (start <= end);\n     assert (end <= len(v));\n@@ -130,6 +239,11 @@ fn slice_mut<T>(v: [mutable? T], start: uint, end: uint) -> [mutable T] {\n \n // Mutators\n \n+/*\n+Function: shift\n+\n+Removes the first element from a vector and return it\n+*/\n fn shift<T>(&v: [mutable? T]) -> T {\n     let ln = len::<T>(v);\n     assert (ln > 0u);\n@@ -139,6 +253,11 @@ fn shift<T>(&v: [mutable? T]) -> T {\n }\n \n // TODO: Write this, unsafely, in a way that's not O(n).\n+/*\n+Function: pop\n+\n+Remove the last element from a vector and return it\n+*/\n fn pop<T>(&v: [mutable? T]) -> T {\n     let ln = len(v);\n     assert (ln > 0u);\n@@ -153,31 +272,72 @@ fn pop<T>(&v: [mutable? T]) -> T {\n \n // Appending\n \n-/// Expands the given vector in-place by appending `n` copies of `initval`.\n+/*\n+Function: grow\n+\n+Expands a vector in place, initializing the new elements to a given value\n+\n+Parameters:\n+\n+v - The vector to grow\n+n - The number of elements to add\n+initval - The value for the new elements\n+*/\n fn grow<T>(&v: [T], n: uint, initval: T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [initval]; i += 1u; }\n }\n \n // TODO: Remove me once we have slots.\n+// FIXME: Can't grow take a [mutable? T]\n+/*\n+Function: grow_mut\n+\n+Expands a vector in place, initializing the new elements to a given value\n+\n+Parameters:\n+\n+v - The vector to grow\n+n - The number of elements to add\n+initval - The value for the new elements\n+*/\n fn grow_mut<T>(&v: [mutable T], n: uint, initval: T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [mutable initval]; i += 1u; }\n }\n \n-/// Calls `f` `n` times and appends the results of these calls to the given\n-/// vector.\n+/*\n+Function: grow_fn\n+\n+Expands a vector in place, initializing the new elements to the result of a\n+function\n+\n+Function `init_fn` is called `n` times with the values [0..`n`)\n+\n+Parameters:\n+\n+v - The vector to grow\n+n - The number of elements to add\n+init_fn - A function to call to retreive each appended element's value\n+*/\n fn grow_fn<T>(&v: [T], n: uint, init_fn: fn(uint) -> T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [init_fn(i)]; i += 1u; }\n }\n \n-/// Sets the element at position `index` to `val`. If `index` is past the end\n-/// of the vector, expands the vector by replicating `initval` to fill the\n-/// intervening space.\n+/*\n+Function: grow_set\n+\n+Sets the value of a vector element at a given index, growing the vector as\n+needed\n+\n+Sets the element at position `index` to `val`. If `index` is past the end\n+of the vector, expands the vector by replicating `initval` to fill the\n+intervening space.\n+*/\n fn grow_set<T>(&v: [mutable T], index: uint, initval: T, val: T) {\n     if index >= len(v) { grow_mut(v, index - len(v) + 1u, initval); }\n     v[index] = val;\n@@ -186,6 +346,11 @@ fn grow_set<T>(&v: [mutable T], index: uint, initval: T, val: T) {\n \n // Functional utilities\n \n+/*\n+Function: map\n+\n+Apply a function to each element of a vector and return the results\n+*/\n fn map<T, U>(f: block(T) -> U, v: [mutable? T]) -> [U] {\n     let result = [];\n     reserve(result, len(v));\n@@ -196,6 +361,11 @@ fn map<T, U>(f: block(T) -> U, v: [mutable? T]) -> [U] {\n     ret result;\n }\n \n+/*\n+Function: map2\n+\n+Apply a function to each pair of elements and return the results\n+*/\n fn map2<T, U, V>(f: block(T, U) -> V, v0: [T], v1: [U]) -> [V] {\n     let v0_len = len::<T>(v0);\n     if v0_len != len::<U>(v1) { fail; }\n@@ -205,6 +375,14 @@ fn map2<T, U, V>(f: block(T, U) -> V, v0: [T], v1: [U]) -> [V] {\n     ret u;\n }\n \n+/*\n+Function: filter_map\n+\n+Apply a function to each element of a vector and return the results\n+\n+If function `f` returns `none` then that element is excluded from\n+the resulting vector.\n+*/\n fn filter_map<T, U>(f: block(T) -> option::t<U>, v: [mutable? T]) -> [U] {\n     let result = [];\n     for elem: T in v {\n@@ -217,6 +395,15 @@ fn filter_map<T, U>(f: block(T) -> option::t<U>, v: [mutable? T]) -> [U] {\n     ret result;\n }\n \n+/*\n+Function: filter\n+\n+Construct a new vector from the elements of a vector for which some predicate\n+holds.\n+\n+Apply function `f` to each element of `v` and return a vector containing\n+only those elements for which `f` returned true.\n+*/\n fn filter<T>(f: block(T) -> bool, v: [mutable? T]) -> [T] {\n     let result = [];\n     for elem: T in v {\n@@ -228,6 +415,11 @@ fn filter<T>(f: block(T) -> bool, v: [mutable? T]) -> [T] {\n     ret result;\n }\n \n+/*\n+Function: foldl\n+\n+FIXME: This looks like it's actually foldr\n+*/\n fn foldl<T, U>(p: block(U, T) -> U, z: U, v: [mutable? T]) -> U {\n     let sz = len(v);\n     if sz == 0u { ret z; }\n@@ -236,44 +428,97 @@ fn foldl<T, U>(p: block(U, T) -> U, z: U, v: [mutable? T]) -> U {\n     ret p(foldl(p, z, rest), first);\n }\n \n+/*\n+Function: any\n+\n+Return true if a predicate matches any elements\n+\n+If the vector contains no elements then false is returned.\n+*/\n fn any<T>(f: block(T) -> bool, v: [T]) -> bool {\n     for elem: T in v { if f(elem) { ret true; } }\n     ret false;\n }\n \n+/*\n+Function: all\n+\n+Return true if a predicate matches all elements\n+\n+If the vector contains no elements then true is returned.\n+*/\n fn all<T>(f: block(T) -> bool, v: [T]) -> bool {\n     for elem: T in v { if !f(elem) { ret false; } }\n     ret true;\n }\n \n+/*\n+Function: member\n+\n+Return true if a vector contains an element with the given value\n+*/\n fn member<T>(x: T, v: [T]) -> bool {\n     for elt: T in v { if x == elt { ret true; } }\n     ret false;\n }\n \n+/*\n+Function: count\n+\n+Returns the number of elements that are equal to a given value\n+*/\n fn count<T>(x: T, v: [mutable? T]) -> uint {\n     let cnt = 0u;\n     for elt: T in v { if x == elt { cnt += 1u; } }\n     ret cnt;\n }\n \n+/*\n+Function: find\n+\n+Search for an element that matches a given predicate\n+\n+Apply function `f` to each element of `v`, starting from the first.\n+When function `f` matches then an option containing the element\n+is returned. If `f` matches no elements then none is returned.\n+*/\n fn find<T>(f: block(T) -> bool, v: [T]) -> option::t<T> {\n     for elt: T in v { if f(elt) { ret some(elt); } }\n     ret none;\n }\n \n+/*\n+Function: position\n+\n+Find the first index containing a matching value\n+\n+Returns:\n+\n+option::some(uint) - The first index containing a matching value\n+option::none - No elements matched\n+*/\n fn position<T>(x: T, v: [T]) -> option::t<uint> {\n     let i: uint = 0u;\n     while i < len(v) { if x == v[i] { ret some::<uint>(i); } i += 1u; }\n     ret none;\n }\n \n+/*\n+Function: position_pred\n+\n+Find the first index for which the value matches some predicate\n+*/\n fn position_pred<T>(f: fn(T) -> bool, v: [T]) -> option::t<uint> {\n     let i: uint = 0u;\n     while i < len(v) { if f(v[i]) { ret some::<uint>(i); } i += 1u; }\n     ret none;\n }\n \n+/*\n+Predicate: same_length\n+\n+Returns true if two vectors have the same length\n+*/\n pure fn same_length<T, U>(xs: [T], ys: [U]) -> bool {\n     vec::len(xs) == vec::len(ys)\n }\n@@ -282,12 +527,34 @@ pure fn same_length<T, U>(xs: [T], ys: [U]) -> bool {\n // saying the two result lists have the same length -- or, could\n // return a nominal record with a constraint saying that, instead of\n // returning a tuple (contingent on issue #869)\n+/*\n+Function: unzip\n+\n+Convert a vector of pairs into a pair of vectors\n+\n+Returns a tuple containing two vectors where the i-th element of the first\n+vector contains the first element of the i-th tuple of the input vector,\n+and the i-th element of the second vector contains the second element\n+of the i-th tuple of the input vector.\n+*/\n fn unzip<T, U>(v: [(T, U)]) -> ([T], [U]) {\n     let as = [], bs = [];\n     for (a, b) in v { as += [a]; bs += [b]; }\n     ret (as, bs);\n }\n \n+/*\n+Function: zip\n+\n+Convert two vectors to a vector of pairs\n+\n+Returns a vector of tuples, where the i-th tuple contains contains the\n+i-th elements from each of the input vectors.\n+\n+Preconditions:\n+\n+<same_length> (v, u)\n+*/\n fn zip<T, U>(v: [T], u: [U]) : same_length(v, u) -> [(T, U)] {\n     let zipped = [];\n     let sz = len(v), i = 0u;\n@@ -296,22 +563,39 @@ fn zip<T, U>(v: [T], u: [U]) : same_length(v, u) -> [(T, U)] {\n     ret zipped;\n }\n \n-// Swaps two elements in a vector\n+/*\n+Function: swap\n+\n+Swaps two elements in a vector\n+\n+Parameters:\n+v - The input vector\n+a - The index of the first element\n+b - The index of the second element\n+*/\n fn swap<T>(v: [mutable T], a: uint, b: uint) {\n     let t: T = v[a];\n     v[a] = v[b];\n     v[b] = t;\n }\n \n-// In place vector reversal\n+/*\n+Function: reverse\n+\n+Reverse the order of elements in a vector, in place\n+*/\n fn reverse<T>(v: [mutable T]) {\n     let i: uint = 0u;\n     let ln = len::<T>(v);\n     while i < ln / 2u { swap(v, i, ln - i - 1u); i += 1u; }\n }\n \n \n-// Functional vector reversal. Returns a reversed copy of v.\n+/*\n+Function: reversed\n+\n+Returns a vector with the order of elements reversed\n+*/\n fn reversed<T>(v: [T]) -> [T] {\n     let rs: [T] = [];\n     let i = len::<T>(v);\n@@ -321,21 +605,40 @@ fn reversed<T>(v: [T]) -> [T] {\n     ret rs;\n }\n \n-// Generating vecs.\n+// FIXME: Seems like this should take char params. Maybe belongs in char\n+/*\n+Function: enum_chars\n+\n+Returns a vector containing a range of chars\n+*/\n fn enum_chars(start: u8, end: u8) : u8::le(start, end) -> [char] {\n     let i = start;\n     let r = [];\n     while i <= end { r += [i as char]; i += 1u as u8; }\n     ret r;\n }\n \n+// FIXME: Probably belongs in uint. Compare to uint::range\n+/*\n+Function: enum_uints\n+\n+Returns a vector containing a range of uints\n+*/\n fn enum_uints(start: uint, end: uint) : uint::le(start, end) -> [uint] {\n     let i = start;\n     let r = [];\n     while i <= end { r += [i]; i += 1u; }\n     ret r;\n }\n \n+/*\n+Function: eachi\n+\n+Iterates over a vector's elements and indexes\n+\n+Iterates over vector `v` and, for each element, calls function `f`\n+with the element's value and index.\n+*/\n fn eachi<T>(f: block(T, uint) -> (), v: [mutable? T]) {\n     let i = 0u;\n     let l = len(v);\n@@ -346,33 +649,75 @@ fn eachi<T>(f: block(T, uint) -> (), v: [mutable? T]) {\n     }\n }\n \n-// Iterate over a list with with the indexes\n+/*\n+Function: iter2\n+\n+FIXME: This is exactly the same as eachi\n+*/\n fn iter2<T>(v: [T], it: block(uint, T)) {\n     let i = 0u;\n     for x in v { it(i, x); i += 1u; }\n }\n \n+/*\n+Function: to_ptr\n+\n+FIXME: We don't need this wrapper\n+*/\n+unsafe fn to_ptr<T>(v: [T]) -> *T { ret unsafe::to_ptr(v); }\n+\n+/*\n+Module: unsafe\n+*/\n mod unsafe {\n     type vec_repr = {mutable fill: uint, mutable alloc: uint, data: u8};\n \n+    /*\n+    Function: from_buf\n+\n+    Constructs a vector from an unsafe pointer to a buffer\n+\n+    Parameters:\n+\n+    ptr - An unsafe pointer to a buffer of `T`\n+    elts - The number of elements in the buffer\n+    */\n     unsafe fn from_buf<T>(ptr: *T, elts: uint) -> [T] {\n         ret rustrt::vec_from_buf_shared(sys::get_type_desc::<T>(),\n                                         ptr, elts);\n     }\n \n+    /*\n+    Function: set_len\n+\n+    Sets the length of a vector\n+\n+    This well explicitly set the size of the vector, without actually\n+    modifing its buffers, so it is up to the caller to ensure that\n+    the vector is actually the specified size.\n+    */\n     unsafe fn set_len<T>(&v: [T], new_len: uint) {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         (**repr).fill = new_len * sys::size_of::<T>();\n     }\n \n+    /*\n+    Function: to_ptr\n+\n+    Returns an unsafe pointer to the vector's buffer\n+\n+    The caller must ensure that the vector outlives the pointer this\n+    function returns, or else it will end up pointing to garbage.\n+\n+    Modifying the vector may cause its buffer to be reallocated, which\n+    would also make any pointers to it invalid.\n+    */\n     unsafe fn to_ptr<T>(v: [T]) -> *T {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         ret ::unsafe::reinterpret_cast(addr_of((**repr).data));\n     }\n }\n \n-unsafe fn to_ptr<T>(v: [T]) -> *T { ret unsafe::to_ptr(v); }\n-\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}]}