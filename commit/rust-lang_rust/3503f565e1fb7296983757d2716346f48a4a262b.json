{"sha": "3503f565e1fb7296983757d2716346f48a4a262b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1MDNmNTY1ZTFmYjcyOTY5ODM3NTdkMjcxNjM0NmY0OGE0YTI2MmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-02T16:33:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-02T16:33:00Z"}, "message": "Auto merge of #73751 - eddyb:no-empty-tables, r=nikomatsakis\n\nRemove `TypeckTables::empty(None)` and make hir_owner non-optional.\n\nEach commit before the last one removes uses of `TypeckTables::empty(None)`, replacing the empty tables with having `Option` around the `&'tcx TypeckTables<'tcx>` that HIR visitors kept track of.\n\nThe last commit removes the concept of \"empty `TypeckTables`\" altogether, guaranteeing that every `TypeckTables` corresponds to a HIR body owner.\n\nr? @nikomatsakis", "tree": {"sha": "3a1a62662e67ccb5eb38100e6e428d6ed747d801", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a1a62662e67ccb5eb38100e6e428d6ed747d801"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3503f565e1fb7296983757d2716346f48a4a262b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3503f565e1fb7296983757d2716346f48a4a262b", "html_url": "https://github.com/rust-lang/rust/commit/3503f565e1fb7296983757d2716346f48a4a262b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3503f565e1fb7296983757d2716346f48a4a262b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "html_url": "https://github.com/rust-lang/rust/commit/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144"}, {"sha": "4b2d9e60f41c11238d60ee9ca319136f61e72ca1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b2d9e60f41c11238d60ee9ca319136f61e72ca1", "html_url": "https://github.com/rust-lang/rust/commit/4b2d9e60f41c11238d60ee9ca319136f61e72ca1"}], "stats": {"total": 726, "additions": 355, "deletions": 371}, "files": [{"sha": "c2c19b6b4056b50e3e5398f8445bdd3a4bc605ca", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -6,6 +6,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(nll)]\n+#![cfg_attr(bootstrap, feature(track_caller))]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "6a34a310f735ad2651452db7b1e3841b597da25a", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -80,8 +80,7 @@ where\n         PpmTyped => {\n             abort_on_err(tcx.analysis(LOCAL_CRATE), tcx.sess);\n \n-            let empty_tables = ty::TypeckTables::empty(None);\n-            let annotation = TypedAnnotation { tcx, tables: Cell::new(&empty_tables) };\n+            let annotation = TypedAnnotation { tcx, maybe_typeck_tables: Cell::new(None) };\n             tcx.dep_graph.with_ignore(|| f(&annotation, tcx.hir().krate()))\n         }\n         _ => panic!(\"Should use call_with_pp_support\"),\n@@ -304,12 +303,22 @@ impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n     }\n }\n \n-struct TypedAnnotation<'a, 'tcx> {\n+struct TypedAnnotation<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    tables: Cell<&'a ty::TypeckTables<'tcx>>,\n+    maybe_typeck_tables: Cell<Option<&'tcx ty::TypeckTables<'tcx>>>,\n }\n \n-impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n+impl<'tcx> TypedAnnotation<'tcx> {\n+    /// Gets the type-checking side-tables for the current body.\n+    /// As this will ICE if called outside bodies, only call when working with\n+    /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n+    #[track_caller]\n+    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n+        self.maybe_typeck_tables.get().expect(\"`TypedAnnotation::tables` called outside of body\")\n+    }\n+}\n+\n+impl<'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n     fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n@@ -327,15 +336,15 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n+impl<'tcx> pprust_hir::PpAnn for TypedAnnotation<'tcx> {\n     fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n-        let old_tables = self.tables.get();\n+        let old_maybe_typeck_tables = self.maybe_typeck_tables.get();\n         if let pprust_hir::Nested::Body(id) = nested {\n-            self.tables.set(self.tcx.body_tables(id));\n+            self.maybe_typeck_tables.set(Some(self.tcx.body_tables(id)));\n         }\n         let pp_ann = &(&self.tcx.hir() as &dyn hir::intravisit::Map<'_>);\n         pprust_hir::PpAnn::nested(pp_ann, state, nested);\n-        self.tables.set(old_tables);\n+        self.maybe_typeck_tables.set(old_maybe_typeck_tables);\n     }\n     fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n         if let pprust_hir::AnnNode::Expr(_) = node {\n@@ -347,7 +356,7 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n             s.s.space();\n             s.s.word(\"as\");\n             s.s.space();\n-            s.s.word(self.tables.get().expr_ty(expr).to_string());\n+            s.s.word(self.tables().expr_ty(expr).to_string());\n             s.pclose();\n         }\n     }"}, {"sha": "b1ea222370742e893f50a91a93d23d2c6947ef2d", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -1684,7 +1684,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n         let generics =\n-            self.in_progress_tables.and_then(|table| table.borrow().hir_owner).map(|table_owner| {\n+            self.in_progress_tables.map(|table| table.borrow().hir_owner).map(|table_owner| {\n                 let hir_id = hir.as_local_hir_id(table_owner);\n                 let parent_id = hir.get_parent_item(hir_id);\n                 ("}, {"sha": "27da514a17f4d8e3b8dd24c24101b52bf4ec95cd", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -588,7 +588,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// Used only by `rustc_typeck` during body type-checking/inference,\n     /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n     pub fn with_fresh_in_progress_tables(mut self, table_owner: LocalDefId) -> Self {\n-        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty(Some(table_owner))));\n+        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::new(table_owner)));\n         self\n     }\n "}, {"sha": "77d403696f18faada664b6a6ee88e1a1fa2f35c4", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                 .pat_ty(pat)\n                 .ty_adt_def()\n                 .expect(\"struct pattern type is not an ADT\")\n-                .variant_of_res(cx.tables().qpath_res(qpath, pat.hir_id));\n+                .variant_of_res(cx.qpath_res(qpath, pat.hir_id));\n             for fieldpat in field_pats {\n                 if fieldpat.is_shorthand {\n                     continue;\n@@ -901,7 +901,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n             expr: &hir::Expr<'_>,\n         ) -> Option<(Ty<'tcx>, Ty<'tcx>)> {\n             let def = if let hir::ExprKind::Path(ref qpath) = expr.kind {\n-                cx.tables().qpath_res(qpath, expr.hir_id)\n+                cx.qpath_res(qpath, expr.hir_id)\n             } else {\n                 return None;\n             };\n@@ -1891,7 +1891,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n             if let hir::ExprKind::Call(ref path_expr, ref args) = expr.kind {\n                 // Find calls to `mem::{uninitialized,zeroed}` methods.\n                 if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n-                    let def_id = cx.tables().qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n+                    let def_id = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n \n                     if cx.tcx.is_diagnostic_item(sym::mem_zeroed, def_id) {\n                         return Some(InitKind::Zeroed);\n@@ -1911,8 +1911,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                     // See if the `self` parameter is one of the dangerous constructors.\n                     if let hir::ExprKind::Call(ref path_expr, _) = args[0].kind {\n                         if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n-                            let def_id =\n-                                cx.tables().qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n+                            let def_id = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n \n                             if cx.tcx.is_diagnostic_item(sym::maybe_uninit_zeroed, def_id) {\n                                 return Some(InitKind::Zeroed);"}, {"sha": "a2f9c9ea7cbe61fc32a3ba6723d206346ae44582", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -24,6 +24,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync;\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n+use rustc_hir::def::Res;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n use rustc_middle::lint::LintDiagnosticBuilder;\n@@ -427,15 +428,12 @@ pub struct LateContext<'a, 'tcx> {\n     /// Current body, or `None` if outside a body.\n     pub enclosing_body: Option<hir::BodyId>,\n \n-    /// Type-checking side-tables for the current body. Access using the\n-    /// `tables` method, which handles querying the tables on demand.\n+    /// Type-checking side-tables for the current body. Access using the `tables`\n+    /// and `maybe_tables` methods, which handle querying the tables on demand.\n     // FIXME(eddyb) move all the code accessing internal fields like this,\n     // to this module, to avoid exposing it to lint logic.\n     pub(super) cached_typeck_tables: Cell<Option<&'tcx ty::TypeckTables<'tcx>>>,\n \n-    // HACK(eddyb) replace this with having `Option` around `&TypeckTables`.\n-    pub(super) empty_typeck_tables: &'a ty::TypeckTables<'tcx>,\n-\n     /// Parameter environment for the item we are in.\n     pub param_env: ty::ParamEnv<'tcx>,\n \n@@ -677,18 +675,35 @@ impl LintContext for EarlyContext<'_> {\n \n impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     /// Gets the type-checking side-tables for the current body,\n-    /// or empty `TypeckTables` if outside a body.\n-    // FIXME(eddyb) return `Option<&'tcx ty::TypeckTables<'tcx>>`,\n-    // where `None` indicates we're outside a body.\n-    pub fn tables(&self) -> &'a ty::TypeckTables<'tcx> {\n-        if let Some(body) = self.enclosing_body {\n-            self.cached_typeck_tables.get().unwrap_or_else(|| {\n+    /// or `None` if outside a body.\n+    pub fn maybe_typeck_tables(&self) -> Option<&'tcx ty::TypeckTables<'tcx>> {\n+        self.cached_typeck_tables.get().or_else(|| {\n+            self.enclosing_body.map(|body| {\n                 let tables = self.tcx.body_tables(body);\n                 self.cached_typeck_tables.set(Some(tables));\n                 tables\n             })\n-        } else {\n-            self.empty_typeck_tables\n+        })\n+    }\n+\n+    /// Gets the type-checking side-tables for the current body.\n+    /// As this will ICE if called outside bodies, only call when working with\n+    /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n+    #[track_caller]\n+    pub fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n+        self.maybe_typeck_tables().expect(\"`LateContext::tables` called outside of body\")\n+    }\n+\n+    /// Returns the final resolution of a `QPath`, or `Res::Err` if unavailable.\n+    /// Unlike `.tables().qpath_res(qpath, id)`, this can be used even outside\n+    /// bodies (e.g. for paths in `hir::Ty`), without any risk of ICE-ing.\n+    pub fn qpath_res(&self, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n+        match *qpath {\n+            hir::QPath::Resolved(_, ref path) => path.res,\n+            hir::QPath::TypeRelative(..) => self\n+                .maybe_typeck_tables()\n+                .and_then(|tables| tables.type_dependent_def(id))\n+                .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),\n         }\n     }\n "}, {"sha": "9fe7edf6ccab24684e47390a570f530edbb0770a", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -378,7 +378,6 @@ fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n         tcx,\n         enclosing_body: None,\n         cached_typeck_tables: Cell::new(None),\n-        empty_typeck_tables: &ty::TypeckTables::empty(None),\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n         lint_store: unerased_lint_store(tcx),\n@@ -427,7 +426,6 @@ fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tc\n         tcx,\n         enclosing_body: None,\n         cached_typeck_tables: Cell::new(None),\n-        empty_typeck_tables: &ty::TypeckTables::empty(None),\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n         lint_store: unerased_lint_store(tcx),"}, {"sha": "45a86cf2cc6ccf56d6ae9aa62ee884a6a43ad75e", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -34,6 +34,7 @@\n #![feature(never_type)]\n #![feature(nll)]\n #![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(track_caller))]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "bf73ea46d5e439d4e49553d1597b78555b1c164f", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             hir::ExprKind::Call(ref callee, _) => {\n                 match callee.kind {\n                     hir::ExprKind::Path(ref qpath) => {\n-                        match cx.tables().qpath_res(qpath, callee.hir_id) {\n+                        match cx.qpath_res(qpath, callee.hir_id) {\n                             Res::Def(DefKind::Fn | DefKind::AssocFn, def_id) => Some(def_id),\n                             // `Res::Local` if it was a closure, for which we\n                             // do not currently support must-use linting"}, {"sha": "d942c07965a491711de06d3ac456aff8df7e66e0", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 27, "deletions": 42, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -188,7 +188,7 @@ pub struct CommonConsts<'tcx> {\n }\n \n pub struct LocalTableInContext<'a, V> {\n-    hir_owner: Option<LocalDefId>,\n+    hir_owner: LocalDefId,\n     data: &'a ItemLocalMap<V>,\n }\n \n@@ -199,42 +199,27 @@ pub struct LocalTableInContext<'a, V> {\n /// would be in a different frame of reference and using its `local_id`\n /// would result in lookup errors, or worse, in silently wrong data being\n /// stored/returned.\n-fn validate_hir_id_for_typeck_tables(\n-    hir_owner: Option<LocalDefId>,\n-    hir_id: hir::HirId,\n-    mut_access: bool,\n-) {\n-    if let Some(hir_owner) = hir_owner {\n-        if hir_id.owner != hir_owner {\n-            ty::tls::with(|tcx| {\n-                bug!(\n-                    \"node {} with HirId::owner {:?} cannot be placed in TypeckTables with hir_owner {:?}\",\n-                    tcx.hir().node_to_string(hir_id),\n-                    hir_id.owner,\n-                    hir_owner\n-                )\n-            });\n-        }\n-    } else {\n-        // We use \"Null Object\" TypeckTables in some of the analysis passes.\n-        // These are just expected to be empty and their `hir_owner` is\n-        // `None`. Therefore we cannot verify whether a given `HirId` would\n-        // be a valid key for the given table. Instead we make sure that\n-        // nobody tries to write to such a Null Object table.\n-        if mut_access {\n-            bug!(\"access to invalid TypeckTables\")\n-        }\n+fn validate_hir_id_for_typeck_tables(hir_owner: LocalDefId, hir_id: hir::HirId) {\n+    if hir_id.owner != hir_owner {\n+        ty::tls::with(|tcx| {\n+            bug!(\n+                \"node {} with HirId::owner {:?} cannot be placed in TypeckTables with hir_owner {:?}\",\n+                tcx.hir().node_to_string(hir_id),\n+                hir_id.owner,\n+                hir_owner\n+            )\n+        });\n     }\n }\n \n impl<'a, V> LocalTableInContext<'a, V> {\n     pub fn contains_key(&self, id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.data.contains_key(&id.local_id)\n     }\n \n     pub fn get(&self, id: hir::HirId) -> Option<&V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.data.get(&id.local_id)\n     }\n \n@@ -252,28 +237,28 @@ impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n }\n \n pub struct LocalTableInContextMut<'a, V> {\n-    hir_owner: Option<LocalDefId>,\n+    hir_owner: LocalDefId,\n     data: &'a mut ItemLocalMap<V>,\n }\n \n impl<'a, V> LocalTableInContextMut<'a, V> {\n     pub fn get_mut(&mut self, id: hir::HirId) -> Option<&mut V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.data.get_mut(&id.local_id)\n     }\n \n     pub fn entry(&mut self, id: hir::HirId) -> Entry<'_, hir::ItemLocalId, V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.data.entry(id.local_id)\n     }\n \n     pub fn insert(&mut self, id: hir::HirId, val: V) -> Option<V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.data.insert(id.local_id, val)\n     }\n \n     pub fn remove(&mut self, id: hir::HirId) -> Option<V> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.data.remove(&id.local_id)\n     }\n }\n@@ -324,7 +309,7 @@ pub struct GeneratorInteriorTypeCause<'tcx> {\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct TypeckTables<'tcx> {\n     /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n-    pub hir_owner: Option<LocalDefId>,\n+    pub hir_owner: LocalDefId,\n \n     /// Resolved definitions for `<T>::X` associated paths and\n     /// method calls, including those of overloaded operators.\n@@ -432,7 +417,7 @@ pub struct TypeckTables<'tcx> {\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n-    pub fn empty(hir_owner: Option<LocalDefId>) -> TypeckTables<'tcx> {\n+    pub fn new(hir_owner: LocalDefId) -> TypeckTables<'tcx> {\n         TypeckTables {\n             hir_owner,\n             type_dependent_defs: Default::default(),\n@@ -474,7 +459,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn type_dependent_def(&self, id: HirId) -> Option<(DefKind, DefId)> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.type_dependent_defs.get(&id.local_id).cloned().and_then(|r| r.ok())\n     }\n \n@@ -521,7 +506,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn node_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.node_types.get(&id.local_id).cloned()\n     }\n \n@@ -530,12 +515,12 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn node_substs(&self, id: hir::HirId) -> SubstsRef<'tcx> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.node_substs.get(&id.local_id).cloned().unwrap_or_else(|| InternalSubsts::empty())\n     }\n \n     pub fn node_substs_opt(&self, id: hir::HirId) -> Option<SubstsRef<'tcx>> {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id);\n         self.node_substs.get(&id.local_id).cloned()\n     }\n \n@@ -578,7 +563,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn expr_adjustments(&self, expr: &hir::Expr<'_>) -> &[ty::adjustment::Adjustment<'tcx>] {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, expr.hir_id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, expr.hir_id);\n         self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n     }\n \n@@ -657,7 +642,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn is_coercion_cast(&self, hir_id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_tables(self.hir_owner, hir_id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, hir_id);\n         self.coercion_casts.contains(&hir_id.local_id)\n     }\n \n@@ -710,7 +695,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             hash_stable_hashmap(hcx, hasher, upvar_capture_map, |up_var_id, hcx| {\n                 let ty::UpvarId { var_path, closure_expr_id } = *up_var_id;\n \n-                assert_eq!(Some(var_path.hir_id.owner), hir_owner);\n+                assert_eq!(var_path.hir_id.owner, hir_owner);\n \n                 (\n                     hcx.local_def_path_hash(var_path.hir_id.owner),"}, {"sha": "87348894a5ad9296012efde1930e7d201247bcd3", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -37,10 +37,10 @@ fn should_explore(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n     }\n }\n \n-struct MarkSymbolVisitor<'a, 'tcx> {\n+struct MarkSymbolVisitor<'tcx> {\n     worklist: Vec<hir::HirId>,\n     tcx: TyCtxt<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n     live_symbols: FxHashSet<hir::HirId>,\n     repr_has_repr_c: bool,\n     in_pat: bool,\n@@ -50,7 +50,15 @@ struct MarkSymbolVisitor<'a, 'tcx> {\n     struct_constructors: FxHashMap<hir::HirId, hir::HirId>,\n }\n \n-impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n+impl<'tcx> MarkSymbolVisitor<'tcx> {\n+    /// Gets the type-checking side-tables for the current body.\n+    /// As this will ICE if called outside bodies, only call when working with\n+    /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n+    #[track_caller]\n+    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n+        self.maybe_typeck_tables.expect(\"`MarkSymbolVisitor::tables` called outside of body\")\n+    }\n+\n     fn check_def_id(&mut self, def_id: DefId) {\n         if let Some(def_id) = def_id.as_local() {\n             let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n@@ -107,17 +115,17 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn lookup_and_handle_method(&mut self, id: hir::HirId) {\n-        if let Some(def_id) = self.tables.type_dependent_def_id(id) {\n+        if let Some(def_id) = self.tables().type_dependent_def_id(id) {\n             self.check_def_id(def_id);\n         } else {\n             bug!(\"no type-dependent def for method\");\n         }\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr<'_>, hir_id: hir::HirId) {\n-        match self.tables.expr_ty_adjusted(lhs).kind {\n+        match self.tables().expr_ty_adjusted(lhs).kind {\n             ty::Adt(def, _) => {\n-                let index = self.tcx.field_index(hir_id, self.tables);\n+                let index = self.tcx.field_index(hir_id, self.tables());\n                 self.insert_def_id(def.non_enum_variant().fields[index].did);\n             }\n             ty::Tuple(..) => {}\n@@ -131,15 +139,15 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         res: Res,\n         pats: &[hir::FieldPat<'_>],\n     ) {\n-        let variant = match self.tables.node_type(lhs.hir_id).kind {\n+        let variant = match self.tables().node_type(lhs.hir_id).kind {\n             ty::Adt(adt, _) => adt.variant_of_res(res),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\"),\n         };\n         for pat in pats {\n             if let PatKind::Wild = pat.pat.kind {\n                 continue;\n             }\n-            let index = self.tcx.field_index(pat.hir_id, self.tables);\n+            let index = self.tcx.field_index(pat.hir_id, self.tables());\n             self.insert_def_id(variant.fields[index].did);\n         }\n     }\n@@ -204,26 +212,25 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn mark_as_used_if_union(&mut self, adt: &ty::AdtDef, fields: &[hir::Field<'_>]) {\n         if adt.is_union() && adt.non_enum_variant().fields.len() > 1 && adt.did.is_local() {\n             for field in fields {\n-                let index = self.tcx.field_index(field.hir_id, self.tables);\n+                let index = self.tcx.field_index(field.hir_id, self.tables());\n                 self.insert_def_id(adt.non_enum_variant().fields[index].did);\n             }\n         }\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n     type Map = intravisit::ErasedMap<'tcx>;\n \n     fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n         NestedVisitorMap::None\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_tables = self.tables;\n-        self.tables = self.tcx.body_tables(body);\n+        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.tcx.body_tables(body));\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n-        self.tables = old_tables;\n+        self.maybe_typeck_tables = old_maybe_typeck_tables;\n     }\n \n     fn visit_variant_data(\n@@ -248,7 +255,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         match expr.kind {\n             hir::ExprKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n-                let res = self.tables.qpath_res(qpath, expr.hir_id);\n+                let res = self.tables().qpath_res(qpath, expr.hir_id);\n                 self.handle_res(res);\n             }\n             hir::ExprKind::MethodCall(..) => {\n@@ -258,9 +265,9 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.handle_field_access(&lhs, expr.hir_id);\n             }\n             hir::ExprKind::Struct(ref qpath, ref fields, _) => {\n-                let res = self.tables.qpath_res(qpath, expr.hir_id);\n+                let res = self.tables().qpath_res(qpath, expr.hir_id);\n                 self.handle_res(res);\n-                if let ty::Adt(ref adt, _) = self.tables.expr_ty(expr).kind {\n+                if let ty::Adt(ref adt, _) = self.tables().expr_ty(expr).kind {\n                     self.mark_as_used_if_union(adt, fields);\n                 }\n             }\n@@ -283,11 +290,11 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n         match pat.kind {\n             PatKind::Struct(ref path, ref fields, _) => {\n-                let res = self.tables.qpath_res(path, pat.hir_id);\n+                let res = self.tables().qpath_res(path, pat.hir_id);\n                 self.handle_field_pattern_match(pat, res, fields);\n             }\n             PatKind::Path(ref qpath) => {\n-                let res = self.tables.qpath_res(qpath, pat.hir_id);\n+                let res = self.tables().qpath_res(qpath, pat.hir_id);\n                 self.handle_res(res);\n             }\n             _ => (),\n@@ -473,7 +480,7 @@ fn find_live<'tcx>(\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n         tcx,\n-        tables: &ty::TypeckTables::empty(None),\n+        maybe_typeck_tables: None,\n         live_symbols: Default::default(),\n         repr_has_repr_c: false,\n         in_pat: false,"}, {"sha": "5109d8debeefd26e5c38e14829687298eb5ee751", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -8,6 +8,7 @@\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(track_caller))]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "50fcefa3569ac422884c783471eed7f4878472e3", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -60,10 +60,10 @@ fn method_might_be_inlined(\n }\n \n // Information needed while computing reachability.\n-struct ReachableContext<'a, 'tcx> {\n+struct ReachableContext<'tcx> {\n     // The type context.\n     tcx: TyCtxt<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n     // The set of items which must be exported in the linkage sense.\n     reachable_symbols: HirIdSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n@@ -73,26 +73,25 @@ struct ReachableContext<'a, 'tcx> {\n     any_library: bool,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for ReachableContext<'tcx> {\n     type Map = intravisit::ErasedMap<'tcx>;\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n         NestedVisitorMap::None\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_tables = self.tables;\n-        self.tables = self.tcx.body_tables(body);\n+        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.tcx.body_tables(body));\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n-        self.tables = old_tables;\n+        self.maybe_typeck_tables = old_maybe_typeck_tables;\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         let res = match expr.kind {\n-            hir::ExprKind::Path(ref qpath) => Some(self.tables.qpath_res(qpath, expr.hir_id)),\n+            hir::ExprKind::Path(ref qpath) => Some(self.tables().qpath_res(qpath, expr.hir_id)),\n             hir::ExprKind::MethodCall(..) => self\n-                .tables\n+                .tables()\n                 .type_dependent_def(expr.hir_id)\n                 .map(|(kind, def_id)| Res::Def(kind, def_id)),\n             _ => None,\n@@ -133,7 +132,15 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n+impl<'tcx> ReachableContext<'tcx> {\n+    /// Gets the type-checking side-tables for the current body.\n+    /// As this will ICE if called outside bodies, only call when working with\n+    /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n+    #[track_caller]\n+    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n+        self.maybe_typeck_tables.expect(\"`ReachableContext::tables` called outside of body\")\n+    }\n+\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n@@ -381,7 +388,7 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet\n         });\n     let mut reachable_context = ReachableContext {\n         tcx,\n-        tables: &ty::TypeckTables::empty(None),\n+        maybe_typeck_tables: None,\n         reachable_symbols: Default::default(),\n         worklist: Vec::new(),\n         any_library,"}, {"sha": "de21365c5369af268742886e76c5b06189750fae", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 58, "deletions": 98, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -2,6 +2,7 @@\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(track_caller))]\n #![recursion_limit = \"256\"]\n \n use rustc_attr as attr;\n@@ -345,17 +346,6 @@ fn def_id_visibility<'tcx>(\n     }\n }\n \n-// Set the correct `TypeckTables` for the given `item_id` (or an empty table if\n-// there is no `TypeckTables` for the item).\n-fn item_tables<'a, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    hir_id: hir::HirId,\n-    empty_tables: &'a ty::TypeckTables<'tcx>,\n-) -> &'a ty::TypeckTables<'tcx> {\n-    let def_id = tcx.hir().local_def_id(hir_id);\n-    if tcx.has_typeck_tables(def_id) { tcx.typeck_tables_of(def_id) } else { empty_tables }\n-}\n-\n fn min(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'_>) -> ty::Visibility {\n     if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n }\n@@ -1029,14 +1019,21 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n /// This pass performs remaining checks for fields in struct expressions and patterns.\n //////////////////////////////////////////////////////////////////////////////////////\n \n-struct NamePrivacyVisitor<'a, 'tcx> {\n+struct NamePrivacyVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n     current_item: Option<hir::HirId>,\n-    empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n-impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n+impl<'tcx> NamePrivacyVisitor<'tcx> {\n+    /// Gets the type-checking side-tables for the current body.\n+    /// As this will ICE if called outside bodies, only call when working with\n+    /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n+    #[track_caller]\n+    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n+        self.maybe_typeck_tables.expect(\"`NamePrivacyVisitor::tables` called outside of body\")\n+    }\n+\n     // Checks that a field in a struct constructor (expression or pattern) is accessible.\n     fn check_field(\n         &mut self,\n@@ -1072,7 +1069,7 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n     type Map = Map<'tcx>;\n \n     /// We want to visit items in the context of their containing\n@@ -1087,39 +1084,22 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let orig_tables = mem::replace(&mut self.tables, self.tcx.body_tables(body));\n+        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.tcx.body_tables(body));\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n-        self.tables = orig_tables;\n+        self.maybe_typeck_tables = old_maybe_typeck_tables;\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = mem::replace(&mut self.current_item, Some(item.hir_id));\n-        let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n+        let orig_current_item = self.current_item.replace(item.hir_id);\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n-        self.tables = orig_tables;\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n-        let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ti.hir_id, self.empty_tables));\n-        intravisit::walk_trait_item(self, ti);\n-        self.tables = orig_tables;\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n-        let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ii.hir_id, self.empty_tables));\n-        intravisit::walk_impl_item(self, ii);\n-        self.tables = orig_tables;\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         if let hir::ExprKind::Struct(ref qpath, fields, ref base) = expr.kind {\n-            let res = self.tables.qpath_res(qpath, expr.hir_id);\n-            let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n+            let res = self.tables().qpath_res(qpath, expr.hir_id);\n+            let adt = self.tables().expr_ty(expr).ty_adt_def().unwrap();\n             let variant = adt.variant_of_res(res);\n             if let Some(ref base) = *base {\n                 // If the expression uses FRU we need to make sure all the unmentioned fields\n@@ -1128,7 +1108,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 for (vf_index, variant_field) in variant.fields.iter().enumerate() {\n                     let field = fields\n                         .iter()\n-                        .find(|f| self.tcx.field_index(f.hir_id, self.tables) == vf_index);\n+                        .find(|f| self.tcx.field_index(f.hir_id, self.tables()) == vf_index);\n                     let (use_ctxt, span) = match field {\n                         Some(field) => (field.ident.span, field.span),\n                         None => (base.span, base.span),\n@@ -1138,7 +1118,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n             } else {\n                 for field in fields {\n                     let use_ctxt = field.ident.span;\n-                    let index = self.tcx.field_index(field.hir_id, self.tables);\n+                    let index = self.tcx.field_index(field.hir_id, self.tables());\n                     self.check_field(use_ctxt, field.span, adt, &variant.fields[index], false);\n                 }\n             }\n@@ -1149,12 +1129,12 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n         if let PatKind::Struct(ref qpath, fields, _) = pat.kind {\n-            let res = self.tables.qpath_res(qpath, pat.hir_id);\n-            let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n+            let res = self.tables().qpath_res(qpath, pat.hir_id);\n+            let adt = self.tables().pat_ty(pat).ty_adt_def().unwrap();\n             let variant = adt.variant_of_res(res);\n             for field in fields {\n                 let use_ctxt = field.ident.span;\n-                let index = self.tcx.field_index(field.hir_id, self.tables);\n+                let index = self.tcx.field_index(field.hir_id, self.tables());\n                 self.check_field(use_ctxt, field.span, adt, &variant.fields[index], false);\n             }\n         }\n@@ -1169,16 +1149,22 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n /// Checks are performed on \"semantic\" types regardless of names and their hygiene.\n ////////////////////////////////////////////////////////////////////////////////////////////\n \n-struct TypePrivacyVisitor<'a, 'tcx> {\n+struct TypePrivacyVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n     current_item: LocalDefId,\n-    in_body: bool,\n     span: Span,\n-    empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n-impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n+impl<'tcx> TypePrivacyVisitor<'tcx> {\n+    /// Gets the type-checking side-tables for the current body.\n+    /// As this will ICE if called outside bodies, only call when working with\n+    /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n+    #[track_caller]\n+    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n+        self.maybe_typeck_tables.expect(\"`TypePrivacyVisitor::tables` called outside of body\")\n+    }\n+\n     fn item_is_accessible(&self, did: DefId) -> bool {\n         def_id_visibility(self.tcx, did)\n             .0\n@@ -1188,10 +1174,11 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n     // Take node-id of an expression or pattern and check its type for privacy.\n     fn check_expr_pat_type(&mut self, id: hir::HirId, span: Span) -> bool {\n         self.span = span;\n-        if self.visit(self.tables.node_type(id)) || self.visit(self.tables.node_substs(id)) {\n+        let tables = self.tables();\n+        if self.visit(tables.node_type(id)) || self.visit(tables.node_substs(id)) {\n             return true;\n         }\n-        if let Some(adjustments) = self.tables.adjustments().get(id) {\n+        if let Some(adjustments) = tables.adjustments().get(id) {\n             for adjustment in adjustments {\n                 if self.visit(adjustment.target) {\n                     return true;\n@@ -1214,7 +1201,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n     type Map = Map<'tcx>;\n \n     /// We want to visit items in the context of their containing\n@@ -1229,19 +1216,17 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let orig_tables = mem::replace(&mut self.tables, self.tcx.body_tables(body));\n-        let orig_in_body = mem::replace(&mut self.in_body, true);\n+        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.tcx.body_tables(body));\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n-        self.tables = orig_tables;\n-        self.in_body = orig_in_body;\n+        self.maybe_typeck_tables = old_maybe_typeck_tables;\n     }\n \n     fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'tcx>) {\n         self.span = hir_ty.span;\n-        if self.in_body {\n+        if let Some(tables) = self.maybe_typeck_tables {\n             // Types in bodies.\n-            if self.visit(self.tables.node_type(hir_ty.hir_id)) {\n+            if self.visit(tables.node_type(hir_ty.hir_id)) {\n                 return;\n             }\n         } else {\n@@ -1258,7 +1243,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef<'tcx>) {\n         self.span = trait_ref.path.span;\n-        if !self.in_body {\n+        if self.maybe_typeck_tables.is_none() {\n             // Avoid calling `hir_trait_to_predicates` in bodies, it will ICE.\n             // The traits' privacy in bodies is already checked as a part of trait object types.\n             let bounds = rustc_typeck::hir_trait_to_predicates(\n@@ -1304,7 +1289,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             hir::ExprKind::MethodCall(_, span, _, _) => {\n                 // Method calls have to be checked specially.\n                 self.span = span;\n-                if let Some(def_id) = self.tables.type_dependent_def_id(expr.hir_id) {\n+                if let Some(def_id) = self.tables().type_dependent_def_id(expr.hir_id) {\n                     if self.visit(self.tcx.type_of(def_id)) {\n                         return;\n                     }\n@@ -1327,9 +1312,14 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     // more code internal visibility at link time. (Access to private functions\n     // is already prohibited by type privacy for function types.)\n     fn visit_qpath(&mut self, qpath: &'tcx hir::QPath<'tcx>, id: hir::HirId, span: Span) {\n-        let def = match self.tables.qpath_res(qpath, id) {\n-            Res::Def(kind, def_id) => Some((kind, def_id)),\n-            _ => None,\n+        let def = match qpath {\n+            hir::QPath::Resolved(_, path) => match path.res {\n+                Res::Def(kind, def_id) => Some((kind, def_id)),\n+                _ => None,\n+            },\n+            hir::QPath::TypeRelative(..) => {\n+                self.maybe_typeck_tables.and_then(|tables| tables.type_dependent_def(id))\n+            }\n         };\n         let def = def.filter(|(kind, _)| match kind {\n             DefKind::AssocFn | DefKind::AssocConst | DefKind::AssocTy | DefKind::Static => true,\n@@ -1385,31 +1375,14 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let orig_current_item =\n             mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.hir_id));\n-        let orig_in_body = mem::replace(&mut self.in_body, false);\n-        let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n+        let old_maybe_typeck_tables = self.maybe_typeck_tables.take();\n         intravisit::walk_item(self, item);\n-        self.tables = orig_tables;\n-        self.in_body = orig_in_body;\n+        self.maybe_typeck_tables = old_maybe_typeck_tables;\n         self.current_item = orig_current_item;\n     }\n-\n-    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n-        let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ti.hir_id, self.empty_tables));\n-        intravisit::walk_trait_item(self, ti);\n-        self.tables = orig_tables;\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n-        let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ii.hir_id, self.empty_tables));\n-        intravisit::walk_impl_item(self, ii);\n-        self.tables = orig_tables;\n-    }\n }\n \n-impl DefIdVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n+impl DefIdVisitor<'tcx> for TypePrivacyVisitor<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n@@ -2066,29 +2039,16 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    let empty_tables = ty::TypeckTables::empty(None);\n-\n     // Check privacy of names not checked in previous compilation stages.\n-    let mut visitor = NamePrivacyVisitor {\n-        tcx,\n-        tables: &empty_tables,\n-        current_item: None,\n-        empty_tables: &empty_tables,\n-    };\n+    let mut visitor = NamePrivacyVisitor { tcx, maybe_typeck_tables: None, current_item: None };\n     let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n \n     intravisit::walk_mod(&mut visitor, module, hir_id);\n \n     // Check privacy of explicitly written types and traits as well as\n     // inferred types of expressions and patterns.\n-    let mut visitor = TypePrivacyVisitor {\n-        tcx,\n-        tables: &empty_tables,\n-        current_item: module_def_id,\n-        in_body: false,\n-        span,\n-        empty_tables: &empty_tables,\n-    };\n+    let mut visitor =\n+        TypePrivacyVisitor { tcx, maybe_typeck_tables: None, current_item: module_def_id, span };\n     intravisit::walk_mod(&mut visitor, module, hir_id);\n }\n "}, {"sha": "38be97fc8d9eb2186c814464d1f90655c0f486a1", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -109,15 +109,15 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         F: FnOnce(&mut Self),\n     {\n         let tables = if self.tcx.has_typeck_tables(item_def_id) {\n-            self.tcx.typeck_tables_of(item_def_id)\n+            Some(self.tcx.typeck_tables_of(item_def_id))\n         } else {\n-            self.save_ctxt.empty_tables\n+            None\n         };\n \n-        let old_tables = self.save_ctxt.tables;\n-        self.save_ctxt.tables = tables;\n+        let old_maybe_typeck_tables = self.save_ctxt.maybe_typeck_tables;\n+        self.save_ctxt.maybe_typeck_tables = tables;\n         f(self);\n-        self.save_ctxt.tables = old_tables;\n+        self.save_ctxt.maybe_typeck_tables = old_maybe_typeck_tables;\n     }\n \n     fn span_from_span(&self, span: Span) -> SpanData {\n@@ -226,7 +226,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             collector.visit_pat(&arg.pat);\n \n             for (hir_id, ident, ..) in collector.collected_idents {\n-                let typ = match self.save_ctxt.tables.node_type_opt(hir_id) {\n+                let typ = match self.save_ctxt.tables().node_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n                 };\n@@ -859,7 +859,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         match p.kind {\n             hir::PatKind::Struct(ref _path, fields, _) => {\n                 // FIXME do something with _path?\n-                let adt = match self.save_ctxt.tables.node_type_opt(p.hir_id) {\n+                let adt = match self.save_ctxt.tables().node_type_opt(p.hir_id) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n                     _ => {\n                         intravisit::walk_pat(self, p);\n@@ -900,7 +900,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 Res::Local(hir_id) => {\n                     let typ = self\n                         .save_ctxt\n-                        .tables\n+                        .tables()\n                         .node_type_opt(hir_id)\n                         .map(|t| t.to_string())\n                         .unwrap_or_default();\n@@ -1393,7 +1393,7 @@ impl<'l, 'tcx> Visitor<'tcx> for DumpVisitor<'l, 'tcx> {\n         match ex.kind {\n             hir::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = self.save_ctxt.tcx.hir().expect_expr(ex.hir_id);\n-                let adt = match self.save_ctxt.tables.expr_ty_opt(&hir_expr) {\n+                let adt = match self.save_ctxt.tables().expr_ty_opt(&hir_expr) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n                     _ => {\n                         intravisit::walk_expr(self, ex);"}, {"sha": "1ac91289a8623fb16c0de41feef992f743dc620b", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -1,6 +1,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(nll)]\n #![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(track_caller))]\n #![recursion_limit = \"256\"]\n \n mod dump_visitor;\n@@ -47,12 +48,9 @@ use rls_data::{\n \n use log::{debug, error, info};\n \n-pub struct SaveContext<'l, 'tcx> {\n+pub struct SaveContext<'l, 'tcx: 'l> {\n     tcx: TyCtxt<'tcx>,\n-    tables: &'l ty::TypeckTables<'tcx>,\n-    /// Used as a fallback when nesting the typeck tables during item processing\n-    /// (if these are not available for that item, e.g. don't own a body)\n-    empty_tables: &'l ty::TypeckTables<'tcx>,\n+    maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n     access_levels: &'l AccessLevels,\n     span_utils: SpanUtils<'tcx>,\n     config: Config,\n@@ -67,6 +65,14 @@ pub enum Data {\n }\n \n impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n+    /// Gets the type-checking side-tables for the current body.\n+    /// As this will ICE if called outside bodies, only call when working with\n+    /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n+    #[track_caller]\n+    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n+        self.maybe_typeck_tables.expect(\"`SaveContext::tables` called outside of body\")\n+    }\n+\n     fn span_from_span(&self, span: Span) -> SpanData {\n         use rls_span::{Column, Row};\n \n@@ -518,13 +524,13 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_expr_data(&self, expr: &hir::Expr<'_>) -> Option<Data> {\n-        let ty = self.tables.expr_ty_adjusted_opt(expr)?;\n+        let ty = self.tables().expr_ty_adjusted_opt(expr)?;\n         if matches!(ty.kind, ty::Error(_)) {\n             return None;\n         }\n         match expr.kind {\n             hir::ExprKind::Field(ref sub_ex, ident) => {\n-                match self.tables.expr_ty_adjusted(&sub_ex).kind {\n+                match self.tables().expr_ty_adjusted(&sub_ex).kind {\n                     ty::Adt(def, _) if !def.is_enum() => {\n                         let variant = &def.non_enum_variant();\n                         filter!(self.span_utils, ident.span);\n@@ -569,7 +575,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 }\n             }\n             hir::ExprKind::MethodCall(ref seg, ..) => {\n-                let method_id = match self.tables.type_dependent_def_id(expr.hir_id) {\n+                let method_id = match self.tables().type_dependent_def_id(expr.hir_id) {\n                     Some(id) => id,\n                     None => {\n                         debug!(\"could not resolve method id for {:?}\", expr);\n@@ -618,7 +624,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             },\n \n             Node::Expr(&hir::Expr { kind: hir::ExprKind::Struct(ref qpath, ..), .. }) => {\n-                self.tables.qpath_res(qpath, hir_id)\n+                self.tables().qpath_res(qpath, hir_id)\n             }\n \n             Node::Expr(&hir::Expr { kind: hir::ExprKind::Path(ref qpath), .. })\n@@ -629,9 +635,12 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     | hir::PatKind::TupleStruct(ref qpath, ..),\n                 ..\n             })\n-            | Node::Ty(&hir::Ty { kind: hir::TyKind::Path(ref qpath), .. }) => {\n-                self.tables.qpath_res(qpath, hir_id)\n-            }\n+            | Node::Ty(&hir::Ty { kind: hir::TyKind::Path(ref qpath), .. }) => match qpath {\n+                hir::QPath::Resolved(_, path) => path.res,\n+                hir::QPath::TypeRelative(..) => self\n+                    .maybe_typeck_tables\n+                    .map_or(Res::Err, |tables| tables.qpath_res(qpath, hir_id)),\n+            },\n \n             Node::Binding(&hir::Pat {\n                 kind: hir::PatKind::Binding(_, canonical_id, ..), ..\n@@ -1001,8 +1010,7 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n \n         let save_ctxt = SaveContext {\n             tcx,\n-            tables: &ty::TypeckTables::empty(None),\n-            empty_tables: &ty::TypeckTables::empty(None),\n+            maybe_typeck_tables: None,\n             access_levels: &access_levels,\n             span_utils: SpanUtils::new(&tcx.sess),\n             config: find_config(config),"}, {"sha": "cdfe5f9f92db04e9d369cf3b28c2b0450a374a12", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -1407,7 +1407,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         );\n         let query_tables;\n         let tables: &TypeckTables<'tcx> = match &in_progress_tables {\n-            Some(t) if t.hir_owner.map(|owner| owner.to_def_id()) == Some(generator_did_root) => t,\n+            Some(t) if t.hir_owner.to_def_id() == generator_did_root => t,\n             _ => {\n                 query_tables = self.tcx.typeck_tables_of(generator_did.expect_local());\n                 &query_tables"}, {"sha": "fbf81e94d03d550eed8628fb4a1c393b6e5f93a1", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 62, "deletions": 65, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -1039,22 +1039,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let mut suggested = false;\n             if let (Some(ref param), Some(ref table)) = (param_type, self.in_progress_tables) {\n                 let table_owner = table.borrow().hir_owner;\n-                if let Some(table_owner) = table_owner {\n-                    let generics = self.tcx.generics_of(table_owner.to_def_id());\n-                    let type_param = generics.type_param(param, self.tcx);\n-                    let hir = &self.tcx.hir();\n-                    if let Some(def_id) = type_param.def_id.as_local() {\n-                        let id = hir.as_local_hir_id(def_id);\n-                        // Get the `hir::Param` to verify whether it already has any bounds.\n-                        // We do this to avoid suggesting code that ends up as `T: FooBar`,\n-                        // instead we suggest `T: Foo + Bar` in that case.\n-                        match hir.get(id) {\n-                            Node::GenericParam(ref param) => {\n-                                let mut impl_trait = false;\n-                                let has_bounds = if let hir::GenericParamKind::Type {\n-                                    synthetic: Some(_),\n-                                    ..\n-                                } = &param.kind\n+                let generics = self.tcx.generics_of(table_owner.to_def_id());\n+                let type_param = generics.type_param(param, self.tcx);\n+                let hir = &self.tcx.hir();\n+                if let Some(def_id) = type_param.def_id.as_local() {\n+                    let id = hir.as_local_hir_id(def_id);\n+                    // Get the `hir::Param` to verify whether it already has any bounds.\n+                    // We do this to avoid suggesting code that ends up as `T: FooBar`,\n+                    // instead we suggest `T: Foo + Bar` in that case.\n+                    match hir.get(id) {\n+                        Node::GenericParam(ref param) => {\n+                            let mut impl_trait = false;\n+                            let has_bounds =\n+                                if let hir::GenericParamKind::Type { synthetic: Some(_), .. } =\n+                                    &param.kind\n                                 {\n                                     // We've found `fn foo(x: impl Trait)` instead of\n                                     // `fn foo<T>(x: T)`. We want to suggest the correct\n@@ -1065,64 +1063,63 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 } else {\n                                     param.bounds.get(0)\n                                 };\n-                                let sp = hir.span(id);\n-                                let sp = if let Some(first_bound) = has_bounds {\n-                                    // `sp` only covers `T`, change it so that it covers\n-                                    // `T:` when appropriate\n-                                    sp.until(first_bound.span())\n-                                } else {\n-                                    sp\n-                                };\n-                                let trait_def_ids: FxHashSet<DefId> = param\n-                                    .bounds\n-                                    .iter()\n-                                    .filter_map(|bound| Some(bound.trait_ref()?.trait_def_id()?))\n-                                    .collect();\n-                                if !candidates.iter().any(|t| trait_def_ids.contains(&t.def_id)) {\n-                                    err.span_suggestions(\n-                                        sp,\n-                                        &message(format!(\n-                                            \"restrict type parameter `{}` with\",\n-                                            param.name.ident(),\n-                                        )),\n-                                        candidates.iter().map(|t| {\n-                                            format!(\n-                                                \"{}{} {}{}\",\n-                                                param.name.ident(),\n-                                                if impl_trait { \" +\" } else { \":\" },\n-                                                self.tcx.def_path_str(t.def_id),\n-                                                if has_bounds.is_some() { \" + \" } else { \"\" },\n-                                            )\n-                                        }),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                                suggested = true;\n-                            }\n-                            Node::Item(hir::Item {\n-                                kind: hir::ItemKind::Trait(.., bounds, _),\n-                                ident,\n-                                ..\n-                            }) => {\n-                                let (sp, sep, article) = if bounds.is_empty() {\n-                                    (ident.span.shrink_to_hi(), \":\", \"a\")\n-                                } else {\n-                                    (bounds.last().unwrap().span().shrink_to_hi(), \" +\", \"another\")\n-                                };\n+                            let sp = hir.span(id);\n+                            let sp = if let Some(first_bound) = has_bounds {\n+                                // `sp` only covers `T`, change it so that it covers\n+                                // `T:` when appropriate\n+                                sp.until(first_bound.span())\n+                            } else {\n+                                sp\n+                            };\n+                            let trait_def_ids: FxHashSet<DefId> = param\n+                                .bounds\n+                                .iter()\n+                                .filter_map(|bound| Some(bound.trait_ref()?.trait_def_id()?))\n+                                .collect();\n+                            if !candidates.iter().any(|t| trait_def_ids.contains(&t.def_id)) {\n                                 err.span_suggestions(\n                                     sp,\n-                                    &message(format!(\"add {} supertrait for\", article)),\n+                                    &message(format!(\n+                                        \"restrict type parameter `{}` with\",\n+                                        param.name.ident(),\n+                                    )),\n                                     candidates.iter().map(|t| {\n-                                        format!(\"{} {}\", sep, self.tcx.def_path_str(t.def_id),)\n+                                        format!(\n+                                            \"{}{} {}{}\",\n+                                            param.name.ident(),\n+                                            if impl_trait { \" +\" } else { \":\" },\n+                                            self.tcx.def_path_str(t.def_id),\n+                                            if has_bounds.is_some() { \" + \" } else { \"\" },\n+                                        )\n                                     }),\n                                     Applicability::MaybeIncorrect,\n                                 );\n-                                suggested = true;\n                             }\n-                            _ => {}\n+                            suggested = true;\n+                        }\n+                        Node::Item(hir::Item {\n+                            kind: hir::ItemKind::Trait(.., bounds, _),\n+                            ident,\n+                            ..\n+                        }) => {\n+                            let (sp, sep, article) = if bounds.is_empty() {\n+                                (ident.span.shrink_to_hi(), \":\", \"a\")\n+                            } else {\n+                                (bounds.last().unwrap().span().shrink_to_hi(), \" +\", \"another\")\n+                            };\n+                            err.span_suggestions(\n+                                sp,\n+                                &message(format!(\"add {} supertrait for\", article)),\n+                                candidates.iter().map(|t| {\n+                                    format!(\"{} {}\", sep, self.tcx.def_path_str(t.def_id),)\n+                                }),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                            suggested = true;\n                         }\n+                        _ => {}\n                     }\n-                };\n+                }\n             }\n \n             if !suggested {"}, {"sha": "58fd0f989c67897a44c8633af120764b713742ce", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -1126,7 +1126,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n \n     // Consistency check our TypeckTables instance can hold all ItemLocalIds\n     // it will need to hold.\n-    assert_eq!(tables.hir_owner, Some(id.owner));\n+    assert_eq!(tables.hir_owner, id.owner);\n \n     tables\n }"}, {"sha": "fa17696e02b3021a226a4b8d406ebf2bdbb8dddb", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -109,12 +109,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     ) -> WritebackCx<'cx, 'tcx> {\n         let owner = body.id().hir_id.owner;\n \n-        WritebackCx {\n-            fcx,\n-            tables: ty::TypeckTables::empty(Some(owner)),\n-            body,\n-            rustc_dump_user_substs,\n-        }\n+        WritebackCx { fcx, tables: ty::TypeckTables::new(owner), body, rustc_dump_user_substs }\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -342,7 +337,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_closures(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n-        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n+        let common_hir_owner = fcx_tables.hir_owner;\n \n         for (&id, &origin) in fcx_tables.closure_kind_origins().iter() {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id: id };\n@@ -363,7 +358,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_user_provided_tys(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n-        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n+        let common_hir_owner = fcx_tables.hir_owner;\n \n         let mut errors_buffer = Vec::new();\n         for (&local_id, c_ty) in fcx_tables.user_provided_types().iter() {\n@@ -561,7 +556,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_liberated_fn_sigs(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n-        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n+        let common_hir_owner = fcx_tables.hir_owner;\n \n         for (&local_id, fn_sig) in fcx_tables.liberated_fn_sigs().iter() {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n@@ -573,7 +568,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_fru_field_types(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n-        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n+        let common_hir_owner = fcx_tables.hir_owner;\n \n         for (&local_id, ftys) in fcx_tables.fru_field_types().iter() {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };"}, {"sha": "1115ba1bf922d37725c61d58bcb1dd2113543cae", "filename": "src/tools/clippy/clippy_lints/src/atomic_ordering.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -76,7 +76,7 @@ fn check_atomic_load_store(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         if method == \"load\" || method == \"store\";\n         let ordering_arg = if method == \"load\" { &args[1] } else { &args[2] };\n         if let ExprKind::Path(ref ordering_qpath) = ordering_arg.kind;\n-        if let Some(ordering_def_id) = cx.tables().qpath_res(ordering_qpath, ordering_arg.hir_id).opt_def_id();\n+        if let Some(ordering_def_id) = cx.qpath_res(ordering_qpath, ordering_arg.hir_id).opt_def_id();\n         then {\n             if method == \"load\" &&\n                 match_ordering_def_path(cx, ordering_def_id, &[\"Release\", \"AcqRel\"]) {\n@@ -107,12 +107,12 @@ fn check_memory_fence(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Call(ref func, ref args) = expr.kind;\n         if let ExprKind::Path(ref func_qpath) = func.kind;\n-        if let Some(def_id) = cx.tables().qpath_res(func_qpath, func.hir_id).opt_def_id();\n+        if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n         if [\"fence\", \"compiler_fence\"]\n             .iter()\n             .any(|func| match_def_path(cx, def_id, &[\"core\", \"sync\", \"atomic\", func]));\n         if let ExprKind::Path(ref ordering_qpath) = &args[0].kind;\n-        if let Some(ordering_def_id) = cx.tables().qpath_res(ordering_qpath, args[0].hir_id).opt_def_id();\n+        if let Some(ordering_def_id) = cx.qpath_res(ordering_qpath, args[0].hir_id).opt_def_id();\n         if match_ordering_def_path(cx, ordering_def_id, &[\"Relaxed\"]);\n         then {\n             span_lint_and_help("}, {"sha": "8cc69c806aa995c9eda7f3fa9e849b0c9d7e5205", "filename": "src/tools/clippy/clippy_lints/src/copies.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -192,7 +192,7 @@ fn lint_same_then_else(cx: &LateContext<'_, '_>, blocks: &[&Block<'_>]) {\n /// Implementation of `IFS_SAME_COND`.\n fn lint_same_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n     let hash: &dyn Fn(&&Expr<'_>) -> u64 = &|expr| -> u64 {\n-        let mut h = SpanlessHash::new(cx, cx.tables());\n+        let mut h = SpanlessHash::new(cx);\n         h.hash_expr(expr);\n         h.finish()\n     };\n@@ -215,7 +215,7 @@ fn lint_same_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n /// Implementation of `SAME_FUNCTIONS_IN_IF_CONDITION`.\n fn lint_same_fns_in_if_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n     let hash: &dyn Fn(&&Expr<'_>) -> u64 = &|expr| -> u64 {\n-        let mut h = SpanlessHash::new(cx, cx.tables());\n+        let mut h = SpanlessHash::new(cx);\n         h.hash_expr(expr);\n         h.finish()\n     };\n@@ -251,7 +251,7 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr<'_>) {\n \n     if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n         let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n-            let mut h = SpanlessHash::new(cx, cx.tables());\n+            let mut h = SpanlessHash::new(cx);\n             h.hash_expr(&arm.body);\n             h.finish()\n         };"}, {"sha": "a918c72fb275ea6417d3284b05455182845d77b8", "filename": "src/tools/clippy/clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n             if let ExprKind::Call(ref path, ..) = expr.kind;\n             if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n             if let ExprKind::Path(ref qpath) = path.kind;\n-            if let Some(def_id) = cx.tables().qpath_res(qpath, path.hir_id).opt_def_id();\n+            if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n             then {\n                 match qpath {"}, {"sha": "31fe7382e46de1e01dfe5341075bcfad281bd4e9", "filename": "src/tools/clippy/clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n                 if let ExprKind::Path(ref qpath) = lhs.kind {\n                     if let QPath::Resolved(_, ref path) = *qpath {\n                         if path.segments.len() == 1 {\n-                            if let def::Res::Local(var) = cx.tables().qpath_res(qpath, lhs.hir_id) {\n+                            if let def::Res::Local(var) = cx.qpath_res(qpath, lhs.hir_id) {\n                                 let mut visitor = ReadVisitor {\n                                     cx,\n                                     var,\n@@ -309,7 +309,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n                 if_chain! {\n                     if let QPath::Resolved(None, ref path) = *qpath;\n                     if path.segments.len() == 1;\n-                    if let def::Res::Local(local_id) = self.cx.tables().qpath_res(qpath, expr.hir_id);\n+                    if let def::Res::Local(local_id) = self.cx.qpath_res(qpath, expr.hir_id);\n                     if local_id == self.var;\n                     // Check that this is a read, not a write.\n                     if !is_in_assignment_position(self.cx, expr);"}, {"sha": "dc8795e3d11eb6c06f75789d39b08c6663e4b7c1", "filename": "src/tools/clippy/clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -88,7 +88,7 @@ fn on_argumentv1_new<'a, 'tcx>(\n         // matches `core::fmt::Display::fmt`\n         if args.len() == 2;\n         if let ExprKind::Path(ref qpath) = args[1].kind;\n-        if let Some(did) = cx.tables().qpath_res(qpath, args[1].hir_id).opt_def_id();\n+        if let Some(did) = cx.qpath_res(qpath, args[1].hir_id).opt_def_id();\n         if match_def_path(cx, did, &paths::DISPLAY_FMT_METHOD);\n         // check `(arg0,)` in match block\n         if let PatKind::Tuple(ref pats, None) = arms[0].pat.kind;"}, {"sha": "b43babc1de87901b7d12e010782a4ae7fd6ae154", "filename": "src/tools/clippy/clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -108,7 +108,7 @@ fn expr_match(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         ExprKind::Call(expr, ..) => {\n             if_chain! {\n                 if let ExprKind::Path(qpath) = &expr.kind;\n-                if let Some(path_def_id) = cx.tables().qpath_res(qpath, expr.hir_id).opt_def_id();\n+                if let Some(path_def_id) = cx.qpath_res(qpath, expr.hir_id).opt_def_id();\n                 if match_def_path(cx, path_def_id, &BEGIN_PANIC) ||\n                     match_def_path(cx, path_def_id, &BEGIN_PANIC_FMT);\n                 then { }"}, {"sha": "7d338cfa86f9fe170f1c4388d8859507b29a7a5f", "filename": "src/tools/clippy/clippy_lints/src/let_and_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -107,7 +107,7 @@ impl BorrowVisitor<'_, '_> {\n                     ..\n                 },\n                 ..,\n-            ) => self.cx.tables().qpath_res(qpath, expr.hir_id).opt_def_id(),\n+            ) => self.cx.qpath_res(qpath, expr.hir_id).opt_def_id(),\n             _ => None,\n         }\n     }"}, {"sha": "c0d8c1127b9d3fb14de7de17dae90b5741862036", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -343,7 +343,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n                 })\n             {\n                 let hir_id = ty.hir_id;\n-                match self.cx.tables().qpath_res(qpath, hir_id) {\n+                match self.cx.qpath_res(qpath, hir_id) {\n                     Res::Def(DefKind::TyAlias | DefKind::Struct, def_id) => {\n                         let generics = self.cx.tcx.generics_of(def_id);\n                         for _ in generics.params.as_slice() {"}, {"sha": "90d4a34a19a29b3c73aa69416788e4174b77a4e5", "filename": "src/tools/clippy/clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -160,10 +160,10 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr<'_>)\n     }\n }\n \n-fn unit_closure<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'a hir::Expr<'a>,\n-) -> Option<(&'tcx hir::Param<'tcx>, &'a hir::Expr<'a>)> {\n+fn unit_closure<'tcx>(\n+    cx: &LateContext<'_, 'tcx>,\n+    expr: &hir::Expr<'_>,\n+) -> Option<(&'tcx hir::Param<'tcx>, &'tcx hir::Expr<'tcx>)> {\n     if let hir::ExprKind::Closure(_, ref decl, inner_expr_id, _, _) = expr.kind {\n         let body = cx.tcx.hir().body(inner_expr_id);\n         let body_expr = &body.value;"}, {"sha": "8a665a6e1fad3f4f2321714eb59edbacb678a71a", "filename": "src/tools/clippy/clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemDiscriminant {\n             if let ExprKind::Call(ref func, ref func_args) = expr.kind;\n             // is `mem::discriminant`\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n-            if let Some(def_id) = cx.tables().qpath_res(func_qpath, func.hir_id).opt_def_id();\n+            if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::MEM_DISCRIMINANT);\n             // type is non-enum\n             let ty_param = cx.tables().node_substs(func.hir_id).type_at(0);"}, {"sha": "703f91f8ac028401a62c8b59e861c56e18795ff7", "filename": "src/tools/clippy/clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -162,7 +162,7 @@ fn check_replace_with_uninit(cx: &LateContext<'_, '_>, src: &Expr<'_>, dest: &Ex\n         if let ExprKind::Call(ref repl_func, ref repl_args) = src.kind;\n         if repl_args.is_empty();\n         if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n-        if let Some(repl_def_id) = cx.tables().qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n+        if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n         then {\n             if cx.tcx.is_diagnostic_item(sym::mem_uninitialized, repl_def_id) {\n                 let mut applicability = Applicability::MachineApplicable;\n@@ -198,7 +198,7 @@ fn check_replace_with_default(cx: &LateContext<'_, '_>, src: &Expr<'_>, dest: &E\n         if_chain! {\n             if !in_external_macro(cx.tcx.sess, expr_span);\n             if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n-            if let Some(repl_def_id) = cx.tables().qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n+            if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n             if match_def_path(cx, repl_def_id, &paths::DEFAULT_TRAIT_METHOD);\n             then {\n                 span_lint_and_then(\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n             // Check that `expr` is a call to `mem::replace()`\n             if let ExprKind::Call(ref func, ref func_args) = expr.kind;\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n-            if let Some(def_id) = cx.tables().qpath_res(func_qpath, func.hir_id).opt_def_id();\n+            if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::MEM_REPLACE);\n             if let [dest, src] = &**func_args;\n             then {"}, {"sha": "7018a2f40397603794c5d4fc0bab3fe8e3a6c5c5", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -1824,7 +1824,7 @@ fn lint_expect_fun_call(\n             hir::ExprKind::Lit(_) => true,\n             hir::ExprKind::Call(fun, _) => {\n                 if let hir::ExprKind::Path(ref p) = fun.kind {\n-                    match cx.tables().qpath_res(p, fun.hir_id) {\n+                    match cx.qpath_res(p, fun.hir_id) {\n                         hir::def::Res::Def(hir::def::DefKind::Fn | hir::def::DefKind::AssocFn, def_id) => matches!(\n                             cx.tcx.fn_sig(def_id).output().skip_binder().kind,\n                             ty::Ref(ty::ReStatic, ..)\n@@ -1844,7 +1844,7 @@ fn lint_expect_fun_call(\n                         ty::Ref(ty::ReStatic, ..)\n                     )\n                 }),\n-            hir::ExprKind::Path(ref p) => match cx.tables().qpath_res(p, arg.hir_id) {\n+            hir::ExprKind::Path(ref p) => match cx.qpath_res(p, arg.hir_id) {\n                 hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _) => true,\n                 _ => false,\n             },\n@@ -3317,7 +3317,7 @@ fn lint_option_as_ref_deref<'a, 'tcx>(\n                     if_chain! {\n                         if args.len() == 1;\n                         if let hir::ExprKind::Path(qpath) = &args[0].kind;\n-                        if let hir::def::Res::Local(local_id) = cx.tables().qpath_res(qpath, args[0].hir_id);\n+                        if let hir::def::Res::Local(local_id) = cx.qpath_res(qpath, args[0].hir_id);\n                         if closure_body.params[0].pat.hir_id == local_id;\n                         let adj = cx.tables().expr_adjustments(&args[0]).iter().map(|x| &x.kind).collect::<Box<[_]>>();\n                         if let [ty::adjustment::Adjust::Deref(None), ty::adjustment::Adjust::Borrow(_)] = *adj;\n@@ -3334,7 +3334,7 @@ fn lint_option_as_ref_deref<'a, 'tcx>(\n                         if let hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner1) = inner.kind;\n                         if let hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner2) = inner1.kind;\n                         if let hir::ExprKind::Path(ref qpath) = inner2.kind;\n-                        if let hir::def::Res::Local(local_id) = cx.tables().qpath_res(qpath, inner2.hir_id);\n+                        if let hir::def::Res::Local(local_id) = cx.qpath_res(qpath, inner2.hir_id);\n                         then {\n                             closure_body.params[0].pat.hir_id == local_id\n                         } else {"}, {"sha": "8a3df85c91bff28bd3f5d73b645296b1ca8bacc6", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -65,7 +65,7 @@ fn check_expression<'a, 'tcx>(\n                     if match_qpath(path, &paths::OPTION_SOME) {\n                         if_chain! {\n                             if let hir::ExprKind::Path(path) = &args[0].kind;\n-                            if let Res::Local(ref local) = cx.tables().qpath_res(path, args[0].hir_id);\n+                            if let Res::Local(ref local) = cx.qpath_res(path, args[0].hir_id);\n                             then {\n                                 if arg_id == *local {\n                                     return (false, false)"}, {"sha": "fcd77088b88ebf0f6818f65e2dd44765e3d9fae0", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -436,7 +436,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n                     binding != \"_result\" && // FIXME: #944\n                     is_used(cx, expr) &&\n                     // don't lint if the declaration is in a macro\n-                    non_macro_local(cx, cx.tables().qpath_res(qpath, expr.hir_id))\n+                    non_macro_local(cx, cx.qpath_res(qpath, expr.hir_id))\n                 {\n                     Some(binding)\n                 } else {"}, {"sha": "a77e104bb8f0f8c41f43d6c3ef2ff8e08f414b57", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -158,7 +158,7 @@ impl QuestionMark {\n             ExprKind::Ret(Some(ref expr)) => Self::expression_returns_none(cx, expr),\n             ExprKind::Path(ref qp) => {\n                 if let Res::Def(DefKind::Ctor(def::CtorOf::Variant, def::CtorKind::Const), def_id) =\n-                    cx.tables().qpath_res(qp, expression.hir_id)\n+                    cx.qpath_res(qp, expression.hir_id)\n                 {\n                     return match_def_path(cx, def_id, &paths::OPTION_NONE);\n                 }"}, {"sha": "0b56ef02a844b27eec65a514bbb22a0dbfb4297e", "filename": "src/tools/clippy/clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Regex {\n             if let ExprKind::Call(ref fun, ref args) = expr.kind;\n             if let ExprKind::Path(ref qpath) = fun.kind;\n             if args.len() == 1;\n-            if let Some(def_id) = cx.tables().qpath_res(qpath, fun.hir_id).opt_def_id();\n+            if let Some(def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n             then {\n                 if match_def_path(cx, def_id, &paths::REGEX_NEW) ||\n                    match_def_path(cx, def_id, &paths::REGEX_BUILDER_NEW) {"}, {"sha": "bc282e4bd987c9cc72b568eee99b2adb60fee603", "filename": "src/tools/clippy/clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -26,7 +26,7 @@ fn is_temporary(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     match &expr.kind {\n         ExprKind::Struct(..) | ExprKind::Tup(..) => true,\n         ExprKind::Path(qpath) => {\n-            if let Res::Def(DefKind::Const, ..) = cx.tables().qpath_res(qpath, expr.hir_id) {\n+            if let Res::Def(DefKind::Const, ..) = cx.qpath_res(qpath, expr.hir_id) {\n                 true\n             } else {\n                 false"}, {"sha": "4f943eeaeebc7d39878a44a5d1585129ed7550bf", "filename": "src/tools/clippy/clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ToDigitIsSome {\n                         if_chain! {\n                             if let [char_arg, radix_arg] = &**to_digit_args;\n                             if let hir::ExprKind::Path(to_digits_path) = &to_digits_call.kind;\n-                            if let to_digits_call_res = cx.tables().qpath_res(to_digits_path, to_digits_call.hir_id);\n+                            if let to_digits_call_res = cx.qpath_res(to_digits_path, to_digits_call.hir_id);\n                             if let Some(to_digits_def_id) = to_digits_call_res.opt_def_id();\n                             if match_def_path(cx, to_digits_def_id, &[\"core\", \"char\", \"methods\", \"<impl char>\", \"to_digit\"]);\n                             then {"}, {"sha": "c3e4eb05eb4edd9a93fc4a33b1e57a99b09e25a0", "filename": "src/tools/clippy/clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TraitBounds {\n             return;\n         }\n         let hash = |ty| -> u64 {\n-            let mut hasher = SpanlessHash::new(cx, cx.tables());\n+            let mut hasher = SpanlessHash::new(cx);\n             hasher.hash_ty(ty);\n             hasher.finish()\n         };"}, {"sha": "6ef4b8dcfc1944ecfb7a33d337c8320686be8506", "filename": "src/tools/clippy/clippy_lints/src/transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -299,7 +299,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n         if_chain! {\n             if let ExprKind::Call(ref path_expr, ref args) = e.kind;\n             if let ExprKind::Path(ref qpath) = path_expr.kind;\n-            if let Some(def_id) = cx.tables().qpath_res(qpath, path_expr.hir_id).opt_def_id();\n+            if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::TRANSMUTE);\n             then {\n                 let from_ty = cx.tables().expr_ty(&args[0]);"}, {"sha": "74db29e4f1d5082462284e2b56a611712a267b8a", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -2490,7 +2490,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ImplicitHasherTypeVisitor<'a, 'tcx> {\n /// Looks for default-hasher-dependent constructors like `HashMap::new`.\n struct ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    body: &'a TypeckTables<'tcx>,\n+    maybe_typeck_tables: Option<&'tcx TypeckTables<'tcx>>,\n     target: &'b ImplicitHasherType<'tcx>,\n     suggestions: BTreeMap<Span, String>,\n }\n@@ -2499,7 +2499,7 @@ impl<'a, 'b, 'tcx> ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n     fn new(cx: &'a LateContext<'a, 'tcx>, target: &'b ImplicitHasherType<'tcx>) -> Self {\n         Self {\n             cx,\n-            body: cx.tables(),\n+            maybe_typeck_tables: cx.maybe_typeck_tables(),\n             target,\n             suggestions: BTreeMap::new(),\n         }\n@@ -2510,10 +2510,9 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n     type Map = Map<'tcx>;\n \n     fn visit_body(&mut self, body: &'tcx Body<'_>) {\n-        let prev_body = self.body;\n-        self.body = self.cx.tcx.body_tables(body.id());\n+        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.cx.tcx.body_tables(body.id()));\n         walk_body(self, body);\n-        self.body = prev_body;\n+        self.maybe_typeck_tables = old_maybe_typeck_tables;\n     }\n \n     fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n@@ -2522,7 +2521,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n             if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.kind;\n             if let TyKind::Path(QPath::Resolved(None, ty_path)) = ty.kind;\n             then {\n-                if !TyS::same_type(self.target.ty(), self.body.expr_ty(e)) {\n+                if !TyS::same_type(self.target.ty(), self.maybe_typeck_tables.unwrap().expr_ty(e)) {\n                     return;\n                 }\n "}, {"sha": "0efbf68dcd842c0fd3650667655493f6f80e0da5", "filename": "src/tools/clippy/clippy_lints/src/unnamed_address.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -98,7 +98,7 @@ impl LateLintPass<'_, '_> for UnnamedAddress {\n         if_chain! {\n             if let ExprKind::Call(ref func, [ref _left, ref _right]) = expr.kind;\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n-            if let Some(def_id) = cx.tables().qpath_res(func_qpath, func.hir_id).opt_def_id();\n+            if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::PTR_EQ) ||\n                 match_def_path(cx, def_id, &paths::RC_PTR_EQ) ||\n                 match_def_path(cx, def_id, &paths::ARC_PTR_EQ);"}, {"sha": "ad5ecc0c026792f8f6e67d7b49455c0c3d05d215", "filename": "src/tools/clippy/clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n                 if_chain! {\n                     if args.len() == 1;\n                     if let ExprKind::Path(ref qpath) = path.kind;\n-                    if let Some(def_id) = cx.tables().qpath_res(qpath, path.hir_id).opt_def_id();\n+                    if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n                     let a = cx.tables().expr_ty(e);\n                     let b = cx.tables().expr_ty(&args[0]);\n "}, {"sha": "9502d85e6ee9821ed94fc7ae3f6237d48e357e38", "filename": "src/tools/clippy/clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -262,7 +262,7 @@ pub fn vec_macro<'e>(cx: &LateContext<'_, '_>, expr: &'e hir::Expr<'_>) -> Optio\n         if let hir::ExprKind::Call(ref fun, ref args) = expr.kind;\n         if let hir::ExprKind::Path(ref qpath) = fun.kind;\n         if is_expn_of(fun.span, \"vec\").is_some();\n-        if let Some(fun_def_id) = cx.tables().qpath_res(qpath, fun.hir_id).opt_def_id();\n+        if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n         then {\n             return if match_def_path(cx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n                 // `vec![elem; size]` case"}, {"sha": "bf1017d76ec636b761d9458cd5b9df420245ec20", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -22,7 +22,7 @@ use std::hash::Hash;\n pub struct SpanlessEq<'a, 'tcx> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'a, 'tcx>,\n-    tables: &'a TypeckTables<'tcx>,\n+    maybe_typeck_tables: Option<&'tcx TypeckTables<'tcx>>,\n     /// If is true, never consider as equal expressions containing function\n     /// calls.\n     ignore_fn: bool,\n@@ -32,16 +32,15 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n         Self {\n             cx,\n-            tables: cx.tables(),\n+            maybe_typeck_tables: cx.maybe_typeck_tables(),\n             ignore_fn: false,\n         }\n     }\n \n     pub fn ignore_fn(self) -> Self {\n         Self {\n-            cx: self.cx,\n-            tables: self.cx.tables(),\n             ignore_fn: true,\n+            ..self\n         }\n     }\n \n@@ -72,12 +71,14 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             return false;\n         }\n \n-        if let (Some(l), Some(r)) = (\n-            constant_simple(self.cx, self.tables, left),\n-            constant_simple(self.cx, self.tables, right),\n-        ) {\n-            if l == r {\n-                return true;\n+        if let Some(tables) = self.maybe_typeck_tables {\n+            if let (Some(l), Some(r)) = (\n+                constant_simple(self.cx, tables, left),\n+                constant_simple(self.cx, tables, right),\n+            ) {\n+                if l == r {\n+                    return true;\n+                }\n             }\n         }\n \n@@ -271,18 +272,18 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         match (left, right) {\n             (&TyKind::Slice(ref l_vec), &TyKind::Slice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyKind::Array(ref lt, ref ll_id), &TyKind::Array(ref rt, ref rl_id)) => {\n-                let full_table = self.tables;\n+                let old_maybe_typeck_tables = self.maybe_typeck_tables;\n \n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id.body));\n-                self.tables = self.cx.tcx.body_tables(ll_id.body);\n+                self.maybe_typeck_tables = Some(self.cx.tcx.body_tables(ll_id.body));\n                 let ll = celcx.expr(&self.cx.tcx.hir().body(ll_id.body).value);\n \n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(rl_id.body));\n-                self.tables = self.cx.tcx.body_tables(rl_id.body);\n+                self.maybe_typeck_tables = Some(self.cx.tcx.body_tables(rl_id.body));\n                 let rl = celcx.expr(&self.cx.tcx.hir().body(rl_id.body).value);\n \n                 let eq_ty = self.eq_ty(lt, rt);\n-                self.tables = full_table;\n+                self.maybe_typeck_tables = old_maybe_typeck_tables;\n                 eq_ty && ll == rl\n             },\n             (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => {\n@@ -347,15 +348,15 @@ pub fn over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -\n pub struct SpanlessHash<'a, 'tcx> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'a, 'tcx>,\n-    tables: &'a TypeckTables<'tcx>,\n+    maybe_typeck_tables: Option<&'tcx TypeckTables<'tcx>>,\n     s: StableHasher,\n }\n \n impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n-    pub fn new(cx: &'a LateContext<'a, 'tcx>, tables: &'a TypeckTables<'tcx>) -> Self {\n+    pub fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n         Self {\n             cx,\n-            tables,\n+            maybe_typeck_tables: cx.maybe_typeck_tables(),\n             s: StableHasher::new(),\n         }\n     }\n@@ -384,7 +385,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n     #[allow(clippy::many_single_char_names, clippy::too_many_lines)]\n     pub fn hash_expr(&mut self, e: &Expr<'_>) {\n-        let simple_const = constant_simple(self.cx, self.tables, e);\n+        let simple_const = self\n+            .maybe_typeck_tables\n+            .and_then(|tables| constant_simple(self.cx, tables, e));\n \n         // const hashing may result in the same hash as some unrelated node, so add a sort of\n         // discriminant depending on which path we're choosing next\n@@ -599,7 +602,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_name(path.ident.name);\n             },\n         }\n-        // self.cx.tables.qpath_res(p, id).hash(&mut self.s);\n+        // self.maybe_typeck_tables.unwrap().qpath_res(p, id).hash(&mut self.s);\n     }\n \n     pub fn hash_path(&mut self, p: &Path<'_>) {\n@@ -728,9 +731,8 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n     pub fn hash_body(&mut self, body_id: BodyId) {\n         // swap out TypeckTables when hashing a body\n-        let old_tables = self.tables;\n-        self.tables = self.cx.tcx.body_tables(body_id);\n+        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.cx.tcx.body_tables(body_id));\n         self.hash_expr(&self.cx.tcx.hir().body(body_id).value);\n-        self.tables = old_tables;\n+        self.maybe_typeck_tables = old_maybe_typeck_tables;\n     }\n }"}, {"sha": "ca947e9241f0f6c10a6bfa07d0d6fd0652ef80d2", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -347,7 +347,7 @@ fn is_lint_ref_type<'tcx>(cx: &LateContext<'_, 'tcx>, ty: &Ty<'_>) -> bool {\n     ) = ty.kind\n     {\n         if let TyKind::Path(ref path) = inner.kind {\n-            if let Res::Def(DefKind::Struct, def_id) = cx.tables().qpath_res(path, inner.hir_id) {\n+            if let Res::Def(DefKind::Struct, def_id) = cx.qpath_res(path, inner.hir_id) {\n                 return match_def_path(cx, def_id, &paths::LINT);\n             }\n         }"}, {"sha": "8be9ba2c3c2449ba46664fae714af7066f4db351", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3503f565e1fb7296983757d2716346f48a4a262b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=3503f565e1fb7296983757d2716346f48a4a262b", "patch": "@@ -898,7 +898,7 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     if let ExprKind::Call(ref fun, _) = expr.kind {\n         if let ExprKind::Path(ref qp) = fun.kind {\n-            let res = cx.tables().qpath_res(qp, fun.hir_id);\n+            let res = cx.qpath_res(qp, fun.hir_id);\n             return match res {\n                 def::Res::Def(DefKind::Variant | DefKind::Ctor(..), ..) => true,\n                 def::Res::Def(_, def_id) => cx.tcx.is_promotable_const_fn(def_id),\n@@ -914,7 +914,7 @@ pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_, '_>, expr: &Exp\n pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat<'_>) -> bool {\n     fn is_enum_variant(cx: &LateContext<'_, '_>, qpath: &QPath<'_>, id: HirId) -> bool {\n         matches!(\n-            cx.tables().qpath_res(qpath, id),\n+            cx.qpath_res(qpath, id),\n             def::Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(def::CtorOf::Variant, _), _)\n         )\n     }\n@@ -1190,7 +1190,7 @@ pub fn match_function_call<'a, 'tcx>(\n     if_chain! {\n         if let ExprKind::Call(ref fun, ref args) = expr.kind;\n         if let ExprKind::Path(ref qpath) = fun.kind;\n-        if let Some(fun_def_id) = cx.tables().qpath_res(qpath, fun.hir_id).opt_def_id();\n+        if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n         if match_def_path(cx, fun_def_id, path);\n         then {\n             return Some(&args)\n@@ -1317,7 +1317,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool\n     let did = match expr.kind {\n         ExprKind::Call(ref path, _) => if_chain! {\n             if let ExprKind::Path(ref qpath) = path.kind;\n-            if let def::Res::Def(_, did) = cx.tables().qpath_res(qpath, path.hir_id);\n+            if let def::Res::Def(_, did) = cx.qpath_res(qpath, path.hir_id);\n             then {\n                 Some(did)\n             } else {"}]}