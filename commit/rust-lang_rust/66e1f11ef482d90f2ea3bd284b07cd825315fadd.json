{"sha": "66e1f11ef482d90f2ea3bd284b07cd825315fadd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZTFmMTFlZjQ4MmQ5MGYyZWEzYmQyODRiMDdjZDgyNTMxNWZhZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-09T20:21:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-09T20:21:29Z"}, "message": "auto merge of #15471 : erickt/rust/push_all, r=acrichto\n\nllvm is currently not able to conver `Vec::extend` into a memcpy for `Copy` types, which results in methods like `Vec::push_all` to run twice as slow as it should be running. This patch takes the unsafe `Vec::clone` optimization to speed up all the operations that are cloning a slice into a `Vec`.\r\n\r\nbefore:\r\n\r\n```\r\ntest vec::tests::bench_clone_from_0000_0000                ... bench:        12 ns/iter (+/- 2)\r\ntest vec::tests::bench_clone_from_0000_0010                ... bench:       125 ns/iter (+/- 4) = 80 MB/s\r\ntest vec::tests::bench_clone_from_0000_0100                ... bench:       360 ns/iter (+/- 33) = 277 MB/s\r\ntest vec::tests::bench_clone_from_0000_1000                ... bench:      2601 ns/iter (+/- 175) = 384 MB/s\r\ntest vec::tests::bench_clone_from_0010_0000                ... bench:        12 ns/iter (+/- 2)\r\ntest vec::tests::bench_clone_from_0010_0010                ... bench:       125 ns/iter (+/- 10) = 80 MB/s\r\ntest vec::tests::bench_clone_from_0010_0100                ... bench:       361 ns/iter (+/- 28) = 277 MB/s\r\ntest vec::tests::bench_clone_from_0100_0010                ... bench:       131 ns/iter (+/- 13) = 76 MB/s\r\ntest vec::tests::bench_clone_from_0100_0100                ... bench:       360 ns/iter (+/- 9) = 277 MB/s\r\ntest vec::tests::bench_clone_from_0100_1000                ... bench:      2575 ns/iter (+/- 168) = 388 MB/s\r\ntest vec::tests::bench_clone_from_1000_0100                ... bench:       356 ns/iter (+/- 20) = 280 MB/s\r\ntest vec::tests::bench_clone_from_1000_1000                ... bench:      2605 ns/iter (+/- 167) = 383 MB/s\r\ntest vec::tests::bench_from_slice_0000                     ... bench:        11 ns/iter (+/- 0)\r\ntest vec::tests::bench_from_slice_0010                     ... bench:       115 ns/iter (+/- 5) = 86 MB/s\r\ntest vec::tests::bench_from_slice_0100                     ... bench:       309 ns/iter (+/- 170) = 323 MB/s\r\ntest vec::tests::bench_from_slice_1000                     ... bench:      2065 ns/iter (+/- 198) = 484 MB/s\r\ntest vec::tests::bench_push_all_0000_0000                  ... bench:         7 ns/iter (+/- 0)\r\ntest vec::tests::bench_push_all_0000_0010                  ... bench:        79 ns/iter (+/- 7) = 126 MB/s\r\ntest vec::tests::bench_push_all_0000_0100                  ... bench:       342 ns/iter (+/- 18) = 292 MB/s\r\ntest vec::tests::bench_push_all_0000_1000                  ... bench:      2873 ns/iter (+/- 75) = 348 MB/s\r\ntest vec::tests::bench_push_all_0010_0010                  ... bench:       154 ns/iter (+/- 8) = 64 MB/s\r\ntest vec::tests::bench_push_all_0100_0100                  ... bench:       518 ns/iter (+/- 18) = 193 MB/s\r\ntest vec::tests::bench_push_all_1000_1000                  ... bench:      4490 ns/iter (+/- 223) = 222 MB/s\r\n```\r\n\r\nafter:\r\n\r\n```\r\ntest vec::tests::bench_clone_from_0000_0000                ... bench:        12 ns/iter (+/- 1)\r\ntest vec::tests::bench_clone_from_0000_0010                ... bench:       123 ns/iter (+/- 5) = 81 MB/s\r\ntest vec::tests::bench_clone_from_0000_0100                ... bench:       367 ns/iter (+/- 23) = 272 MB/s\r\ntest vec::tests::bench_clone_from_0000_1000                ... bench:      2618 ns/iter (+/- 252) = 381 MB/s\r\ntest vec::tests::bench_clone_from_0010_0000                ... bench:        12 ns/iter (+/- 1)\r\ntest vec::tests::bench_clone_from_0010_0010                ... bench:       124 ns/iter (+/- 7) = 80 MB/s\r\ntest vec::tests::bench_clone_from_0010_0100                ... bench:       369 ns/iter (+/- 34) = 271 MB/s\r\ntest vec::tests::bench_clone_from_0100_0010                ... bench:       123 ns/iter (+/- 6) = 81 MB/s\r\ntest vec::tests::bench_clone_from_0100_0100                ... bench:       371 ns/iter (+/- 25) = 269 MB/s\r\ntest vec::tests::bench_clone_from_0100_1000                ... bench:      2713 ns/iter (+/- 532) = 368 MB/s\r\ntest vec::tests::bench_clone_from_1000_0100                ... bench:       369 ns/iter (+/- 14) = 271 MB/s\r\ntest vec::tests::bench_clone_from_1000_1000                ... bench:      2611 ns/iter (+/- 194) = 382 MB/s\r\ntest vec::tests::bench_from_slice_0000                     ... bench:         7 ns/iter (+/- 0)\r\ntest vec::tests::bench_from_slice_0010                     ... bench:       108 ns/iter (+/- 4) = 92 MB/s\r\ntest vec::tests::bench_from_slice_0100                     ... bench:       235 ns/iter (+/- 24) = 425 MB/s\r\ntest vec::tests::bench_from_slice_1000                     ... bench:      1318 ns/iter (+/- 96) = 758 MB/s\r\ntest vec::tests::bench_push_all_0000_0000                  ... bench:         7 ns/iter (+/- 0)\r\ntest vec::tests::bench_push_all_0000_0010                  ... bench:        70 ns/iter (+/- 4) = 142 MB/s\r\ntest vec::tests::bench_push_all_0000_0100                  ... bench:       176 ns/iter (+/- 16) = 568 MB/s\r\ntest vec::tests::bench_push_all_0000_1000                  ... bench:      1125 ns/iter (+/- 94) = 888 MB/s\r\ntest vec::tests::bench_push_all_0010_0010                  ... bench:       159 ns/iter (+/- 15) = 62 MB/s\r\ntest vec::tests::bench_push_all_0100_0100                  ... bench:       363 ns/iter (+/- 12) = 275 MB/s\r\ntest vec::tests::bench_push_all_1000_1000                  ... bench:      2860 ns/iter (+/- 415) = 349 MB/s\r\n```\r\n\r\nThis also includes extra benchmarks for `Vec` and `MemWriter`.", "tree": {"sha": "d129b844584a5675918f13d8a4ab7c886e5e2cf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d129b844584a5675918f13d8a4ab7c886e5e2cf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66e1f11ef482d90f2ea3bd284b07cd825315fadd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66e1f11ef482d90f2ea3bd284b07cd825315fadd", "html_url": "https://github.com/rust-lang/rust/commit/66e1f11ef482d90f2ea3bd284b07cd825315fadd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66e1f11ef482d90f2ea3bd284b07cd825315fadd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa7cbb5a46ddc15c6e5c8ad8f49a537a0cd10732", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa7cbb5a46ddc15c6e5c8ad8f49a537a0cd10732", "html_url": "https://github.com/rust-lang/rust/commit/fa7cbb5a46ddc15c6e5c8ad8f49a537a0cd10732"}, {"sha": "b4984a490b7fe181ec72b8fb0188bbd0ab4c15e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4984a490b7fe181ec72b8fb0188bbd0ab4c15e0", "html_url": "https://github.com/rust-lang/rust/commit/b4984a490b7fe181ec72b8fb0188bbd0ab4c15e0"}], "stats": {"total": 579, "additions": 497, "deletions": 82}, "files": [{"sha": "1e96588dac5f896a9217b791228cac9533f0a52d", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 448, "deletions": 77, "changes": 525, "blob_url": "https://github.com/rust-lang/rust/blob/66e1f11ef482d90f2ea3bd284b07cd825315fadd/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e1f11ef482d90f2ea3bd284b07cd825315fadd/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=66e1f11ef482d90f2ea3bd284b07cd825315fadd", "patch": "@@ -205,7 +205,9 @@ impl<T: Clone> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn from_slice(values: &[T]) -> Vec<T> {\n-        values.iter().map(|x| x.clone()).collect()\n+        let mut vector = Vec::new();\n+        vector.push_all(values);\n+        vector\n     }\n \n     /// Constructs a `Vec` with copies of a value.\n@@ -246,7 +248,21 @@ impl<T: Clone> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn push_all(&mut self, other: &[T]) {\n-        self.extend(other.iter().map(|e| e.clone()));\n+        self.reserve_additional(other.len());\n+\n+        for i in range(0, other.len()) {\n+            let len = self.len();\n+\n+            // Unsafe code so this can be optimised to a memcpy (or something similarly\n+            // fast) when T is Copy. LLVM is easily confused, so any extra operations\n+            // during the loop can prevent this optimisation.\n+            unsafe {\n+                ptr::write(\n+                    self.as_mut_slice().unsafe_mut_ref(len),\n+                    other.unsafe_ref(i).clone());\n+                self.set_len(len + 1);\n+            }\n+        }\n     }\n \n     /// Grows the `Vec` in-place.\n@@ -326,24 +342,7 @@ impl<T: Clone> Vec<T> {\n #[unstable]\n impl<T:Clone> Clone for Vec<T> {\n     fn clone(&self) -> Vec<T> {\n-        let len = self.len;\n-        let mut vector = Vec::with_capacity(len);\n-        // Unsafe code so this can be optimised to a memcpy (or something\n-        // similarly fast) when T is Copy. LLVM is easily confused, so any\n-        // extra operations during the loop can prevent this optimisation\n-        {\n-            let this_slice = self.as_slice();\n-            while vector.len < len {\n-                unsafe {\n-                    let len = vector.len;\n-                    ptr::write(\n-                        vector.as_mut_slice().unsafe_mut_ref(len),\n-                        this_slice.unsafe_ref(len).clone());\n-                }\n-                vector.len += 1;\n-            }\n-        }\n-        vector\n+        Vec::from_slice(self.as_slice())\n     }\n \n     fn clone_from(&mut self, other: &Vec<T>) {\n@@ -359,8 +358,8 @@ impl<T:Clone> Clone for Vec<T> {\n \n         // self.len <= other.len due to the truncate above, so the\n         // slice here is always in-bounds.\n-        let len = self.len();\n-        self.extend(other.slice_from(len).iter().map(|x| x.clone()));\n+        let slice = other.slice_from(self.len());\n+        self.push_all(slice);\n     }\n }\n \n@@ -1550,7 +1549,6 @@ pub mod raw {\n     }\n }\n \n-\n #[cfg(test)]\n mod tests {\n     extern crate test;\n@@ -1852,107 +1850,480 @@ mod tests {\n     #[bench]\n     fn bench_new(b: &mut Bencher) {\n         b.iter(|| {\n-            let v: Vec<int> = Vec::new();\n+            let v: Vec<uint> = Vec::new();\n+            assert_eq!(v.len(), 0);\n             assert_eq!(v.capacity(), 0);\n-            assert!(v.as_slice() == []);\n         })\n     }\n \n-    #[bench]\n-    fn bench_with_capacity_0(b: &mut Bencher) {\n+    fn do_bench_with_capacity(b: &mut Bencher, src_len: uint) {\n+        b.bytes = src_len as u64;\n+\n         b.iter(|| {\n-            let v: Vec<int> = Vec::with_capacity(0);\n-            assert_eq!(v.capacity(), 0);\n-            assert!(v.as_slice() == []);\n+            let v: Vec<uint> = Vec::with_capacity(src_len);\n+            assert_eq!(v.len(), 0);\n+            assert_eq!(v.capacity(), src_len);\n         })\n     }\n \n+    #[bench]\n+    fn bench_with_capacity_0000(b: &mut Bencher) {\n+        do_bench_with_capacity(b, 0)\n+    }\n \n     #[bench]\n-    fn bench_with_capacity_5(b: &mut Bencher) {\n-        b.iter(|| {\n-            let v: Vec<int> = Vec::with_capacity(5);\n-            assert_eq!(v.capacity(), 5);\n-            assert!(v.as_slice() == []);\n-        })\n+    fn bench_with_capacity_0010(b: &mut Bencher) {\n+        do_bench_with_capacity(b, 10)\n     }\n \n     #[bench]\n-    fn bench_with_capacity_100(b: &mut Bencher) {\n+    fn bench_with_capacity_0100(b: &mut Bencher) {\n+        do_bench_with_capacity(b, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_with_capacity_1000(b: &mut Bencher) {\n+        do_bench_with_capacity(b, 1000)\n+    }\n+\n+    fn do_bench_from_fn(b: &mut Bencher, src_len: uint) {\n+        b.bytes = src_len as u64;\n+\n         b.iter(|| {\n-            let v: Vec<int> = Vec::with_capacity(100);\n-            assert_eq!(v.capacity(), 100);\n-            assert!(v.as_slice() == []);\n+            let dst = Vec::from_fn(src_len, |i| i);\n+            assert_eq!(dst.len(), src_len);\n+            assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         })\n     }\n \n     #[bench]\n-    fn bench_from_fn_0(b: &mut Bencher) {\n+    fn bench_from_fn_0000(b: &mut Bencher) {\n+        do_bench_from_fn(b, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_from_fn_0010(b: &mut Bencher) {\n+        do_bench_from_fn(b, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_from_fn_0100(b: &mut Bencher) {\n+        do_bench_from_fn(b, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_from_fn_1000(b: &mut Bencher) {\n+        do_bench_from_fn(b, 1000)\n+    }\n+\n+    fn do_bench_from_elem(b: &mut Bencher, src_len: uint) {\n+        b.bytes = src_len as u64;\n+\n         b.iter(|| {\n-            let v: Vec<int> = Vec::from_fn(0, |_| 5);\n-            assert!(v.as_slice() == []);\n+            let dst: Vec<uint> = Vec::from_elem(src_len, 5);\n+            assert_eq!(dst.len(), src_len);\n+            assert!(dst.iter().all(|x| *x == 5));\n         })\n     }\n \n     #[bench]\n-    fn bench_from_fn_5(b: &mut Bencher) {\n+    fn bench_from_elem_0000(b: &mut Bencher) {\n+        do_bench_from_elem(b, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_from_elem_0010(b: &mut Bencher) {\n+        do_bench_from_elem(b, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_from_elem_0100(b: &mut Bencher) {\n+        do_bench_from_elem(b, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_from_elem_1000(b: &mut Bencher) {\n+        do_bench_from_elem(b, 1000)\n+    }\n+\n+    fn do_bench_from_slice(b: &mut Bencher, src_len: uint) {\n+        let src: Vec<uint> = FromIterator::from_iter(range(0, src_len));\n+\n+        b.bytes = src_len as u64;\n+\n         b.iter(|| {\n-            let v: Vec<int> = Vec::from_fn(5, |_| 5);\n-            assert!(v.as_slice() == [5, 5, 5, 5, 5]);\n-        })\n+            let dst = Vec::from_slice(src.clone().as_slice());\n+            assert_eq!(dst.len(), src_len);\n+            assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_from_slice_0000(b: &mut Bencher) {\n+        do_bench_from_slice(b, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_from_slice_0010(b: &mut Bencher) {\n+        do_bench_from_slice(b, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_from_slice_0100(b: &mut Bencher) {\n+        do_bench_from_slice(b, 100)\n     }\n \n     #[bench]\n-    fn bench_from_slice_0(b: &mut Bencher) {\n+    fn bench_from_slice_1000(b: &mut Bencher) {\n+        do_bench_from_slice(b, 1000)\n+    }\n+\n+    fn do_bench_from_iter(b: &mut Bencher, src_len: uint) {\n+        let src: Vec<uint> = FromIterator::from_iter(range(0, src_len));\n+\n+        b.bytes = src_len as u64;\n+\n         b.iter(|| {\n-            let v: Vec<int> = Vec::from_slice([]);\n-            assert!(v.as_slice() == []);\n-        })\n+            let dst: Vec<uint> = FromIterator::from_iter(src.clone().move_iter());\n+            assert_eq!(dst.len(), src_len);\n+            assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_from_iter_0000(b: &mut Bencher) {\n+        do_bench_from_iter(b, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_from_iter_0010(b: &mut Bencher) {\n+        do_bench_from_iter(b, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_from_iter_0100(b: &mut Bencher) {\n+        do_bench_from_iter(b, 100)\n     }\n \n     #[bench]\n-    fn bench_from_slice_5(b: &mut Bencher) {\n+    fn bench_from_iter_1000(b: &mut Bencher) {\n+        do_bench_from_iter(b, 1000)\n+    }\n+\n+    fn do_bench_extend(b: &mut Bencher, dst_len: uint, src_len: uint) {\n+        let dst: Vec<uint> = FromIterator::from_iter(range(0, dst_len));\n+        let src: Vec<uint> = FromIterator::from_iter(range(dst_len, dst_len + src_len));\n+\n+        b.bytes = src_len as u64;\n+\n         b.iter(|| {\n-            let v: Vec<int> = Vec::from_slice([1i, 2, 3, 4, 5]);\n-            assert!(v.as_slice() == [1, 2, 3, 4, 5]);\n-        })\n+            let mut dst = dst.clone();\n+            dst.extend(src.clone().move_iter());\n+            assert_eq!(dst.len(), dst_len + src_len);\n+            assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_extend_0000_0000(b: &mut Bencher) {\n+        do_bench_extend(b, 0, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_extend_0000_0010(b: &mut Bencher) {\n+        do_bench_extend(b, 0, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_extend_0000_0100(b: &mut Bencher) {\n+        do_bench_extend(b, 0, 100)\n     }\n \n     #[bench]\n-    fn bench_from_iter_0(b: &mut Bencher) {\n+    fn bench_extend_0000_1000(b: &mut Bencher) {\n+        do_bench_extend(b, 0, 1000)\n+    }\n+\n+    #[bench]\n+    fn bench_extend_0010_0010(b: &mut Bencher) {\n+        do_bench_extend(b, 10, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_extend_0100_0100(b: &mut Bencher) {\n+        do_bench_extend(b, 100, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_extend_1000_1000(b: &mut Bencher) {\n+        do_bench_extend(b, 1000, 1000)\n+    }\n+\n+    fn do_bench_push_all(b: &mut Bencher, dst_len: uint, src_len: uint) {\n+        let dst: Vec<uint> = FromIterator::from_iter(range(0, dst_len));\n+        let src: Vec<uint> = FromIterator::from_iter(range(dst_len, dst_len + src_len));\n+\n+        b.bytes = src_len as u64;\n+\n         b.iter(|| {\n-            let v0: Vec<int> = vec!();\n-            let v1: Vec<int> = FromIterator::from_iter(v0.move_iter());\n-            assert!(v1.as_slice() == []);\n-        })\n+            let mut dst = dst.clone();\n+            dst.push_all(src.as_slice());\n+            assert_eq!(dst.len(), dst_len + src_len);\n+            assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_push_all_0000_0000(b: &mut Bencher) {\n+        do_bench_push_all(b, 0, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_push_all_0000_0010(b: &mut Bencher) {\n+        do_bench_push_all(b, 0, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_push_all_0000_0100(b: &mut Bencher) {\n+        do_bench_push_all(b, 0, 100)\n     }\n \n     #[bench]\n-    fn bench_from_iter_5(b: &mut Bencher) {\n+    fn bench_push_all_0000_1000(b: &mut Bencher) {\n+        do_bench_push_all(b, 0, 1000)\n+    }\n+\n+    #[bench]\n+    fn bench_push_all_0010_0010(b: &mut Bencher) {\n+        do_bench_push_all(b, 10, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_push_all_0100_0100(b: &mut Bencher) {\n+        do_bench_push_all(b, 100, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_push_all_1000_1000(b: &mut Bencher) {\n+        do_bench_push_all(b, 1000, 1000)\n+    }\n+\n+    fn do_bench_push_all_move(b: &mut Bencher, dst_len: uint, src_len: uint) {\n+        let dst: Vec<uint> = FromIterator::from_iter(range(0u, dst_len));\n+        let src: Vec<uint> = FromIterator::from_iter(range(dst_len, dst_len + src_len));\n+\n+        b.bytes = src_len as u64;\n+\n         b.iter(|| {\n-            let v0: Vec<int> = vec!(1, 2, 3, 4, 5);\n-            let v1: Vec<int> = FromIterator::from_iter(v0.move_iter());\n-            assert!(v1.as_slice() == [1, 2, 3, 4, 5]);\n-        })\n+            let mut dst = dst.clone();\n+            dst.push_all_move(src.clone());\n+            assert_eq!(dst.len(), dst_len + src_len);\n+            assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_push_all_move_0000_0000(b: &mut Bencher) {\n+        do_bench_push_all_move(b, 0, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_push_all_move_0000_0010(b: &mut Bencher) {\n+        do_bench_push_all_move(b, 0, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_push_all_move_0000_0100(b: &mut Bencher) {\n+        do_bench_push_all_move(b, 0, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_push_all_move_0000_1000(b: &mut Bencher) {\n+        do_bench_push_all_move(b, 0, 1000)\n     }\n \n     #[bench]\n-    fn bench_extend_0(b: &mut Bencher) {\n+    fn bench_push_all_move_0010_0010(b: &mut Bencher) {\n+        do_bench_push_all_move(b, 10, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_push_all_move_0100_0100(b: &mut Bencher) {\n+        do_bench_push_all_move(b, 100, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_push_all_move_1000_1000(b: &mut Bencher) {\n+        do_bench_push_all_move(b, 1000, 1000)\n+    }\n+\n+    fn do_bench_clone(b: &mut Bencher, src_len: uint) {\n+        let src: Vec<uint> = FromIterator::from_iter(range(0, src_len));\n+\n+        b.bytes = src_len as u64;\n+\n         b.iter(|| {\n-            let v0: Vec<int> = vec!();\n-            let mut v1: Vec<int> = vec!(1, 2, 3, 4, 5);\n-            v1.extend(v0.move_iter());\n-            assert!(v1.as_slice() == [1, 2, 3, 4, 5]);\n-        })\n+            let dst = src.clone();\n+            assert_eq!(dst.len(), src_len);\n+            assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+        });\n     }\n \n     #[bench]\n-    fn bench_extend_5(b: &mut Bencher) {\n+    fn bench_clone_0000(b: &mut Bencher) {\n+        do_bench_clone(b, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_0010(b: &mut Bencher) {\n+        do_bench_clone(b, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_0100(b: &mut Bencher) {\n+        do_bench_clone(b, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_1000(b: &mut Bencher) {\n+        do_bench_clone(b, 1000)\n+    }\n+\n+    fn do_bench_clone_from(b: &mut Bencher, times: uint, dst_len: uint, src_len: uint) {\n+        let dst: Vec<uint> = FromIterator::from_iter(range(0, src_len));\n+        let src: Vec<uint> = FromIterator::from_iter(range(dst_len, dst_len + src_len));\n+\n+        b.bytes = (times * src_len) as u64;\n+\n         b.iter(|| {\n-            let v0: Vec<int> = vec!(1, 2, 3, 4, 5);\n-            let mut v1: Vec<int> = vec!(1, 2, 3, 4, 5);\n-            v1.extend(v0.move_iter());\n-            assert!(v1.as_slice() == [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]);\n-        })\n+            let mut dst = dst.clone();\n+\n+            for _ in range(0, times) {\n+                dst.clone_from(&src);\n+\n+                assert_eq!(dst.len(), src_len);\n+                assert!(dst.iter().enumerate().all(|(i, x)| dst_len + i == *x));\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_01_0000_0000(b: &mut Bencher) {\n+        do_bench_clone_from(b, 1, 0, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_01_0000_0010(b: &mut Bencher) {\n+        do_bench_clone_from(b, 1, 0, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_01_0000_0100(b: &mut Bencher) {\n+        do_bench_clone_from(b, 1, 0, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_01_0000_1000(b: &mut Bencher) {\n+        do_bench_clone_from(b, 1, 0, 1000)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_01_0010_0010(b: &mut Bencher) {\n+        do_bench_clone_from(b, 1, 10, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_01_0100_0100(b: &mut Bencher) {\n+        do_bench_clone_from(b, 1, 100, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_01_1000_1000(b: &mut Bencher) {\n+        do_bench_clone_from(b, 1, 1000, 1000)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_01_0010_0100(b: &mut Bencher) {\n+        do_bench_clone_from(b, 1, 10, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_01_0100_1000(b: &mut Bencher) {\n+        do_bench_clone_from(b, 1, 100, 1000)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_01_0010_0000(b: &mut Bencher) {\n+        do_bench_clone_from(b, 1, 10, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_01_0100_0010(b: &mut Bencher) {\n+        do_bench_clone_from(b, 1, 100, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_01_1000_0100(b: &mut Bencher) {\n+        do_bench_clone_from(b, 1, 1000, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_10_0000_0000(b: &mut Bencher) {\n+        do_bench_clone_from(b, 10, 0, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_10_0000_0010(b: &mut Bencher) {\n+        do_bench_clone_from(b, 10, 0, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_10_0000_0100(b: &mut Bencher) {\n+        do_bench_clone_from(b, 10, 0, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_10_0000_1000(b: &mut Bencher) {\n+        do_bench_clone_from(b, 10, 0, 1000)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_10_0010_0010(b: &mut Bencher) {\n+        do_bench_clone_from(b, 10, 10, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_10_0100_0100(b: &mut Bencher) {\n+        do_bench_clone_from(b, 10, 100, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_10_1000_1000(b: &mut Bencher) {\n+        do_bench_clone_from(b, 10, 1000, 1000)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_10_0010_0100(b: &mut Bencher) {\n+        do_bench_clone_from(b, 10, 10, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_10_0100_1000(b: &mut Bencher) {\n+        do_bench_clone_from(b, 10, 100, 1000)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_10_0010_0000(b: &mut Bencher) {\n+        do_bench_clone_from(b, 10, 10, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_10_0100_0010(b: &mut Bencher) {\n+        do_bench_clone_from(b, 10, 100, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_clone_from_10_1000_0100(b: &mut Bencher) {\n+        do_bench_clone_from(b, 10, 1000, 100)\n     }\n }"}, {"sha": "7f9a1180785d99486dce89a3b0e0b09aad36d6a1", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/66e1f11ef482d90f2ea3bd284b07cd825315fadd/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e1f11ef482d90f2ea3bd284b07cd825315fadd/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=66e1f11ef482d90f2ea3bd284b07cd825315fadd", "patch": "@@ -607,17 +607,61 @@ mod test {\n         assert_eq!(buf.as_slice(), &[7, 8, 6]);\n     }\n \n-    #[bench]\n-    fn bench_mem_writer(b: &mut Bencher) {\n+    fn do_bench_mem_writer(b: &mut Bencher, times: uint, len: uint) {\n+        let src: Vec<u8> = Vec::from_elem(len, 5);\n+\n         b.iter(|| {\n             let mut wr = MemWriter::new();\n-            for _i in range(0u, 10) {\n-                wr.write([5, .. 10]).unwrap();\n+            for _ in range(0, times) {\n+                wr.write(src.as_slice()).unwrap();\n             }\n-            assert_eq!(wr.unwrap().as_slice(), [5, .. 100].as_slice());\n+\n+            let v = wr.unwrap();\n+            assert_eq!(v.len(), times * len);\n+            assert!(v.iter().all(|x| *x == 5));\n         });\n     }\n \n+    #[bench]\n+    fn bench_mem_writer_001_0000(b: &mut Bencher) {\n+        do_bench_mem_writer(b, 1, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_mem_writer_001_0010(b: &mut Bencher) {\n+        do_bench_mem_writer(b, 1, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_mem_writer_001_0100(b: &mut Bencher) {\n+        do_bench_mem_writer(b, 1, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_mem_writer_001_1000(b: &mut Bencher) {\n+        do_bench_mem_writer(b, 1, 1000)\n+    }\n+\n+    #[bench]\n+    fn bench_mem_writer_100_0000(b: &mut Bencher) {\n+        do_bench_mem_writer(b, 100, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_mem_writer_100_0010(b: &mut Bencher) {\n+        do_bench_mem_writer(b, 100, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_mem_writer_100_0100(b: &mut Bencher) {\n+        do_bench_mem_writer(b, 100, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_mem_writer_100_1000(b: &mut Bencher) {\n+        do_bench_mem_writer(b, 100, 1000)\n+    }\n+\n     #[bench]\n     fn bench_mem_reader(b: &mut Bencher) {\n         b.iter(|| {"}]}