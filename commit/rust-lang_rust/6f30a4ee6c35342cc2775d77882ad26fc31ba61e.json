{"sha": "6f30a4ee6c35342cc2775d77882ad26fc31ba61e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmMzBhNGVlNmMzNTM0MmNjMjc3NWQ3Nzg4MmFkMjZmYzMxYmE2MWU=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-10-06T23:18:24Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-11-05T22:06:01Z"}, "message": "Remove `Matcher`s", "tree": {"sha": "91b1dd2f9aa3ecc25cbe88193b2db99adb524d02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91b1dd2f9aa3ecc25cbe88193b2db99adb524d02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f30a4ee6c35342cc2775d77882ad26fc31ba61e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f30a4ee6c35342cc2775d77882ad26fc31ba61e", "html_url": "https://github.com/rust-lang/rust/commit/6f30a4ee6c35342cc2775d77882ad26fc31ba61e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "html_url": "https://github.com/rust-lang/rust/commit/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3"}], "stats": {"total": 189, "additions": 33, "deletions": 156}, "files": [{"sha": "639b007e7ab24a020f1249c95cf118d91116ad12", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 12, "deletions": 72, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6f30a4ee6c35342cc2775d77882ad26fc31ba61e", "patch": "@@ -641,14 +641,12 @@ pub enum KleeneOp {\n /// be passed to syntax extensions using a uniform type.\n ///\n /// If the syntax extension is an MBE macro, it will attempt to match its\n-/// LHS \"matchers\" against the provided token tree, and if it finds a\n+/// LHS token tree against the provided token tree, and if it finds a\n /// match, will transcribe the RHS token tree, splicing in any captured\n-/// `macro_parser::matched_nonterminals` into the `TtNonterminal`s it finds.\n+/// macro_parser::matched_nonterminals into the `SubstNt`s it finds.\n ///\n-/// The RHS of an MBE macro is the only place a `TtNonterminal` or `TtSequence`\n-/// makes any real sense. You could write them elsewhere but nothing\n-/// else knows what to do with them, so you'll probably get a syntax\n-/// error.\n+/// The RHS of an MBE macro is the only place `SubstNt`s are substituted.\n+/// Nothing special happens to misnamed or misplaced `SubstNt`s.\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum TokenTree {\n@@ -657,14 +655,19 @@ pub enum TokenTree {\n     /// A delimited sequence of token trees\n     TtDelimited(Span, Rc<Delimited>),\n \n-    // This only makes sense for right-hand-sides of MBE macros:\n+    // This only makes sense in MBE macros.\n \n-    /// A Kleene-style repetition sequence with an optional separator.\n-    // FIXME(eddyb) #6308 Use Rc<[TokenTree]> after DST.\n+    /// A kleene-style repetition sequence with a span, a TT forest,\n+    /// an optional separator, and a boolean where true indicates\n+    /// zero or more (..), and false indicates one or more (+).\n+    /// The last member denotes the number of `MATCH_NONTERMINAL`s\n+    /// in the forest.\n+    // FIXME(eddyb) #12938 Use Rc<[TokenTree]> after DST.\n     TtSequence(Span, Rc<Vec<TokenTree>>, Option<::parse::token::Token>, KleeneOp, uint),\n }\n \n impl TokenTree {\n+    /// For unrolling some tokens or token trees into equivalent sequences.\n     pub fn expand_into_tts(self) -> Rc<Vec<TokenTree>> {\n         match self {\n             TtToken(sp, token::DocComment(name)) => {\n@@ -710,69 +713,6 @@ impl TokenTree {\n     }\n }\n \n-// Matchers are nodes defined-by and recognized-by the main rust parser and\n-// language, but they're only ever found inside syntax-extension invocations;\n-// indeed, the only thing that ever _activates_ the rules in the rust parser\n-// for parsing a matcher is a matcher looking for the 'matchers' nonterminal\n-// itself. Matchers represent a small sub-language for pattern-matching\n-// token-trees, and are thus primarily used by the macro-defining extension\n-// itself.\n-//\n-// MatchTok\n-// --------\n-//\n-//     A matcher that matches a single token, denoted by the token itself. So\n-//     long as there's no $ involved.\n-//\n-//\n-// MatchSeq\n-// --------\n-//\n-//     A matcher that matches a sequence of sub-matchers, denoted various\n-//     possible ways:\n-//\n-//             $(M)*       zero or more Ms\n-//             $(M)+       one or more Ms\n-//             $(M),+      one or more comma-separated Ms\n-//             $(A B C);*  zero or more semi-separated 'A B C' seqs\n-//\n-//\n-// MatchNonterminal\n-// -----------------\n-//\n-//     A matcher that matches one of a few interesting named rust\n-//     nonterminals, such as types, expressions, items, or raw token-trees. A\n-//     black-box matcher on expr, for example, binds an expr to a given ident,\n-//     and that ident can re-occur as an interpolation in the RHS of a\n-//     macro-by-example rule. For example:\n-//\n-//        $foo:expr   =>     1 + $foo    // interpolate an expr\n-//        $foo:tt     =>     $foo        // interpolate a token-tree\n-//        $foo:tt     =>     bar! $foo   // only other valid interpolation\n-//                                       // is in arg position for another\n-//                                       // macro\n-//\n-// As a final, horrifying aside, note that macro-by-example's input is\n-// also matched by one of these matchers. Holy self-referential! It is matched\n-// by a MatchSeq, specifically this one:\n-//\n-//                   $( $lhs:matchers => $rhs:tt );+\n-//\n-// If you understand that, you have closed the loop and understand the whole\n-// macro system. Congratulations.\n-pub type Matcher = Spanned<Matcher_>;\n-\n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub enum Matcher_ {\n-    /// Match one token\n-    MatchTok(token::Token),\n-    /// Match repetitions of a sequence: body, separator, Kleene operator,\n-    /// lo, hi position-in-match-array used:\n-    MatchSeq(Vec<Matcher>, Option<token::Token>, KleeneOp, uint, uint),\n-    /// Parse a Rust NT: name to bind, name of NT, position in match array:\n-    MatchNonterminal(Ident, Ident, uint)\n-}\n-\n pub type Mac = Spanned<Mac_>;\n \n /// Represents a macro invocation. The Path indicates which macro"}, {"sha": "833211f53e7aa9e1c1b8af488bbbac7333d29708", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=6f30a4ee6c35342cc2775d77882ad26fc31ba61e", "patch": "@@ -78,7 +78,7 @@\n \n \n use ast;\n-use ast::{Matcher, TokenTree, Ident};\n+use ast::{TokenTree, Ident};\n use ast::{TtDelimited, TtSequence, TtToken};\n use codemap::{BytePos, mk_sp};\n use codemap;\n@@ -97,9 +97,8 @@ use std::rc::Rc;\n use std::collections::HashMap;\n use std::collections::hash_map::{Vacant, Occupied};\n \n-/* to avoid costly uniqueness checks, we require that `MatchSeq` always has a\n-nonempty body. */\n-\n+// To avoid costly uniqueness checks, we require that `MatchSeq` always has\n+// a nonempty body.\n \n /// an unzipping of `TokenTree`s\n #[deriving(Clone)]\n@@ -157,22 +156,22 @@ pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: ByteP\n     }\n }\n \n-/// NamedMatch is a pattern-match result for a single ast::MatchNonterminal:\n+/// NamedMatch is a pattern-match result for a single token::MATCH_NONTERMINAL:\n /// so it is associated with a single ident in a parse, and all\n-/// MatchedNonterminal's in the NamedMatch have the same nonterminal type\n-/// (expr, item, etc). All the leaves in a single NamedMatch correspond to a\n-/// single matcher_nonterminal in the ast::Matcher that produced it.\n+/// `MatchedNonterminal`s in the NamedMatch have the same nonterminal type\n+/// (expr, item, etc). Each leaf in a single NamedMatch corresponds to a\n+/// single token::MATCH_NONTERMINAL in the TokenTree that produced it.\n ///\n /// The in-memory structure of a particular NamedMatch represents the match\n /// that occurred when a particular subset of a matcher was applied to a\n /// particular token tree.\n ///\n /// The width of each MatchedSeq in the NamedMatch, and the identity of the\n-/// MatchedNonterminal's, will depend on the token tree it was applied to: each\n-/// MatchedSeq corresponds to a single MatchSeq in the originating\n-/// ast::Matcher. The depth of the NamedMatch structure will therefore depend\n-/// only on the nesting depth of ast::MatchSeq's in the originating\n-/// ast::Matcher it was derived from.\n+/// `MatchedNonterminal`s, will depend on the token tree it was applied to:\n+/// each MatchedSeq corresponds to a single TTSeq in the originating\n+/// token tree. The depth of the NamedMatch structure will therefore depend\n+/// only on the nesting depth of `ast::TTSeq`s in the originating\n+/// token tree it was derived from.\n \n pub enum NamedMatch {\n     MatchedSeq(Vec<Rc<NamedMatch>>, codemap::Span),\n@@ -512,7 +511,6 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n         p.quote_depth -= 1u;\n         res\n       }\n-      \"matchers\" => token::NtMatchers(p.parse_matchers()),\n       _ => {\n           p.fatal(format!(\"unsupported builtin nonterminal parser: {}\",\n                           name).as_slice())"}, {"sha": "381e4310d89ecb8ccb1348bd944fd7cf470aaf16", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=6f30a4ee6c35342cc2775d77882ad26fc31ba61e", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Ident, Matcher_, Matcher, MatchTok, MatchNonterminal, MatchSeq, TtDelimited};\n-use ast::{TtSequence, TtToken};\n+use ast::{Ident, TtDelimited, TtSequence, TtToken};\n use ast;\n use codemap::{Span, DUMMY_SP};\n use ext::base::{ExtCtxt, MacResult, MacroDef};\n@@ -21,7 +20,7 @@ use parse::lexer::new_tt_reader;\n use parse::parser::Parser;\n use parse::attr::ParserAttr;\n use parse::token::{special_idents, gensym_ident};\n-use parse::token::{MatchNt, NtMatchers, NtTT};\n+use parse::token::{MatchNt, NtTT};\n use parse::token;\n use print;\n use ptr::P;\n@@ -207,6 +206,11 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n     cx.span_fatal(best_fail_spot, best_fail_msg.as_slice());\n }\n \n+// Note that macro-by-example's input is also matched against a token tree:\n+//                   $( $lhs:tt => $rhs:tt );+\n+//\n+// Holy self-referential!\n+\n /// This procedure performs the expansion of the\n /// macro_rules! macro. It parses the RHS and adds\n /// an extension to the current context."}, {"sha": "746e1d112c7e9488c13d899b44c6f8c07df31ada", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=6f30a4ee6c35342cc2775d77882ad26fc31ba61e", "patch": "@@ -656,8 +656,6 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtMeta(meta_item) => token::NtMeta(fld.fold_meta_item(meta_item)),\n         token::NtPath(box path) => token::NtPath(box fld.fold_path(path)),\n         token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&*tt))),\n-        // it looks to me like we can leave out the matchers: token::NtMatchers(matchers)\n-        _ => nt\n     }\n }\n "}, {"sha": "5a0c7d92fa2cb885ac9292b141afd6ca98b4e87d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 62, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6f30a4ee6c35342cc2775d77882ad26fc31ba61e", "patch": "@@ -37,8 +37,8 @@ use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy};\n use ast::{LifetimeDef, Lit, Lit_};\n use ast::{LitBool, LitChar, LitByte, LitBinary};\n use ast::{LitNil, LitStr, LitInt, Local, LocalLet};\n-use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, Matcher, MatchNonterminal, MatchNormal};\n-use ast::{MatchSeq, MatchTok, Method, MutTy, BiMul, Mutability};\n+use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, MatchNormal};\n+use ast::{Method, MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n@@ -2628,66 +2628,6 @@ impl<'a> Parser<'a> {\n         tts\n     }\n \n-    pub fn parse_matchers(&mut self) -> Vec<Matcher> {\n-        // unification of Matcher's and TokenTree's would vastly improve\n-        // the interpolation of Matcher's\n-        maybe_whole!(self, NtMatchers);\n-        let mut name_idx = 0u;\n-        let delim = self.expect_open_delim();\n-        self.parse_matcher_subseq_upto(&mut name_idx, &token::CloseDelim(delim))\n-    }\n-\n-    /// This goofy function is necessary to correctly match parens in Matcher's.\n-    /// Otherwise, `$( ( )` would be a valid Matcher, and `$( () )` would be\n-    /// invalid. It's similar to common::parse_seq.\n-    pub fn parse_matcher_subseq_upto(&mut self,\n-                                     name_idx: &mut uint,\n-                                     ket: &token::Token)\n-                                     -> Vec<Matcher> {\n-        let mut ret_val = Vec::new();\n-        let mut lparens = 0u;\n-\n-        while self.token != *ket || lparens > 0u {\n-            if self.token == token::OpenDelim(token::Paren) { lparens += 1u; }\n-            if self.token == token::CloseDelim(token::Paren) { lparens -= 1u; }\n-            ret_val.push(self.parse_matcher(name_idx));\n-        }\n-\n-        self.bump();\n-\n-        return ret_val;\n-    }\n-\n-    pub fn parse_matcher(&mut self, name_idx: &mut uint) -> Matcher {\n-        let lo = self.span.lo;\n-\n-        let m = if self.token == token::Dollar {\n-            self.bump();\n-            if self.token == token::OpenDelim(token::Paren) {\n-                let name_idx_lo = *name_idx;\n-                self.bump();\n-                let ms = self.parse_matcher_subseq_upto(name_idx,\n-                                                        &token::CloseDelim(token::Paren));\n-                if ms.len() == 0u {\n-                    self.fatal(\"repetition body must be nonempty\");\n-                }\n-                let (sep, kleene_op) = self.parse_sep_and_kleene_op();\n-                MatchSeq(ms, sep, kleene_op, name_idx_lo, *name_idx)\n-            } else {\n-                let bound_to = self.parse_ident();\n-                self.expect(&token::Colon);\n-                let nt_name = self.parse_ident();\n-                let m = MatchNonterminal(bound_to, nt_name, *name_idx);\n-                *name_idx += 1;\n-                m\n-            }\n-        } else {\n-            MatchTok(self.bump_and_get())\n-        };\n-\n-        return spanned(lo, self.span.hi, m);\n-    }\n-\n     /// Parse a prefix-operator expr\n     pub fn parse_prefix_expr(&mut self) -> P<Expr> {\n         let lo = self.span.lo;"}, {"sha": "b0cca5e14de15448bcf603e4be57c97bbafd8b40", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=6f30a4ee6c35342cc2775d77882ad26fc31ba61e", "patch": "@@ -337,7 +337,6 @@ pub enum Nonterminal {\n     NtMeta(P<ast::MetaItem>),\n     NtPath(Box<ast::Path>),\n     NtTT(P<ast::TokenTree>), // needs P'ed to break a circularity\n-    NtMatchers(Vec<ast::Matcher>)\n }\n \n impl fmt::Show for Nonterminal {\n@@ -353,7 +352,6 @@ impl fmt::Show for Nonterminal {\n             NtMeta(..) => f.pad(\"NtMeta(..)\"),\n             NtPath(..) => f.pad(\"NtPath(..)\"),\n             NtTT(..) => f.pad(\"NtTT(..)\"),\n-            NtMatchers(..) => f.pad(\"NtMatchers(..)\"),\n         }\n     }\n }"}, {"sha": "8ffc2aa3583805d5457a67f64b67d87f97f005a1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f30a4ee6c35342cc2775d77882ad26fc31ba61e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=6f30a4ee6c35342cc2775d77882ad26fc31ba61e", "patch": "@@ -272,7 +272,6 @@ pub fn token_to_string(tok: &Token) -> String {\n             token::NtPat(..)      => \"an interpolated pattern\".into_string(),\n             token::NtIdent(..)    => \"an interpolated identifier\".into_string(),\n             token::NtTT(..)       => \"an interpolated tt\".into_string(),\n-            token::NtMatchers(..) => \"an interpolated matcher sequence\".into_string(),\n         }\n     }\n }"}]}