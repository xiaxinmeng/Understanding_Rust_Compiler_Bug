{"sha": "54b6b034104ce81a8d02800b9fc7d5181389b4df", "node_id": "C_kwDOAAsO6NoAKDU0YjZiMDM0MTA0Y2U4MWE4ZDAyODAwYjlmYzdkNTE4MTM4OWI0ZGY", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-07-06T09:44:03Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-07-08T15:55:37Z"}, "message": "Actually use eyre and get rid of the ad-hoc macros emulating error handling", "tree": {"sha": "4a0e717554a7e2f28cc1836b1d0366c114eb05a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a0e717554a7e2f28cc1836b1d0366c114eb05a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54b6b034104ce81a8d02800b9fc7d5181389b4df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54b6b034104ce81a8d02800b9fc7d5181389b4df", "html_url": "https://github.com/rust-lang/rust/commit/54b6b034104ce81a8d02800b9fc7d5181389b4df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54b6b034104ce81a8d02800b9fc7d5181389b4df/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "570032b0dd8042243721b78f50d186577a52a3a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/570032b0dd8042243721b78f50d186577a52a3a9", "html_url": "https://github.com/rust-lang/rust/commit/570032b0dd8042243721b78f50d186577a52a3a9"}], "stats": {"total": 194, "additions": 88, "deletions": 106}, "files": [{"sha": "008fc7806457fd45d36bfc38b1d0b08bd27572a9", "filename": "tests/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54b6b034104ce81a8d02800b9fc7d5181389b4df/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b6b034104ce81a8d02800b9fc7d5181389b4df/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=54b6b034104ce81a8d02800b9fc7d5181389b4df", "patch": "@@ -2,7 +2,7 @@ use colored::*;\n use regex::Regex;\n use std::env;\n use std::path::PathBuf;\n-use ui_test::{Config, Mode, OutputConflictHandling, color_eyre::Result};\n+use ui_test::{color_eyre::Result, Config, Mode, OutputConflictHandling};\n \n fn miri_path() -> PathBuf {\n     PathBuf::from(option_env!(\"MIRI\").unwrap_or(env!(\"CARGO_BIN_EXE_miri\")))"}, {"sha": "481565cfea0a6da08e5e4c397b24d6f7a0bfba61", "filename": "ui_test/src/comments.rs", "status": "modified", "additions": 71, "deletions": 95, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/54b6b034104ce81a8d02800b9fc7d5181389b4df/ui_test%2Fsrc%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b6b034104ce81a8d02800b9fc7d5181389b4df/ui_test%2Fsrc%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Fcomments.rs?ref=54b6b034104ce81a8d02800b9fc7d5181389b4df", "patch": "@@ -4,7 +4,7 @@ use regex::Regex;\n \n use crate::rustc_stderr::Level;\n \n-use color_eyre::eyre::Result;\n+use color_eyre::eyre::{bail, ensure, eyre, Result};\n \n #[cfg(test)]\n mod tests;\n@@ -66,43 +66,6 @@ impl Condition {\n     }\n }\n \n-macro_rules! checked {\n-    ($path:expr, $l:expr) => {\n-        let path = $path;\n-        let l = $l;\n-        #[allow(unused_macros)]\n-        macro_rules! exit {\n-            ($fmt:expr $$(,$args:expr)*) => {{\n-                eprint!(\"{}:{l}: \", path.display());\n-                eprintln!($fmt, $$($args,)*);\n-                #[cfg(not(test))]\n-                std::process::exit(1);\n-                #[cfg(test)]\n-                panic!();\n-            }};\n-        }\n-        #[allow(unused_macros)]\n-        macro_rules! check {\n-            ($cond:expr, $fmt:expr $$(,$args:expr)*) => {{\n-                if !$cond {\n-                    exit!($fmt $$(,$args)*);\n-                }\n-            }};\n-        }\n-        #[allow(unused_macros)]\n-        macro_rules! unwrap {\n-            ($cond:expr, $fmt:expr $$(,$args:expr)*) => {{\n-                match $cond {\n-                    Some(val) => val,\n-                    None => {\n-                        exit!($fmt $$(,$args)*);\n-                    }\n-                }\n-            }};\n-        }\n-    };\n-}\n-\n impl Comments {\n     pub(crate) fn parse_file(path: &Path) -> Result<Self> {\n         let content = std::fs::read_to_string(path)?;\n@@ -121,24 +84,36 @@ impl Comments {\n         let mut fallthrough_to = None;\n         for (l, line) in content.lines().enumerate() {\n             let l = l + 1; // enumerate starts at 0, but line numbers start at 1\n-            if let Some((_, command)) = line.split_once(\"//@\") {\n-                let command = command.trim();\n-                if let Some((command, args)) = command.split_once(':') {\n-                    this.parse_command_with_args(command, args, path, l);\n-                } else if let Some((command, _comments)) = command.split_once(' ') {\n-                    this.parse_command(command, path, l)\n-                } else {\n-                    this.parse_command(command, path, l)\n-                }\n-            } else if let Some((_, pattern)) = line.split_once(\"//~\") {\n-                this.parse_pattern(pattern, &mut fallthrough_to, path, l)\n-            } else if let Some((_, pattern)) = line.split_once(\"//[\") {\n-                this.parse_revisioned_pattern(pattern, &mut fallthrough_to, path, l)\n+            this.parse_checked_line(l, &mut fallthrough_to, line).map_err(|err| {\n+                err.wrap_err(format!(\"{}:{l}: failed to parse annotation\", path.display()))\n+            })?;\n+        }\n+        Ok(this)\n+    }\n+\n+    fn parse_checked_line(\n+        &mut self,\n+        l: usize,\n+        fallthrough_to: &mut Option<usize>,\n+        line: &str,\n+    ) -> Result<()> {\n+        if let Some((_, command)) = line.split_once(\"//@\") {\n+            let command = command.trim();\n+            if let Some((command, args)) = command.split_once(':') {\n+                self.parse_command_with_args(command, args, l)\n+            } else if let Some((command, _comments)) = command.split_once(' ') {\n+                self.parse_command(command)\n             } else {\n-                fallthrough_to = None;\n+                self.parse_command(command)\n             }\n+        } else if let Some((_, pattern)) = line.split_once(\"//~\") {\n+            self.parse_pattern(pattern, fallthrough_to, l)\n+        } else if let Some((_, pattern)) = line.split_once(\"//[\") {\n+            self.parse_revisioned_pattern(pattern, fallthrough_to, l)\n+        } else {\n+            *fallthrough_to = None;\n+            Ok(())\n         }\n-        Ok(this)\n     }\n \n     /// Parse comments in `content`.\n@@ -214,91 +189,86 @@ impl Comments {\n         Ok(this)\n     }\n \n-    fn parse_command_with_args(&mut self, command: &str, args: &str, path: &Path, l: usize) {\n-        checked!(path, l);\n+    fn parse_command_with_args(&mut self, command: &str, args: &str, l: usize) -> Result<()> {\n         match command {\n             \"revisions\" => {\n-                check!(self.revisions.is_none(), \"cannot specifiy revisions twice\");\n+                ensure!(self.revisions.is_none(), \"cannot specifiy revisions twice\");\n                 self.revisions = Some(args.split_whitespace().map(|s| s.to_string()).collect());\n             }\n             \"compile-flags\" => {\n                 self.compile_flags.extend(args.split_whitespace().map(|s| s.to_string()));\n             }\n             \"rustc-env\" =>\n                 for env in args.split_whitespace() {\n-                    let (k, v) = unwrap!(\n-                        env.split_once('='),\n-                        \"environment variables must be key/value pairs separated by a `=`\"\n-                    );\n+                    let (k, v) = env.split_once('=').ok_or_else(|| {\n+                        eyre!(\"environment variables must be key/value pairs separated by a `=`\")\n+                    })?;\n                     self.env_vars.push((k.to_string(), v.to_string()));\n                 },\n             \"normalize-stderr-test\" => {\n-                let (from, to) =\n-                    unwrap!(args.split_once(\"->\"), \"normalize-stderr-test needs a `->`\");\n+                let (from, to) = args\n+                    .split_once(\"->\")\n+                    .ok_or_else(|| eyre!(\"normalize-stderr-test needs a `->`\"))?;\n                 let from = from.trim().trim_matches('\"');\n                 let to = to.trim().trim_matches('\"');\n-                let from = unwrap!(Regex::new(from).ok(), \"invalid regex\");\n+                let from = Regex::new(from).ok().ok_or_else(|| eyre!(\"invalid regex\"))?;\n                 self.normalize_stderr.push((from, to.to_string()));\n             }\n             \"error-pattern\" => {\n-                check!(\n+                ensure!(\n                     self.error_pattern.is_none(),\n                     \"cannot specifiy error_pattern twice, previous: {:?}\",\n                     self.error_pattern\n                 );\n                 self.error_pattern = Some((args.trim().to_string(), l));\n             }\n             // Maybe the user just left a comment explaining a command without arguments\n-            _ => self.parse_command(command, path, l),\n+            _ => self.parse_command(command)?,\n         }\n+        Ok(())\n     }\n \n-    fn parse_command(&mut self, command: &str, path: &Path, l: usize) {\n-        checked!(path, l);\n-\n+    fn parse_command(&mut self, command: &str) -> Result<()> {\n         if let Some(s) = command.strip_prefix(\"ignore-\") {\n             self.ignore.push(Condition::parse(s));\n-            return;\n+            return Ok(());\n         }\n \n         if let Some(s) = command.strip_prefix(\"only-\") {\n             self.only.push(Condition::parse(s));\n-            return;\n+            return Ok(());\n         }\n \n         if command.starts_with(\"stderr-per-bitwidth\") {\n-            check!(!self.stderr_per_bitwidth, \"cannot specifiy stderr-per-bitwidth twice\");\n+            ensure!(!self.stderr_per_bitwidth, \"cannot specifiy stderr-per-bitwidth twice\");\n             self.stderr_per_bitwidth = true;\n-            return;\n+            return Ok(());\n         }\n \n-        exit!(\"unknown command {command}\");\n+        bail!(\"unknown command {command}\");\n     }\n \n     fn parse_pattern(\n         &mut self,\n         pattern: &str,\n         fallthrough_to: &mut Option<usize>,\n-        path: &Path,\n         l: usize,\n-    ) {\n-        self.parse_pattern_inner(pattern, fallthrough_to, None, path, l)\n+    ) -> Result<()> {\n+        self.parse_pattern_inner(pattern, fallthrough_to, None, l)\n     }\n \n     fn parse_revisioned_pattern(\n         &mut self,\n         pattern: &str,\n         fallthrough_to: &mut Option<usize>,\n-        path: &Path,\n         l: usize,\n-    ) {\n-        checked!(path, l);\n+    ) -> Result<()> {\n         let (revision, pattern) =\n-            unwrap!(pattern.split_once(']'), \"`//[` without corresponding `]`\");\n+            pattern.split_once(']').ok_or_else(|| eyre!(\"`//[` without corresponding `]`\"))?;\n         if let Some(pattern) = pattern.strip_prefix('~') {\n-            self.parse_pattern_inner(pattern, fallthrough_to, Some(revision.to_owned()), path, l)\n+            self.parse_pattern_inner(pattern, fallthrough_to, Some(revision.to_owned()), l)\n         } else {\n-            exit!(\"revisioned pattern must have `~` following the `]`\");\n+            bail!(\"revisioned pattern must have `~` following the `]`\");\n         }\n     }\n \n@@ -308,21 +278,25 @@ impl Comments {\n         pattern: &str,\n         fallthrough_to: &mut Option<usize>,\n         revision: Option<String>,\n-        path: &Path,\n         l: usize,\n-    ) {\n-        checked!(path, l);\n+    ) -> Result<()> {\n         // FIXME: check that the error happens on the marked line\n \n-        let (match_line, pattern) = match unwrap!(pattern.chars().next(), \"no pattern specified\") {\n-            '|' =>\n-                (*unwrap!(fallthrough_to, \"`//~|` pattern without preceding line\"), &pattern[1..]),\n-            '^' => {\n-                let offset = pattern.chars().take_while(|&c| c == '^').count();\n-                (l - offset, &pattern[offset..])\n-            }\n-            _ => (l, pattern),\n-        };\n+        let (match_line, pattern) =\n+            match pattern.chars().next().ok_or_else(|| eyre!(\"no pattern specified\"))? {\n+                '|' =>\n+                    (\n+                        *fallthrough_to\n+                            .as_mut()\n+                            .ok_or_else(|| eyre!(\"`//~|` pattern without preceding line\"))?,\n+                        &pattern[1..],\n+                    ),\n+                '^' => {\n+                    let offset = pattern.chars().take_while(|&c| c == '^').count();\n+                    (l - offset, &pattern[offset..])\n+                }\n+                _ => (l, pattern),\n+            };\n \n         let (level, pattern) = match pattern.trim_start().split_once(|c| matches!(c, ':' | ' ')) {\n             None => (None, pattern),\n@@ -335,7 +309,7 @@ impl Comments {\n \n         let matched = pattern.trim().to_string();\n \n-        check!(!matched.is_empty(), \"no pattern specified\");\n+        ensure!(!matched.is_empty(), \"no pattern specified\");\n \n         *fallthrough_to = Some(match_line);\n \n@@ -346,5 +320,7 @@ impl Comments {\n             definition_line: l,\n             line: match_line,\n         });\n+\n+        Ok(())\n     }\n }"}, {"sha": "cdd81aa990538d7f3c0b46c07b1e0f2dc6002f98", "filename": "ui_test/src/comments/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54b6b034104ce81a8d02800b9fc7d5181389b4df/ui_test%2Fsrc%2Fcomments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b6b034104ce81a8d02800b9fc7d5181389b4df/ui_test%2Fsrc%2Fcomments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Fcomments%2Ftests.rs?ref=54b6b034104ce81a8d02800b9fc7d5181389b4df", "patch": "@@ -1,9 +1,9 @@\n-use std::{path::Path, panic::catch_unwind};\n+use std::path::Path;\n \n use super::Comments;\n \n-use color_eyre::eyre::{Result, bail};\n use crate::tests::init;\n+use color_eyre::eyre::{bail, Result};\n \n #[test]\n fn parse_simple_comment() -> Result<()> {\n@@ -48,8 +48,8 @@ fn parse_slash_slash_at_fail() -> Result<()> {\n use std::mem;\n \n     \";\n-    match catch_unwind(|| Comments::parse(Path::new(\"<dummy>\"), s)) {\n-        Ok(_) => bail!(\"expected parsing to panic\"),\n+    match Comments::parse(Path::new(\"<dummy>\"), s) {\n+        Ok(_) => bail!(\"expected parsing to fail\"),\n         Err(_) => Ok(()),\n     }\n }"}, {"sha": "da562fcac7d29e1fffa27e200779ad85a326f31b", "filename": "ui_test/src/lib.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/54b6b034104ce81a8d02800b9fc7d5181389b4df/ui_test%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b6b034104ce81a8d02800b9fc7d5181389b4df/ui_test%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Flib.rs?ref=54b6b034104ce81a8d02800b9fc7d5181389b4df", "patch": "@@ -7,12 +7,12 @@ use std::process::{Command, ExitStatus};\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::sync::Mutex;\n \n+pub use color_eyre;\n+use color_eyre::eyre::Result;\n use colored::*;\n use comments::ErrorMatch;\n use regex::Regex;\n use rustc_stderr::{Level, Message};\n-use color_eyre::eyre::Result;\n-pub use color_eyre;\n \n use crate::comments::{Comments, Condition};\n \n@@ -68,7 +68,7 @@ pub fn run_tests(config: Config) -> Result<()> {\n     let ignored = AtomicUsize::default();\n     let filtered = AtomicUsize::default();\n \n-    crossbeam::scope(|s| {\n+    crossbeam::scope(|s| -> Result<()> {\n         // Create a thread that is in charge of walking the directory and submitting jobs.\n         // It closes the channel when it is done.\n         s.spawn(|_| {\n@@ -94,9 +94,11 @@ pub fn run_tests(config: Config) -> Result<()> {\n             drop(submit);\n         });\n \n+        let mut threads = vec![];\n+\n         // Create N worker threads that receive files to test.\n         for _ in 0..std::thread::available_parallelism().unwrap().get() {\n-            s.spawn(|_| -> Result<()> {\n+            threads.push(s.spawn(|_| -> Result<()> {\n                 for path in &receive {\n                     if !config.path_filter.is_empty() {\n                         let path_display = path.display().to_string();\n@@ -145,10 +147,14 @@ pub fn run_tests(config: Config) -> Result<()> {\n                     }\n                 }\n                 Ok(())\n-            });\n+            }));\n+        }\n+        for thread in threads {\n+            thread.join().unwrap()?;\n         }\n+        Ok(())\n     })\n-    .unwrap();\n+    .unwrap()?;\n \n     // Print all errors in a single thread to show reliable output\n     let failures = failures.into_inner().unwrap();"}]}