{"sha": "25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZDdlMTkzN2VlMWY5ZDkwYzlhOGU2NDM3ODVkYzJkYzA2ZDk2NTg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-22T18:42:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-22T18:42:58Z"}, "message": "Merge pull request #487 from solson/rustup\n\nRustup", "tree": {"sha": "09dfac54e18d8b37464b6720382f8a7ee4fdc62a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09dfac54e18d8b37464b6720382f8a7ee4fdc62a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbzhoyCRBK7hj4Ov3rIwAAdHIIAHoLL8bF4Uks8uqKiU2kVHod\ne+CaQH4JkddrDfvOW3B3L3O0tVVletQ8XHZjtJ0SYWl20+7OXN1xSwphq8zExaeG\nZBHOphikKtL9Yb6FLZyFnmXQrYmMutEdFMKFNE1EUiwHVKE2Kmpu8DbVU7IYxYA2\ne0LEwuzcIoeHNo2YoKE45cTEB1e5myZ0/n79dPS3nwKWuz7vL8kAuS32KRBDbUpL\n2ez19R96gmKKVXDLucnOdHEbgIWyddP9caau0W6QBY8x0WB1LEsIb3f/DM+7DMzY\nyrmmcSz94Kw+f8YGmjq1aOkJ7w0Hp9VIk75UzYc9q4NIx3OlcT+tNa1bT8hp8WM=\n=/SmR\n-----END PGP SIGNATURE-----\n", "payload": "tree 09dfac54e18d8b37464b6720382f8a7ee4fdc62a\nparent 53dc505592723e124c134e4bc4f9aa380bbb5a3e\nparent 1a7fb7ec3ce5be7205fc1b3fb40642792985d501\nauthor Ralf Jung <post@ralfj.de> 1540233778 +0200\ncommitter GitHub <noreply@github.com> 1540233778 +0200\n\nMerge pull request #487 from solson/rustup\n\nRustup"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "html_url": "https://github.com/rust-lang/rust/commit/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53dc505592723e124c134e4bc4f9aa380bbb5a3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/53dc505592723e124c134e4bc4f9aa380bbb5a3e", "html_url": "https://github.com/rust-lang/rust/commit/53dc505592723e124c134e4bc4f9aa380bbb5a3e"}, {"sha": "1a7fb7ec3ce5be7205fc1b3fb40642792985d501", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a7fb7ec3ce5be7205fc1b3fb40642792985d501", "html_url": "https://github.com/rust-lang/rust/commit/1a7fb7ec3ce5be7205fc1b3fb40642792985d501"}], "stats": {"total": 1216, "additions": 802, "deletions": 414}, "files": [{"sha": "cc0787f877e6f8f180f944ad750a0d5f7ece4ff7", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -1 +1 @@\n-nightly-2018-10-14\n+nightly-2018-10-22"}, {"sha": "0cbd891a34e4c6127786e367c89cc56c4a617a70", "filename": "src/fn_call.rs", "status": "modified", "additions": 51, "deletions": 46, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -12,8 +12,8 @@ pub trait EvalContextExt<'tcx, 'mir> {\n     fn emulate_foreign_item(\n         &mut self,\n         def_id: DefId,\n-        args: &[OpTy<'tcx>],\n-        dest: PlaceTy<'tcx>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: PlaceTy<'tcx, Borrow>,\n         ret: mir::BasicBlock,\n     ) -> EvalResult<'tcx>;\n \n@@ -24,28 +24,28 @@ pub trait EvalContextExt<'tcx, 'mir> {\n     fn emulate_missing_fn(\n         &mut self,\n         path: String,\n-        args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: Option<PlaceTy<'tcx, Borrow>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx>;\n \n     fn find_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: Option<PlaceTy<'tcx, Borrow>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>>;\n \n-    fn write_null(&mut self, dest: PlaceTy<'tcx>) -> EvalResult<'tcx>;\n+    fn write_null(&mut self, dest: PlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n     fn find_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: Option<PlaceTy<'tcx, Borrow>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>> {\n         trace!(\"eval_fn_call: {:#?}, {:?}\", instance, dest.map(|place| *place));\n@@ -104,8 +104,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n     fn emulate_foreign_item(\n         &mut self,\n         def_id: DefId,\n-        args: &[OpTy<'tcx>],\n-        dest: PlaceTy<'tcx>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: PlaceTy<'tcx, Borrow>,\n         ret: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n         let attrs = self.tcx.get_attrs(def_id);\n@@ -114,6 +114,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n             None => self.tcx.item_name(def_id).as_str(),\n         };\n \n+        // All these functions take raw pointers, so if we access memory directly\n+        // (as opposed to through a place), we have to remember to erase any tag\n+        // that might still hang around!\n+\n         match &link_name[..] {\n             \"malloc\" => {\n                 let size = self.read_scalar(args[0])?.to_usize(&self)?;\n@@ -127,10 +131,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n             }\n \n             \"free\" => {\n-                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation, no tag\n                 if !ptr.is_null() {\n                     self.memory.deallocate(\n-                        ptr.to_ptr()?,\n+                        ptr.to_ptr()?.with_default_tag(),\n                         None,\n                         MiriMemoryKind::C.into(),\n                     )?;\n@@ -167,7 +171,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                 self.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_dealloc\" => {\n-                let ptr = self.read_scalar(args[0])?.to_ptr()?;\n+                let ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation, no tag\n                 let old_size = self.read_scalar(args[1])?.to_usize(&self)?;\n                 let align = self.read_scalar(args[2])?.to_usize(&self)?;\n                 if old_size == 0 {\n@@ -177,13 +181,13 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 self.memory.deallocate(\n-                    ptr,\n+                    ptr.with_default_tag(),\n                     Some((Size::from_bytes(old_size), Align::from_bytes(align, align).unwrap())),\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n             }\n             \"__rust_realloc\" => {\n-                let ptr = self.read_scalar(args[0])?.to_ptr()?;\n+                let ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation, no tag\n                 let old_size = self.read_scalar(args[1])?.to_usize(&self)?;\n                 let align = self.read_scalar(args[2])?.to_usize(&self)?;\n                 let new_size = self.read_scalar(args[3])?.to_usize(&self)?;\n@@ -194,7 +198,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 let new_ptr = self.memory.reallocate(\n-                    ptr,\n+                    ptr.with_default_tag(),\n                     Size::from_bytes(old_size),\n                     Align::from_bytes(align, align).unwrap(),\n                     Size::from_bytes(new_size),\n@@ -226,8 +230,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n \n             \"dlsym\" => {\n                 let _handle = self.read_scalar(args[0])?;\n-                let symbol = self.read_scalar(args[1])?.to_ptr()?;\n-                let symbol_name = self.memory.read_c_str(symbol)?;\n+                let symbol = self.read_scalar(args[1])?.to_ptr()?.erase_tag();\n+                let symbol_name = self.memory.read_c_str(symbol.with_default_tag())?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n                 return err!(Unimplemented(format!(\n@@ -280,13 +284,13 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                 return err!(MachineError(\"the evaluated program panicked\".to_string())),\n \n             \"memcmp\" => {\n-                let left = self.read_scalar(args[0])?.not_undef()?;\n-                let right = self.read_scalar(args[1])?.not_undef()?;\n+                let left = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n+                let right = self.read_scalar(args[1])?.not_undef()?.erase_tag(); // raw ptr operation\n                 let n = Size::from_bytes(self.read_scalar(args[2])?.to_usize(&self)?);\n \n                 let result = {\n-                    let left_bytes = self.memory.read_bytes(left, n)?;\n-                    let right_bytes = self.memory.read_bytes(right, n)?;\n+                    let left_bytes = self.memory.read_bytes(left.with_default_tag(), n)?;\n+                    let right_bytes = self.memory.read_bytes(right.with_default_tag(), n)?;\n \n                     use std::cmp::Ordering::*;\n                     match left_bytes.cmp(right_bytes) {\n@@ -303,12 +307,12 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n             }\n \n             \"memrchr\" => {\n-                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n+                let ptr = ptr.with_default_tag();\n                 let val = self.read_scalar(args[1])?.to_bytes()? as u8;\n                 let num = self.read_scalar(args[2])?.to_usize(&self)?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().rev().position(\n-                    |&c| c == val,\n-                )\n+                if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?\n+                    .iter().rev().position(|&c| c == val)\n                 {\n                     let new_ptr = ptr.ptr_offset(Size::from_bytes(num - idx as u64 - 1), &self)?;\n                     self.write_scalar(new_ptr, dest)?;\n@@ -318,7 +322,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n             }\n \n             \"memchr\" => {\n-                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n+                let ptr = ptr.with_default_tag();\n                 let val = self.read_scalar(args[1])?.to_bytes()? as u8;\n                 let num = self.read_scalar(args[2])?.to_usize(&self)?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().position(\n@@ -334,8 +339,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n \n             \"getenv\" => {\n                 let result = {\n-                    let name_ptr = self.read_scalar(args[0])?.to_ptr()?;\n-                    let name = self.memory.read_c_str(name_ptr)?;\n+                    let name_ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation\n+                    let name = self.memory.read_c_str(name_ptr.with_default_tag())?;\n                     match self.machine.env_vars.get(name) {\n                         Some(&var) => Scalar::Ptr(var),\n                         None => Scalar::ptr_null(*self.tcx),\n@@ -347,9 +352,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n             \"unsetenv\" => {\n                 let mut success = None;\n                 {\n-                    let name_ptr = self.read_scalar(args[0])?.not_undef()?;\n+                    let name_ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n                     if !name_ptr.is_null() {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n+                        let name = self.memory.read_c_str(name_ptr.to_ptr()?.with_default_tag())?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             success = Some(self.machine.env_vars.remove(name));\n                         }\n@@ -368,11 +373,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n             \"setenv\" => {\n                 let mut new = None;\n                 {\n-                    let name_ptr = self.read_scalar(args[0])?.not_undef()?;\n-                    let value_ptr = self.read_scalar(args[1])?.to_ptr()?;\n-                    let value = self.memory.read_c_str(value_ptr)?;\n+                    let name_ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n+                    let value_ptr = self.read_scalar(args[1])?.to_ptr()?.erase_tag(); // raw ptr operation\n+                    let value = self.memory.read_c_str(value_ptr.with_default_tag())?;\n                     if !name_ptr.is_null() {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n+                        let name = self.memory.read_c_str(name_ptr.to_ptr()?.with_default_tag())?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             new = Some((name.to_owned(), value.to_owned()));\n                         }\n@@ -403,14 +408,14 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n \n             \"write\" => {\n                 let fd = self.read_scalar(args[0])?.to_bytes()?;\n-                let buf = self.read_scalar(args[1])?.not_undef()?;\n+                let buf = self.read_scalar(args[1])?.not_undef()?.erase_tag();\n                 let n = self.read_scalar(args[2])?.to_bytes()? as u64;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 {\n                     // stdout/stderr\n                     use std::io::{self, Write};\n \n-                    let buf_cont = self.memory.read_bytes(buf, Size::from_bytes(n))?;\n+                    let buf_cont = self.memory.read_bytes(buf.with_default_tag(), Size::from_bytes(n))?;\n                     let res = if fd == 1 {\n                         io::stdout().write(buf_cont)\n                     } else {\n@@ -431,8 +436,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n             }\n \n             \"strlen\" => {\n-                let ptr = self.read_scalar(args[0])?.to_ptr()?;\n-                let n = self.memory.read_c_str(ptr)?.len();\n+                let ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag();\n+                let n = self.memory.read_c_str(ptr.with_default_tag())?.len();\n                 self.write_scalar(Scalar::from_uint(n as u64, dest.layout.size), dest)?;\n             }\n \n@@ -478,7 +483,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n-                let key_ptr = self.read_scalar(args[0])?.to_ptr()?;\n+                let key_ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n                 let dtor = match self.read_scalar(args[1])?.not_undef()? {\n@@ -501,7 +506,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                     return err!(OutOfTls);\n                 }\n                 self.memory.write_scalar(\n-                    key_ptr,\n+                    key_ptr.with_default_tag(),\n                     key_layout.align,\n                     Scalar::from_uint(key, key_layout.size).into(),\n                     key_layout.size,\n@@ -637,8 +642,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n     fn emulate_missing_fn(\n         &mut self,\n         path: String,\n-        _args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n+        _args: &[OpTy<'tcx, Borrow>],\n+        dest: Option<PlaceTy<'tcx, Borrow>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx> {\n         // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n@@ -686,7 +691,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n         Ok(())\n     }\n \n-    fn write_null(&mut self, dest: PlaceTy<'tcx>) -> EvalResult<'tcx> {\n+    fn write_null(&mut self, dest: PlaceTy<'tcx, Borrow>) -> EvalResult<'tcx> {\n         self.write_scalar(Scalar::from_int(0, dest.layout.size), dest)\n     }\n }"}, {"sha": "c4aad2033e570c2a85a736234a3101aff1a735e7", "filename": "src/helpers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -12,7 +12,7 @@ pub trait ScalarExt {\n     fn to_bytes(self) -> EvalResult<'static, u128>;\n }\n \n-impl ScalarExt for Scalar {\n+impl<Tag> ScalarExt for Scalar<Tag> {\n     fn to_bytes(self) -> EvalResult<'static, u128> {\n         match self {\n             Scalar::Bits { bits, size } => {\n@@ -24,7 +24,7 @@ impl ScalarExt for Scalar {\n     }\n }\n \n-impl ScalarExt for ScalarMaybeUndef {\n+impl<Tag> ScalarExt for ScalarMaybeUndef<Tag> {\n     fn to_bytes(self) -> EvalResult<'static, u128> {\n         self.not_undef()?.to_bytes()\n     }"}, {"sha": "5c86075883b0b9b11c3b1a597de143adbf0adc1c", "filename": "src/intrinsic.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -3,35 +3,38 @@ use rustc::ty::layout::{self, LayoutOf, Size};\n use rustc::ty;\n \n use rustc::mir::interpret::{EvalResult, PointerArithmetic};\n-use rustc_mir::interpret::{EvalContext, PlaceTy, OpTy};\n \n use super::{\n-    Value, Scalar, ScalarMaybeUndef,\n+    PlaceTy, OpTy, Value, Scalar, ScalarMaybeUndef, Borrow,\n     ScalarExt, OperatorEvalContextExt\n };\n \n pub trait EvalContextExt<'tcx> {\n     fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: PlaceTy<'tcx>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: PlaceTy<'tcx, Borrow>,\n     ) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n     fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: PlaceTy<'tcx>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: PlaceTy<'tcx, Borrow>,\n     ) -> EvalResult<'tcx> {\n         if self.emulate_intrinsic(instance, args, dest)? {\n             return Ok(());\n         }\n \n         let substs = instance.substs;\n \n+        // All these intrinsics take raw pointers, so if we access memory directly\n+        // (as opposed to through a place), we have to remember to erase any tag\n+        // that might still hang around!\n+\n         let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n         match intrinsic_name {\n             \"arith_offset\" => {\n@@ -147,12 +150,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let elem_size = elem_layout.size.bytes();\n                 let count = self.read_scalar(args[2])?.to_usize(&self)?;\n                 let elem_align = elem_layout.align;\n-                let src = self.read_scalar(args[0])?.not_undef()?;\n-                let dest = self.read_scalar(args[1])?.not_undef()?;\n+                // erase tags: this is a raw ptr operation\n+                let src = self.read_scalar(args[0])?.not_undef()?.erase_tag();\n+                let dest = self.read_scalar(args[1])?.not_undef()?.erase_tag();\n                 self.memory.copy(\n-                    src,\n+                    src.with_default_tag(),\n                     elem_align,\n-                    dest,\n+                    dest.with_default_tag(),\n                     elem_align,\n                     Size::from_bytes(count * elem_size),\n                     intrinsic_name.ends_with(\"_nonoverlapping\"),\n@@ -429,7 +433,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let ty = substs.type_at(0);\n                 let ty_layout = self.layout_of(ty)?;\n                 let val_byte = self.read_scalar(args[1])?.to_u8()?;\n-                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag().with_default_tag();\n                 let count = self.read_scalar(args[2])?.to_usize(&self)?;\n                 self.memory.check_align(ptr, ty_layout.align)?;\n                 self.memory.write_repeat(ptr, val_byte, ty_layout.size * count)?;"}, {"sha": "ed23eef3f550054cc616d50f36924861a1bd543b", "filename": "src/lib.rs", "status": "modified", "additions": 104, "deletions": 33, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -16,16 +16,14 @@ extern crate syntax;\n use std::collections::HashMap;\n use std::borrow::Cow;\n \n-use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n+use rustc::ty::{self, Ty, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n \n-use syntax::ast::Mutability;\n use syntax::attr;\n \n \n-pub use rustc::mir::interpret::*;\n pub use rustc_mir::interpret::*;\n pub use rustc_mir::interpret::{self, AllocMap}; // resolve ambiguity\n \n@@ -34,9 +32,9 @@ mod operator;\n mod intrinsic;\n mod helpers;\n mod tls;\n-mod locks;\n mod range_map;\n mod mono_hash_map;\n+mod stacked_borrows;\n \n use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n use operator::EvalContextExt as OperatorEvalContextExt;\n@@ -46,6 +44,7 @@ use range_map::RangeMap;\n #[allow(unused_imports)] // FIXME rustc bug https://github.com/rust-lang/rust/issues/53682\n use helpers::{ScalarExt, EvalContextExt as HelpersEvalContextExt};\n use mono_hash_map::MonoHashMap;\n+use stacked_borrows::{EvalContextExt as StackedBorEvalContextExt, Borrow};\n \n pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -56,7 +55,6 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n         Evaluator::new(validate),\n-        Default::default(),\n     );\n \n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n@@ -124,9 +122,9 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         let foo = ecx.memory.allocate_static_bytes(b\"foo\\0\");\n         let foo_ty = ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8);\n         let foo_layout = ecx.layout_of(foo_ty)?;\n-        let foo_place = ecx.allocate(foo_layout, MemoryKind::Stack)?; // will be interned in just a second\n+        let foo_place = ecx.allocate(foo_layout, MiriMemoryKind::Env.into())?;\n         ecx.write_scalar(Scalar::Ptr(foo), foo_place.into())?;\n-        ecx.memory.intern_static(foo_place.to_ptr()?.alloc_id, Mutability::Immutable)?;\n+        ecx.memory.mark_immutable(foo_place.to_ptr()?.alloc_id)?;\n         ecx.write_scalar(foo_place.ptr, dest)?;\n \n         assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n@@ -222,23 +220,36 @@ pub enum MiriMemoryKind {\n }\n \n impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n+    #[inline(always)]\n     fn into(self) -> MemoryKind<MiriMemoryKind> {\n         MemoryKind::Machine(self)\n     }\n }\n \n+impl MayLeak for MiriMemoryKind {\n+    #[inline(always)]\n+    fn may_leak(self) -> bool {\n+        use MiriMemoryKind::*;\n+        match self {\n+            Rust | C => false,\n+            Env | MutStatic => true,\n+        }\n+    }\n+}\n \n-#[derive(Clone, PartialEq, Eq)]\n pub struct Evaluator<'tcx> {\n     /// Environment variables set by `setenv`\n     /// Miri does not expose env vars from the host to the emulated program\n-    pub(crate) env_vars: HashMap<Vec<u8>, Pointer>,\n+    pub(crate) env_vars: HashMap<Vec<u8>, Pointer<Borrow>>,\n \n     /// TLS state\n     pub(crate) tls: TlsData<'tcx>,\n \n     /// Whether to enforce the validity invariant\n     pub(crate) validate: bool,\n+\n+    /// Stacked Borrows state\n+    pub(crate) stacked_borrows: stacked_borrows::State,\n }\n \n impl<'tcx> Evaluator<'tcx> {\n@@ -247,16 +258,23 @@ impl<'tcx> Evaluator<'tcx> {\n             env_vars: HashMap::default(),\n             tls: TlsData::default(),\n             validate,\n+            stacked_borrows: stacked_borrows::State::new(),\n         }\n     }\n }\n \n+#[allow(dead_code)] // FIXME https://github.com/rust-lang/rust/issues/47131\n+type MiriEvalContext<'a, 'mir, 'tcx> = EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>;\n+\n+\n impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n-    type MemoryData = ();\n     type MemoryKinds = MiriMemoryKind;\n-    type PointerTag = (); // still WIP\n \n-    type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<()>)>;\n+    type AllocExtra = stacked_borrows::Stacks;\n+    type PointerTag = Borrow;\n+    const ENABLE_PTR_TRACKING_HOOKS: bool = true;\n+\n+    type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Borrow, Self::AllocExtra>)>;\n \n     const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::MutStatic);\n \n@@ -284,39 +302,42 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     /// Returns Ok() when the function was handled, fail otherwise\n+    #[inline(always)]\n     fn find_fn(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: Option<PlaceTy<'tcx, Borrow>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>> {\n         ecx.find_fn(instance, args, dest, ret)\n     }\n \n+    #[inline(always)]\n     fn call_intrinsic(\n         ecx: &mut rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        dest: PlaceTy<'tcx>,\n+        args: &[OpTy<'tcx, Borrow>],\n+        dest: PlaceTy<'tcx, Borrow>,\n     ) -> EvalResult<'tcx> {\n         ecx.call_intrinsic(instance, args, dest)\n     }\n \n+    #[inline(always)]\n     fn ptr_op(\n         ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n-        left: Scalar,\n+        left: Scalar<Borrow>,\n         left_layout: TyLayout<'tcx>,\n-        right: Scalar,\n+        right: Scalar<Borrow>,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)> {\n         ecx.ptr_op(bin_op, left, left_layout, right, right_layout)\n     }\n \n     fn box_alloc(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        dest: PlaceTy<'tcx>,\n+        dest: PlaceTy<'tcx, Borrow>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"box_alloc for {:?}\", dest.layout.ty);\n         // Call the `exchange_malloc` lang item\n@@ -356,7 +377,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     fn find_foreign_static(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n-    ) -> EvalResult<'tcx, Cow<'tcx, Allocation>> {\n+    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Borrow, Self::AllocExtra>>> {\n         let attrs = tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n             Some(name) => name.as_str(),\n@@ -376,16 +397,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         Ok(Cow::Owned(alloc))\n     }\n \n-    fn validation_op(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        _op: ::rustc::mir::ValidationOp,\n-        _operand: &::rustc::mir::ValidationOperand<'tcx, ::rustc::mir::Place<'tcx>>,\n-    ) -> EvalResult<'tcx> {\n-        // FIXME: prevent this from ICEing\n-        //ecx.validation_op(op, operand)\n-        Ok(())\n-    }\n-\n+    #[inline(always)]\n     fn before_terminator(_ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>\n     {\n         // We are not interested in detecting loops\n@@ -394,8 +406,67 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n \n     fn static_with_default_tag(\n         alloc: &'_ Allocation\n-    ) -> Cow<'_, Allocation<Self::PointerTag>> {\n-        let alloc = alloc.clone();\n+    ) -> Cow<'_, Allocation<Borrow, Self::AllocExtra>> {\n+        let alloc: Allocation<Borrow, Self::AllocExtra> = Allocation {\n+            bytes: alloc.bytes.clone(),\n+            relocations: Relocations::from_presorted(\n+                alloc.relocations.iter()\n+                    .map(|&(offset, ((), alloc))| (offset, (Borrow::default(), alloc)))\n+                    .collect()\n+            ),\n+            undef_mask: alloc.undef_mask.clone(),\n+            align: alloc.align,\n+            mutability: alloc.mutability,\n+            extra: Self::AllocExtra::default(),\n+        };\n         Cow::Owned(alloc)\n     }\n+\n+    #[inline(always)]\n+    fn memory_accessed(\n+        alloc: &Allocation<Borrow, Self::AllocExtra>,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+        access: MemoryAccess,\n+    ) -> EvalResult<'tcx> {\n+        alloc.extra.memory_accessed(ptr, size, access)\n+    }\n+\n+    #[inline(always)]\n+    fn memory_deallocated(\n+        alloc: &mut Allocation<Self::PointerTag, Self::AllocExtra>,\n+        ptr: Pointer<Borrow>,\n+    ) -> EvalResult<'tcx> {\n+        alloc.extra.memory_deallocated(ptr)\n+    }\n+\n+    #[inline(always)]\n+    fn tag_reference(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ptr: Pointer<Borrow>,\n+        pointee_ty: Ty<'tcx>,\n+        pointee_size: Size,\n+        borrow_kind: Option<mir::BorrowKind>,\n+    ) -> EvalResult<'tcx, Borrow> {\n+        if !ecx.machine.validate {\n+            // No tracking\n+            Ok(Borrow::default())\n+        } else {\n+            ecx.tag_reference(ptr, pointee_ty, pointee_size, borrow_kind)\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn tag_dereference(\n+        ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n+        ptr: Pointer<Borrow>,\n+        ptr_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Borrow> {\n+        if !ecx.machine.validate {\n+            // No tracking\n+            Ok(Borrow::default())\n+        } else {\n+            ecx.tag_dereference(ptr, ptr_ty)\n+        }\n+    }\n }"}, {"sha": "a87ff6367e3ad89c398360e87013b3d994586d22", "filename": "src/locks.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/53dc505592723e124c134e4bc4f9aa380bbb5a3e/src%2Flocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53dc505592723e124c134e4bc4f9aa380bbb5a3e/src%2Flocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flocks.rs?ref=53dc505592723e124c134e4bc4f9aa380bbb5a3e", "patch": "@@ -1,94 +0,0 @@\n-#![allow(unused)]\n-\n-use super::*;\n-use rustc::middle::region;\n-use rustc::ty::layout::Size;\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Locks\n-////////////////////////////////////////////////////////////////////////////////\n-\n-// Just some dummy to keep this compiling; I think some of this will be useful later\n-type AbsPlace<'tcx> = ::rustc::ty::Ty<'tcx>;\n-\n-/// Information about a lock that is currently held.\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct LockInfo<'tcx> {\n-    /// Stores for which lifetimes (of the original write lock) we got\n-    /// which suspensions.\n-    suspended: HashMap<WriteLockId<'tcx>, Vec<region::Scope>>,\n-    /// The current state of the lock that's actually effective.\n-    pub active: Lock,\n-}\n-\n-/// Write locks are identified by a stack frame and an \"abstract\" (untyped) place.\n-/// It may be tempting to use the lifetime as identifier, but that does not work\n-/// for two reasons:\n-/// * First of all, due to subtyping, the same lock may be referred to with different\n-///   lifetimes.\n-/// * Secondly, different write locks may actually have the same lifetime.  See `test2`\n-///   in `run-pass/many_shr_bor.rs`.\n-/// The Id is \"captured\" when the lock is first suspended; at that point, the borrow checker\n-/// considers the path frozen and hence the Id remains stable.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct WriteLockId<'tcx> {\n-    frame: usize,\n-    path: AbsPlace<'tcx>,\n-}\n-\n-\n-use rustc::mir::interpret::Lock::*;\n-use rustc::mir::interpret::Lock;\n-\n-impl<'tcx> Default for LockInfo<'tcx> {\n-    fn default() -> Self {\n-        LockInfo::new(NoLock)\n-    }\n-}\n-\n-impl<'tcx> LockInfo<'tcx> {\n-    fn new(lock: Lock) -> LockInfo<'tcx> {\n-        LockInfo {\n-            suspended: HashMap::new(),\n-            active: lock,\n-        }\n-    }\n-\n-    fn access_permitted(&self, frame: Option<usize>, access: AccessKind) -> bool {\n-        use super::AccessKind::*;\n-        match (&self.active, access) {\n-            (&NoLock, _) => true,\n-            (&ReadLock(ref lfts), Read) => {\n-                assert!(!lfts.is_empty(), \"Someone left an empty read lock behind.\");\n-                // Read access to read-locked region is okay, no matter who's holding the read lock.\n-                true\n-            }\n-            (&WriteLock(ref lft), _) => {\n-                // All access is okay if we are the ones holding it\n-                Some(lft.frame) == frame\n-            }\n-            _ => false, // Nothing else is okay.\n-        }\n-    }\n-}\n-\n-impl<'tcx> RangeMap<LockInfo<'tcx>> {\n-    pub fn check(\n-        &self,\n-        frame: Option<usize>,\n-        offset: u64,\n-        len: u64,\n-        access: AccessKind,\n-    ) -> Result<(), LockInfo<'tcx>> {\n-        if len == 0 {\n-            return Ok(());\n-        }\n-        for lock in self.iter(offset, len) {\n-            // Check if the lock is in conflict with the access.\n-            if !lock.access_permitted(frame, access) {\n-                return Err(lock.clone());\n-            }\n-        }\n-        Ok(())\n-    }\n-}"}, {"sha": "a11f8f34e7e86170c6a309cd0e1eb6f5a51f1816", "filename": "src/operator.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -7,44 +7,44 @@ pub trait EvalContextExt<'tcx> {\n     fn ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Scalar,\n+        left: Scalar<Borrow>,\n         left_layout: TyLayout<'tcx>,\n-        right: Scalar,\n+        right: Scalar<Borrow>,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Scalar, bool)>;\n+    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)>;\n \n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Pointer,\n+        left: Pointer<Borrow>,\n         right: u128,\n         signed: bool,\n-    ) -> EvalResult<'tcx, (Scalar, bool)>;\n+    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)>;\n \n     fn ptr_eq(\n         &self,\n-        left: Scalar,\n-        right: Scalar,\n+        left: Scalar<Borrow>,\n+        right: Scalar<Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx, bool>;\n \n     fn pointer_offset_inbounds(\n         &self,\n-        ptr: Scalar,\n+        ptr: Scalar<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         offset: i64,\n-    ) -> EvalResult<'tcx, Scalar>;\n+    ) -> EvalResult<'tcx, Scalar<Borrow>>;\n }\n \n-impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n     fn ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Scalar,\n+        left: Scalar<Borrow>,\n         left_layout: TyLayout<'tcx>,\n-        right: Scalar,\n+        right: Scalar<Borrow>,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)> {\n         use rustc::mir::BinOp::*;\n \n         trace!(\"ptr_op: {:?} {:?} {:?}\", left, bin_op, right);\n@@ -124,8 +124,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n     fn ptr_eq(\n         &self,\n-        left: Scalar,\n-        right: Scalar,\n+        left: Scalar<Borrow>,\n+        right: Scalar<Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx, bool> {\n         Ok(match (left, right) {\n@@ -203,13 +203,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Pointer,\n+        left: Pointer<Borrow>,\n         right: u128,\n         signed: bool,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar<Borrow>, bool)> {\n         use rustc::mir::BinOp::*;\n \n-        fn map_to_primval((res, over): (Pointer, bool)) -> (Scalar, bool) {\n+        fn map_to_primval((res, over): (Pointer<Borrow>, bool)) -> (Scalar<Borrow>, bool) {\n             (Scalar::Ptr(res), over)\n         }\n \n@@ -237,7 +237,14 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 if right & base_mask == base_mask {\n                     // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n                     let offset = (left.offset.bytes() as u128 & right) as u64;\n-                    (Scalar::Ptr(Pointer::new(left.alloc_id, Size::from_bytes(offset))), false)\n+                    (\n+                        Scalar::Ptr(Pointer::new_with_tag(\n+                            left.alloc_id,\n+                            Size::from_bytes(offset),\n+                            left.tag,\n+                        )),\n+                        false,\n+                    )\n                 } else if right & base_mask == 0 {\n                     // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n                     (Scalar::Bits { bits: (left.offset.bytes() as u128) & right, size: ptr_size }, false)\n@@ -277,10 +284,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n     /// allocation.\n     fn pointer_offset_inbounds(\n         &self,\n-        ptr: Scalar,\n+        ptr: Scalar<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         offset: i64,\n-    ) -> EvalResult<'tcx, Scalar> {\n+    ) -> EvalResult<'tcx, Scalar<Borrow>> {\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n         let offset = offset.checked_mul(pointee_size).ok_or_else(|| EvalErrorKind::Overflow(mir::BinOp::Mul))?;"}, {"sha": "74a49bf83b8198310c3ab6b8043d8bb9d8885ed2", "filename": "src/range_map.rs", "status": "modified", "additions": 102, "deletions": 52, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -9,26 +9,40 @@\n use std::collections::BTreeMap;\n use std::ops;\n \n+use rustc::ty::layout::Size;\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct RangeMap<T> {\n     map: BTreeMap<Range, T>,\n }\n \n+impl<T> Default for RangeMap<T> {\n+    #[inline(always)]\n+    fn default() -> Self {\n+        RangeMap::new()\n+    }\n+}\n+\n // The derived `Ord` impl sorts first by the first field, then, if the fields are the same,\n // by the second field.\n // This is exactly what we need for our purposes, since a range query on a BTReeSet/BTreeMap will give us all\n // `MemoryRange`s whose `start` is <= than the one we're looking for, but not > the end of the range we're checking.\n // At the same time the `end` is irrelevant for the sorting and range searching, but used for the check.\n // This kind of search breaks, if `end < start`, so don't do that!\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n-pub struct Range {\n+struct Range {\n     start: u64,\n     end: u64, // Invariant: end > start\n }\n \n impl Range {\n+    /// Compute a range of ranges that contains all ranges overlaping with [offset, offset+len)\n     fn range(offset: u64, len: u64) -> ops::Range<Range> {\n-        assert!(len > 0);\n+        if len == 0 {\n+            // We can produce an empty range, nothing overlaps with this.\n+            let r = Range { start: 0, end: 1 };\n+            return r..r;\n+        }\n         // We select all elements that are within\n         // the range given by the offset into the allocation and the length.\n         // This is sound if all ranges that intersect with the argument range, are in the\n@@ -46,14 +60,20 @@ impl Range {\n         left..right\n     }\n \n-    /// Tests if all of [offset, offset+len) are contained in this range.\n+    /// Tests if any element of [offset, offset+len) is contained in this range.\n+    #[inline(always)]\n     fn overlaps(&self, offset: u64, len: u64) -> bool {\n-        assert!(len > 0);\n-        offset < self.end && offset + len >= self.start\n+        if len == 0 {\n+            // `offset` totally does not matter, we cannot overlap with an empty interval\n+            false\n+        } else {\n+            offset < self.end && offset.checked_add(len).unwrap() >= self.start\n+        }\n     }\n }\n \n impl<T> RangeMap<T> {\n+    #[inline(always)]\n     pub fn new() -> RangeMap<T> {\n         RangeMap { map: BTreeMap::new() }\n     }\n@@ -63,10 +83,9 @@ impl<T> RangeMap<T> {\n         offset: u64,\n         len: u64,\n     ) -> impl Iterator<Item = (&'a Range, &'a T)> + 'a {\n-        assert!(len > 0);\n         self.map.range(Range::range(offset, len)).filter_map(\n-            move |(range,\n-                   data)| {\n+            move |(range, data)| {\n+                debug_assert!(len > 0);\n                 if range.overlaps(offset, len) {\n                     Some((range, data))\n                 } else {\n@@ -76,8 +95,12 @@ impl<T> RangeMap<T> {\n         )\n     }\n \n-    pub fn iter<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item = &'a T> + 'a {\n-        self.iter_with_range(offset, len).map(|(_, data)| data)\n+    pub fn iter<'a>(&'a self, offset: Size, len: Size) -> impl Iterator<Item = &'a T> + 'a {\n+        self.iter_with_range(offset.bytes(), len.bytes()).map(|(_, data)| data)\n+    }\n+\n+    pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item = &'a mut T> + 'a {\n+        self.map.values_mut()\n     }\n \n     fn split_entry_at(&mut self, offset: u64)\n@@ -114,28 +137,30 @@ impl<T> RangeMap<T> {\n         }\n     }\n \n-    pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item = &'a mut T> + 'a {\n-        self.map.values_mut()\n-    }\n-\n     /// Provide mutable iteration over everything in the given range.  As a side-effect,\n     /// this will split entries in the map that are only partially hit by the given range,\n     /// to make sure that when they are mutated, the effect is constrained to the given range.\n+    /// If there are gaps, leave them be.\n     pub fn iter_mut_with_gaps<'a>(\n         &'a mut self,\n-        offset: u64,\n-        len: u64,\n+        offset: Size,\n+        len: Size,\n     ) -> impl Iterator<Item = &'a mut T> + 'a\n     where\n         T: Clone,\n     {\n-        assert!(len > 0);\n-        // Preparation: Split first and last entry as needed.\n-        self.split_entry_at(offset);\n-        self.split_entry_at(offset + len);\n+        let offset = offset.bytes();\n+        let len = len.bytes();\n+\n+        if len > 0 {\n+            // Preparation: Split first and last entry as needed.\n+            self.split_entry_at(offset);\n+            self.split_entry_at(offset + len);\n+        }\n         // Now we can provide a mutable iterator\n         self.map.range_mut(Range::range(offset, len)).filter_map(\n             move |(&range, data)| {\n+                debug_assert!(len > 0);\n                 if range.overlaps(offset, len) {\n                     assert!(\n                         offset <= range.start && offset + len >= range.end,\n@@ -151,35 +176,41 @@ impl<T> RangeMap<T> {\n     }\n \n     /// Provide a mutable iterator over everything in the given range, with the same side-effects as\n-    /// iter_mut_with_gaps.  Furthermore, if there are gaps between ranges, fill them with the given default.\n+    /// iter_mut_with_gaps.  Furthermore, if there are gaps between ranges, fill them with the given default\n+    /// before yielding them in the iterator.\n     /// This is also how you insert.\n-    pub fn iter_mut<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item = &'a mut T> + 'a\n+    pub fn iter_mut<'a>(&'a mut self, offset: Size, len: Size) -> impl Iterator<Item = &'a mut T> + 'a\n     where\n         T: Clone + Default,\n     {\n-        // Do a first iteration to collect the gaps\n-        let mut gaps = Vec::new();\n-        let mut last_end = offset;\n-        for (range, _) in self.iter_with_range(offset, len) {\n-            if last_end < range.start {\n+        if len.bytes() > 0 {\n+            let offset = offset.bytes();\n+            let len = len.bytes();\n+\n+            // Do a first iteration to collect the gaps\n+            let mut gaps = Vec::new();\n+            let mut last_end = offset;\n+            for (range, _) in self.iter_with_range(offset, len) {\n+                if last_end < range.start {\n+                    gaps.push(Range {\n+                        start: last_end,\n+                        end: range.start,\n+                    });\n+                }\n+                last_end = range.end;\n+            }\n+            if last_end < offset + len {\n                 gaps.push(Range {\n                     start: last_end,\n-                    end: range.start,\n+                    end: offset + len,\n                 });\n             }\n-            last_end = range.end;\n-        }\n-        if last_end < offset + len {\n-            gaps.push(Range {\n-                start: last_end,\n-                end: offset + len,\n-            });\n-        }\n \n-        // Add default for all gaps\n-        for gap in gaps {\n-            let old = self.map.insert(gap, Default::default());\n-            assert!(old.is_none());\n+            // Add default for all gaps\n+            for gap in gaps {\n+                let old = self.map.insert(gap, Default::default());\n+                assert!(old.is_none());\n+            }\n         }\n \n         // Now provide mutable iteration\n@@ -208,45 +239,64 @@ mod tests {\n     use super::*;\n \n     /// Query the map at every offset in the range and collect the results.\n-    fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64) -> Vec<T> {\n+    fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64, default: Option<T>) -> Vec<T> {\n         (offset..offset + len)\n             .into_iter()\n-            .map(|i| *map.iter(i, 1).next().unwrap())\n+            .map(|i| map\n+                .iter(Size::from_bytes(i), Size::from_bytes(1))\n+                .next()\n+                .map(|&t| t)\n+                .or(default)\n+                .unwrap()\n+            )\n             .collect()\n     }\n \n     #[test]\n     fn basic_insert() {\n         let mut map = RangeMap::<i32>::new();\n         // Insert\n-        for x in map.iter_mut(10, 1) {\n+        for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(1)) {\n             *x = 42;\n         }\n         // Check\n-        assert_eq!(to_vec(&map, 10, 1), vec![42]);\n+        assert_eq!(to_vec(&map, 10, 1, None), vec![42]);\n+\n+        // Insert with size 0\n+        for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(0)) {\n+            *x = 19;\n+        }\n+        for x in map.iter_mut(Size::from_bytes(11), Size::from_bytes(0)) {\n+            *x = 19;\n+        }\n+        assert_eq!(to_vec(&map, 10, 2, Some(-1)), vec![42, -1]);\n     }\n \n     #[test]\n     fn gaps() {\n         let mut map = RangeMap::<i32>::new();\n-        for x in map.iter_mut(11, 1) {\n+        for x in map.iter_mut(Size::from_bytes(11), Size::from_bytes(1)) {\n             *x = 42;\n         }\n-        for x in map.iter_mut(15, 1) {\n-            *x = 42;\n+        for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(1)) {\n+            *x = 43;\n         }\n+        assert_eq!(\n+            to_vec(&map, 10, 10, Some(-1)),\n+            vec![-1, 42, -1, -1, -1, 43, -1, -1, -1, -1]\n+        );\n \n         // Now request a range that needs three gaps filled\n-        for x in map.iter_mut(10, 10) {\n-            if *x != 42 {\n+        for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(10)) {\n+            if *x < 42 {\n                 *x = 23;\n             }\n         }\n \n         assert_eq!(\n-            to_vec(&map, 10, 10),\n-            vec![23, 42, 23, 23, 23, 42, 23, 23, 23, 23]\n+            to_vec(&map, 10, 10, None),\n+            vec![23, 42, 23, 23, 23, 43, 23, 23, 23, 23]\n         );\n-        assert_eq!(to_vec(&map, 13, 5), vec![23, 23, 42, 23, 23]);\n+        assert_eq!(to_vec(&map, 13, 5, None), vec![23, 23, 43, 23, 23]);\n     }\n }"}, {"sha": "077deceecf2a6768f6a538217d2a163d38a795b1", "filename": "src/stacked_borrows.rs", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -0,0 +1,308 @@\n+use std::cell::RefCell;\n+\n+use rustc::ty::{Ty, layout::Size};\n+use rustc::mir;\n+\n+use super::{\n+    MemoryAccess, RangeMap, EvalResult,\n+    Pointer,\n+};\n+\n+pub type Timestamp = u64;\n+\n+/// Information about a potentially mutable borrow\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum Mut {\n+    /// A unique, mutable reference\n+    Uniq(Timestamp),\n+    /// Any raw pointer, or a shared borrow with interior mutability\n+    Raw,\n+}\n+\n+impl Mut {\n+    #[inline(always)]\n+    fn is_raw(self) -> bool {\n+        match self {\n+            Mut::Raw => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+/// Information about any kind of borrow\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum Borrow {\n+    /// A mutable borrow, a raw pointer, or a shared borrow with interior mutability\n+    Mut(Mut),\n+    /// A shared borrow without interior mutability\n+    Frz(Timestamp)\n+}\n+\n+impl Borrow {\n+    #[inline(always)]\n+    fn is_uniq(self) -> bool {\n+        match self {\n+            Borrow::Mut(Mut::Uniq(_)) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+/// An item in the borrow stack\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum BorStackItem {\n+    /// Defines which references are permitted to mutate *if* the location is not frozen\n+    Mut(Mut),\n+    /// A barrier, tracking the function it belongs to by its index on the call stack\n+    #[allow(dead_code)] // for future use\n+    FnBarrier(usize)\n+}\n+\n+impl Default for Borrow {\n+    fn default() -> Self {\n+        Borrow::Mut(Mut::Raw)\n+    }\n+}\n+\n+/// Extra global machine state\n+#[derive(Clone, Debug)]\n+pub struct State {\n+    clock: Timestamp\n+}\n+\n+impl State {\n+    pub fn new() -> State {\n+        State { clock: 0 }\n+    }\n+}\n+\n+/// Extra per-location state\n+#[derive(Clone, Debug)]\n+struct Stack {\n+    borrows: Vec<BorStackItem>, // used as a stack\n+    frozen_since: Option<Timestamp>,\n+}\n+\n+impl Default for Stack {\n+    fn default() -> Self {\n+        Stack {\n+            borrows: Vec::new(),\n+            frozen_since: None,\n+        }\n+    }\n+}\n+\n+/// Extra per-allocation state\n+#[derive(Clone, Debug, Default)]\n+pub struct Stacks {\n+    stacks: RefCell<RangeMap<Stack>>,\n+}\n+\n+/// Core operations\n+impl<'tcx> Stack {\n+    fn check(&self, bor: Borrow) -> bool {\n+        match bor {\n+            Borrow::Frz(acc_t) =>\n+                // Must be frozen at least as long as the `acc_t` says.\n+                self.frozen_since.map_or(false, |loc_t| loc_t <= acc_t),\n+            Borrow::Mut(acc_m) =>\n+                // Raw pointers are fine with frozen locations. This is important because &Cell is raw!\n+                if self.frozen_since.is_some() {\n+                    acc_m.is_raw()\n+                } else {\n+                    self.borrows.last().map_or(false, |&loc_itm| loc_itm == BorStackItem::Mut(acc_m))\n+                }\n+        }\n+    }\n+\n+    /// Reactive `bor` for this stack.  If `force_mut` is set, we want to aggressively\n+    /// unfreeze this location (because we are about to push a `Uniq`).\n+    fn reactivate(&mut self, bor: Borrow, force_mut: bool) -> EvalResult<'tcx> {\n+        // Unless mutation is bound to happen, do NOT change anything if `bor` is already active.\n+        // In particular, if it is a `Mut(Raw)` and we are frozen, this should be a NOP.\n+        if !force_mut && self.check(bor) {\n+            return Ok(());\n+        }\n+\n+        let acc_m = match bor {\n+            Borrow::Frz(_) =>\n+                if force_mut {\n+                    return err!(MachineError(format!(\"Using a shared borrow for mutation\")))\n+                } else {\n+                    return err!(MachineError(format!(\"Location should be frozen but it is not\")))\n+                }\n+            Borrow::Mut(acc_m) => acc_m,\n+        };\n+        // We definitely have to unfreeze this, even if we use the topmost item.\n+        self.frozen_since = None;\n+        // Pop until we see the one we are looking for.\n+        while let Some(&itm) = self.borrows.last() {\n+            match itm {\n+                BorStackItem::FnBarrier(_) => {\n+                    return err!(MachineError(format!(\"Trying to reactivate a borrow that lives behind a barrier\")));\n+                }\n+                BorStackItem::Mut(loc_m) => {\n+                    if loc_m == acc_m { return Ok(()); }\n+                    trace!(\"reactivate: Popping {:?}\", itm);\n+                    self.borrows.pop();\n+                }\n+            }\n+        }\n+        // Nothing to be found.  Simulate a \"virtual raw\" element at the bottom of the stack.\n+        if acc_m.is_raw() {\n+            Ok(())\n+        } else {\n+            err!(MachineError(format!(\"Borrow-to-reactivate does not exist on the stack\")))\n+        }\n+    }\n+\n+    fn initiate(&mut self, bor: Borrow) -> EvalResult<'tcx> {\n+        match bor {\n+            Borrow::Frz(t) => {\n+                trace!(\"initiate: Freezing\");\n+                match self.frozen_since {\n+                    None => self.frozen_since = Some(t),\n+                    Some(since) => assert!(since <= t),\n+                }\n+            }\n+            Borrow::Mut(m) => {\n+                trace!(\"initiate: Pushing {:?}\", bor);\n+                match self.frozen_since {\n+                    None => self.borrows.push(BorStackItem::Mut(m)),\n+                    Some(_) =>\n+                        // FIXME: Do we want an exception for raw borrows?\n+                        return err!(MachineError(format!(\"Trying to mutate frozen location\")))\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl State {\n+    fn increment_clock(&mut self) -> Timestamp {\n+        self.clock += 1;\n+        self.clock\n+    }\n+}\n+\n+/// Higher-level operations\n+impl<'tcx> Stacks {\n+    pub fn memory_accessed(\n+        &self,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+        access: MemoryAccess,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"memory_accessed({:?}) with tag {:?}: {:?}, size {}\", access, ptr.tag, ptr, size.bytes());\n+        let mut stacks = self.stacks.borrow_mut();\n+        for stack in stacks.iter_mut(ptr.offset, size) {\n+            // FIXME: Compare this with what the blog post says.\n+            stack.reactivate(ptr.tag, /*force_mut*/access == MemoryAccess::Write)?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn memory_deallocated(\n+        &mut self,\n+        ptr: Pointer<Borrow>,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"memory_deallocated with tag {:?}: {:?}\", ptr.tag, ptr);\n+        let stacks = self.stacks.get_mut();\n+        for stack in stacks.iter_mut_all() {\n+            // This is like mutating.\n+            stack.reactivate(ptr.tag, /*force_mut*/true)?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn reborrow(\n+        &self,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+        new_bor: Borrow,\n+    ) -> EvalResult<'tcx> {\n+        let mut stacks = self.stacks.borrow_mut();\n+        for stack in stacks.iter_mut(ptr.offset, size) {\n+            if stack.check(new_bor) {\n+                // The new borrow is already active!  This can happen when creating multiple\n+                // shared references from the same mutable reference.  Do nothing.\n+            } else {\n+                // FIXME: The blog post says we should `reset` if this is a local.\n+                stack.reactivate(ptr.tag, /*force_mut*/new_bor.is_uniq())?;\n+                stack.initiate(new_bor)?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+/// Machine hooks\n+pub trait EvalContextExt<'tcx> {\n+    fn tag_reference(\n+        &mut self,\n+        ptr: Pointer<Borrow>,\n+        pointee_ty: Ty<'tcx>,\n+        size: Size,\n+        borrow_kind: Option<mir::BorrowKind>,\n+    ) -> EvalResult<'tcx, Borrow>;\n+\n+    fn tag_dereference(\n+        &self,\n+        ptr: Pointer<Borrow>,\n+        ptr_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Borrow>;\n+}\n+\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n+    fn tag_reference(\n+        &mut self,\n+        ptr: Pointer<Borrow>,\n+        pointee_ty: Ty<'tcx>,\n+        size: Size,\n+        borrow_kind: Option<mir::BorrowKind>,\n+    ) -> EvalResult<'tcx, Borrow> {\n+        let time = self.machine.stacked_borrows.increment_clock();\n+        let new_bor = match borrow_kind {\n+            Some(mir::BorrowKind::Mut { .. }) => Borrow::Mut(Mut::Uniq(time)),\n+            Some(_) =>\n+                // FIXME This does not do enough checking when only part of the data has\n+                // interior mutability. When the type is `(i32, Cell<i32>)`, we want the\n+                // first field to be frozen but not the second.\n+                if self.type_is_freeze(pointee_ty) {\n+                    Borrow::Frz(time)\n+                } else {\n+                    Borrow::Mut(Mut::Raw)\n+                },\n+            None => Borrow::Mut(Mut::Raw),\n+        };\n+        trace!(\"tag_reference: Creating new reference ({:?}) for {:?} (pointee {}, size {}): {:?}\",\n+            borrow_kind, ptr, pointee_ty, size.bytes(), new_bor);\n+\n+        // Make sure this reference is not dangling or so\n+        self.memory.check_bounds(ptr, size, false)?;\n+\n+        // Update the stacks.  We cannot use `get_mut` becuse this might be immutable\n+        // memory.\n+        let alloc = self.memory.get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        alloc.extra.reborrow(ptr, size, new_bor)?;\n+\n+        Ok(new_bor)\n+    }\n+\n+    fn tag_dereference(\n+        &self,\n+        ptr: Pointer<Borrow>,\n+        ptr_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Borrow> {\n+        // If this is a raw ptr, forget about the tag.\n+        Ok(if ptr_ty.is_unsafe_ptr() {\n+            trace!(\"tag_dereference: Erasing tag for {:?} ({})\", ptr, ptr_ty);\n+            Borrow::Mut(Mut::Raw)\n+        } else {\n+            // FIXME: Do we want to adjust the tag if it does not match the type?\n+            ptr.tag\n+        })\n+    }\n+}"}, {"sha": "2bddc43df8c4ae1114974fa535bae84029e7b6c9", "filename": "src/tls.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -4,19 +4,19 @@ use rustc_target::abi::LayoutOf;\n use rustc::{ty, ty::layout::HasDataLayout, mir};\n \n use super::{\n-    EvalResult, EvalErrorKind, StackPopCleanup, EvalContext, Evaluator,\n-    MPlaceTy, Scalar,\n+    EvalResult, EvalErrorKind, StackPopCleanup,\n+    MPlaceTy, Scalar, Borrow,\n };\n \n pub type TlsKey = u128;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug)]\n pub struct TlsEntry<'tcx> {\n-    pub(crate) data: Scalar, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n+    pub(crate) data: Scalar<Borrow>, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n     pub(crate) dtor: Option<ty::Instance<'tcx>>,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug)]\n pub struct TlsData<'tcx> {\n     /// The Key to use for the next thread-local allocation.\n     pub(crate) next_key: TlsKey,\n@@ -67,7 +67,7 @@ impl<'tcx> TlsData<'tcx> {\n         }\n     }\n \n-    pub fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar> {\n+    pub fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar<Borrow>> {\n         match self.keys.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n@@ -77,7 +77,7 @@ impl<'tcx> TlsData<'tcx> {\n         }\n     }\n \n-    pub fn store_tls(&mut self, key: TlsKey, new_data: Scalar) -> EvalResult<'tcx> {\n+    pub fn store_tls(&mut self, key: TlsKey, new_data: Scalar<Borrow>) -> EvalResult<'tcx> {\n         match self.keys.get_mut(&key) {\n             Some(&mut TlsEntry { ref mut data, .. }) => {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n@@ -110,7 +110,7 @@ impl<'tcx> TlsData<'tcx> {\n         &mut self,\n         key: Option<TlsKey>,\n         cx: impl HasDataLayout,\n-    ) -> Option<(ty::Instance<'tcx>, Scalar, TlsKey)> {\n+    ) -> Option<(ty::Instance<'tcx>, Scalar<Borrow>, TlsKey)> {\n         use std::collections::Bound::*;\n \n         let thread_local = &mut self.keys;\n@@ -133,7 +133,7 @@ impl<'tcx> TlsData<'tcx> {\n     }\n }\n \n-impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n     fn run_tls_dtors(&mut self) -> EvalResult<'tcx> {\n         let mut dtor = self.machine.tls.fetch_tls_dtor(None, *self.tcx);\n         // FIXME: replace loop by some structure that works with stepping"}, {"sha": "9fa50da45bd0fb4cb1f0784fd50773bc0ee179a7", "filename": "tests/compile-fail/stacked_borrows/alias_through_mutation.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -0,0 +1,15 @@\n+#![allow(unused_variables)]\n+\n+// This makes a ref that was passed to us via &mut alias with things it should not alias with\n+fn retarget(x: &mut &u32, target: &mut u32) {\n+    unsafe { *x = &mut *(target as *mut _); }\n+}\n+\n+fn main() {\n+    let target = &mut 42;\n+    let mut target_alias = &42; // initial dummy value\n+    retarget(&mut target_alias, target);\n+    // now `target_alias` points to the same thing as `target`\n+    *target = 13;\n+    let _val = *target_alias; //~ ERROR should be frozen\n+}"}, {"sha": "e812e13e702cadbfc5dd1dece7e0ba011b0720e2", "filename": "tests/compile-fail/stacked_borrows/aliasing_mut1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut1.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "previous_filename": "tests/compile-fail/validation_aliasing_mut1.rs"}, {"sha": "36ebcc2b4ac6fae57a657af0c9b9c1dfdeda47a3", "filename": "tests/compile-fail/stacked_borrows/aliasing_mut2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut2.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "previous_filename": "tests/compile-fail/validation_aliasing_mut2.rs"}, {"sha": "ad50fbd61b451f0d1a8d1cd05b24afe11a8eff8c", "filename": "tests/compile-fail/stacked_borrows/aliasing_mut3.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut3.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "previous_filename": "tests/compile-fail/validation_aliasing_mut3.rs"}, {"sha": "a0f0a3cf9753a1abbb6fff23ded22eeb41f0e989", "filename": "tests/compile-fail/stacked_borrows/aliasing_mut4.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut4.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "previous_filename": "tests/compile-fail/validation_aliasing_mut4.rs"}, {"sha": "4857ada7fb2c7f67500a46f8900e2d9e614fda89", "filename": "tests/compile-fail/stacked_borrows/buggy_as_mut_slice.rs", "status": "renamed", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -1,10 +1,5 @@\n-// ignore-test validation_op is disabled\n-\n #![allow(unused_variables)]\n \n-// For some reason, the error location is different when using fullmir\n-// error-pattern: in conflict with lock WriteLock\n-\n mod safe {\n     use std::slice::from_raw_parts_mut;\n \n@@ -17,6 +12,8 @@ mod safe {\n \n fn main() {\n     let v = vec![0,1,2];\n-    let v1_ = safe::as_mut_slice(&v);\n-    let v2_ = safe::as_mut_slice(&v);\n+    let v1 = safe::as_mut_slice(&v);\n+    let v2 = safe::as_mut_slice(&v);\n+    v1[1] = 5; //~ ERROR does not exist on the stack\n+    v1[1] = 6;\n }", "previous_filename": "tests/compile-fail/validation_buggy_as_mut_slice.rs"}, {"sha": "d7f4300f82c05cc8ec49f32d5f74200c4c6aad51", "filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -1,5 +1,3 @@\n-// ignore-test validation_op is disabled\n-\n #![allow(unused_variables)]\n \n mod safe {\n@@ -20,5 +18,7 @@ mod safe {\n \n fn main() {\n     let mut array = [1,2,3,4];\n-    let _x = safe::split_at_mut(&mut array, 0); //~ ERROR: in conflict with lock WriteLock\n+    let (a, b) = safe::split_at_mut(&mut array, 0);\n+    a[1] = 5; //~ ERROR does not exist on the stack\n+    b[1] = 6;\n }", "previous_filename": "tests/compile-fail/validation_buggy_split_at_mut.rs"}, {"sha": "6a7ccc84012c667e0bcadff5bc1635b57ea9e11c", "filename": "tests/compile-fail/stacked_borrows/illegal_write.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -0,0 +1,11 @@\n+fn evil(x: &u32) {\n+    let x : &mut u32 = unsafe { &mut *(x as *const _ as *mut _) };\n+    *x = 42; // mutating shared ref without `UnsafeCell`\n+}\n+\n+fn main() {\n+    let target = 42;\n+    let ref_ = &target;\n+    evil(ref_); // invalidates shared ref\n+    let _x = *ref_; //~ ERROR should be frozen\n+}"}, {"sha": "1d61b1b9889659ea8fadd832045ef3e31f0ccdd1", "filename": "tests/compile-fail/stacked_borrows/illegal_write2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -0,0 +1,10 @@\n+#![allow(unused_variables)]\n+\n+fn main() {\n+    let target = &mut 42;\n+    let target2 = target as *mut _;\n+    drop(&mut *target); // reborrow\n+    // Now make sure our ref is still the only one\n+    unsafe { *target2 = 13; } // invalidate our ref\n+    let _val = *target; //~ ERROR does not exist on the stack\n+}"}, {"sha": "3576aa52b753c2c025cf19f2a9b81f454403d301", "filename": "tests/compile-fail/stacked_borrows/pointer_smuggling.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -0,0 +1,22 @@\n+#![allow(unused_variables)]\n+\n+static mut PTR: *mut u8 = 0 as *mut _;\n+\n+fn fun1(x: &mut u8) {\n+    unsafe {\n+        PTR = x;\n+    }\n+}\n+\n+fn fun2() {\n+    // Now we use a pointer we are not allowed to use\n+    let _x = unsafe { *PTR };\n+}\n+\n+fn main() {\n+    let val = &mut 0; // FIXME: This should also work with a local variable, but currently it does not.\n+    fun1(val);\n+    *val = 2; // this invalidates any raw ptrs `fun1` might have created.\n+    fun2(); // if they now use a raw ptr they break our reference\n+    *val = 3; //~ ERROR does not exist on the stack\n+}"}, {"sha": "584053f59323bc621f746b0a9a2ea3e1e5bf2ec9", "filename": "tests/compile-fail/stacked_borrows/shared_confusion.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -0,0 +1,21 @@\n+#![allow(unused_variables)]\n+use std::cell::RefCell;\n+\n+fn test(r: &mut RefCell<i32>) {\n+    let x = &*r; // not freezing because interior mutability\n+    let mut x_ref = x.borrow_mut();\n+    let x_inner : &mut i32 = &mut *x_ref; // Uniq reference\n+    let x_evil = x_inner as *mut _;\n+    {\n+        let x_inner_shr = &*x_inner; // frozen\n+        let y = &*r; // outer ref, not freezing\n+        let x_inner_shr2 = &*x_inner; // freezing again\n+    }\n+    // Our old raw should be dead by now\n+    unsafe { *x_evil = 0; } // this falls back to some Raw higher up the stack\n+    *x_inner = 12; //~ ERROR does not exist on the stack\n+}\n+\n+fn main() {\n+    test(&mut RefCell::new(0));\n+}"}, {"sha": "cb3e4b3c1a204249571a6010bf3bfee86b104913", "filename": "tests/compile-fail/validation_illegal_write.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/53dc505592723e124c134e4bc4f9aa380bbb5a3e/tests%2Fcompile-fail%2Fvalidation_illegal_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53dc505592723e124c134e4bc4f9aa380bbb5a3e/tests%2Fcompile-fail%2Fvalidation_illegal_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_illegal_write.rs?ref=53dc505592723e124c134e4bc4f9aa380bbb5a3e", "patch": "@@ -1,17 +0,0 @@\n-// ignore-test validation_op is disabled\n-\n-#![allow(unused_variables)]\n-\n-mod safe {\n-    pub(crate) fn safe(x: &u32) {\n-        let x : &mut u32 = unsafe { &mut *(x as *const _ as *mut _) };\n-        *x = 42; //~ ERROR: in conflict with lock ReadLock\n-    }\n-}\n-\n-fn main() {\n-    let target = &mut 42;\n-    let target_ref = &target;\n-    // do a reborrow, but we keep the lock\n-    safe::safe(&*target);\n-}"}, {"sha": "2a0857659622f7ddb7a6736165052f2493d1814f", "filename": "tests/compile-fail/validation_lock_confusion.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/53dc505592723e124c134e4bc4f9aa380bbb5a3e/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53dc505592723e124c134e4bc4f9aa380bbb5a3e/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs?ref=53dc505592723e124c134e4bc4f9aa380bbb5a3e", "patch": "@@ -1,26 +0,0 @@\n-// ignore-test validation_op is disabled\n-\n-// Make sure validation can handle many overlapping shared borrows for different parts of a data structure\n-#![allow(unused_variables)]\n-use std::cell::RefCell;\n-\n-fn evil(x: *mut i32) {\n-    unsafe { *x = 0; } //~ ERROR: in conflict with lock WriteLock\n-}\n-\n-fn test(r: &mut RefCell<i32>) {\n-    let x = &*r; // releasing write lock, first suspension recorded\n-    let mut x_ref = x.borrow_mut();\n-    let x_inner : &mut i32 = &mut *x_ref; // new inner write lock, with same lifetime as outer lock\n-    {\n-        let x_inner_shr = &*x_inner; // releasing inner write lock, recording suspension\n-        let y = &*r; // second suspension for the outer write lock\n-        let x_inner_shr2 = &*x_inner; // 2nd suspension for inner write lock\n-    }\n-    // If the two locks are mixed up, here we should have a write lock, but we do not.\n-    evil(x_inner as *mut _);\n-}\n-\n-fn main() {\n-    test(&mut RefCell::new(0));\n-}"}, {"sha": "14d6242860382d5781ada58d749ffe87a1b8a862", "filename": "tests/compile-fail/validation_pointer_smuggling.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/53dc505592723e124c134e4bc4f9aa380bbb5a3e/tests%2Fcompile-fail%2Fvalidation_pointer_smuggling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53dc505592723e124c134e4bc4f9aa380bbb5a3e/tests%2Fcompile-fail%2Fvalidation_pointer_smuggling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_pointer_smuggling.rs?ref=53dc505592723e124c134e4bc4f9aa380bbb5a3e", "patch": "@@ -1,22 +0,0 @@\n-// ignore-test validation_op is disabled\n-\n-#![allow(unused_variables)]\n-\n-static mut PTR: *mut u8 = 0 as *mut _;\n-\n-fn fun1(x: &mut u8) {\n-    unsafe {\n-        PTR = x;\n-    }\n-}\n-\n-fn fun2() {\n-    // Now we use a pointer we are not allowed to use\n-    let _x = unsafe { *PTR }; //~ ERROR: in conflict with lock WriteLock\n-}\n-\n-fn main() {\n-    let mut val = 0;\n-    fun1(&mut val);\n-    fun2();\n-}"}, {"sha": "9061070ef67ebbed6aeb9dff7bd9b0740794e6ce", "filename": "tests/compile-fail/validation_recover1.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/53dc505592723e124c134e4bc4f9aa380bbb5a3e/tests%2Fcompile-fail%2Fvalidation_recover1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53dc505592723e124c134e4bc4f9aa380bbb5a3e/tests%2Fcompile-fail%2Fvalidation_recover1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_recover1.rs?ref=53dc505592723e124c134e4bc4f9aa380bbb5a3e", "patch": "@@ -1,18 +0,0 @@\n-// ignore-test validation_op is disabled\n-\n-#![allow(unused_variables)]\n-\n-#[repr(u32)]\n-enum Bool { True }\n-\n-mod safe {\n-    pub(crate) fn safe(x: &mut super::Bool) {\n-        let x = x as *mut _ as *mut u32;\n-        unsafe { *x = 44; } // out-of-bounds enum discriminant\n-    }\n-}\n-\n-fn main() {\n-    let mut x = Bool::True;\n-    safe::safe(&mut x); //~ ERROR: invalid enum discriminant\n-}"}, {"sha": "7a4a417ab1db993b640864d6911a92f9015d94c8", "filename": "tests/compile-fail/validation_recover2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53dc505592723e124c134e4bc4f9aa380bbb5a3e/tests%2Fcompile-fail%2Fvalidation_recover2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53dc505592723e124c134e4bc4f9aa380bbb5a3e/tests%2Fcompile-fail%2Fvalidation_recover2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_recover2.rs?ref=53dc505592723e124c134e4bc4f9aa380bbb5a3e", "patch": "@@ -1,16 +0,0 @@\n-// ignore-test validation_op is disabled\n-\n-#![allow(unused_variables)]\n-\n-mod safe {\n-    // This makes a ref that was passed to us via &mut alias with things it should not alias with\n-    pub(crate) fn safe(x: &mut &u32, target: &mut u32) {\n-        unsafe { *x = &mut *(target as *mut _); }\n-    }\n-}\n-\n-fn main() {\n-    let target = &mut 42;\n-    let mut target_alias = &42; // initial dummy value\n-    safe::safe(&mut target_alias, target); //~ ERROR: in conflict with lock ReadLock\n-}"}, {"sha": "5cfc8aaa66b5f2cefa127b5dfe236a00e65b497b", "filename": "tests/compile-fail/validation_recover3.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/53dc505592723e124c134e4bc4f9aa380bbb5a3e/tests%2Fcompile-fail%2Fvalidation_recover3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53dc505592723e124c134e4bc4f9aa380bbb5a3e/tests%2Fcompile-fail%2Fvalidation_recover3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_recover3.rs?ref=53dc505592723e124c134e4bc4f9aa380bbb5a3e", "patch": "@@ -1,17 +0,0 @@\n-// ignore-test validation_op is disabled\n-\n-#![allow(unused_variables)]\n-\n-mod safe {\n-    pub(crate) fn safe(x: *mut u32) {\n-        unsafe { *x = 42; } //~ ERROR: in conflict with lock WriteLock\n-    }\n-}\n-\n-fn main() {\n-    let target = &mut 42u32;\n-    let target2 = target as *mut _;\n-    drop(&mut *target); // reborrow\n-    // Now make sure we still got the lock\n-    safe::safe(target2);\n-}"}, {"sha": "939e93a264e8c03214903485b62c38c206353092", "filename": "tests/compile-fail/validation_undef.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53dc505592723e124c134e4bc4f9aa380bbb5a3e/tests%2Fcompile-fail%2Fvalidation_undef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53dc505592723e124c134e4bc4f9aa380bbb5a3e/tests%2Fcompile-fail%2Fvalidation_undef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_undef.rs?ref=53dc505592723e124c134e4bc4f9aa380bbb5a3e", "patch": "@@ -1,16 +0,0 @@\n-// ignore-test validation_op is disabled\n-\n-#![allow(unused_variables)]\n-// error-pattern: attempted to read undefined bytes\n-\n-mod safe {\n-    use std::mem;\n-\n-    pub(crate) fn make_float() -> f32 {\n-        unsafe { mem::uninitialized() }\n-    }\n-}\n-\n-fn main() {\n-    let _x = safe::make_float();\n-}"}, {"sha": "82f2d10ee4bb5e94439135fc8dcda014c390b904", "filename": "tests/compile-fail/validity/cast_fn_ptr1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fvalidity%2Fcast_fn_ptr1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fvalidity%2Fcast_fn_ptr1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Fcast_fn_ptr1.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "previous_filename": "tests/compile-fail/validation_cast_fn_ptr1.rs"}, {"sha": "2f3b91a53e622a2b7c91db07fc6827b831595686", "filename": "tests/compile-fail/validity/cast_fn_ptr2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fvalidity%2Fcast_fn_ptr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fvalidity%2Fcast_fn_ptr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Fcast_fn_ptr2.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "previous_filename": "tests/compile-fail/validation_cast_fn_ptr2.rs"}, {"sha": "af4ad67a4f0999db940cabdb65cff97b6433b0b3", "filename": "tests/compile-fail/validity/invalid_bool.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fvalidity%2Finvalid_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fvalidity%2Finvalid_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Finvalid_bool.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "previous_filename": "tests/compile-fail/invalid_bool.rs"}, {"sha": "3ff0ed60f664c53e3a247a6c8e03470deb450a06", "filename": "tests/compile-fail/validity/invalid_char.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fvalidity%2Finvalid_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fvalidity%2Finvalid_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Finvalid_char.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "previous_filename": "tests/compile-fail/invalid_char.rs"}, {"sha": "543a797d44f20de0fa0492bbd4fcc35f21fdcdd8", "filename": "tests/compile-fail/validity/invalid_enum_discriminant.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fvalidity%2Finvalid_enum_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fvalidity%2Finvalid_enum_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Finvalid_enum_discriminant.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "previous_filename": "tests/compile-fail/invalid_enum_discriminant.rs"}, {"sha": "0a4c64bb9bb119bfad61901a4bdade67dae4398c", "filename": "tests/compile-fail/validity/transmute_through_ptr.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fvalidity%2Ftransmute_through_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fvalidity%2Ftransmute_through_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Ftransmute_through_ptr.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -0,0 +1,16 @@\n+#![allow(unused_variables)]\n+\n+#[repr(u32)]\n+enum Bool { True }\n+\n+fn evil(x: &mut Bool) {\n+    let x = x as *mut _ as *mut u32;\n+    unsafe { *x = 44; } // out-of-bounds enum discriminant\n+}\n+\n+fn main() {\n+    let mut x = Bool::True;\n+    evil(&mut x);\n+    let _y = x; // reading this ought to be enough to trigger validation\n+    //~^ ERROR invalid enum discriminant 44\n+}"}, {"sha": "58d3926dadafa824296938a5aff109f6c72f3d9e", "filename": "tests/compile-fail/validity/undef.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fvalidity%2Fundef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompile-fail%2Fvalidity%2Fundef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Fundef.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -0,0 +1,12 @@\n+#![allow(unused_variables)]\n+// error-pattern: encountered undefined data in pointer\n+\n+use std::mem;\n+\n+fn make_raw() -> *const f32 {\n+    unsafe { mem::uninitialized() }\n+}\n+\n+fn main() {\n+    let _x = make_raw();\n+}"}, {"sha": "7a7d7e49b2db5a2fc95c8f8b13355719f89be459", "filename": "tests/compiletest.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -63,6 +63,7 @@ fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, need_fullm\n     flags.push(format!(\"--sysroot {}\", sysroot.display()));\n     flags.push(\"-Dwarnings -Dunused\".to_owned()); // overwrite the -Aunused in compiletest-rs\n     config.src_base = PathBuf::from(path.to_string());\n+    flags.push(\"-Zmir-opt-level=0\".to_owned()); // optimization circumvents some stacked borrow checks\n     flags.push(\"-Zmir-emit-validate=1\".to_owned());\n     config.target_rustcflags = Some(flags.join(\" \"));\n     config.target = target.to_owned();"}, {"sha": "0ca63e148fdbb056d7cf155d3307f57a9d6e89b2", "filename": "tests/run-pass-fullmir/env.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Frun-pass-fullmir%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Frun-pass-fullmir%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fenv.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -0,0 +1,9 @@\n+//ignore-windows: env var emulation not implemented on Windows\n+\n+use std::env;\n+\n+fn main() {\n+    assert_eq!(env::var(\"MIRI_TEST\"), Err(env::VarError::NotPresent));\n+    env::set_var(\"MIRI_TEST\", \"the answer\");\n+    assert_eq!(env::var(\"MIRI_TEST\"), Ok(\"the answer\".to_owned()));\n+}"}, {"sha": "4fbbb270957b39d6ee71ee70e18d64078d661c8c", "filename": "tests/run-pass/raw.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Frun-pass%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Frun-pass%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fraw.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -0,0 +1,21 @@\n+fn basic_raw() {\n+    let mut x = 12;\n+    let x = &mut x;\n+\n+    assert_eq!(*x, 12);\n+\n+    let raw = x as *mut i32;\n+    unsafe { *raw = 42; }\n+\n+    assert_eq!(*x, 42);\n+\n+    let raw = x as *mut i32;\n+    unsafe { *raw = 12; }\n+    *x = 23;\n+\n+    assert_eq!(*x, 23);\n+}\n+\n+fn main() {\n+    basic_raw();\n+}"}, {"sha": "93cef1572a3e13d5c88b4e1315ecfe0357c2ec7e", "filename": "tests/run-pass/refcell.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Frun-pass%2Frefcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Frun-pass%2Frefcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frefcell.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -0,0 +1,33 @@\n+use std::cell::RefCell;\n+\n+fn main() {\n+    let c = RefCell::new(42);\n+    {\n+        let s1 = c.borrow();\n+        let _x: i32 = *s1;\n+        let s2 = c.borrow();\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+    }\n+    {\n+        let mut m = c.borrow_mut();\n+        let _z: i32 = *m;\n+        {\n+            let s: &i32 = &*m;\n+            let _x = *s;\n+        }\n+        *m = 23;\n+        let _z: i32 = *m;\n+    }\n+    {\n+        let s1 = c.borrow();\n+        let _x: i32 = *s1;\n+        let s2 = c.borrow();\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+        let _x: i32 = *s1;\n+        let _y: i32 = *s2;\n+    }\n+}"}, {"sha": "7ff967b29f344e591c4afeec638287206a835ec3", "filename": "tests/run-pass/std.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Frun-pass%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d7e1937ee1f9d90c9a8e643785dc2dc06d9658/tests%2Frun-pass%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstd.rs?ref=25d7e1937ee1f9d90c9a8e643785dc2dc06d9658", "patch": "@@ -12,8 +12,9 @@ fn rc_cell() -> Rc<Cell<i32>> {\n fn rc_refcell() -> i32 {\n     let r = Rc::new(RefCell::new(42));\n     *r.borrow_mut() += 10;\n-    let x = *r.borrow();\n-    x\n+    let x = r.borrow();\n+    let y = r.borrow();\n+    (*x + *y)/2\n }\n \n fn arc() -> Arc<i32> {"}]}