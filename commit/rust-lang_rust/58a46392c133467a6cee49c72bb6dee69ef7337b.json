{"sha": "58a46392c133467a6cee49c72bb6dee69ef7337b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4YTQ2MzkyYzEzMzQ2N2E2Y2VlNDljNzJiYjZkZWU2OWVmNzMzN2I=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-06-06T09:01:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-06T09:01:50Z"}, "message": "Merge pull request #185 from RalfJung/pointers\n\nVarious pointer-related things", "tree": {"sha": "7a4bbd956c3b6ebb7d1858002ea22b6597613c96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a4bbd956c3b6ebb7d1858002ea22b6597613c96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58a46392c133467a6cee49c72bb6dee69ef7337b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58a46392c133467a6cee49c72bb6dee69ef7337b", "html_url": "https://github.com/rust-lang/rust/commit/58a46392c133467a6cee49c72bb6dee69ef7337b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58a46392c133467a6cee49c72bb6dee69ef7337b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c16f24b1338fb1b2760f0bffc3206546f5cf3a51", "url": "https://api.github.com/repos/rust-lang/rust/commits/c16f24b1338fb1b2760f0bffc3206546f5cf3a51", "html_url": "https://github.com/rust-lang/rust/commit/c16f24b1338fb1b2760f0bffc3206546f5cf3a51"}, {"sha": "91b93bc701dfb015c375ee485792ce06615362c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/91b93bc701dfb015c375ee485792ce06615362c6", "html_url": "https://github.com/rust-lang/rust/commit/91b93bc701dfb015c375ee485792ce06615362c6"}], "stats": {"total": 424, "additions": 322, "deletions": 102}, "files": [{"sha": "dc7b227b7972ea8d16fa5305ecdea51f4ebf89b9", "filename": "src/error.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -18,11 +18,12 @@ pub enum EvalError<'tcx> {\n     InvalidDiscriminant,\n     PointerOutOfBounds {\n         ptr: Pointer,\n-        size: u64,\n+        access: bool,\n         allocation_size: u64,\n     },\n     ReadPointerAsBytes,\n     InvalidPointerMath,\n+    OverflowingPointerMath,\n     ReadUndefBytes,\n     DeadLocal,\n     InvalidBoolOp(mir::BinOp),\n@@ -82,6 +83,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"a raw memory access tried to access part of a pointer value as raw bytes\",\n             EvalError::InvalidPointerMath =>\n                 \"attempted to do math or a comparison on pointers into different allocations\",\n+            EvalError::OverflowingPointerMath =>\n+                \"attempted to do overflowing math on a pointer\",\n             EvalError::ReadUndefBytes =>\n                 \"attempted to read undefined bytes\",\n             EvalError::DeadLocal =>\n@@ -147,9 +150,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n impl<'tcx> fmt::Display for EvalError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            EvalError::PointerOutOfBounds { ptr, size, allocation_size } => {\n-                write!(f, \"memory access of {}..{} outside bounds of allocation {} which has size {}\",\n-                       ptr.offset, ptr.offset + size, ptr.alloc_id, allocation_size)\n+            EvalError::PointerOutOfBounds { ptr, access, allocation_size } => {\n+                write!(f, \"{} at offset {}, outside bounds of allocation {} which has size {}\",\n+                       if access { \"memory access\" } else { \"pointer computed\" },\n+                       ptr.offset, ptr.alloc_id, allocation_size)\n             },\n             EvalError::NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n             EvalError::FunctionPointerTyMismatch(sig, got) =>"}, {"sha": "d45c419c78a9a1d35582fb951b9df4576eb5682b", "filename": "src/eval_context.rs", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -391,7 +391,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // FIXME(solson)\n         let dest_ptr = self.force_allocation(dest)?.to_ptr();\n \n-        let discr_dest = dest_ptr.offset(discr_offset);\n+        let discr_dest = dest_ptr.offset(discr_offset, self.memory.layout)?;\n         self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n \n         let dest = Lvalue::Ptr {\n@@ -550,7 +550,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 // FIXME(solson)\n                                 let dest = self.force_allocation(dest)?.to_ptr();\n \n-                                let dest = dest.offset(offset.bytes());\n+                                let dest = dest.offset(offset.bytes(), self.memory.layout)?;\n                                 let dest_size = self.type_size(ty)?\n                                     .expect(\"bad StructWrappedNullablePointer discrfield\");\n                                 self.memory.write_int(dest, 0, dest_size)?;\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let dest = self.force_allocation(dest)?.to_ptr();\n \n                 for i in 0..length {\n-                    let elem_dest = dest.offset(i * elem_size);\n+                    let elem_dest = dest.offset(i * elem_size, self.memory.layout)?;\n                     self.write_value_to_ptr(value, elem_dest, elem_ty)?;\n                 }\n             }\n@@ -662,7 +662,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let src = self.eval_operand(operand)?;\n                         let src_ty = self.operand_ty(operand);\n                         if self.type_is_fat_ptr(src_ty) {\n-                            trace!(\"misc cast: {:?}\", src);\n                             match (src, self.type_is_fat_ptr(dest_ty)) {\n                                 (Value::ByRef(_), _) |\n                                 (Value::ByValPair(..), true) => {\n@@ -674,9 +673,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 (Value::ByVal(_), _) => bug!(\"expected fat ptr\"),\n                             }\n                         } else {\n-                            let src_val = self.value_to_primval(src, src_ty)?;\n-                            let dest_val = self.cast_primval(src_val, src_ty, dest_ty)?;\n-                            self.write_value(Value::ByVal(dest_val), dest, dest_ty)?;\n+                            // First, try casting\n+                            let dest_val = self.value_to_primval(src, src_ty).and_then(\n+                                |src_val| { self.cast_primval(src_val, src_ty, dest_ty) })\n+                                // Alternatively, if the sizes are equal, try just reading at the target type\n+                                .or_else(|err| {\n+                                    let size = self.type_size(src_ty)?;\n+                                    if size.is_some() && size == self.type_size(dest_ty)? {\n+                                        self.value_to_primval(src, dest_ty)\n+                                    } else {\n+                                        Err(err)\n+                                    }\n+                                });\n+                            self.write_value(Value::ByVal(dest_val?), dest, dest_ty)?;\n                         }\n                     }\n \n@@ -841,11 +850,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n+    pub(super) fn wrapping_pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n+        // FIXME: assuming here that type size is < i64::max_value()\n+        let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n+        let offset = offset.overflowing_mul(pointee_size).0;\n+        Ok(ptr.wrapping_signed_offset(offset, self.memory.layout))\n+    }\n+\n     pub(super) fn pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n+        if offset == 0 {\n+            // rustc relies on Offset-by-0 to be well-defined even for \"bad\" pointers like Unique::empty().\n+            return Ok(ptr);\n+        }\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n-        // FIXME: Check overflow, out-of-bounds\n-        Ok(ptr.signed_offset(offset * pointee_size))\n+        return if let Some(offset) = offset.checked_mul(pointee_size) {\n+            let ptr = ptr.signed_offset(offset, self.memory.layout)?;\n+            self.memory.check_bounds(ptr, false)?;\n+            Ok(ptr)\n+        } else {\n+            Err(EvalError::OverflowingPointerMath)\n+        }\n     }\n \n     pub(super) fn eval_operand_to_primval(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, PrimVal> {\n@@ -1099,8 +1124,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let field_1_ty = self.get_field_ty(ty, 1)?;\n         let field_0_size = self.type_size(field_0_ty)?.expect(\"pair element type must be sized\");\n         let field_1_size = self.type_size(field_1_ty)?.expect(\"pair element type must be sized\");\n-        self.memory.write_primval(ptr.offset(field_0), a, field_0_size)?;\n-        self.memory.write_primval(ptr.offset(field_1), b, field_1_size)?;\n+        self.memory.write_primval(ptr.offset(field_0, self.memory.layout)?, a, field_0_size)?;\n+        self.memory.write_primval(ptr.offset(field_1, self.memory.layout)?, b, field_1_size)?;\n         Ok(())\n     }\n \n@@ -1217,7 +1242,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Ok(Value::ByVal(PrimVal::Ptr(p)))\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n-            let extra = ptr.offset(self.memory.pointer_size());\n+            let extra = ptr.offset(self.memory.pointer_size(), self.memory.layout)?;\n             let extra = match self.tcx.struct_tail(pointee_ty).sty {\n                 ty::TyDynamic(..) => PrimVal::Ptr(self.memory.read_ptr(extra)?),\n                 ty::TySlice(..) |\n@@ -1402,8 +1427,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                     let src_field_offset = self.get_field_offset(src_ty, i)?.bytes();\n                     let dst_field_offset = self.get_field_offset(dest_ty, i)?.bytes();\n-                    let src_f_ptr = src_ptr.offset(src_field_offset);\n-                    let dst_f_ptr = dest.offset(dst_field_offset);\n+                    let src_f_ptr = src_ptr.offset(src_field_offset, self.memory.layout)?;\n+                    let dst_f_ptr = dest.offset(dst_field_offset, self.memory.layout)?;\n                     if src_fty == dst_fty {\n                         self.copy(src_f_ptr, dst_f_ptr, src_fty)?;\n                     } else {\n@@ -1438,6 +1463,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     panic!(\"Failed to access local: {:?}\", err);\n                 }\n                 Ok(Value::ByRef(ptr)) => {\n+                    write!(msg, \" by ref:\").unwrap();\n                     allocs.push(ptr.alloc_id);\n                 }\n                 Ok(Value::ByVal(val)) => {"}, {"sha": "c5811774e941e653797393b84d2d3b59f5bc620e", "filename": "src/lvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -270,7 +270,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             _ => offset.bytes(),\n         };\n \n-        let ptr = base_ptr.offset(offset);\n+        let ptr = base_ptr.offset(offset, self.memory.layout)?;\n \n         let field_ty = self.monomorphize(field_ty, self.substs());\n \n@@ -363,7 +363,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let usize = self.tcx.types.usize;\n                 let n = self.value_to_primval(n_ptr, usize)?.to_u64()?;\n                 assert!(n < len, \"Tried to access element {} of array/slice with length {}\", n, len);\n-                let ptr = base_ptr.offset(n * elem_size);\n+                let ptr = base_ptr.offset(n * elem_size, self.memory.layout)?;\n                 (ptr, LvalueExtra::None)\n             }\n \n@@ -384,7 +384,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     u64::from(offset)\n                 };\n \n-                let ptr = base_ptr.offset(index * elem_size);\n+                let ptr = base_ptr.offset(index * elem_size, self.memory.layout)?;\n                 (ptr, LvalueExtra::None)\n             }\n \n@@ -398,7 +398,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 assert!(u64::from(from) <= n - u64::from(to));\n-                let ptr = base_ptr.offset(u64::from(from) * elem_size);\n+                let ptr = base_ptr.offset(u64::from(from) * elem_size, self.memory.layout)?;\n                 let extra = LvalueExtra::Length(n - u64::from(to) - u64::from(from));\n                 (ptr, extra)\n             }"}, {"sha": "18f757a6bd6c0f50ed6cecaccc623370f7fb4d65", "filename": "src/memory.rs", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -60,20 +60,36 @@ impl Pointer {\n         Pointer { alloc_id, offset }\n     }\n \n-    pub fn signed_offset(self, i: i64) -> Self {\n+    pub fn wrapping_signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> Self {\n+        Pointer::new(self.alloc_id, (self.offset.wrapping_add(i as u64) as u128 % (1u128 << layout.pointer_size.bits())) as u64)\n+    }\n+\n+    pub fn signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n         // FIXME: is it possible to over/underflow here?\n         if i < 0 {\n             // trickery to ensure that i64::min_value() works fine\n             // this formula only works for true negative values, it panics for zero!\n             let n = u64::max_value() - (i as u64) + 1;\n-            Pointer::new(self.alloc_id, self.offset - n)\n+            if let Some(res) = self.offset.checked_sub(n) {\n+                Ok(Pointer::new(self.alloc_id, res))\n+            } else {\n+                Err(EvalError::OverflowingPointerMath)\n+            }\n         } else {\n-            self.offset(i as u64)\n+            self.offset(i as u64, layout)\n         }\n     }\n \n-    pub fn offset(self, i: u64) -> Self {\n-        Pointer::new(self.alloc_id, self.offset + i)\n+    pub fn offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+        if let Some(res) = self.offset.checked_add(i) {\n+            if res as u128 >= (1u128 << layout.pointer_size.bits()) {\n+                Err(EvalError::OverflowingPointerMath)\n+            } else {\n+                Ok(Pointer::new(self.alloc_id, res))\n+            }\n+        } else {\n+            Err(EvalError::OverflowingPointerMath)\n+        }\n     }\n \n     pub fn points_to_zst(&self) -> bool {\n@@ -108,7 +124,7 @@ pub type TlsKey = usize;\n \n #[derive(Copy, Clone, Debug)]\n pub struct TlsEntry<'tcx> {\n-    data: Pointer, // will eventually become a map from thread IDs to pointers\n+    data: Pointer, // Will eventually become a map from thread IDs to pointers, if we ever support more than one thread.\n     dtor: Option<ty::Instance<'tcx>>,\n }\n \n@@ -161,8 +177,8 @@ pub struct Memory<'a, 'tcx> {\n     /// A cache for basic byte allocations keyed by their contents. This is used to deduplicate\n     /// allocations for string and bytestring literals.\n     literal_alloc_cache: HashMap<Vec<u8>, AllocId>,\n-    \n-    /// pthreads-style Thread-local storage.  We only have one thread, so this is just a map from TLS keys (indices into the vector) to the pointer stored there.\n+\n+    /// pthreads-style thread-local storage.\n     thread_local: HashMap<TlsKey, TlsEntry<'tcx>>,\n \n     /// The Key to use for the next thread-local allocation.\n@@ -271,7 +287,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             alloc.undef_mask.grow(amount, false);\n         } else if size > new_size {\n             self.memory_usage -= size - new_size;\n-            self.clear_relocations(ptr.offset(new_size), size - new_size)?;\n+            self.clear_relocations(ptr.offset(new_size, self.layout)?, size - new_size)?;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n             // `as usize` is fine here, since it is smaller than `size`, which came from a usize\n             alloc.bytes.truncate(new_size as usize);\n@@ -354,6 +370,15 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n+    pub(crate) fn check_bounds(&self, ptr: Pointer, access: bool) -> EvalResult<'tcx> {\n+        let alloc = self.get(ptr.alloc_id)?;\n+        let allocation_size = alloc.bytes.len() as u64;\n+        if ptr.offset > allocation_size {\n+            return Err(EvalError::PointerOutOfBounds { ptr, access, allocation_size });\n+        }\n+        Ok(())\n+    }\n+\n     pub(crate) fn mark_packed(&mut self, ptr: Pointer, len: u64) {\n         self.packed.insert(Entry {\n             alloc_id: ptr.alloc_id,\n@@ -574,11 +599,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Ok(&[]);\n         }\n         self.check_align(ptr, align, size)?;\n+        self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get(ptr.alloc_id)?;\n-        let allocation_size = alloc.bytes.len() as u64;\n-        if ptr.offset + size > allocation_size {\n-            return Err(EvalError::PointerOutOfBounds { ptr, size, allocation_size });\n-        }\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n         assert_eq!(size as usize as u64, size);\n         let offset = ptr.offset as usize;\n@@ -590,11 +612,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Ok(&mut []);\n         }\n         self.check_align(ptr, align, size)?;\n+        self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get_mut(ptr.alloc_id)?;\n-        let allocation_size = alloc.bytes.len() as u64;\n-        if ptr.offset + size > allocation_size {\n-            return Err(EvalError::PointerOutOfBounds { ptr, size, allocation_size });\n-        }\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n         assert_eq!(size as usize as u64, size);\n         let offset = ptr.offset as usize;\n@@ -746,7 +765,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn write_ptr(&mut self, dest: Pointer, ptr: Pointer) -> EvalResult<'tcx> {\n         self.write_usize(dest, ptr.offset as u64)?;\n-        self.get_mut(dest.alloc_id)?.relocations.insert(dest.offset, ptr.alloc_id);\n+        if ptr.alloc_id != NEVER_ALLOC_ID {\n+            self.get_mut(dest.alloc_id)?.relocations.insert(dest.offset, ptr.alloc_id);\n+        }\n         Ok(())\n     }\n \n@@ -913,7 +934,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     fn check_relocation_edges(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx> {\n         let overlapping_start = self.relocations(ptr, 0)?.count();\n-        let overlapping_end = self.relocations(ptr.offset(size), 0)?.count();\n+        let overlapping_end = self.relocations(ptr.offset(size, self.layout)?, 0)?.count();\n         if overlapping_start + overlapping_end != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n         }"}, {"sha": "3fe3b63407910eb2b531aaeaed60c4d6229685b4", "filename": "src/operator.rs", "status": "modified", "additions": 63, "deletions": 39, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -155,57 +155,48 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n         let (left, right) = (normalize(left), normalize(right));\n \n+        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n+        let right_kind = self.ty_to_primval_kind(right_ty)?;\n+\n         // Offset is handled early, before we dispatch to unrelated_ptr_ops.  We have to also catch the case where both arguments *are* convertible to integers.\n         if bin_op == Offset {\n-            let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n-            let ptr = self.pointer_offset(left.to_ptr()?, pointee_ty, right.to_bytes()? as i64)?;\n-            return Ok((PrimVal::Ptr(ptr), false));\n+            if left_kind == Ptr && right_kind == PrimValKind::from_uint_size(self.memory.pointer_size()) {\n+                let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n+                let ptr = self.pointer_offset(left.to_ptr()?, pointee_ty, right.to_bytes()? as i64)?;\n+                return Ok((PrimVal::Ptr(ptr), false));\n+            } else {\n+                bug!(\"Offset used with wrong type\");\n+            }\n         }\n \n         let (l, r) = match (left, right) {\n             (PrimVal::Bytes(left_bytes), PrimVal::Bytes(right_bytes)) => (left_bytes, right_bytes),\n \n+            // One argument is a pointer value -- this is handled separately\n             (PrimVal::Ptr(left_ptr), PrimVal::Ptr(right_ptr)) => {\n-                if left_ptr.alloc_id == right_ptr.alloc_id {\n-                    // If the pointers are into the same allocation, fall through to the more general\n-                    // match later, which will do comparisons on the pointer offsets.\n-                    (left_ptr.offset as u128, right_ptr.offset as u128)\n-                } else {\n-                    return Ok((unrelated_ptr_ops(bin_op, left_ptr, right_ptr)?, false));\n-                }\n+                return self.ptr_ops(bin_op, left_ptr, left_kind, right_ptr, right_kind);\n+            }\n+            (PrimVal::Ptr(ptr), PrimVal::Bytes(bytes)) => {\n+                return self.ptr_ops(bin_op, ptr, left_kind, Pointer::from_int(bytes as u64), right_kind);\n             }\n-\n-            (PrimVal::Ptr(ptr), PrimVal::Bytes(bytes)) |\n             (PrimVal::Bytes(bytes), PrimVal::Ptr(ptr)) => {\n-                return Ok((unrelated_ptr_ops(bin_op, ptr, Pointer::from_int(bytes as u64))?, false));\n+                return self.ptr_ops(bin_op, Pointer::from_int(bytes as u64), left_kind, ptr, right_kind);\n             }\n \n             (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n         };\n \n-        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n-        let right_kind = self.ty_to_primval_kind(right_ty)?;\n-\n         // These ops can have an RHS with a different numeric type.\n-        if bin_op == Shl || bin_op == Shr {\n+        if right_kind.is_int() && (bin_op == Shl || bin_op == Shr) {\n             return match bin_op {\n                 Shl => int_shift!(left_kind, overflowing_shl, l, r as u32),\n                 Shr => int_shift!(left_kind, overflowing_shr, l, r as u32),\n                 _ => bug!(\"it has already been checked that this is a shift op\"),\n             };\n         }\n-        if bin_op == Offset {\n-            // We permit offset-by-0 in any case.  Drop glue actually does this, and it's probably (TM) fine for LLVM.\n-            if left_kind == PrimValKind::Ptr && right_kind.is_int() && r == 0 {\n-                return Ok((PrimVal::Bytes(l), false));\n-            } else {\n-                let msg = format!(\"unimplemented Offset: {:?}, {:?}\", left, right);\n-                return Err(EvalError::Unimplemented(msg));\n-            }\n-        }\n \n         if left_kind != right_kind {\n-            let msg = format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", left, right, bin_op);\n+            let msg = format!(\"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n             return Err(EvalError::Unimplemented(msg));\n         }\n \n@@ -258,25 +249,58 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             (Rem, k) if k.is_int() => return int_arithmetic!(k, overflowing_rem, l, r),\n \n             _ => {\n-                let msg = format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", left, right, bin_op);\n+                let msg = format!(\"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n                 return Err(EvalError::Unimplemented(msg));\n             }\n         };\n \n         Ok((val, false))\n     }\n-}\n \n-fn unrelated_ptr_ops<'tcx>(bin_op: mir::BinOp, left: Pointer, right: Pointer) -> EvalResult<'tcx, PrimVal> {\n-    use rustc::mir::BinOp::*;\n-    match bin_op {\n-        Eq => Ok(PrimVal::from_bool(false)),\n-        Ne => Ok(PrimVal::from_bool(true)),\n-        Lt | Le | Gt | Ge => Err(EvalError::InvalidPointerMath),\n-        _ if left.to_int().is_ok() ^ right.to_int().is_ok() => {\n-            Err(EvalError::ReadPointerAsBytes)\n-        },\n-        _ => bug!(),\n+    fn ptr_ops(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: Pointer,\n+        left_kind: PrimValKind,\n+        right: Pointer,\n+        right_kind: PrimValKind,\n+    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n+        use rustc::mir::BinOp::*;\n+        use value::PrimValKind::*;\n+\n+        if left_kind != right_kind || !(left_kind.is_ptr() || left_kind == PrimValKind::from_uint_size(self.memory.pointer_size())) {\n+            let msg = format!(\"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n+            return Err(EvalError::Unimplemented(msg));\n+        }\n+\n+        let val = match bin_op {\n+            Eq => PrimVal::from_bool(left == right),\n+            Ne => PrimVal::from_bool(left != right),\n+            Lt | Le | Gt | Ge => {\n+                if left.alloc_id == right.alloc_id {\n+                    PrimVal::from_bool(match bin_op {\n+                        Lt => left.offset < right.offset,\n+                        Le => left.offset <= right.offset,\n+                        Gt => left.offset > right.offset,\n+                        Ge => left.offset >= right.offset,\n+                        _ => bug!(\"We already established it has to be a comparison operator.\"),\n+                    })\n+                } else {\n+                    return Err(EvalError::InvalidPointerMath);\n+                }\n+            }\n+            Sub => {\n+                if left.alloc_id == right.alloc_id {\n+                    return int_arithmetic!(left_kind, overflowing_sub, left.offset, right.offset);\n+                } else {\n+                    return Err(EvalError::InvalidPointerMath);\n+                }\n+            }\n+            _ => {\n+                return Err(EvalError::ReadPointerAsBytes);\n+            }\n+        };\n+        Ok((val, false))\n     }\n }\n "}, {"sha": "31886e9cc6d915ee8bc8dcd2d088f54dbc4e7dba", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -43,10 +43,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n \n             \"arith_offset\" => {\n+                // FIXME: Switch to non-checked, wrapped version of pointer_offset\n+                let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n-                let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()?;\n-                let new_ptr = ptr.signed_offset(offset as i64);\n-                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n+                let result_ptr = self.wrapping_pointer_offset(ptr, substs.type_at(0), offset)?;\n+                self.write_primval(dest, PrimVal::Ptr(result_ptr), dest_ty)?;\n             }\n \n             \"assume\" => {\n@@ -414,8 +415,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = self.type_size(ty)?.expect(\"write_bytes() type must be sized\");\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n-                self.memory.check_align(ptr, ty_align, size * count)?;\n-                self.memory.write_repeat(ptr, val_byte, size * count)?;\n+                if count > 0 {\n+                    self.memory.check_align(ptr, ty_align, size * count)?;\n+                    self.memory.write_repeat(ptr, val_byte, size * count)?;\n+                }\n             }\n \n             name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),"}, {"sha": "afc3bf1c37feb421257a5d5835f4292441b2042c", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 match arg_val {\n                                     Value::ByRef(ptr) => {\n                                         for ((offset, ty), arg_local) in offsets.zip(fields).zip(arg_locals) {\n-                                            let arg = Value::ByRef(ptr.offset(offset));\n+                                            let arg = Value::ByRef(ptr.offset(offset, self.memory.layout)?);\n                                             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                                             trace!(\"writing arg {:?} to {:?} (type: {})\", arg, dest, ty);\n                                             self.write_value(arg, dest, ty)?;\n@@ -387,7 +387,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n                 let (_, vtable) = self.eval_operand(&arg_operands[0])?.expect_ptr_vtable_pair(&self.memory)?;\n-                let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3)))?;\n+                let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3), self.memory.layout)?)?;\n                 let instance = self.memory.get_fn(fn_ptr.alloc_id)?;\n                 let mut arg_operands = arg_operands.to_vec();\n                 let ty = self.operand_ty(&arg_operands[0]);\n@@ -473,7 +473,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n                 let (offset, ty) = self.nonnull_offset_and_ty(adt_ty, nndiscr, discrfield)?;\n-                let nonnull = adt_ptr.offset(offset.bytes());\n+                let nonnull = adt_ptr.offset(offset.bytes(), self.memory.layout)?;\n                 trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                 // only the pointer part of a fat pointer is used for this space optimization\n                 let discr_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n@@ -654,7 +654,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n-                    let new_ptr = ptr.offset(num - idx as u64 - 1);\n+                    let new_ptr = ptr.offset(num - idx as u64 - 1, self.memory.layout)?;\n                     self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n                 } else {\n                     self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n@@ -666,7 +666,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n-                    let new_ptr = ptr.offset(idx as u64);\n+                    let new_ptr = ptr.offset(idx as u64, self.memory.layout)?;\n                     self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n                 } else {\n                     self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n@@ -742,6 +742,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n                     return Err(EvalError::OutOfTls);\n                 }\n+                // TODO: Does this need checking for alignment?\n                 self.memory.write_uint(key_ptr, key, key_size.bytes())?;\n \n                 // Return success (0)"}, {"sha": "322ebc1981b488f9409395705a536e2fae8f8da0", "filename": "src/traits.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -56,14 +56,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let drop = self.memory.create_fn_alloc(drop);\n         self.memory.write_ptr(vtable, drop)?;\n \n-        self.memory.write_usize(vtable.offset(ptr_size), size)?;\n-        self.memory.write_usize(vtable.offset(ptr_size * 2), align)?;\n+        self.memory.write_usize(vtable.offset(ptr_size, self.memory.layout)?, size)?;\n+        self.memory.write_usize(vtable.offset(ptr_size * 2, self.memory.layout)?, align)?;\n \n         for (i, method) in ::rustc::traits::get_vtable_methods(self.tcx, trait_ref).enumerate() {\n             if let Some((def_id, substs)) = method {\n                 let instance = ::eval_context::resolve(self.tcx, def_id, substs);\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n-                self.memory.write_ptr(vtable.offset(ptr_size * (3 + i as u64)), fn_ptr)?;\n+                self.memory.write_ptr(vtable.offset(ptr_size * (3 + i as u64), self.memory.layout)?, fn_ptr)?;\n             }\n         }\n \n@@ -88,8 +88,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub fn read_size_and_align_from_vtable(&self, vtable: Pointer) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n-        let size = self.memory.read_usize(vtable.offset(pointer_size))?;\n-        let align = self.memory.read_usize(vtable.offset(pointer_size * 2))?;\n+        let size = self.memory.read_usize(vtable.offset(pointer_size, self.memory.layout)?)?;\n+        let align = self.memory.read_usize(vtable.offset(pointer_size * 2, self.memory.layout)?)?;\n         Ok((size, align))\n     }\n "}, {"sha": "387002eee7bc2d243b387b25ef923dde9c925c27", "filename": "src/value.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'tcx: 'a> Value {\n         match *self {\n             ByRef(ref_ptr) => {\n                 let ptr = mem.read_ptr(ref_ptr)?;\n-                let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size()))?;\n+                let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size(), mem.layout)?)?;\n                 Ok((ptr, vtable))\n             }\n \n@@ -105,7 +105,7 @@ impl<'a, 'tcx: 'a> Value {\n         match *self {\n             ByRef(ref_ptr) => {\n                 let ptr = mem.read_ptr(ref_ptr)?;\n-                let len = mem.read_usize(ref_ptr.offset(mem.pointer_size()))?;\n+                let len = mem.read_usize(ref_ptr.offset(mem.pointer_size(), mem.layout)?)?;\n                 Ok((ptr, len))\n             },\n             ByValPair(ptr, val) => {\n@@ -243,4 +243,12 @@ impl PrimValKind {\n             _ => bug!(\"can't make int with size {}\", size),\n         }\n     }\n+\n+    pub fn is_ptr(self) -> bool {\n+        use self::PrimValKind::*;\n+        match self {\n+            Ptr | FnPtr => true,\n+            _ => false,\n+        }\n+    }\n }"}, {"sha": "8dce7e578626403647b5764d26387798a15420b4", "filename": "tests/compile-fail/out_of_bounds_ptr_1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fout_of_bounds_ptr_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fout_of_bounds_ptr_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fout_of_bounds_ptr_1.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -0,0 +1,8 @@\n+// error-pattern: pointer computed at offset 5, outside bounds of allocation\n+fn main() {\n+    let v = [0i8; 4];\n+    let x = &v as *const i8;\n+    // The error is inside another function, so we cannot match it by line\n+    let x = unsafe { x.offset(5) };\n+    panic!(\"this should never print: {:?}\", x);\n+}"}, {"sha": "0bb670fd022f72d37f3184fb3d20af3b5cab2ddf", "filename": "tests/compile-fail/out_of_bounds_ptr_2.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fout_of_bounds_ptr_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fout_of_bounds_ptr_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fout_of_bounds_ptr_2.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -0,0 +1,7 @@\n+// error-pattern: overflowing math on a pointer\n+fn main() {\n+    let v = [0i8; 4];\n+    let x = &v as *const i8;\n+    let x = unsafe { x.offset(-1) };\n+    panic!(\"this should never print: {:?}\", x);\n+}"}, {"sha": "8c56b14bdf221f055cbfe2f82550b1788cfeb90c", "filename": "tests/compile-fail/out_of_bounds_read.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fout_of_bounds_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fout_of_bounds_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fout_of_bounds_read.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let v: Vec<u8> = vec![1, 2];\n-    let x = unsafe { *v.get_unchecked(5) }; //~ ERROR: which has size 2\n+    let x = unsafe { *v.as_ptr().wrapping_offset(5) }; //~ ERROR: which has size 2\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "d29b22ffb2a6b633c29bc18115a675227b361c7f", "filename": "tests/compile-fail/out_of_bounds_read2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let v: Vec<u8> = vec![1, 2];\n-    let x = unsafe { *v.get_unchecked(5) }; //~ ERROR: memory access of 5..6 outside bounds of allocation\n+    let x = unsafe { *v.as_ptr().wrapping_offset(5) }; //~ ERROR: memory access at offset 6, outside bounds of allocation\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "3a889be741efdf159f05fc87134203ef7e5b92e1", "filename": "tests/compile-fail/overflowing-lsh-neg.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Foverflowing-lsh-neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Foverflowing-lsh-neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverflowing-lsh-neg.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(exceeding_bitshifts)]\n+#![allow(const_err)]\n+\n+fn main() {\n+    let _n = 2i64 << -1; //~ Overflow(Shl)\n+}"}, {"sha": "285a0684a93eab6a1aa656670bab0269e458c66d", "filename": "tests/compile-fail/pointer_byte_read_1.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let x = 13;\n+    let y = &x;\n+    let z = &y as *const &i32 as *const usize;\n+    let ptr_bytes = unsafe { *z }; // the actual deref is fine, because we read the entire pointer at once\n+    let _ = ptr_bytes == 15; //~ ERROR: tried to access part of a pointer value as raw bytes\n+}"}, {"sha": "b0f619332e00c933cbe1502b1770d18f34222709", "filename": "tests/compile-fail/pointer_byte_read_2.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fpointer_byte_read_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fpointer_byte_read_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointer_byte_read_2.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let x = 13;\n+    let y = &x;\n+    let z = &y as *const &i32 as *const u8;\n+    // the deref fails, because we are reading only a part of the pointer\n+    let _ = unsafe { *z }; //~ ERROR: tried to access part of a pointer value as raw bytes\n+}"}, {"sha": "78fd8e912b5e73524f20475050a86478b0c864c1", "filename": "tests/compile-fail/ptr_bitops.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fptr_bitops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fptr_bitops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_bitops.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let bytes = [0i8, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let one = bytes.as_ptr().wrapping_offset(1);\n+    let three = bytes.as_ptr().wrapping_offset(3);\n+    let res = (one as usize) | (three as usize); //~ ERROR a raw memory access tried to access part of a pointer value as raw bytes\n+    println!(\"{}\", res);\n+}"}, {"sha": "ebd972a8717527f6348ed02c5028978a473eddc7", "filename": "tests/compile-fail/ptr_offset_overflow.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fptr_offset_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Fcompile-fail%2Fptr_offset_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_offset_overflow.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -0,0 +1,6 @@\n+//error-pattern: overflowing math on a pointer\n+fn main() {\n+    let v = [1i8, 2];\n+    let x = &v[1] as *const i8;\n+    let _ = unsafe { x.offset(isize::min_value()) };\n+}"}, {"sha": "dd46c638a2afe747294f99a1e325aabba1bd40cf", "filename": "tests/run-pass/aux_test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Faux_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Faux_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Faux_test.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -1,4 +1,5 @@\n // aux-build:dep.rs\n+// This ignores the test against rustc, but runs it against miri:\n // ignore-cross-compile\n \n extern crate dep;"}, {"sha": "25e7bc329db54c793e6c4c46248f2d26a4972442", "filename": "tests/run-pass/drop_empty_slice.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fdrop_empty_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fdrop_empty_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdrop_empty_slice.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -0,0 +1,9 @@\n+#![feature(box_syntax)]\n+// This disables the test completely:\n+// ignore-stage1\n+\n+fn main() {\n+    // With the nested Vec, this is calling Offset(Unique::empty(), 0).\n+    let args : Vec<Vec<i32>> = Vec::new();\n+    let local = box args;\n+}"}, {"sha": "775dee252f6258ed409dbc046dde57b2a3055997", "filename": "tests/run-pass/hashmap.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fhashmap.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -0,0 +1,19 @@\n+use std::collections::{self, HashMap};\n+use std::hash::BuildHasherDefault;\n+\n+// This disables the test completely:\n+// ignore-stage1\n+// TODO: The tests actually passes against rustc and miri with MIR-libstd, but right now, we cannot express that in the test flags\n+\n+fn main() {\n+    let map : HashMap<String, i32, BuildHasherDefault<collections::hash_map::DefaultHasher>> = Default::default();\n+    assert_eq!(map.values().fold(0, |x, y| x+y), 0);\n+\n+    // TODO: This performs bit operations on the least significant bit of a pointer\n+//     for i in 0..33 {\n+//         map.insert(format!(\"key_{}\", i), i);\n+//         assert_eq!(map.values().fold(0, |x, y| x+y), i*(i+1)/2);\n+//     }\n+\n+    // TODO: Test Entry API\n+}"}, {"sha": "fd7229c3455e4da6a491d289b056fad62c91282a", "filename": "tests/run-pass/iter_slice.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fiter_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fiter_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fiter_slice.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -0,0 +1,12 @@\n+fn main() {\n+    for _ in Vec::<u32>::new().iter() { // this iterates over a Unique::empty()\n+        panic!(\"We should never be here.\");\n+    }\n+\n+    // Iterate over a ZST (uses arith_offset internally)\n+    let mut count = 0;\n+    for _ in &[(), (), ()] {\n+        count += 1;\n+    }\n+    assert_eq!(count, 3);\n+}"}, {"sha": "7912da9fd437ce45e8479b74bc13dedf78773af9", "filename": "tests/run-pass/ptr_arith_offset.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fptr_arith_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fptr_arith_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_arith_offset.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let v = [1i16, 2];\n+    let x = &v as *const i16;\n+    let x = x.wrapping_offset(1);\n+    assert_eq!(unsafe { *x }, 2);\n+}"}, {"sha": "3383c3b80148209239c12898ad861fd58236b4c3", "filename": "tests/run-pass/ptr_arith_offset_overflow.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    let v = [1i16, 2];\n+    let x = &v[1] as *const i16;\n+    // Adding 2*isize::max and then 1 is like substracting 1\n+    let x = x.wrapping_offset(isize::max_value());\n+    let x = x.wrapping_offset(isize::max_value());\n+    let x = x.wrapping_offset(1);\n+    assert_eq!(unsafe { *x }, 1);\n+}"}, {"sha": "e245cb22475d504fb4adcb907af54e036ddf042a", "filename": "tests/run-pass/ptr_int_casts.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fptr_int_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fptr_int_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_int_casts.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -0,0 +1,15 @@\n+fn eq_ref<T>(x: &T, y: &T) -> bool {\n+    x as *const _ == y as *const _\n+}\n+\n+fn main() {\n+    // int-ptr-int\n+    assert_eq!(1 as *const i32 as usize, 1);\n+\n+    {   // ptr-int-ptr\n+        let x = 13;\n+        let y = &x as *const _ as usize;\n+        let y = y as *const _;\n+        assert!(eq_ref(&x, unsafe { &*y }));\n+    }\n+}"}, {"sha": "6add5212db9f6eef59c54f8fca1c20bb63863e18", "filename": "tests/run-pass/ptr_offset.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_offset.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let v = [1i16, 2];\n+    let x = &v as *const i16;\n+    let x = unsafe { x.offset(1) };\n+    assert_eq!(unsafe { *x }, 2);\n+}"}, {"sha": "4fe40a9694d4870876cb84b1927a67d3df9b0904", "filename": "tests/run-pass/u128.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a46392c133467a6cee49c72bb6dee69ef7337b/tests%2Frun-pass%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fu128.rs?ref=58a46392c133467a6cee49c72bb6dee69ef7337b", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-stage0\n+// This disables the test completely:\n // ignore-stage1\n \n-// ignore-emscripten\n-\n #![feature(i128_type)]\n \n fn b<T>(t: T) -> T { t }"}]}