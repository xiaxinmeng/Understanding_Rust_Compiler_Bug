{"sha": "7739bb2d3520fbbd2ae26efc9fd1bf4657a35d9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MzliYjJkMzUyMGZiYmQyYWUyNmVmYzlmZDFiZjQ2NTdhMzVkOWI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-19T12:27:10Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-22T09:54:32Z"}, "message": "Move resolve() into a function", "tree": {"sha": "9ebf41ad1ee048530b08db26777011f49afbb29b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ebf41ad1ee048530b08db26777011f49afbb29b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7739bb2d3520fbbd2ae26efc9fd1bf4657a35d9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7739bb2d3520fbbd2ae26efc9fd1bf4657a35d9b", "html_url": "https://github.com/rust-lang/rust/commit/7739bb2d3520fbbd2ae26efc9fd1bf4657a35d9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7739bb2d3520fbbd2ae26efc9fd1bf4657a35d9b/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbd2d16c3f9a4ce04547fa30aa60e8cb0362fdc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd2d16c3f9a4ce04547fa30aa60e8cb0362fdc7", "html_url": "https://github.com/rust-lang/rust/commit/fbd2d16c3f9a4ce04547fa30aa60e8cb0362fdc7"}], "stats": {"total": 48, "additions": 25, "deletions": 23}, "files": [{"sha": "66b7cd0cff99e41c3384a521aefc0db155c9de97", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7739bb2d3520fbbd2ae26efc9fd1bf4657a35d9b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7739bb2d3520fbbd2ae26efc9fd1bf4657a35d9b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7739bb2d3520fbbd2ae26efc9fd1bf4657a35d9b", "patch": "@@ -892,6 +892,24 @@ fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n              .emit();\n }\n \n+/// Resolve a given string as a path, along with whether or not it is\n+/// in the value namespace\n+fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<hir::Path, ()> {\n+    // In case we're in a module, try to resolve the relative\n+    // path\n+    if let Some(id) = cx.mod_ids.borrow().last() {\n+        cx.resolver.borrow_mut()\n+                   .with_scope(*id, |resolver| {\n+                        resolver.resolve_str_path_error(DUMMY_SP,\n+                                                        &path_str, is_val)\n+                    })\n+    } else {\n+        // FIXME(Manishearth) this branch doesn't seem to ever be hit, really\n+        cx.resolver.borrow_mut()\n+                   .resolve_str_path_error(DUMMY_SP, &path_str, is_val)\n+    }\n+}\n+\n enum PathKind {\n     /// can be either value or type, not a macro\n     Unknown,\n@@ -945,22 +963,6 @@ impl Clean<Attributes> for [ast::Attribute] {\n                         continue;\n                     }\n \n-                    let resolve = |is_val| {\n-                        // In case we're in a module, try to resolve the relative\n-                        // path\n-                        if let Some(id) = cx.mod_ids.borrow().last() {\n-                            cx.resolver.borrow_mut()\n-                                       .with_scope(*id, |resolver| {\n-                                            resolver.resolve_str_path_error(DUMMY_SP,\n-                                                                            &path_str, is_val)\n-                                        })\n-                        } else {\n-                            // FIXME(Manishearth) this branch doesn't seem to ever be hit, really\n-                            cx.resolver.borrow_mut()\n-                                       .resolve_str_path_error(DUMMY_SP, &path_str, is_val)\n-                        }\n-                    };\n-\n                     let macro_resolve = || {\n                             use syntax::ext::base::MacroKind;\n                             use syntax::ext::hygiene::Mark;\n@@ -989,7 +991,7 @@ impl Clean<Attributes> for [ast::Attribute] {\n \n                     match kind {\n                         PathKind::Value => {\n-                            if let Ok(path) = resolve(true) {\n+                            if let Ok(path) = resolve(cx, path_str, true) {\n                                 path.def\n                             } else {\n                                 // this could just be a normal link or a broken link\n@@ -999,7 +1001,7 @@ impl Clean<Attributes> for [ast::Attribute] {\n                             }\n                         }\n                         PathKind::Type => {\n-                            if let Ok(path) = resolve(false) {\n+                            if let Ok(path) = resolve(cx, path_str, false) {\n                                 path.def\n                             } else {\n                                 // this could just be a normal link\n@@ -1009,14 +1011,14 @@ impl Clean<Attributes> for [ast::Attribute] {\n                         PathKind::Unknown => {\n                             // try everything!\n                             if let Some(macro_def) = macro_resolve() {\n-                                if let Ok(type_path) = resolve(false) {\n+                                if let Ok(type_path) = resolve(cx, path_str, false) {\n                                     let (type_kind, article, type_disambig)\n                                         = type_ns_kind(type_path.def, path_str);\n                                     ambiguity_error(cx, &attrs, path_str,\n                                                     article, type_kind, &type_disambig,\n                                                     \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n                                     continue;\n-                                } else if let Ok(value_path) = resolve(true) {\n+                                } else if let Ok(value_path) = resolve(cx, path_str, true) {\n                                     let (value_kind, value_disambig)\n                                         = value_ns_kind(value_path.def, path_str)\n                                             .expect(\"struct and mod cases should have been \\\n@@ -1026,12 +1028,12 @@ impl Clean<Attributes> for [ast::Attribute] {\n                                                     \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n                                 }\n                                 macro_def\n-                            } else if let Ok(type_path) = resolve(false) {\n+                            } else if let Ok(type_path) = resolve(cx, path_str, false) {\n                                 // It is imperative we search for not-a-value first\n                                 // Otherwise we will find struct ctors for when we are looking\n                                 // for structs, and the link won't work.\n                                 // if there is something in both namespaces\n-                                if let Ok(value_path) = resolve(true) {\n+                                if let Ok(value_path) = resolve(cx, path_str, true) {\n                                     let kind = value_ns_kind(value_path.def, path_str);\n                                     if let Some((value_kind, value_disambig)) = kind {\n                                         let (type_kind, article, type_disambig)\n@@ -1043,7 +1045,7 @@ impl Clean<Attributes> for [ast::Attribute] {\n                                     }\n                                 }\n                                 type_path.def\n-                            } else if let Ok(value_path) = resolve(true) {\n+                            } else if let Ok(value_path) = resolve(cx, path_str, true) {\n                                 value_path.def\n                             } else {\n                                 // this could just be a normal link"}]}