{"sha": "31262c206e9d0152610572859092132555c7d492", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMjYyYzIwNmU5ZDAxNTI2MTA1NzI4NTkwOTIxMzI1NTVjN2Q0OTI=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-07-14T14:32:43Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-07-14T14:32:43Z"}, "message": "Arguments are now passed directly to the function instead of the enum variants", "tree": {"sha": "9573767ddf0f7f974960a98332d069a6c00404fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9573767ddf0f7f974960a98332d069a6c00404fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31262c206e9d0152610572859092132555c7d492", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31262c206e9d0152610572859092132555c7d492", "html_url": "https://github.com/rust-lang/rust/commit/31262c206e9d0152610572859092132555c7d492", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31262c206e9d0152610572859092132555c7d492/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5f7c19cf274f510b48d6835f5677ae22e978d6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5f7c19cf274f510b48d6835f5677ae22e978d6d", "html_url": "https://github.com/rust-lang/rust/commit/c5f7c19cf274f510b48d6835f5677ae22e978d6d"}], "stats": {"total": 393, "additions": 197, "deletions": 196}, "files": [{"sha": "67eeb19e6fd7887716b2892114e0e793dd44471e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/31262c206e9d0152610572859092132555c7d492/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31262c206e9d0152610572859092132555c7d492/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=31262c206e9d0152610572859092132555c7d492", "patch": "@@ -209,9 +209,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     // had the duplicate.\n                     let ns = ns.unwrap();\n                     ::resolve_error(\n+                        self,\n+                        sp,\n                         &::ResolutionError::DuplicateDefinition(\n-                            self,\n-                            sp,\n                             namespace_error_to_string(duplicate_type),\n                             &*token::get_name(name))\n                     );\n@@ -307,9 +307,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                             full_path.segments.last().unwrap().identifier.name;\n                         if &token::get_name(source_name)[..] == \"mod\" ||\n                            &token::get_name(source_name)[..] == \"self\" {\n-                            ::resolve_error(&::ResolutionError::SelfImportsOnlyAllowedWithin(\n-                                                                                self,\n-                                                                                view_path.span)\n+                            ::resolve_error(self,\n+                                            view_path.span,\n+                                            &::ResolutionError::SelfImportsOnlyAllowedWithin\n                             );\n                         }\n \n@@ -331,9 +331,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         }).collect::<Vec<Span>>();\n                         if mod_spans.len() > 1 {\n                             ::resolve_error(\n-                                &::ResolutionError::SelfImportCanOnlyAppearOnceInTheList(\n-                                    self,\n-                                    mod_spans[0])\n+                                self,\n+                                mod_spans[0],\n+                                &::ResolutionError::SelfImportCanOnlyAppearOnceInTheList\n                             );\n                             for other_span in mod_spans.iter().skip(1) {\n                                 self.session.span_note(*other_span,\n@@ -350,10 +350,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                         Some(name) => *name,\n                                         None => {\n                                             ::resolve_error(\n+                                                self,\n+                                                source_item.span,\n                                                 &::ResolutionError::\n-                                                SelfImportOnlyInImportListWithNonEmptyPrefix(\n-                                                    self,\n-                                                    source_item.span)\n+                                                SelfImportOnlyInImportListWithNonEmptyPrefix\n                                             );\n                                             continue;\n                                         }"}, {"sha": "6a8022341b07a254e2b7f678ce0eff947a36f62b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 183, "deletions": 184, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/31262c206e9d0152610572859092132555c7d492/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31262c206e9d0152610572859092132555c7d492/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=31262c206e9d0152610572859092132555c7d492", "patch": "@@ -116,265 +116,253 @@ mod record_exports;\n mod build_reduced_graph;\n mod resolve_imports;\n \n-pub enum ResolutionError<'b, 'a:'b, 'tcx:'a> {\n+pub enum ResolutionError<'b> {\n     /// error E0401: can't use type parameters from outer function\n-    TypeParametersFromOuterFunction(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    TypeParametersFromOuterFunction,\n     /// error E0402: cannot use an outer type parameter in this context\n-    OuterTypeParameterContext(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    OuterTypeParameterContext,\n     /// error E0403: the name is already used for a type parameter in this type parameter list\n-    NameAlreadyUsedInTypeParameterList(&'b Resolver<'a, 'tcx>, syntax::codemap::Span,\n-                                       syntax::ast::Name),\n+    NameAlreadyUsedInTypeParameterList(syntax::ast::Name),\n     /// error E0404: is not a trait\n-    IsNotATrait(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    IsNotATrait(&'b str),\n     /// error E0405: use of undeclared trait name\n-    UndeclaredTraitName(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    UndeclaredTraitName(&'b str),\n     /// error E0406: undeclared associated type\n-    UndeclaredAssociatedType(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    UndeclaredAssociatedType,\n     /// error E0407: method is not a member of trait\n-    MethodNotMemberOfTrait(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, syntax::ast::Name,\n-                           &'b str),\n+    MethodNotMemberOfTrait(syntax::ast::Name, &'b str),\n     /// error E0408: variable `{}` from pattern #1 is not bound in pattern\n-    VariableNotBoundInPattern(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, syntax::ast::Name,\n-                              usize),\n+    VariableNotBoundInPattern(syntax::ast::Name, usize),\n     /// error E0409: variable is bound with different mode in pattern #{} than in pattern #1\n-    VariableBoundWithDifferentMode(&'b Resolver<'a, 'tcx>, syntax::codemap::Span,\n-                                   syntax::ast::Name, usize),\n+    VariableBoundWithDifferentMode(syntax::ast::Name, usize),\n     /// error E0410: variable from pattern is not bound in pattern #1\n-    VariableNotBoundInParentPattern(&'b Resolver<'a, 'tcx>, syntax::codemap::Span,\n-                                    syntax::ast::Name, usize),\n+    VariableNotBoundInParentPattern(syntax::ast::Name, usize),\n     /// error E0411: use of `Self` outside of an impl or trait\n-    SelfUsedOutsideImplOrTrait(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    SelfUsedOutsideImplOrTrait,\n     /// error E0412: use of undeclared\n-    UseOfUndeclared(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str, &'b str),\n+    UseOfUndeclared(&'b str, &'b str),\n     /// error E0413: declaration shadows an enum variant or unit-like struct in scope\n-    DeclarationShadowsEnumVariantOrUnitLikeStruct(&'b Resolver<'a, 'tcx>, syntax::codemap::Span,\n-                                                  syntax::ast::Name),\n+    DeclarationShadowsEnumVariantOrUnitLikeStruct(syntax::ast::Name),\n     /// error E0414: only irrefutable patterns allowed here\n-    OnlyIrrefutablePatternsAllowedHere(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    OnlyIrrefutablePatternsAllowedHere,\n     /// error E0415: identifier is bound more than once in this parameter list\n-    IdentifierBoundMoreThanOnceInParameterList(&'b Resolver<'a, 'tcx>, syntax::codemap::Span,\n-                                               &'b str),\n+    IdentifierBoundMoreThanOnceInParameterList(&'b str),\n     /// error E0416: identifier is bound more than once in the same pattern\n-    IdentifierBoundMoreThanOnceInSamePattern(&'b Resolver<'a, 'tcx>, syntax::codemap::Span,\n-                                             &'b str),\n+    IdentifierBoundMoreThanOnceInSamePattern(&'b str),\n     /// error E0417: static variables cannot be referenced in a pattern\n-    StaticVariableReference(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    StaticVariableReference,\n     /// error E0418: is not an enum variant, struct or const\n-    NotAnEnumVariantStructOrConst(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    NotAnEnumVariantStructOrConst(&'b str),\n     /// error E0419: unresolved enum variant, struct or const\n-    UnresolvedEnumVariantStructOrConst(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    UnresolvedEnumVariantStructOrConst(&'b str),\n     /// error E0420: is not an associated const\n-    NotAnAssociatedConst(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    NotAnAssociatedConst(&'b str),\n     /// error E0421: unresolved associated const\n-    UnresolvedAssociatedConst(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    UnresolvedAssociatedConst(&'b str),\n     /// error E0422: does not name a struct\n-    DoesNotNameAStruct(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    DoesNotNameAStruct(&'b str),\n     /// error E0423: is a struct variant name, but this expression uses it like a function name\n-    StructVariantUsedAsFunction(&'a Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    StructVariantUsedAsFunction(&'b str),\n     /// error E0424: `self` is not available in a static method\n-    SelfNotAvailableInStaticMethod(&'a Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    SelfNotAvailableInStaticMethod,\n     /// error E0425: unresolved name\n-    UnresolvedName(&'a Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str, &'b str),\n+    UnresolvedName(&'b str, &'b str),\n     /// error E0426: use of undeclared label\n-    UndeclaredLabel(&'a Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    UndeclaredLabel(&'b str),\n     /// error E0427: cannot use `ref` binding mode with ...\n-    CannotUseRefBindingModeWith(&'a Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    CannotUseRefBindingModeWith(&'b str),\n     /// error E0428: duplicate definition\n-    DuplicateDefinition(&'a Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str, &'b str),\n+    DuplicateDefinition(&'b str, &'b str),\n     /// error E0429: `self` imports are only allowed within a { } list\n-    SelfImportsOnlyAllowedWithin(&'a Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    SelfImportsOnlyAllowedWithin,\n     /// error E0430: `self` import can only appear once in the list\n-    SelfImportCanOnlyAppearOnceInTheList(&'a Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    SelfImportCanOnlyAppearOnceInTheList,\n     /// error E0431: `self` import can only appear in an import list with a non-empty prefix\n-    SelfImportOnlyInImportListWithNonEmptyPrefix(&'a Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    SelfImportOnlyInImportListWithNonEmptyPrefix,\n     /// error E0432: unresolved import\n-    UnresolvedImport(&'b Resolver<'a, 'tcx>, syntax::codemap::Span,\n-                     Option<(&'b str, Option<&'b str>)>),\n+    UnresolvedImport(Option<(&'b str, Option<&'b str>)>),\n     /// error E0433: failed to resolve\n-    FailedToResolve(&'b Resolver<'a, 'tcx>, syntax::codemap::Span, &'b str),\n+    FailedToResolve(&'b str),\n     /// error E0434: can't capture dynamic environment in a fn item\n-    CannotCaptureDynamicEnvironmentInFnItem(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    CannotCaptureDynamicEnvironmentInFnItem,\n     /// error E0435: attempt to use a non-constant value in a constant\n-    AttemptToUseNonConstantValueInConstant(&'b Resolver<'a, 'tcx>, syntax::codemap::Span),\n+    AttemptToUseNonConstantValueInConstant,\n }\n \n-fn resolve_error<'b, 'a:'b, 'tcx:'a>(resolution_error: &ResolutionError<'b, 'a, 'tcx>) {\n+fn resolve_error<'b, 'a:'b, 'tcx:'a>(resolver: &'b Resolver<'a, 'tcx>, span: syntax::codemap::Span,\n+                                     resolution_error: &ResolutionError<'b>) {\n     match resolution_error {\n-        &ResolutionError::TypeParametersFromOuterFunction(resolver, span) => {\n+        &ResolutionError::TypeParametersFromOuterFunction => {\n             resolve_err!(resolver, span, E0401, \"can't use type parameters from \\\n                                                  outer function; try using a local \\\n                                                  type parameter instead\");\n         },\n-        &ResolutionError::OuterTypeParameterContext(resolver, span) => {\n+        &ResolutionError::OuterTypeParameterContext => {\n             resolve_err!(resolver, span, E0402,\n                          \"cannot use an outer type parameter in this context\");\n         },\n-        &ResolutionError::NameAlreadyUsedInTypeParameterList(resolver, span, name) => {\n+        &ResolutionError::NameAlreadyUsedInTypeParameterList(name) => {\n             resolve_err!(resolver, span, E0403,\n                          \"the name `{}` is already used for a type \\\n                           parameter in this type parameter list\", name);\n         },\n-        &ResolutionError::IsNotATrait(resolver, span, name) => {\n+        &ResolutionError::IsNotATrait(name) => {\n             resolve_err!(resolver, span, E0404,\n                          \"`{}` is not a trait\",\n                          name);\n         },\n-        &ResolutionError::UndeclaredTraitName(resolver, span, name) => {\n+        &ResolutionError::UndeclaredTraitName(name) => {\n             resolve_err!(resolver, span, E0405,\n                          \"use of undeclared trait name `{}`\",\n                          name);\n         },\n-        &ResolutionError::UndeclaredAssociatedType(resolver, span) => {\n+        &ResolutionError::UndeclaredAssociatedType => {\n             resolve_err!(resolver, span, E0406, \"undeclared associated type\");\n         },\n-        &ResolutionError::MethodNotMemberOfTrait(resolver, span, method, trait_) => {\n+        &ResolutionError::MethodNotMemberOfTrait(method, trait_) => {\n             resolve_err!(resolver, span, E0407,\n                          \"method `{}` is not a member of trait `{}`\",\n                          method,\n                          trait_);\n         },\n-        &ResolutionError::VariableNotBoundInPattern(resolver, span, variable_name,\n-                                                    pattern_number) => {\n+        &ResolutionError::VariableNotBoundInPattern(variable_name, pattern_number) => {\n             resolve_err!(resolver, span, E0408,\n                          \"variable `{}` from pattern #1 is not bound in pattern #{}\",\n                          variable_name,\n                          pattern_number);\n         },\n-        &ResolutionError::VariableBoundWithDifferentMode(resolver, span, variable_name,\n-                                                         pattern_number) => {\n+        &ResolutionError::VariableBoundWithDifferentMode(variable_name, pattern_number) => {\n             resolve_err!(resolver, span, E0409,\n                          \"variable `{}` is bound with different \\\n                          mode in pattern #{} than in pattern #1\",\n                          variable_name,\n                          pattern_number);\n         },\n-        &ResolutionError::VariableNotBoundInParentPattern(resolver, span, variable_name,\n-                                                          pattern_number) => {\n+        &ResolutionError::VariableNotBoundInParentPattern(variable_name, pattern_number) => {\n             resolve_err!(resolver, span, E0410,\n                          \"variable `{}` from pattern #{} is not bound in pattern #1\",\n                          variable_name,\n                          pattern_number);\n         },\n-        &ResolutionError::SelfUsedOutsideImplOrTrait(resolver, span) => {\n+        &ResolutionError::SelfUsedOutsideImplOrTrait => {\n             resolve_err!(resolver, span, E0411, \"use of `Self` outside of an impl or trait\");\n         },\n-        &ResolutionError::UseOfUndeclared(resolver, span, kind, name) => {\n+        &ResolutionError::UseOfUndeclared(kind, name) => {\n             resolve_err!(resolver, span, E0412,\n                          \"use of undeclared {} `{}`\",\n                          kind,\n                          name);\n         },\n-        &ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(resolver, span, name) => {\n+        &ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(name) => {\n             resolve_err!(resolver, span, E0413,\n                          \"declaration of `{}` shadows an enum variant or unit-like struct in \\\n                           scope\",\n                          name);\n         },\n-        &ResolutionError::OnlyIrrefutablePatternsAllowedHere(resolver, span) => {\n+        &ResolutionError::OnlyIrrefutablePatternsAllowedHere => {\n             resolve_err!(resolver, span, E0414, \"only irrefutable patterns allowed here\");\n         },\n-        &ResolutionError::IdentifierBoundMoreThanOnceInParameterList(resolver, span,\n-                                                                     identifier) => {\n+        &ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n             resolve_err!(resolver, span, E0415,\n                          \"identifier `{}` is bound more than once in this parameter list\",\n                          identifier);\n         },\n-        &ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(resolver, span, identifier) => {\n+        &ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => {\n             resolve_err!(resolver, span, E0416,\n                          \"identifier `{}` is bound more than once in the same pattern\",\n                          identifier);\n         },\n-        &ResolutionError::StaticVariableReference(resolver, span) => {\n+        &ResolutionError::StaticVariableReference => {\n             resolve_err!(resolver, span, E0417, \"static variables cannot be \\\n                                                  referenced in a pattern, \\\n                                                  use a `const` instead\");\n         },\n-        &ResolutionError::NotAnEnumVariantStructOrConst(resolver, span, name) => {\n+        &ResolutionError::NotAnEnumVariantStructOrConst(name) => {\n             resolve_err!(resolver, span, E0418,\n                          \"`{}` is not an enum variant, struct or const\",\n                          name);\n         },\n-        &ResolutionError::UnresolvedEnumVariantStructOrConst(resolver, span, name) => {\n+        &ResolutionError::UnresolvedEnumVariantStructOrConst(name) => {\n             resolve_err!(resolver, span, E0419,\n                          \"unresolved enum variant, struct or const `{}`\",\n                          name);\n         },\n-        &ResolutionError::NotAnAssociatedConst(resolver, span, name) => {\n+        &ResolutionError::NotAnAssociatedConst(name) => {\n             resolve_err!(resolver, span, E0420,\n                          \"`{}` is not an associated const\",\n                          name);\n         },\n-        &ResolutionError::UnresolvedAssociatedConst(resolver, span, name) => {\n+        &ResolutionError::UnresolvedAssociatedConst(name) => {\n             resolve_err!(resolver, span, E0421,\n                          \"unresolved associated const `{}`\",\n                          name);\n         },\n-        &ResolutionError::DoesNotNameAStruct(resolver, span, name) => {\n+        &ResolutionError::DoesNotNameAStruct(name) => {\n             resolve_err!(resolver, span, E0422, \"`{}` does not name a structure\", name);\n         },\n-        &ResolutionError::StructVariantUsedAsFunction(resolver, span, path_name) => {\n+        &ResolutionError::StructVariantUsedAsFunction(path_name) => {\n             resolve_err!(resolver, span, E0423,\n                          \"`{}` is a struct variant name, but \\\n                           this expression \\\n                           uses it like a function name\",\n                           path_name);\n         },\n-        &ResolutionError::SelfNotAvailableInStaticMethod(resolver, span) => {\n+        &ResolutionError::SelfNotAvailableInStaticMethod => {\n             resolve_err!(resolver, span, E0424, \"`self` is not available in a static method. \\\n                                                  Maybe a `self` argument is missing?\");\n         },\n-        &ResolutionError::UnresolvedName(resolver, span, path, name) => {\n+        &ResolutionError::UnresolvedName(path, name) => {\n             resolve_err!(resolver, span, E0425,\n                          \"unresolved name `{}`{}\",\n                          path,\n                          name);\n         },\n-        &ResolutionError::UndeclaredLabel(resolver, span, name) => {\n+        &ResolutionError::UndeclaredLabel(name) => {\n             resolve_err!(resolver, span, E0426,\n                          \"use of undeclared label `{}`\",\n                          name);\n         },\n-        &ResolutionError::CannotUseRefBindingModeWith(resolver, span, descr) => {\n+        &ResolutionError::CannotUseRefBindingModeWith(descr) => {\n             resolve_err!(resolver, span, E0427,\n                          \"cannot use `ref` binding mode with {}\",\n                          descr);\n         },\n-        &ResolutionError::DuplicateDefinition(resolver, span, namespace, name) => {\n+        &ResolutionError::DuplicateDefinition(namespace, name) => {\n             resolve_err!(resolver, span, E0428,\n                          \"duplicate definition of {} `{}`\",\n                          namespace,\n                          name);\n         },\n-        &ResolutionError::SelfImportsOnlyAllowedWithin(resolver, span) => {\n+        &ResolutionError::SelfImportsOnlyAllowedWithin => {\n             resolve_err!(resolver, span, E0429, \"{}\",\n                          \"`self` imports are only allowed within a { } list\");\n         },\n-        &ResolutionError::SelfImportCanOnlyAppearOnceInTheList(resolver, span) => {\n+        &ResolutionError::SelfImportCanOnlyAppearOnceInTheList => {\n             resolve_err!(resolver, span, E0430,\n                          \"`self` import can only appear once in the list\");\n         },\n-        &ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix(resolver, span) => {\n+        &ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => {\n             resolve_err!(resolver, span, E0431,\n                          \"`self` import can only appear in an import list with a \\\n                           non-empty prefix\");\n         }\n-        &ResolutionError::UnresolvedImport(resolver, span, name) => {\n+        &ResolutionError::UnresolvedImport(name) => {\n             let msg = match name {\n                 Some((n, Some(p))) => format!(\"unresolved import `{}`{}\", n, p),\n                 Some((n, None)) => format!(\"unresolved import (maybe you meant `{}::*`?)\", n),\n                 None => \"unresolved import\".to_owned()\n             };\n             resolve_err!(resolver, span, E0432, \"{}\", msg);\n         },\n-        &ResolutionError::FailedToResolve(resolver, span, msg) => {\n+        &ResolutionError::FailedToResolve(msg) => {\n             resolve_err!(resolver, span, E0433, \"failed to resolve. {}\", msg);\n         },\n-        &ResolutionError::CannotCaptureDynamicEnvironmentInFnItem(resolver, span) => {\n+        &ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n             resolve_err!(resolver, span, E0434, \"{}\",\n                          \"can't capture dynamic environment in a fn item; \\\n                           use the || { ... } closure form instead\");\n         },\n-        &ResolutionError::AttemptToUseNonConstantValueInConstant(resolver, span) =>{\n+        &ResolutionError::AttemptToUseNonConstantValueInConstant =>{\n             resolve_err!(resolver, span, E0435,\n                          \"attempt to use a non-constant value in a constant\");\n         },\n@@ -1575,7 +1563,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               PathSearch,\n                                               true) {\n                 Failed(Some((span, msg))) => {\n-                    resolve_error(&ResolutionError::FailedToResolve(self, span, &*msg));\n+                    resolve_error(self, span, &ResolutionError::FailedToResolve(&*msg));\n                 },\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n@@ -1833,13 +1821,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                          .span_to_snippet((*imports)[index].span)\n                          .unwrap();\n             if sn.contains(\"::\") {\n-                resolve_error(&ResolutionError::UnresolvedImport(self,\n-                                                                 (*imports)[index].span,\n-                                                                 None));\n+                resolve_error(self,\n+                              (*imports)[index].span,\n+                              &ResolutionError::UnresolvedImport(None));\n             } else {\n-                resolve_error(&ResolutionError::UnresolvedImport(self,\n-                                                                 (*imports)[index].span,\n-                                                                 Some((&*sn, None))));\n+                resolve_error(self,\n+                              (*imports)[index].span,\n+                              &ResolutionError::UnresolvedImport(Some((&*sn, None))));\n             }\n         }\n \n@@ -1966,18 +1954,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // named function item. This is not allowed, so we\n                             // report an error.\n                             resolve_error(\n-                                &ResolutionError::CannotCaptureDynamicEnvironmentInFnItem(\n-                                    self,\n-                                    span)\n+                                self,\n+                                span,\n+                                &ResolutionError::CannotCaptureDynamicEnvironmentInFnItem\n                             );\n                             return None;\n                         }\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n                             resolve_error(\n-                                &ResolutionError::AttemptToUseNonConstantValueInConstant(\n-                                    self,\n-                                    span)\n+                                self,\n+                                span,\n+                                &ResolutionError::AttemptToUseNonConstantValueInConstant\n                             );\n                             return None;\n                         }\n@@ -1994,13 +1982,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // This was an attempt to use a type parameter outside\n                             // its scope.\n \n-                            resolve_error(&ResolutionError::TypeParametersFromOuterFunction(self,\n-                                                                                            span));\n+                            resolve_error(self,\n+                                          span,\n+                                          &ResolutionError::TypeParametersFromOuterFunction);\n                             return None;\n                         }\n                         ConstantItemRibKind => {\n                             // see #9186\n-                            resolve_error(&ResolutionError::OuterTypeParameterContext(self, span));\n+                            resolve_error(self, span, &ResolutionError::OuterTypeParameterContext);\n                             return None;\n                         }\n                     }\n@@ -2198,10 +2187,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n                     if seen_bindings.contains(&name) {\n-                        resolve_error(&ResolutionError::NameAlreadyUsedInTypeParameterList(\n-                                                            self,\n-                                                            type_parameter.span,\n-                                                            name));\n+                        resolve_error(self,\n+                                      type_parameter.span,\n+                                      &ResolutionError::NameAlreadyUsedInTypeParameterList(\n+                                        name)\n+                        );\n                     }\n                     seen_bindings.insert(name);\n \n@@ -2288,9 +2278,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n                 Ok(path_res)\n             } else {\n-                resolve_error(&ResolutionError::IsNotATrait(self, trait_path.span,\n-                                                            &*path_names_to_string(trait_path,\n-                                                                                 path_depth))\n+                resolve_error(self,\n+                              trait_path.span,\n+                              &ResolutionError::IsNotATrait(&*path_names_to_string(trait_path,\n+                                                                                   path_depth))\n                              );\n \n                 // If it's a typedef, give a note\n@@ -2301,10 +2292,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Err(())\n             }\n         } else {\n-            resolve_error(&ResolutionError::UndeclaredTraitName(self,\n-                                                                trait_path.span,\n-                                                                &*path_names_to_string(trait_path,\n-                                                                                     path_depth)));\n+            resolve_error(self,\n+                          trait_path.span,\n+                          &ResolutionError::UndeclaredTraitName(\n+                            &*path_names_to_string(trait_path, path_depth))\n+                         );\n             Err(())\n         }\n     }\n@@ -2322,8 +2314,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     if let Some(PathResolution { base_def: DefTyParam(..), .. }) = path_res {\n                         self.record_def(eq_pred.id, path_res.unwrap());\n                     } else {\n-                        resolve_error(&ResolutionError::UndeclaredAssociatedType(self,\n-                                                                                 eq_pred.span));\n+                        resolve_error(self,\n+                                      eq_pred.span,\n+                                      &ResolutionError::UndeclaredAssociatedType);\n                     }\n                 }\n             }\n@@ -2448,9 +2441,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if let Some((did, ref trait_ref)) = self.current_trait_ref {\n             if !self.trait_item_map.contains_key(&(name, did)) {\n                 let path_str = path_names_to_string(&trait_ref.path, 0);\n-                resolve_error(&ResolutionError::MethodNotMemberOfTrait(self,\n-                                                                       span,\n-                                                                       name,\n+                resolve_error(self,\n+                              span,\n+                              &ResolutionError::MethodNotMemberOfTrait(name,\n                                                                        &*path_str));\n             }\n         }\n@@ -2498,18 +2491,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             for (&key, &binding_0) in &map_0 {\n                 match map_i.get(&key) {\n                   None => {\n-                    resolve_error(&ResolutionError::VariableNotBoundInPattern(self,\n-                                                                              p.span,\n-                                                                              key,\n+                    resolve_error(self,\n+                                  p.span,\n+                                  &ResolutionError::VariableNotBoundInPattern(key,\n                                                                               i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n-                        resolve_error(&ResolutionError::VariableBoundWithDifferentMode(\n-                                                                        self,\n-                                                                        binding_i.span,\n-                                                                        key,\n-                                                                        i + 1)\n+                        resolve_error(self,\n+                                      binding_i.span,\n+                                      &ResolutionError::VariableBoundWithDifferentMode(key,\n+                                                                                       i + 1)\n                                      );\n                     }\n                   }\n@@ -2518,9 +2510,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             for (&key, &binding) in &map_i {\n                 if !map_0.contains_key(&key) {\n-                    resolve_error(&ResolutionError::VariableNotBoundInParentPattern(self,\n-                                                                                    binding.span,\n-                                                                                    key,\n+                    resolve_error(self,\n+                                  binding.span,\n+                                  &ResolutionError::VariableNotBoundInParentPattern(key,\n                                                                                     i + 1));\n                 }\n             }\n@@ -2635,12 +2627,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             maybe_qself.is_none() &&\n                             path.segments[0].identifier.name == self_type_name;\n                         if is_invalid_self_type_name {\n-                            resolve_error(&ResolutionError::SelfUsedOutsideImplOrTrait(self,\n-                                                                                       ty.span));\n+                            resolve_error(self,\n+                                          ty.span,\n+                                          &ResolutionError::SelfUsedOutsideImplOrTrait);\n                         } else {\n-                            resolve_error(&ResolutionError::UseOfUndeclared(\n-                                                                    self,\n-                                                                    ty.span,\n+                            resolve_error(self,\n+                                          ty.span,\n+                                          &ResolutionError::UseOfUndeclared(\n                                                                     kind,\n                                                                     &*path_names_to_string(path,\n                                                                                            0))\n@@ -2697,9 +2690,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n                         FoundStructOrEnumVariant(..) => {\n                             resolve_error(\n+                                self,\n+                                pattern.span,\n                                 &ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(\n-                                    self,\n-                                    pattern.span,\n                                     renamed)\n                             );\n                         }\n@@ -2720,9 +2713,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n                         FoundConst(..) => {\n                             resolve_error(\n-                                &ResolutionError::OnlyIrrefutablePatternsAllowedHere(\n-                                    self,\n-                                    pattern.span)\n+                                self,\n+                                pattern.span,\n+                                &ResolutionError::OnlyIrrefutablePatternsAllowedHere\n                             );\n                         }\n                         BareIdentifierPatternUnresolved => {\n@@ -2756,19 +2749,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 // Forbid duplicate bindings in the same\n                                 // parameter list.\n                                 resolve_error(\n+                                    self,\n+                                    pattern.span,\n                                     &ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n-                                        self,\n-                                        pattern.span,\n                                         &*token::get_ident(ident))\n                                 );\n                             } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n                                 // same disjunction, which is an error.\n                                 resolve_error(\n+                                    self,\n+                                    pattern.span,\n                                     &ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n-                                        self,\n-                                        pattern.span,\n                                         &*token::get_ident(ident))\n                                 );\n                             }\n@@ -2801,8 +2794,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 self.record_def(pattern.id, path_res);\n                             }\n                             DefStatic(..) => {\n-                                resolve_error(&ResolutionError::StaticVariableReference(&self,\n-                                              path.span));\n+                                resolve_error(&self,\n+                                              path.span,\n+                                              &ResolutionError::StaticVariableReference);\n                             }\n                             _ => {\n                                 // If anything ends up here entirely resolved,\n@@ -2811,9 +2805,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 // be a `T::CONST` that typeck will resolve.\n                                 if path_res.depth == 0 {\n                                     resolve_error(\n+                                        self,\n+                                        path.span,\n                                         &ResolutionError::NotAnEnumVariantStructOrConst(\n-                                            self,\n-                                            path.span,\n                                             &*token::get_ident(\n                                                 path.segments.last().unwrap().identifier)\n                                             )\n@@ -2829,9 +2823,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n                     } else {\n                         resolve_error(\n+                            self,\n+                            path.span,\n                             &ResolutionError::UnresolvedEnumVariantStructOrConst(\n-                                self,\n-                                path.span,\n                                 &*token::get_ident(path.segments.last().unwrap().identifier))\n                         );\n                     }\n@@ -2866,9 +2860,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             }\n                             _ => {\n                                 resolve_error(\n+                                    self,\n+                                    path.span,\n                                     &ResolutionError::NotAnAssociatedConst(\n-                                        self,\n-                                        path.span,\n                                         &*token::get_ident(\n                                             path.segments.last().unwrap().identifier)\n                                     )\n@@ -2877,9 +2871,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n                     } else {\n                         resolve_error(\n+                            self,\n+                            path.span,\n                             &ResolutionError::UnresolvedAssociatedConst(\n-                                self,\n-                                path.span,\n                                 &*token::get_ident(path.segments.last().unwrap().identifier)\n                             )\n                         );\n@@ -2895,11 +2889,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         result => {\n                             debug!(\"(resolving pattern) didn't find struct \\\n                                     def: {:?}\", result);\n-                            resolve_error(&ResolutionError::DoesNotNameAStruct(\n-                                                                self,\n-                                                                path.span,\n-                                                                &*path_names_to_string(path, 0))\n-                                         );\n+                            resolve_error(\n+                                self,\n+                                path.span,\n+                                &ResolutionError::DoesNotNameAStruct(\n+                                    &*path_names_to_string(path, 0))\n+                            );\n                         }\n                     }\n                     visit::walk_path(self, path);\n@@ -2945,8 +2940,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 return FoundConst(def, LastMod(AllPublic));\n                             }\n                             DefStatic(..) => {\n-                                resolve_error(&ResolutionError::StaticVariableReference(self,\n-                                                                                        span));\n+                                resolve_error(self,\n+                                              span,\n+                                              &ResolutionError::StaticVariableReference);\n                                 return BareIdentifierPatternUnresolved;\n                             }\n                             _ => {\n@@ -2963,7 +2959,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) => {\n-                        resolve_error(&ResolutionError::FailedToResolve(self, span, &*msg));\n+                        resolve_error(self, span, &ResolutionError::FailedToResolve(&*msg));\n                     }\n                     None => ()\n                 }\n@@ -3192,7 +3188,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                resolve_error(&ResolutionError::FailedToResolve(self, span, &*msg));\n+                resolve_error(self, span, &ResolutionError::FailedToResolve(&*msg));\n                 return None;\n             }\n             Indeterminate => panic!(\"indeterminate unexpected\"),\n@@ -3251,7 +3247,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                resolve_error(&ResolutionError::FailedToResolve(self, span, &*msg));\n+                resolve_error(self, span, &ResolutionError::FailedToResolve(&*msg));\n                 return None;\n             }\n \n@@ -3347,7 +3343,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                          failed to resolve {}\", name);\n \n                 if let Some((span, msg)) = err {\n-                    resolve_error(&ResolutionError::FailedToResolve(self, span, &*msg))\n+                    resolve_error(self, span, &ResolutionError::FailedToResolve(&*msg))\n                 }\n \n                 return None;\n@@ -3550,9 +3546,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     if let DefVariant(_, _, true) = path_res.base_def {\n                         let path_name = path_names_to_string(path, 0);\n \n-                        resolve_error(&ResolutionError::StructVariantUsedAsFunction(self,\n-                                                                                    expr.span,\n-                                                                                    &*path_name));\n+                        resolve_error(self,\n+                                      expr.span,\n+                                      &ResolutionError::StructVariantUsedAsFunction(&*path_name));\n \n                         let msg = format!(\"did you mean to write: \\\n                                            `{} {{ /* fields */ }}`?\",\n@@ -3589,9 +3585,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     match type_res.map(|r| r.base_def) {\n                         Some(DefTy(struct_id, _))\n                             if self.structs.contains_key(&struct_id) => {\n-                                resolve_error(&ResolutionError::StructVariantUsedAsFunction(self,\n-                                                                                    expr.span,\n-                                                                                    &*path_name));\n+                                resolve_error(\n+                                    self,\n+                                    expr.span,\n+                                    &ResolutionError::StructVariantUsedAsFunction(\n+                                        &*path_name)\n+                                );\n \n                                 let msg = format!(\"did you mean to write: \\\n                                                      `{} {{ /* fields */ }}`?\",\n@@ -3619,9 +3618,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             if method_scope &&\n                                &token::get_name(special_names::self_)[..] == path_name {\n                                 resolve_error(\n-                                    &ResolutionError::SelfNotAvailableInStaticMethod(\n-                                        self,\n-                                        expr.span)\n+                                    self,\n+                                    expr.span,\n+                                    &ResolutionError::SelfNotAvailableInStaticMethod\n                                 );\n                             } else {\n                                 let last_name = path.segments.last().unwrap().identifier.name;\n@@ -3646,9 +3645,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     msg = format!(\". Did you mean {}?\", msg)\n                                 }\n \n-                                resolve_error(&ResolutionError::UnresolvedName(self,\n-                                                                               expr.span,\n-                                                                               &*path_name,\n+                                resolve_error(self,\n+                                              expr.span,\n+                                              &ResolutionError::UnresolvedName(&*path_name,\n                                                                                &*msg));\n                             }\n                         }\n@@ -3667,9 +3666,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         debug!(\"(resolving expression) didn't find struct def\",);\n \n-                        resolve_error(&ResolutionError::DoesNotNameAStruct(\n-                                                                self,\n-                                                                path.span,\n+                        resolve_error(self,\n+                                      path.span,\n+                                      &ResolutionError::DoesNotNameAStruct(\n                                                                 &*path_names_to_string(path, 0))\n                                      );\n                     }\n@@ -3696,9 +3695,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let renamed = mtwt::resolve(label);\n                 match self.search_label(renamed) {\n                     None => {\n-                        resolve_error(&ResolutionError::UndeclaredLabel(self,\n-                                                                        expr.span,\n-                                                                        &*token::get_ident(label)))\n+                        resolve_error(self,\n+                                      expr.span,\n+                                      &ResolutionError::UndeclaredLabel(&*token::get_ident(label)))\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n@@ -3844,9 +3843,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match pat_binding_mode {\n             BindByValue(_) => {}\n             BindByRef(..) => {\n-                resolve_error(&ResolutionError::CannotUseRefBindingModeWith(self,\n-                                                                            pat.span,\n-                                                                            descr));\n+                resolve_error(self,\n+                              pat.span,\n+                              &ResolutionError::CannotUseRefBindingModeWith(descr));\n             }\n         }\n     }"}, {"sha": "080c99b07d6224ae03a8ddd81a75ed000ad06321", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31262c206e9d0152610572859092132555c7d492/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31262c206e9d0152610572859092132555c7d492/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=31262c206e9d0152610572859092132555c7d492", "patch": "@@ -272,7 +272,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         Some((span, msg)) => (span, format!(\". {}\", msg)),\n                         None => (import_directive.span, String::new())\n                     };\n-                    ::resolve_error(&::ResolutionError::UnresolvedImport(self.resolver, span,\n+                    ::resolve_error(self.resolver,\n+                                    span,\n+                                    &::ResolutionError::UnresolvedImport(\n                                                 Some((&*import_path_to_string(\n                                                         &import_directive.module_path,\n                                                         import_directive.subclass),"}]}