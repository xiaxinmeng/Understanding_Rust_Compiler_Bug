{"sha": "f02fcc16444fcd18ccd51b43fa01bf0233e044fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMmZjYzE2NDQ0ZmNkMThjY2Q1MWI0M2ZhMDFiZjAyMzNlMDQ0ZmE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-13T21:32:44Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-13T21:33:38Z"}, "message": "Use path macro", "tree": {"sha": "44540371722c5d5a47d13e1e9f00bda579dcc311", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44540371722c5d5a47d13e1e9f00bda579dcc311"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f02fcc16444fcd18ccd51b43fa01bf0233e044fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f02fcc16444fcd18ccd51b43fa01bf0233e044fa", "html_url": "https://github.com/rust-lang/rust/commit/f02fcc16444fcd18ccd51b43fa01bf0233e044fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f02fcc16444fcd18ccd51b43fa01bf0233e044fa/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6911bc89a784ce72b4dfd8e0ba72bd22ce898395", "url": "https://api.github.com/repos/rust-lang/rust/commits/6911bc89a784ce72b4dfd8e0ba72bd22ce898395", "html_url": "https://github.com/rust-lang/rust/commit/6911bc89a784ce72b4dfd8e0ba72bd22ce898395"}], "stats": {"total": 129, "additions": 49, "deletions": 80}, "files": [{"sha": "f82242c3a05a2190321c16bdb66551b2eb48afa2", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f02fcc16444fcd18ccd51b43fa01bf0233e044fa/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02fcc16444fcd18ccd51b43fa01bf0233e044fa/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=f02fcc16444fcd18ccd51b43fa01bf0233e044fa", "patch": "@@ -15,7 +15,7 @@ use hir_def::{\n     },\n     expr::{ExprId, PatId},\n     nameres::ModuleSource,\n-    path::known,\n+    path::path,\n     resolver::{self, resolver_for_scope, HasResolver, Resolver, TypeNs, ValueNs},\n     AssocItemId, DefWithBodyId,\n };\n@@ -418,7 +418,7 @@ impl SourceAnalyzer {\n     /// Checks that particular type `ty` implements `std::future::Future`.\n     /// This function is used in `.await` syntax completion.\n     pub fn impls_future(&self, db: &impl HirDatabase, ty: Type) -> bool {\n-        let std_future_path = known::std_future_future();\n+        let std_future_path = path![std::future::Future];\n \n         let std_future_trait = match self.resolver.resolve_known_trait(db, &std_future_path) {\n             Some(it) => it.into(),"}, {"sha": "1e9eb14ea58838db99f66f95df76684b7678e6f0", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 32, "deletions": 63, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/f02fcc16444fcd18ccd51b43fa01bf0233e044fa/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02fcc16444fcd18ccd51b43fa01bf0233e044fa/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=f02fcc16444fcd18ccd51b43fa01bf0233e044fa", "patch": "@@ -76,10 +76,7 @@ impl Path {\n         }\n     }\n \n-    pub(crate) fn from_simple_segments(\n-        kind: PathKind,\n-        segments: impl IntoIterator<Item = Name>,\n-    ) -> Path {\n+    pub fn from_simple_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> Path {\n         Path {\n             kind,\n             segments: segments\n@@ -296,64 +293,36 @@ impl From<Name> for Path {\n     }\n }\n \n-pub mod known {\n-    use hir_expand::name::name;\n-\n-    use super::{Path, PathKind};\n-\n-    macro_rules! P {\n-        ($start:ident $(:: $seg:ident)*) => { Path::from_simple_segments(PathKind::Abs, vec![name![$start], $(name![$seg],)*]) };\n-    }\n-\n-    pub fn std_iter_into_iterator() -> Path {\n-        P![std::iter::IntoIterator]\n-    }\n-\n-    pub fn std_ops_try() -> Path {\n-        P![std::ops::Try]\n-    }\n-\n-    pub fn std_ops_range() -> Path {\n-        P![std::ops::Range]\n-    }\n-\n-    pub fn std_ops_range_from() -> Path {\n-        P![std::ops::RangeFrom]\n-    }\n-\n-    pub fn std_ops_range_full() -> Path {\n-        P![std::ops::RangeFull]\n-    }\n-\n-    pub fn std_ops_range_inclusive() -> Path {\n-        P![std::ops::RangeInclusive]\n-    }\n-\n-    pub fn std_ops_range_to() -> Path {\n-        P![std::ops::RangeTo]\n-    }\n-\n-    pub fn std_ops_range_to_inclusive() -> Path {\n-        P![std::ops::RangeToInclusive]\n-    }\n-\n-    pub fn std_ops_neg() -> Path {\n-        P![std::ops::Neg]\n-    }\n-\n-    pub fn std_ops_not() -> Path {\n-        P![std::ops::Not]\n-    }\n-\n-    pub fn std_result_result() -> Path {\n-        P![std::result::Result]\n-    }\n-\n-    pub fn std_future_future() -> Path {\n-        P![std::future::Future]\n-    }\n+pub use hir_expand::name as __name;\n+\n+#[macro_export]\n+macro_rules! __known_path {\n+    (std::iter::IntoIterator) => {};\n+    (std::result::Result) => {};\n+    (std::ops::Range) => {};\n+    (std::ops::RangeFrom) => {};\n+    (std::ops::RangeFull) => {};\n+    (std::ops::RangeTo) => {};\n+    (std::ops::RangeToInclusive) => {};\n+    (std::ops::RangeInclusive) => {};\n+    (std::boxed::Box) => {};\n+    (std::future::Future) => {};\n+    (std::ops::Try) => {};\n+    (std::ops::Neg) => {};\n+    (std::ops::Not) => {};\n+    ($path:path) => {\n+        compile_error!(\"Please register your known path in the path module\")\n+    };\n+}\n \n-    pub fn std_boxed_box() -> Path {\n-        P![std::boxed::Box]\n-    }\n+#[macro_export]\n+macro_rules! __path {\n+    ($start:ident $(:: $seg:ident)*) => ({\n+        $crate::__known_path!($start $(:: $seg)*);\n+        $crate::path::Path::from_simple_segments($crate::path::PathKind::Abs, vec![\n+            $crate::path::__name![$start], $($crate::path::__name![$seg],)*\n+        ])\n+    });\n }\n+\n+pub use crate::__path as path;"}, {"sha": "f752a9f09ae7cc96d5f2c44c0639364042e7c1d1", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f02fcc16444fcd18ccd51b43fa01bf0233e044fa/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02fcc16444fcd18ccd51b43fa01bf0233e044fa/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=f02fcc16444fcd18ccd51b43fa01bf0233e044fa", "patch": "@@ -3,7 +3,7 @@\n use std::sync::Arc;\n \n use hir_def::{\n-    path::{known, Path},\n+    path::{path, Path},\n     resolver::HasResolver,\n     AdtId, FunctionId,\n };\n@@ -124,7 +124,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             None => return,\n         };\n \n-        let std_result_path = known::std_result_result();\n+        let std_result_path = path![std::result::Result];\n \n         let resolver = self.func.resolver(db);\n         let std_result_enum = match resolver.resolve_known_enum(db, &std_result_path) {"}, {"sha": "f1b7e9442d30dba47e78721c8f879295303a82c1", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f02fcc16444fcd18ccd51b43fa01bf0233e044fa/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02fcc16444fcd18ccd51b43fa01bf0233e044fa/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=f02fcc16444fcd18ccd51b43fa01bf0233e044fa", "patch": "@@ -24,7 +24,7 @@ use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData},\n     expr::{BindingAnnotation, ExprId, PatId},\n-    path::{known, Path},\n+    path::{path, Path},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{Mutability, TypeRef},\n     AdtId, AssocItemId, DefWithBodyId, FunctionId, StructFieldId, TypeAliasId, VariantId,\n@@ -422,73 +422,73 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n-        let path = known::std_iter_into_iterator();\n+        let path = path![std::iter::IntoIterator];\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n     }\n \n     fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n-        let path = known::std_ops_try();\n+        let path = path![std::ops::Try];\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Ok])\n     }\n \n     fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n-        let path = known::std_ops_neg();\n+        let path = path![std::ops::Neg];\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_ops_not_output(&self) -> Option<TypeAliasId> {\n-        let path = known::std_ops_not();\n+        let path = path![std::ops::Not];\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAliasId> {\n-        let path = known::std_future_future();\n+        let path = path![std::future::Future];\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_boxed_box(&self) -> Option<AdtId> {\n-        let path = known::std_boxed_box();\n+        let path = path![std::boxed::Box];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_full(&self) -> Option<AdtId> {\n-        let path = known::std_ops_range_full();\n+        let path = path![std::ops::RangeFull];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range(&self) -> Option<AdtId> {\n-        let path = known::std_ops_range();\n+        let path = path![std::ops::Range];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_inclusive(&self) -> Option<AdtId> {\n-        let path = known::std_ops_range_inclusive();\n+        let path = path![std::ops::RangeInclusive];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_from(&self) -> Option<AdtId> {\n-        let path = known::std_ops_range_from();\n+        let path = path![std::ops::RangeFrom];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_to(&self) -> Option<AdtId> {\n-        let path = known::std_ops_range_to();\n+        let path = path![std::ops::RangeTo];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_to_inclusive(&self) -> Option<AdtId> {\n-        let path = known::std_ops_range_to_inclusive();\n+        let path = path![std::ops::RangeToInclusive];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }"}]}