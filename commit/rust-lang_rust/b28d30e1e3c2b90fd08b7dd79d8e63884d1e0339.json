{"sha": "b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "node_id": "C_kwDOAAsO6NoAKGIyOGQzMGUxZTNjMmI5MGZkMDhiN2RkNzlkOGU2Mzg4NGQxZTAzMzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-06T18:51:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-06T18:51:14Z"}, "message": "Auto merge of #105378 - matthiaskrgr:rollup-fjeorw5, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #104898 (Put all cached values into a central struct instead of just the stable hash)\n - #105004 (Fix `emit_unused_delims_expr` ICE)\n - #105174 (Suggest removing struct field from destructive binding only in shorthand scenario)\n - #105250 (Replace usage of `ResumeTy` in async lowering with `Context`)\n - #105286 (Add -Z maximal-hir-to-mir-coverage flag)\n - #105320 (rustdoc: simplify CSS selectors on top-doc and non-exhaustive toggles)\n - #105349 (Point at args in associated const fn pointers)\n - #105362 (Cleanup macro-expanded code in `rustc_type_ir`)\n - #105370 (Remove outdated syntax from trait alias pretty printing)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "5981b5bf2eda92d5d212eb46fcc17480cfe52e4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5981b5bf2eda92d5d212eb46fcc17480cfe52e4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "html_url": "https://github.com/rust-lang/rust/commit/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e60fbaf4ce768d13a6abc048bd34ee12995d18dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e60fbaf4ce768d13a6abc048bd34ee12995d18dc", "html_url": "https://github.com/rust-lang/rust/commit/e60fbaf4ce768d13a6abc048bd34ee12995d18dc"}, {"sha": "97008a23fc20f66e3dc5b292ad79d97198788ac3", "url": "https://api.github.com/repos/rust-lang/rust/commits/97008a23fc20f66e3dc5b292ad79d97198788ac3", "html_url": "https://github.com/rust-lang/rust/commit/97008a23fc20f66e3dc5b292ad79d97198788ac3"}], "stats": {"total": 1408, "additions": 658, "deletions": 750}, "files": [{"sha": "9974ebff311fb8c536f140880172ab7f95c4b07f", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -16,7 +16,7 @@ use rustc_hir::def::Res;\n use rustc_hir::definitions::DefPathData;\n use rustc_session::errors::report_lit_error;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::DUMMY_SP;\n use thin_vec::thin_vec;\n \n@@ -594,14 +594,38 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         let output = ret_ty.unwrap_or_else(|| hir::FnRetTy::DefaultReturn(self.lower_span(span)));\n \n-        // Resume argument type: `ResumeTy`\n-        let unstable_span =\n-            self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n-        let resume_ty = hir::QPath::LangItem(hir::LangItem::ResumeTy, unstable_span, None);\n+        // Resume argument type, which should be `&mut Context<'_>`.\n+        // NOTE: Using the `'static` lifetime here is technically cheating.\n+        // The `Future::poll` argument really is `&'a mut Context<'b>`, but we cannot\n+        // express the fact that we are not storing it across yield-points yet,\n+        // and we would thus run into lifetime errors.\n+        // See <https://github.com/rust-lang/rust/issues/68923>.\n+        // Our lowering makes sure we are not mis-using the `_task_context` input type\n+        // in the sense that we are indeed not using it across yield points. We\n+        // get a fresh `&mut Context` for each resume / call of `Future::poll`.\n+        // This \"cheating\" was previously done with a `ResumeTy` that contained a raw\n+        // pointer, and a `get_context` accessor that pulled the `Context` lifetimes\n+        // out of thin air.\n+        let context_lifetime_ident = Ident::with_dummy_span(kw::StaticLifetime);\n+        let context_lifetime = self.arena.alloc(hir::Lifetime {\n+            hir_id: self.next_id(),\n+            ident: context_lifetime_ident,\n+            res: hir::LifetimeName::Static,\n+        });\n+        let context_path =\n+            hir::QPath::LangItem(hir::LangItem::Context, self.lower_span(span), None);\n+        let context_ty = hir::MutTy {\n+            ty: self.arena.alloc(hir::Ty {\n+                hir_id: self.next_id(),\n+                kind: hir::TyKind::Path(context_path),\n+                span: self.lower_span(span),\n+            }),\n+            mutbl: hir::Mutability::Mut,\n+        };\n         let input_ty = hir::Ty {\n             hir_id: self.next_id(),\n-            kind: hir::TyKind::Path(resume_ty),\n-            span: unstable_span,\n+            kind: hir::TyKind::Rptr(context_lifetime, context_ty),\n+            span: self.lower_span(span),\n         };\n \n         // The closure/generator `FnDecl` takes a single (resume) argument of type `input_ty`.\n@@ -659,12 +683,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             .map_or(false, |attrs| attrs.into_iter().any(|attr| attr.has_name(sym::track_caller)));\n \n         let hir_id = self.lower_node_id(closure_node_id);\n+        let unstable_span =\n+            self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n         if track_caller {\n-            let unstable_span = self.mark_span_with_reason(\n-                DesugaringKind::Async,\n-                span,\n-                self.allow_gen_future.clone(),\n-            );\n             self.lower_attrs(\n                 hir_id,\n                 &[Attribute {\n@@ -711,7 +732,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ///     mut __awaitee => loop {\n     ///         match unsafe { ::std::future::Future::poll(\n     ///             <::std::pin::Pin>::new_unchecked(&mut __awaitee),\n-    ///             ::std::future::get_context(task_context),\n+    ///             task_context,\n     ///         ) } {\n     ///             ::std::task::Poll::Ready(result) => break result,\n     ///             ::std::task::Poll::Pending => {}\n@@ -752,7 +773,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // unsafe {\n         //     ::std::future::Future::poll(\n         //         ::std::pin::Pin::new_unchecked(&mut __awaitee),\n-        //         ::std::future::get_context(task_context),\n+        //         task_context,\n         //     )\n         // }\n         let poll_expr = {\n@@ -770,16 +791,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 arena_vec![self; ref_mut_awaitee],\n                 Some(expr_hir_id),\n             );\n-            let get_context = self.expr_call_lang_item_fn_mut(\n-                gen_future_span,\n-                hir::LangItem::GetContext,\n-                arena_vec![self; task_context],\n-                Some(expr_hir_id),\n-            );\n             let call = self.expr_call_lang_item_fn(\n                 span,\n                 hir::LangItem::FuturePoll,\n-                arena_vec![self; new_unchecked, get_context],\n+                arena_vec![self; new_unchecked, task_context],\n                 Some(expr_hir_id),\n             );\n             self.arena.alloc(self.expr_unsafe(call))"}, {"sha": "5b6a07721e2bbdb605710cfb2a701f5e90078584", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -348,21 +348,10 @@ impl<'a> State<'a> {\n                 self.head(visibility_qualified(&item.vis, \"trait\"));\n                 self.print_ident(item.ident);\n                 self.print_generic_params(&generics.params);\n-                let mut real_bounds = Vec::with_capacity(bounds.len());\n-                // FIXME(durka) this seems to be some quite outdated syntax\n-                for b in bounds.iter() {\n-                    if let GenericBound::Trait(ptr, ast::TraitBoundModifier::Maybe) = b {\n-                        self.space();\n-                        self.word_space(\"for ?\");\n-                        self.print_trait_ref(&ptr.trait_ref);\n-                    } else {\n-                        real_bounds.push(b.clone());\n-                    }\n-                }\n                 self.nbsp();\n-                if !real_bounds.is_empty() {\n+                if !bounds.is_empty() {\n                     self.word_nbsp(\"=\");\n-                    self.print_type_bounds(&real_bounds);\n+                    self.print_type_bounds(&bounds);\n                 }\n                 self.print_where_clause(&generics.where_clause);\n                 self.word(\";\");"}, {"sha": "ba94f3776eb90bc5da1e4e534508d689aa20dda7", "filename": "compiler/rustc_data_structures/src/intern.rs", "status": "modified", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -4,8 +4,6 @@ use std::hash::{Hash, Hasher};\n use std::ops::Deref;\n use std::ptr;\n \n-use crate::fingerprint::Fingerprint;\n-\n mod private {\n     #[derive(Clone, Copy, Debug)]\n     pub struct PrivateZst;\n@@ -110,86 +108,5 @@ where\n     }\n }\n \n-/// A helper type that you can wrap round your own type in order to automatically\n-/// cache the stable hash on creation and not recompute it whenever the stable hash\n-/// of the type is computed.\n-/// This is only done in incremental mode. You can also opt out of caching by using\n-/// StableHash::ZERO for the hash, in which case the hash gets computed each time.\n-/// This is useful if you have values that you intern but never (can?) use for stable\n-/// hashing.\n-#[derive(Copy, Clone)]\n-pub struct WithStableHash<T> {\n-    pub internee: T,\n-    pub stable_hash: Fingerprint,\n-}\n-\n-impl<T: PartialEq> PartialEq for WithStableHash<T> {\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool {\n-        self.internee.eq(&other.internee)\n-    }\n-}\n-\n-impl<T: Eq> Eq for WithStableHash<T> {}\n-\n-impl<T: Ord> PartialOrd for WithStableHash<T> {\n-    fn partial_cmp(&self, other: &WithStableHash<T>) -> Option<Ordering> {\n-        Some(self.internee.cmp(&other.internee))\n-    }\n-}\n-\n-impl<T: Ord> Ord for WithStableHash<T> {\n-    fn cmp(&self, other: &WithStableHash<T>) -> Ordering {\n-        self.internee.cmp(&other.internee)\n-    }\n-}\n-\n-impl<T> Deref for WithStableHash<T> {\n-    type Target = T;\n-\n-    #[inline]\n-    fn deref(&self) -> &T {\n-        &self.internee\n-    }\n-}\n-\n-impl<T: Hash> Hash for WithStableHash<T> {\n-    #[inline]\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        if self.stable_hash != Fingerprint::ZERO {\n-            self.stable_hash.hash(s)\n-        } else {\n-            self.internee.hash(s)\n-        }\n-    }\n-}\n-\n-impl<T: HashStable<CTX>, CTX> HashStable<CTX> for WithStableHash<T> {\n-    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        if self.stable_hash == Fingerprint::ZERO || cfg!(debug_assertions) {\n-            // No cached hash available. This can only mean that incremental is disabled.\n-            // We don't cache stable hashes in non-incremental mode, because they are used\n-            // so rarely that the performance actually suffers.\n-\n-            // We need to build the hash as if we cached it and then hash that hash, as\n-            // otherwise the hashes will differ between cached and non-cached mode.\n-            let stable_hash: Fingerprint = {\n-                let mut hasher = StableHasher::new();\n-                self.internee.hash_stable(hcx, &mut hasher);\n-                hasher.finish()\n-            };\n-            if cfg!(debug_assertions) && self.stable_hash != Fingerprint::ZERO {\n-                assert_eq!(\n-                    stable_hash, self.stable_hash,\n-                    \"cached stable hash does not match freshly computed stable hash\"\n-                );\n-            }\n-            stable_hash.hash_stable(hcx, hasher);\n-        } else {\n-            self.stable_hash.hash_stable(hcx, hasher);\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests;"}, {"sha": "b51257df713ea37a273bc14fc579d3ac38eb7e9f", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -286,10 +286,9 @@ language_item_table! {\n \n     // FIXME(swatinem): the following lang items are used for async lowering and\n     // should become obsolete eventually.\n-    ResumeTy,                sym::ResumeTy,            resume_ty,                  Target::Struct,         GenericRequirement::None;\n     IdentityFuture,          sym::identity_future,     identity_future_fn,         Target::Fn,             GenericRequirement::None;\n-    GetContext,              sym::get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n \n+    Context,                 sym::Context,             context,                    Target::Struct,         GenericRequirement::None;\n     FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n \n     FromFrom,                sym::from,                from_fn,                    Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;"}, {"sha": "94bab9f339d8c9e0b8d0c5741975506184e1bbca", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -695,19 +695,8 @@ impl<'a> State<'a> {\n                 self.head(\"trait\");\n                 self.print_ident(item.ident);\n                 self.print_generic_params(generics.params);\n-                let mut real_bounds = Vec::with_capacity(bounds.len());\n-                // FIXME(durka) this seems to be some quite outdated syntax\n-                for b in bounds {\n-                    if let GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = b {\n-                        self.space();\n-                        self.word_space(\"for ?\");\n-                        self.print_trait_ref(&ptr.trait_ref);\n-                    } else {\n-                        real_bounds.push(b);\n-                    }\n-                }\n                 self.nbsp();\n-                self.print_bounds(\"=\", real_bounds);\n+                self.print_bounds(\"=\", bounds);\n                 self.print_where_clause(generics);\n                 self.word(\";\");\n                 self.end(); // end inner head-block"}, {"sha": "8a875e05b19b7db2280c4b2356e7a827eb8217e3", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -1918,15 +1918,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         receiver: Option<&'tcx hir::Expr<'tcx>>,\n         args: &'tcx [hir::Expr<'tcx>],\n     ) -> bool {\n-        // Do not call `fn_sig` on non-functions.\n-        if !matches!(\n-            self.tcx.def_kind(def_id),\n-            DefKind::Fn | DefKind::AssocFn | DefKind::Variant | DefKind::Ctor(..)\n-        ) {\n+        let ty = self.tcx.type_of(def_id);\n+        if !ty.is_fn() {\n             return false;\n         }\n-\n-        let sig = self.tcx.fn_sig(def_id).skip_binder();\n+        let sig = ty.fn_sig(self.tcx).skip_binder();\n         let args_referencing_param: Vec<_> = sig\n             .inputs()\n             .iter()"}, {"sha": "2b8f6557c829b32042879be2c525ed09e4fbef8f", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -747,6 +747,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(link_only, true);\n     tracked!(llvm_plugins, vec![String::from(\"plugin_name\")]);\n     tracked!(location_detail, LocationDetail { file: true, line: false, column: false });\n+    tracked!(maximal_hir_to_mir_coverage, true);\n     tracked!(merge_functions, Some(MergeFunctions::Disabled));\n     tracked!(mir_emit_retag, true);\n     tracked!(mir_enable_passes, vec![(\"DestProp\".to_string(), false)]);"}, {"sha": "0fa81b7e4e0bc20f2c644783199734475e474359", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -10,7 +10,7 @@ declare_tool_lint! {\n     /// The `rustc_pass_by_value` lint marks a type with `#[rustc_pass_by_value]` requiring it to\n     /// always be passed by value. This is usually used for types that are thin wrappers around\n     /// references, so there is no benefit to an extra layer of indirection. (Example: `Ty` which\n-    /// is a reference to an `Interned<TyS>`)\n+    /// is a reference to an `Interned<TyKind>`)\n     pub rustc::PASS_BY_VALUE,\n     Warn,\n     \"pass by reference of a type flagged as `#[rustc_pass_by_value]`\","}, {"sha": "b5db94f8c0684b3235fa92972c5f453df2c71c6f", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -633,13 +633,34 @@ trait UnusedDelimLint {\n         left_pos: Option<BytePos>,\n         right_pos: Option<BytePos>,\n     ) {\n+        // If `value` has `ExprKind::Err`, unused delim lint can be broken.\n+        // For example, the following code caused ICE.\n+        // This is because the `ExprKind::Call` in `value` has `ExprKind::Err` as its argument\n+        // and this leads to wrong spans. #104897\n+        //\n+        // ```\n+        // fn f(){(print!(\u00e1\n+        // ```\n+        use rustc_ast::visit::{walk_expr, Visitor};\n+        struct ErrExprVisitor {\n+            has_error: bool,\n+        }\n+        impl<'ast> Visitor<'ast> for ErrExprVisitor {\n+            fn visit_expr(&mut self, expr: &'ast ast::Expr) {\n+                if let ExprKind::Err = expr.kind {\n+                    self.has_error = true;\n+                    return;\n+                }\n+                walk_expr(self, expr)\n+            }\n+        }\n+        let mut visitor = ErrExprVisitor { has_error: false };\n+        visitor.visit_expr(value);\n+        if visitor.has_error {\n+            return;\n+        }\n         let spans = match value.kind {\n             ast::ExprKind::Block(ref block, None) if block.stmts.len() == 1 => {\n-                if let StmtKind::Expr(expr) = &block.stmts[0].kind\n-                    && let ExprKind::Err = expr.kind\n-                {\n-                    return\n-                }\n                 if let Some(span) = block.stmts[0].span.find_ancestor_inside(value.span) {\n                     Some((value.span.with_hi(span.lo()), value.span.with_lo(span.hi())))\n                 } else {"}, {"sha": "6de68841fe91f41fa84faa97f77ce3448350d9e9", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -1,3 +1,5 @@\n+#![allow(rustc::usage_of_ty_tykind)]\n+\n /// This higher-order macro declares a list of types which can be allocated by `Arena`.\n ///\n /// Specifying the `decode` modifier will add decode impls for `&T` and `&[T]` where `T` is the type\n@@ -89,8 +91,8 @@ macro_rules! arena_types {\n             [] hir_id_set: rustc_hir::HirIdSet,\n \n             // Interned types\n-            [] tys: rustc_data_structures::intern::WithStableHash<rustc_middle::ty::TyS<'tcx>>,\n-            [] predicates: rustc_data_structures::intern::WithStableHash<rustc_middle::ty::PredicateS<'tcx>>,\n+            [] tys: rustc_type_ir::WithCachedTypeInfo<rustc_middle::ty::TyKind<'tcx>>,\n+            [] predicates: rustc_type_ir::WithCachedTypeInfo<rustc_middle::ty::PredicateKind<'tcx>>,\n             [] consts: rustc_middle::ty::ConstS<'tcx>,\n \n             // Note that this deliberately duplicates items in the `rustc_hir::arena`,"}, {"sha": "221105ac48f79b5487374c7969cdd058d1515755", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -103,7 +103,7 @@ impl hash::Hash for Allocation {\n /// Interned types generally have an `Outer` type and an `Inner` type, where\n /// `Outer` is a newtype around `Interned<Inner>`, and all the operations are\n /// done on `Outer`, because all occurrences are interned. E.g. `Ty` is an\n-/// outer type and `TyS` is its inner type.\n+/// outer type and `TyKind` is its inner type.\n ///\n /// Here things are different because only const allocations are interned. This\n /// means that both the inner type (`Allocation`) and the outer type"}, {"sha": "82ca1b87535d89780909a8d5c5f95789138c60b7", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 27, "deletions": 56, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -1,5 +1,7 @@\n //! Type context book-keeping.\n \n+#![allow(rustc::usage_of_ty_tykind)]\n+\n use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::hir::place::Place as HirPlace;\n@@ -19,15 +21,15 @@ use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n     ClosureSizeProfileData, Const, ConstS, DefIdTree, FloatTy, FloatVar, FloatVid,\n     GenericParamDefKind, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n-    PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, PredicateS, ProjectionTy,\n-    Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut,\n-    UintTy, Visibility,\n+    PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, ProjectionTy, Region,\n+    RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, UintTy,\n+    Visibility,\n };\n use crate::ty::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef, UserSubsts};\n use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::intern::{Interned, WithStableHash};\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n@@ -68,6 +70,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Layout, LayoutS, TargetDataLayout, VariantIdx};\n use rustc_target::spec::abi;\n use rustc_type_ir::sty::TyKind::*;\n+use rustc_type_ir::WithCachedTypeInfo;\n use rustc_type_ir::{DynKind, InternAs, InternIteratorElement, Interner, TypeFlags};\n \n use std::any::Any;\n@@ -137,13 +140,13 @@ pub struct CtxtInterners<'tcx> {\n \n     // Specifically use a speedy hash algorithm for these hash sets, since\n     // they're accessed quite often.\n-    type_: InternedSet<'tcx, WithStableHash<TyS<'tcx>>>,\n+    type_: InternedSet<'tcx, WithCachedTypeInfo<TyKind<'tcx>>>,\n     const_lists: InternedSet<'tcx, List<ty::Const<'tcx>>>,\n     substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo<'tcx>>>,\n     region: InternedSet<'tcx, RegionKind<'tcx>>,\n     poly_existential_predicates: InternedSet<'tcx, List<PolyExistentialPredicate<'tcx>>>,\n-    predicate: InternedSet<'tcx, WithStableHash<PredicateS<'tcx>>>,\n+    predicate: InternedSet<'tcx, WithCachedTypeInfo<ty::Binder<'tcx, PredicateKind<'tcx>>>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n@@ -194,15 +197,12 @@ impl<'tcx> CtxtInterners<'tcx> {\n                     let stable_hash =\n                         self.stable_hash(&flags, sess, definitions, cstore, source_span, &kind);\n \n-                    let ty_struct = TyS {\n-                        kind,\n+                    InternedInSet(self.arena.alloc(WithCachedTypeInfo {\n+                        internee: kind,\n+                        stable_hash,\n                         flags: flags.flags,\n                         outer_exclusive_binder: flags.outer_exclusive_binder,\n-                    };\n-\n-                    InternedInSet(\n-                        self.arena.alloc(WithStableHash { internee: ty_struct, stable_hash }),\n-                    )\n+                    }))\n                 })\n                 .0,\n         ))\n@@ -246,16 +246,12 @@ impl<'tcx> CtxtInterners<'tcx> {\n                     let stable_hash =\n                         self.stable_hash(&flags, sess, definitions, cstore, source_span, &kind);\n \n-                    let predicate_struct = PredicateS {\n-                        kind,\n+                    InternedInSet(self.arena.alloc(WithCachedTypeInfo {\n+                        internee: kind,\n+                        stable_hash,\n                         flags: flags.flags,\n                         outer_exclusive_binder: flags.outer_exclusive_binder,\n-                    };\n-\n-                    InternedInSet(\n-                        self.arena\n-                            .alloc(WithStableHash { internee: predicate_struct, stable_hash }),\n-                    )\n+                    }))\n                 })\n                 .0,\n         ))\n@@ -2104,7 +2100,7 @@ macro_rules! sty_debug_print {\n                 let shards = tcx.interners.type_.lock_shards();\n                 let types = shards.iter().flat_map(|shard| shard.keys());\n                 for &InternedInSet(t) in types {\n-                    let variant = match t.kind {\n+                    let variant = match t.internee {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n                             ty::Float(..) | ty::Str | ty::Never => continue,\n                         ty::Error(_) => /* unimportant */ continue,\n@@ -2214,51 +2210,26 @@ impl<'tcx, T: 'tcx + ?Sized> IntoPointer for InternedInSet<'tcx, T> {\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n-impl<'tcx> Borrow<TyKind<'tcx>> for InternedInSet<'tcx, WithStableHash<TyS<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a TyKind<'tcx> {\n-        &self.0.kind\n-    }\n-}\n-\n-impl<'tcx> PartialEq for InternedInSet<'tcx, WithStableHash<TyS<'tcx>>> {\n-    fn eq(&self, other: &InternedInSet<'tcx, WithStableHash<TyS<'tcx>>>) -> bool {\n-        // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n-        // `x == y`.\n-        self.0.kind == other.0.kind\n-    }\n-}\n-\n-impl<'tcx> Eq for InternedInSet<'tcx, WithStableHash<TyS<'tcx>>> {}\n-\n-impl<'tcx> Hash for InternedInSet<'tcx, WithStableHash<TyS<'tcx>>> {\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n-        self.0.kind.hash(s)\n-    }\n-}\n-\n-impl<'tcx> Borrow<Binder<'tcx, PredicateKind<'tcx>>>\n-    for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>>\n-{\n-    fn borrow<'a>(&'a self) -> &'a Binder<'tcx, PredicateKind<'tcx>> {\n-        &self.0.kind\n+impl<'tcx, T> Borrow<T> for InternedInSet<'tcx, WithCachedTypeInfo<T>> {\n+    fn borrow<'a>(&'a self) -> &'a T {\n+        &self.0.internee\n     }\n }\n \n-impl<'tcx> PartialEq for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>> {\n-    fn eq(&self, other: &InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>>) -> bool {\n+impl<'tcx, T: PartialEq> PartialEq for InternedInSet<'tcx, WithCachedTypeInfo<T>> {\n+    fn eq(&self, other: &InternedInSet<'tcx, WithCachedTypeInfo<T>>) -> bool {\n         // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n         // `x == y`.\n-        self.0.kind == other.0.kind\n+        self.0.internee == other.0.internee\n     }\n }\n \n-impl<'tcx> Eq for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>> {}\n+impl<'tcx, T: Eq> Eq for InternedInSet<'tcx, WithCachedTypeInfo<T>> {}\n \n-impl<'tcx> Hash for InternedInSet<'tcx, WithStableHash<PredicateS<'tcx>>> {\n+impl<'tcx, T: Hash> Hash for InternedInSet<'tcx, WithCachedTypeInfo<T>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n-        self.0.kind.hash(s)\n+        self.0.internee.hash(s)\n     }\n }\n "}, {"sha": "cd679ffdfbc67d6f72efadd5a4fb028c2d021e94", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 20, "deletions": 107, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -9,6 +9,8 @@\n //!\n //! [\"The `ty` module: representing types\"]: https://rustc-dev-guide.rust-lang.org/ty.html\n \n+#![allow(rustc::usage_of_ty_tykind)]\n+\n pub use self::fold::{FallibleTypeFolder, TypeFoldable, TypeFolder, TypeSuperFoldable};\n pub use self::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n pub use self::AssocItemContainer::*;\n@@ -32,7 +34,7 @@ use rustc_ast::node_id::NodeMap;\n use rustc_attr as attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n-use rustc_data_structures::intern::{Interned, WithStableHash};\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n@@ -50,6 +52,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{ExpnId, Span};\n use rustc_target::abi::{Align, Integer, IntegerType, VariantIdx};\n pub use rustc_target::abi::{ReprFlags, ReprOptions};\n+use rustc_type_ir::WithCachedTypeInfo;\n pub use subst::*;\n pub use vtable::*;\n \n@@ -445,86 +448,22 @@ pub struct CReaderCacheKey {\n     pub pos: usize,\n }\n \n-/// Represents a type.\n-///\n-/// IMPORTANT:\n-/// - This is a very \"dumb\" struct (with no derives and no `impls`).\n-/// - Values of this type are always interned and thus unique, and are stored\n-///   as an `Interned<TyS>`.\n-/// - `Ty` (which contains a reference to a `Interned<TyS>`) or `Interned<TyS>`\n-///   should be used everywhere instead of `TyS`. In particular, `Ty` has most\n-///   of the relevant methods.\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-#[allow(rustc::usage_of_ty_tykind)]\n-pub(crate) struct TyS<'tcx> {\n-    /// This field shouldn't be used directly and may be removed in the future.\n-    /// Use `Ty::kind()` instead.\n-    kind: TyKind<'tcx>,\n-\n-    /// This field provides fast access to information that is also contained\n-    /// in `kind`.\n-    ///\n-    /// This field shouldn't be used directly and may be removed in the future.\n-    /// Use `Ty::flags()` instead.\n-    flags: TypeFlags,\n-\n-    /// This field provides fast access to information that is also contained\n-    /// in `kind`.\n-    ///\n-    /// This is a kind of confusing thing: it stores the smallest\n-    /// binder such that\n-    ///\n-    /// (a) the binder itself captures nothing but\n-    /// (b) all the late-bound things within the type are captured\n-    ///     by some sub-binder.\n-    ///\n-    /// So, for a type without any late-bound things, like `u32`, this\n-    /// will be *innermost*, because that is the innermost binder that\n-    /// captures nothing. But for a type `&'D u32`, where `'D` is a\n-    /// late-bound region with De Bruijn index `D`, this would be `D + 1`\n-    /// -- the binder itself does not capture `D`, but `D` is captured\n-    /// by an inner binder.\n-    ///\n-    /// We call this concept an \"exclusive\" binder `D` because all\n-    /// De Bruijn indices within the type are contained within `0..D`\n-    /// (exclusive).\n-    outer_exclusive_binder: ty::DebruijnIndex,\n-}\n-\n-/// Use this rather than `TyS`, whenever possible.\n+/// Use this rather than `TyKind`, whenever possible.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n #[rustc_diagnostic_item = \"Ty\"]\n #[rustc_pass_by_value]\n-pub struct Ty<'tcx>(Interned<'tcx, WithStableHash<TyS<'tcx>>>);\n+pub struct Ty<'tcx>(Interned<'tcx, WithCachedTypeInfo<TyKind<'tcx>>>);\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// A \"bool\" type used in rustc_mir_transform unit tests when we\n     /// have not spun up a TyCtxt.\n-    pub const BOOL_TY_FOR_UNIT_TESTING: Ty<'tcx> = Ty(Interned::new_unchecked(&WithStableHash {\n-        internee: TyS {\n-            kind: ty::Bool,\n+    pub const BOOL_TY_FOR_UNIT_TESTING: Ty<'tcx> =\n+        Ty(Interned::new_unchecked(&WithCachedTypeInfo {\n+            internee: ty::Bool,\n+            stable_hash: Fingerprint::ZERO,\n             flags: TypeFlags::empty(),\n             outer_exclusive_binder: DebruijnIndex::from_usize(0),\n-        },\n-        stable_hash: Fingerprint::ZERO,\n-    }));\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n-    #[inline]\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let TyS {\n-            kind,\n-\n-            // The other fields just provide fast access to information that is\n-            // also contained in `kind`, so no need to hash them.\n-            flags: _,\n-\n-            outer_exclusive_binder: _,\n-        } = self;\n-\n-        kind.hash_stable(hcx, hasher)\n-    }\n+        }));\n }\n \n impl ty::EarlyBoundRegion {\n@@ -535,28 +474,18 @@ impl ty::EarlyBoundRegion {\n     }\n }\n \n-/// Represents a predicate.\n-///\n-/// See comments on `TyS`, which apply here too (albeit for\n-/// `PredicateS`/`Predicate` rather than `TyS`/`Ty`).\n-#[derive(Debug)]\n-pub(crate) struct PredicateS<'tcx> {\n-    kind: Binder<'tcx, PredicateKind<'tcx>>,\n-    flags: TypeFlags,\n-    /// See the comment for the corresponding field of [TyS].\n-    outer_exclusive_binder: ty::DebruijnIndex,\n-}\n-\n-/// Use this rather than `PredicateS`, whenever possible.\n+/// Use this rather than `PredicateKind`, whenever possible.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, HashStable)]\n #[rustc_pass_by_value]\n-pub struct Predicate<'tcx>(Interned<'tcx, WithStableHash<PredicateS<'tcx>>>);\n+pub struct Predicate<'tcx>(\n+    Interned<'tcx, WithCachedTypeInfo<ty::Binder<'tcx, PredicateKind<'tcx>>>>,\n+);\n \n impl<'tcx> Predicate<'tcx> {\n     /// Gets the inner `Binder<'tcx, PredicateKind<'tcx>>`.\n     #[inline]\n     pub fn kind(self) -> Binder<'tcx, PredicateKind<'tcx>> {\n-        self.0.kind\n+        self.0.internee\n     }\n \n     #[inline(always)]\n@@ -631,21 +560,6 @@ impl<'tcx> Predicate<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for PredicateS<'tcx> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let PredicateS {\n-            ref kind,\n-\n-            // The other fields just provide fast access to information that is\n-            // also contained in `kind`, so no need to hash them.\n-            flags: _,\n-            outer_exclusive_binder: _,\n-        } = self;\n-\n-        kind.hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl rustc_errors::IntoDiagnosticArg for Predicate<'_> {\n     fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n         rustc_errors::DiagnosticArgValue::Str(std::borrow::Cow::Owned(self.to_string()))\n@@ -1028,7 +942,7 @@ impl<'tcx> Term<'tcx> {\n         unsafe {\n             match ptr & TAG_MASK {\n                 TYPE_TAG => TermKind::Ty(Ty(Interned::new_unchecked(\n-                    &*((ptr & !TAG_MASK) as *const WithStableHash<ty::TyS<'tcx>>),\n+                    &*((ptr & !TAG_MASK) as *const WithCachedTypeInfo<ty::TyKind<'tcx>>),\n                 ))),\n                 CONST_TAG => TermKind::Const(ty::Const(Interned::new_unchecked(\n                     &*((ptr & !TAG_MASK) as *const ty::ConstS<'tcx>),\n@@ -1072,7 +986,7 @@ impl<'tcx> TermKind<'tcx> {\n             TermKind::Ty(ty) => {\n                 // Ensure we can use the tag bits.\n                 assert_eq!(mem::align_of_val(&*ty.0.0) & TAG_MASK, 0);\n-                (TYPE_TAG, ty.0.0 as *const WithStableHash<ty::TyS<'tcx>> as usize)\n+                (TYPE_TAG, ty.0.0 as *const WithCachedTypeInfo<ty::TyKind<'tcx>> as usize)\n             }\n             TermKind::Const(ct) => {\n                 // Ensure we can use the tag bits.\n@@ -2692,8 +2606,7 @@ mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n     // tidy-alphabetical-start\n-    static_assert_size!(PredicateS<'_>, 48);\n-    static_assert_size!(TyS<'_>, 40);\n-    static_assert_size!(WithStableHash<TyS<'_>>, 56);\n+    static_assert_size!(PredicateKind<'_>, 32);\n+    static_assert_size!(WithCachedTypeInfo<TyKind<'_>>, 56);\n     // tidy-alphabetical-end\n }"}, {"sha": "9cbda95a4df7a7f1e582dadbcf021829f45791a4", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -1611,7 +1611,7 @@ impl<'tcx> Region<'tcx> {\n impl<'tcx> Ty<'tcx> {\n     #[inline(always)]\n     pub fn kind(self) -> &'tcx TyKind<'tcx> {\n-        &self.0.0.kind\n+        &self.0.0\n     }\n \n     #[inline(always)]"}, {"sha": "a1b084a5e891eca1bb2bf780597bae2fb06cbb40", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -6,10 +6,11 @@ use crate::ty::sty::{ClosureSubsts, GeneratorSubsts, InlineConstSubsts};\n use crate::ty::visit::{TypeVisitable, TypeVisitor};\n use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt};\n \n-use rustc_data_structures::intern::{Interned, WithStableHash};\n+use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_serialize::{self, Decodable, Encodable};\n+use rustc_type_ir::WithCachedTypeInfo;\n use smallvec::SmallVec;\n \n use core::intrinsics;\n@@ -84,7 +85,7 @@ impl<'tcx> GenericArgKind<'tcx> {\n             GenericArgKind::Type(ty) => {\n                 // Ensure we can use the tag bits.\n                 assert_eq!(mem::align_of_val(&*ty.0.0) & TAG_MASK, 0);\n-                (TYPE_TAG, ty.0.0 as *const WithStableHash<ty::TyS<'tcx>> as usize)\n+                (TYPE_TAG, ty.0.0 as *const WithCachedTypeInfo<ty::TyKind<'tcx>> as usize)\n             }\n             GenericArgKind::Const(ct) => {\n                 // Ensure we can use the tag bits.\n@@ -162,7 +163,7 @@ impl<'tcx> GenericArg<'tcx> {\n                     &*((ptr & !TAG_MASK) as *const ty::RegionKind<'tcx>),\n                 ))),\n                 TYPE_TAG => GenericArgKind::Type(Ty(Interned::new_unchecked(\n-                    &*((ptr & !TAG_MASK) as *const WithStableHash<ty::TyS<'tcx>>),\n+                    &*((ptr & !TAG_MASK) as *const WithCachedTypeInfo<ty::TyKind<'tcx>>),\n                 ))),\n                 CONST_TAG => GenericArgKind::Const(ty::Const(Interned::new_unchecked(\n                     &*((ptr & !TAG_MASK) as *const ty::ConstS<'tcx>),"}, {"sha": "007f3b55ec8bb156b6c53c338fdfbbfacd3641f8", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -948,20 +948,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         original_source_scope: SourceScope,\n         pattern_span: Span,\n     ) {\n-        let tcx = self.tcx;\n-        let current_root = tcx.maybe_lint_level_root_bounded(arg_hir_id, self.hir_id);\n-        let parent_root = tcx.maybe_lint_level_root_bounded(\n-            self.source_scopes[original_source_scope]\n-                .local_data\n-                .as_ref()\n-                .assert_crate_local()\n-                .lint_root,\n-            self.hir_id,\n-        );\n-        if current_root != parent_root {\n-            self.source_scope =\n-                self.new_source_scope(pattern_span, LintLevel::Explicit(current_root), None);\n-        }\n+        let parent_id = self.source_scopes[original_source_scope]\n+            .local_data\n+            .as_ref()\n+            .assert_crate_local()\n+            .lint_root;\n+        self.maybe_new_source_scope(pattern_span, None, arg_hir_id, parent_id);\n     }\n \n     fn get_unit_temp(&mut self) -> Place<'tcx> {"}, {"sha": "33f49ffdaf6403fd4ae06a43b763e86789ab567b", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -85,6 +85,7 @@ use std::mem;\n \n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n@@ -567,25 +568,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>,\n     {\n         let source_scope = self.source_scope;\n-        let tcx = self.tcx;\n         if let LintLevel::Explicit(current_hir_id) = lint_level {\n-            // Use `maybe_lint_level_root_bounded` with `root_lint_level` as a bound\n-            // to avoid adding Hir dependencies on our parents.\n-            // We estimate the true lint roots here to avoid creating a lot of source scopes.\n-\n-            let parent_root = tcx.maybe_lint_level_root_bounded(\n-                self.source_scopes[source_scope].local_data.as_ref().assert_crate_local().lint_root,\n-                self.hir_id,\n-            );\n-            let current_root = tcx.maybe_lint_level_root_bounded(current_hir_id, self.hir_id);\n-\n-            if parent_root != current_root {\n-                self.source_scope = self.new_source_scope(\n-                    region_scope.1.span,\n-                    LintLevel::Explicit(current_root),\n-                    None,\n-                );\n-            }\n+            let parent_id =\n+                self.source_scopes[source_scope].local_data.as_ref().assert_crate_local().lint_root;\n+            self.maybe_new_source_scope(region_scope.1.span, None, current_hir_id, parent_id);\n         }\n         self.push_scope(region_scope);\n         let mut block;\n@@ -758,6 +744,40 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         ))\n     }\n \n+    /// Possibly creates a new source scope if `current_root` and `parent_root`\n+    /// are different, or if -Zmaximal-hir-to-mir-coverage is enabled.\n+    pub(crate) fn maybe_new_source_scope(\n+        &mut self,\n+        span: Span,\n+        safety: Option<Safety>,\n+        current_id: HirId,\n+        parent_id: HirId,\n+    ) {\n+        let (current_root, parent_root) =\n+            if self.tcx.sess.opts.unstable_opts.maximal_hir_to_mir_coverage {\n+                // Some consumers of rustc need to map MIR locations back to HIR nodes. Currently the\n+                // the only part of rustc that tracks MIR -> HIR is the `SourceScopeLocalData::lint_root`\n+                // field that tracks lint levels for MIR locations.  Normally the number of source scopes\n+                // is limited to the set of nodes with lint annotations. The -Zmaximal-hir-to-mir-coverage\n+                // flag changes this behavior to maximize the number of source scopes, increasing the\n+                // granularity of the MIR->HIR mapping.\n+                (current_id, parent_id)\n+            } else {\n+                // Use `maybe_lint_level_root_bounded` with `self.hir_id` as a bound\n+                // to avoid adding Hir dependencies on our parents.\n+                // We estimate the true lint roots here to avoid creating a lot of source scopes.\n+                (\n+                    self.tcx.maybe_lint_level_root_bounded(current_id, self.hir_id),\n+                    self.tcx.maybe_lint_level_root_bounded(parent_id, self.hir_id),\n+                )\n+            };\n+\n+        if current_root != parent_root {\n+            let lint_level = LintLevel::Explicit(current_root);\n+            self.source_scope = self.new_source_scope(span, lint_level, safety);\n+        }\n+    }\n+\n     /// Creates a new source scope, nested in the current one.\n     pub(crate) fn new_source_scope(\n         &mut self,"}, {"sha": "1f65cc8b6096775368cd47562ecf3e55cf48ea4b", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -1548,7 +1548,13 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 .or_insert_with(|| (ln, var, vec![id_and_sp]));\n         });\n \n-        let can_remove = matches!(&pat.kind, hir::PatKind::Struct(_, _, true));\n+        let can_remove = match pat.kind {\n+            hir::PatKind::Struct(_, fields, true) => {\n+                // if all fields are shorthand, remove the struct field, otherwise, mark with _ as prefix\n+                fields.iter().all(|f| f.is_shorthand)\n+            }\n+            _ => false,\n+        };\n \n         for (_, (ln, var, hir_ids_and_spans)) in vars {\n             if self.used_on_entry(ln, var) {"}, {"sha": "8e9198b79dff7cb39284333ad0f1fe6f53e27d78", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -1382,6 +1382,9 @@ options! {\n         \"list the symbols defined by a library crate (default: no)\"),\n     macro_backtrace: bool = (false, parse_bool, [UNTRACKED],\n         \"show macro backtraces (default: no)\"),\n+    maximal_hir_to_mir_coverage: bool = (false, parse_bool, [TRACKED],\n+        \"save as much information as possible about the correspondence between MIR and HIR \\\n+        as source scopes (default: no)\"),\n     merge_functions: Option<MergeFunctions> = (None, parse_merge_functions, [TRACKED],\n         \"control the operation of the MergeFunctions LLVM pass, taking \\\n         the same values as the target option of the same name\"),"}, {"sha": "0ad1f1a0da72fb63441861d253f918f7a51987f6", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -274,7 +274,7 @@ impl Ord for DefId {\n impl PartialOrd for DefId {\n     #[inline]\n     fn partial_cmp(&self, other: &DefId) -> Option<std::cmp::Ordering> {\n-        Some(Ord::cmp(self, other))\n+        Some(self.cmp(other))\n     }\n }\n "}, {"sha": "61253845497238c664ac8116ae14f4b29be7f12f", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -165,6 +165,7 @@ symbols! {\n         Capture,\n         Center,\n         Clone,\n+        Context,\n         Continue,\n         Copy,\n         Count,\n@@ -264,7 +265,6 @@ symbols! {\n         Relaxed,\n         Release,\n         Result,\n-        ResumeTy,\n         Return,\n         Right,\n         Rust,\n@@ -754,7 +754,6 @@ symbols! {\n         generic_associated_types_extended,\n         generic_const_exprs,\n         generic_param_attrs,\n-        get_context,\n         global_allocator,\n         global_asm,\n         globs,"}, {"sha": "e3f7a1bd033cea39b7ed706a45ed49ce7e8474e6", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -19,9 +19,11 @@ use std::mem::discriminant;\n \n pub mod codec;\n pub mod sty;\n+pub mod ty_info;\n \n pub use codec::*;\n pub use sty::*;\n+pub use ty_info::*;\n \n /// Needed so we can use #[derive(HashStable_Generic)]\n pub trait HashStableContext {}"}, {"sha": "3ed616d709b1edf4e1b38933c8002417eea0fb67", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 212, "deletions": 370, "changes": 582, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -301,61 +301,44 @@ impl<I: Interner> Clone for TyKind<I> {\n impl<I: Interner> PartialEq for TyKind<I> {\n     #[inline]\n     fn eq(&self, other: &TyKind<I>) -> bool {\n-        let __self_vi = tykind_discriminant(self);\n-        let __arg_1_vi = tykind_discriminant(other);\n-        if __self_vi == __arg_1_vi {\n-            match (&*self, &*other) {\n-                (&Int(ref __self_0), &Int(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Uint(ref __self_0), &Uint(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Float(ref __self_0), &Float(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Adt(ref __self_0, ref __self_1), &Adt(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+        tykind_discriminant(self) == tykind_discriminant(other)\n+            && match (self, other) {\n+                (Int(a_i), Int(b_i)) => a_i == b_i,\n+                (Uint(a_u), Uint(b_u)) => a_u == b_u,\n+                (Float(a_f), Float(b_f)) => a_f == b_f,\n+                (Adt(a_d, a_s), Adt(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+                (Foreign(a_d), Foreign(b_d)) => a_d == b_d,\n+                (Array(a_t, a_c), Array(b_t, b_c)) => a_t == b_t && a_c == b_c,\n+                (Slice(a_t), Slice(b_t)) => a_t == b_t,\n+                (RawPtr(a_t), RawPtr(b_t)) => a_t == b_t,\n+                (Ref(a_r, a_t, a_m), Ref(b_r, b_t, b_m)) => a_r == b_r && a_t == b_t && a_m == b_m,\n+                (FnDef(a_d, a_s), FnDef(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+                (FnPtr(a_s), FnPtr(b_s)) => a_s == b_s,\n+                (Dynamic(a_p, a_r, a_repr), Dynamic(b_p, b_r, b_repr)) => {\n+                    a_p == b_p && a_r == b_r && a_repr == b_repr\n                 }\n-                (&Foreign(ref __self_0), &Foreign(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Array(ref __self_0, ref __self_1), &Array(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                (Closure(a_d, a_s), Closure(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+                (Generator(a_d, a_s, a_m), Generator(b_d, b_s, b_m)) => {\n+                    a_d == b_d && a_s == b_s && a_m == b_m\n                 }\n-                (&Slice(ref __self_0), &Slice(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&RawPtr(ref __self_0), &RawPtr(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (\n-                    &Ref(ref __self_0, ref __self_1, ref __self_2),\n-                    &Ref(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n-                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1 && __self_2 == __arg_1_2,\n-                (&FnDef(ref __self_0, ref __self_1), &FnDef(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g == b_g,\n+                (Tuple(a_t), Tuple(b_t)) => a_t == b_t,\n+                (Projection(a_p), Projection(b_p)) => a_p == b_p,\n+                (Opaque(a_d, a_s), Opaque(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+                (Param(a_p), Param(b_p)) => a_p == b_p,\n+                (Bound(a_d, a_b), Bound(b_d, b_b)) => a_d == b_d && a_b == b_b,\n+                (Placeholder(a_p), Placeholder(b_p)) => a_p == b_p,\n+                (Infer(a_t), Infer(b_t)) => a_t == b_t,\n+                (Error(a_e), Error(b_e)) => a_e == b_e,\n+                (Bool, Bool) | (Char, Char) | (Str, Str) | (Never, Never) => true,\n+                _ => {\n+                    debug_assert!(\n+                        false,\n+                        \"This branch must be unreachable, maybe the match is missing an arm? self = self = {self:?}, other = {other:?}\"\n+                    );\n+                    true\n                 }\n-                (&FnPtr(ref __self_0), &FnPtr(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (\n-                    &Dynamic(ref __self_0, ref __self_1, ref self_repr),\n-                    &Dynamic(ref __arg_1_0, ref __arg_1_1, ref arg_repr),\n-                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1 && self_repr == arg_repr,\n-                (&Closure(ref __self_0, ref __self_1), &Closure(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n-                }\n-                (\n-                    &Generator(ref __self_0, ref __self_1, ref __self_2),\n-                    &Generator(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n-                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1 && __self_2 == __arg_1_2,\n-                (&GeneratorWitness(ref __self_0), &GeneratorWitness(ref __arg_1_0)) => {\n-                    __self_0 == __arg_1_0\n-                }\n-                (&Tuple(ref __self_0), &Tuple(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Projection(ref __self_0), &Projection(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Opaque(ref __self_0, ref __self_1), &Opaque(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n-                }\n-                (&Param(ref __self_0), &Param(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Bound(ref __self_0, ref __self_1), &Bound(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n-                }\n-                (&Placeholder(ref __self_0), &Placeholder(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Infer(ref __self_0), &Infer(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Error(ref __self_0), &Error(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                _ => true,\n             }\n-        } else {\n-            false\n-        }\n     }\n }\n \n@@ -366,259 +349,149 @@ impl<I: Interner> Eq for TyKind<I> {}\n impl<I: Interner> PartialOrd for TyKind<I> {\n     #[inline]\n     fn partial_cmp(&self, other: &TyKind<I>) -> Option<Ordering> {\n-        Some(Ord::cmp(self, other))\n+        Some(self.cmp(other))\n     }\n }\n \n // This is manually implemented because a derive would require `I: Ord`\n impl<I: Interner> Ord for TyKind<I> {\n     #[inline]\n     fn cmp(&self, other: &TyKind<I>) -> Ordering {\n-        let __self_vi = tykind_discriminant(self);\n-        let __arg_1_vi = tykind_discriminant(other);\n-        if __self_vi == __arg_1_vi {\n-            match (&*self, &*other) {\n-                (&Int(ref __self_0), &Int(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Uint(ref __self_0), &Uint(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Float(ref __self_0), &Float(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Adt(ref __self_0, ref __self_1), &Adt(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n-                }\n-                (&Foreign(ref __self_0), &Foreign(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Array(ref __self_0, ref __self_1), &Array(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n-                }\n-                (&Slice(ref __self_0), &Slice(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&RawPtr(ref __self_0), &RawPtr(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (\n-                    &Ref(ref __self_0, ref __self_1, ref __self_2),\n-                    &Ref(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n-                ) => match Ord::cmp(__self_0, __arg_1_0) {\n-                    Ordering::Equal => match Ord::cmp(__self_1, __arg_1_1) {\n-                        Ordering::Equal => Ord::cmp(__self_2, __arg_1_2),\n-                        cmp => cmp,\n-                    },\n-                    cmp => cmp,\n-                },\n-                (&FnDef(ref __self_0, ref __self_1), &FnDef(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n+        tykind_discriminant(self).cmp(&tykind_discriminant(other)).then_with(|| {\n+            match (self, other) {\n+                (Int(a_i), Int(b_i)) => a_i.cmp(b_i),\n+                (Uint(a_u), Uint(b_u)) => a_u.cmp(b_u),\n+                (Float(a_f), Float(b_f)) => a_f.cmp(b_f),\n+                (Adt(a_d, a_s), Adt(b_d, b_s)) => a_d.cmp(b_d).then_with(|| a_s.cmp(b_s)),\n+                (Foreign(a_d), Foreign(b_d)) => a_d.cmp(b_d),\n+                (Array(a_t, a_c), Array(b_t, b_c)) => a_t.cmp(b_t).then_with(|| a_c.cmp(b_c)),\n+                (Slice(a_t), Slice(b_t)) => a_t.cmp(b_t),\n+                (RawPtr(a_t), RawPtr(b_t)) => a_t.cmp(b_t),\n+                (Ref(a_r, a_t, a_m), Ref(b_r, b_t, b_m)) => {\n+                    a_r.cmp(b_r).then_with(|| a_t.cmp(b_t).then_with(|| a_m.cmp(b_m)))\n                 }\n-                (&FnPtr(ref __self_0), &FnPtr(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (\n-                    &Dynamic(ref __self_0, ref __self_1, ref self_repr),\n-                    &Dynamic(ref __arg_1_0, ref __arg_1_1, ref arg_repr),\n-                ) => match Ord::cmp(__self_0, __arg_1_0) {\n-                    Ordering::Equal => match Ord::cmp(__self_1, __arg_1_1) {\n-                        Ordering::Equal => Ord::cmp(self_repr, arg_repr),\n-                        cmp => cmp,\n-                    },\n-                    cmp => cmp,\n-                },\n-                (&Closure(ref __self_0, ref __self_1), &Closure(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n+                (FnDef(a_d, a_s), FnDef(b_d, b_s)) => a_d.cmp(b_d).then_with(|| a_s.cmp(b_s)),\n+                (FnPtr(a_s), FnPtr(b_s)) => a_s.cmp(b_s),\n+                (Dynamic(a_p, a_r, a_repr), Dynamic(b_p, b_r, b_repr)) => {\n+                    a_p.cmp(b_p).then_with(|| a_r.cmp(b_r).then_with(|| a_repr.cmp(b_repr)))\n                 }\n-                (\n-                    &Generator(ref __self_0, ref __self_1, ref __self_2),\n-                    &Generator(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n-                ) => match Ord::cmp(__self_0, __arg_1_0) {\n-                    Ordering::Equal => match Ord::cmp(__self_1, __arg_1_1) {\n-                        Ordering::Equal => Ord::cmp(__self_2, __arg_1_2),\n-                        cmp => cmp,\n-                    },\n-                    cmp => cmp,\n-                },\n-                (&GeneratorWitness(ref __self_0), &GeneratorWitness(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n+                (Closure(a_p, a_s), Closure(b_p, b_s)) => a_p.cmp(b_p).then_with(|| a_s.cmp(b_s)),\n+                (Generator(a_d, a_s, a_m), Generator(b_d, b_s, b_m)) => {\n+                    a_d.cmp(b_d).then_with(|| a_s.cmp(b_s).then_with(|| a_m.cmp(b_m)))\n                 }\n-                (&Tuple(ref __self_0), &Tuple(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Projection(ref __self_0), &Projection(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n+                (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g.cmp(b_g),\n+                (Tuple(a_t), Tuple(b_t)) => a_t.cmp(b_t),\n+                (Projection(a_p), Projection(b_p)) => a_p.cmp(b_p),\n+                (Opaque(a_d, a_s), Opaque(b_d, b_s)) => a_d.cmp(b_d).then_with(|| a_s.cmp(b_s)),\n+                (Param(a_p), Param(b_p)) => a_p.cmp(b_p),\n+                (Bound(a_d, a_b), Bound(b_d, b_b)) => a_d.cmp(b_d).then_with(|| a_b.cmp(b_b)),\n+                (Placeholder(a_p), Placeholder(b_p)) => a_p.cmp(b_p),\n+                (Infer(a_t), Infer(b_t)) => a_t.cmp(b_t),\n+                (Error(a_e), Error(b_e)) => a_e.cmp(b_e),\n+                (Bool, Bool) | (Char, Char) | (Str, Str) | (Never, Never) => Ordering::Equal,\n+                _ => {\n+                    debug_assert!(false, \"This branch must be unreachable, maybe the match is missing an arm? self = self = {self:?}, other = {other:?}\");\n+                    Ordering::Equal\n                 }\n-                (&Opaque(ref __self_0, ref __self_1), &Opaque(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n-                }\n-                (&Param(ref __self_0), &Param(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Bound(ref __self_0, ref __self_1), &Bound(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n-                }\n-                (&Placeholder(ref __self_0), &Placeholder(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n-                }\n-                (&Infer(ref __self_0), &Infer(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Error(ref __self_0), &Error(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                _ => Ordering::Equal,\n             }\n-        } else {\n-            Ord::cmp(&__self_vi, &__arg_1_vi)\n-        }\n+        })\n     }\n }\n \n // This is manually implemented because a derive would require `I: Hash`\n impl<I: Interner> hash::Hash for TyKind<I> {\n     fn hash<__H: hash::Hasher>(&self, state: &mut __H) -> () {\n-        match (&*self,) {\n-            (&Int(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Uint(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Float(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Adt(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Foreign(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Array(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Slice(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&RawPtr(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Ref(ref __self_0, ref __self_1, ref __self_2),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state);\n-                hash::Hash::hash(__self_2, state)\n-            }\n-            (&FnDef(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&FnPtr(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Dynamic(ref __self_0, ref __self_1, ref repr),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state);\n-                hash::Hash::hash(repr, state)\n-            }\n-            (&Closure(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Generator(ref __self_0, ref __self_1, ref __self_2),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state);\n-                hash::Hash::hash(__self_2, state)\n-            }\n-            (&GeneratorWitness(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Tuple(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Projection(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Opaque(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Param(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Bound(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Placeholder(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Infer(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n+        tykind_discriminant(self).hash(state);\n+        match self {\n+            Int(i) => i.hash(state),\n+            Uint(u) => u.hash(state),\n+            Float(f) => f.hash(state),\n+            Adt(d, s) => {\n+                d.hash(state);\n+                s.hash(state)\n+            }\n+            Foreign(d) => d.hash(state),\n+            Array(t, c) => {\n+                t.hash(state);\n+                c.hash(state)\n             }\n-            (&Error(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n+            Slice(t) => t.hash(state),\n+            RawPtr(t) => t.hash(state),\n+            Ref(r, t, m) => {\n+                r.hash(state);\n+                t.hash(state);\n+                m.hash(state)\n+            }\n+            FnDef(d, s) => {\n+                d.hash(state);\n+                s.hash(state)\n+            }\n+            FnPtr(s) => s.hash(state),\n+            Dynamic(p, r, repr) => {\n+                p.hash(state);\n+                r.hash(state);\n+                repr.hash(state)\n+            }\n+            Closure(d, s) => {\n+                d.hash(state);\n+                s.hash(state)\n+            }\n+            Generator(d, s, m) => {\n+                d.hash(state);\n+                s.hash(state);\n+                m.hash(state)\n+            }\n+            GeneratorWitness(g) => g.hash(state),\n+            Tuple(t) => t.hash(state),\n+            Projection(p) => p.hash(state),\n+            Opaque(d, s) => {\n+                d.hash(state);\n+                s.hash(state)\n+            }\n+            Param(p) => p.hash(state),\n+            Bound(d, b) => {\n+                d.hash(state);\n+                b.hash(state)\n             }\n-            _ => hash::Hash::hash(&tykind_discriminant(self), state),\n+            Placeholder(p) => p.hash(state),\n+            Infer(t) => t.hash(state),\n+            Error(e) => e.hash(state),\n+            Bool | Char | Str | Never => (),\n         }\n     }\n }\n \n // This is manually implemented because a derive would require `I: Debug`\n impl<I: Interner> fmt::Debug for TyKind<I> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use std::fmt::*;\n         match self {\n-            Bool => Formatter::write_str(f, \"Bool\"),\n-            Char => Formatter::write_str(f, \"Char\"),\n-            Int(f0) => Formatter::debug_tuple_field1_finish(f, \"Int\", f0),\n-            Uint(f0) => Formatter::debug_tuple_field1_finish(f, \"Uint\", f0),\n-            Float(f0) => Formatter::debug_tuple_field1_finish(f, \"Float\", f0),\n-            Adt(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Adt\", f0, f1),\n-            Foreign(f0) => Formatter::debug_tuple_field1_finish(f, \"Foreign\", f0),\n-            Str => Formatter::write_str(f, \"Str\"),\n-            Array(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Array\", f0, f1),\n-            Slice(f0) => Formatter::debug_tuple_field1_finish(f, \"Slice\", f0),\n-            RawPtr(f0) => Formatter::debug_tuple_field1_finish(f, \"RawPtr\", f0),\n-            Ref(f0, f1, f2) => Formatter::debug_tuple_field3_finish(f, \"Ref\", f0, f1, f2),\n-            FnDef(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"FnDef\", f0, f1),\n-            FnPtr(f0) => Formatter::debug_tuple_field1_finish(f, \"FnPtr\", f0),\n-            Dynamic(f0, f1, f2) => Formatter::debug_tuple_field3_finish(f, \"Dynamic\", f0, f1, f2),\n-            Closure(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Closure\", f0, f1),\n-            Generator(f0, f1, f2) => {\n-                Formatter::debug_tuple_field3_finish(f, \"Generator\", f0, f1, f2)\n-            }\n-            GeneratorWitness(f0) => Formatter::debug_tuple_field1_finish(f, \"GeneratorWitness\", f0),\n-            Never => Formatter::write_str(f, \"Never\"),\n-            Tuple(f0) => Formatter::debug_tuple_field1_finish(f, \"Tuple\", f0),\n-            Projection(f0) => Formatter::debug_tuple_field1_finish(f, \"Projection\", f0),\n-            Opaque(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Opaque\", f0, f1),\n-            Param(f0) => Formatter::debug_tuple_field1_finish(f, \"Param\", f0),\n-            Bound(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Bound\", f0, f1),\n-            Placeholder(f0) => Formatter::debug_tuple_field1_finish(f, \"Placeholder\", f0),\n-            Infer(f0) => Formatter::debug_tuple_field1_finish(f, \"Infer\", f0),\n-            TyKind::Error(f0) => Formatter::debug_tuple_field1_finish(f, \"Error\", f0),\n+            Bool => f.write_str(\"Bool\"),\n+            Char => f.write_str(\"Char\"),\n+            Int(i) => f.debug_tuple_field1_finish(\"Int\", i),\n+            Uint(u) => f.debug_tuple_field1_finish(\"Uint\", u),\n+            Float(float) => f.debug_tuple_field1_finish(\"Float\", float),\n+            Adt(d, s) => f.debug_tuple_field2_finish(\"Adt\", d, s),\n+            Foreign(d) => f.debug_tuple_field1_finish(\"Foreign\", d),\n+            Str => f.write_str(\"Str\"),\n+            Array(t, c) => f.debug_tuple_field2_finish(\"Array\", t, c),\n+            Slice(t) => f.debug_tuple_field1_finish(\"Slice\", t),\n+            RawPtr(t) => f.debug_tuple_field1_finish(\"RawPtr\", t),\n+            Ref(r, t, m) => f.debug_tuple_field3_finish(\"Ref\", r, t, m),\n+            FnDef(d, s) => f.debug_tuple_field2_finish(\"FnDef\", d, s),\n+            FnPtr(s) => f.debug_tuple_field1_finish(\"FnPtr\", s),\n+            Dynamic(p, r, repr) => f.debug_tuple_field3_finish(\"Dynamic\", p, r, repr),\n+            Closure(d, s) => f.debug_tuple_field2_finish(\"Closure\", d, s),\n+            Generator(d, s, m) => f.debug_tuple_field3_finish(\"Generator\", d, s, m),\n+            GeneratorWitness(g) => f.debug_tuple_field1_finish(\"GeneratorWitness\", g),\n+            Never => f.write_str(\"Never\"),\n+            Tuple(t) => f.debug_tuple_field1_finish(\"Tuple\", t),\n+            Projection(p) => f.debug_tuple_field1_finish(\"Projection\", p),\n+            Opaque(d, s) => f.debug_tuple_field2_finish(\"Opaque\", d, s),\n+            Param(p) => f.debug_tuple_field1_finish(\"Param\", p),\n+            Bound(d, b) => f.debug_tuple_field2_finish(\"Bound\", d, b),\n+            Placeholder(p) => f.debug_tuple_field1_finish(\"Placeholder\", p),\n+            Infer(t) => f.debug_tuple_field1_finish(\"Infer\", t),\n+            TyKind::Error(e) => f.debug_tuple_field1_finish(\"Error\", e),\n         }\n     }\n }\n@@ -1091,12 +964,12 @@ where\n impl<I: Interner> Clone for RegionKind<I> {\n     fn clone(&self) -> Self {\n         match self {\n-            ReEarlyBound(a) => ReEarlyBound(a.clone()),\n-            ReLateBound(a, b) => ReLateBound(a.clone(), b.clone()),\n-            ReFree(a) => ReFree(a.clone()),\n+            ReEarlyBound(r) => ReEarlyBound(r.clone()),\n+            ReLateBound(d, r) => ReLateBound(d.clone(), r.clone()),\n+            ReFree(r) => ReFree(r.clone()),\n             ReStatic => ReStatic,\n-            ReVar(a) => ReVar(a.clone()),\n-            RePlaceholder(a) => RePlaceholder(a.clone()),\n+            ReVar(r) => ReVar(r.clone()),\n+            RePlaceholder(r) => RePlaceholder(r.clone()),\n             ReErased => ReErased,\n         }\n     }\n@@ -1106,29 +979,23 @@ impl<I: Interner> Clone for RegionKind<I> {\n impl<I: Interner> PartialEq for RegionKind<I> {\n     #[inline]\n     fn eq(&self, other: &RegionKind<I>) -> bool {\n-        let __self_vi = regionkind_discriminant(self);\n-        let __arg_1_vi = regionkind_discriminant(other);\n-        if __self_vi == __arg_1_vi {\n-            match (&*self, &*other) {\n-                (&ReEarlyBound(ref __self_0), &ReEarlyBound(ref __arg_1_0)) => {\n-                    __self_0 == __arg_1_0\n+        regionkind_discriminant(self) == regionkind_discriminant(other)\n+            && match (self, other) {\n+                (ReEarlyBound(a_r), ReEarlyBound(b_r)) => a_r == b_r,\n+                (ReLateBound(a_d, a_r), ReLateBound(b_d, b_r)) => a_d == b_d && a_r == b_r,\n+                (ReFree(a_r), ReFree(b_r)) => a_r == b_r,\n+                (ReStatic, ReStatic) => true,\n+                (ReVar(a_r), ReVar(b_r)) => a_r == b_r,\n+                (RePlaceholder(a_r), RePlaceholder(b_r)) => a_r == b_r,\n+                (ReErased, ReErased) => true,\n+                _ => {\n+                    debug_assert!(\n+                        false,\n+                        \"This branch must be unreachable, maybe the match is missing an arm? self = self = {self:?}, other = {other:?}\"\n+                    );\n+                    true\n                 }\n-                (\n-                    &ReLateBound(ref __self_0, ref __self_1),\n-                    &ReLateBound(ref __arg_1_0, ref __arg_1_1),\n-                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1,\n-                (&ReFree(ref __self_0), &ReFree(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&ReStatic, &ReStatic) => true,\n-                (&ReVar(ref __self_0), &ReVar(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&RePlaceholder(ref __self_0), &RePlaceholder(ref __arg_1_0)) => {\n-                    __self_0 == __arg_1_0\n-                }\n-                (&ReErased, &ReErased) => true,\n-                _ => true,\n             }\n-        } else {\n-            false\n-        }\n     }\n }\n \n@@ -1139,74 +1006,49 @@ impl<I: Interner> Eq for RegionKind<I> {}\n impl<I: Interner> PartialOrd for RegionKind<I> {\n     #[inline]\n     fn partial_cmp(&self, other: &RegionKind<I>) -> Option<Ordering> {\n-        Some(Ord::cmp(self, other))\n+        Some(self.cmp(other))\n     }\n }\n \n // This is manually implemented because a derive would require `I: Ord`\n impl<I: Interner> Ord for RegionKind<I> {\n     #[inline]\n     fn cmp(&self, other: &RegionKind<I>) -> Ordering {\n-        let __self_vi = regionkind_discriminant(self);\n-        let __arg_1_vi = regionkind_discriminant(other);\n-        if __self_vi == __arg_1_vi {\n-            match (&*self, &*other) {\n-                (&ReEarlyBound(ref __self_0), &ReEarlyBound(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n+        regionkind_discriminant(self).cmp(&regionkind_discriminant(other)).then_with(|| {\n+            match (self, other) {\n+                (ReEarlyBound(a_r), ReEarlyBound(b_r)) => a_r.cmp(b_r),\n+                (ReLateBound(a_d, a_r), ReLateBound(b_d, b_r)) => {\n+                    a_d.cmp(b_d).then_with(|| a_r.cmp(b_r))\n                 }\n-                (\n-                    &ReLateBound(ref __self_0, ref __self_1),\n-                    &ReLateBound(ref __arg_1_0, ref __arg_1_1),\n-                ) => match Ord::cmp(__self_0, __arg_1_0) {\n-                    Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                    cmp => cmp,\n-                },\n-                (&ReFree(ref __self_0), &ReFree(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&ReStatic, &ReStatic) => Ordering::Equal,\n-                (&ReVar(ref __self_0), &ReVar(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&RePlaceholder(ref __self_0), &RePlaceholder(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n+                (ReFree(a_r), ReFree(b_r)) => a_r.cmp(b_r),\n+                (ReStatic, ReStatic) => Ordering::Equal,\n+                (ReVar(a_r), ReVar(b_r)) => a_r.cmp(b_r),\n+                (RePlaceholder(a_r), RePlaceholder(b_r)) => a_r.cmp(b_r),\n+                (ReErased, ReErased) => Ordering::Equal,\n+                _ => {\n+                    debug_assert!(false, \"This branch must be unreachable, maybe the match is missing an arm? self = self = {self:?}, other = {other:?}\");\n+                    Ordering::Equal\n                 }\n-                (&ReErased, &ReErased) => Ordering::Equal,\n-                _ => Ordering::Equal,\n             }\n-        } else {\n-            Ord::cmp(&__self_vi, &__arg_1_vi)\n-        }\n+        })\n     }\n }\n \n // This is manually implemented because a derive would require `I: Hash`\n impl<I: Interner> hash::Hash for RegionKind<I> {\n-    fn hash<__H: hash::Hasher>(&self, state: &mut __H) -> () {\n-        match (&*self,) {\n-            (&ReEarlyBound(ref __self_0),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&ReLateBound(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&ReFree(ref __self_0),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&ReStatic,) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-            }\n-            (&ReVar(ref __self_0),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&RePlaceholder(ref __self_0),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&ReErased,) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-            }\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) -> () {\n+        regionkind_discriminant(self).hash(state);\n+        match self {\n+            ReEarlyBound(r) => r.hash(state),\n+            ReLateBound(d, r) => {\n+                d.hash(state);\n+                r.hash(state)\n+            }\n+            ReFree(r) => r.hash(state),\n+            ReStatic => (),\n+            ReVar(r) => r.hash(state),\n+            RePlaceholder(r) => r.hash(state),\n+            ReErased => (),\n         }\n     }\n }\n@@ -1215,21 +1057,21 @@ impl<I: Interner> hash::Hash for RegionKind<I> {\n impl<I: Interner> fmt::Debug for RegionKind<I> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            ReEarlyBound(ref data) => write!(f, \"ReEarlyBound({:?})\", data),\n+            ReEarlyBound(data) => write!(f, \"ReEarlyBound({:?})\", data),\n \n-            ReLateBound(binder_id, ref bound_region) => {\n+            ReLateBound(binder_id, bound_region) => {\n                 write!(f, \"ReLateBound({:?}, {:?})\", binder_id, bound_region)\n             }\n \n-            ReFree(ref fr) => fr.fmt(f),\n+            ReFree(fr) => fr.fmt(f),\n \n-            ReStatic => write!(f, \"ReStatic\"),\n+            ReStatic => f.write_str(\"ReStatic\"),\n \n-            ReVar(ref vid) => vid.fmt(f),\n+            ReVar(vid) => vid.fmt(f),\n \n             RePlaceholder(placeholder) => write!(f, \"RePlaceholder({:?})\", placeholder),\n \n-            ReErased => write!(f, \"ReErased\"),\n+            ReErased => f.write_str(\"ReErased\"),\n         }\n     }\n }\n@@ -1317,18 +1159,18 @@ where\n             ReErased | ReStatic => {\n                 // No variant fields to hash for these ...\n             }\n-            ReLateBound(db, br) => {\n-                db.hash_stable(hcx, hasher);\n-                br.hash_stable(hcx, hasher);\n+            ReLateBound(d, r) => {\n+                d.hash_stable(hcx, hasher);\n+                r.hash_stable(hcx, hasher);\n             }\n-            ReEarlyBound(eb) => {\n-                eb.hash_stable(hcx, hasher);\n+            ReEarlyBound(r) => {\n+                r.hash_stable(hcx, hasher);\n             }\n-            ReFree(ref free_region) => {\n-                free_region.hash_stable(hcx, hasher);\n+            ReFree(r) => {\n+                r.hash_stable(hcx, hasher);\n             }\n-            RePlaceholder(p) => {\n-                p.hash_stable(hcx, hasher);\n+            RePlaceholder(r) => {\n+                r.hash_stable(hcx, hasher);\n             }\n             ReVar(_) => {\n                 panic!(\"region variables should not be hashed: {self:?}\")"}, {"sha": "4e5d424886ad8017e91627f310d848e3288a59ee", "filename": "compiler/rustc_type_ir/src/ty_info.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_type_ir%2Fsrc%2Fty_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/compiler%2Frustc_type_ir%2Fsrc%2Fty_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fty_info.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -0,0 +1,122 @@\n+use std::{\n+    cmp::Ordering,\n+    hash::{Hash, Hasher},\n+    ops::Deref,\n+};\n+\n+use rustc_data_structures::{\n+    fingerprint::Fingerprint,\n+    stable_hasher::{HashStable, StableHasher},\n+};\n+\n+use crate::{DebruijnIndex, TypeFlags};\n+\n+/// A helper type that you can wrap round your own type in order to automatically\n+/// cache the stable hash, type flags and debruijn index on creation and\n+/// not recompute it whenever the information is needed.\n+/// This is only done in incremental mode. You can also opt out of caching by using\n+/// StableHash::ZERO for the hash, in which case the hash gets computed each time.\n+/// This is useful if you have values that you intern but never (can?) use for stable\n+/// hashing.\n+#[derive(Copy, Clone)]\n+pub struct WithCachedTypeInfo<T> {\n+    pub internee: T,\n+    pub stable_hash: Fingerprint,\n+\n+    /// This field provides fast access to information that is also contained\n+    /// in `kind`.\n+    ///\n+    /// This field shouldn't be used directly and may be removed in the future.\n+    /// Use `Ty::flags()` instead.\n+    pub flags: TypeFlags,\n+\n+    /// This field provides fast access to information that is also contained\n+    /// in `kind`.\n+    ///\n+    /// This is a kind of confusing thing: it stores the smallest\n+    /// binder such that\n+    ///\n+    /// (a) the binder itself captures nothing but\n+    /// (b) all the late-bound things within the type are captured\n+    ///     by some sub-binder.\n+    ///\n+    /// So, for a type without any late-bound things, like `u32`, this\n+    /// will be *innermost*, because that is the innermost binder that\n+    /// captures nothing. But for a type `&'D u32`, where `'D` is a\n+    /// late-bound region with De Bruijn index `D`, this would be `D + 1`\n+    /// -- the binder itself does not capture `D`, but `D` is captured\n+    /// by an inner binder.\n+    ///\n+    /// We call this concept an \"exclusive\" binder `D` because all\n+    /// De Bruijn indices within the type are contained within `0..D`\n+    /// (exclusive).\n+    pub outer_exclusive_binder: DebruijnIndex,\n+}\n+\n+impl<T: PartialEq> PartialEq for WithCachedTypeInfo<T> {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.internee.eq(&other.internee)\n+    }\n+}\n+\n+impl<T: Eq> Eq for WithCachedTypeInfo<T> {}\n+\n+impl<T: Ord> PartialOrd for WithCachedTypeInfo<T> {\n+    fn partial_cmp(&self, other: &WithCachedTypeInfo<T>) -> Option<Ordering> {\n+        Some(self.internee.cmp(&other.internee))\n+    }\n+}\n+\n+impl<T: Ord> Ord for WithCachedTypeInfo<T> {\n+    fn cmp(&self, other: &WithCachedTypeInfo<T>) -> Ordering {\n+        self.internee.cmp(&other.internee)\n+    }\n+}\n+\n+impl<T> Deref for WithCachedTypeInfo<T> {\n+    type Target = T;\n+\n+    #[inline]\n+    fn deref(&self) -> &T {\n+        &self.internee\n+    }\n+}\n+\n+impl<T: Hash> Hash for WithCachedTypeInfo<T> {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        if self.stable_hash != Fingerprint::ZERO {\n+            self.stable_hash.hash(s)\n+        } else {\n+            self.internee.hash(s)\n+        }\n+    }\n+}\n+\n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for WithCachedTypeInfo<T> {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        if self.stable_hash == Fingerprint::ZERO || cfg!(debug_assertions) {\n+            // No cached hash available. This can only mean that incremental is disabled.\n+            // We don't cache stable hashes in non-incremental mode, because they are used\n+            // so rarely that the performance actually suffers.\n+\n+            // We need to build the hash as if we cached it and then hash that hash, as\n+            // otherwise the hashes will differ between cached and non-cached mode.\n+            let stable_hash: Fingerprint = {\n+                let mut hasher = StableHasher::new();\n+                self.internee.hash_stable(hcx, &mut hasher);\n+                hasher.finish()\n+            };\n+            if cfg!(debug_assertions) && self.stable_hash != Fingerprint::ZERO {\n+                assert_eq!(\n+                    stable_hash, self.stable_hash,\n+                    \"cached stable hash does not match freshly computed stable hash\"\n+                );\n+            }\n+            stable_hash.hash_stable(hcx, hasher);\n+        } else {\n+            self.stable_hash.hash_stable(hcx, hasher);\n+        }\n+    }\n+}"}, {"sha": "2a8e12fd4cf60fcc2bbc8aa749c500a6229f009c", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -44,7 +44,7 @@ pub use poll_fn::{poll_fn, PollFn};\n ///    non-Send/Sync as well, and we don't want that.\n ///\n /// It also simplifies the HIR lowering of `.await`.\n-#[cfg_attr(not(bootstrap), lang = \"ResumeTy\")]\n+// FIXME(swatinem): This type can be removed when bumping the bootstrap compiler\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[derive(Debug, Copy, Clone)]\n@@ -61,6 +61,7 @@ unsafe impl Sync for ResumeTy {}\n /// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n /// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n // This is `const` to avoid extra errors after we recover from `const async fn`\n+// FIXME(swatinem): This fn can be removed when bumping the bootstrap compiler\n #[cfg_attr(bootstrap, lang = \"from_generator\")]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n@@ -102,7 +103,8 @@ where\n     GenFuture(gen)\n }\n \n-#[lang = \"get_context\"]\n+// FIXME(swatinem): This fn can be removed when bumping the bootstrap compiler\n+#[cfg_attr(bootstrap, lang = \"get_context\")]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[must_use]\n@@ -113,6 +115,10 @@ pub unsafe fn get_context<'a, 'b>(cx: ResumeTy) -> &'a mut Context<'b> {\n     unsafe { &mut *cx.0.as_ptr().cast() }\n }\n \n+// FIXME(swatinem): This fn is currently needed to work around shortcomings\n+// in type and lifetime inference.\n+// See the comment at the bottom of `LoweringContext::make_async_expr` and\n+// <https://github.com/rust-lang/rust/issues/104826>.\n #[cfg_attr(not(bootstrap), lang = \"identity_future\")]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]"}, {"sha": "9ab9b0ba1c79739548fc891ba34d5d0f33bb82dc", "filename": "library/core/src/task/wake.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -174,6 +174,7 @@ impl RawWakerVTable {\n /// Currently, `Context` only serves to provide access to a [`&Waker`](Waker)\n /// which can be used to wake the current task.\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+#[cfg_attr(not(bootstrap), lang = \"Context\")]\n pub struct Context<'a> {\n     waker: &'a Waker,\n     // Ensure we future-proof against variance changes by forcing"}, {"sha": "0cd15768ac6e850abfa62f40c5f61c7aeecec3f1", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -195,8 +195,7 @@ h1, h2, h3, h4, h5, h6,\n span.since,\n a.srclink,\n #help-button > a,\n-details.rustdoc-toggle.top-doc > summary,\n-details.rustdoc-toggle.non-exhaustive > summary,\n+summary.hideme,\n .scraped-example-list,\n /* This selector is for the items listed in the \"all items\" page. */\n ul.all-items {\n@@ -1484,6 +1483,7 @@ details.rustdoc-toggle {\n \t\"Expand description\" or \"Show methods\". */\n details.rustdoc-toggle > summary.hideme {\n \tcursor: pointer;\n+\tfont-size: 1rem;\n }\n \n details.rustdoc-toggle > summary {\n@@ -1546,13 +1546,6 @@ details.rustdoc-toggle > summary:focus-visible::before {\n \toutline-offset: 1px;\n }\n \n-details.rustdoc-toggle.top-doc > summary,\n-details.rustdoc-toggle.top-doc > summary::before,\n-details.rustdoc-toggle.non-exhaustive > summary,\n-details.rustdoc-toggle.non-exhaustive > summary::before {\n-\tfont-size: 1rem;\n-}\n-\n details.non-exhaustive {\n \tmargin-bottom: 8px;\n }"}, {"sha": "8dfc49285f2eb6695818d2d5a6090a3728ba3349", "filename": "src/test/rustdoc-gui/enum-variants.goml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Frustdoc-gui%2Fenum-variants.goml", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Frustdoc-gui%2Fenum-variants.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fenum-variants.goml?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -3,3 +3,8 @@ goto: \"file://\" + |DOC_PATH| + \"/test_docs/enum.WhoLetTheDogOut.html\"\n \n assert-css: (\".variants > .variant\", {\"margin\": \"0px 0px 12px\"})\n assert-css: (\".variants > .docblock\", {\"margin\": \"0px 0px 32px 24px\"})\n+\n+assert-css: (\n+    \"details.non-exhaustive > summary\",\n+    {\"font-family\": '\"Fira Sans\", Arial, NanumBarunGothic, sans-serif'},\n+)"}, {"sha": "1340511d4726b381b6ca4a118d2caf5dc1d4f91f", "filename": "src/test/rustdoc-gui/src/test_docs/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -76,6 +76,7 @@ impl AsRef<str> for Foo {\n ///\n /// # title!\n #[doc(alias = \"ThisIsAnAlias\")]\n+#[non_exhaustive]\n pub enum WhoLetTheDogOut {\n     /// Woof!\n     Woof,"}, {"sha": "45bb8daf1f20c575bc4bb0414e8c664b44a4b73b", "filename": "src/test/rustdoc-gui/toggle-docs.goml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs.goml", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs.goml?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -7,6 +7,10 @@ wait-for: 50\n // This is now collapsed so there shouldn't be the \"open\" attribute on details.\n assert-attribute-false: (\"#main-content > details.top-doc\", {\"open\": \"\"})\n assert-text: (\"#toggle-all-docs\", \"[+]\")\n+assert-css: (\n+    \"#main-content > details.top-doc > summary\",\n+    {\"font-family\": '\"Fira Sans\", Arial, NanumBarunGothic, sans-serif'},\n+)\n click: \"#toggle-all-docs\"\n // Not collapsed anymore so the \"open\" attribute should be back.\n wait-for-attribute: (\"#main-content > details.top-doc\", {\"open\": \"\"})"}, {"sha": "94cf7b94241df8d79144969b852f538de8ccfa88", "filename": "src/test/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -77,6 +77,7 @@\n     -Z                         location-detail=val -- what location details should be tracked when using caller_location, either `none`, or a comma separated list of location details, for which valid options are `file`, `line`, and `column` (default: `file,line,column`)\n     -Z                                      ls=val -- list the symbols defined by a library crate (default: no)\n     -Z                         macro-backtrace=val -- show macro backtraces (default: no)\n+    -Z             maximal-hir-to-mir-coverage=val -- save as much information as possible about the correspondence between MIR and HIR as source scopes (default: no)\n     -Z                         merge-functions=val -- control the operation of the MergeFunctions LLVM pass, taking the same values as the target option of the same name\n     -Z                              meta-stats=val -- gather metadata statistics (default: no)\n     -Z                          mir-emit-retag=val -- emit Retagging MIR statements, interpreted e.g., by miri; implies -Zmir-opt-level=0 (default: no)"}, {"sha": "616623ee07759eeabd7c7fb4dc211d435aedd462", "filename": "src/test/ui/async-await/async-await-let-else.drop-tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.drop-tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.drop-tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.drop-tracking.stderr?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -40,7 +40,7 @@ LL |   async fn bar2<T>(_: T) -> ! {\n LL | |     panic!()\n LL | | }\n    | |_^\n-   = note: required because it captures the following types: `ResumeTy`, `Option<bool>`, `impl Future<Output = !>`, `()`\n+   = note: required because it captures the following types: `&mut Context<'_>`, `Option<bool>`, `impl Future<Output = !>`, `()`\n note: required because it's used within this `async fn` body\n   --> $DIR/async-await-let-else.rs:21:32\n    |"}, {"sha": "1c90bedae790c66259bc6c47e956ebb90907e003", "filename": "src/test/ui/async-await/issue-68112.drop_tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.drop_tracking.stderr?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -57,7 +57,7 @@ note: required because it appears within the type `impl Future<Output = Arc<RefC\n    |\n LL | fn make_non_send_future2() -> impl Future<Output = Arc<RefCell<i32>>> {\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: required because it captures the following types: `ResumeTy`, `impl Future<Output = Arc<RefCell<i32>>>`, `()`, `Ready<i32>`\n+   = note: required because it captures the following types: `&mut Context<'_>`, `impl Future<Output = Arc<RefCell<i32>>>`, `()`, `Ready<i32>`\n note: required because it's used within this `async` block\n   --> $DIR/issue-68112.rs:60:20\n    |"}, {"sha": "e09ae7fedd8055f1f636f711bbe1fdd619048213", "filename": "src/test/ui/async-await/issue-68112.no_drop_tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.no_drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.no_drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.no_drop_tracking.stderr?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -57,7 +57,7 @@ note: required because it appears within the type `impl Future<Output = Arc<RefC\n    |\n LL | fn make_non_send_future2() -> impl Future<Output = Arc<RefCell<i32>>> {\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: required because it captures the following types: `ResumeTy`, `impl Future<Output = Arc<RefCell<i32>>>`, `()`, `i32`, `Ready<i32>`\n+   = note: required because it captures the following types: `&mut Context<'_>`, `impl Future<Output = Arc<RefCell<i32>>>`, `()`, `i32`, `Ready<i32>`\n note: required because it's used within this `async` block\n   --> $DIR/issue-68112.rs:60:20\n    |"}, {"sha": "e6ad2f0d444bb7e8faa44cd6cc6f4a787fc87b80", "filename": "src/test/ui/async-await/issue-69446-fnmut-capture.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.stderr?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -14,6 +14,9 @@ LL | |     });\n    |\n    = note: `FnMut` closures only have access to their captured variables while they are executing...\n    = note: ...therefore, they cannot allow references to captured variables to escape\n+   = note: requirement occurs because of a mutable reference to `Context<'_>`\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: aborting due to previous error\n "}, {"sha": "a8fd97cde8f7a8bd7b9f64c71b96179ed7658dce", "filename": "src/test/ui/async-await/issue-70935-complex-spans.drop_tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -18,7 +18,7 @@ LL |   async fn baz<T>(_c: impl FnMut() -> T) where T: Future<Output=()> {\n    |  ___________________________________________________________________^\n LL | | }\n    | |_^\n-   = note: required because it captures the following types: `ResumeTy`, `impl Future<Output = ()>`, `()`\n+   = note: required because it captures the following types: `&mut Context<'_>`, `impl Future<Output = ()>`, `()`\n note: required because it's used within this `async` block\n   --> $DIR/issue-70935-complex-spans.rs:16:5\n    |"}, {"sha": "25876d5084015f6720a31293c78bce0bb7c67a77", "filename": "src/test/ui/async-await/partial-drop-partial-reinit.drop_tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.drop_tracking.stderr?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -11,7 +11,7 @@ LL | async fn foo() {\n    |\n    = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `NotSend`\n    = note: required because it appears within the type `(NotSend,)`\n-   = note: required because it captures the following types: `ResumeTy`, `(NotSend,)`, `()`, `impl Future<Output = ()>`\n+   = note: required because it captures the following types: `&mut Context<'_>`, `(NotSend,)`, `()`, `impl Future<Output = ()>`\n note: required because it's used within this `async fn` body\n   --> $DIR/partial-drop-partial-reinit.rs:31:16\n    |"}, {"sha": "dba2a620779f0f446f537663fc8995a40037baaf", "filename": "src/test/ui/async-await/partial-drop-partial-reinit.no_drop_tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.no_drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.no_drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpartial-drop-partial-reinit.no_drop_tracking.stderr?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -11,7 +11,7 @@ LL | async fn foo() {\n    |\n    = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `NotSend`\n    = note: required because it appears within the type `(NotSend,)`\n-   = note: required because it captures the following types: `ResumeTy`, `(NotSend,)`, `impl Future<Output = ()>`, `()`\n+   = note: required because it captures the following types: `&mut Context<'_>`, `(NotSend,)`, `impl Future<Output = ()>`, `()`\n note: required because it's used within this `async fn` body\n   --> $DIR/partial-drop-partial-reinit.rs:31:16\n    |"}, {"sha": "5fbc658f1557c9cbe1d61713592df9885356fde5", "filename": "src/test/ui/lint/issue-104897.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Flint%2Fissue-104897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Flint%2Fissue-104897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-104897.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -0,0 +1,6 @@\n+// error-pattern: this file contains an unclosed delimiter\n+// error-pattern: this file contains an unclosed delimiter\n+// error-pattern: this file contains an unclosed delimiter\n+// error-pattern: format argument must be a string literal\n+\n+fn f(){(print!(\u00e1"}, {"sha": "817a93c2f3bb2774d2ba158999384d4740324cbe", "filename": "src/test/ui/lint/issue-104897.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Flint%2Fissue-104897.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Flint%2Fissue-104897.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-104897.stderr?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -0,0 +1,43 @@\n+error: this file contains an unclosed delimiter\n+  --> $DIR/issue-104897.rs:6:18\n+   |\n+LL | fn f(){(print!(\u00e1\n+   |       --      -  ^\n+   |       ||      |\n+   |       ||      unclosed delimiter\n+   |       |unclosed delimiter\n+   |       unclosed delimiter\n+\n+error: this file contains an unclosed delimiter\n+  --> $DIR/issue-104897.rs:6:18\n+   |\n+LL | fn f(){(print!(\u00e1\n+   |       --      -  ^\n+   |       ||      |\n+   |       ||      unclosed delimiter\n+   |       |unclosed delimiter\n+   |       unclosed delimiter\n+\n+error: this file contains an unclosed delimiter\n+  --> $DIR/issue-104897.rs:6:18\n+   |\n+LL | fn f(){(print!(\u00e1\n+   |       --      -  ^\n+   |       ||      |\n+   |       ||      unclosed delimiter\n+   |       |unclosed delimiter\n+   |       unclosed delimiter\n+\n+error: format argument must be a string literal\n+  --> $DIR/issue-104897.rs:6:16\n+   |\n+LL | fn f(){(print!(\u00e1\n+   |                ^\n+   |\n+help: you might be missing a string literal to format with\n+   |\n+LL | fn f(){(print!(\"{}\", \u00e1\n+   |                +++++\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "5ca54633f219a14650af9be6d11208443dc25bc2", "filename": "src/test/ui/maximal_mir_to_hir_coverage.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fmaximal_mir_to_hir_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fmaximal_mir_to_hir_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmaximal_mir_to_hir_coverage.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -Zmaximal-hir-to-mir-coverage\n+// run-pass\n+\n+// Just making sure this flag is accepted and doesn't crash the compiler\n+\n+fn main() {\n+  let x = 1;\n+  let y = x + 1;\n+  println!(\"{y}\");\n+}"}, {"sha": "88b1c1396516d497870ab47a559636999fccca90", "filename": "src/test/ui/regions/closure-in-projection-issue-97405.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fregions%2Fclosure-in-projection-issue-97405.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fregions%2Fclosure-in-projection-issue-97405.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fclosure-in-projection-issue-97405.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -22,11 +22,11 @@ fn good_generic_fn<T>() {\n // This should fail because `T` ends up in the upvars of the closure.\n fn bad_generic_fn<T: Copy>(t: T) {\n     assert_static(opaque(async move { t; }).next());\n-    //~^ ERROR the associated type `<impl Iterator as Iterator>::Item` may not live long enough\n+    //~^ ERROR the parameter type `T` may not live long enough\n     assert_static(opaque(move || { t; }).next());\n     //~^ ERROR the associated type `<impl Iterator as Iterator>::Item` may not live long enough\n     assert_static(opaque(opaque(async move { t; }).next()).next());\n-    //~^ ERROR the associated type `<impl Iterator as Iterator>::Item` may not live long enough\n+    //~^ ERROR the parameter type `T` may not live long enough\n }\n \n fn main() {}"}, {"sha": "907964aaf379e5c27b9ecfdf665558f77dfd2380", "filename": "src/test/ui/regions/closure-in-projection-issue-97405.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fregions%2Fclosure-in-projection-issue-97405.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fregions%2Fclosure-in-projection-issue-97405.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fclosure-in-projection-issue-97405.stderr?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -1,11 +1,13 @@\n-error[E0310]: the associated type `<impl Iterator as Iterator>::Item` may not live long enough\n+error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/closure-in-projection-issue-97405.rs:24:5\n    |\n LL |     assert_static(opaque(async move { t; }).next());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |\n-   = help: consider adding an explicit lifetime bound `<impl Iterator as Iterator>::Item: 'static`...\n-   = note: ...so that the type `<impl Iterator as Iterator>::Item` will meet its required lifetime bounds\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn bad_generic_fn<T: Copy + 'static>(t: T) {\n+   |                           +++++++++\n \n error[E0310]: the associated type `<impl Iterator as Iterator>::Item` may not live long enough\n   --> $DIR/closure-in-projection-issue-97405.rs:26:5\n@@ -16,14 +18,16 @@ LL |     assert_static(opaque(move || { t; }).next());\n    = help: consider adding an explicit lifetime bound `<impl Iterator as Iterator>::Item: 'static`...\n    = note: ...so that the type `<impl Iterator as Iterator>::Item` will meet its required lifetime bounds\n \n-error[E0310]: the associated type `<impl Iterator as Iterator>::Item` may not live long enough\n+error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/closure-in-projection-issue-97405.rs:28:5\n    |\n LL |     assert_static(opaque(opaque(async move { t; }).next()).next());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |\n-   = help: consider adding an explicit lifetime bound `<impl Iterator as Iterator>::Item: 'static`...\n-   = note: ...so that the type `<impl Iterator as Iterator>::Item` will meet its required lifetime bounds\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn bad_generic_fn<T: Copy + 'static>(t: T) {\n+   |                           +++++++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "3b6e947c59f766955072217512ecc9318a825077", "filename": "src/test/ui/suggestions/assoc-const-as-fn.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.stderr?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -1,8 +1,10 @@\n error[E0277]: the trait bound `T: GlUniformScalar` is not satisfied\n-  --> $DIR/assoc-const-as-fn.rs:14:5\n+  --> $DIR/assoc-const-as-fn.rs:14:40\n    |\n LL |     <T as GlUniformScalar>::FACTORY(1, value);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `GlUniformScalar` is not implemented for `T`\n+   |     -------------------------------    ^^^^^ the trait `GlUniformScalar` is not implemented for `T`\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n help: consider further restricting this bound\n    |"}, {"sha": "1b7289b229b5d488fba8bb5385ca18fd4042dd0f", "filename": "src/test/ui/suggestions/try-removing-the-field.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fsuggestions%2Ftry-removing-the-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fsuggestions%2Ftry-removing-the-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftry-removing-the-field.rs?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -14,4 +14,19 @@ fn use_foo(x: Foo) -> i32 {\n     return foo;\n }\n \n+// issue #105028, suggest removing the field only for shorthand\n+fn use_match(x: Foo) {\n+    match x {\n+        Foo { foo: unused, .. } => { //~ WARNING unused variable\n+                                     //~| help: if this is intentional, prefix it with an underscore\n+        }\n+    }\n+\n+    match x {\n+        Foo { foo, .. } => { //~ WARNING unused variable\n+                             //~| help: try removing the field\n+        }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "7a6013d4a6eab978f2900f75b3f50a1f9e2c5ed6", "filename": "src/test/ui/suggestions/try-removing-the-field.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fsuggestions%2Ftry-removing-the-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339/src%2Ftest%2Fui%2Fsuggestions%2Ftry-removing-the-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftry-removing-the-field.stderr?ref=b28d30e1e3c2b90fd08b7dd79d8e63884d1e0339", "patch": "@@ -8,5 +8,19 @@ LL |     let Foo { foo, bar, .. } = x;\n    |\n    = note: `#[warn(unused_variables)]` on by default\n \n-warning: 1 warning emitted\n+warning: unused variable: `unused`\n+  --> $DIR/try-removing-the-field.rs:20:20\n+   |\n+LL |         Foo { foo: unused, .. } => {\n+   |                    ^^^^^^ help: if this is intentional, prefix it with an underscore: `_unused`\n+\n+warning: unused variable: `foo`\n+  --> $DIR/try-removing-the-field.rs:26:15\n+   |\n+LL |         Foo { foo, .. } => {\n+   |               ^^^-\n+   |               |\n+   |               help: try removing the field\n+\n+warning: 3 warnings emitted\n "}]}