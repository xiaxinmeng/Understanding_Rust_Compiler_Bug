{"sha": "2315f76f9d66b39db975bc722046cca55bc17079", "node_id": "C_kwDOAAsO6NoAKDIzMTVmNzZmOWQ2NmIzOWRiOTc1YmM3MjIwNDZjY2E1NWJjMTcwNzk", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-04-06T01:14:42Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-27T17:14:25Z"}, "message": "Actually check lifetimes in `trivially_copy_pass_by_ref`", "tree": {"sha": "f12789e0bee1631af4035465d19c136808cc31f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f12789e0bee1631af4035465d19c136808cc31f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2315f76f9d66b39db975bc722046cca55bc17079", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2315f76f9d66b39db975bc722046cca55bc17079", "html_url": "https://github.com/rust-lang/rust/commit/2315f76f9d66b39db975bc722046cca55bc17079", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2315f76f9d66b39db975bc722046cca55bc17079/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaa03ea911662b282d3c7bc7c3a29f9fb370b933", "html_url": "https://github.com/rust-lang/rust/commit/eaa03ea911662b282d3c7bc7c3a29f9fb370b933"}], "stats": {"total": 158, "additions": 117, "deletions": 41}, "files": [{"sha": "832e9df96650ee3d9b148181c4c1dbb5916821a0", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2315f76f9d66b39db975bc722046cca55bc17079/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2315f76f9d66b39db975bc722046cca55bc17079/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=2315f76f9d66b39db975bc722046cca55bc17079", "patch": "@@ -7,6 +7,7 @@\n #![feature(let_chains)]\n #![feature(let_else)]\n #![feature(lint_reasons)]\n+#![feature(never_type)]\n #![feature(once_cell)]\n #![feature(rustc_private)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "6edf0e7a7b2ed9ac9d6662fe7d528f763f4383f3", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 53, "deletions": 38, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2315f76f9d66b39db975bc722046cca55bc17079/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2315f76f9d66b39db975bc722046cca55bc17079/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=2315f76f9d66b39db975bc722046cca55bc17079", "patch": "@@ -3,17 +3,19 @@ use std::iter;\n \n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n-use clippy_utils::ty::is_copy;\n+use clippy_utils::ty::{for_each_top_level_late_bound_region, is_copy};\n use clippy_utils::{is_self, is_self_ty};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_ast::attr;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{BindingAnnotation, Body, FnDecl, HirId, Impl, ItemKind, MutTy, Mutability, Node, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n use rustc_middle::ty::layout::LayoutOf;\n+use rustc_middle::ty::{self, RegionKind};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{sym, Span};\n@@ -141,50 +143,62 @@ impl<'tcx> PassByRefOrValue {\n         }\n \n         let fn_sig = cx.tcx.fn_sig(def_id);\n-        let fn_sig = cx.tcx.erase_late_bound_regions(fn_sig);\n-\n         let fn_body = cx.enclosing_body.map(|id| cx.tcx.hir().body(id));\n \n-        for (index, (input, &ty)) in iter::zip(decl.inputs, fn_sig.inputs()).enumerate() {\n+        // Gather all the lifetimes found in the output type which may affect whether\n+        // `TRIVIALLY_COPY_PASS_BY_REF` should be linted.\n+        let mut output_regions = FxHashSet::default();\n+        for_each_top_level_late_bound_region(fn_sig.skip_binder().output(), |region| -> ControlFlow<!> {\n+            output_regions.insert(region);\n+            ControlFlow::Continue(())\n+        });\n+\n+        for (index, (input, ty)) in iter::zip(\n+            decl.inputs,\n+            fn_sig.skip_binder().inputs().iter().map(|&ty| fn_sig.rebind(ty)),\n+        )\n+        .enumerate()\n+        {\n             // All spans generated from a proc-macro invocation are the same...\n             match span {\n-                Some(s) if s == input.span => return,\n+                Some(s) if s == input.span => continue,\n                 _ => (),\n             }\n \n-            match ty.kind() {\n-                ty::Ref(input_lt, ty, Mutability::Not) => {\n-                    // Use lifetimes to determine if we're returning a reference to the\n-                    // argument. In that case we can't switch to pass-by-value as the\n-                    // argument will not live long enough.\n-                    let output_lts = match *fn_sig.output().kind() {\n-                        ty::Ref(output_lt, _, _) => vec![output_lt],\n-                        ty::Adt(_, substs) => substs.regions().collect(),\n-                        _ => vec![],\n-                    };\n+            match *ty.skip_binder().kind() {\n+                ty::Ref(lt, ty, Mutability::Not) => {\n+                    match lt.kind() {\n+                        RegionKind::ReLateBound(index, region)\n+                            if index.as_u32() == 0 && output_regions.contains(&region) =>\n+                        {\n+                            continue;\n+                        },\n+                        // Early bound regions on functions are either from the containing item, are bounded by another\n+                        // lifetime, or are used as a bound for a type or lifetime.\n+                        RegionKind::ReEarlyBound(..) => continue,\n+                        _ => (),\n+                    }\n \n-                    if_chain! {\n-                        if !output_lts.contains(input_lt);\n-                        if is_copy(cx, *ty);\n-                        if let Some(size) = cx.layout_of(*ty).ok().map(|l| l.size.bytes());\n-                        if size <= self.ref_min_size;\n-                        if let hir::TyKind::Rptr(_, MutTy { ty: decl_ty, .. }) = input.kind;\n-                        then {\n-                            let value_type = if fn_body.and_then(|body| body.params.get(index)).map_or(false, is_self) {\n-                                \"self\".into()\n-                            } else {\n-                                snippet(cx, decl_ty.span, \"_\").into()\n-                            };\n-                            span_lint_and_sugg(\n-                                cx,\n-                                TRIVIALLY_COPY_PASS_BY_REF,\n-                                input.span,\n-                                &format!(\"this argument ({} byte) is passed by reference, but would be more efficient if passed by value (limit: {} byte)\", size, self.ref_min_size),\n-                                \"consider passing by value instead\",\n-                                value_type,\n-                                Applicability::Unspecified,\n-                            );\n-                        }\n+                    let ty = cx.tcx.erase_late_bound_regions(fn_sig.rebind(ty));\n+                    if is_copy(cx, ty)\n+                        && let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes())\n+                        && size <= self.ref_min_size\n+                        && let hir::TyKind::Rptr(_, MutTy { ty: decl_ty, .. }) = input.kind\n+                    {\n+                        let value_type = if fn_body.and_then(|body| body.params.get(index)).map_or(false, is_self) {\n+                            \"self\".into()\n+                        } else {\n+                            snippet(cx, decl_ty.span, \"_\").into()\n+                        };\n+                        span_lint_and_sugg(\n+                            cx,\n+                            TRIVIALLY_COPY_PASS_BY_REF,\n+                            input.span,\n+                            &format!(\"this argument ({} byte) is passed by reference, but would be more efficient if passed by value (limit: {} byte)\", size, self.ref_min_size),\n+                            \"consider passing by value instead\",\n+                            value_type,\n+                            Applicability::Unspecified,\n+                        );\n                     }\n                 },\n \n@@ -196,6 +210,7 @@ impl<'tcx> PassByRefOrValue {\n                             _ => continue,\n                         }\n                     }\n+                    let ty = cx.tcx.erase_late_bound_regions(ty);\n \n                     if_chain! {\n                         if is_copy(cx, ty);"}, {"sha": "4c079151f24d40a78ee71cb9499c83b08e1b507c", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2315f76f9d66b39db975bc722046cca55bc17079/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2315f76f9d66b39db975bc722046cca55bc17079/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=2315f76f9d66b39db975bc722046cca55bc17079", "patch": "@@ -2,6 +2,7 @@\n \n #![allow(clippy::module_name_repetitions)]\n \n+use core::ops::ControlFlow;\n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n@@ -13,8 +14,8 @@ use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{\n-    self, AdtDef, Binder, FnSig, IntTy, ParamEnv, Predicate, PredicateKind, Ty, TyCtxt, TypeFoldable, UintTy,\n-    VariantDiscr,\n+    self, AdtDef, Binder, BoundRegion, FnSig, IntTy, ParamEnv, Predicate, PredicateKind, Region, RegionKind, Ty,\n+    TyCtxt, TypeFoldable, TypeSuperFoldable, TypeVisitor, UintTy, VariantDiscr,\n };\n use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n@@ -667,3 +668,30 @@ pub fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n         false\n     }\n }\n+\n+pub fn for_each_top_level_late_bound_region<B>(\n+    ty: Ty<'_>,\n+    f: impl FnMut(BoundRegion) -> ControlFlow<B>,\n+) -> ControlFlow<B> {\n+    struct V<F> {\n+        index: u32,\n+        f: F,\n+    }\n+    impl<'tcx, B, F: FnMut(BoundRegion) -> ControlFlow<B>> TypeVisitor<'tcx> for V<F> {\n+        type BreakTy = B;\n+        fn visit_region(&mut self, r: Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            if let RegionKind::ReLateBound(idx, bound) = r.kind() && idx.as_u32() == self.index {\n+                (self.f)(bound)\n+            } else {\n+                ControlFlow::Continue(())\n+            }\n+        }\n+        fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<'tcx, T>) -> ControlFlow<Self::BreakTy> {\n+            self.index += 1;\n+            let res = t.super_visit_with(self);\n+            self.index -= 1;\n+            res\n+        }\n+    }\n+    ty.visit_with(&mut V { index: 0, f })\n+}"}, {"sha": "24117e37ed1c37ba726bd69ac457d8279902bfff", "filename": "tests/ui/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2315f76f9d66b39db975bc722046cca55bc17079/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2315f76f9d66b39db975bc722046cca55bc17079/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs?ref=2315f76f9d66b39db975bc722046cca55bc17079", "patch": "@@ -113,6 +113,32 @@ mod issue5876 {\n     }\n }\n \n+fn _ref_to_opt_ref_implicit(x: &u32) -> Option<&u32> {\n+    Some(x)\n+}\n+\n+#[allow(clippy::needless_lifetimes)]\n+fn _ref_to_opt_ref_explicit<'a>(x: &'a u32) -> Option<&'a u32> {\n+    Some(x)\n+}\n+\n+fn _with_constraint<'a, 'b: 'a>(x: &'b u32, y: &'a u32) -> &'a u32 {\n+    if true { x } else { y }\n+}\n+\n+async fn _async_implicit(x: &u32) -> &u32 {\n+    x\n+}\n+\n+#[allow(clippy::needless_lifetimes)]\n+async fn _async_explicit<'a>(x: &'a u32) -> &'a u32 {\n+    x\n+}\n+\n+fn _unrelated_lifetimes<'a, 'b>(_x: &'a u32, y: &'b u32) -> &'b u32 {\n+    y\n+}\n+\n fn main() {\n     let (mut foo, bar) = (Foo(0), Bar([0; 24]));\n     let (mut a, b, c, x, y, z) = (0, 0, Bar([0; 24]), 0, Foo(0), 0);"}, {"sha": "66ecb3d8e77acfd3f5b822f307aff7d1f3bb775f", "filename": "tests/ui/trivially_copy_pass_by_ref.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2315f76f9d66b39db975bc722046cca55bc17079/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2315f76f9d66b39db975bc722046cca55bc17079/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr?ref=2315f76f9d66b39db975bc722046cca55bc17079", "patch": "@@ -106,5 +106,11 @@ error: this argument (N byte) is passed by reference, but would be more efficien\n LL |     fn foo(x: &i32) {\n    |               ^^^^ help: consider passing by value instead: `i32`\n \n-error: aborting due to 17 previous errors\n+error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n+  --> $DIR/trivially_copy_pass_by_ref.rs:138:37\n+   |\n+LL | fn _unrelated_lifetimes<'a, 'b>(_x: &'a u32, y: &'b u32) -> &'b u32 {\n+   |                                     ^^^^^^^ help: consider passing by value instead: `u32`\n+\n+error: aborting due to 18 previous errors\n "}]}