{"sha": "c2a408840ad18f74280805535f0b7193528ff3df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYTQwODg0MGFkMThmNzQyODA4MDU1MzVmMGI3MTkzNTI4ZmYzZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-01T01:02:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-01T01:02:42Z"}, "message": "Auto merge of #87688 - camsteffen:let-else, r=cjgillot\n\nIntroduce `let...else`\n\nTracking issue: #87335\n\nThe trickiest part for me was enforcing the diverging else block with clear diagnostics. Perhaps the obvious solution is to expand to `let _: ! = ..`, but I decided against this because, when a \"mismatched type\" error is found in typeck, there is no way to trace where in the HIR the expected type originated, AFAICT. In order to pass down this information, I believe we should introduce `Expectation::LetElseNever(HirId)` or maybe add `HirId` to `Expectation::HasType`, but I left that as a future enhancement. For now, I simply assert that the block is `!` with a custom `ObligationCauseCode`, and I think this is clear enough, at least to start. The downside here is that the error points at the entire block rather than the specific expression with the wrong type. I left a todo to this effect.\n\nOverall, I believe this PR is feature-complete with regard to the RFC.", "tree": {"sha": "5d8815373247ba476a90946678a2c19e713f8780", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d8815373247ba476a90946678a2c19e713f8780"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2a408840ad18f74280805535f0b7193528ff3df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2a408840ad18f74280805535f0b7193528ff3df", "html_url": "https://github.com/rust-lang/rust/commit/c2a408840ad18f74280805535f0b7193528ff3df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2a408840ad18f74280805535f0b7193528ff3df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3956106d12cebec91be0637759e29ab6908b4cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3956106d12cebec91be0637759e29ab6908b4cd", "html_url": "https://github.com/rust-lang/rust/commit/a3956106d12cebec91be0637759e29ab6908b4cd"}, {"sha": "3ff1d6bbf427cfb3d504092c93f261b49577170e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ff1d6bbf427cfb3d504092c93f261b49577170e", "html_url": "https://github.com/rust-lang/rust/commit/3ff1d6bbf427cfb3d504092c93f261b49577170e"}], "stats": {"total": 1133, "additions": 901, "deletions": 232}, "files": [{"sha": "0632d937c4c17e2d154fe856e0f4343e3b746608", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -1005,13 +1005,42 @@ pub struct Local {\n     pub id: NodeId,\n     pub pat: P<Pat>,\n     pub ty: Option<P<Ty>>,\n-    /// Initializer expression to set the value, if any.\n-    pub init: Option<P<Expr>>,\n+    pub kind: LocalKind,\n     pub span: Span,\n     pub attrs: AttrVec,\n     pub tokens: Option<LazyTokenStream>,\n }\n \n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub enum LocalKind {\n+    /// Local declaration.\n+    /// Example: `let x;`\n+    Decl,\n+    /// Local declaration with an initializer.\n+    /// Example: `let x = y;`\n+    Init(P<Expr>),\n+    /// Local declaration with an initializer and an `else` clause.\n+    /// Example: `let Some(x) = y else { return };`\n+    InitElse(P<Expr>, P<Block>),\n+}\n+\n+impl LocalKind {\n+    pub fn init(&self) -> Option<&Expr> {\n+        match self {\n+            Self::Decl => None,\n+            Self::Init(i) | Self::InitElse(i, _) => Some(i),\n+        }\n+    }\n+\n+    pub fn init_else_opt(&self) -> Option<(&Expr, Option<&Block>)> {\n+        match self {\n+            Self::Decl => None,\n+            Self::Init(init) => Some((init, None)),\n+            Self::InitElse(init, els) => Some((init, Some(els))),\n+        }\n+    }\n+}\n+\n /// An arm of a 'match'.\n ///\n /// E.g., `0..=10 => { println!(\"match!\") }` as in"}, {"sha": "368a23e34290dd99855fb74ac108182e7da221ed", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -571,11 +571,20 @@ pub fn noop_visit_parenthesized_parameter_data<T: MutVisitor>(\n }\n \n pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n-    let Local { id, pat, ty, init, span, attrs, tokens } = local.deref_mut();\n+    let Local { id, pat, ty, kind, span, attrs, tokens } = local.deref_mut();\n     vis.visit_id(id);\n     vis.visit_pat(pat);\n     visit_opt(ty, |ty| vis.visit_ty(ty));\n-    visit_opt(init, |init| vis.visit_expr(init));\n+    match kind {\n+        LocalKind::Decl => {}\n+        LocalKind::Init(init) => {\n+            vis.visit_expr(init);\n+        }\n+        LocalKind::InitElse(init, els) => {\n+            vis.visit_expr(init);\n+            vis.visit_block(els);\n+        }\n+    }\n     vis.visit_span(span);\n     visit_thin_attrs(attrs, vis);\n     visit_lazy_tts(tokens, vis);"}, {"sha": "6ea3db6d3037252c5a2c371e2a6dabe50aebbf26", "filename": "compiler/rustc_ast/src/util/classify.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -23,3 +23,30 @@ pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n             | ast::ExprKind::TryBlock(..)\n     )\n }\n+\n+/// If an expression ends with `}`, returns the innermost expression ending in the `}`\n+pub fn expr_trailing_brace(mut expr: &ast::Expr) -> Option<&ast::Expr> {\n+    use ast::ExprKind::*;\n+\n+    loop {\n+        match &expr.kind {\n+            AddrOf(_, _, e)\n+            | Assign(_, e, _)\n+            | AssignOp(_, _, e)\n+            | Binary(_, _, e)\n+            | Box(e)\n+            | Break(_, Some(e))\n+            | Closure(.., e, _)\n+            | Let(_, e, _)\n+            | Range(_, Some(e), _)\n+            | Ret(Some(e))\n+            | Unary(_, e)\n+            | Yield(Some(e)) => {\n+                expr = e;\n+            }\n+            Async(..) | Block(..) | ForLoop(..) | If(..) | Loop(..) | Match(..) | Struct(..)\n+            | TryBlock(..) | While(..) => break Some(expr),\n+            _ => break None,\n+        }\n+    }\n+}"}, {"sha": "c30f711b3970793fdde4b52ec1c3adc40740aefa", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -242,7 +242,10 @@ pub fn walk_local<'a, V: Visitor<'a>>(visitor: &mut V, local: &'a Local) {\n     }\n     visitor.visit_pat(&local.pat);\n     walk_list!(visitor, visit_ty, &local.ty);\n-    walk_list!(visitor, visit_expr, &local.init);\n+    if let Some((init, els)) = local.kind.init_else_opt() {\n+        visitor.visit_expr(init);\n+        walk_list!(visitor, visit_block, els);\n+    }\n }\n \n pub fn walk_label<'a, V: Visitor<'a>>(visitor: &mut V, label: &'a Label) {"}, {"sha": "ca804ec6758b727b23ae4b02d59159c7dbc2b556", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,185 @@\n+use crate::{ImplTraitContext, ImplTraitPosition, LoweringContext};\n+use rustc_ast::{AttrVec, Block, BlockCheckMode, Expr, Local, LocalKind, Stmt, StmtKind};\n+use rustc_hir as hir;\n+use rustc_session::parse::feature_err;\n+use rustc_span::symbol::Ident;\n+use rustc_span::{sym, DesugaringKind};\n+\n+use smallvec::SmallVec;\n+\n+impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    pub(super) fn lower_block(\n+        &mut self,\n+        b: &Block,\n+        targeted_by_break: bool,\n+    ) -> &'hir hir::Block<'hir> {\n+        self.arena.alloc(self.lower_block_noalloc(b, targeted_by_break))\n+    }\n+\n+    pub(super) fn lower_block_noalloc(\n+        &mut self,\n+        b: &Block,\n+        targeted_by_break: bool,\n+    ) -> hir::Block<'hir> {\n+        let (stmts, expr) = self.lower_stmts(&b.stmts);\n+        let rules = self.lower_block_check_mode(&b.rules);\n+        let hir_id = self.lower_node_id(b.id);\n+        hir::Block { hir_id, stmts, expr, rules, span: self.lower_span(b.span), targeted_by_break }\n+    }\n+\n+    fn lower_stmts(\n+        &mut self,\n+        mut ast_stmts: &[Stmt],\n+    ) -> (&'hir [hir::Stmt<'hir>], Option<&'hir hir::Expr<'hir>>) {\n+        let mut stmts = SmallVec::<[hir::Stmt<'hir>; 8]>::new();\n+        let mut expr = None;\n+        while let [s, tail @ ..] = ast_stmts {\n+            match s.kind {\n+                StmtKind::Local(ref local) => {\n+                    let hir_id = self.lower_node_id(s.id);\n+                    match &local.kind {\n+                        LocalKind::InitElse(init, els) => {\n+                            let (s, e) = self.lower_let_else(hir_id, local, init, els, tail);\n+                            stmts.push(s);\n+                            expr = Some(e);\n+                            // remaining statements are in let-else expression\n+                            break;\n+                        }\n+                        _ => {\n+                            let local = self.lower_local(local);\n+                            self.alias_attrs(hir_id, local.hir_id);\n+                            let kind = hir::StmtKind::Local(local);\n+                            let span = self.lower_span(s.span);\n+                            stmts.push(hir::Stmt { hir_id, kind, span });\n+                        }\n+                    }\n+                }\n+                StmtKind::Item(ref it) => {\n+                    stmts.extend(self.lower_item_id(it).into_iter().enumerate().map(\n+                        |(i, item_id)| {\n+                            let hir_id = match i {\n+                                0 => self.lower_node_id(s.id),\n+                                _ => self.next_id(),\n+                            };\n+                            let kind = hir::StmtKind::Item(item_id);\n+                            let span = self.lower_span(s.span);\n+                            hir::Stmt { hir_id, kind, span }\n+                        },\n+                    ));\n+                }\n+                StmtKind::Expr(ref e) => {\n+                    let e = self.lower_expr(e);\n+                    if tail.is_empty() {\n+                        expr = Some(e);\n+                    } else {\n+                        let hir_id = self.lower_node_id(s.id);\n+                        self.alias_attrs(hir_id, e.hir_id);\n+                        let kind = hir::StmtKind::Expr(e);\n+                        let span = self.lower_span(s.span);\n+                        stmts.push(hir::Stmt { hir_id, kind, span });\n+                    }\n+                }\n+                StmtKind::Semi(ref e) => {\n+                    let e = self.lower_expr(e);\n+                    let hir_id = self.lower_node_id(s.id);\n+                    self.alias_attrs(hir_id, e.hir_id);\n+                    let kind = hir::StmtKind::Semi(e);\n+                    let span = self.lower_span(s.span);\n+                    stmts.push(hir::Stmt { hir_id, kind, span });\n+                }\n+                StmtKind::Empty => {}\n+                StmtKind::MacCall(..) => panic!(\"shouldn't exist here\"),\n+            }\n+            ast_stmts = &ast_stmts[1..];\n+        }\n+        (self.arena.alloc_from_iter(stmts), expr)\n+    }\n+\n+    fn lower_local(&mut self, l: &Local) -> &'hir hir::Local<'hir> {\n+        let ty = l\n+            .ty\n+            .as_ref()\n+            .map(|t| self.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Binding)));\n+        let init = l.kind.init().map(|init| self.lower_expr(init));\n+        let hir_id = self.lower_node_id(l.id);\n+        let pat = self.lower_pat(&l.pat);\n+        let span = self.lower_span(l.span);\n+        let source = hir::LocalSource::Normal;\n+        self.lower_attrs(hir_id, &l.attrs);\n+        self.arena.alloc(hir::Local { hir_id, ty, pat, init, span, source })\n+    }\n+\n+    fn lower_block_check_mode(&mut self, b: &BlockCheckMode) -> hir::BlockCheckMode {\n+        match *b {\n+            BlockCheckMode::Default => hir::BlockCheckMode::DefaultBlock,\n+            BlockCheckMode::Unsafe(u) => {\n+                hir::BlockCheckMode::UnsafeBlock(self.lower_unsafe_source(u))\n+            }\n+        }\n+    }\n+\n+    fn lower_let_else(\n+        &mut self,\n+        stmt_hir_id: hir::HirId,\n+        local: &Local,\n+        init: &Expr,\n+        els: &Block,\n+        tail: &[Stmt],\n+    ) -> (hir::Stmt<'hir>, &'hir hir::Expr<'hir>) {\n+        let ty = local\n+            .ty\n+            .as_ref()\n+            .map(|t| self.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Binding)));\n+        let span = self.lower_span(local.span);\n+        let span = self.mark_span_with_reason(DesugaringKind::LetElse, span, None);\n+        let init = Some(self.lower_expr(init));\n+        let val = Ident::with_dummy_span(sym::val);\n+        let (pat, val_id) =\n+            self.pat_ident_binding_mode(span, val, hir::BindingAnnotation::Unannotated);\n+        let local_hir_id = self.lower_node_id(local.id);\n+        self.lower_attrs(local_hir_id, &local.attrs);\n+        // first statement which basically exists for the type annotation\n+        let stmt = {\n+            let local = self.arena.alloc(hir::Local {\n+                hir_id: local_hir_id,\n+                ty,\n+                pat,\n+                init,\n+                span,\n+                source: hir::LocalSource::Normal,\n+            });\n+            let kind = hir::StmtKind::Local(local);\n+            hir::Stmt { hir_id: stmt_hir_id, kind, span }\n+        };\n+        let let_expr = {\n+            let scrutinee = self.expr_ident(span, val, val_id);\n+            let let_kind = hir::ExprKind::Let(self.lower_pat(&local.pat), scrutinee, span);\n+            self.arena.alloc(self.expr(span, let_kind, AttrVec::new()))\n+        };\n+        let then_expr = {\n+            let (stmts, expr) = self.lower_stmts(tail);\n+            let block = self.block_all(span, stmts, expr);\n+            self.arena.alloc(self.expr_block(block, AttrVec::new()))\n+        };\n+        let else_expr = {\n+            let block = self.lower_block(els, false);\n+            self.arena.alloc(self.expr_block(block, AttrVec::new()))\n+        };\n+        self.alias_attrs(else_expr.hir_id, local_hir_id);\n+        let if_expr = self.arena.alloc(hir::Expr {\n+            hir_id: self.next_id(),\n+            span,\n+            kind: hir::ExprKind::If(let_expr, then_expr, Some(else_expr)),\n+        });\n+        if !self.sess.features_untracked().let_else {\n+            feature_err(\n+                &self.sess.parse_sess,\n+                sym::let_else,\n+                local.span,\n+                \"`let...else` statements are unstable\",\n+            )\n+            .emit();\n+        }\n+        (stmt, if_expr)\n+    }\n+}"}, {"sha": "deb7e742e5cc3b31d1233b85ff7694e9d104287e", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 95, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -64,7 +64,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n \n-use smallvec::{smallvec, SmallVec};\n+use smallvec::SmallVec;\n use std::collections::BTreeMap;\n use std::mem;\n use tracing::{debug, trace};\n@@ -77,6 +77,7 @@ macro_rules! arena_vec {\n }\n \n mod asm;\n+mod block;\n mod expr;\n mod item;\n mod pat;\n@@ -1793,24 +1794,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         )\n     }\n \n-    fn lower_local(&mut self, l: &Local) -> hir::Local<'hir> {\n-        let ty = l\n-            .ty\n-            .as_ref()\n-            .map(|t| self.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Binding)));\n-        let init = l.init.as_ref().map(|e| self.lower_expr(e));\n-        let hir_id = self.lower_node_id(l.id);\n-        self.lower_attrs(hir_id, &l.attrs);\n-        hir::Local {\n-            hir_id,\n-            ty,\n-            pat: self.lower_pat(&l.pat),\n-            init,\n-            span: self.lower_span(l.span),\n-            source: hir::LocalSource::Normal,\n-        }\n-    }\n-\n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> &'hir [Ident] {\n         // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n         // as they are not explicit in HIR/Ty function signatures.\n@@ -2396,23 +2379,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         bounds.iter().map(move |bound| self.lower_param_bound(bound, itctx.reborrow()))\n     }\n \n-    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> &'hir hir::Block<'hir> {\n-        self.arena.alloc(self.lower_block_noalloc(b, targeted_by_break))\n-    }\n-\n-    fn lower_block_noalloc(&mut self, b: &Block, targeted_by_break: bool) -> hir::Block<'hir> {\n-        let (stmts, expr) = match &*b.stmts {\n-            [stmts @ .., Stmt { kind: StmtKind::Expr(e), .. }] => (stmts, Some(&*e)),\n-            stmts => (stmts, None),\n-        };\n-        let stmts = self.arena.alloc_from_iter(stmts.iter().flat_map(|stmt| self.lower_stmt(stmt)));\n-        let expr = expr.map(|e| self.lower_expr(e));\n-        let rules = self.lower_block_check_mode(&b.rules);\n-        let hir_id = self.lower_node_id(b.id);\n-\n-        hir::Block { hir_id, stmts, expr, rules, span: self.lower_span(b.span), targeted_by_break }\n-    }\n-\n     /// Lowers a block directly to an expression, presuming that it\n     /// has no attributes and is not targeted by a `break`.\n     fn lower_block_expr(&mut self, b: &Block) -> hir::Expr<'hir> {\n@@ -2427,65 +2393,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         })\n     }\n \n-    fn lower_stmt(&mut self, s: &Stmt) -> SmallVec<[hir::Stmt<'hir>; 1]> {\n-        let (hir_id, kind) = match s.kind {\n-            StmtKind::Local(ref l) => {\n-                let l = self.lower_local(l);\n-                let hir_id = self.lower_node_id(s.id);\n-                self.alias_attrs(hir_id, l.hir_id);\n-                return smallvec![hir::Stmt {\n-                    hir_id,\n-                    kind: hir::StmtKind::Local(self.arena.alloc(l)),\n-                    span: self.lower_span(s.span),\n-                }];\n-            }\n-            StmtKind::Item(ref it) => {\n-                // Can only use the ID once.\n-                let mut id = Some(s.id);\n-                return self\n-                    .lower_item_id(it)\n-                    .into_iter()\n-                    .map(|item_id| {\n-                        let hir_id = id\n-                            .take()\n-                            .map(|id| self.lower_node_id(id))\n-                            .unwrap_or_else(|| self.next_id());\n-\n-                        hir::Stmt {\n-                            hir_id,\n-                            kind: hir::StmtKind::Item(item_id),\n-                            span: self.lower_span(s.span),\n-                        }\n-                    })\n-                    .collect();\n-            }\n-            StmtKind::Expr(ref e) => {\n-                let e = self.lower_expr(e);\n-                let hir_id = self.lower_node_id(s.id);\n-                self.alias_attrs(hir_id, e.hir_id);\n-                (hir_id, hir::StmtKind::Expr(e))\n-            }\n-            StmtKind::Semi(ref e) => {\n-                let e = self.lower_expr(e);\n-                let hir_id = self.lower_node_id(s.id);\n-                self.alias_attrs(hir_id, e.hir_id);\n-                (hir_id, hir::StmtKind::Semi(e))\n-            }\n-            StmtKind::Empty => return smallvec![],\n-            StmtKind::MacCall(..) => panic!(\"shouldn't exist here\"),\n-        };\n-        smallvec![hir::Stmt { hir_id, kind, span: self.lower_span(s.span) }]\n-    }\n-\n-    fn lower_block_check_mode(&mut self, b: &BlockCheckMode) -> hir::BlockCheckMode {\n-        match *b {\n-            BlockCheckMode::Default => hir::BlockCheckMode::DefaultBlock,\n-            BlockCheckMode::Unsafe(u) => {\n-                hir::BlockCheckMode::UnsafeBlock(self.lower_unsafe_source(u))\n-            }\n-        }\n-    }\n-\n     fn lower_unsafe_source(&mut self, u: UnsafeSource) -> hir::UnsafeSource {\n         match u {\n             CompilerGenerated => hir::UnsafeSource::CompilerGenerated,"}, {"sha": "3cf04be160c64a0a8003493187d618cbca4217a2", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -1518,13 +1518,19 @@ impl<'a> State<'a> {\n                 self.ibox(INDENT_UNIT);\n                 self.print_local_decl(loc);\n                 self.end();\n-                if let Some(ref init) = loc.init {\n+                if let Some((init, els)) = loc.kind.init_else_opt() {\n                     self.nbsp();\n                     self.word_space(\"=\");\n                     self.print_expr(init);\n+                    if let Some(els) = els {\n+                        self.cbox(INDENT_UNIT);\n+                        self.ibox(INDENT_UNIT);\n+                        self.s.word(\" else \");\n+                        self.print_block(els);\n+                    }\n                 }\n                 self.s.word(\";\");\n-                self.end();\n+                self.end(); // `let` ibox\n             }\n             ast::StmtKind::Item(ref item) => self.print_item(item),\n             ast::StmtKind::Expr(ref expr) => {"}, {"sha": "14506f296bf95d294964445da692c648ceceacdc", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -3,7 +3,7 @@ use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Expr, MetaItem};\n+use rustc_ast::{self as ast, Expr, LocalKind, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n@@ -135,8 +135,8 @@ fn stmt_let_underscore(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<ast::Expr>) -> as\n     let local = P(ast::Local {\n         pat: cx.pat_wild(sp),\n         ty: None,\n-        init: Some(expr),\n         id: ast::DUMMY_NODE_ID,\n+        kind: LocalKind::Init(expr),\n         span: sp,\n         attrs: ast::AttrVec::new(),\n         tokens: None,"}, {"sha": "1d83ecbfd404bd2b3b6e1c47a08cefb453c661dc", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -2,7 +2,7 @@ use crate::base::ExtCtxt;\n \n use rustc_ast::attr;\n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, AttrVec, BlockCheckMode, Expr, PatKind, UnOp};\n+use rustc_ast::{self as ast, AttrVec, BlockCheckMode, Expr, LocalKind, PatKind, UnOp};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n \n@@ -153,8 +153,8 @@ impl<'a> ExtCtxt<'a> {\n         let local = P(ast::Local {\n             pat,\n             ty: None,\n-            init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n+            kind: LocalKind::Init(ex),\n             span: sp,\n             attrs: AttrVec::new(),\n             tokens: None,\n@@ -167,8 +167,8 @@ impl<'a> ExtCtxt<'a> {\n         let local = P(ast::Local {\n             pat: self.pat_wild(span),\n             ty: Some(ty),\n-            init: None,\n             id: ast::DUMMY_NODE_ID,\n+            kind: LocalKind::Decl,\n             span,\n             attrs: AttrVec::new(),\n             tokens: None,"}, {"sha": "a3807a2bb9fde64cb5a3a6e2574de2a9176f145f", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -676,6 +676,9 @@ declare_features! (\n     /// Allows additional const parameter types, such as `&'static str` or user defined types\n     (incomplete, adt_const_params, \"1.56.0\", Some(44580), None),\n \n+    /// Allows `let...else` statements.\n+    (active, let_else, \"1.56.0\", Some(87335), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "d54933841fd4e1142c2a7484402c88d8e0d0833e", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -781,6 +781,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     );\n                 }\n             }\n+            ObligationCauseCode::LetElse => {\n+                err.help(\"try adding a diverging expression, such as `return` or `panic!(..)`\");\n+                err.help(\"...or use `match` instead of `let...else`\");\n+            }\n             _ => (),\n         }\n     }\n@@ -2592,6 +2596,7 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n             }\n             IfExpression { .. } => Error0308(\"`if` and `else` have incompatible types\"),\n             IfExpressionWithNoElse => Error0317(\"`if` may be missing an `else` clause\"),\n+            LetElse => Error0308(\"`else` clause of `let...else` does not diverge\"),\n             MainFunctionType => Error0580(\"`main` function has wrong type\"),\n             StartFunctionType => Error0308(\"`#[start]` function has wrong type\"),\n             IntrinsicType => Error0308(\"intrinsic has wrong type\"),"}, {"sha": "f04ac8dd9426ff4d7b32bc81cf705f56fcb5362f", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -1,7 +1,7 @@\n use crate::Lint;\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n-use rustc_ast::util::parser;\n+use rustc_ast::util::{classify, parser};\n use rustc_ast::{ExprKind, StmtKind};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{pluralize, Applicability};\n@@ -382,6 +382,7 @@ enum UnusedDelimsCtx {\n     FunctionArg,\n     MethodArg,\n     AssignedValue,\n+    AssignedValueLetElse,\n     IfCond,\n     WhileCond,\n     ForIterExpr,\n@@ -398,7 +399,9 @@ impl From<UnusedDelimsCtx> for &'static str {\n         match ctx {\n             UnusedDelimsCtx::FunctionArg => \"function argument\",\n             UnusedDelimsCtx::MethodArg => \"method argument\",\n-            UnusedDelimsCtx::AssignedValue => \"assigned value\",\n+            UnusedDelimsCtx::AssignedValue | UnusedDelimsCtx::AssignedValueLetElse => {\n+                \"assigned value\"\n+            }\n             UnusedDelimsCtx::IfCond => \"`if` condition\",\n             UnusedDelimsCtx::WhileCond => \"`while` condition\",\n             UnusedDelimsCtx::ForIterExpr => \"`for` iterator expression\",\n@@ -441,14 +444,26 @@ trait UnusedDelimLint {\n         right_pos: Option<BytePos>,\n     );\n \n-    fn is_expr_delims_necessary(inner: &ast::Expr, followed_by_block: bool) -> bool {\n+    fn is_expr_delims_necessary(\n+        inner: &ast::Expr,\n+        followed_by_block: bool,\n+        followed_by_else: bool,\n+    ) -> bool {\n+        if followed_by_else {\n+            match inner.kind {\n+                ast::ExprKind::Binary(op, ..) if op.node.lazy() => return true,\n+                _ if classify::expr_trailing_brace(inner).is_some() => return true,\n+                _ => {}\n+            }\n+        }\n+\n         // Prevent false-positives in cases like `fn x() -> u8 { ({ 0 } + 1) }`\n         let lhs_needs_parens = {\n             let mut innermost = inner;\n             loop {\n                 if let ExprKind::Binary(_, lhs, _rhs) = &innermost.kind {\n                     innermost = lhs;\n-                    if !rustc_ast::util::classify::expr_requires_semi_to_be_stmt(innermost) {\n+                    if !classify::expr_requires_semi_to_be_stmt(innermost) {\n                         break true;\n                     }\n                 } else {\n@@ -618,15 +633,12 @@ trait UnusedDelimLint {\n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n         match s.kind {\n             StmtKind::Local(ref local) if Self::LINT_EXPR_IN_PATTERN_MATCHING_CTX => {\n-                if let Some(ref value) = local.init {\n-                    self.check_unused_delims_expr(\n-                        cx,\n-                        &value,\n-                        UnusedDelimsCtx::AssignedValue,\n-                        false,\n-                        None,\n-                        None,\n-                    );\n+                if let Some((init, els)) = local.kind.init_else_opt() {\n+                    let ctx = match els {\n+                        None => UnusedDelimsCtx::AssignedValue,\n+                        Some(_) => UnusedDelimsCtx::AssignedValueLetElse,\n+                    };\n+                    self.check_unused_delims_expr(cx, init, ctx, false, None, None);\n                 }\n             }\n             StmtKind::Expr(ref expr) => {\n@@ -702,7 +714,8 @@ impl UnusedDelimLint for UnusedParens {\n     ) {\n         match value.kind {\n             ast::ExprKind::Paren(ref inner) => {\n-                if !Self::is_expr_delims_necessary(inner, followed_by_block)\n+                let followed_by_else = ctx == UnusedDelimsCtx::AssignedValueLetElse;\n+                if !Self::is_expr_delims_necessary(inner, followed_by_block, followed_by_else)\n                     && value.attrs.is_empty()\n                     && !value.span.from_expansion()\n                     && (ctx != UnusedDelimsCtx::LetScrutineeExpr\n@@ -941,7 +954,7 @@ impl UnusedDelimLint for UnusedBraces {\n                 // FIXME(const_generics): handle paths when #67075 is fixed.\n                 if let [stmt] = inner.stmts.as_slice() {\n                     if let ast::StmtKind::Expr(ref expr) = stmt.kind {\n-                        if !Self::is_expr_delims_necessary(expr, followed_by_block)\n+                        if !Self::is_expr_delims_necessary(expr, followed_by_block, false)\n                             && (ctx != UnusedDelimsCtx::AnonConst\n                                 || matches!(expr.kind, ast::ExprKind::Lit(_)))\n                             && !cx.sess().source_map().is_multiline(value.span)"}, {"sha": "74edb17fe32f1af9e4daccc8c1ab447c412893e8", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -305,6 +305,9 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Intrinsic has wrong type\n     IntrinsicType,\n \n+    /// A let else block does not diverge\n+    LetElse,\n+\n     /// Method receiver\n     MethodReceiver,\n "}, {"sha": "b34c1e07be71c61ff6d2673d67e1ea2bfe1509e6", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 62, "deletions": 41, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::builtin::BINDINGS_WITH_VARIANT_NAME;\n use rustc_session::lint::builtin::{IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS};\n use rustc_session::Session;\n-use rustc_span::Span;\n+use rustc_span::{DesugaringKind, ExpnKind, Span};\n use std::slice;\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n@@ -118,31 +118,6 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         check_for_bindings_named_same_as_variants(self, pat);\n     }\n \n-    fn let_source(&mut self, pat: &'tcx hir::Pat<'tcx>, _expr: &hir::Expr<'_>) -> LetSource {\n-        let hir = self.tcx.hir();\n-        let parent = hir.get_parent_node(pat.hir_id);\n-        let parent_parent = hir.get_parent_node(parent);\n-        let parent_parent_node = hir.get(parent_parent);\n-\n-        let parent_parent_parent = hir.get_parent_node(parent_parent);\n-        let parent_parent_parent_parent = hir.get_parent_node(parent_parent_parent);\n-        let parent_parent_parent_parent_node = hir.get(parent_parent_parent_parent);\n-\n-        if let hir::Node::Expr(hir::Expr {\n-            kind: hir::ExprKind::Loop(_, _, hir::LoopSource::While, _),\n-            ..\n-        }) = parent_parent_parent_parent_node\n-        {\n-            LetSource::WhileLet\n-        } else if let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::If { .. }, .. }) =\n-            parent_parent_node\n-        {\n-            LetSource::IfLet\n-        } else {\n-            LetSource::GenericLet\n-        }\n-    }\n-\n     fn lower_pattern<'p>(\n         &self,\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n@@ -172,10 +147,9 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n     fn check_let(&mut self, pat: &'tcx hir::Pat<'tcx>, expr: &hir::Expr<'_>, span: Span) {\n         self.check_patterns(pat);\n-        let ls = self.let_source(pat, expr);\n         let mut cx = self.new_cx(expr.hir_id);\n         let tpat = self.lower_pattern(&mut cx, pat, &mut false).0;\n-        check_let_reachability(&mut cx, ls, pat.hir_id, &tpat, span);\n+        check_let_reachability(&mut cx, pat.hir_id, &tpat, span);\n     }\n \n     fn check_match(\n@@ -192,13 +166,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             if let Some(hir::Guard::IfLet(ref pat, _)) = arm.guard {\n                 self.check_patterns(pat);\n                 let tpat = self.lower_pattern(&mut cx, pat, &mut false).0;\n-                check_let_reachability(\n-                    &mut cx,\n-                    LetSource::IfLetGuard,\n-                    pat.hir_id,\n-                    &tpat,\n-                    tpat.span,\n-                );\n+                check_let_reachability(&mut cx, pat.hir_id, &tpat, tpat.span);\n             }\n         }\n \n@@ -397,7 +365,7 @@ fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<\n     });\n }\n \n-fn irrefutable_let_pattern(id: HirId, ls: LetSource, span: Span, tcx: TyCtxt<'_>) {\n+fn irrefutable_let_pattern(tcx: TyCtxt<'_>, id: HirId, span: Span) {\n     macro_rules! emit_diag {\n         (\n             $lint:expr,\n@@ -412,7 +380,12 @@ fn irrefutable_let_pattern(id: HirId, ls: LetSource, span: Span, tcx: TyCtxt<'_>\n         }};\n     }\n \n-    tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, |lint| match ls {\n+    let source = let_source(tcx, id);\n+    let span = match source {\n+        LetSource::LetElse(span) => span,\n+        _ => span,\n+    };\n+    tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, |lint| match source {\n         LetSource::GenericLet => {\n             emit_diag!(lint, \"`let`\", \"`let` is useless\", \"removing `let`\");\n         }\n@@ -432,6 +405,14 @@ fn irrefutable_let_pattern(id: HirId, ls: LetSource, span: Span, tcx: TyCtxt<'_>\n                 \"removing the guard and adding a `let` inside the match arm\"\n             );\n         }\n+        LetSource::LetElse(..) => {\n+            emit_diag!(\n+                lint,\n+                \"`let...else`\",\n+                \"`else` clause is useless\",\n+                \"removing the `else` clause\"\n+            );\n+        }\n         LetSource::WhileLet => {\n             emit_diag!(\n                 lint,\n@@ -445,7 +426,6 @@ fn irrefutable_let_pattern(id: HirId, ls: LetSource, span: Span, tcx: TyCtxt<'_>\n \n fn check_let_reachability<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-    ls: LetSource,\n     pat_id: HirId,\n     pat: &'p super::Pat<'tcx>,\n     span: Span,\n@@ -454,13 +434,13 @@ fn check_let_reachability<'p, 'tcx>(\n     let report = compute_match_usefulness(&cx, &arms, pat_id, pat.ty);\n \n     report_arm_reachability(&cx, &report, |arm_index, arm_span, arm_hir_id, _| {\n-        match ls {\n+        match let_source(cx.tcx, pat_id) {\n             LetSource::IfLet | LetSource::WhileLet => {\n                 match arm_index {\n                     // The arm with the user-specified pattern.\n                     0 => unreachable_pattern(cx.tcx, arm_span, arm_hir_id, None),\n                     // The arm with the wildcard pattern.\n-                    1 => irrefutable_let_pattern(pat_id, ls, arm_span, cx.tcx),\n+                    1 => irrefutable_let_pattern(cx.tcx, pat_id, arm_span),\n                     _ => bug!(),\n                 }\n             }\n@@ -473,7 +453,7 @@ fn check_let_reachability<'p, 'tcx>(\n \n     if report.non_exhaustiveness_witnesses.is_empty() {\n         // The match is exhaustive, i.e. the `if let` pattern is irrefutable.\n-        irrefutable_let_pattern(pat_id, ls, span, cx.tcx);\n+        irrefutable_let_pattern(cx.tcx, pat_id, span);\n     }\n }\n \n@@ -787,5 +767,46 @@ pub enum LetSource {\n     GenericLet,\n     IfLet,\n     IfLetGuard,\n+    LetElse(Span),\n     WhileLet,\n }\n+\n+fn let_source(tcx: TyCtxt<'_>, pat_id: HirId) -> LetSource {\n+    let hir = tcx.hir();\n+    let parent = hir.get_parent_node(pat_id);\n+    match hir.get(parent) {\n+        hir::Node::Arm(hir::Arm {\n+            guard: Some(hir::Guard::IfLet(&hir::Pat { hir_id, .. }, _)),\n+            ..\n+        }) if hir_id == pat_id => {\n+            return LetSource::IfLetGuard;\n+        }\n+        hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Let(..), span, .. }) => {\n+            let expn_data = span.ctxt().outer_expn_data();\n+            if let ExpnKind::Desugaring(DesugaringKind::LetElse) = expn_data.kind {\n+                return LetSource::LetElse(expn_data.call_site);\n+            }\n+        }\n+        _ => {}\n+    }\n+    let parent_parent = hir.get_parent_node(parent);\n+    let parent_parent_node = hir.get(parent_parent);\n+\n+    let parent_parent_parent = hir.get_parent_node(parent_parent);\n+    let parent_parent_parent_parent = hir.get_parent_node(parent_parent_parent);\n+    let parent_parent_parent_parent_node = hir.get(parent_parent_parent_parent);\n+\n+    if let hir::Node::Expr(hir::Expr {\n+        kind: hir::ExprKind::Loop(_, _, hir::LoopSource::While, _),\n+        ..\n+    }) = parent_parent_parent_parent_node\n+    {\n+        LetSource::WhileLet\n+    } else if let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::If { .. }, .. }) =\n+        parent_parent_node\n+    {\n+        LetSource::IfLet\n+    } else {\n+        LetSource::GenericLet\n+    }\n+}"}, {"sha": "068bd36af55240c8e2f4c1e3ec1d4b1c7884b7d6", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 68, "deletions": 10, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -11,8 +11,9 @@ use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, TokenKind};\n use rustc_ast::util::classify;\n-use rustc_ast::AstLike;\n-use rustc_ast::{AttrStyle, AttrVec, Attribute, MacCall, MacCallStmt, MacStmtStyle};\n+use rustc_ast::{\n+    AstLike, AttrStyle, AttrVec, Attribute, LocalKind, MacCall, MacCallStmt, MacStmtStyle,\n+};\n use rustc_ast::{Block, BlockCheckMode, Expr, ExprKind, Local, Stmt};\n use rustc_ast::{StmtKind, DUMMY_NODE_ID};\n use rustc_errors::{Applicability, PResult};\n@@ -292,8 +293,65 @@ impl<'a> Parser<'a> {\n                 return Err(err);\n             }\n         };\n+        let kind = match init {\n+            None => LocalKind::Decl,\n+            Some(init) => {\n+                if self.eat_keyword(kw::Else) {\n+                    let els = self.parse_block()?;\n+                    self.check_let_else_init_bool_expr(&init);\n+                    self.check_let_else_init_trailing_brace(&init);\n+                    LocalKind::InitElse(init, els)\n+                } else {\n+                    LocalKind::Init(init)\n+                }\n+            }\n+        };\n         let hi = if self.token == token::Semi { self.token.span } else { self.prev_token.span };\n-        Ok(P(ast::Local { ty, pat, init, id: DUMMY_NODE_ID, span: lo.to(hi), attrs, tokens: None }))\n+        Ok(P(ast::Local { ty, pat, kind, id: DUMMY_NODE_ID, span: lo.to(hi), attrs, tokens: None }))\n+    }\n+\n+    fn check_let_else_init_bool_expr(&self, init: &ast::Expr) {\n+        if let ast::ExprKind::Binary(op, ..) = init.kind {\n+            if op.node.lazy() {\n+                let suggs = vec![\n+                    (init.span.shrink_to_lo(), \"(\".to_string()),\n+                    (init.span.shrink_to_hi(), \")\".to_string()),\n+                ];\n+                self.struct_span_err(\n+                    init.span,\n+                    &format!(\n+                        \"a `{}` expression cannot be directly assigned in `let...else`\",\n+                        op.node.to_string()\n+                    ),\n+                )\n+                .multipart_suggestion(\n+                    \"wrap the expression in parenthesis\",\n+                    suggs,\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+            }\n+        }\n+    }\n+\n+    fn check_let_else_init_trailing_brace(&self, init: &ast::Expr) {\n+        if let Some(trailing) = classify::expr_trailing_brace(init) {\n+            let err_span = trailing.span.with_lo(trailing.span.hi() - BytePos(1));\n+            let suggs = vec![\n+                (trailing.span.shrink_to_lo(), \"(\".to_string()),\n+                (trailing.span.shrink_to_hi(), \")\".to_string()),\n+            ];\n+            self.struct_span_err(\n+                err_span,\n+                \"right curly brace `}` before `else` in a `let...else` statement not allowed\",\n+            )\n+            .multipart_suggestion(\n+                \"try wrapping the expression in parenthesis\",\n+                suggs,\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+        }\n     }\n \n     /// Parses the RHS of a local variable declaration (e.g., `= 14;`).\n@@ -495,13 +553,13 @@ impl<'a> Parser<'a> {\n             StmtKind::Expr(_) | StmtKind::MacCall(_) => {}\n             StmtKind::Local(ref mut local) if let Err(e) = self.expect_semi() => {\n                 // We might be at the `,` in `let x = foo<bar, baz>;`. Try to recover.\n-                match &mut local.init {\n-                    Some(ref mut expr) => {\n-                        self.check_mistyped_turbofish_with_multiple_type_params(e, expr)?;\n-                        // We found `foo<bar, baz>`, have we fully recovered?\n-                        self.expect_semi()?;\n-                    }\n-                    None => return Err(e),\n+                match &mut local.kind {\n+                    LocalKind::Init(expr) | LocalKind::InitElse(expr, _) => {\n+                            self.check_mistyped_turbofish_with_multiple_type_params(e, expr)?;\n+                            // We found `foo<bar, baz>`, have we fully recovered?\n+                            self.expect_semi()?;\n+                        }\n+                        LocalKind::Decl => return Err(e),\n                 }\n                 eat_semi = false;\n             }"}, {"sha": "5c7b4b028227ec3c9c0bc67654ffc5827e8c825f", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -454,7 +454,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             _ => Some((\n                 local.pat.span,\n                 local.ty.as_ref().map(|ty| ty.span),\n-                local.init.as_ref().map(|init| init.span),\n+                local.kind.init().map(|init| init.span),\n             )),\n         };\n         let original = replace(&mut self.diagnostic_metadata.current_let_binding, local_spans);\n@@ -1426,7 +1426,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         walk_list!(self, visit_ty, &local.ty);\n \n         // Resolve the initializer.\n-        walk_list!(self, visit_expr, &local.init);\n+        if let Some((init, els)) = local.kind.init_else_opt() {\n+            self.visit_expr(init);\n+\n+            // Resolve the `else` block\n+            if let Some(els) = els {\n+                self.visit_block(els);\n+            }\n+        }\n \n         // Resolve the pattern.\n         self.resolve_pattern_top(&local.pat, PatternSource::Let);"}, {"sha": "c22093c5a428811ac78241029325969330873b41", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -1097,6 +1097,7 @@ pub enum DesugaringKind {\n     Async,\n     Await,\n     ForLoop(ForLoopLoc),\n+    LetElse,\n }\n \n /// A location in the desugaring of a `for` loop\n@@ -1117,6 +1118,7 @@ impl DesugaringKind {\n             DesugaringKind::TryBlock => \"`try` block\",\n             DesugaringKind::OpaqueTy => \"`impl Trait`\",\n             DesugaringKind::ForLoop(_) => \"`for` loop\",\n+            DesugaringKind::LetElse => \"`let...else`\",\n         }\n     }\n }"}, {"sha": "899c51e12ff1f42f25e5e3babf37748038077cef", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -744,6 +744,7 @@ symbols! {\n         le,\n         len,\n         let_chains,\n+        let_else,\n         lhs,\n         lib,\n         libc,"}, {"sha": "db3432b01422fabe81afa2654993521cb3672be6", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -1928,7 +1928,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             | ObligationCauseCode::OpaqueType\n             | ObligationCauseCode::MiscObligation\n             | ObligationCauseCode::WellFormed(..)\n-            | ObligationCauseCode::MatchImpl(..) => {}\n+            | ObligationCauseCode::MatchImpl(..)\n+            | ObligationCauseCode::ReturnType\n+            | ObligationCauseCode::ReturnValue(_)\n+            | ObligationCauseCode::BlockTailExpression(_)\n+            | ObligationCauseCode::LetElse => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }\n@@ -2338,9 +2342,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     predicate\n                 ));\n             }\n-            ObligationCauseCode::ReturnType\n-            | ObligationCauseCode::ReturnValue(_)\n-            | ObligationCauseCode::BlockTailExpression(_) => (),\n             ObligationCauseCode::TrivialBound => {\n                 err.help(\"see issue #48214\");\n                 if tcx.sess.opts.unstable_features.is_nightly_build() {"}, {"sha": "10f5b000aca1c84e3a30eb23aac00979d711ca98", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -849,7 +849,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         coerce.coerce(self, &self.misc(sp), then_expr, then_ty);\n \n         if let Some(else_expr) = opt_else_expr {\n-            let else_ty = self.check_expr_with_expectation(else_expr, expected);\n+            let else_ty = if sp.desugaring_kind() == Some(DesugaringKind::LetElse) {\n+                // todo introduce `check_expr_with_expectation(.., Expectation::LetElse)`\n+                //   for errors that point to the offending expression rather than the entire block.\n+                //   We could use `check_expr_eq_type(.., tcx.types.never)`, but then there is no\n+                //   way to detect that the expected type originated from let-else and provide\n+                //   a customized error.\n+                let else_ty = self.check_expr(else_expr);\n+                let cause = self.cause(else_expr.span, ObligationCauseCode::LetElse);\n+\n+                if let Some(mut err) =\n+                    self.demand_eqtype_with_origin(&cause, self.tcx.types.never, else_ty)\n+                {\n+                    err.emit();\n+                    self.tcx.ty_error()\n+                } else {\n+                    else_ty\n+                }\n+            } else {\n+                self.check_expr_with_expectation(else_expr, expected)\n+            };\n             let else_diverges = self.diverges.get();\n \n             let opt_suggest_box_span ="}, {"sha": "d2938435ece31b0ae435d0b714ddfaa9ee51193d", "filename": "src/test/ui/did_you_mean/issue-40396.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -31,11 +31,11 @@ help: use `::<...>` instead of `<...>` to specify type or const arguments\n LL |     (0..13).collect::<Vec<i32>();\n    |                    ++\n \n-error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, or an operator, found `,`\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `,`\n   --> $DIR/issue-40396.rs:11:43\n    |\n LL |     let x = std::collections::HashMap<i128, i128>::new();\n-   |                                           ^ expected one of 7 possible tokens\n+   |                                           ^ expected one of 8 possible tokens\n    |\n help: use `::<...>` instead of `<...>` to specify type or const arguments\n    |"}, {"sha": "3f04a9dabfd1f743046b2a87c69b558919743863", "filename": "src/test/ui/feature-gates/feature-gate-let_else.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-let_else.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let Some(x) = Some(1) else { //~ ERROR `let...else` statements are unstable\n+        return;\n+    };\n+}"}, {"sha": "8625260415467f23b3fdc983391bb6c791764a33", "filename": "src/test/ui/feature-gates/feature-gate-let_else.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-let_else.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,14 @@\n+error[E0658]: `let...else` statements are unstable\n+  --> $DIR/feature-gate-let_else.rs:2:5\n+   |\n+LL | /     let Some(x) = Some(1) else {\n+LL | |         return;\n+LL | |     };\n+   | |______^\n+   |\n+   = note: see issue #87335 <https://github.com/rust-lang/rust/issues/87335> for more information\n+   = help: add `#![feature(let_else)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "e47f7f23d7e07938aa54dc3b978c7ff4a04de780", "filename": "src/test/ui/let-else/let-else-bool-binop-init.fixed", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-bool-binop-init.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-bool-binop-init.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-bool-binop-init.fixed?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+\n+#![feature(let_else)]\n+\n+fn main() {\n+    let true = (true && false) else { return }; //~ ERROR a `&&` expression cannot be directly assigned in `let...else`\n+    let true = (true || false) else { return }; //~ ERROR a `||` expression cannot be directly assigned in `let...else`\n+}"}, {"sha": "e443fb0d6a376a4f57ebe0c20edcde8cfc3bdf11", "filename": "src/test/ui/let-else/let-else-bool-binop-init.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-bool-binop-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-bool-binop-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-bool-binop-init.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+\n+#![feature(let_else)]\n+\n+fn main() {\n+    let true = true && false else { return }; //~ ERROR a `&&` expression cannot be directly assigned in `let...else`\n+    let true = true || false else { return }; //~ ERROR a `||` expression cannot be directly assigned in `let...else`\n+}"}, {"sha": "6551e24cc83d063376dd6a066269ea9f4f587618", "filename": "src/test/ui/let-else/let-else-bool-binop-init.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-bool-binop-init.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-bool-binop-init.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-bool-binop-init.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,24 @@\n+error: a `&&` expression cannot be directly assigned in `let...else`\n+  --> $DIR/let-else-bool-binop-init.rs:6:16\n+   |\n+LL |     let true = true && false else { return };\n+   |                ^^^^^^^^^^^^^\n+   |\n+help: wrap the expression in parenthesis\n+   |\n+LL |     let true = (true && false) else { return };\n+   |                +             +\n+\n+error: a `||` expression cannot be directly assigned in `let...else`\n+  --> $DIR/let-else-bool-binop-init.rs:7:16\n+   |\n+LL |     let true = true || false else { return };\n+   |                ^^^^^^^^^^^^^\n+   |\n+help: wrap the expression in parenthesis\n+   |\n+LL |     let true = (true || false) else { return };\n+   |                +             +\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "fb4fd77791e030045f71f4e584ac32133a720996", "filename": "src/test/ui/let-else/let-else-brace-before-else.fixed", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.fixed?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,26 @@\n+// run-rustfix\n+\n+#![feature(let_else)]\n+\n+fn main() {\n+    let Some(1) = ({ Some(1) }) else {\n+        //~^ ERROR right curly brace `}` before `else` in a `let...else` statement not allowed\n+        return;\n+    };\n+    let Some(1) = (loop { break Some(1) }) else {\n+        //~^ ERROR right curly brace `}` before `else` in a `let...else` statement not allowed\n+        return;\n+    };\n+    let 2 = 1 + (match 1 { n => n }) else {\n+        //~^ ERROR right curly brace `}` before `else` in a `let...else` statement not allowed\n+        return;\n+    };\n+    let Some(1) = (unsafe { unsafe_fn() }) else {\n+        //~^ ERROR right curly brace `}` before `else` in a `let...else` statement not allowed\n+        return;\n+    };\n+}\n+\n+unsafe fn unsafe_fn<T>() -> T {\n+    unimplemented!();\n+}"}, {"sha": "c4c5a1ca28bbefbc588af6456fea6224e70b809f", "filename": "src/test/ui/let-else/let-else-brace-before-else.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,26 @@\n+// run-rustfix\n+\n+#![feature(let_else)]\n+\n+fn main() {\n+    let Some(1) = { Some(1) } else {\n+        //~^ ERROR right curly brace `}` before `else` in a `let...else` statement not allowed\n+        return;\n+    };\n+    let Some(1) = loop { break Some(1) } else {\n+        //~^ ERROR right curly brace `}` before `else` in a `let...else` statement not allowed\n+        return;\n+    };\n+    let 2 = 1 + match 1 { n => n } else {\n+        //~^ ERROR right curly brace `}` before `else` in a `let...else` statement not allowed\n+        return;\n+    };\n+    let Some(1) = unsafe { unsafe_fn() } else {\n+        //~^ ERROR right curly brace `}` before `else` in a `let...else` statement not allowed\n+        return;\n+    };\n+}\n+\n+unsafe fn unsafe_fn<T>() -> T {\n+    unimplemented!();\n+}"}, {"sha": "eac029c848b20ada60838cc0cab55d844302fb26", "filename": "src/test/ui/let-else/let-else-brace-before-else.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,46 @@\n+error: right curly brace `}` before `else` in a `let...else` statement not allowed\n+  --> $DIR/let-else-brace-before-else.rs:6:29\n+   |\n+LL |     let Some(1) = { Some(1) } else {\n+   |                             ^\n+   |\n+help: try wrapping the expression in parenthesis\n+   |\n+LL |     let Some(1) = ({ Some(1) }) else {\n+   |                   +           +\n+\n+error: right curly brace `}` before `else` in a `let...else` statement not allowed\n+  --> $DIR/let-else-brace-before-else.rs:10:40\n+   |\n+LL |     let Some(1) = loop { break Some(1) } else {\n+   |                                        ^\n+   |\n+help: try wrapping the expression in parenthesis\n+   |\n+LL |     let Some(1) = (loop { break Some(1) }) else {\n+   |                   +                      +\n+\n+error: right curly brace `}` before `else` in a `let...else` statement not allowed\n+  --> $DIR/let-else-brace-before-else.rs:14:34\n+   |\n+LL |     let 2 = 1 + match 1 { n => n } else {\n+   |                                  ^\n+   |\n+help: try wrapping the expression in parenthesis\n+   |\n+LL |     let 2 = 1 + (match 1 { n => n }) else {\n+   |                 +                  +\n+\n+error: right curly brace `}` before `else` in a `let...else` statement not allowed\n+  --> $DIR/let-else-brace-before-else.rs:18:40\n+   |\n+LL |     let Some(1) = unsafe { unsafe_fn() } else {\n+   |                                        ^\n+   |\n+help: try wrapping the expression in parenthesis\n+   |\n+LL |     let Some(1) = (unsafe { unsafe_fn() }) else {\n+   |                   +                      +\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "ab763447ef7e1abe754064a5c02765bf4840c7db", "filename": "src/test/ui/let-else/let-else-check.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,14 @@\n+#![feature(let_else)]\n+\n+#![deny(unused_variables)]\n+\n+fn main() {\n+    // type annotation, attributes\n+    #[allow(unused_variables)]\n+    let Some(_): Option<u32> = Some(Default::default()) else {\n+        let x = 1; // OK\n+        return;\n+    };\n+\n+    let x = 1; //~ ERROR unused variable: `x`\n+}"}, {"sha": "50e54d320b006ced046b0147259e197d38427225", "filename": "src/test/ui/let-else/let-else-check.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,14 @@\n+error: unused variable: `x`\n+  --> $DIR/let-else-check.rs:13:9\n+   |\n+LL |     let x = 1;\n+   |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/let-else-check.rs:3:9\n+   |\n+LL | #![deny(unused_variables)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "b1e09a1248ff7cae6e0c3964c08f343cc16605da", "filename": "src/test/ui/let-else/let-else-irrefutable.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-irrefutable.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,7 @@\n+// check-pass\n+\n+#![feature(let_else)]\n+\n+fn main() {\n+    let x = 1 else { return }; //~ WARN irrefutable `let...else` pattern\n+}"}, {"sha": "e030c50d45dcf7b4aed415121f370d5007a31b54", "filename": "src/test/ui/let-else/let-else-irrefutable.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-irrefutable.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,12 @@\n+warning: irrefutable `let...else` pattern\n+  --> $DIR/let-else-irrefutable.rs:6:5\n+   |\n+LL |     let x = 1 else { return };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(irrefutable_let_patterns)]` on by default\n+   = note: this pattern will always match, so the `else` clause is useless\n+   = help: consider removing the `else` clause\n+\n+warning: 1 warning emitted\n+"}, {"sha": "ed9d79f1ebde9c45dcb9cfabbb02397742cd6e18", "filename": "src/test/ui/let-else/let-else-missing-semicolon.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-missing-semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-missing-semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-missing-semicolon.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,11 @@\n+#![feature(let_else)]\n+\n+fn main() {\n+    let Some(x) = Some(1) else {\n+        return;\n+    } //~ ERROR expected `;`, found keyword `let`\n+    let _ = \"\";\n+    let Some(x) = Some(1) else {\n+        panic!();\n+    } //~ ERROR expected `;`, found `}`\n+}"}, {"sha": "1818a0b1263487cbcff6f130557c155b990a7b8e", "filename": "src/test/ui/let-else/let-else-missing-semicolon.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-missing-semicolon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-missing-semicolon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-missing-semicolon.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,18 @@\n+error: expected `;`, found keyword `let`\n+  --> $DIR/let-else-missing-semicolon.rs:6:6\n+   |\n+LL |     }\n+   |      ^ help: add `;` here\n+LL |     let _ = \"\";\n+   |     --- unexpected token\n+\n+error: expected `;`, found `}`\n+  --> $DIR/let-else-missing-semicolon.rs:10:6\n+   |\n+LL |     }\n+   |      ^ help: add `;` here\n+LL | }\n+   | - unexpected token\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a1cee335aeeba49d20849be48c0b51c8529b6a3f", "filename": "src/test/ui/let-else/let-else-non-diverging.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-diverging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-diverging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-diverging.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,13 @@\n+#![feature(let_else)]\n+\n+fn main() {\n+    let Some(x) = Some(1) else { //~ ERROR does not diverge\n+        Some(2)\n+    };\n+    let Some(x) = Some(1) else { //~ ERROR does not diverge\n+        if 1 == 1 {\n+            panic!();\n+        }\n+    };\n+    let Some(x) = Some(1) else { Some(2) }; //~ ERROR does not diverge\n+}"}, {"sha": "fd5a18ce7ea51278921b65d6723a052e41f33792", "filename": "src/test/ui/let-else/let-else-non-diverging.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-diverging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-diverging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-diverging.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,44 @@\n+error[E0308]: `else` clause of `let...else` does not diverge\n+  --> $DIR/let-else-non-diverging.rs:12:32\n+   |\n+LL |     let Some(x) = Some(1) else { Some(2) };\n+   |                                ^^^^^^^^^^^ expected `!`, found enum `Option`\n+   |\n+   = note: expected type `!`\n+              found type `Option<{integer}>`\n+   = help: try adding a diverging expression, such as `return` or `panic!(..)`\n+   = help: ...or use `match` instead of `let...else`\n+\n+error[E0308]: `else` clause of `let...else` does not diverge\n+  --> $DIR/let-else-non-diverging.rs:7:32\n+   |\n+LL |       let Some(x) = Some(1) else {\n+   |  ________________________________^\n+LL | |         if 1 == 1 {\n+LL | |             panic!();\n+LL | |         }\n+LL | |     };\n+   | |_____^ expected `!`, found `()`\n+   |\n+   = note: expected type `!`\n+              found type `()`\n+   = help: try adding a diverging expression, such as `return` or `panic!(..)`\n+   = help: ...or use `match` instead of `let...else`\n+\n+error[E0308]: `else` clause of `let...else` does not diverge\n+  --> $DIR/let-else-non-diverging.rs:4:32\n+   |\n+LL |       let Some(x) = Some(1) else {\n+   |  ________________________________^\n+LL | |         Some(2)\n+LL | |     };\n+   | |_____^ expected `!`, found enum `Option`\n+   |\n+   = note: expected type `!`\n+              found type `Option<{integer}>`\n+   = help: try adding a diverging expression, such as `return` or `panic!(..)`\n+   = help: ...or use `match` instead of `let...else`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "5d96623236dab6bc6e7798f81e9910af88c241c7", "filename": "src/test/ui/let-else/let-else-run-pass.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-run-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-run-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-run-pass.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,35 @@\n+// run-pass\n+\n+#![feature(let_else)]\n+\n+fn main() {\n+    #[allow(dead_code)]\n+    enum MyEnum {\n+        A(String),\n+        B { f: String },\n+        C,\n+    }\n+    // ref binding to non-copy value and or-pattern\n+    let (MyEnum::A(ref x) | MyEnum::B { f: ref x }) = (MyEnum::B { f: String::new() }) else {\n+        panic!();\n+    };\n+    assert_eq!(x, \"\");\n+\n+    // nested let-else\n+    let mut x = 1;\n+    loop {\n+        let 4 = x else {\n+            let 3 = x else {\n+                x += 1;\n+                continue;\n+            };\n+            break;\n+        };\n+        panic!();\n+    }\n+    assert_eq!(x, 3);\n+\n+    // else return\n+    let Some(1) = Some(2) else { return };\n+    panic!();\n+}"}, {"sha": "f17682db4c3bd04529bed5c680b2fc2cd623a574", "filename": "src/test/ui/let-else/let-else-scope.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-scope.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,7 @@\n+#![feature(let_else)]\n+\n+fn main() {\n+    let Some(x) = Some(2) else {\n+        panic!(\"{}\", x); //~ ERROR cannot find value `x` in this scope\n+    };\n+}"}, {"sha": "4b3936eac4bd5a93d2996b71348d1eb7dba5635c", "filename": "src/test/ui/let-else/let-else-scope.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Flet-else%2Flet-else-scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-scope.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/let-else-scope.rs:5:22\n+   |\n+LL |         panic!(\"{}\", x);\n+   |                      ^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "cec6980c008c4c9cc74350c2abd46e4afc5bd3ac", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -12,11 +12,11 @@ error: expected expression, found `]`\n LL | #[cfg(FALSE)] fn e() { let _ = [#[attr]]; }\n    |                                        ^ expected expression\n \n-error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, or an operator, found `#`\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `#`\n   --> $DIR/attr-stmt-expr-attr-bad.rs:9:35\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = foo#[attr](); }\n-   |                                   ^ expected one of 7 possible tokens\n+   |                                   ^ expected one of 8 possible tokens\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:11:36\n@@ -70,11 +70,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = -#![attr] 0; }\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n-error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, or an operator, found `#`\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `#`\n   --> $DIR/attr-stmt-expr-attr-bad.rs:23:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x #![attr] as Y; }\n-   |                                  ^ expected one of 7 possible tokens\n+   |                                  ^ expected one of 8 possible tokens\n \n error: an inner attribute is not permitted in this context\n   --> $DIR/attr-stmt-expr-attr-bad.rs:25:35\n@@ -372,23 +372,23 @@ error: unexpected token: `#`\n LL | #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n    |                                  ^\n \n-error: expected one of `.`, `;`, `?`, or an operator, found `#`\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n   --> $DIR/attr-stmt-expr-attr-bad.rs:100:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n-   |                                  ^ expected one of `.`, `;`, `?`, or an operator\n+   |                                  ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: unexpected token: `#`\n   --> $DIR/attr-stmt-expr-attr-bad.rs:103:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n    |                                  ^\n \n-error: expected one of `.`, `;`, `?`, or an operator, found `#`\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n   --> $DIR/attr-stmt-expr-attr-bad.rs:103:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n-   |                                  ^ expected one of `.`, `;`, `?`, or an operator\n+   |                                  ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: expected statement after outer attribute\n   --> $DIR/attr-stmt-expr-attr-bad.rs:108:37"}, {"sha": "1446a796fa0d5ba81825cad5d9e846dfd8bcd510", "filename": "src/test/ui/parser/issue-72253.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fissue-72253.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fissue-72253.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-72253.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let a = std::process::Command::new(\"echo\")\n         .arg(\"1\")\n-        ,arg(\"2\") //~ ERROR expected one of `.`, `;`, `?`, or an operator, found `,`\n+        ,arg(\"2\") //~ ERROR expected one of `.`, `;`, `?`, `else`, or an operator, found `,`\n         .output();\n }"}, {"sha": "477fa09f495e23c315b7702283db3a1948dd407d", "filename": "src/test/ui/parser/issue-72253.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fissue-72253.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fissue-72253.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-72253.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `.`, `;`, `?`, or an operator, found `,`\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `,`\n   --> $DIR/issue-72253.rs:4:9\n    |\n LL |         .arg(\"1\")\n-   |                  - expected one of `.`, `;`, `?`, or an operator\n+   |                  - expected one of `.`, `;`, `?`, `else`, or an operator\n LL |         ,arg(\"2\")\n    |         ^ unexpected token\n "}, {"sha": "919585877cf9cfa899c7e234188c72a108f0c97c", "filename": "src/test/ui/parser/issue-84117.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fissue-84117.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fissue-84117.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-84117.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -2,8 +2,8 @@ fn main() {\n     let outer_local:e_outer<&str, { let inner_local:e_inner<&str, }\n     //~^ ERROR expected one of `>`, a const expression\n     //~| ERROR expected one of `>`, a const expression, lifetime, or type, found `}`\n-    //~| ERROR expected one of `!`, `.`, `::`, `;`, `?`, `{`, or an operator, found `,`\n-    //~| ERROR expected one of `!`, `.`, `::`, `;`, `?`, `{`, or an operator, found `,`\n-    //~| ERROR expected one of `!`, `.`, `::`, `;`, `?`, `{`, or an operator, found `,`\n+    //~| ERROR expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `,`\n+    //~| ERROR expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `,`\n+    //~| ERROR expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `,`\n }\n //~^ ERROR expected one of `,`, `:`, `=`, or `>`, found `}`"}, {"sha": "5b9cc53baa5eb891d247ca8a950ca9bd2c0b0574", "filename": "src/test/ui/parser/issue-84117.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fissue-84117.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fissue-84117.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-84117.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -7,11 +7,11 @@ LL |     let outer_local:e_outer<&str, { let inner_local:e_inner<&str, }\n    |                                         |          help: use `=` if you meant to assign\n    |                                         while parsing the type for `inner_local`\n \n-error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, or an operator, found `,`\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `,`\n   --> $DIR/issue-84117.rs:2:65\n    |\n LL |     let outer_local:e_outer<&str, { let inner_local:e_inner<&str, }\n-   |                                                                 ^ expected one of 7 possible tokens\n+   |                                                                 ^ expected one of 8 possible tokens\n \n error: expected one of `,`, `:`, `=`, or `>`, found `}`\n   --> $DIR/issue-84117.rs:8:1\n@@ -33,17 +33,17 @@ LL |     let outer_local:e_outer<&str, { let inner_local:e_inner<&str, }\n    |                                         |          help: use `=` if you meant to assign\n    |                                         while parsing the type for `inner_local`\n \n-error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, or an operator, found `,`\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `,`\n   --> $DIR/issue-84117.rs:2:65\n    |\n LL |     let outer_local:e_outer<&str, { let inner_local:e_inner<&str, }\n-   |                                                                 ^ expected one of 7 possible tokens\n+   |                                                                 ^ expected one of 8 possible tokens\n \n-error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, or an operator, found `,`\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `,`\n   --> $DIR/issue-84117.rs:2:33\n    |\n LL |     let outer_local:e_outer<&str, { let inner_local:e_inner<&str, }\n-   |                                 ^ expected one of 7 possible tokens\n+   |                                 ^ expected one of 8 possible tokens\n \n error: aborting due to 6 previous errors\n "}, {"sha": "8d9636d401c1ed0fa83414165c00fdffac342d1b", "filename": "src/test/ui/parser/macro/issue-37234.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-37234.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-37234.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-37234.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `.`, `;`, `?`, or an operator, found `\"\"`\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `\"\"`\n   --> $DIR/issue-37234.rs:3:19\n    |\n LL |         let x = 5 \"\";\n-   |                   ^^ expected one of `.`, `;`, `?`, or an operator\n+   |                   ^^ expected one of `.`, `;`, `?`, `else`, or an operator\n ...\n LL |     failed!();\n    |     ---------- in this macro invocation"}, {"sha": "f68d177c01f1fe04061871d6a4aa7d9ccbd0ea69", "filename": "src/test/ui/parser/missing-semicolon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fmissing-semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fmissing-semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmissing-semicolon.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -1,6 +1,6 @@\n macro_rules! m {\n     ($($e1:expr),*; $($e2:expr),*) => {\n-        $( let x = $e1 )*; //~ ERROR expected one of `.`, `;`, `?`, or\n+        $( let x = $e1 )*; //~ ERROR expected one of `.`, `;`, `?`, `else`, or\n         $( println!(\"{}\", $e2) )*;\n     }\n }"}, {"sha": "72f76b6fe3f548ce62809f6a58259d212afec891", "filename": "src/test/ui/parser/missing-semicolon.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fmissing-semicolon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Fmissing-semicolon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmissing-semicolon.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `.`, `;`, `?`, or an operator, found keyword `let`\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found keyword `let`\n   --> $DIR/missing-semicolon.rs:3:12\n    |\n LL |         $( let x = $e1 )*;\n-   |            ^^^ expected one of `.`, `;`, `?`, or an operator\n+   |            ^^^ expected one of `.`, `;`, `?`, `else`, or an operator\n ...\n LL | fn main() { m!(0, 0; 0, 0); }\n    |             --------------- in this macro invocation"}, {"sha": "2c917a24e908aa1e030356b86fb0d6ab83beee34", "filename": "src/test/ui/parser/range-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Frange-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Frange-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frange-3.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -2,5 +2,5 @@\n \n pub fn main() {\n     let r = 1..2..3;\n-    //~^ ERROR expected one of `.`, `;`, `?`, or an operator, found `..`\n+    //~^ ERROR expected one of `.`, `;`, `?`, `else`, or an operator, found `..`\n }"}, {"sha": "340167f1804e37a868dd6beac1addfd96e984d9d", "filename": "src/test/ui/parser/range-3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Frange-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Frange-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frange-3.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `.`, `;`, `?`, or an operator, found `..`\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `..`\n   --> $DIR/range-3.rs:4:17\n    |\n LL |     let r = 1..2..3;\n-   |                 ^^ expected one of `.`, `;`, `?`, or an operator\n+   |                 ^^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: aborting due to previous error\n "}, {"sha": "c970c96de849094b14c1f2e637abee323778ff32", "filename": "src/test/ui/parser/range-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Frange-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Frange-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frange-4.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -2,5 +2,5 @@\n \n pub fn main() {\n     let r = ..1..2;\n-    //~^ ERROR expected one of `.`, `;`, `?`, or an operator, found `..`\n+    //~^ ERROR expected one of `.`, `;`, `?`, `else`, or an operator, found `..`\n }"}, {"sha": "720d489389bfb7876f3b69253fe6d58f9030c40b", "filename": "src/test/ui/parser/range-4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Frange-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fparser%2Frange-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frange-4.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `.`, `;`, `?`, or an operator, found `..`\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `..`\n   --> $DIR/range-4.rs:4:16\n    |\n LL |     let r = ..1..2;\n-   |                ^^ expected one of `.`, `;`, `?`, or an operator\n+   |                ^^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: aborting due to previous error\n "}, {"sha": "076de846129e676b51b742fbe1b8ed0c1c09f51a", "filename": "src/test/ui/pattern/usefulness/top-level-alternation.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -1,3 +1,5 @@\n+#![feature(let_else)]\n+\n #![deny(unreachable_patterns)]\n \n fn main() {\n@@ -53,4 +55,5 @@ fn main() {\n         1..=2 => {}, //~ ERROR unreachable pattern\n         _ => {},\n     }\n+    let (0 | 0) = 0 else { return }; //~ ERROR unreachable pattern\n }"}, {"sha": "dd5936fdcc42930c9ca3afb2d1a29153377b0424", "filename": "src/test/ui/pattern/usefulness/top-level-alternation.stderr", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.stderr?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -1,68 +1,74 @@\n error: unreachable pattern\n-  --> $DIR/top-level-alternation.rs:4:23\n+  --> $DIR/top-level-alternation.rs:6:23\n    |\n LL |     while let 0..=2 | 1 = 0 {}\n    |                       ^\n    |\n note: the lint level is defined here\n-  --> $DIR/top-level-alternation.rs:1:9\n+  --> $DIR/top-level-alternation.rs:3:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/top-level-alternation.rs:5:20\n+  --> $DIR/top-level-alternation.rs:7:20\n    |\n LL |     if let 0..=2 | 1 = 0 {}\n    |                    ^\n \n error: unreachable pattern\n-  --> $DIR/top-level-alternation.rs:9:15\n+  --> $DIR/top-level-alternation.rs:11:15\n    |\n LL |             | 0 => {}\n    |               ^\n \n error: unreachable pattern\n-  --> $DIR/top-level-alternation.rs:14:15\n+  --> $DIR/top-level-alternation.rs:16:15\n    |\n LL |             | Some(0) => {}\n    |               ^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/top-level-alternation.rs:19:9\n+  --> $DIR/top-level-alternation.rs:21:9\n    |\n LL |         (0, 0) => {}\n    |         ^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/top-level-alternation.rs:39:9\n+  --> $DIR/top-level-alternation.rs:41:9\n    |\n LL |         _ => {}\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/top-level-alternation.rs:43:9\n+  --> $DIR/top-level-alternation.rs:45:9\n    |\n LL |         Some(_) => {}\n    |         ^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/top-level-alternation.rs:44:9\n+  --> $DIR/top-level-alternation.rs:46:9\n    |\n LL |         None => {}\n    |         ^^^^\n \n error: unreachable pattern\n-  --> $DIR/top-level-alternation.rs:49:9\n+  --> $DIR/top-level-alternation.rs:51:9\n    |\n LL |         None | Some(_) => {}\n    |         ^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/top-level-alternation.rs:53:9\n+  --> $DIR/top-level-alternation.rs:55:9\n    |\n LL |         1..=2 => {},\n    |         ^^^^^\n \n-error: aborting due to 10 previous errors\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:58:14\n+   |\n+LL |     let (0 | 0) = 0 else { return };\n+   |              ^\n+\n+error: aborting due to 11 previous errors\n "}, {"sha": "2ffc00b449d08b7e9c25282579618b98ee233912", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -316,8 +316,11 @@ impl<'a, 'b> SimilarNamesLocalVisitor<'a, 'b> {\n \n impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n     fn visit_local(&mut self, local: &'tcx Local) {\n-        if let Some(ref init) = local.init {\n-            self.apply(|this| walk_expr(this, &**init));\n+        if let Some((init, els)) = &local.kind.init_else_opt() {\n+            self.apply(|this| walk_expr(this, init));\n+            if let Some(els) = els {\n+                self.apply(|this| walk_block(this, els));\n+            }\n         }\n         // add the pattern after the expression because the bindings aren't available\n         // yet in the init"}, {"sha": "133f6c29f7d2162d6300eca8c3d96d9f61af97d4", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -221,7 +221,7 @@ pub fn eq_stmt(l: &Stmt, r: &Stmt) -> bool {\n         (Local(l), Local(r)) => {\n             eq_pat(&l.pat, &r.pat)\n                 && both(&l.ty, &r.ty, |l, r| eq_ty(l, r))\n-                && eq_expr_opt(&l.init, &r.init)\n+                && eq_local_kind(&l.kind, &r.kind)\n                 && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n         },\n         (Item(l), Item(r)) => eq_item(l, r, eq_item_kind),\n@@ -234,6 +234,16 @@ pub fn eq_stmt(l: &Stmt, r: &Stmt) -> bool {\n     }\n }\n \n+pub fn eq_local_kind(l: &LocalKind, r: &LocalKind) -> bool {\n+    use LocalKind::*;\n+    match (l, r) {\n+        (Decl, Decl) => true,\n+        (Init(l), Init(r)) => eq_expr(l, r),\n+        (InitElse(li, le), InitElse(ri, re)) => eq_expr(li, ri) && eq_block(le, re),\n+        _ => false,\n+    }\n+}\n+\n pub fn eq_item<K>(l: &Item<K>, r: &Item<K>, mut eq_kind: impl FnMut(&K, &K) -> bool) -> bool {\n     eq_id(l.ident, r.ident)\n         && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))"}, {"sha": "2483d0570d9eaf1c27358646918b8bd56c50bfcb", "filename": "src/tools/rustfmt/src/items.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -48,7 +48,7 @@ impl Rewrite for ast::Local {\n \n         skip_out_of_file_lines_range!(context, self.span);\n \n-        if contains_skip(&self.attrs) {\n+        if contains_skip(&self.attrs) || matches!(self.kind, ast::LocalKind::InitElse(..)) {\n             return None;\n         }\n \n@@ -97,7 +97,7 @@ impl Rewrite for ast::Local {\n                 infix.push_str(&rewrite);\n             }\n \n-            if self.init.is_some() {\n+            if self.kind.init().is_some() {\n                 infix.push_str(\" =\");\n             }\n \n@@ -106,11 +106,12 @@ impl Rewrite for ast::Local {\n \n         result.push_str(&infix);\n \n-        if let Some(ref ex) = self.init {\n+        if let Some((init, _els)) = self.kind.init_else_opt() {\n             // 1 = trailing semicolon;\n             let nested_shape = shape.sub_width(1)?;\n \n-            result = rewrite_assign_rhs(context, result, &**ex, nested_shape)?;\n+            result = rewrite_assign_rhs(context, result, init, nested_shape)?;\n+            // todo else\n         }\n \n         result.push(';');"}, {"sha": "a6e816fb524b70ca01c72c4a66c41fe2b8fccc93", "filename": "src/tools/rustfmt/tests/source/let_else.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Flet_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Flet_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Flet_else.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let Some(1) = Some(1) else { return };\n+}"}, {"sha": "a6e816fb524b70ca01c72c4a66c41fe2b8fccc93", "filename": "src/tools/rustfmt/tests/target/let_else.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Flet_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a408840ad18f74280805535f0b7193528ff3df/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Flet_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Flet_else.rs?ref=c2a408840ad18f74280805535f0b7193528ff3df", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let Some(1) = Some(1) else { return };\n+}"}]}