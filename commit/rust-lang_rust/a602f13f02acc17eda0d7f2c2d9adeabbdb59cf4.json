{"sha": "a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MDJmMTNmMDJhY2MxN2VkYTBkN2YyYzJkOWFkZWFiYmRiNTljZjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-04T11:51:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-04T11:51:30Z"}, "message": "Auto merge of #55986 - cjgillot:issue-45510, r=nikomatsakis\n\nAllow to dispatch fn traits depending on number of parameters\n\nHello,\n\nBy following @eddyb's advise on issue #45510, I managed to have the snippets of code in #45510 and #18952 passing without breaking older diagnostics.\n\nEDIT: the codegen tests breakage I experienced is due to the poor quality of my laptop.\n\nIf any kind reviewer has any advice, you are very welcome.", "tree": {"sha": "04a0bd2d05491d2c0c03a4a353247a8cf3d67191", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04a0bd2d05491d2c0c03a4a353247a8cf3d67191"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4", "html_url": "https://github.com/rust-lang/rust/commit/a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae38baed33de726cbbf5edde75a3ae1dd311ebc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae38baed33de726cbbf5edde75a3ae1dd311ebc9", "html_url": "https://github.com/rust-lang/rust/commit/ae38baed33de726cbbf5edde75a3ae1dd311ebc9"}, {"sha": "91c155bcd7af54fba0b705de1a2c2d55fa9788fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/91c155bcd7af54fba0b705de1a2c2d55fa9788fa", "html_url": "https://github.com/rust-lang/rust/commit/91c155bcd7af54fba0b705de1a2c2d55fa9788fa"}], "stats": {"total": 454, "additions": 309, "deletions": 145}, "files": [{"sha": "c59c143f74b6227623321141946c611864813c28", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 221, "deletions": 145, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4", "patch": "@@ -1,16 +1,17 @@\n-use super::{Expectation, FnCtxt, Needs, TupleArgumentsFlag};\n use super::autoderef::Autoderef;\n use super::method::MethodCallee;\n+use super::{Expectation, FnCtxt, Needs, TupleArgumentsFlag};\n \n+use errors::Applicability;\n use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::{infer, traits};\n-use rustc::ty::{self, TyCtxt, TypeFoldable, Ty};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc_target::spec::abi;\n use syntax::ast::Ident;\n use syntax_pos::Span;\n-use errors::Applicability;\n \n use rustc::hir;\n \n@@ -33,19 +34,20 @@ enum CallStep<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn check_call(&self,\n-                      call_expr: &'gcx hir::Expr,\n-                      callee_expr: &'gcx hir::Expr,\n-                      arg_exprs: &'gcx [hir::Expr],\n-                      expected: Expectation<'tcx>)\n-                      -> Ty<'tcx> {\n+    pub fn check_call(\n+        &self,\n+        call_expr: &'gcx hir::Expr,\n+        callee_expr: &'gcx hir::Expr,\n+        arg_exprs: &'gcx [hir::Expr],\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n         let original_callee_ty = self.check_expr(callee_expr);\n         let expr_ty = self.structurally_resolved_type(call_expr.span, original_callee_ty);\n \n         let mut autoderef = self.autoderef(callee_expr.span, expr_ty);\n         let mut result = None;\n         while result.is_none() && autoderef.next().is_some() {\n-            result = self.try_overloaded_call_step(call_expr, callee_expr, &autoderef);\n+            result = self.try_overloaded_call_step(call_expr, callee_expr, arg_exprs, &autoderef);\n         }\n         autoderef.finalize(self);\n \n@@ -74,15 +76,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         output\n     }\n \n-    fn try_overloaded_call_step(&self,\n-                                call_expr: &'gcx hir::Expr,\n-                                callee_expr: &'gcx hir::Expr,\n-                                autoderef: &Autoderef<'a, 'gcx, 'tcx>)\n-                                -> Option<CallStep<'tcx>> {\n+    fn try_overloaded_call_step(\n+        &self,\n+        call_expr: &'gcx hir::Expr,\n+        callee_expr: &'gcx hir::Expr,\n+        arg_exprs: &'gcx [hir::Expr],\n+        autoderef: &Autoderef<'a, 'gcx, 'tcx>,\n+    ) -> Option<CallStep<'tcx>> {\n         let adjusted_ty = autoderef.unambiguous_final_ty(self);\n-        debug!(\"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?})\",\n-               call_expr,\n-               adjusted_ty);\n+        debug!(\n+            \"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?})\",\n+            call_expr, adjusted_ty\n+        );\n \n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.sty {\n@@ -100,21 +105,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n                 if self.closure_kind(def_id, substs).is_none() {\n                     let closure_ty = self.closure_sig(def_id, substs);\n-                    let fn_sig = self.replace_bound_vars_with_fresh_vars(\n-                        call_expr.span,\n-                        infer::FnCall,\n-                        &closure_ty\n-                    ).0;\n+                    let fn_sig = self\n+                        .replace_bound_vars_with_fresh_vars(\n+                            call_expr.span,\n+                            infer::FnCall,\n+                            &closure_ty,\n+                        )\n+                        .0;\n                     let adjustments = autoderef.adjust_steps(self, Needs::None);\n-                    self.record_deferred_call_resolution(def_id, DeferredCallResolution {\n-                        call_expr,\n-                        callee_expr,\n-                        adjusted_ty,\n-                        adjustments,\n-                        fn_sig,\n-                        closure_def_id: def_id,\n-                        closure_substs: substs,\n-                    });\n+                    self.record_deferred_call_resolution(\n+                        def_id,\n+                        DeferredCallResolution {\n+                            call_expr,\n+                            callee_expr,\n+                            adjusted_ty,\n+                            adjustments,\n+                            fn_sig,\n+                            closure_def_id: def_id,\n+                            closure_substs: substs,\n+                        },\n+                    );\n                     return Some(CallStep::DeferredClosure(fn_sig));\n                 }\n             }\n@@ -134,34 +144,68 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n-        self.try_overloaded_call_traits(call_expr, adjusted_ty).map(|(autoref, method)| {\n-            let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n-            adjustments.extend(autoref);\n-            self.apply_adjustments(callee_expr, adjustments);\n-            CallStep::Overloaded(method)\n-        })\n+        // Now, we look for the implementation of a Fn trait on the object's type.\n+        // We first do it with the explicit instruction to look for an impl of\n+        // `Fn<Tuple>`, with the tuple `Tuple` having an arity corresponding\n+        // to the number of call parameters.\n+        // If that fails (or_else branch), we try again without specifying the\n+        // shape of the tuple (hence the None). This allows to detect an Fn trait\n+        // is implemented, and use this information for diagnostic.\n+        self.try_overloaded_call_traits(call_expr, adjusted_ty, Some(arg_exprs))\n+            .or_else(|| self.try_overloaded_call_traits(call_expr, adjusted_ty, None))\n+            .map(|(autoref, method)| {\n+                let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n+                adjustments.extend(autoref);\n+                self.apply_adjustments(callee_expr, adjustments);\n+                CallStep::Overloaded(method)\n+            })\n     }\n \n-    fn try_overloaded_call_traits(&self,\n-                                  call_expr: &hir::Expr,\n-                                  adjusted_ty: Ty<'tcx>)\n-                                  -> Option<(Option<Adjustment<'tcx>>,\n-                                             MethodCallee<'tcx>)> {\n+    fn try_overloaded_call_traits(\n+        &self,\n+        call_expr: &hir::Expr,\n+        adjusted_ty: Ty<'tcx>,\n+        opt_arg_exprs: Option<&'gcx [hir::Expr]>,\n+    ) -> Option<(Option<Adjustment<'tcx>>, MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n-        for &(opt_trait_def_id, method_name, borrow) in\n-            &[(self.tcx.lang_items().fn_trait(), Ident::from_str(\"call\"), true),\n-              (self.tcx.lang_items().fn_mut_trait(), Ident::from_str(\"call_mut\"), true),\n-              (self.tcx.lang_items().fn_once_trait(), Ident::from_str(\"call_once\"), false)] {\n+        for &(opt_trait_def_id, method_name, borrow) in &[\n+            (\n+                self.tcx.lang_items().fn_trait(),\n+                Ident::from_str(\"call\"),\n+                true,\n+            ),\n+            (\n+                self.tcx.lang_items().fn_mut_trait(),\n+                Ident::from_str(\"call_mut\"),\n+                true,\n+            ),\n+            (\n+                self.tcx.lang_items().fn_once_trait(),\n+                Ident::from_str(\"call_once\"),\n+                false,\n+            ),\n+        ] {\n             let trait_def_id = match opt_trait_def_id {\n                 Some(def_id) => def_id,\n                 None => continue,\n             };\n \n-            if let Some(ok) = self.lookup_method_in_trait(call_expr.span,\n-                                                          method_name,\n-                                                          trait_def_id,\n-                                                          adjusted_ty,\n-                                                          None) {\n+            let opt_input_types = opt_arg_exprs.map(|arg_exprs| [self.tcx.mk_tup(\n+                arg_exprs\n+                .iter()\n+                .map(|e| self.next_ty_var(\n+                    TypeVariableOrigin::TypeInference(e.span)\n+                ))\n+            )]);\n+            let opt_input_types = opt_input_types.as_ref().map(AsRef::as_ref);\n+\n+            if let Some(ok) = self.lookup_method_in_trait(\n+                call_expr.span,\n+                method_name,\n+                trait_def_id,\n+                adjusted_ty,\n+                opt_input_types,\n+            ) {\n                 let method = self.register_infer_ok_obligations(ok);\n                 let mut autoref = None;\n                 if borrow {\n@@ -173,11 +217,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 // deployment, conservatively omit\n                                 // overloaded function call ops.\n                                 allow_two_phase_borrow: AllowTwoPhase::No,\n-                            }\n+                            },\n                         };\n                         autoref = Some(Adjustment {\n                             kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                            target: method.sig.inputs()[0]\n+                            target: method.sig.inputs()[0],\n                         });\n                     }\n                 }\n@@ -188,16 +232,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    fn confirm_builtin_call(&self,\n-                            call_expr: &hir::Expr,\n-                            callee_ty: Ty<'tcx>,\n-                            arg_exprs: &'gcx [hir::Expr],\n-                            expected: Expectation<'tcx>)\n-                            -> Ty<'tcx> {\n+    fn confirm_builtin_call(\n+        &self,\n+        call_expr: &hir::Expr,\n+        callee_ty: Ty<'tcx>,\n+        arg_exprs: &'gcx [hir::Expr],\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n         let (fn_sig, def_span) = match callee_ty.sty {\n-            ty::FnDef(def_id, _) => {\n-                (callee_ty.fn_sig(self.tcx), self.tcx.hir().span_if_local(def_id))\n-            }\n+            ty::FnDef(def_id, _) => (\n+                callee_ty.fn_sig(self.tcx),\n+                self.tcx.hir().span_if_local(def_id),\n+            ),\n             ty::FnPtr(sig) => (sig, None),\n             ref t => {\n                 let mut unit_variant = None;\n@@ -219,84 +265,96 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         match unit_variant {\n                             Some(ref path) => format!(\"enum variant `{}`\", path),\n                             None => format!(\"`{}`\", callee_ty),\n-                        });\n+                        }\n+                    );\n \n                     if let Some(ref path) = unit_variant {\n                         err.span_suggestion_with_applicability(\n                             call_expr.span,\n-                            &format!(\"`{}` is a unit variant, you need to write it \\\n-                                      without the parenthesis\", path),\n+                            &format!(\n+                                \"`{}` is a unit variant, you need to write it \\\n+                                 without the parenthesis\",\n+                                path\n+                            ),\n                             path.to_string(),\n-                            Applicability::MachineApplicable\n+                            Applicability::MachineApplicable,\n                         );\n                     }\n \n                     let mut inner_callee_path = None;\n                     let def = match callee.node {\n                         hir::ExprKind::Path(ref qpath) => {\n                             self.tables.borrow().qpath_def(qpath, callee.hir_id)\n-                        },\n+                        }\n                         hir::ExprKind::Call(ref inner_callee, _) => {\n                             // If the call spans more than one line and the callee kind is\n                             // itself another `ExprCall`, that's a clue that we might just be\n                             // missing a semicolon (Issue #51055)\n-                            let call_is_multiline = self.tcx.sess.source_map()\n-                                .is_multiline(call_expr.span);\n+                            let call_is_multiline =\n+                                self.tcx.sess.source_map().is_multiline(call_expr.span);\n                             if call_is_multiline {\n                                 let span = self.tcx.sess.source_map().next_point(callee.span);\n                                 err.span_suggestion_with_applicability(\n                                     span,\n                                     \"try adding a semicolon\",\n                                     \";\".to_owned(),\n-                                    Applicability::MaybeIncorrect\n+                                    Applicability::MaybeIncorrect,\n                                 );\n                             }\n                             if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.node {\n                                 inner_callee_path = Some(inner_qpath);\n-                                self.tables.borrow().qpath_def(inner_qpath, inner_callee.hir_id)\n+                                self.tables\n+                                    .borrow()\n+                                    .qpath_def(inner_qpath, inner_callee.hir_id)\n                             } else {\n                                 Def::Err\n                             }\n-                        },\n-                        _ => {\n-                            Def::Err\n                         }\n+                        _ => Def::Err,\n                     };\n \n                     err.span_label(call_expr.span, \"call expression requires function\");\n \n                     let def_span = match def {\n                         Def::Err => None,\n-                        Def::Local(id) | Def::Upvar(id, ..) => {\n-                            Some(self.tcx.hir().span(id))\n-                        }\n-                        _ => def.opt_def_id().and_then(|did| self.tcx.hir().span_if_local(did)),\n+                        Def::Local(id) | Def::Upvar(id, ..) => Some(self.tcx.hir().span(id)),\n+                        _ => def\n+                            .opt_def_id()\n+                            .and_then(|did| self.tcx.hir().span_if_local(did)),\n                     };\n                     if let Some(span) = def_span {\n                         let label = match (unit_variant, inner_callee_path) {\n                             (Some(path), _) => format!(\"`{}` defined here\", path),\n                             (_, Some(hir::QPath::Resolved(_, path))) => format!(\n-                                \"`{}` defined here returns `{}`\", path, callee_ty.to_string()\n+                                \"`{}` defined here returns `{}`\",\n+                                path,\n+                                callee_ty.to_string()\n                             ),\n                             _ => format!(\"`{}` defined here\", callee_ty.to_string()),\n                         };\n                         err.span_label(span, label);\n                     }\n                     err.emit();\n                 } else {\n-                    bug!(\"call_expr.node should be an ExprKind::Call, got {:?}\", call_expr.node);\n+                    bug!(\n+                        \"call_expr.node should be an ExprKind::Call, got {:?}\",\n+                        call_expr.node\n+                    );\n                 }\n \n                 // This is the \"default\" function signature, used in case of error.\n                 // In that case, we check each argument against \"error\" in order to\n                 // set up all the node type bindings.\n-                (ty::Binder::bind(self.tcx.mk_fn_sig(\n-                    self.err_args(arg_exprs.len()).into_iter(),\n-                    self.tcx.types.err,\n-                    false,\n-                    hir::Unsafety::Normal,\n-                    abi::Abi::Rust\n-                )), None)\n+                (\n+                    ty::Binder::bind(self.tcx.mk_fn_sig(\n+                        self.err_args(arg_exprs.len()).into_iter(),\n+                        self.tcx.types.err,\n+                        false,\n+                        hir::Unsafety::Normal,\n+                        abi::Abi::Rust,\n+                    )),\n+                    None,\n+                )\n             }\n         };\n \n@@ -305,69 +363,80 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // renormalize the associated types at this point, since they\n         // previously appeared within a `Binder<>` and hence would not\n         // have been normalized before.\n-        let fn_sig =\n-            self.replace_bound_vars_with_fresh_vars(call_expr.span, infer::FnCall, &fn_sig)\n-                .0;\n+        let fn_sig = self\n+            .replace_bound_vars_with_fresh_vars(call_expr.span, infer::FnCall, &fn_sig)\n+            .0;\n         let fn_sig = self.normalize_associated_types_in(call_expr.span, &fn_sig);\n \n         // Call the generic checker.\n-        let expected_arg_tys =\n-            self.expected_inputs_for_expected_output(call_expr.span,\n-                                            expected,\n-                                            fn_sig.output(),\n-                                            fn_sig.inputs());\n-        self.check_argument_types(call_expr.span,\n-                                  call_expr.span,\n-                                  fn_sig.inputs(),\n-                                  &expected_arg_tys[..],\n-                                  arg_exprs,\n-                                  fn_sig.variadic,\n-                                  TupleArgumentsFlag::DontTupleArguments,\n-                                  def_span);\n+        let expected_arg_tys = self.expected_inputs_for_expected_output(\n+            call_expr.span,\n+            expected,\n+            fn_sig.output(),\n+            fn_sig.inputs(),\n+        );\n+        self.check_argument_types(\n+            call_expr.span,\n+            call_expr.span,\n+            fn_sig.inputs(),\n+            &expected_arg_tys[..],\n+            arg_exprs,\n+            fn_sig.variadic,\n+            TupleArgumentsFlag::DontTupleArguments,\n+            def_span,\n+        );\n \n         fn_sig.output()\n     }\n \n-    fn confirm_deferred_closure_call(&self,\n-                                     call_expr: &hir::Expr,\n-                                     arg_exprs: &'gcx [hir::Expr],\n-                                     expected: Expectation<'tcx>,\n-                                     fn_sig: ty::FnSig<'tcx>)\n-                                     -> Ty<'tcx> {\n+    fn confirm_deferred_closure_call(\n+        &self,\n+        call_expr: &hir::Expr,\n+        arg_exprs: &'gcx [hir::Expr],\n+        expected: Expectation<'tcx>,\n+        fn_sig: ty::FnSig<'tcx>,\n+    ) -> Ty<'tcx> {\n         // `fn_sig` is the *signature* of the cosure being called. We\n         // don't know the full details yet (`Fn` vs `FnMut` etc), but we\n         // do know the types expected for each argument and the return\n         // type.\n \n-        let expected_arg_tys = self.expected_inputs_for_expected_output(call_expr.span,\n-                                                               expected,\n-                                                               fn_sig.output().clone(),\n-                                                               fn_sig.inputs());\n-\n-        self.check_argument_types(call_expr.span,\n-                                  call_expr.span,\n-                                  fn_sig.inputs(),\n-                                  &expected_arg_tys,\n-                                  arg_exprs,\n-                                  fn_sig.variadic,\n-                                  TupleArgumentsFlag::TupleArguments,\n-                                  None);\n+        let expected_arg_tys = self.expected_inputs_for_expected_output(\n+            call_expr.span,\n+            expected,\n+            fn_sig.output().clone(),\n+            fn_sig.inputs(),\n+        );\n+\n+        self.check_argument_types(\n+            call_expr.span,\n+            call_expr.span,\n+            fn_sig.inputs(),\n+            &expected_arg_tys,\n+            arg_exprs,\n+            fn_sig.variadic,\n+            TupleArgumentsFlag::TupleArguments,\n+            None,\n+        );\n \n         fn_sig.output()\n     }\n \n-    fn confirm_overloaded_call(&self,\n-                               call_expr: &hir::Expr,\n-                               arg_exprs: &'gcx [hir::Expr],\n-                               expected: Expectation<'tcx>,\n-                               method_callee: MethodCallee<'tcx>)\n-                               -> Ty<'tcx> {\n-        let output_type = self.check_method_argument_types(call_expr.span,\n-                                                           call_expr.span,\n-                                                           Ok(method_callee),\n-                                                           arg_exprs,\n-                                                           TupleArgumentsFlag::TupleArguments,\n-                                                           expected);\n+    fn confirm_overloaded_call(\n+        &self,\n+        call_expr: &hir::Expr,\n+        arg_exprs: &'gcx [hir::Expr],\n+        expected: Expectation<'tcx>,\n+        method_callee: MethodCallee<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let output_type = self.check_method_argument_types(\n+            call_expr.span,\n+            call_expr.span,\n+            Ok(method_callee),\n+            arg_exprs,\n+            TupleArgumentsFlag::TupleArguments,\n+            expected,\n+        );\n \n         self.write_method_call(call_expr.hir_id, method_callee);\n         output_type\n@@ -391,11 +460,12 @@ impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n \n         // we should not be invoked until the closure kind has been\n         // determined by upvar inference\n-        assert!(fcx.closure_kind(self.closure_def_id, self.closure_substs).is_some());\n+        assert!(fcx\n+            .closure_kind(self.closure_def_id, self.closure_substs)\n+            .is_some());\n \n         // We may now know enough to figure out fn vs fnmut etc.\n-        match fcx.try_overloaded_call_traits(self.call_expr,\n-                                             self.adjusted_ty) {\n+        match fcx.try_overloaded_call_traits(self.call_expr, self.adjusted_ty, None) {\n             Some((autoref, method_callee)) => {\n                 // One problem is that when we get here, we are going\n                 // to have a newly instantiated function signature\n@@ -410,22 +480,28 @@ impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n                 debug!(\"attempt_resolution: method_callee={:?}\", method_callee);\n \n                 for (method_arg_ty, self_arg_ty) in\n-                    method_sig.inputs().iter().skip(1).zip(self.fn_sig.inputs()) {\n+                    method_sig.inputs().iter().skip(1).zip(self.fn_sig.inputs())\n+                {\n                     fcx.demand_eqtype(self.call_expr.span, &self_arg_ty, &method_arg_ty);\n                 }\n \n-                fcx.demand_eqtype(self.call_expr.span, method_sig.output(), self.fn_sig.output());\n+                fcx.demand_eqtype(\n+                    self.call_expr.span,\n+                    method_sig.output(),\n+                    self.fn_sig.output(),\n+                );\n \n                 let mut adjustments = self.adjustments;\n                 adjustments.extend(autoref);\n                 fcx.apply_adjustments(self.callee_expr, adjustments);\n \n-                fcx.write_method_call(self.call_expr.hir_id,\n-                                      method_callee);\n+                fcx.write_method_call(self.call_expr.hir_id, method_callee);\n             }\n             None => {\n-                span_bug!(self.call_expr.span,\n-                          \"failed to find an overloaded call trait for closure call\");\n+                span_bug!(\n+                    self.call_expr.span,\n+                    \"failed to find an overloaded call trait for closure call\"\n+                );\n             }\n         }\n     }"}, {"sha": "56378b59e3642cd986b4c56e25a2b052acea7b52", "filename": "src/test/run-pass/issue-18952.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4/src%2Ftest%2Frun-pass%2Fissue-18952.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4/src%2Ftest%2Frun-pass%2Fissue-18952.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18952.rs?ref=a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4", "patch": "@@ -0,0 +1,56 @@\n+// This issue tests fn_traits overloading on arity.\n+// run-pass\n+\n+#![feature(fn_traits)]\n+#![feature(unboxed_closures)]\n+\n+struct Foo;\n+\n+impl Fn<(isize, isize)> for Foo {\n+    extern \"rust-call\" fn call(&self, args: (isize, isize)) -> Self::Output {\n+        println!(\"{:?}\", args);\n+        (args.0 + 1, args.1 + 1)\n+    }\n+}\n+\n+impl FnMut<(isize, isize)> for Foo {\n+    extern \"rust-call\" fn call_mut(&mut self, args: (isize, isize)) -> Self::Output {\n+        println!(\"{:?}\", args);\n+        (args.0 + 1, args.1 + 1)\n+    }\n+}\n+\n+impl FnOnce<(isize, isize)> for Foo {\n+    type Output = (isize, isize);\n+    extern \"rust-call\" fn call_once(self, args: (isize, isize)) -> Self::Output {\n+        println!(\"{:?}\", args);\n+        (args.0 + 1, args.1 + 1)\n+    }\n+}\n+\n+impl Fn<(isize, isize, isize)> for Foo {\n+    extern \"rust-call\" fn call(&self, args: (isize, isize, isize)) -> Self::Output {\n+        println!(\"{:?}\", args);\n+        (args.0 + 3, args.1 + 3, args.2 + 3)\n+    }\n+}\n+\n+impl FnMut<(isize, isize, isize)> for Foo {\n+    extern \"rust-call\" fn call_mut(&mut self, args: (isize, isize, isize)) -> Self::Output {\n+        println!(\"{:?}\", args);\n+        (args.0 + 3, args.1 + 3, args.2 + 3)\n+    }\n+}\n+impl FnOnce<(isize, isize, isize)> for Foo {\n+    type Output = (isize, isize, isize);\n+    extern \"rust-call\" fn call_once(self, args: (isize, isize, isize)) -> Self::Output {\n+        println!(\"{:?}\", args);\n+        (args.0 + 3, args.1 + 3, args.2 + 3)\n+    }\n+}\n+\n+fn main() {\n+    let foo = Foo;\n+    assert_eq!(foo(1, 1), (2, 2));\n+    assert_eq!(foo(1, 1, 1), (4, 4, 4));\n+}"}, {"sha": "9e104ce6c4f30b8c1a438a9c1e7d055c393b932f", "filename": "src/test/run-pass/issue-45510.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4/src%2Ftest%2Frun-pass%2Fissue-45510.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4/src%2Ftest%2Frun-pass%2Fissue-45510.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-45510.rs?ref=a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4", "patch": "@@ -0,0 +1,32 @@\n+// Test overloaded resolution of fn_traits.\n+// run-pass\n+\n+#![feature(fn_traits)]\n+#![feature(unboxed_closures)]\n+\n+#[derive(Debug, PartialEq, Eq)]\n+struct Ishmael;\n+#[derive(Debug, PartialEq, Eq)]\n+struct Maybe;\n+struct CallMe;\n+\n+impl FnOnce<(Ishmael,)> for CallMe {\n+    type Output = Ishmael;\n+    extern \"rust-call\" fn call_once(self, _args: (Ishmael,)) -> Ishmael {\n+        println!(\"Split your lungs with blood and thunder!\");\n+        Ishmael\n+    }\n+}\n+\n+impl FnOnce<(Maybe,)> for CallMe {\n+    type Output = Maybe;\n+    extern \"rust-call\" fn call_once(self, _args: (Maybe,)) -> Maybe {\n+        println!(\"So we just met, and this is crazy\");\n+        Maybe\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(CallMe(Ishmael), Ishmael);\n+    assert_eq!(CallMe(Maybe), Maybe);\n+}"}]}