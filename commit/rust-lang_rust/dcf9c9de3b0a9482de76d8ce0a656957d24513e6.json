{"sha": "dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "node_id": "C_kwDOAAsO6NoAKGRjZjljOWRlM2IwYTk0ODJkZTc2ZDhjZTBhNjU2OTU3ZDI0NTEzZTY", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-02-02T21:59:39Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-02-02T21:59:39Z"}, "message": "Merge from rustc", "tree": {"sha": "d1ecf0686716e383eb107312a84086de7c172ee2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1ecf0686716e383eb107312a84086de7c172ee2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "html_url": "https://github.com/rust-lang/rust/commit/dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff6fb4c33e8bd94b17a4715046b8266a1d42e793", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff6fb4c33e8bd94b17a4715046b8266a1d42e793", "html_url": "https://github.com/rust-lang/rust/commit/ff6fb4c33e8bd94b17a4715046b8266a1d42e793"}, {"sha": "cc8758480ccc841232e3eba13423fa2f7ed47253", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc8758480ccc841232e3eba13423fa2f7ed47253", "html_url": "https://github.com/rust-lang/rust/commit/cc8758480ccc841232e3eba13423fa2f7ed47253"}], "stats": {"total": 2669, "additions": 1698, "deletions": 971}, "files": [{"sha": "ac3a51df401350cd3c8c503c8b8e75cb318c56b2", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -325,7 +325,7 @@ jobs:\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: macos-12-xl\n+            os: macos-latest\n           - name: dist-apple-various\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --host='' --target=aarch64-apple-ios,x86_64-apple-ios,aarch64-apple-ios-sim\"\n@@ -336,7 +336,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-12-xl\n+            os: macos-latest\n           - name: dist-x86_64-apple-alt\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths\"\n@@ -347,7 +347,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-12-xl\n+            os: macos-latest\n           - name: x86_64-apple-1\n             env:\n               SCRIPT: \"./x.py --stage 2 test --exclude tests/ui --exclude tests/rustdoc --exclude tests/run-make-fulldeps\"\n@@ -358,7 +358,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-12-xl\n+            os: macos-latest\n           - name: x86_64-apple-2\n             env:\n               SCRIPT: \"./x.py --stage 2 test tests/ui tests/rustdoc tests/run-make-fulldeps\"\n@@ -369,7 +369,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-12-xl\n+            os: macos-latest\n           - name: dist-aarch64-apple\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --stage 2\"\n@@ -384,7 +384,7 @@ jobs:\n               NO_OVERFLOW_CHECKS: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n               JEMALLOC_SYS_WITH_LG_PAGE: 14\n-            os: macos-12-xl\n+            os: macos-latest\n           - name: x86_64-msvc-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\""}, {"sha": "bad47db0de1d4e16103d6724d786eb479d480ab7", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -29,16 +29,30 @@ pub fn expand_deriving_partial_eq(\n                         cx.span_bug(field.span, \"not exactly 2 arguments in `derive(PartialEq)`\");\n                     };\n \n-                    // We received `&T` arguments. Convert them to `T` by\n-                    // stripping `&` or adding `*`. This isn't necessary for\n-                    // type checking, but it results in much better error\n-                    // messages if something goes wrong.\n+                    // We received arguments of type `&T`. Convert them to type `T` by stripping\n+                    // any leading `&` or adding `*`. This isn't necessary for type checking, but\n+                    // it results in better error messages if something goes wrong.\n+                    //\n+                    // Note: for arguments that look like `&{ x }`, which occur with packed\n+                    // structs, this would cause expressions like `{ self.x } == { other.x }`,\n+                    // which isn't valid Rust syntax. This wouldn't break compilation because these\n+                    // AST nodes are constructed within the compiler. But it would mean that code\n+                    // printed by `-Zunpretty=expanded` (or `cargo expand`) would have invalid\n+                    // syntax, which would be suboptimal. So we wrap these in parens, giving\n+                    // `({ self.x }) == ({ other.x })`, which is valid syntax.\n                     let convert = |expr: &P<Expr>| {\n                         if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) =\n                             &expr.kind\n                         {\n-                            inner.clone()\n+                            if let ExprKind::Block(..) = &inner.kind {\n+                                // `&{ x }` form: remove the `&`, add parens.\n+                                cx.expr_paren(field.span, inner.clone())\n+                            } else {\n+                                // `&x` form: remove the `&`.\n+                                inner.clone()\n+                            }\n                         } else {\n+                            // No leading `&`: add a leading `*`.\n                             cx.expr_deref(field.span, expr.clone())\n                         }\n                     };"}, {"sha": "9831e98fe371c33466e86f939fa8d36492872f27", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 3, "deletions": 47, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -85,55 +85,11 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n         } else if attr.has_name(sym::rustc_allocator) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n         } else if attr.has_name(sym::ffi_returns_twice) {\n-            if tcx.is_foreign_item(did) {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n-            } else {\n-                // `#[ffi_returns_twice]` is only allowed `extern fn`s.\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0724,\n-                    \"`#[ffi_returns_twice]` may only be used on foreign functions\"\n-                )\n-                .emit();\n-            }\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n         } else if attr.has_name(sym::ffi_pure) {\n-            if tcx.is_foreign_item(did) {\n-                if attrs.iter().any(|a| a.has_name(sym::ffi_const)) {\n-                    // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        attr.span,\n-                        E0757,\n-                        \"`#[ffi_const]` function cannot be `#[ffi_pure]`\"\n-                    )\n-                    .emit();\n-                } else {\n-                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_PURE;\n-                }\n-            } else {\n-                // `#[ffi_pure]` is only allowed on foreign functions\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0755,\n-                    \"`#[ffi_pure]` may only be used on foreign functions\"\n-                )\n-                .emit();\n-            }\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_PURE;\n         } else if attr.has_name(sym::ffi_const) {\n-            if tcx.is_foreign_item(did) {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n-            } else {\n-                // `#[ffi_const]` is only allowed on foreign functions\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0756,\n-                    \"`#[ffi_const]` may only be used on foreign functions\"\n-                )\n-                .emit();\n-            }\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n         } else if attr.has_name(sym::rustc_nounwind) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n         } else if attr.has_name(sym::rustc_reallocator) {"}, {"sha": "0f13d29d0fcb6a4d5f5bfdb1dadf0a7bf71b80a3", "filename": "compiler/rustc_error_messages/locales/en-US/hir_typeck.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -57,3 +57,7 @@ hir_typeck_lang_start_incorrect_param = parameter {$param_num} of the `start` la\n \n hir_typeck_lang_start_incorrect_ret_ty = the return type of the `start` lang item is incorrect\n     .suggestion = change the type from `{$found_ty}` to `{$expected_ty}`\n+\n+hir_typeck_help_set_edition_cargo = set `edition = \"{$edition}\"` in `Cargo.toml`\n+hir_typeck_help_set_edition_standalone = pass `--edition {$edition}` to `rustc`\n+hir_typeck_note_edition_guide = for more on editions, read https://doc.rust-lang.org/edition-guide"}, {"sha": "21cf4bd789c7e8ecf3bc4548b77314359a85c6a5", "filename": "compiler/rustc_error_messages/locales/en-US/parse.ftl", "status": "modified", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -390,3 +390,191 @@ parse_where_clause_before_tuple_struct_body = where clauses are not allowed befo\n     .name_label = while parsing this tuple struct\n     .body_label = the struct body\n     .suggestion = move the body before the where clause\n+\n+parse_async_fn_in_2015 = `async fn` is not permitted in Rust 2015\n+    .label = to use `async fn`, switch to Rust 2018 or later\n+\n+parse_async_block_in_2015 = `async` blocks are only allowed in Rust 2018 or later\n+\n+parse_self_argument_pointer = cannot pass `self` by raw pointer\n+    .label = cannot pass `self` by raw pointer\n+\n+parse_visibility_not_followed_by_item = visibility `{$vis}` is not followed by an item\n+    .label = the visibility\n+    .help = you likely meant to define an item, e.g., `{$vis} fn foo() {\"{}\"}`\n+\n+parse_default_not_followed_by_item = `default` is not followed by an item\n+    .label = the `default` qualifier\n+    .note = only `fn`, `const`, `type`, or `impl` items may be prefixed by `default`\n+\n+parse_missing_struct_for_struct_definition = missing `struct` for struct definition\n+    .suggestion = add `struct` here to parse `{$ident}` as a public struct\n+\n+parse_missing_fn_for_function_definition = missing `fn` for function definition\n+    .suggestion = add `fn` here to parse `{$ident}` as a public function\n+\n+parse_missing_fn_for_method_definition = missing `fn` for method definition\n+    .suggestion = add `fn` here to parse `{$ident}` as a public method\n+\n+parse_ambiguous_missing_keyword_for_item_definition = missing `fn` or `struct` for function or struct definition\n+    .suggestion = if you meant to call a macro, try\n+    .help = if you meant to call a macro, remove the `pub` and add a trailing `!` after the identifier\n+\n+parse_missing_trait_in_trait_impl = missing trait in a trait impl\n+    .suggestion_add_trait = add a trait here\n+    .suggestion_remove_for = for an inherent impl, drop this `for`\n+\n+parse_missing_for_in_trait_impl = missing `for` in a trait impl\n+    .suggestion = add `for` here\n+\n+parse_expected_trait_in_trait_impl_found_type = expected a trait, found type\n+\n+parse_non_item_in_item_list = non-item in item list\n+    .suggestion_use_const_not_let = consider using `const` instead of `let` for associated const\n+    .label_list_start = item list starts here\n+    .label_non_item = non-item starts here\n+    .label_list_end = item list ends here\n+    .suggestion_remove_semicolon = consider removing this semicolon\n+\n+parse_bounds_not_allowed_on_trait_aliases = bounds are not allowed on trait aliases\n+\n+parse_trait_alias_cannot_be_auto = trait aliases cannot be `auto`\n+parse_trait_alias_cannot_be_unsafe = trait aliases cannot be `unsafe`\n+\n+parse_associated_static_item_not_allowed = associated `static` items are not allowed\n+\n+parse_extern_crate_name_with_dashes = crate name using dashes are not valid in `extern crate` statements\n+    .label = dash-separated idents are not valid\n+    .suggestion = if the original crate name uses dashes you need to use underscores in the code\n+\n+parse_extern_item_cannot_be_const = extern items cannot be `const`\n+    .suggestion = try using a static value\n+    .note = for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+parse_const_global_cannot_be_mutable = const globals cannot be mutable\n+    .label = cannot be mutable\n+    .suggestion = you might want to declare a static instead\n+\n+parse_missing_const_type = missing type for `{$kind}` item\n+    .suggestion = provide a type for the item\n+\n+parse_enum_struct_mutually_exclusive = `enum` and `struct` are mutually exclusive\n+    .suggestion = replace `enum struct` with\n+\n+parse_unexpected_token_after_struct_name = expected `where`, `{\"{\"}`, `(`, or `;` after struct name\n+parse_unexpected_token_after_struct_name_found_reserved_identifier = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found reserved identifier `{$token}`\n+parse_unexpected_token_after_struct_name_found_keyword = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found keyword `{$token}`\n+parse_unexpected_token_after_struct_name_found_reserved_keyword = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found reserved keyword `{$token}`\n+parse_unexpected_token_after_struct_name_found_doc_comment = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found doc comment `{$token}`\n+parse_unexpected_token_after_struct_name_found_other = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found `{$token}`\n+\n+parse_unexpected_self_in_generic_parameters = unexpected keyword `Self` in generic parameters\n+    .note = you cannot use `Self` as a generic parameter because it is reserved for associated items\n+\n+parse_multiple_where_clauses = cannot define duplicate `where` clauses on an item\n+    .label = previous `where` clause starts here\n+    .suggestion = consider joining the two `where` clauses into one\n+\n+parse_nonterminal_expected_item_keyword = expected an item keyword\n+parse_nonterminal_expected_statement = expected a statement\n+parse_nonterminal_expected_ident = expected ident, found `{$token}`\n+parse_nonterminal_expected_lifetime = expected a lifetime, found `{$token}`\n+\n+parse_or_pattern_not_allowed_in_let_binding = top-level or-patterns are not allowed in `let` bindings\n+parse_or_pattern_not_allowed_in_fn_parameters = top-level or-patterns are not allowed in function parameters\n+parse_sugg_remove_leading_vert_in_pattern = remove the `|`\n+parse_sugg_wrap_pattern_in_parens = wrap the pattern in parentheses\n+\n+parse_note_pattern_alternatives_use_single_vert = alternatives in or-patterns are separated with `|`, not `||`\n+\n+parse_unexpected_vert_vert_before_function_parameter = unexpected `||` before function parameter\n+    .suggestion = remove the `||`\n+\n+parse_label_while_parsing_or_pattern_here = while parsing this or-pattern starting here\n+\n+parse_unexpected_vert_vert_in_pattern = unexpected token `||` in pattern\n+    .suggestion = use a single `|` to separate multiple alternative patterns\n+\n+parse_trailing_vert_not_allowed = a trailing `|` is not allowed in an or-pattern\n+    .suggestion = remove the `{$token}`\n+\n+parse_dotdotdot_rest_pattern = unexpected `...`\n+    .label = not a valid pattern\n+    .suggestion = for a rest pattern, use `..` instead of `...`\n+\n+parse_pattern_on_wrong_side_of_at = pattern on wrong side of `@`\n+    .label_pattern = pattern on the left, should be on the right\n+    .label_binding = binding on the right, should be on the left\n+    .suggestion = switch the order\n+\n+parse_expected_binding_left_of_at = left-hand side of `@` must be a binding\n+    .label_lhs = interpreted as a pattern, not a binding\n+    .label_rhs = also a pattern\n+    .note = bindings are `x`, `mut x`, `ref x`, and `ref mut x`\n+\n+parse_ambiguous_range_pattern = the range pattern here has ambiguous interpretation\n+    .suggestion = add parentheses to clarify the precedence\n+\n+parse_unexpected_lifetime_in_pattern = unexpected lifetime `{$symbol}` in pattern\n+    .suggestion = remove the lifetime\n+\n+parse_ref_mut_order_incorrect = the order of `mut` and `ref` is incorrect\n+    .suggestion = try switching the order\n+\n+parse_mut_on_nested_ident_pattern = `mut` must be attached to each individual binding\n+    .suggestion = add `mut` to each binding\n+parse_mut_on_non_ident_pattern = `mut` must be followed by a named binding\n+    .suggestion = remove the `mut` prefix\n+parse_note_mut_pattern_usage = `mut` may be followed by `variable` and `variable @ pattern`\n+\n+parse_repeated_mut_in_pattern = `mut` on a binding may not be repeated\n+    .suggestion = remove the additional `mut`s\n+\n+parse_dot_dot_dot_range_to_pattern_not_allowed = range-to patterns with `...` are not allowed\n+    .suggestion = use `..=` instead\n+\n+parse_enum_pattern_instead_of_identifier = expected identifier, found enum pattern\n+\n+parse_dot_dot_dot_for_remaining_fields = expected field pattern, found `...`\n+    .suggestion = to omit remaining fields, use one fewer `.`\n+\n+parse_expected_comma_after_pattern_field = expected `,`\n+\n+parse_return_types_use_thin_arrow = return types are denoted using `->`\n+    .suggestion = use `->` instead\n+\n+parse_need_plus_after_trait_object_lifetime = lifetime in trait object type must be followed by `+`\n+\n+parse_expected_mut_or_const_in_raw_pointer_type = expected `mut` or `const` keyword in raw pointer type\n+    .suggestion = add `mut` or `const` here\n+\n+parse_lifetime_after_mut = lifetime must precede `mut`\n+    .suggestion = place the lifetime before `mut`\n+\n+parse_dyn_after_mut = `mut` must precede `dyn`\n+    .suggestion = place `mut` before `dyn`\n+\n+parse_fn_pointer_cannot_be_const = an `fn` pointer type cannot be `const`\n+    .label = `const` because of this\n+    .suggestion = remove the `const` qualifier\n+\n+parse_fn_pointer_cannot_be_async = an `fn` pointer type cannot be `async`\n+    .label = `async` because of this\n+    .suggestion = remove the `async` qualifier\n+\n+parse_nested_c_variadic_type = C-variadic type `...` may not be nested inside another type\n+\n+parse_invalid_dyn_keyword = invalid `dyn` keyword\n+    .help = `dyn` is only needed at the start of a trait `+`-separated list\n+    .suggestion = remove this keyword\n+\n+parse_negative_bounds_not_supported = negative bounds are not supported\n+    .label = negative bounds are not supported\n+    .suggestion = {$num_bounds ->\n+            [one] remove the bound\n+           *[other] remove the bounds\n+        }\n+\n+parse_help_set_edition_cargo = set `edition = \"{$edition}\"` in `Cargo.toml`\n+parse_help_set_edition_standalone = pass `--edition {$edition}` to `rustc`\n+parse_note_edition_guide = for more on editions, read https://doc.rust-lang.org/edition-guide"}, {"sha": "0c7e02912d4ef5af76dd39e631a5c3d32de306aa", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -182,6 +182,18 @@ passes_has_incoherent_inherent_impl =\n     `rustc_has_incoherent_inherent_impls` attribute should be applied to types or traits.\n     .label = only adts, extern types and traits are supported\n \n+passes_both_ffi_const_and_pure =\n+    `#[ffi_const]` function cannot be `#[ffi_pure]`\n+\n+passes_ffi_pure_invalid_target =\n+    `#[ffi_pure]` may only be used on foreign functions\n+\n+passes_ffi_const_invalid_target =\n+    `#[ffi_const]` may only be used on foreign functions\n+\n+passes_ffi_returns_twice_invalid_target =\n+    `#[ffi_returns_twice]` may only be used on foreign functions\n+\n passes_must_use_async =\n     `must_use` attribute on `async` functions applies to the anonymous `Future` returned by the function, not the value within\n     .label = this attribute does nothing, the `Future`s returned by async functions are already `must_use`"}, {"sha": "9ed8ab67431c05b9a51a9bb4fa1f6310b0e2050d", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -7,7 +7,6 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_error_messages::fluent_value_from_str_list_sep_by_and;\n use rustc_error_messages::FluentValue;\n use rustc_lint_defs::{Applicability, LintExpectationId};\n-use rustc_span::edition::LATEST_STABLE_EDITION;\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use std::borrow::Cow;\n@@ -555,18 +554,6 @@ impl Diagnostic {\n         self\n     }\n \n-    /// Help the user upgrade to the latest edition.\n-    /// This is factored out to make sure it does the right thing with `Cargo.toml`.\n-    pub fn help_use_latest_edition(&mut self) -> &mut Self {\n-        if std::env::var_os(\"CARGO\").is_some() {\n-            self.help(&format!(\"set `edition = \\\"{}\\\"` in `Cargo.toml`\", LATEST_STABLE_EDITION));\n-        } else {\n-            self.help(&format!(\"pass `--edition {}` to `rustc`\", LATEST_STABLE_EDITION));\n-        }\n-        self.note(\"for more on editions, read https://doc.rust-lang.org/edition-guide\");\n-        self\n-    }\n-\n     /// Disallow attaching suggestions this diagnostic.\n     /// Any suggestions attached e.g. with the `span_suggestion_*` methods\n     /// (before and after the call to `disable_suggestions`) will be ignored."}, {"sha": "3064d2bedbe125ffac7985e43a20f2b2ad29741c", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -669,7 +669,6 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         sp: impl Into<MultiSpan>,\n         msg: impl Into<SubdiagnosticMessage>,\n     ) -> &mut Self);\n-    forward!(pub fn help_use_latest_edition(&mut self,) -> &mut Self);\n     forward!(pub fn set_is_lint(&mut self,) -> &mut Self);\n \n     forward!(pub fn disable_suggestions(&mut self,) -> &mut Self);"}, {"sha": "5ada85d04b0bcb60556600353b5e492f118588a2", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -189,6 +189,14 @@ impl IntoDiagnosticArg for rustc_data_structures::small_c_str::SmallCStr {\n     }\n }\n \n+impl IntoDiagnosticArg for ast::Visibility {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        let s = pprust::vis_to_string(&self);\n+        let s = s.trim_end().to_string();\n+        DiagnosticArgValue::Str(Cow::Owned(s))\n+    }\n+}\n+\n impl IntoDiagnosticArg for Level {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(Cow::Borrowed(self.to_cmd_flag()))"}, {"sha": "6cd56852f9d686942633ce3b258358c310d56469", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -272,6 +272,10 @@ impl<'a> ExtCtxt<'a> {\n         self.expr(sp, ast::ExprKind::AddrOf(ast::BorrowKind::Ref, ast::Mutability::Not, e))\n     }\n \n+    pub fn expr_paren(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n+        self.expr(sp, ast::ExprKind::Paren(e))\n+    }\n+\n     pub fn expr_call(\n         &self,\n         span: Span,"}, {"sha": "2c8979402b654b8fb5f7cdb57d07d6208d42f29f", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -2,7 +2,11 @@\n use rustc_errors::{AddToDiagnostic, Applicability, Diagnostic, MultiSpan, SubdiagnosticMessage};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_middle::ty::Ty;\n-use rustc_span::{symbol::Ident, Span};\n+use rustc_span::{\n+    edition::{Edition, LATEST_STABLE_EDITION},\n+    symbol::Ident,\n+    Span,\n+};\n \n #[derive(Diagnostic)]\n #[diag(hir_typeck_field_multiply_specified_in_initializer, code = \"E0062\")]\n@@ -205,3 +209,24 @@ pub struct LangStartIncorrectRetTy<'tcx> {\n     pub expected_ty: Ty<'tcx>,\n     pub found_ty: Ty<'tcx>,\n }\n+\n+#[derive(Subdiagnostic)]\n+pub enum HelpUseLatestEdition {\n+    #[help(hir_typeck_help_set_edition_cargo)]\n+    #[note(hir_typeck_note_edition_guide)]\n+    Cargo { edition: Edition },\n+    #[help(hir_typeck_help_set_edition_standalone)]\n+    #[note(hir_typeck_note_edition_guide)]\n+    Standalone { edition: Edition },\n+}\n+\n+impl HelpUseLatestEdition {\n+    pub fn new() -> Self {\n+        let edition = LATEST_STABLE_EDITION;\n+        if std::env::var_os(\"CARGO\").is_some() {\n+            Self::Cargo { edition }\n+        } else {\n+            Self::Standalone { edition }\n+        }\n+    }\n+}"}, {"sha": "3561992e86ab4ca41a518f241bc3c2ecd1a4a9e4", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -8,7 +8,7 @@ use crate::coercion::DynamicCoerceMany;\n use crate::errors::TypeMismatchFruTypo;\n use crate::errors::{AddressOfTemporaryTaken, ReturnStmtOutsideOfFnBody, StructExprNonExhaustive};\n use crate::errors::{\n-    FieldMultiplySpecifiedInInitializer, FunctionalRecordUpdateOnNonStruct,\n+    FieldMultiplySpecifiedInInitializer, FunctionalRecordUpdateOnNonStruct, HelpUseLatestEdition,\n     YieldExprOutsideOfGenerator,\n };\n use crate::fatally_break_rust;\n@@ -23,8 +23,8 @@ use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n-    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, DiagnosticId,\n-    ErrorGuaranteed, StashKey,\n+    pluralize, struct_span_err, AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder,\n+    DiagnosticId, ErrorGuaranteed, StashKey,\n };\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n@@ -2433,7 +2433,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // We know by construction that `<expr>.await` is either on Rust 2015\n             // or results in `ExprKind::Await`. Suggest switching the edition to 2018.\n             err.note(\"to `.await` a `Future`, switch to Rust 2018 or later\");\n-            err.help_use_latest_edition();\n+            HelpUseLatestEdition::new().add_to_diagnostic(&mut err);\n         }\n \n         err.emit();"}, {"sha": "b5c2d14e8d15b05a6e7dd54eaa894e6db8ac33e7", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 16, "deletions": 46, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -60,7 +60,7 @@ use crate::traits::{\n \n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed, IntoDiagnosticArg};\n-use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString, MultiSpan};\n+use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -1470,51 +1470,17 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 for (key, values) in types.iter() {\n                     let count = values.len();\n                     let kind = key.descr();\n-                    let mut returned_async_output_error = false;\n                     for &sp in values {\n-                        if sp.is_desugaring(DesugaringKind::Async) && !returned_async_output_error {\n-                            if [sp] != err.span.primary_spans() {\n-                                let mut span: MultiSpan = sp.into();\n-                                span.push_span_label(\n-                                    sp,\n-                                    format!(\n-                                        \"checked the `Output` of this `async fn`, {}{} {}{}\",\n-                                        if count > 1 { \"one of the \" } else { \"\" },\n-                                        target,\n-                                        kind,\n-                                        pluralize!(count),\n-                                    ),\n-                                );\n-                                err.span_note(\n-                                    span,\n-                                    \"while checking the return type of the `async fn`\",\n-                                );\n-                            } else {\n-                                err.span_label(\n-                                    sp,\n-                                    format!(\n-                                        \"checked the `Output` of this `async fn`, {}{} {}{}\",\n-                                        if count > 1 { \"one of the \" } else { \"\" },\n-                                        target,\n-                                        kind,\n-                                        pluralize!(count),\n-                                    ),\n-                                );\n-                                err.note(\"while checking the return type of the `async fn`\");\n-                            }\n-                            returned_async_output_error = true;\n-                        } else {\n-                            err.span_label(\n-                                sp,\n-                                format!(\n-                                    \"{}{} {}{}\",\n-                                    if count == 1 { \"the \" } else { \"one of the \" },\n-                                    target,\n-                                    kind,\n-                                    pluralize!(count),\n-                                ),\n-                            );\n-                        }\n+                        err.span_label(\n+                            sp,\n+                            format!(\n+                                \"{}{} {}{}\",\n+                                if count == 1 { \"the \" } else { \"one of the \" },\n+                                target,\n+                                kind,\n+                                pluralize!(count),\n+                            ),\n+                        );\n                     }\n                 }\n             }\n@@ -1537,7 +1503,11 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     //    |\n                     //    = note: expected unit type `()`\n                     //                 found closure `[closure@$DIR/issue-20862.rs:2:5: 2:14 x:_]`\n-                    if !self.ignore_span.overlaps(span) {\n+                    //\n+                    // Also ignore opaque `Future`s that come from async fns.\n+                    if !self.ignore_span.overlaps(span)\n+                        && !span.is_desugaring(DesugaringKind::Async)\n+                    {\n                         self.types.entry(kind).or_default().insert(span);\n                     }\n                 }"}, {"sha": "12bcd939bd61b78e74b974b75eece249ca5d8680", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -322,11 +322,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 let generated_code = self\n                     .generate_inner_field_code(\n                         attr,\n-                        FieldInfo {\n-                            binding: binding_info,\n-                            ty: inner_ty.inner_type().unwrap_or(&field.ty),\n-                            span: &field.span(),\n-                        },\n+                        FieldInfo { binding: binding_info, ty: inner_ty, span: &field.span() },\n                         binding,\n                     )\n                     .unwrap_or_else(|v| v.to_compile_error());\n@@ -418,9 +414,9 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n             }\n             SubdiagnosticKind::Note | SubdiagnosticKind::Help | SubdiagnosticKind::Warn => {\n-                if type_matches_path(info.ty, &[\"rustc_span\", \"Span\"]) {\n+                if type_matches_path(info.ty.inner_type(), &[\"rustc_span\", \"Span\"]) {\n                     Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n-                } else if type_is_unit(info.ty) {\n+                } else if type_is_unit(info.ty.inner_type()) {\n                     Ok(self.add_subdiagnostic(&fn_ident, slug))\n                 } else {\n                     report_type_error(attr, \"`Span` or `()`\")?\n@@ -432,6 +428,15 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 code_field,\n                 code_init,\n             } => {\n+                if let FieldInnerTy::Vec(_) = info.ty {\n+                    throw_invalid_attr!(attr, &meta, |diag| {\n+                        diag\n+                        .note(\"`#[suggestion(...)]` applied to `Vec` field is ambiguous\")\n+                        .help(\"to show a suggestion consisting of multiple parts, use a `Subdiagnostic` annotated with `#[multipart_suggestion(...)]`\")\n+                        .help(\"to show a variable set of suggestions, use a `Vec` of `Subdiagnostic`s annotated with `#[suggestion(...)]`\")\n+                    });\n+                }\n+\n                 let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n \n                 if let Some((static_applicability, span)) = static_applicability {\n@@ -489,7 +494,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         &self,\n         info: FieldInfo<'_>,\n     ) -> Result<(TokenStream, SpannedOption<TokenStream>), DiagnosticDeriveError> {\n-        match &info.ty {\n+        match &info.ty.inner_type() {\n             // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n             ty @ Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n                 let binding = &info.binding.binding;"}, {"sha": "906e4c0b0e16c293faa07d0e4558d482a1627579", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -247,11 +247,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     return quote! {};\n                 }\n \n-                let info = FieldInfo {\n-                    binding,\n-                    ty: inner_ty.inner_type().unwrap_or(&ast.ty),\n-                    span: &ast.span(),\n-                };\n+                let info = FieldInfo { binding, ty: inner_ty, span: &ast.span() };\n \n                 let generated = self\n                     .generate_field_code_inner(kind_stats, attr, info, inner_ty.will_iterate())\n@@ -312,6 +308,21 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     let binding = info.binding.binding.clone();\n                     // FIXME(#100717): support `Option<Span>` on `primary_span` like in the\n                     // diagnostic derive\n+                    if !matches!(info.ty, FieldInnerTy::Plain(_)) {\n+                        throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n+                            let diag = diag.note(\"there must be exactly one primary span\");\n+\n+                            if kind_stats.has_normal_suggestion {\n+                                diag.help(\n+                                    \"to create a suggestion with multiple spans, \\\n+                                     use `#[multipart_suggestion]` instead\",\n+                                )\n+                            } else {\n+                                diag\n+                            }\n+                        });\n+                    }\n+\n                     self.span_field.set_once(binding, span);\n                 }\n "}, {"sha": "27b8f676f3fbb8cec626e05a44e97b1ade90da4c", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -80,7 +80,7 @@ fn report_error_if_not_applied_to_ty(\n     path: &[&str],\n     ty_name: &str,\n ) -> Result<(), DiagnosticDeriveError> {\n-    if !type_matches_path(info.ty, path) {\n+    if !type_matches_path(info.ty.inner_type(), path) {\n         report_type_error(attr, ty_name)?;\n     }\n \n@@ -105,8 +105,8 @@ pub(crate) fn report_error_if_not_applied_to_span(\n     attr: &Attribute,\n     info: &FieldInfo<'_>,\n ) -> Result<(), DiagnosticDeriveError> {\n-    if !type_matches_path(info.ty, &[\"rustc_span\", \"Span\"])\n-        && !type_matches_path(info.ty, &[\"rustc_errors\", \"MultiSpan\"])\n+    if !type_matches_path(info.ty.inner_type(), &[\"rustc_span\", \"Span\"])\n+        && !type_matches_path(info.ty.inner_type(), &[\"rustc_errors\", \"MultiSpan\"])\n     {\n         report_type_error(attr, \"`Span` or `MultiSpan`\")?;\n     }\n@@ -115,60 +115,67 @@ pub(crate) fn report_error_if_not_applied_to_span(\n }\n \n /// Inner type of a field and type of wrapper.\n+#[derive(Copy, Clone)]\n pub(crate) enum FieldInnerTy<'ty> {\n     /// Field is wrapped in a `Option<$inner>`.\n     Option(&'ty Type),\n     /// Field is wrapped in a `Vec<$inner>`.\n     Vec(&'ty Type),\n     /// Field isn't wrapped in an outer type.\n-    None,\n+    Plain(&'ty Type),\n }\n \n impl<'ty> FieldInnerTy<'ty> {\n     /// Returns inner type for a field, if there is one.\n     ///\n-    /// - If `ty` is an `Option`, returns `FieldInnerTy::Option { inner: (inner type) }`.\n-    /// - If `ty` is a `Vec`, returns `FieldInnerTy::Vec { inner: (inner type) }`.\n-    /// - Otherwise returns `None`.\n+    /// - If `ty` is an `Option<Inner>`, returns `FieldInnerTy::Option(Inner)`.\n+    /// - If `ty` is a `Vec<Inner>`, returns `FieldInnerTy::Vec(Inner)`.\n+    /// - Otherwise returns `FieldInnerTy::Plain(ty)`.\n     pub(crate) fn from_type(ty: &'ty Type) -> Self {\n-        let variant: &dyn Fn(&'ty Type) -> FieldInnerTy<'ty> =\n-            if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n-                &FieldInnerTy::Option\n-            } else if type_matches_path(ty, &[\"std\", \"vec\", \"Vec\"]) {\n-                &FieldInnerTy::Vec\n-            } else {\n-                return FieldInnerTy::None;\n+        fn single_generic_type(ty: &Type) -> &Type {\n+            let Type::Path(ty_path) = ty else {\n+                panic!(\"expected path type\");\n             };\n \n-        if let Type::Path(ty_path) = ty {\n             let path = &ty_path.path;\n             let ty = path.segments.iter().last().unwrap();\n-            if let syn::PathArguments::AngleBracketed(bracketed) = &ty.arguments {\n-                if bracketed.args.len() == 1 {\n-                    if let syn::GenericArgument::Type(ty) = &bracketed.args[0] {\n-                        return variant(ty);\n-                    }\n-                }\n-            }\n+            let syn::PathArguments::AngleBracketed(bracketed) = &ty.arguments else {\n+                panic!(\"expected bracketed generic arguments\");\n+            };\n+\n+            assert_eq!(bracketed.args.len(), 1);\n+\n+            let syn::GenericArgument::Type(ty) = &bracketed.args[0] else {\n+                panic!(\"expected generic parameter to be a type generic\");\n+            };\n+\n+            ty\n         }\n \n-        unreachable!();\n+        if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n+            FieldInnerTy::Option(single_generic_type(ty))\n+        } else if type_matches_path(ty, &[\"std\", \"vec\", \"Vec\"]) {\n+            FieldInnerTy::Vec(single_generic_type(ty))\n+        } else {\n+            FieldInnerTy::Plain(ty)\n+        }\n     }\n \n     /// Returns `true` if `FieldInnerTy::with` will result in iteration for this inner type (i.e.\n     /// that cloning might be required for values moved in the loop body).\n     pub(crate) fn will_iterate(&self) -> bool {\n         match self {\n             FieldInnerTy::Vec(..) => true,\n-            FieldInnerTy::Option(..) | FieldInnerTy::None => false,\n+            FieldInnerTy::Option(..) | FieldInnerTy::Plain(_) => false,\n         }\n     }\n \n-    /// Returns `Option` containing inner type if there is one.\n-    pub(crate) fn inner_type(&self) -> Option<&'ty Type> {\n+    /// Returns the inner type.\n+    pub(crate) fn inner_type(&self) -> &'ty Type {\n         match self {\n-            FieldInnerTy::Option(inner) | FieldInnerTy::Vec(inner) => Some(inner),\n-            FieldInnerTy::None => None,\n+            FieldInnerTy::Option(inner) | FieldInnerTy::Vec(inner) | FieldInnerTy::Plain(inner) => {\n+                inner\n+            }\n         }\n     }\n \n@@ -185,7 +192,7 @@ impl<'ty> FieldInnerTy<'ty> {\n                     #inner\n                 }\n             },\n-            FieldInnerTy::None => quote! { #inner },\n+            FieldInnerTy::Plain(..) => quote! { #inner },\n         }\n     }\n }\n@@ -194,7 +201,7 @@ impl<'ty> FieldInnerTy<'ty> {\n /// `generate_*` methods from walking the attributes themselves.\n pub(crate) struct FieldInfo<'a> {\n     pub(crate) binding: &'a BindingInfo<'a>,\n-    pub(crate) ty: &'a Type,\n+    pub(crate) ty: FieldInnerTy<'a>,\n     pub(crate) span: &'a proc_macro2::Span,\n }\n "}, {"sha": "145611923ff16a127f4668b9ce999b542d9eda2b", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 607, "deletions": 1, "changes": 608, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -1,8 +1,9 @@\n use rustc_ast::token::Token;\n-use rustc_ast::Path;\n+use rustc_ast::{Path, Visibility};\n use rustc_errors::{fluent, AddToDiagnostic, Applicability, EmissionGuarantee, IntoDiagnostic};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_session::errors::ExprParenthesesNeeded;\n+use rustc_span::edition::{Edition, LATEST_STABLE_EDITION};\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, Symbol};\n \n@@ -1330,3 +1331,608 @@ pub(crate) struct WhereClauseBeforeTupleStructBodySugg {\n     #[suggestion_part(code = \"\")]\n     pub right: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_async_fn_in_2015, code = \"E0670\")]\n+pub(crate) struct AsyncFnIn2015 {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub help: HelpUseLatestEdition,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(parse_async_block_in_2015)]\n+pub(crate) struct AsyncBlockIn2015 {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_self_argument_pointer)]\n+pub(crate) struct SelfArgumentPointer {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_visibility_not_followed_by_item)]\n+#[help]\n+pub(crate) struct VisibilityNotFollowedByItem {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub vis: Visibility,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_default_not_followed_by_item)]\n+#[note]\n+pub(crate) struct DefaultNotFollowedByItem {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum MissingKeywordForItemDefinition {\n+    #[diag(parse_missing_struct_for_struct_definition)]\n+    Struct {\n+        #[primary_span]\n+        #[suggestion(style = \"short\", applicability = \"maybe-incorrect\", code = \" struct \")]\n+        span: Span,\n+        ident: Ident,\n+    },\n+    #[diag(parse_missing_fn_for_function_definition)]\n+    Function {\n+        #[primary_span]\n+        #[suggestion(style = \"short\", applicability = \"maybe-incorrect\", code = \" fn \")]\n+        span: Span,\n+        ident: Ident,\n+    },\n+    #[diag(parse_missing_fn_for_method_definition)]\n+    Method {\n+        #[primary_span]\n+        #[suggestion(style = \"short\", applicability = \"maybe-incorrect\", code = \" fn \")]\n+        span: Span,\n+        ident: Ident,\n+    },\n+    #[diag(parse_ambiguous_missing_keyword_for_item_definition)]\n+    Ambiguous {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiag: Option<AmbiguousMissingKwForItemSub>,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum AmbiguousMissingKwForItemSub {\n+    #[suggestion(suggestion, applicability = \"maybe-incorrect\", code = \"{snippet}!\")]\n+    SuggestMacro {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+    },\n+    #[help(help)]\n+    HelpMacro,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_missing_trait_in_trait_impl)]\n+pub(crate) struct MissingTraitInTraitImpl {\n+    #[primary_span]\n+    #[suggestion(suggestion_add_trait, code = \" Trait \", applicability = \"has-placeholders\")]\n+    pub span: Span,\n+    #[suggestion(suggestion_remove_for, code = \"\", applicability = \"maybe-incorrect\")]\n+    pub for_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_missing_for_in_trait_impl)]\n+pub(crate) struct MissingForInTraitImpl {\n+    #[primary_span]\n+    #[suggestion(style = \"short\", code = \" for \", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_expected_trait_in_trait_impl_found_type)]\n+pub(crate) struct ExpectedTraitInTraitImplFoundType {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_bounds_not_allowed_on_trait_aliases)]\n+pub(crate) struct BoundsNotAllowedOnTraitAliases {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_trait_alias_cannot_be_auto)]\n+pub(crate) struct TraitAliasCannotBeAuto {\n+    #[primary_span]\n+    #[label(parse_trait_alias_cannot_be_auto)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_trait_alias_cannot_be_unsafe)]\n+pub(crate) struct TraitAliasCannotBeUnsafe {\n+    #[primary_span]\n+    #[label(parse_trait_alias_cannot_be_unsafe)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_associated_static_item_not_allowed)]\n+pub(crate) struct AssociatedStaticItemNotAllowed {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_extern_crate_name_with_dashes)]\n+pub(crate) struct ExternCrateNameWithDashes {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: ExternCrateNameWithDashesSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct ExternCrateNameWithDashesSugg {\n+    #[suggestion_part(code = \"_\")]\n+    pub dashes: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_extern_item_cannot_be_const)]\n+#[note]\n+pub(crate) struct ExternItemCannotBeConst {\n+    #[primary_span]\n+    pub ident_span: Span,\n+    #[suggestion(code = \"static \", applicability = \"machine-applicable\")]\n+    pub const_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_const_global_cannot_be_mutable)]\n+pub(crate) struct ConstGlobalCannotBeMutable {\n+    #[primary_span]\n+    #[label]\n+    pub ident_span: Span,\n+    #[suggestion(code = \"static\", applicability = \"maybe-incorrect\")]\n+    pub const_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_missing_const_type)]\n+pub(crate) struct MissingConstType {\n+    #[primary_span]\n+    #[suggestion(code = \"{colon} <type>\", applicability = \"has-placeholders\")]\n+    pub span: Span,\n+\n+    pub kind: &'static str,\n+    pub colon: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_enum_struct_mutually_exclusive)]\n+pub(crate) struct EnumStructMutuallyExclusive {\n+    #[primary_span]\n+    #[suggestion(code = \"enum\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum UnexpectedTokenAfterStructName {\n+    #[diag(parse_unexpected_token_after_struct_name_found_reserved_identifier)]\n+    ReservedIdentifier {\n+        #[primary_span]\n+        #[label(parse_unexpected_token_after_struct_name)]\n+        span: Span,\n+        token: Token,\n+    },\n+    #[diag(parse_unexpected_token_after_struct_name_found_keyword)]\n+    Keyword {\n+        #[primary_span]\n+        #[label(parse_unexpected_token_after_struct_name)]\n+        span: Span,\n+        token: Token,\n+    },\n+    #[diag(parse_unexpected_token_after_struct_name_found_reserved_keyword)]\n+    ReservedKeyword {\n+        #[primary_span]\n+        #[label(parse_unexpected_token_after_struct_name)]\n+        span: Span,\n+        token: Token,\n+    },\n+    #[diag(parse_unexpected_token_after_struct_name_found_doc_comment)]\n+    DocComment {\n+        #[primary_span]\n+        #[label(parse_unexpected_token_after_struct_name)]\n+        span: Span,\n+        token: Token,\n+    },\n+    #[diag(parse_unexpected_token_after_struct_name_found_other)]\n+    Other {\n+        #[primary_span]\n+        #[label(parse_unexpected_token_after_struct_name)]\n+        span: Span,\n+        token: Token,\n+    },\n+}\n+\n+impl UnexpectedTokenAfterStructName {\n+    pub fn new(span: Span, token: Token) -> Self {\n+        match TokenDescription::from_token(&token) {\n+            Some(TokenDescription::ReservedIdentifier) => Self::ReservedIdentifier { span, token },\n+            Some(TokenDescription::Keyword) => Self::Keyword { span, token },\n+            Some(TokenDescription::ReservedKeyword) => Self::ReservedKeyword { span, token },\n+            Some(TokenDescription::DocComment) => Self::DocComment { span, token },\n+            None => Self::Other { span, token },\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unexpected_self_in_generic_parameters)]\n+#[note]\n+pub(crate) struct UnexpectedSelfInGenericParameters {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_multiple_where_clauses)]\n+pub(crate) struct MultipleWhereClauses {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub previous: Span,\n+    #[suggestion(style = \"verbose\", code = \",\", applicability = \"maybe-incorrect\")]\n+    pub between: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum UnexpectedNonterminal {\n+    #[diag(parse_nonterminal_expected_item_keyword)]\n+    Item(#[primary_span] Span),\n+    #[diag(parse_nonterminal_expected_statement)]\n+    Statement(#[primary_span] Span),\n+    #[diag(parse_nonterminal_expected_ident)]\n+    Ident {\n+        #[primary_span]\n+        span: Span,\n+        token: Token,\n+    },\n+    #[diag(parse_nonterminal_expected_lifetime)]\n+    Lifetime {\n+        #[primary_span]\n+        span: Span,\n+        token: Token,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum TopLevelOrPatternNotAllowed {\n+    #[diag(parse_or_pattern_not_allowed_in_let_binding)]\n+    LetBinding {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        sub: Option<TopLevelOrPatternNotAllowedSugg>,\n+    },\n+    #[diag(parse_or_pattern_not_allowed_in_fn_parameters)]\n+    FunctionParameter {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        sub: Option<TopLevelOrPatternNotAllowedSugg>,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum TopLevelOrPatternNotAllowedSugg {\n+    #[suggestion(\n+        parse_sugg_remove_leading_vert_in_pattern,\n+        code = \"{pat}\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    RemoveLeadingVert {\n+        #[primary_span]\n+        span: Span,\n+        pat: String,\n+    },\n+    #[suggestion(\n+        parse_sugg_wrap_pattern_in_parens,\n+        code = \"({pat})\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    WrapInParens {\n+        #[primary_span]\n+        span: Span,\n+        pat: String,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unexpected_vert_vert_before_function_parameter)]\n+#[note(parse_note_pattern_alternatives_use_single_vert)]\n+pub(crate) struct UnexpectedVertVertBeforeFunctionParam {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unexpected_vert_vert_in_pattern)]\n+pub(crate) struct UnexpectedVertVertInPattern {\n+    #[primary_span]\n+    #[suggestion(code = \"|\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    #[label(parse_label_while_parsing_or_pattern_here)]\n+    pub start: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_trailing_vert_not_allowed)]\n+pub(crate) struct TrailingVertNotAllowed {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    #[label(parse_label_while_parsing_or_pattern_here)]\n+    pub start: Option<Span>,\n+    pub token: Token,\n+    #[note(parse_note_pattern_alternatives_use_single_vert)]\n+    pub note_double_vert: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_dotdotdot_rest_pattern)]\n+pub(crate) struct DotDotDotRestPattern {\n+    #[primary_span]\n+    #[suggestion(style = \"short\", code = \"..\", applicability = \"machine-applicable\")]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_pattern_on_wrong_side_of_at)]\n+pub(crate) struct PatternOnWrongSideOfAt {\n+    #[primary_span]\n+    #[suggestion(code = \"{whole_pat}\", applicability = \"machine-applicable\")]\n+    pub whole_span: Span,\n+    pub whole_pat: String,\n+    #[label(label_pattern)]\n+    pub pattern: Span,\n+    #[label(label_binding)]\n+    pub binding: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_expected_binding_left_of_at)]\n+#[note]\n+pub(crate) struct ExpectedBindingLeftOfAt {\n+    #[primary_span]\n+    pub whole_span: Span,\n+    #[label(label_lhs)]\n+    pub lhs: Span,\n+    #[label(label_rhs)]\n+    pub rhs: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_ambiguous_range_pattern)]\n+pub(crate) struct AmbiguousRangePattern {\n+    #[primary_span]\n+    #[suggestion(code = \"({pat})\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+    pub pat: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unexpected_lifetime_in_pattern)]\n+pub(crate) struct UnexpectedLifetimeInPattern {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub symbol: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_ref_mut_order_incorrect)]\n+pub(crate) struct RefMutOrderIncorrect {\n+    #[primary_span]\n+    #[suggestion(code = \"ref mut\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum InvalidMutInPattern {\n+    #[diag(parse_mut_on_nested_ident_pattern)]\n+    #[note(parse_note_mut_pattern_usage)]\n+    NestedIdent {\n+        #[primary_span]\n+        #[suggestion(code = \"{pat}\", applicability = \"machine-applicable\")]\n+        span: Span,\n+        pat: String,\n+    },\n+    #[diag(parse_mut_on_non_ident_pattern)]\n+    #[note(parse_note_mut_pattern_usage)]\n+    NonIdent {\n+        #[primary_span]\n+        #[suggestion(code = \"{pat}\", applicability = \"machine-applicable\")]\n+        span: Span,\n+        pat: String,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_repeated_mut_in_pattern)]\n+pub(crate) struct RepeatedMutInPattern {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_dot_dot_dot_range_to_pattern_not_allowed)]\n+pub(crate) struct DotDotDotRangeToPatternNotAllowed {\n+    #[primary_span]\n+    #[suggestion(style = \"short\", code = \"..=\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_enum_pattern_instead_of_identifier)]\n+pub(crate) struct EnumPatternInsteadOfIdentifier {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_dot_dot_dot_for_remaining_fields)]\n+pub(crate) struct DotDotDotForRemainingFields {\n+    #[primary_span]\n+    #[suggestion(code = \"..\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_expected_comma_after_pattern_field)]\n+pub(crate) struct ExpectedCommaAfterPatternField {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_return_types_use_thin_arrow)]\n+pub(crate) struct ReturnTypesUseThinArrow {\n+    #[primary_span]\n+    #[suggestion(style = \"short\", code = \"->\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_need_plus_after_trait_object_lifetime)]\n+pub(crate) struct NeedPlusAfterTraitObjectLifetime {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_expected_mut_or_const_in_raw_pointer_type)]\n+pub(crate) struct ExpectedMutOrConstInRawPointerType {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code(\"mut \", \"const \"), applicability = \"has-placeholders\")]\n+    pub after_asterisk: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_lifetime_after_mut)]\n+pub(crate) struct LifetimeAfterMut {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"&{snippet} mut\", applicability = \"maybe-incorrect\")]\n+    pub suggest_lifetime: Option<Span>,\n+    pub snippet: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_dyn_after_mut)]\n+pub(crate) struct DynAfterMut {\n+    #[primary_span]\n+    #[suggestion(code = \"&mut dyn\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_fn_pointer_cannot_be_const)]\n+pub(crate) struct FnPointerCannotBeConst {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    #[label]\n+    pub qualifier: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_fn_pointer_cannot_be_async)]\n+pub(crate) struct FnPointerCannotBeAsync {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    #[label]\n+    pub qualifier: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_nested_c_variadic_type, code = \"E0743\")]\n+pub(crate) struct NestedCVariadicType {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_invalid_dyn_keyword)]\n+#[help]\n+pub(crate) struct InvalidDynKeyword {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_negative_bounds_not_supported)]\n+pub(crate) struct NegativeBoundsNotSupported {\n+    #[primary_span]\n+    pub negative_bounds: Vec<Span>,\n+    #[label]\n+    pub last_span: Span,\n+    #[subdiagnostic]\n+    pub sub: Option<NegativeBoundsNotSupportedSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    suggestion,\n+    style = \"tool-only\",\n+    code = \"{fixed}\",\n+    applicability = \"machine-applicable\"\n+)]\n+pub(crate) struct NegativeBoundsNotSupportedSugg {\n+    #[primary_span]\n+    pub bound_list: Span,\n+    pub num_bounds: usize,\n+    pub fixed: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum HelpUseLatestEdition {\n+    #[help(parse_help_set_edition_cargo)]\n+    #[note(parse_note_edition_guide)]\n+    Cargo { edition: Edition },\n+    #[help(parse_help_set_edition_standalone)]\n+    #[note(parse_note_edition_guide)]\n+    Standalone { edition: Edition },\n+}\n+\n+impl HelpUseLatestEdition {\n+    pub fn new() -> Self {\n+        let edition = LATEST_STABLE_EDITION;\n+        if std::env::var_os(\"CARGO\").is_some() {\n+            Self::Cargo { edition }\n+        } else {\n+            Self::Standalone { edition }\n+        }\n+    }\n+}"}, {"sha": "26274822ed8a8ffdeef508586b7c91f471764156", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -2030,7 +2030,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn recover_arg_parse(&mut self) -> PResult<'a, (P<ast::Pat>, P<ast::Ty>)> {\n-        let pat = self.parse_pat_no_top_alt(Some(\"argument name\"))?;\n+        let pat = self.parse_pat_no_top_alt(Some(Expected::ArgumentName))?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n@@ -2397,7 +2397,7 @@ impl<'a> Parser<'a> {\n     pub(crate) fn maybe_recover_colon_colon_in_pat_typo_or_anon_enum(\n         &mut self,\n         mut first_pat: P<Pat>,\n-        expected: Expected,\n+        expected: Option<Expected>,\n     ) -> P<Pat> {\n         if token::Colon != self.token.kind {\n             return first_pat;"}, {"sha": "b7a023868fced9e84107b4194816a3db53bede7f", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -1,25 +1,26 @@\n use super::diagnostics::SnapshotParser;\n-use super::pat::{CommaRecoveryMode, RecoverColon, RecoverComma, PARAM_EXPECTED};\n+use super::pat::{CommaRecoveryMode, Expected, RecoverColon, RecoverComma};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{\n     AttrWrapper, BlockMode, ClosureSpans, ForceCollect, Parser, PathStyle, Restrictions,\n     SemiColonMode, SeqSep, TokenExpectType, TokenType, TrailingToken,\n };\n use crate::errors::{\n-    ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, AsyncMoveOrderIncorrect,\n-    BracesForStructLiteral, CatchAfterTry, CommaAfterBaseStruct, ComparisonInterpretedAsGeneric,\n-    ComparisonOrShiftInterpretedAsGenericSugg, DoCatchSyntaxRemoved, DotDotDot, EqFieldInit,\n-    ExpectedElseBlock, ExpectedEqForLetExpr, ExpectedExpressionFoundLet,\n-    FieldExpressionWithGeneric, FloatLiteralRequiresIntegerPart, FoundExprWouldBeStmt,\n-    IfExpressionLetSomeSub, IfExpressionMissingCondition, IfExpressionMissingThenBlock,\n-    IfExpressionMissingThenBlockSub, InvalidBlockMacroSegment, InvalidComparisonOperator,\n-    InvalidComparisonOperatorSub, InvalidInterpolatedExpression, InvalidLiteralSuffixOnTupleIndex,\n-    InvalidLogicalOperator, InvalidLogicalOperatorSub, LabeledLoopInBreak, LeadingPlusNotSupported,\n-    LeftArrowOperator, LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath,\n-    MalformedLoopLabel, MatchArmBodyWithoutBraces, MatchArmBodyWithoutBracesSugg,\n-    MissingCommaAfterMatchArm, MissingDotDot, MissingInInForLoop, MissingInInForLoopSub,\n-    MissingSemicolonBeforeArray, NoFieldsForFnCall, NotAsNegationOperator,\n-    NotAsNegationOperatorSub, OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n+    ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, AsyncBlockIn2015,\n+    AsyncMoveOrderIncorrect, BracesForStructLiteral, CatchAfterTry, CommaAfterBaseStruct,\n+    ComparisonInterpretedAsGeneric, ComparisonOrShiftInterpretedAsGenericSugg,\n+    DoCatchSyntaxRemoved, DotDotDot, EqFieldInit, ExpectedElseBlock, ExpectedEqForLetExpr,\n+    ExpectedExpressionFoundLet, FieldExpressionWithGeneric, FloatLiteralRequiresIntegerPart,\n+    FoundExprWouldBeStmt, HelpUseLatestEdition, IfExpressionLetSomeSub,\n+    IfExpressionMissingCondition, IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub,\n+    InvalidBlockMacroSegment, InvalidComparisonOperator, InvalidComparisonOperatorSub,\n+    InvalidInterpolatedExpression, InvalidLiteralSuffixOnTupleIndex, InvalidLogicalOperator,\n+    InvalidLogicalOperatorSub, LabeledLoopInBreak, LeadingPlusNotSupported, LeftArrowOperator,\n+    LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath, MalformedLoopLabel,\n+    MatchArmBodyWithoutBraces, MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm,\n+    MissingDotDot, MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray,\n+    NoFieldsForFnCall, NotAsNegationOperator, NotAsNegationOperatorSub,\n+    OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n     RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric, StructLiteralNotAllowedHere,\n     StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator, UnexpectedIfWithIf,\n     UnexpectedTokenAfterLabel, UnexpectedTokenAfterLabelSugg, WrapExpressionInParentheses,\n@@ -39,8 +40,8 @@ use rustc_ast::{Arm, Async, BlockCheckMode, Expr, ExprKind, Label, Movability, R\n use rustc_ast::{ClosureBinder, MetaItemLit, StmtKind};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{\n-    Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, PResult,\n-    StashKey,\n+    AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic,\n+    PResult, StashKey,\n };\n use rustc_session::errors::{report_lit_error, ExprParenthesesNeeded};\n use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n@@ -2221,7 +2222,7 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let attrs = self.parse_outer_attributes()?;\n         self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n-            let pat = this.parse_pat_no_top_alt(PARAM_EXPECTED)?;\n+            let pat = this.parse_pat_no_top_alt(Some(Expected::ParameterName))?;\n             let ty = if this.eat(&token::Colon) {\n                 this.parse_ty()?\n             } else {\n@@ -2926,8 +2927,8 @@ impl<'a> Parser<'a> {\n \n         let mut async_block_err = |e: &mut Diagnostic, span: Span| {\n             recover_async = true;\n-            e.span_label(span, \"`async` blocks are only allowed in Rust 2018 or later\");\n-            e.help_use_latest_edition();\n+            AsyncBlockIn2015 { span }.add_to_diagnostic(e);\n+            HelpUseLatestEdition::new().add_to_diagnostic(e);\n         };\n \n         while self.token != token::CloseDelim(close_delim) {"}, {"sha": "585dfc518b325c1735f89e1dec201179d0840d25", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -1,4 +1,7 @@\n-use crate::errors::{WhereClauseBeforeTupleStructBody, WhereClauseBeforeTupleStructBodySugg};\n+use crate::errors::{\n+    MultipleWhereClauses, UnexpectedSelfInGenericParameters, WhereClauseBeforeTupleStructBody,\n+    WhereClauseBeforeTupleStructBodySugg,\n+};\n \n use super::{ForceCollect, Parser, TrailingToken};\n \n@@ -127,12 +130,9 @@ impl<'a> Parser<'a> {\n                     if this.eat_keyword_noexpect(kw::SelfUpper) {\n                         // `Self` as a generic param is invalid. Here we emit the diagnostic and continue parsing\n                         // as if `Self` never existed.\n-                        this.struct_span_err(\n-                            this.prev_token.span,\n-                            \"unexpected keyword `Self` in generic parameters\",\n-                        )\n-                        .note(\"you cannot use `Self` as a generic parameter because it is reserved for associated items\")\n-                        .emit();\n+                        this.sess.emit_err(UnexpectedSelfInGenericParameters {\n+                            span: this.prev_token.span,\n+                        });\n \n                         this.eat(&token::Comma);\n                     }\n@@ -329,16 +329,11 @@ impl<'a> Parser<'a> {\n             let ate_comma = self.eat(&token::Comma);\n \n             if self.eat_keyword_noexpect(kw::Where) {\n-                let msg = \"cannot define duplicate `where` clauses on an item\";\n-                let mut err = self.struct_span_err(self.token.span, msg);\n-                err.span_label(pred_lo, \"previous `where` clause starts here\");\n-                err.span_suggestion_verbose(\n-                    prev_token.shrink_to_hi().to(self.prev_token.span),\n-                    \"consider joining the two `where` clauses into one\",\n-                    \",\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-                err.emit();\n+                self.sess.emit_err(MultipleWhereClauses {\n+                    span: self.token.span,\n+                    previous: pred_lo,\n+                    between: prev_token.shrink_to_hi().to(self.prev_token.span),\n+                });\n             } else if !ate_comma {\n                 break;\n             }"}, {"sha": "81fd084ccb38e25c691e7d72a8e4598ad0b47c15", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 142, "deletions": 236, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -1,4 +1,13 @@\n-use crate::errors::{DocCommentDoesNotDocumentAnything, UseEmptyBlockNotSemi};\n+use crate::errors::{\n+    AmbiguousMissingKwForItemSub, AssociatedStaticItemNotAllowed, AsyncFnIn2015,\n+    BoundsNotAllowedOnTraitAliases, ConstGlobalCannotBeMutable, ConstLetMutuallyExclusive,\n+    DefaultNotFollowedByItem, DocCommentDoesNotDocumentAnything, EnumStructMutuallyExclusive,\n+    ExpectedTraitInTraitImplFoundType, ExternCrateNameWithDashes, ExternCrateNameWithDashesSugg,\n+    ExternItemCannotBeConst, HelpUseLatestEdition, MissingConstType, MissingForInTraitImpl,\n+    MissingKeywordForItemDefinition, MissingTraitInTraitImpl, SelfArgumentPointer,\n+    TraitAliasCannotBeAuto, TraitAliasCannotBeUnsafe, UnexpectedTokenAfterStructName,\n+    UseEmptyBlockNotSemi, VisibilityNotFollowedByItem,\n+};\n \n use super::diagnostics::{dummy_arg, ConsumeClosingDelim};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n@@ -16,12 +25,16 @@ use rustc_ast::{EnumDef, FieldDef, Generics, TraitRef, Ty, TyKind, Variant, Vari\n use rustc_ast::{FnHeader, ForeignItem, Path, PathSegment, Visibility, VisibilityKind};\n use rustc_ast::{MacCall, MacDelimiter};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{struct_span_err, Applicability, IntoDiagnostic, PResult, StashKey};\n+use rustc_errors::{\n+    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, PResult,\n+    StashKey,\n+};\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::lev_distance;\n use rustc_span::source_map::{self, Span};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n+use std::fmt::Write;\n use std::mem;\n use thin_vec::ThinVec;\n \n@@ -163,35 +176,18 @@ impl<'a> Parser<'a> {\n         }\n \n         // At this point, we have failed to parse an item.\n-        self.error_on_unmatched_vis(&vis);\n-        self.error_on_unmatched_defaultness(def);\n-        if !attrs_allowed {\n-            self.recover_attrs_no_item(&attrs)?;\n+        if !matches!(vis.kind, VisibilityKind::Inherited) {\n+            self.sess.emit_err(VisibilityNotFollowedByItem { span: vis.span, vis });\n         }\n-        Ok(None)\n-    }\n \n-    /// Error in-case a non-inherited visibility was parsed but no item followed.\n-    fn error_on_unmatched_vis(&self, vis: &Visibility) {\n-        if let VisibilityKind::Inherited = vis.kind {\n-            return;\n+        if let Defaultness::Default(span) = def {\n+            self.sess.emit_err(DefaultNotFollowedByItem { span });\n         }\n-        let vs = pprust::vis_to_string(&vis);\n-        let vs = vs.trim_end();\n-        self.struct_span_err(vis.span, &format!(\"visibility `{vs}` is not followed by an item\"))\n-            .span_label(vis.span, \"the visibility\")\n-            .help(&format!(\"you likely meant to define an item, e.g., `{vs} fn foo() {{}}`\"))\n-            .emit();\n-    }\n \n-    /// Error in-case a `default` was parsed but no item followed.\n-    fn error_on_unmatched_defaultness(&self, def: Defaultness) {\n-        if let Defaultness::Default(sp) = def {\n-            self.struct_span_err(sp, \"`default` is not followed by an item\")\n-                .span_label(sp, \"the `default` qualifier\")\n-                .note(\"only `fn`, `const`, `type`, or `impl` items may be prefixed by `default`\")\n-                .emit();\n+        if !attrs_allowed {\n+            self.recover_attrs_no_item(&attrs)?;\n         }\n+        Ok(None)\n     }\n \n     /// Error in-case `default` was parsed in an in-appropriate context.\n@@ -384,86 +380,72 @@ impl<'a> Parser<'a> {\n         let sp = self.prev_token.span.between(self.token.span);\n         let full_sp = self.prev_token.span.to(self.token.span);\n         let ident_sp = self.token.span;\n-        if self.look_ahead(1, |t| *t == token::OpenDelim(Delimiter::Brace)) {\n+\n+        let ident = if self.look_ahead(1, |t| {\n+            [\n+                token::Lt,\n+                token::OpenDelim(Delimiter::Brace),\n+                token::OpenDelim(Delimiter::Parenthesis),\n+            ]\n+            .contains(&t.kind)\n+        }) {\n+            self.parse_ident().unwrap()\n+        } else {\n+            return Ok(());\n+        };\n+\n+        let mut found_generics = false;\n+        if self.check(&token::Lt) {\n+            found_generics = true;\n+            self.eat_to_tokens(&[&token::Gt]);\n+            self.bump(); // `>`\n+        }\n+\n+        let err = if self.check(&token::OpenDelim(Delimiter::Brace)) {\n             // possible public struct definition where `struct` was forgotten\n-            let ident = self.parse_ident().unwrap();\n-            let msg = format!(\"add `struct` here to parse `{ident}` as a public struct\");\n-            let mut err = self.struct_span_err(sp, \"missing `struct` for struct definition\");\n-            err.span_suggestion_short(\n-                sp,\n-                &msg,\n-                \" struct \",\n-                Applicability::MaybeIncorrect, // speculative\n-            );\n-            Err(err)\n-        } else if self.look_ahead(1, |t| *t == token::OpenDelim(Delimiter::Parenthesis)) {\n-            let ident = self.parse_ident().unwrap();\n+            Some(MissingKeywordForItemDefinition::Struct { span: sp, ident })\n+        } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n+            // possible public function or tuple struct definition where `fn`/`struct` was\n+            // forgotten\n             self.bump(); // `(`\n-            let kw_name = self.recover_first_param();\n+            let is_method = self.recover_self_param();\n+\n             self.consume_block(Delimiter::Parenthesis, ConsumeClosingDelim::Yes);\n-            let (kw, kw_name, ambiguous) = if self.check(&token::RArrow) {\n+\n+            let err = if self.check(&token::RArrow)\n+                || self.check(&token::OpenDelim(Delimiter::Brace))\n+            {\n                 self.eat_to_tokens(&[&token::OpenDelim(Delimiter::Brace)]);\n                 self.bump(); // `{`\n-                (\"fn\", kw_name, false)\n-            } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n-                self.bump(); // `{`\n-                (\"fn\", kw_name, false)\n-            } else if self.check(&token::Colon) {\n-                let kw = \"struct\";\n-                (kw, kw, false)\n-            } else {\n-                (\"fn` or `struct\", \"function or struct\", true)\n-            };\n-\n-            let msg = format!(\"missing `{kw}` for {kw_name} definition\");\n-            let mut err = self.struct_span_err(sp, &msg);\n-            if !ambiguous {\n                 self.consume_block(Delimiter::Brace, ConsumeClosingDelim::Yes);\n-                let suggestion =\n-                    format!(\"add `{kw}` here to parse `{ident}` as a public {kw_name}\");\n-                err.span_suggestion_short(\n-                    sp,\n-                    &suggestion,\n-                    format!(\" {kw} \"),\n-                    Applicability::MachineApplicable,\n-                );\n-            } else if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n-                err.span_suggestion(\n-                    full_sp,\n-                    \"if you meant to call a macro, try\",\n-                    format!(\"{}!\", snippet),\n-                    // this is the `ambiguous` conditional branch\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                err.help(\n-                    \"if you meant to call a macro, remove the `pub` \\\n-                              and add a trailing `!` after the identifier\",\n-                );\n-            }\n-            Err(err)\n-        } else if self.look_ahead(1, |t| *t == token::Lt) {\n-            let ident = self.parse_ident().unwrap();\n-            self.eat_to_tokens(&[&token::Gt]);\n-            self.bump(); // `>`\n-            let (kw, kw_name, ambiguous) = if self.eat(&token::OpenDelim(Delimiter::Parenthesis)) {\n-                (\"fn\", self.recover_first_param(), false)\n-            } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n-                (\"struct\", \"struct\", false)\n+                if is_method {\n+                    MissingKeywordForItemDefinition::Method { span: sp, ident }\n+                } else {\n+                    MissingKeywordForItemDefinition::Function { span: sp, ident }\n+                }\n+            } else if self.check(&token::Semi) {\n+                MissingKeywordForItemDefinition::Struct { span: sp, ident }\n             } else {\n-                (\"fn` or `struct\", \"function or struct\", true)\n+                MissingKeywordForItemDefinition::Ambiguous {\n+                    span: sp,\n+                    subdiag: if found_generics {\n+                        None\n+                    } else if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n+                        Some(AmbiguousMissingKwForItemSub::SuggestMacro { span: full_sp, snippet })\n+                    } else {\n+                        Some(AmbiguousMissingKwForItemSub::HelpMacro)\n+                    },\n+                }\n             };\n-            let msg = format!(\"missing `{kw}` for {kw_name} definition\");\n-            let mut err = self.struct_span_err(sp, &msg);\n-            if !ambiguous {\n-                err.span_suggestion_short(\n-                    sp,\n-                    &format!(\"add `{kw}` here to parse `{ident}` as a public {kw_name}\"),\n-                    format!(\" {} \", kw),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            Err(err)\n+            Some(err)\n+        } else if found_generics {\n+            Some(MissingKeywordForItemDefinition::Ambiguous { span: sp, subdiag: None })\n+        } else {\n+            None\n+        };\n+\n+        if let Some(err) = err {\n+            Err(err.into_diagnostic(&self.sess.span_diagnostic))\n         } else {\n             Ok(())\n         }\n@@ -512,16 +494,13 @@ impl<'a> Parser<'a> {\n         let mut err = self.struct_span_err(end.span, msg);\n         if end.is_doc_comment() {\n             err.span_label(end.span, \"this doc comment doesn't document anything\");\n-        }\n-        if end.meta_kind().is_some() {\n-            if self.token.kind == TokenKind::Semi {\n-                err.span_suggestion_verbose(\n-                    self.token.span,\n-                    \"consider removing this semicolon\",\n-                    \"\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n+        } else if self.token.kind == TokenKind::Semi {\n+            err.span_suggestion_verbose(\n+                self.token.span,\n+                \"consider removing this semicolon\",\n+                \"\",\n+                Applicability::MaybeIncorrect,\n+            );\n         }\n         if let [.., penultimate, _] = attrs {\n             err.span_label(start.span.to(penultimate.span), \"other attributes here\");\n@@ -588,20 +567,9 @@ impl<'a> Parser<'a> {\n         let ty_first = if self.token.is_keyword(kw::For) && self.look_ahead(1, |t| t != &token::Lt)\n         {\n             let span = self.prev_token.span.between(self.token.span);\n-            self.struct_span_err(span, \"missing trait in a trait impl\")\n-                .span_suggestion(\n-                    span,\n-                    \"add a trait here\",\n-                    \" Trait \",\n-                    Applicability::HasPlaceholders,\n-                )\n-                .span_suggestion(\n-                    span.to(self.token.span),\n-                    \"for an inherent impl, drop this `for`\",\n-                    \"\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            self.sess\n+                .emit_err(MissingTraitInTraitImpl { span, for_span: span.to(self.token.span) });\n+\n             P(Ty {\n                 kind: TyKind::Path(None, err_path(span)),\n                 span,\n@@ -634,22 +602,16 @@ impl<'a> Parser<'a> {\n             Some(ty_second) => {\n                 // impl Trait for Type\n                 if !has_for {\n-                    self.struct_span_err(missing_for_span, \"missing `for` in a trait impl\")\n-                        .span_suggestion_short(\n-                            missing_for_span,\n-                            \"add `for` here\",\n-                            \" for \",\n-                            Applicability::MachineApplicable,\n-                        )\n-                        .emit();\n+                    self.sess.emit_err(MissingForInTraitImpl { span: missing_for_span });\n                 }\n \n                 let ty_first = ty_first.into_inner();\n                 let path = match ty_first.kind {\n                     // This notably includes paths passed through `ty` macro fragments (#46438).\n                     TyKind::Path(None, path) => path,\n                     _ => {\n-                        self.struct_span_err(ty_first.span, \"expected a trait, found type\").emit();\n+                        self.sess\n+                            .emit_err(ExpectedTraitInTraitImplFoundType { span: ty_first.span });\n                         err_path(ty_first.span)\n                     }\n                 };\n@@ -783,6 +745,7 @@ impl<'a> Parser<'a> {\n     fn recover_doc_comment_before_brace(&mut self) -> bool {\n         if let token::DocComment(..) = self.token.kind {\n             if self.look_ahead(1, |tok| tok == &token::CloseDelim(Delimiter::Brace)) {\n+                // FIXME: merge with `DocCommentDoesNotDocumentAnything` (E0585)\n                 struct_span_err!(\n                     self.diagnostic(),\n                     self.token.span,\n@@ -849,7 +812,7 @@ impl<'a> Parser<'a> {\n             // It's a trait alias.\n             if had_colon {\n                 let span = span_at_colon.to(span_before_eq);\n-                self.struct_span_err(span, \"bounds are not allowed on trait aliases\").emit();\n+                self.sess.emit_err(BoundsNotAllowedOnTraitAliases { span });\n             }\n \n             let bounds = self.parse_generic_bounds(None)?;\n@@ -858,12 +821,10 @@ impl<'a> Parser<'a> {\n \n             let whole_span = lo.to(self.prev_token.span);\n             if is_auto == IsAuto::Yes {\n-                let msg = \"trait aliases cannot be `auto`\";\n-                self.struct_span_err(whole_span, msg).span_label(whole_span, msg).emit();\n+                self.sess.emit_err(TraitAliasCannotBeAuto { span: whole_span });\n             }\n             if let Unsafe::Yes(_) = unsafety {\n-                let msg = \"trait aliases cannot be `unsafe`\";\n-                self.struct_span_err(whole_span, msg).span_label(whole_span, msg).emit();\n+                self.sess.emit_err(TraitAliasCannotBeUnsafe { span: whole_span });\n             }\n \n             self.sess.gated_spans.gate(sym::trait_alias, whole_span);\n@@ -909,8 +870,7 @@ impl<'a> Parser<'a> {\n                     Ok(kind) => kind,\n                     Err(kind) => match kind {\n                         ItemKind::Static(a, _, b) => {\n-                            self.struct_span_err(span, \"associated `static` items are not allowed\")\n-                                .emit();\n+                            self.sess.emit_err(AssociatedStaticItemNotAllowed { span });\n                             AssocItemKind::Const(Defaultness::Final, a, b)\n                         }\n                         _ => return self.error_bad_item_kind(span, &kind, \"`trait`s or `impl`s\"),\n@@ -1084,41 +1044,37 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_crate_name_with_dashes(&mut self) -> PResult<'a, Ident> {\n-        let error_msg = \"crate name using dashes are not valid in `extern crate` statements\";\n-        let suggestion_msg = \"if the original crate name uses dashes you need to use underscores \\\n-                              in the code\";\n-        let mut ident = if self.token.is_keyword(kw::SelfLower) {\n+        let ident = if self.token.is_keyword(kw::SelfLower) {\n             self.parse_path_segment_ident()\n         } else {\n             self.parse_ident()\n         }?;\n-        let mut idents = vec![];\n-        let mut replacement = vec![];\n-        let mut fixed_crate_name = false;\n-        // Accept `extern crate name-like-this` for better diagnostics.\n+\n         let dash = token::BinOp(token::BinOpToken::Minus);\n-        if self.token == dash {\n-            // Do not include `-` as part of the expected tokens list.\n-            while self.eat(&dash) {\n-                fixed_crate_name = true;\n-                replacement.push((self.prev_token.span, \"_\".to_string()));\n-                idents.push(self.parse_ident()?);\n-            }\n+        if self.token != dash {\n+            return Ok(ident);\n         }\n-        if fixed_crate_name {\n-            let fixed_name_sp = ident.span.to(idents.last().unwrap().span);\n-            let mut fixed_name = ident.name.to_string();\n-            for part in idents {\n-                fixed_name.push_str(&format!(\"_{}\", part.name));\n-            }\n-            ident = Ident::from_str_and_span(&fixed_name, fixed_name_sp);\n \n-            self.struct_span_err(fixed_name_sp, error_msg)\n-                .span_label(fixed_name_sp, \"dash-separated idents are not valid\")\n-                .multipart_suggestion(suggestion_msg, replacement, Applicability::MachineApplicable)\n-                .emit();\n+        // Accept `extern crate name-like-this` for better diagnostics.\n+        let mut dashes = vec![];\n+        let mut idents = vec![];\n+        while self.eat(&dash) {\n+            dashes.push(self.prev_token.span);\n+            idents.push(self.parse_ident()?);\n         }\n-        Ok(ident)\n+\n+        let fixed_name_sp = ident.span.to(idents.last().unwrap().span);\n+        let mut fixed_name = ident.name.to_string();\n+        for part in idents {\n+            write!(fixed_name, \"_{}\", part.name).unwrap();\n+        }\n+\n+        self.sess.emit_err(ExternCrateNameWithDashes {\n+            span: fixed_name_sp,\n+            sugg: ExternCrateNameWithDashesSugg { dashes },\n+        });\n+\n+        Ok(Ident::from_str_and_span(&fixed_name, fixed_name_sp))\n     }\n \n     /// Parses `extern` for foreign ABIs modules.\n@@ -1166,7 +1122,10 @@ impl<'a> Parser<'a> {\n                     Ok(kind) => kind,\n                     Err(kind) => match kind {\n                         ItemKind::Const(_, a, b) => {\n-                            self.error_on_foreign_const(span, ident);\n+                            self.sess.emit_err(ExternItemCannotBeConst {\n+                                ident_span: ident.span,\n+                                const_span: span.with_hi(ident.span.lo()),\n+                            });\n                             ForeignItemKind::Static(a, Mutability::Not, b)\n                         }\n                         _ => return self.error_bad_item_kind(span, &kind, \"`extern` blocks\"),\n@@ -1178,6 +1137,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn error_bad_item_kind<T>(&self, span: Span, kind: &ItemKind, ctx: &str) -> Option<T> {\n+        // FIXME(#100717): needs variant for each `ItemKind` (instead of using `ItemKind::descr()`)\n         let span = self.sess.source_map().guess_head_span(span);\n         let descr = kind.descr();\n         self.struct_span_err(span, &format!(\"{descr} is not supported in {ctx}\"))\n@@ -1186,18 +1146,6 @@ impl<'a> Parser<'a> {\n         None\n     }\n \n-    fn error_on_foreign_const(&self, span: Span, ident: Ident) {\n-        self.struct_span_err(ident.span, \"extern items cannot be `const`\")\n-            .span_suggestion(\n-                span.with_hi(ident.span.lo()),\n-                \"try using a static value\",\n-                \"static \",\n-                Applicability::MachineApplicable,\n-            )\n-            .note(\"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\")\n-            .emit();\n-    }\n-\n     fn is_unsafe_foreign_mod(&self) -> bool {\n         self.token.is_keyword(kw::Unsafe)\n             && self.is_keyword_ahead(1, &[kw::Extern])\n@@ -1225,25 +1173,10 @@ impl<'a> Parser<'a> {\n     fn recover_const_mut(&mut self, const_span: Span) {\n         if self.eat_keyword(kw::Mut) {\n             let span = self.prev_token.span;\n-            self.struct_span_err(span, \"const globals cannot be mutable\")\n-                .span_label(span, \"cannot be mutable\")\n-                .span_suggestion(\n-                    const_span,\n-                    \"you might want to declare a static instead\",\n-                    \"static\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            self.sess.emit_err(ConstGlobalCannotBeMutable { ident_span: span, const_span });\n         } else if self.eat_keyword(kw::Let) {\n             let span = self.prev_token.span;\n-            self.struct_span_err(const_span.to(span), \"`const` and `let` are mutually exclusive\")\n-                .span_suggestion(\n-                    const_span.to(span),\n-                    \"remove `let`\",\n-                    \"const\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            self.sess.emit_err(ConstLetMutuallyExclusive { span: const_span.to(span) });\n         }\n     }\n \n@@ -1328,13 +1261,8 @@ impl<'a> Parser<'a> {\n         };\n \n         let span = self.prev_token.span.shrink_to_hi();\n-        let mut err = self.struct_span_err(span, &format!(\"missing type for `{kind}` item\"));\n-        err.span_suggestion(\n-            span,\n-            \"provide a type for the item\",\n-            format!(\"{colon} <type>\"),\n-            Applicability::HasPlaceholders,\n-        );\n+        let err: DiagnosticBuilder<'_, ErrorGuaranteed> =\n+            MissingConstType { span, colon, kind }.into_diagnostic(&self.sess.span_diagnostic);\n         err.stash(span, StashKey::ItemNoType);\n \n         // The user intended that the type be inferred,\n@@ -1346,18 +1274,12 @@ impl<'a> Parser<'a> {\n     fn parse_item_enum(&mut self) -> PResult<'a, ItemInfo> {\n         if self.token.is_keyword(kw::Struct) {\n             let span = self.prev_token.span.to(self.token.span);\n-            let mut err = self.struct_span_err(span, \"`enum` and `struct` are mutually exclusive\");\n-            err.span_suggestion(\n-                span,\n-                \"replace `enum struct` with\",\n-                \"enum\",\n-                Applicability::MachineApplicable,\n-            );\n+            let err = EnumStructMutuallyExclusive { span };\n             if self.look_ahead(1, |t| t.is_ident()) {\n                 self.bump();\n-                err.emit();\n+                self.sess.emit_err(err);\n             } else {\n-                return Err(err);\n+                return Err(err.into_diagnostic(&self.sess.span_diagnostic));\n             }\n         }\n \n@@ -1493,13 +1415,8 @@ impl<'a> Parser<'a> {\n             self.expect_semi()?;\n             body\n         } else {\n-            let token_str = super::token_descr(&self.token);\n-            let msg = &format!(\n-                \"expected `where`, `{{`, `(`, or `;` after struct name, found {token_str}\"\n-            );\n-            let mut err = self.struct_span_err(self.token.span, msg);\n-            err.span_label(self.token.span, \"expected `where`, `{`, `(`, or `;` after struct name\");\n-            return Err(err);\n+            let err = UnexpectedTokenAfterStructName::new(self.token.span, self.token.clone());\n+            return Err(err.into_diagnostic(&self.sess.span_diagnostic));\n         };\n \n         Ok((class_name, ItemKind::Struct(vdata, generics)))\n@@ -2330,7 +2247,9 @@ impl<'a> Parser<'a> {\n         let ext = self.parse_extern(case);\n \n         if let Async::Yes { span, .. } = asyncness {\n-            self.ban_async_in_2015(span);\n+            if span.rust_2015() {\n+                self.sess.emit_err(AsyncFnIn2015 { span, help: HelpUseLatestEdition::new() });\n+            }\n         }\n \n         if !self.eat_keyword_case(kw::Fn, case) {\n@@ -2440,17 +2359,6 @@ impl<'a> Parser<'a> {\n         Ok(FnHeader { constness, unsafety, asyncness, ext })\n     }\n \n-    /// We are parsing `async fn`. If we are on Rust 2015, emit an error.\n-    fn ban_async_in_2015(&self, span: Span) {\n-        if span.rust_2015() {\n-            let diag = self.diagnostic();\n-            struct_span_err!(diag, span, E0670, \"`async fn` is not permitted in Rust 2015\")\n-                .span_label(span, \"to use `async fn`, switch to Rust 2018 or later\")\n-                .help_use_latest_edition()\n-                .emit();\n-        }\n-    }\n-\n     /// Parses the parameter list and result type of a function declaration.\n     pub(super) fn parse_fn_decl(\n         &mut self,\n@@ -2593,9 +2501,7 @@ impl<'a> Parser<'a> {\n         };\n         // Recover for the grammar `*self`, `*const self`, and `*mut self`.\n         let recover_self_ptr = |this: &mut Self| {\n-            let msg = \"cannot pass `self` by raw pointer\";\n-            let span = this.token.span;\n-            this.struct_span_err(span, msg).span_label(span, msg).emit();\n+            self.sess.emit_err(SelfArgumentPointer { span: this.token.span });\n \n             Ok((SelfKind::Value(Mutability::Not), expect_self_ident(this), this.prev_token.span))\n         };\n@@ -2676,14 +2582,14 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(offset + 1, |t| t == &token::Colon)\n     }\n \n-    fn recover_first_param(&mut self) -> &'static str {\n+    fn recover_self_param(&mut self) -> bool {\n         match self\n             .parse_outer_attributes()\n             .and_then(|_| self.parse_self_param())\n             .map_err(|e| e.cancel())\n         {\n-            Ok(Some(_)) => \"method\",\n-            _ => \"function\",\n+            Ok(Some(_)) => true,\n+            _ => false,\n         }\n     }\n }"}, {"sha": "7a4d53ed8bbe04d87983124b01a2586ee00ba8cb", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -2,9 +2,11 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, NonterminalKind, Token};\n use rustc_ast::HasTokens;\n use rustc_ast_pretty::pprust;\n+use rustc_errors::IntoDiagnostic;\n use rustc_errors::PResult;\n use rustc_span::symbol::{kw, Ident};\n \n+use crate::errors::UnexpectedNonterminal;\n use crate::parser::pat::{CommaRecoveryMode, RecoverColon, RecoverComma};\n use crate::parser::{FollowedByType, ForceCollect, NtOrTt, Parser, PathStyle};\n \n@@ -113,7 +115,8 @@ impl<'a> Parser<'a> {\n             NonterminalKind::Item => match self.parse_item(ForceCollect::Yes)? {\n                 Some(item) => token::NtItem(item),\n                 None => {\n-                    return Err(self.struct_span_err(self.token.span, \"expected an item keyword\"));\n+                    return Err(UnexpectedNonterminal::Item(self.token.span)\n+                               .into_diagnostic(&self.sess.span_diagnostic));\n                 }\n             },\n             NonterminalKind::Block => {\n@@ -124,7 +127,8 @@ impl<'a> Parser<'a> {\n             NonterminalKind::Stmt => match self.parse_stmt(ForceCollect::Yes)? {\n                 Some(s) => token::NtStmt(P(s)),\n                 None => {\n-                    return Err(self.struct_span_err(self.token.span, \"expected a statement\"));\n+                    return Err(UnexpectedNonterminal::Statement(self.token.span)\n+                               .into_diagnostic(&self.sess.span_diagnostic));\n                 }\n             },\n             NonterminalKind::PatParam { .. } | NonterminalKind::PatWithOr { .. } => {\n@@ -160,9 +164,10 @@ impl<'a> Parser<'a> {\n                 token::NtIdent(ident, is_raw)\n             }\n             NonterminalKind::Ident => {\n-                let token_str = pprust::token_to_string(&self.token);\n-                let msg = &format!(\"expected ident, found {}\", &token_str);\n-                return Err(self.struct_span_err(self.token.span, msg));\n+                return Err(UnexpectedNonterminal::Ident {\n+                    span: self.token.span,\n+                    token: self.token.clone(),\n+                }.into_diagnostic(&self.sess.span_diagnostic));\n             }\n             NonterminalKind::Path => token::NtPath(\n                 P(self.collect_tokens_no_attrs(|this| this.parse_path(PathStyle::Type))?),\n@@ -175,9 +180,10 @@ impl<'a> Parser<'a> {\n                 if self.check_lifetime() {\n                     token::NtLifetime(self.expect_lifetime().ident)\n                 } else {\n-                    let token_str = pprust::token_to_string(&self.token);\n-                    let msg = &format!(\"expected a lifetime, found `{}`\", &token_str);\n-                    return Err(self.struct_span_err(self.token.span, msg));\n+                    return Err(UnexpectedNonterminal::Lifetime {\n+                        span: self.token.span,\n+                        token: self.token.clone(),\n+                    }.into_diagnostic(&self.sess.span_diagnostic));\n                 }\n             }\n         };"}, {"sha": "88c75fd81e7582b2a4d72a471fd55ac97df7e486", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 135, "deletions": 192, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -1,6 +1,12 @@\n use super::{ForceCollect, Parser, PathStyle, TrailingToken};\n use crate::errors::{\n-    InclusiveRangeExtraEquals, InclusiveRangeMatchArrow, InclusiveRangeNoEnd, RemoveLet,\n+    AmbiguousRangePattern, DotDotDotForRemainingFields, DotDotDotRangeToPatternNotAllowed,\n+    DotDotDotRestPattern, EnumPatternInsteadOfIdentifier, ExpectedBindingLeftOfAt,\n+    ExpectedCommaAfterPatternField, InclusiveRangeExtraEquals, InclusiveRangeMatchArrow,\n+    InclusiveRangeNoEnd, InvalidMutInPattern, PatternOnWrongSideOfAt, RefMutOrderIncorrect,\n+    RemoveLet, RepeatedMutInPattern, TopLevelOrPatternNotAllowed, TopLevelOrPatternNotAllowedSugg,\n+    TrailingVertNotAllowed, UnexpectedLifetimeInPattern, UnexpectedVertVertBeforeFunctionParam,\n+    UnexpectedVertVertInPattern,\n };\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n@@ -11,15 +17,33 @@ use rustc_ast::{\n     PatField, PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n };\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n+use rustc_errors::{\n+    fluent, Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, PResult,\n+};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::{respan, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n \n-pub(super) type Expected = Option<&'static str>;\n+#[derive(PartialEq, Copy, Clone)]\n+pub enum Expected {\n+    ParameterName,\n+    ArgumentName,\n+    Identifier,\n+    BindingPattern,\n+}\n \n-/// `Expected` for function and lambda parameter patterns.\n-pub(super) const PARAM_EXPECTED: Expected = Some(\"parameter name\");\n+impl Expected {\n+    // FIXME(#100717): migrate users of this to proper localization\n+    fn to_string_or_fallback(expected: Option<Expected>) -> &'static str {\n+        match expected {\n+            Some(Expected::ParameterName) => \"parameter name\",\n+            Some(Expected::ArgumentName) => \"argument name\",\n+            Some(Expected::Identifier) => \"identifier\",\n+            Some(Expected::BindingPattern) => \"binding pattern\",\n+            None => \"pattern\",\n+        }\n+    }\n+}\n \n const WHILE_PARSING_OR_MSG: &str = \"while parsing this or-pattern starting here\";\n \n@@ -56,13 +80,19 @@ enum EatOrResult {\n     None,\n }\n \n+/// The syntax location of a given pattern. Used for diagnostics.\n+pub(super) enum PatternLocation {\n+    LetBinding,\n+    FunctionParameter,\n+}\n+\n impl<'a> Parser<'a> {\n     /// Parses a pattern.\n     ///\n     /// Corresponds to `pat<no_top_alt>` in RFC 2535 and does not admit or-patterns\n     /// at the top level. Used when parsing the parameters of lambda expressions,\n     /// functions, function pointers, and `pat` macro fragments.\n-    pub fn parse_pat_no_top_alt(&mut self, expected: Expected) -> PResult<'a, P<Pat>> {\n+    pub fn parse_pat_no_top_alt(&mut self, expected: Option<Expected>) -> PResult<'a, P<Pat>> {\n         self.parse_pat_with_range_pat(true, expected)\n     }\n \n@@ -76,7 +106,7 @@ impl<'a> Parser<'a> {\n     /// simplify the grammar somewhat.\n     pub fn parse_pat_allow_top_alt(\n         &mut self,\n-        expected: Expected,\n+        expected: Option<Expected>,\n         rc: RecoverComma,\n         ra: RecoverColon,\n         rt: CommaRecoveryMode,\n@@ -88,7 +118,7 @@ impl<'a> Parser<'a> {\n     /// recovered).\n     fn parse_pat_allow_top_alt_inner(\n         &mut self,\n-        expected: Expected,\n+        expected: Option<Expected>,\n         rc: RecoverComma,\n         ra: RecoverColon,\n         rt: CommaRecoveryMode,\n@@ -168,9 +198,9 @@ impl<'a> Parser<'a> {\n     /// otherwise).\n     pub(super) fn parse_pat_before_ty(\n         &mut self,\n-        expected: Expected,\n+        expected: Option<Expected>,\n         rc: RecoverComma,\n-        syntax_loc: &str,\n+        syntax_loc: PatternLocation,\n     ) -> PResult<'a, (P<Pat>, bool)> {\n         // We use `parse_pat_allow_top_alt` regardless of whether we actually want top-level\n         // or-patterns so that we can detect when a user tries to use it. This allows us to print a\n@@ -184,27 +214,41 @@ impl<'a> Parser<'a> {\n         let colon = self.eat(&token::Colon);\n \n         if let PatKind::Or(pats) = &pat.kind {\n-            let msg = format!(\"top-level or-patterns are not allowed in {}\", syntax_loc);\n-            let (help, fix) = if pats.len() == 1 {\n-                // If all we have is a leading vert, then print a special message. This is the case\n-                // if `parse_pat_allow_top_alt` returns an or-pattern with one variant.\n-                let msg = \"remove the `|`\";\n-                let fix = pprust::pat_to_string(&pat);\n-                (msg, fix)\n-            } else {\n-                let msg = \"wrap the pattern in parentheses\";\n-                let fix = format!(\"({})\", pprust::pat_to_string(&pat));\n-                (msg, fix)\n-            };\n+            let span = pat.span;\n \n             if trailing_vert {\n                 // We already emitted an error and suggestion to remove the trailing vert. Don't\n                 // emit again.\n-                self.sess.span_diagnostic.delay_span_bug(pat.span, &msg);\n+\n+                // FIXME(#100717): pass `TopLevelOrPatternNotAllowed::* { sub: None }` to\n+                // `delay_span_bug()` instead of fluent message\n+                self.sess.span_diagnostic.delay_span_bug(\n+                    span,\n+                    match syntax_loc {\n+                        PatternLocation::LetBinding => {\n+                            fluent::parse_or_pattern_not_allowed_in_let_binding\n+                        }\n+                        PatternLocation::FunctionParameter => {\n+                            fluent::parse_or_pattern_not_allowed_in_fn_parameters\n+                        }\n+                    },\n+                );\n             } else {\n-                self.struct_span_err(pat.span, &msg)\n-                    .span_suggestion(pat.span, help, fix, Applicability::MachineApplicable)\n-                    .emit();\n+                let pat = pprust::pat_to_string(&pat);\n+                let sub = if pats.len() == 1 {\n+                    Some(TopLevelOrPatternNotAllowedSugg::RemoveLeadingVert { span, pat })\n+                } else {\n+                    Some(TopLevelOrPatternNotAllowedSugg::WrapInParens { span, pat })\n+                };\n+\n+                self.sess.emit_err(match syntax_loc {\n+                    PatternLocation::LetBinding => {\n+                        TopLevelOrPatternNotAllowed::LetBinding { span, sub }\n+                    }\n+                    PatternLocation::FunctionParameter => {\n+                        TopLevelOrPatternNotAllowed::FunctionParameter { span, sub }\n+                    }\n+                });\n             }\n         }\n \n@@ -221,15 +265,15 @@ impl<'a> Parser<'a> {\n         // a leading `||` probably doesn't indicate an or-pattern attempt, so we handle that\n         // separately.\n         if let token::OrOr = self.token.kind {\n-            let span = self.token.span;\n-            let mut err = self.struct_span_err(span, \"unexpected `||` before function parameter\");\n-            err.span_suggestion(span, \"remove the `||`\", \"\", Applicability::MachineApplicable);\n-            err.note(\"alternatives in or-patterns are separated with `|`, not `||`\");\n-            err.emit();\n+            self.sess.emit_err(UnexpectedVertVertBeforeFunctionParam { span: self.token.span });\n             self.bump();\n         }\n \n-        self.parse_pat_before_ty(PARAM_EXPECTED, RecoverComma::No, \"function parameters\")\n+        self.parse_pat_before_ty(\n+            Some(Expected::ParameterName),\n+            RecoverComma::No,\n+            PatternLocation::FunctionParameter,\n+        )\n     }\n \n     /// Eat the or-pattern `|` separator.\n@@ -239,7 +283,7 @@ impl<'a> Parser<'a> {\n             EatOrResult::TrailingVert\n         } else if matches!(self.token.kind, token::OrOr) {\n             // Found `||`; Recover and pretend we parsed `|`.\n-            self.ban_unexpected_or_or(lo);\n+            self.sess.emit_err(UnexpectedVertVertInPattern { span: self.token.span, start: lo });\n             self.bump();\n             EatOrResult::AteOr\n         } else if self.eat(&token::BinOp(token::Or)) {\n@@ -273,54 +317,26 @@ impl<'a> Parser<'a> {\n         });\n         match (is_end_ahead, &self.token.kind) {\n             (true, token::BinOp(token::Or) | token::OrOr) => {\n-                self.ban_illegal_vert(lo, \"trailing\", \"not allowed in an or-pattern\");\n+                // A `|` or possibly `||` token shouldn't be here. Ban it.\n+                self.sess.emit_err(TrailingVertNotAllowed {\n+                    span: self.token.span,\n+                    start: lo,\n+                    token: self.token.clone(),\n+                    note_double_vert: matches!(self.token.kind, token::OrOr).then_some(()),\n+                });\n                 self.bump();\n                 true\n             }\n             _ => false,\n         }\n     }\n \n-    /// We have parsed `||` instead of `|`. Error and suggest `|` instead.\n-    fn ban_unexpected_or_or(&mut self, lo: Option<Span>) {\n-        let mut err = self.struct_span_err(self.token.span, \"unexpected token `||` in pattern\");\n-        err.span_suggestion(\n-            self.token.span,\n-            \"use a single `|` to separate multiple alternative patterns\",\n-            \"|\",\n-            Applicability::MachineApplicable,\n-        );\n-        if let Some(lo) = lo {\n-            err.span_label(lo, WHILE_PARSING_OR_MSG);\n-        }\n-        err.emit();\n-    }\n-\n-    /// A `|` or possibly `||` token shouldn't be here. Ban it.\n-    fn ban_illegal_vert(&mut self, lo: Option<Span>, pos: &str, ctx: &str) {\n-        let span = self.token.span;\n-        let mut err = self.struct_span_err(span, &format!(\"a {} `|` is {}\", pos, ctx));\n-        err.span_suggestion(\n-            span,\n-            &format!(\"remove the `{}`\", pprust::token_to_string(&self.token)),\n-            \"\",\n-            Applicability::MachineApplicable,\n-        );\n-        if let Some(lo) = lo {\n-            err.span_label(lo, WHILE_PARSING_OR_MSG);\n-        }\n-        if let token::OrOr = self.token.kind {\n-            err.note(\"alternatives in or-patterns are separated with `|`, not `||`\");\n-        }\n-        err.emit();\n-    }\n-\n     /// Parses a pattern, with a setting whether modern range patterns (e.g., `a..=b`, `a..b` are\n     /// allowed).\n     fn parse_pat_with_range_pat(\n         &mut self,\n         allow_range_pat: bool,\n-        expected: Expected,\n+        expected: Option<Expected>,\n     ) -> PResult<'a, P<Pat>> {\n         maybe_recover_from_interpolated_ty_qpath!(self, true);\n         maybe_whole!(self, NtPat, |x| x);\n@@ -416,7 +432,7 @@ impl<'a> Parser<'a> {\n             let lt = self.expect_lifetime();\n             let (lit, _) =\n                 self.recover_unclosed_char(lt.ident, Parser::mk_token_lit_char, |self_| {\n-                    let expected = expected.unwrap_or(\"pattern\");\n+                    let expected = Expected::to_string_or_fallback(expected);\n                     let msg = format!(\n                         \"expected {}, found {}\",\n                         expected,\n@@ -457,15 +473,7 @@ impl<'a> Parser<'a> {\n         self.bump(); // `...`\n \n         // The user probably mistook `...` for a rest pattern `..`.\n-        self.struct_span_err(lo, \"unexpected `...`\")\n-            .span_label(lo, \"not a valid pattern\")\n-            .span_suggestion_short(\n-                lo,\n-                \"for a rest pattern, use `..` instead of `...`\",\n-                \"..\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(DotDotDotRestPattern { span: lo });\n         PatKind::Rest\n     }\n \n@@ -490,7 +498,7 @@ impl<'a> Parser<'a> {\n         // At this point we attempt to parse `@ $pat_rhs` and emit an error.\n         self.bump(); // `@`\n         let mut rhs = self.parse_pat_no_top_alt(None)?;\n-        let sp = lhs.span.to(rhs.span);\n+        let whole_span = lhs.span.to(rhs.span);\n \n         if let PatKind::Ident(_, _, sub @ None) = &mut rhs.kind {\n             // The user inverted the order, so help them fix that.\n@@ -499,27 +507,23 @@ impl<'a> Parser<'a> {\n             // The RHS is now the full pattern.\n             *sub = Some(lhs);\n \n-            self.struct_span_err(sp, \"pattern on wrong side of `@`\")\n-                .span_label(lhs_span, \"pattern on the left, should be on the right\")\n-                .span_label(rhs.span, \"binding on the right, should be on the left\")\n-                .span_suggestion(\n-                    sp,\n-                    \"switch the order\",\n-                    pprust::pat_to_string(&rhs),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(PatternOnWrongSideOfAt {\n+                whole_span,\n+                whole_pat: pprust::pat_to_string(&rhs),\n+                pattern: lhs_span,\n+                binding: rhs.span,\n+            });\n         } else {\n             // The special case above doesn't apply so we may have e.g. `A(x) @ B(y)`.\n             rhs.kind = PatKind::Wild;\n-            self.struct_span_err(sp, \"left-hand side of `@` must be a binding\")\n-                .span_label(lhs.span, \"interpreted as a pattern, not a binding\")\n-                .span_label(rhs.span, \"also a pattern\")\n-                .note(\"bindings are `x`, `mut x`, `ref x`, and `ref mut x`\")\n-                .emit();\n+            self.sess.emit_err(ExpectedBindingLeftOfAt {\n+                whole_span,\n+                lhs: lhs.span,\n+                rhs: rhs.span,\n+            });\n         }\n \n-        rhs.span = sp;\n+        rhs.span = whole_span;\n         Ok(rhs)\n     }\n \n@@ -534,35 +538,23 @@ impl<'a> Parser<'a> {\n             _ => return,\n         }\n \n-        self.struct_span_err(pat.span, \"the range pattern here has ambiguous interpretation\")\n-            .span_suggestion(\n-                pat.span,\n-                \"add parentheses to clarify the precedence\",\n-                format!(\"({})\", pprust::pat_to_string(&pat)),\n-                // \"ambiguous interpretation\" implies that we have to be guessing\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+        self.sess\n+            .emit_err(AmbiguousRangePattern { span: pat.span, pat: pprust::pat_to_string(&pat) });\n     }\n \n     /// Parse `&pat` / `&mut pat`.\n-    fn parse_pat_deref(&mut self, expected: Expected) -> PResult<'a, PatKind> {\n+    fn parse_pat_deref(&mut self, expected: Option<Expected>) -> PResult<'a, PatKind> {\n         self.expect_and()?;\n-        self.recover_lifetime_in_deref_pat();\n-        let mutbl = self.parse_mutability();\n-        let subpat = self.parse_pat_with_range_pat(false, expected)?;\n-        Ok(PatKind::Ref(subpat, mutbl))\n-    }\n-\n-    fn recover_lifetime_in_deref_pat(&mut self) {\n         if let token::Lifetime(name) = self.token.kind {\n             self.bump(); // `'a`\n \n-            let span = self.prev_token.span;\n-            self.struct_span_err(span, &format!(\"unexpected lifetime `{}` in pattern\", name))\n-                .span_suggestion(span, \"remove the lifetime\", \"\", Applicability::MachineApplicable)\n-                .emit();\n+            self.sess\n+                .emit_err(UnexpectedLifetimeInPattern { span: self.prev_token.span, symbol: name });\n         }\n+\n+        let mutbl = self.parse_mutability();\n+        let subpat = self.parse_pat_with_range_pat(false, expected)?;\n+        Ok(PatKind::Ref(subpat, mutbl))\n     }\n \n     /// Parse a tuple or parenthesis pattern.\n@@ -590,7 +582,8 @@ impl<'a> Parser<'a> {\n         let mut_span = self.prev_token.span;\n \n         if self.eat_keyword(kw::Ref) {\n-            return self.recover_mut_ref_ident(mut_span);\n+            self.sess.emit_err(RefMutOrderIncorrect { span: mut_span.to(self.prev_token.span) });\n+            return self.parse_pat_ident(BindingAnnotation::REF_MUT);\n         }\n \n         self.recover_additional_muts();\n@@ -603,7 +596,7 @@ impl<'a> Parser<'a> {\n         }\n \n         // Parse the pattern we hope to be an identifier.\n-        let mut pat = self.parse_pat_no_top_alt(Some(\"identifier\"))?;\n+        let mut pat = self.parse_pat_no_top_alt(Some(Expected::Identifier))?;\n \n         // If we don't have `mut $ident (@ pat)?`, error.\n         if let PatKind::Ident(BindingAnnotation(ByRef::No, m @ Mutability::Not), ..) = &mut pat.kind\n@@ -620,22 +613,6 @@ impl<'a> Parser<'a> {\n         Ok(pat.into_inner().kind)\n     }\n \n-    /// Recover on `mut ref? ident @ pat` and suggest\n-    /// that the order of `mut` and `ref` is incorrect.\n-    fn recover_mut_ref_ident(&mut self, lo: Span) -> PResult<'a, PatKind> {\n-        let mutref_span = lo.to(self.prev_token.span);\n-        self.struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n-            .span_suggestion(\n-                mutref_span,\n-                \"try switching the order\",\n-                \"ref mut\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n-\n-        self.parse_pat_ident(BindingAnnotation::REF_MUT)\n-    }\n-\n     /// Turn all by-value immutable bindings in a pattern into mutable bindings.\n     /// Returns `true` if any change was made.\n     fn make_all_value_bindings_mutable(pat: &mut P<Pat>) -> bool {\n@@ -660,16 +637,13 @@ impl<'a> Parser<'a> {\n     /// Error on `mut $pat` where `$pat` is not an ident.\n     fn ban_mut_general_pat(&self, lo: Span, pat: &Pat, changed_any_binding: bool) {\n         let span = lo.to(pat.span);\n-        let fix = pprust::pat_to_string(&pat);\n-        let (problem, suggestion) = if changed_any_binding {\n-            (\"`mut` must be attached to each individual binding\", \"add `mut` to each binding\")\n+        let pat = pprust::pat_to_string(&pat);\n+\n+        self.sess.emit_err(if changed_any_binding {\n+            InvalidMutInPattern::NestedIdent { span, pat }\n         } else {\n-            (\"`mut` must be followed by a named binding\", \"remove the `mut` prefix\")\n-        };\n-        self.struct_span_err(span, problem)\n-            .span_suggestion(span, suggestion, fix, Applicability::MachineApplicable)\n-            .note(\"`mut` may be followed by `variable` and `variable @ pattern`\")\n-            .emit();\n+            InvalidMutInPattern::NonIdent { span, pat }\n+        });\n     }\n \n     /// Eat any extraneous `mut`s and error + recover if we ate any.\n@@ -680,15 +654,7 @@ impl<'a> Parser<'a> {\n             return;\n         }\n \n-        let span = lo.to(self.prev_token.span);\n-        self.struct_span_err(span, \"`mut` on a binding may not be repeated\")\n-            .span_suggestion(\n-                span,\n-                \"remove the additional `mut`s\",\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(RepeatedMutInPattern { span: lo.to(self.prev_token.span) });\n     }\n \n     /// Parse macro invocation\n@@ -702,11 +668,11 @@ impl<'a> Parser<'a> {\n     fn fatal_unexpected_non_pat(\n         &mut self,\n         err: DiagnosticBuilder<'a, ErrorGuaranteed>,\n-        expected: Expected,\n+        expected: Option<Expected>,\n     ) -> PResult<'a, P<Pat>> {\n         err.cancel();\n \n-        let expected = expected.unwrap_or(\"pattern\");\n+        let expected = Expected::to_string_or_fallback(expected);\n         let msg = format!(\"expected {}, found {}\", expected, super::token_descr(&self.token));\n \n         let mut err = self.struct_span_err(self.token.span, &msg);\n@@ -774,28 +740,18 @@ impl<'a> Parser<'a> {\n                     let _ = self.parse_pat_range_end().map_err(|e| e.cancel());\n                 }\n \n-                self.error_inclusive_range_with_extra_equals(span_with_eq);\n+                self.sess.emit_err(InclusiveRangeExtraEquals { span: span_with_eq });\n             }\n             token::Gt if no_space => {\n-                self.error_inclusive_range_match_arrow(span);\n+                let after_pat = span.with_hi(span.hi() - rustc_span::BytePos(1)).shrink_to_hi();\n+                self.sess.emit_err(InclusiveRangeMatchArrow { span, after_pat });\n+            }\n+            _ => {\n+                self.sess.emit_err(InclusiveRangeNoEnd { span });\n             }\n-            _ => self.error_inclusive_range_with_no_end(span),\n         }\n     }\n \n-    fn error_inclusive_range_with_extra_equals(&self, span: Span) {\n-        self.sess.emit_err(InclusiveRangeExtraEquals { span });\n-    }\n-\n-    fn error_inclusive_range_match_arrow(&self, span: Span) {\n-        let after_pat = span.with_hi(span.hi() - rustc_span::BytePos(1)).shrink_to_hi();\n-        self.sess.emit_err(InclusiveRangeMatchArrow { span, after_pat });\n-    }\n-\n-    fn error_inclusive_range_with_no_end(&self, span: Span) {\n-        self.sess.emit_err(InclusiveRangeNoEnd { span });\n-    }\n-\n     /// Parse a range-to pattern, `..X` or `..=X` where `X` remains to be parsed.\n     ///\n     /// The form `...X` is prohibited to reduce confusion with the potential\n@@ -804,14 +760,7 @@ impl<'a> Parser<'a> {\n         let end = self.parse_pat_range_end()?;\n         if let RangeEnd::Included(syn @ RangeSyntax::DotDotDot) = &mut re.node {\n             *syn = RangeSyntax::DotDotEq;\n-            self.struct_span_err(re.span, \"range-to patterns with `...` are not allowed\")\n-                .span_suggestion_short(\n-                    re.span,\n-                    \"use `..=` instead\",\n-                    \"..=\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(DotDotDotRangeToPatternNotAllowed { span: re.span });\n         }\n         Ok(PatKind::Range(None, Some(end), re))\n     }\n@@ -876,7 +825,7 @@ impl<'a> Parser<'a> {\n     fn parse_pat_ident(&mut self, binding_annotation: BindingAnnotation) -> PResult<'a, PatKind> {\n         let ident = self.parse_ident()?;\n         let sub = if self.eat(&token::At) {\n-            Some(self.parse_pat_no_top_alt(Some(\"binding pattern\"))?)\n+            Some(self.parse_pat_no_top_alt(Some(Expected::BindingPattern))?)\n         } else {\n             None\n         };\n@@ -887,8 +836,8 @@ impl<'a> Parser<'a> {\n         // binding mode then we do not end up here, because the lookahead\n         // will direct us over to `parse_enum_variant()`.\n         if self.token == token::OpenDelim(Delimiter::Parenthesis) {\n-            return Err(self\n-                .struct_span_err(self.prev_token.span, \"expected identifier, found enum pattern\"));\n+            return Err(EnumPatternInsteadOfIdentifier { span: self.prev_token.span }\n+                .into_diagnostic(&self.sess.span_diagnostic));\n         }\n \n         Ok(PatKind::Ident(binding_annotation, ident, sub))\n@@ -970,7 +919,7 @@ impl<'a> Parser<'a> {\n             // We cannot use `parse_pat_ident()` since it will complain `box`\n             // is not an identifier.\n             let sub = if self.eat(&token::At) {\n-                Some(self.parse_pat_no_top_alt(Some(\"binding pattern\"))?)\n+                Some(self.parse_pat_no_top_alt(Some(Expected::BindingPattern))?)\n             } else {\n                 None\n             };\n@@ -1005,7 +954,8 @@ impl<'a> Parser<'a> {\n \n             // check that a comma comes after every field\n             if !ate_comma {\n-                let err = self.struct_span_err(self.token.span, \"expected `,`\");\n+                let err = ExpectedCommaAfterPatternField { span: self.token.span }\n+                    .into_diagnostic(&self.sess.span_diagnostic);\n                 if let Some(mut delayed) = delayed_err {\n                     delayed.emit();\n                 }\n@@ -1118,14 +1068,7 @@ impl<'a> Parser<'a> {\n             return;\n         }\n \n-        self.struct_span_err(self.token.span, \"expected field pattern, found `...`\")\n-            .span_suggestion(\n-                self.token.span,\n-                \"to omit remaining fields, use one fewer `.`\",\n-                \"..\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(DotDotDotForRemainingFields { span: self.token.span });\n     }\n \n     fn parse_pat_field(&mut self, lo: Span, attrs: AttrVec) -> PResult<'a, PatField> {"}, {"sha": "647639b9b62b4244b5918205448b01f7ba8ef94d", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -1,7 +1,7 @@\n use super::attr::InnerAttrForbiddenReason;\n use super::diagnostics::AttemptLocalParseRecovery;\n use super::expr::LhsExpr;\n-use super::pat::RecoverComma;\n+use super::pat::{PatternLocation, RecoverComma};\n use super::path::PathStyle;\n use super::TrailingToken;\n use super::{\n@@ -275,7 +275,8 @@ impl<'a> Parser<'a> {\n         }\n \n         self.report_invalid_identifier_error()?;\n-        let (pat, colon) = self.parse_pat_before_ty(None, RecoverComma::Yes, \"`let` bindings\")?;\n+        let (pat, colon) =\n+            self.parse_pat_before_ty(None, RecoverComma::Yes, PatternLocation::LetBinding)?;\n \n         let (err, ty) = if colon {\n             // Save the state of the parser before parsing type normally, in case there is a `:`"}, {"sha": "306cbcff149f7d5327c66e9cc397142811ad6281", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 38, "deletions": 85, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -1,6 +1,12 @@\n use super::{Parser, PathStyle, TokenType};\n \n-use crate::errors::{ExpectedFnPathFoundFnKeyword, FnPtrWithGenerics, FnPtrWithGenericsSugg};\n+use crate::errors::{\n+    DynAfterMut, ExpectedFnPathFoundFnKeyword, ExpectedMutOrConstInRawPointerType,\n+    FnPointerCannotBeAsync, FnPointerCannotBeConst, FnPtrWithGenerics, FnPtrWithGenericsSugg,\n+    InvalidDynKeyword, LifetimeAfterMut, NeedPlusAfterTraitObjectLifetime,\n+    NegativeBoundsNotSupported, NegativeBoundsNotSupportedSugg, NestedCVariadicType,\n+    ReturnTypesUseThinArrow,\n+};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n \n use ast::DUMMY_NODE_ID;\n@@ -12,7 +18,7 @@ use rustc_ast::{\n     MacCall, MutTy, Mutability, PolyTraitRef, TraitBoundModifier, TraitObjectSyntax, Ty, TyKind,\n };\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, PResult};\n+use rustc_errors::{Applicability, PResult};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n@@ -233,14 +239,7 @@ impl<'a> Parser<'a> {\n             // Don't `eat` to prevent `=>` from being added as an expected token which isn't\n             // actually expected and could only confuse users\n             self.bump();\n-            self.struct_span_err(self.prev_token.span, \"return types are denoted using `->`\")\n-                .span_suggestion_short(\n-                    self.prev_token.span,\n-                    \"use `->` instead\",\n-                    \"->\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(ReturnTypesUseThinArrow { span: self.prev_token.span });\n             let ty = self.parse_ty_common(\n                 allow_plus,\n                 AllowCVariadic::No,\n@@ -328,7 +327,7 @@ impl<'a> Parser<'a> {\n                 AllowCVariadic::No => {\n                     // FIXME(Centril): Should we just allow `...` syntactically\n                     // anywhere in a type and use semantic restrictions instead?\n-                    self.error_illegal_c_varadic_ty(lo);\n+                    self.sess.emit_err(NestedCVariadicType { span: lo.to(self.prev_token.span) });\n                     TyKind::Err\n                 }\n             }\n@@ -431,8 +430,7 @@ impl<'a> Parser<'a> {\n         let lt_no_plus = self.check_lifetime() && !self.look_ahead(1, |t| t.is_like_plus());\n         let bounds = self.parse_generic_bounds_common(allow_plus, None)?;\n         if lt_no_plus {\n-            self.struct_span_err(lo, \"lifetime in trait object type must be followed by `+`\")\n-                .emit();\n+            self.sess.emit_err(NeedPlusAfterTraitObjectLifetime { span: lo });\n         }\n         Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n     }\n@@ -466,14 +464,10 @@ impl<'a> Parser<'a> {\n     fn parse_ty_ptr(&mut self) -> PResult<'a, TyKind> {\n         let mutbl = self.parse_const_or_mut().unwrap_or_else(|| {\n             let span = self.prev_token.span;\n-            self.struct_span_err(span, \"expected `mut` or `const` keyword in raw pointer type\")\n-                .span_suggestions(\n-                    span.shrink_to_hi(),\n-                    \"add `mut` or `const` here\",\n-                    [\"mut \".to_string(), \"const \".to_string()],\n-                    Applicability::HasPlaceholders,\n-                )\n-                .emit();\n+            self.sess.emit_err(ExpectedMutOrConstInRawPointerType {\n+                span,\n+                after_asterisk: span.shrink_to_hi(),\n+            });\n             Mutability::Not\n         });\n         let ty = self.parse_ty_no_plus()?;\n@@ -528,16 +522,13 @@ impl<'a> Parser<'a> {\n                 let lifetime_span = self.token.span;\n                 let span = and_span.to(lifetime_span);\n \n-                let mut err = self.struct_span_err(span, \"lifetime must precede `mut`\");\n-                if let Ok(lifetime_src) = self.span_to_snippet(lifetime_span) {\n-                    err.span_suggestion(\n-                        span,\n-                        \"place the lifetime before `mut`\",\n-                        format!(\"&{} mut\", lifetime_src),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                err.emit();\n+                let (suggest_lifetime, snippet) =\n+                    if let Ok(lifetime_src) = self.span_to_snippet(lifetime_span) {\n+                        (Some(span), lifetime_src)\n+                    } else {\n+                        (None, String::new())\n+                    };\n+                self.sess.emit_err(LifetimeAfterMut { span, suggest_lifetime, snippet });\n \n                 opt_lifetime = Some(self.expect_lifetime());\n             }\n@@ -547,14 +538,7 @@ impl<'a> Parser<'a> {\n         {\n             // We have `&dyn mut ...`, which is invalid and should be `&mut dyn ...`.\n             let span = and_span.to(self.look_ahead(1, |t| t.span));\n-            let mut err = self.struct_span_err(span, \"`mut` must precede `dyn`\");\n-            err.span_suggestion(\n-                span,\n-                \"place `mut` before `dyn`\",\n-                \"&mut dyn\",\n-                Applicability::MachineApplicable,\n-            );\n-            err.emit();\n+            self.sess.emit_err(DynAfterMut { span });\n \n             // Recovery\n             mutbl = Mutability::Mut;\n@@ -608,10 +592,10 @@ impl<'a> Parser<'a> {\n             // If we ever start to allow `const fn()`, then update\n             // feature gating for `#![feature(const_extern_fn)]` to\n             // cover it.\n-            self.error_fn_ptr_bad_qualifier(whole_span, span, \"const\");\n+            self.sess.emit_err(FnPointerCannotBeConst { span: whole_span, qualifier: span });\n         }\n         if let ast::Async::Yes { span, .. } = asyncness {\n-            self.error_fn_ptr_bad_qualifier(whole_span, span, \"async\");\n+            self.sess.emit_err(FnPointerCannotBeAsync { span: whole_span, qualifier: span });\n         }\n         let decl_span = span_start.to(self.token.span);\n         Ok(TyKind::BareFn(P(BareFnTy { ext, unsafety, generic_params: params, decl, decl_span })))\n@@ -659,19 +643,6 @@ impl<'a> Parser<'a> {\n         Ok(())\n     }\n \n-    /// Emit an error for the given bad function pointer qualifier.\n-    fn error_fn_ptr_bad_qualifier(&self, span: Span, qual_span: Span, qual: &str) {\n-        self.struct_span_err(span, &format!(\"an `fn` pointer type cannot be `{}`\", qual))\n-            .span_label(qual_span, format!(\"`{}` because of this\", qual))\n-            .span_suggestion_short(\n-                qual_span,\n-                &format!(\"remove the `{}` qualifier\", qual),\n-                \"\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n-    }\n-\n     /// Parses an `impl B0 + ... + Bn` type.\n     fn parse_impl_ty(&mut self, impl_dyn_multi: &mut bool) -> PResult<'a, TyKind> {\n         // Always parse bounds greedily for better error recovery.\n@@ -758,16 +729,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn error_illegal_c_varadic_ty(&self, lo: Span) {\n-        struct_span_err!(\n-            self.sess.span_diagnostic,\n-            lo.to(self.prev_token.span),\n-            E0743,\n-            \"C-variadic type `...` may not be nested inside another type\",\n-        )\n-        .emit();\n-    }\n-\n     pub(super) fn parse_generic_bounds(\n         &mut self,\n         colon_span: Option<Span>,\n@@ -797,15 +758,7 @@ impl<'a> Parser<'a> {\n         {\n             if self.token.is_keyword(kw::Dyn) {\n                 // Account for `&dyn Trait + dyn Other`.\n-                self.struct_span_err(self.token.span, \"invalid `dyn` keyword\")\n-                    .help(\"`dyn` is only needed at the start of a trait `+`-separated list\")\n-                    .span_suggestion(\n-                        self.token.span,\n-                        \"remove this keyword\",\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                self.sess.emit_err(InvalidDynKeyword { span: self.token.span });\n                 self.bump();\n             }\n             match self.parse_generic_bound()? {\n@@ -842,11 +795,7 @@ impl<'a> Parser<'a> {\n         bounds: &[GenericBound],\n         negative_bounds: Vec<Span>,\n     ) {\n-        let negative_bounds_len = negative_bounds.len();\n-        let last_span = *negative_bounds.last().expect(\"no negative bounds, but still error?\");\n-        let mut err = self.struct_span_err(negative_bounds, \"negative bounds are not supported\");\n-        err.span_label(last_span, \"negative bounds are not supported\");\n-        if let Some(bound_list) = colon_span {\n+        let sub = if let Some(bound_list) = colon_span {\n             let bound_list = bound_list.to(self.prev_token.span);\n             let mut new_bound_list = String::new();\n             if !bounds.is_empty() {\n@@ -857,14 +806,18 @@ impl<'a> Parser<'a> {\n                 }\n                 new_bound_list = new_bound_list.replacen(\" +\", \":\", 1);\n             }\n-            err.tool_only_span_suggestion(\n+\n+            Some(NegativeBoundsNotSupportedSugg {\n                 bound_list,\n-                &format!(\"remove the bound{}\", pluralize!(negative_bounds_len)),\n-                new_bound_list,\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-        err.emit();\n+                num_bounds: negative_bounds.len(),\n+                fixed: new_bound_list,\n+            })\n+        } else {\n+            None\n+        };\n+\n+        let last_span = *negative_bounds.last().expect(\"no negative bounds, but still error?\");\n+        self.sess.emit_err(NegativeBoundsNotSupported { negative_bounds, last_span, sub });\n     }\n \n     /// Parses a bound according to the grammar:"}, {"sha": "644d701be0caa79ddcbfcb7e04bcc321309db8de", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -174,6 +174,9 @@ impl CheckAttrVisitor<'_> {\n                 sym::rustc_has_incoherent_inherent_impls => {\n                     self.check_has_incoherent_inherent_impls(&attr, span, target)\n                 }\n+                sym::ffi_pure => self.check_ffi_pure(attr.span, attrs, target),\n+                sym::ffi_const => self.check_ffi_const(attr.span, target),\n+                sym::ffi_returns_twice => self.check_ffi_returns_twice(attr.span, target),\n                 sym::rustc_const_unstable\n                 | sym::rustc_const_stable\n                 | sym::unstable\n@@ -1213,6 +1216,38 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n+    fn check_ffi_pure(&self, attr_span: Span, attrs: &[Attribute], target: Target) -> bool {\n+        if target != Target::ForeignFn {\n+            self.tcx.sess.emit_err(errors::FfiPureInvalidTarget { attr_span });\n+            return false;\n+        }\n+        if attrs.iter().any(|a| a.has_name(sym::ffi_const)) {\n+            // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n+            self.tcx.sess.emit_err(errors::BothFfiConstAndPure { attr_span });\n+            false\n+        } else {\n+            true\n+        }\n+    }\n+\n+    fn check_ffi_const(&self, attr_span: Span, target: Target) -> bool {\n+        if target == Target::ForeignFn {\n+            true\n+        } else {\n+            self.tcx.sess.emit_err(errors::FfiConstInvalidTarget { attr_span });\n+            false\n+        }\n+    }\n+\n+    fn check_ffi_returns_twice(&self, attr_span: Span, target: Target) -> bool {\n+        if target == Target::ForeignFn {\n+            true\n+        } else {\n+            self.tcx.sess.emit_err(errors::FfiReturnsTwiceInvalidTarget { attr_span });\n+            false\n+        }\n+    }\n+\n     /// Warns against some misuses of `#[must_use]`\n     fn check_must_use(&self, hir_id: HirId, attr: &Attribute, target: Target) -> bool {\n         if !matches!("}, {"sha": "68b098e3457b7b77fd6c1d455aef2065cbf121a2", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -348,6 +348,34 @@ pub struct HasIncoherentInherentImpl {\n     pub span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(passes_both_ffi_const_and_pure, code = \"E0757\")]\n+pub struct BothFfiConstAndPure {\n+    #[primary_span]\n+    pub attr_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes_ffi_pure_invalid_target, code = \"E0755\")]\n+pub struct FfiPureInvalidTarget {\n+    #[primary_span]\n+    pub attr_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes_ffi_const_invalid_target, code = \"E0756\")]\n+pub struct FfiConstInvalidTarget {\n+    #[primary_span]\n+    pub attr_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes_ffi_returns_twice_invalid_target, code = \"E0724\")]\n+pub struct FfiReturnsTwiceInvalidTarget {\n+    #[primary_span]\n+    pub attr_span: Span,\n+}\n+\n #[derive(LintDiagnostic)]\n #[diag(passes_must_use_async)]\n pub struct MustUseAsync {"}, {"sha": "2b135b6703481821fddd80ceabb5c93d863c0d0b", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios_macabi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -2,7 +2,7 @@ use super::apple_base::{opts, Arch};\n use crate::spec::{Cc, FramePointer, LinkerFlavor, Lld, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let llvm_target = \"arm64-apple-ios14.0-macabi\";\n+    let llvm_target = \"arm64-apple-ios-macabi\";\n \n     let arch = Arch::Arm64_macabi;\n     let mut base = opts(\"ios\", arch);\n@@ -22,7 +22,7 @@ pub fn target() -> Target {\n             // These arguments are not actually invoked - they just have\n             // to look right to pass App Store validation.\n             bitcode_llvm_cmdline: \"-triple\\0\\\n-                arm64-apple-ios14.0-macabi\\0\\\n+                arm64-apple-ios-macabi\\0\\\n                 -emit-obj\\0\\\n                 -disable-llvm-passes\\0\\\n                 -Os\\0\""}, {"sha": "5a3e2a79bb9cc326d3b84f284c9d6aedc8e85910", "filename": "compiler/rustc_target/src/spec/x86_64_apple_ios_macabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -2,7 +2,7 @@ use super::apple_base::{opts, Arch};\n use crate::spec::{Cc, LinkerFlavor, Lld, StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let llvm_target = \"x86_64-apple-ios13.0-macabi\";\n+    let llvm_target = \"x86_64-apple-ios-macabi\";\n \n     let arch = Arch::X86_64_macabi;\n     let mut base = opts(\"ios\", arch);"}, {"sha": "8ff6e3ba4e801886ef9243957389c6f24d8474a6", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -77,7 +77,7 @@ x--expand-yaml-anchors--remove:\n     <<: *base-job\n \n   - &job-macos-xl\n-    os: macos-12-xl\n+    os: macos-latest  # We don't have an XL builder for this\n     <<: *base-job\n \n   - &job-windows-xl"}, {"sha": "4ab1c36f976525dfcfb3a44e568d11305b8e6efd", "filename": "src/doc/style-guide/src/statements.md", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fstatements.md", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fstatements.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fstatements.md?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -99,6 +99,84 @@ let Foo {\n );\n ```\n \n+#### else blocks (let-else statements)\n+\n+If a let statement contains an `else` component, also known as a let-else statement,\n+then the `else` component should be formatted according to the same rules as the `else` block\n+in [control flow expressions (i.e. if-else, and if-let-else expressions)](./expressions.md#control-flow-expressions).\n+Apply the same formatting rules to the components preceding\n+the `else` block (i.e. the `let pattern: Type = initializer_expr ...` portion)\n+as described [above](#let-statements)\n+\n+Similarly to if-else expressions, if the initializer\n+expression is multi-lined, then the `else` keyword and opening brace of the block (i.e. `else {`)\n+should be put on the same line as the end of the initializer\n+expression with a preceding space if all the following are true:\n+\n+* The initializer expression ends with one or more closing\n+  parentheses, square brackets, and/or braces\n+* There is nothing else on that line\n+* That line is not indented beyond the indent of the first line containing the `let` keyword\n+\n+For example:\n+\n+```rust\n+let Some(x) = y.foo(\n+    \"abc\",\n+    fairly_long_identifier,\n+    \"def\",\n+    \"123456\",\n+    \"string\",\n+    \"cheese\",\n+) else {\n+    bar()\n+}\n+```\n+\n+Otherwise, the `else` keyword and opening brace should be placed on the next line after the end of the initializer expression, and should not be indented (the `else` keyword should be aligned with the `let` keyword).\n+\n+For example:\n+\n+```rust\n+let Some(x) = abcdef()\n+    .foo(\n+        \"abc\",\n+        some_really_really_really_long_ident,\n+        \"ident\",\n+        \"123456\",\n+    )\n+    .bar()\n+    .baz()\n+    .qux(\"fffffffffffffffff\")\n+else {\n+    foo_bar()\n+}\n+```\n+\n+##### Single line let-else statements\n+\n+The entire let-else statement may be formatted on a single line if all the following are true:\n+\n+* the entire statement is *short*\n+* the `else` block contains a single-line expression and no statements\n+* the `else` block contains no comments\n+* the let statement components preceding the `else` block can be formatted on a single line\n+\n+```rust\n+let Some(1) = opt else { return };\n+\n+let Some(1) = opt else {\n+    return;\n+};\n+\n+let Some(1) = opt else {\n+    // nope\n+    return\n+};\n+```\n+\n+Formatters may allow users to configure the value of the threshold\n+used to determine whether a let-else statement is *short*.\n \n ### Macros in statement position\n "}, {"sha": "ee988090ca334e9ed2ea02dfebd308b43b113d5a", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -814,8 +814,11 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \tbackground-repeat: no-repeat;\n \tbackground-size: 20px;\n \tbackground-position: calc(100% - 2px) 56%;\n-\t/* image is black color */\n-\tbackground-image: url(\"down-arrow-927217e04c7463ac.svg\");\n+\t/* down arrow (image is black color) */\n+\tbackground-image: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" \\\n+\twidth=\"128\" height=\"128\" viewBox=\"-30 -20 176 176\"><path d=\"M111,40.5L64,87.499L17,40.5\" \\\n+\tfill=\"none\" stroke=\"black\" strike-linecap=\"square\" stroke-miterlimit=\"10\" stroke-width=\"12\"/> \\\n+\t</svg>');\n \t/* changes the arrow image color */\n \tfilter: var(--crate-search-div-filter);\n }\n@@ -1444,7 +1447,10 @@ details.toggle > summary.hideme > span {\n }\n \n details.toggle > summary::before {\n-\tbackground: url(\"toggle-plus-1092eb4930d581b0.svg\") no-repeat top left;\n+\t/* toggle plus */\n+\tbackground: url('data:image/svg+xml,<svg width=\"17\" height=\"17\" \\\n+shape-rendering=\"crispEdges\" stroke=\"black\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path \\\n+d=\"M5 2.5H2.5v12H5m7-12h2.5v12H12M5 8.5h7M8.5 12V8.625v0V5\"/></svg>') no-repeat top left;\n \tcontent: \"\";\n \tcursor: pointer;\n \twidth: 16px;\n@@ -1522,7 +1528,10 @@ details.toggle[open] > summary.hideme > span {\n }\n \n details.toggle[open] > summary::before {\n-\tbackground: url(\"toggle-minus-31bbd6e4c77f5c96.svg\") no-repeat top left;\n+\t/* toggle minus */\n+\tbackground: url('data:image/svg+xml,<svg width=\"17\" height=\"17\" \\\n+shape-rendering=\"crispEdges\" stroke=\"black\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path \\\n+d=\"M5 2.5H2.5v12H5m7-12h2.5v12H12M5 8.5h7\"/></svg>') no-repeat top left;\n }\n \n details.toggle[open] > summary::after {"}, {"sha": "5d76a64e92c70ea2bf86b5010406e641aa680e79", "filename": "src/librustdoc/html/static/images/down-arrow.svg", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff6fb4c33e8bd94b17a4715046b8266a1d42e793/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Fdown-arrow.svg", "raw_url": "https://github.com/rust-lang/rust/raw/ff6fb4c33e8bd94b17a4715046b8266a1d42e793/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Fdown-arrow.svg", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Fdown-arrow.svg?ref=ff6fb4c33e8bd94b17a4715046b8266a1d42e793", "patch": "@@ -1 +0,0 @@\n-<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" id=\"Layer_1\" width=\"128\" height=\"128\" enable-background=\"new 0 0 128 128\" version=\"1.1\" viewBox=\"-30 -20 176 176\" xml:space=\"preserve\"><g><line x1=\"111\" x2=\"64\" y1=\"40.5\" y2=\"87.499\" fill=\"none\" stroke=\"#000000\" stroke-linecap=\"square\" stroke-miterlimit=\"10\" stroke-width=\"12\"/><line x1=\"64\" x2=\"17\" y1=\"87.499\" y2=\"40.5\" fill=\"none\" stroke=\"#000000\" stroke-linecap=\"square\" stroke-miterlimit=\"10\" stroke-width=\"12\"/></g></svg>\n\\ No newline at end of file"}, {"sha": "73154788a0e8ed4563843abf5da671263aa9571a", "filename": "src/librustdoc/html/static/images/toggle-minus.svg", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff6fb4c33e8bd94b17a4715046b8266a1d42e793/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Ftoggle-minus.svg", "raw_url": "https://github.com/rust-lang/rust/raw/ff6fb4c33e8bd94b17a4715046b8266a1d42e793/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Ftoggle-minus.svg", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Ftoggle-minus.svg?ref=ff6fb4c33e8bd94b17a4715046b8266a1d42e793", "patch": "@@ -1 +0,0 @@\n-<svg width=\"17\" height=\"17\" shape-rendering=\"crispEdges\" stroke=\"#000\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5 2.5H2.5v12H5m7-12h2.5v12H12M5 8.5h7\"/></svg>\n\\ No newline at end of file"}, {"sha": "08b17033e164b15fb31decfbb5befc16209d697e", "filename": "src/librustdoc/html/static/images/toggle-plus.svg", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff6fb4c33e8bd94b17a4715046b8266a1d42e793/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Ftoggle-plus.svg", "raw_url": "https://github.com/rust-lang/rust/raw/ff6fb4c33e8bd94b17a4715046b8266a1d42e793/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Ftoggle-plus.svg", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Ftoggle-plus.svg?ref=ff6fb4c33e8bd94b17a4715046b8266a1d42e793", "patch": "@@ -1 +0,0 @@\n-<svg width=\"17\" height=\"17\" shape-rendering=\"crispEdges\" stroke=\"#000\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5 2.5H2.5v12H5m7-12h2.5v12H12M5 8.5h7M8.5 12V8.625v0V5\"/></svg>\n\\ No newline at end of file"}, {"sha": "767b974cc9109f6c0c35fecf71a1bff09dde17b9", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -102,9 +102,6 @@ static_files! {\n     scrape_examples_js => \"static/js/scrape-examples.js\",\n     wheel_svg => \"static/images/wheel.svg\",\n     clipboard_svg => \"static/images/clipboard.svg\",\n-    down_arrow_svg => \"static/images/down-arrow.svg\",\n-    toggle_minus_png => \"static/images/toggle-minus.svg\",\n-    toggle_plus_png => \"static/images/toggle-plus.svg\",\n     copyright => \"static/COPYRIGHT.txt\",\n     license_apache => \"static/LICENSE-APACHE.txt\",\n     license_mit => \"static/LICENSE-MIT.txt\","}, {"sha": "7c5c6eb3d2bbf1b5ee5b713763a09d05749240cc", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -222,7 +222,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n     fn after_krate(&mut self) -> Result<(), Error> {\n         debug!(\"Done with crate\");\n \n-        debug!(\"Adding Primitve impls\");\n+        debug!(\"Adding Primitive impls\");\n         for primitive in Rc::clone(&self.cache).primitive_locations.values() {\n             self.get_impls(*primitive);\n         }"}, {"sha": "07f95d13937b47d246017b1a0aa7f5f8f555b24d", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -799,3 +799,11 @@ struct SuggestionStyleGood {\n     #[suggestion(code = \"\", style = \"hidden\")]\n     sub: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest_example)]\n+struct SuggestionOnVec {\n+    #[suggestion(suggestion, code = \"\")]\n+    //~^ ERROR `#[suggestion(...)]` is not a valid attribute\n+    sub: Vec<Span>,\n+}"}, {"sha": "61806c80efc0b8195c10a59153bb33fa439f8b37", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -589,6 +589,16 @@ error: `code = \"...\"`/`code(...)` must contain only string literals\n LL |     #[suggestion(code = 3)]\n    |                  ^^^^^^^^\n \n+error: `#[suggestion(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:806:5\n+   |\n+LL |     #[suggestion(suggestion, code = \"\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[suggestion(...)]` applied to `Vec` field is ambiguous\n+   = help: to show a suggestion consisting of multiple parts, use a `Subdiagnostic` annotated with `#[multipart_suggestion(...)]`\n+   = help: to show a variable set of suggestions, use a `Vec` of `Subdiagnostic`s annotated with `#[suggestion(...)]`\n+\n error: cannot find attribute `nonsense` in this scope\n   --> $DIR/diagnostic-derive.rs:55:3\n    |\n@@ -660,7 +670,7 @@ note: required by a bound in `DiagnosticBuilder::<'a, G>::set_arg`\n   --> $COMPILER_DIR/rustc_errors/src/diagnostic_builder.rs:LL:CC\n    = note: this error originates in the derive macro `Diagnostic` which comes from the expansion of the macro `forward` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 83 previous errors\n+error: aborting due to 84 previous errors\n \n Some errors have detailed explanations: E0277, E0425.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "09ad69649098342dc26b2da15f462e77c09f8347", "filename": "tests/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -798,3 +798,13 @@ struct SuggestionStyleInvalid4 {\n     #[primary_span]\n     sub: Span,\n }\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(parse_add_paren, code = \"\")]\n+//~^ ERROR suggestion without `#[primary_span]` field\n+struct PrimarySpanOnVec {\n+    #[primary_span]\n+    //~^ ERROR `#[primary_span]` is not a valid attribute\n+    //~| NOTE there must be exactly one primary span\n+    sub: Vec<Span>,\n+}"}, {"sha": "f9d1a63031d7cceb84c5093304e523d8a9b6fcc1", "filename": "tests/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -501,6 +501,27 @@ error: `#[suggestion(style(...))]` is not a valid attribute\n LL | #[suggestion(parse_add_paren, code = \"\", style(\"foo\"))]\n    |                                          ^^^^^^^^^^^^\n \n+error: `#[primary_span]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:806:5\n+   |\n+LL |     #[primary_span]\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+   = note: there must be exactly one primary span\n+   = help: to create a suggestion with multiple spans, use `#[multipart_suggestion]` instead\n+\n+error: suggestion without `#[primary_span]` field\n+  --> $DIR/subdiagnostic-derive.rs:803:1\n+   |\n+LL | / #[suggestion(parse_add_paren, code = \"\")]\n+LL | |\n+LL | | struct PrimarySpanOnVec {\n+LL | |     #[primary_span]\n+...  |\n+LL | |     sub: Vec<Span>,\n+LL | | }\n+   | |_^\n+\n error: cannot find attribute `foo` in this scope\n   --> $DIR/subdiagnostic-derive.rs:63:3\n    |\n@@ -561,6 +582,6 @@ error[E0425]: cannot find value `slug` in module `rustc_errors::fluent`\n LL | #[label(slug)]\n    |         ^^^^ not found in `rustc_errors::fluent`\n \n-error: aborting due to 79 previous errors\n+error: aborting due to 81 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}, {"sha": "8e2d42c8f138cff4bfb013fb22da8d3e96d44a58", "filename": "tests/ui/async-await/dont-suggest-missing-await.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -6,11 +6,6 @@ LL |         take_u32(x)\n    |         |\n    |         arguments to this function are incorrect\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/dont-suggest-missing-await.rs:7:24\n-   |\n-LL | async fn make_u32() -> u32 {\n-   |                        ^^^ checked the `Output` of this `async fn`, found opaque type\n    = note:     expected type `u32`\n            found opaque type `impl Future<Output = u32>`\n note: function defined here"}, {"sha": "9fdb1ce47d7bae8db1a1a042e9dd5e378140f399", "filename": "tests/ui/async-await/generator-desc.stderr", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fgenerator-desc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fgenerator-desc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fgenerator-desc.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -21,16 +21,6 @@ LL |     fun(one(), two());\n    |     |\n    |     arguments to this function are incorrect\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/generator-desc.rs:5:16\n-   |\n-LL | async fn one() {}\n-   |                ^ checked the `Output` of this `async fn`, expected opaque type\n-note: while checking the return type of the `async fn`\n-  --> $DIR/generator-desc.rs:6:16\n-   |\n-LL | async fn two() {}\n-   |                ^ checked the `Output` of this `async fn`, found opaque type\n    = note: expected opaque type `impl Future<Output = ()>` (opaque type at <$DIR/generator-desc.rs:5:16>)\n               found opaque type `impl Future<Output = ()>` (opaque type at <$DIR/generator-desc.rs:6:16>)\n    = help: consider `await`ing on both `Future`s"}, {"sha": "9c4acbe0a5bf735857cd288d03589f97810518bd", "filename": "tests/ui/async-await/issue-61076.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fissue-61076.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fissue-61076.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fissue-61076.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -54,9 +54,6 @@ async fn struct_() -> Struct {\n }\n \n async fn tuple() -> Tuple {\n-    //~^ NOTE checked the `Output` of this `async fn`, expected opaque type\n-    //~| NOTE while checking the return type of the `async fn`\n-    //~| NOTE in this expansion of desugaring of `async` block or function\n     Tuple(1i32)\n }\n "}, {"sha": "b25b29bf50c174fd18b5db994a8b6bd8a6d808a9", "filename": "tests/ui/async-await/issue-61076.stderr", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fissue-61076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fissue-61076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fissue-61076.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -11,7 +11,7 @@ LL |     foo().await?;\n    |          ++++++\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/issue-61076.rs:65:5\n+  --> $DIR/issue-61076.rs:62:5\n    |\n LL |     t?;\n    |     ^^ the `?` operator cannot be applied to type `T`\n@@ -23,7 +23,7 @@ LL |     t.await?;\n    |      ++++++\n \n error[E0609]: no field `0` on type `impl Future<Output = Tuple>`\n-  --> $DIR/issue-61076.rs:74:26\n+  --> $DIR/issue-61076.rs:71:26\n    |\n LL |     let _: i32 = tuple().0;\n    |                          ^ field not available in `impl Future`, but it is available in its `Output`\n@@ -34,7 +34,7 @@ LL |     let _: i32 = tuple().await.0;\n    |                         ++++++\n \n error[E0609]: no field `a` on type `impl Future<Output = Struct>`\n-  --> $DIR/issue-61076.rs:78:28\n+  --> $DIR/issue-61076.rs:75:28\n    |\n LL |     let _: i32 = struct_().a;\n    |                            ^ field not available in `impl Future`, but it is available in its `Output`\n@@ -45,7 +45,7 @@ LL |     let _: i32 = struct_().await.a;\n    |                           ++++++\n \n error[E0599]: no method named `method` found for opaque type `impl Future<Output = Struct>` in the current scope\n-  --> $DIR/issue-61076.rs:82:15\n+  --> $DIR/issue-61076.rs:79:15\n    |\n LL |     struct_().method();\n    |               ^^^^^^ method not found in `impl Future<Output = Struct>`\n@@ -56,19 +56,14 @@ LL |     struct_().await.method();\n    |               ++++++\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-61076.rs:91:9\n+  --> $DIR/issue-61076.rs:88:9\n    |\n LL |     match tuple() {\n    |           ------- this expression has type `impl Future<Output = Tuple>`\n LL |\n LL |         Tuple(_) => {}\n    |         ^^^^^^^^ expected opaque type, found `Tuple`\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/issue-61076.rs:56:21\n-   |\n-LL | async fn tuple() -> Tuple {\n-   |                     ^^^^^ checked the `Output` of this `async fn`, expected opaque type\n    = note: expected opaque type `impl Future<Output = Tuple>`\n                    found struct `Tuple`\n help: consider `await`ing on the `Future`"}, {"sha": "4c5dfeed9ba5c6e87992d40a0b9bb8350e9f56b3", "filename": "tests/ui/async-await/issue-98634.stderr", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fissue-98634.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fissue-98634.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fissue-98634.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -4,11 +4,6 @@ error[E0271]: expected `callback` to be a fn item that returns `Pin<Box<dyn Futu\n LL |         StructAsync { callback }.await;\n    |                       ^^^^^^^^ expected `Pin<Box<dyn Future<Output = ()>>>`, found opaque type\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/issue-98634.rs:24:21\n-   |\n-LL | async fn callback() {}\n-   |                     ^ checked the `Output` of this `async fn`, found opaque type\n    = note:   expected struct `Pin<Box<(dyn Future<Output = ()> + 'static)>>`\n            found opaque type `impl Future<Output = ()>`\n note: required by a bound in `StructAsync`\n@@ -23,11 +18,6 @@ error[E0271]: expected `callback` to be a fn item that returns `Pin<Box<dyn Futu\n LL |         StructAsync { callback }.await;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ expected `Pin<Box<dyn Future<Output = ()>>>`, found opaque type\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/issue-98634.rs:24:21\n-   |\n-LL | async fn callback() {}\n-   |                     ^ checked the `Output` of this `async fn`, found opaque type\n    = note:   expected struct `Pin<Box<(dyn Future<Output = ()> + 'static)>>`\n            found opaque type `impl Future<Output = ()>`\n note: required by a bound in `StructAsync`\n@@ -42,11 +32,6 @@ error[E0271]: expected `callback` to be a fn item that returns `Pin<Box<dyn Futu\n LL |         StructAsync { callback }.await;\n    |                                 ^^^^^^ expected `Pin<Box<dyn Future<Output = ()>>>`, found opaque type\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/issue-98634.rs:24:21\n-   |\n-LL | async fn callback() {}\n-   |                     ^ checked the `Output` of this `async fn`, found opaque type\n    = note:   expected struct `Pin<Box<(dyn Future<Output = ()> + 'static)>>`\n            found opaque type `impl Future<Output = ()>`\n note: required by a bound in `StructAsync`"}, {"sha": "ebb80f6e07e74f21d7271e00cae744cbf90ea390", "filename": "tests/ui/async-await/issues/issue-102206.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fissues%2Fissue-102206.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fissues%2Fissue-102206.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fissues%2Fissue-102206.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -8,11 +8,6 @@ LL |     std::mem::size_of_val(foo());\n    |     |                     help: consider borrowing here: `&foo()`\n    |     arguments to this function are incorrect\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/issue-102206.rs:3:16\n-   |\n-LL | async fn foo() {}\n-   |                ^ checked the `Output` of this `async fn`, found opaque type\n    = note: expected reference `&_`\n             found opaque type `impl Future<Output = ()>`\n note: function defined here"}, {"sha": "e47325cb4aeaec6fcf5f3291a4d93fa0c30c8b74", "filename": "tests/ui/async-await/suggest-missing-await-closure.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -6,11 +6,6 @@ LL |         take_u32(x)\n    |         |\n    |         arguments to this function are incorrect\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await-closure.rs:8:24\n-   |\n-LL | async fn make_u32() -> u32 {\n-   |                        ^^^ checked the `Output` of this `async fn`, found opaque type\n    = note:     expected type `u32`\n            found opaque type `impl Future<Output = u32>`\n note: function defined here"}, {"sha": "4ed0272ac1a127b7ebd9b0c08948541ddfa21afa", "filename": "tests/ui/async-await/suggest-missing-await.stderr", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -6,11 +6,6 @@ LL |     take_u32(x)\n    |     |\n    |     arguments to this function are incorrect\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await.rs:5:24\n-   |\n-LL | async fn make_u32() -> u32 {\n-   |                        ^^^ checked the `Output` of this `async fn`, found opaque type\n    = note:     expected type `u32`\n            found opaque type `impl Future<Output = u32>`\n note: function defined here\n@@ -29,11 +24,6 @@ error[E0308]: mismatched types\n LL |     dummy()\n    |     ^^^^^^^ expected `()`, found opaque type\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await.rs:18:18\n-   |\n-LL | async fn dummy() {}\n-   |                  ^ checked the `Output` of this `async fn`, found opaque type\n    = note: expected unit type `()`\n             found opaque type `impl Future<Output = ()>`\n help: consider `await`ing on the `Future`\n@@ -60,11 +50,6 @@ LL | |\n LL | |     };\n    | |_____- `if` and `else` have incompatible types\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await.rs:18:18\n-   |\n-LL | async fn dummy() {}\n-   |                  ^ checked the `Output` of this `async fn`, expected opaque type\n    = note: expected opaque type `impl Future<Output = ()>`\n                 found unit type `()`\n help: consider `await`ing on the `Future`\n@@ -87,11 +72,6 @@ LL | |\n LL | |     };\n    | |_____- `match` arms have incompatible types\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await.rs:18:18\n-   |\n-LL | async fn dummy() {}\n-   |                  ^ checked the `Output` of this `async fn`, expected opaque type\n    = note: expected opaque type `impl Future<Output = ()>`\n                 found unit type `()`\n help: consider `await`ing on the `Future`\n@@ -108,11 +88,6 @@ LL |     let _x = match dummy() {\n LL |         () => {}\n    |         ^^ expected opaque type, found `()`\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await.rs:18:18\n-   |\n-LL | async fn dummy() {}\n-   |                  ^ checked the `Output` of this `async fn`, expected opaque type\n    = note: expected opaque type `impl Future<Output = ()>`\n                 found unit type `()`\n help: consider `await`ing on the `Future`\n@@ -129,11 +104,6 @@ LL |     match dummy_result() {\n LL |         Ok(_) => {}\n    |         ^^^^^ expected opaque type, found `Result<_, _>`\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await.rs:57:28\n-   |\n-LL | async fn dummy_result() -> Result<(), ()> {\n-   |                            ^^^^^^^^^^^^^^ checked the `Output` of this `async fn`, expected opaque type\n    = note: expected opaque type `impl Future<Output = Result<(), ()>>`\n                      found enum `Result<_, _>`\n help: consider `await`ing on the `Future`\n@@ -150,11 +120,6 @@ LL |     match dummy_result() {\n LL |         Err(_) => {}\n    |         ^^^^^^ expected opaque type, found `Result<_, _>`\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await.rs:57:28\n-   |\n-LL | async fn dummy_result() -> Result<(), ()> {\n-   |                            ^^^^^^^^^^^^^^ checked the `Output` of this `async fn`, expected opaque type\n    = note: expected opaque type `impl Future<Output = Result<(), ()>>`\n                      found enum `Result<_, _>`\n help: consider `await`ing on the `Future`"}, {"sha": "8e238a509d2fd5193ac460241b91a1a763e4688c", "filename": "tests/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -209,7 +209,7 @@ impl ::core::marker::StructuralPartialEq for PackedPoint { }\n impl ::core::cmp::PartialEq for PackedPoint {\n     #[inline]\n     fn eq(&self, other: &PackedPoint) -> bool {\n-        { self.x } == { other.x } && { self.y } == { other.y }\n+        ({ self.x }) == ({ other.x }) && ({ self.y }) == ({ other.y })\n     }\n }\n #[automatically_derived]\n@@ -718,8 +718,8 @@ impl<T: ::core::cmp::PartialEq + ::core::marker::Copy + Trait,\n     ::core::marker::Copy {\n     #[inline]\n     fn eq(&self, other: &PackedGeneric<T, U>) -> bool {\n-        { self.0 } == { other.0 } && { self.1 } == { other.1 } &&\n-            { self.2 } == { other.2 }\n+        ({ self.0 }) == ({ other.0 }) && ({ self.1 }) == ({ other.1 }) &&\n+            ({ self.2 }) == ({ other.2 })\n     }\n }\n #[automatically_derived]"}, {"sha": "aa20a4d4c653a871d276fdf45ed00f7fae764ccf", "filename": "tests/ui/ffi_const.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fffi_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fffi_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fffi_const.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -3,3 +3,13 @@\n \n #[ffi_const] //~ ERROR `#[ffi_const]` may only be used on foreign functions\n pub fn foo() {}\n+\n+#[ffi_const] //~ ERROR `#[ffi_const]` may only be used on foreign functions\n+macro_rules! bar {\n+    () => ()\n+}\n+\n+extern \"C\" {\n+    #[ffi_const] //~ ERROR `#[ffi_const]` may only be used on foreign functions\n+    static INT: i32;\n+}"}, {"sha": "394b98f89712a6f7380d1921e24132a89f4b0b52", "filename": "tests/ui/ffi_const.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fffi_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fffi_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fffi_const.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -4,6 +4,18 @@ error[E0756]: `#[ffi_const]` may only be used on foreign functions\n LL | #[ffi_const]\n    | ^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0756]: `#[ffi_const]` may only be used on foreign functions\n+  --> $DIR/ffi_const.rs:7:1\n+   |\n+LL | #[ffi_const]\n+   | ^^^^^^^^^^^^\n+\n+error[E0756]: `#[ffi_const]` may only be used on foreign functions\n+  --> $DIR/ffi_const.rs:13:5\n+   |\n+LL |     #[ffi_const]\n+   |     ^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0756`."}, {"sha": "6d2f3a614ec97154f344223a35be02d6c8ed216e", "filename": "tests/ui/ffi_pure.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fffi_pure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fffi_pure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fffi_pure.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -3,3 +3,13 @@\n \n #[ffi_pure] //~ ERROR `#[ffi_pure]` may only be used on foreign functions\n pub fn foo() {}\n+\n+#[ffi_pure] //~ ERROR `#[ffi_pure]` may only be used on foreign functions\n+macro_rules! bar {\n+    () => ()\n+}\n+\n+extern \"C\" {\n+    #[ffi_pure] //~ ERROR `#[ffi_pure]` may only be used on foreign functions\n+    static INT: i32;\n+}"}, {"sha": "8b61a4b609fc08e9e1f1dffbbf9e0be36615147d", "filename": "tests/ui/ffi_pure.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fffi_pure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fffi_pure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fffi_pure.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -4,6 +4,18 @@ error[E0755]: `#[ffi_pure]` may only be used on foreign functions\n LL | #[ffi_pure]\n    | ^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0755]: `#[ffi_pure]` may only be used on foreign functions\n+  --> $DIR/ffi_pure.rs:7:1\n+   |\n+LL | #[ffi_pure]\n+   | ^^^^^^^^^^^\n+\n+error[E0755]: `#[ffi_pure]` may only be used on foreign functions\n+  --> $DIR/ffi_pure.rs:13:5\n+   |\n+LL |     #[ffi_pure]\n+   |     ^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0755`."}, {"sha": "8195d0e48636927b6a7410c18637a451c516773b", "filename": "tests/ui/ffi_returns_twice.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fffi_returns_twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fffi_returns_twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fffi_returns_twice.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -3,3 +3,13 @@\n \n #[ffi_returns_twice] //~ ERROR `#[ffi_returns_twice]` may only be used on foreign functions\n pub fn foo() {}\n+\n+#[ffi_returns_twice] //~ ERROR `#[ffi_returns_twice]` may only be used on foreign functions\n+macro_rules! bar {\n+    () => ()\n+}\n+\n+extern \"C\" {\n+    #[ffi_returns_twice] //~ ERROR `#[ffi_returns_twice]` may only be used on foreign functions\n+    static INT: i32;\n+}"}, {"sha": "0abe7613f1493a0ce7521c374577b92509ea80f9", "filename": "tests/ui/ffi_returns_twice.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fffi_returns_twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fffi_returns_twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fffi_returns_twice.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -4,6 +4,18 @@ error[E0724]: `#[ffi_returns_twice]` may only be used on foreign functions\n LL | #[ffi_returns_twice]\n    | ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0724]: `#[ffi_returns_twice]` may only be used on foreign functions\n+  --> $DIR/ffi_returns_twice.rs:7:1\n+   |\n+LL | #[ffi_returns_twice]\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0724]: `#[ffi_returns_twice]` may only be used on foreign functions\n+  --> $DIR/ffi_returns_twice.rs:13:5\n+   |\n+LL |     #[ffi_returns_twice]\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0724`."}, {"sha": "3ec62020e6c89c41077a681f599a9856cc2cb05a", "filename": "tests/ui/impl-trait/in-trait/method-signature-matches.stderr", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -24,16 +24,6 @@ LL |     async fn owo(_: u8) {}\n    |                     expected `()`, found `u8`\n    |                     help: change the parameter type to match the trait: `()`\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/method-signature-matches.rs:20:25\n-   |\n-LL |     async fn owo(_: u8) {}\n-   |                         ^ checked the `Output` of this `async fn`, expected opaque type\n-note: while checking the return type of the `async fn`\n-  --> $DIR/method-signature-matches.rs:20:25\n-   |\n-LL |     async fn owo(_: u8) {}\n-   |                         ^ checked the `Output` of this `async fn`, found opaque type\n note: type in trait\n   --> $DIR/method-signature-matches.rs:16:21\n    |"}, {"sha": "8ff08968008bb31839eb5c65444e1044377671a3", "filename": "tests/ui/impl-trait/issue-102605.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fimpl-trait%2Fissue-102605.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fimpl-trait%2Fissue-102605.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fissue-102605.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -6,11 +6,6 @@ LL |     convert_result(foo())\n    |     |\n    |     arguments to this function are incorrect\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/issue-102605.rs:3:19\n-   |\n-LL | async fn foo() -> Result<(), String> {\n-   |                   ^^^^^^^^^^^^^^^^^^ checked the `Output` of this `async fn`, found opaque type\n    = note:     expected enum `Result<(), _>`\n            found opaque type `impl Future<Output = Result<(), String>>`\n note: function defined here"}, {"sha": "a4b7fc1f5bc75e6e62e932461e6e3c32c0c3a1dd", "filename": "tests/ui/impl-trait/issue-99914.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fimpl-trait%2Fissue-99914.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fimpl-trait%2Fissue-99914.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fissue-99914.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -4,11 +4,6 @@ error[E0308]: mismatched types\n LL |     t.and_then(|t| -> _ { bar(t) });\n    |                           ^^^^^^ expected `Result<_, Error>`, found opaque type\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/issue-99914.rs:13:23\n-   |\n-LL | async fn bar(t: Okay) {}\n-   |                       ^ checked the `Output` of this `async fn`, found opaque type\n    = note:     expected enum `Result<_, Error>`\n            found opaque type `impl Future<Output = ()>`\n help: try wrapping the expression in `Ok`"}, {"sha": "020128fa214460f0d2f6f574eb422d5314c7c5d1", "filename": "tests/ui/proc-macro/crt-static.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fproc-macro%2Fcrt-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fproc-macro%2Fcrt-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fcrt-static.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -5,6 +5,9 @@\n // ignore-wasm32\n // ignore-sgx no support for proc-macro crate type\n // build-pass\n+// force-host\n+// no-prefer-dynamic\n+\n #![crate_type = \"proc-macro\"]\n \n // FIXME: This don't work when crate-type is specified by attribute"}, {"sha": "fdbea7cf487ebf0c513fa1e9d6eafe32884dbf57", "filename": "tests/ui/pub/pub-ident-fn-3.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff6fb4c33e8bd94b17a4715046b8266a1d42e793/tests%2Fui%2Fpub%2Fpub-ident-fn-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff6fb4c33e8bd94b17a4715046b8266a1d42e793/tests%2Fui%2Fpub%2Fpub-ident-fn-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpub%2Fpub-ident-fn-3.rs?ref=ff6fb4c33e8bd94b17a4715046b8266a1d42e793", "patch": "@@ -1,8 +0,0 @@\n-// #60115\n-\n-mod foo {\n-    pub bar();\n-    //~^ ERROR missing `fn` or `struct` for function or struct definition\n-}\n-\n-fn main() {}"}, {"sha": "6d3d4e592c8ed8f88554db971d50cf75d14b1e8a", "filename": "tests/ui/pub/pub-ident-fn-3.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff6fb4c33e8bd94b17a4715046b8266a1d42e793/tests%2Fui%2Fpub%2Fpub-ident-fn-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff6fb4c33e8bd94b17a4715046b8266a1d42e793/tests%2Fui%2Fpub%2Fpub-ident-fn-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpub%2Fpub-ident-fn-3.stderr?ref=ff6fb4c33e8bd94b17a4715046b8266a1d42e793", "patch": "@@ -1,8 +0,0 @@\n-error: missing `fn` or `struct` for function or struct definition\n-  --> $DIR/pub-ident-fn-3.rs:4:8\n-   |\n-LL |     pub bar();\n-   |     ---^--- help: if you meant to call a macro, try: `bar!`\n-\n-error: aborting due to previous error\n-"}, {"sha": "8f67cdd293342f3d8c22d207ab5be73b6f377767", "filename": "tests/ui/pub/pub-ident-fn-or-struct-2.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff6fb4c33e8bd94b17a4715046b8266a1d42e793/tests%2Fui%2Fpub%2Fpub-ident-fn-or-struct-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff6fb4c33e8bd94b17a4715046b8266a1d42e793/tests%2Fui%2Fpub%2Fpub-ident-fn-or-struct-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpub%2Fpub-ident-fn-or-struct-2.rs?ref=ff6fb4c33e8bd94b17a4715046b8266a1d42e793", "patch": "@@ -1,4 +0,0 @@\n-pub S();\n-//~^ ERROR missing `fn` or `struct` for function or struct definition\n-\n-fn main() {}"}, {"sha": "047e66b18d8cd2c683b6f02d555e9d0671623b9f", "filename": "tests/ui/pub/pub-ident-fn-or-struct-2.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff6fb4c33e8bd94b17a4715046b8266a1d42e793/tests%2Fui%2Fpub%2Fpub-ident-fn-or-struct-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff6fb4c33e8bd94b17a4715046b8266a1d42e793/tests%2Fui%2Fpub%2Fpub-ident-fn-or-struct-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpub%2Fpub-ident-fn-or-struct-2.stderr?ref=ff6fb4c33e8bd94b17a4715046b8266a1d42e793", "patch": "@@ -1,8 +0,0 @@\n-error: missing `fn` or `struct` for function or struct definition\n-  --> $DIR/pub-ident-fn-or-struct-2.rs:1:4\n-   |\n-LL | pub S();\n-   | ---^- help: if you meant to call a macro, try: `S!`\n-\n-error: aborting due to previous error\n-"}, {"sha": "50db4039d4fc114b3a020eabc761300b2ffc6f81", "filename": "tests/ui/pub/pub-ident-struct-2.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fpub%2Fpub-ident-struct-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fpub%2Fpub-ident-struct-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpub%2Fpub-ident-struct-2.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -0,0 +1,8 @@\n+// #60115\n+\n+mod foo {\n+    pub bar();\n+    //~^ ERROR missing `struct` for struct definition\n+}\n+\n+fn main() {}"}, {"sha": "6969a376a5e76b85e260746f5bc3856ad292fa94", "filename": "tests/ui/pub/pub-ident-struct-2.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fpub%2Fpub-ident-struct-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fpub%2Fpub-ident-struct-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpub%2Fpub-ident-struct-2.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -0,0 +1,13 @@\n+error: missing `struct` for struct definition\n+  --> $DIR/pub-ident-struct-2.rs:4:8\n+   |\n+LL |     pub bar();\n+   |        ^\n+   |\n+help: add `struct` here to parse `bar` as a public struct\n+   |\n+LL |     pub struct bar();\n+   |         ++++++\n+\n+error: aborting due to previous error\n+"}, {"sha": "dfa6cf2ee1e87696e48049ce57342f497e77a015", "filename": "tests/ui/pub/pub-ident-struct-3.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fpub%2Fpub-ident-struct-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fpub%2Fpub-ident-struct-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpub%2Fpub-ident-struct-3.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -0,0 +1,4 @@\n+pub S();\n+//~^ ERROR missing `struct` for struct definition\n+\n+fn main() {}"}, {"sha": "d94198a6b6deb0339c3e4f50d73d4cc07051542c", "filename": "tests/ui/pub/pub-ident-struct-3.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fpub%2Fpub-ident-struct-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fpub%2Fpub-ident-struct-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpub%2Fpub-ident-struct-3.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -0,0 +1,13 @@\n+error: missing `struct` for struct definition\n+  --> $DIR/pub-ident-struct-3.rs:1:4\n+   |\n+LL | pub S();\n+   |    ^\n+   |\n+help: add `struct` here to parse `S` as a public struct\n+   |\n+LL | pub struct S();\n+   |     ++++++\n+\n+error: aborting due to previous error\n+"}, {"sha": "b49fa678e1b7d3221777cce538f499f786ebbbd4", "filename": "tests/ui/pub/pub-ident-struct-4.fixed", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fpub%2Fpub-ident-struct-4.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fpub%2Fpub-ident-struct-4.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpub%2Fpub-ident-struct-4.fixed?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -0,0 +1,6 @@\n+// run-rustfix\n+\n+pub struct T(String);\n+//~^ ERROR missing `struct` for struct definition\n+\n+fn main() {}"}, {"sha": "20bc94b0acb19f4f081351daa4b67b8a375424d7", "filename": "tests/ui/pub/pub-ident-struct-4.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fpub%2Fpub-ident-struct-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fpub%2Fpub-ident-struct-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpub%2Fpub-ident-struct-4.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -0,0 +1,6 @@\n+// run-rustfix\n+\n+pub T(String);\n+//~^ ERROR missing `struct` for struct definition\n+\n+fn main() {}"}, {"sha": "90c7138e5cee0fb325f5dd0bac36c573913ff160", "filename": "tests/ui/pub/pub-ident-struct-4.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fpub%2Fpub-ident-struct-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fpub%2Fpub-ident-struct-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpub%2Fpub-ident-struct-4.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -0,0 +1,13 @@\n+error: missing `struct` for struct definition\n+  --> $DIR/pub-ident-struct-4.rs:3:4\n+   |\n+LL | pub T(String);\n+   |    ^\n+   |\n+help: add `struct` here to parse `T` as a public struct\n+   |\n+LL | pub struct T(String);\n+   |     ++++++\n+\n+error: aborting due to previous error\n+"}, {"sha": "7be4312bfbacbdcf0ff2bf01bb10af78c303eb47", "filename": "tests/ui/suggestions/if-then-neeing-semi.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fsuggestions%2Fif-then-neeing-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fsuggestions%2Fif-then-neeing-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fif-then-neeing-semi.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -15,18 +15,9 @@ fn extra_semicolon() {\n     };\n }\n \n-async fn async_dummy() {} //~ NOTE checked the `Output` of this `async fn`, found opaque type\n-//~| NOTE while checking the return type of the `async fn`\n-//~| NOTE in this expansion of desugaring of `async` block or function\n-//~| NOTE checked the `Output` of this `async fn`, expected opaque type\n-//~| NOTE while checking the return type of the `async fn`\n-//~| NOTE in this expansion of desugaring of `async` block or function\n-async fn async_dummy2() {} //~ NOTE checked the `Output` of this `async fn`, found opaque type\n-//~| NOTE checked the `Output` of this `async fn`, found opaque type\n-//~| NOTE while checking the return type of the `async fn`\n-//~| NOTE in this expansion of desugaring of `async` block or function\n-//~| NOTE while checking the return type of the `async fn`\n-//~| NOTE in this expansion of desugaring of `async` block or function\n+async fn async_dummy() {}\n+\n+async fn async_dummy2() {}\n \n async fn async_extra_semicolon_same() {\n     let _ = if true {"}, {"sha": "567deb405fccd98332c24019c511ffc642187a62", "filename": "tests/ui/suggestions/if-then-neeing-semi.stderr", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fsuggestions%2Fif-then-neeing-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fsuggestions%2Fif-then-neeing-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fif-then-neeing-semi.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: `if` and `else` have incompatible types\n-  --> $DIR/if-then-neeing-semi.rs:37:9\n+  --> $DIR/if-then-neeing-semi.rs:28:9\n    |\n LL |       let _ = if true {\n    |  _____________-\n@@ -15,11 +15,6 @@ LL | |\n LL | |     };\n    | |_____- `if` and `else` have incompatible types\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/if-then-neeing-semi.rs:18:24\n-   |\n-LL | async fn async_dummy() {}\n-   |                        ^ checked the `Output` of this `async fn`, found opaque type\n    = note: expected unit type `()`\n             found opaque type `impl Future<Output = ()>`\n help: consider `await`ing on the `Future`\n@@ -33,7 +28,7 @@ LL +         async_dummy()\n    |\n \n error[E0308]: `if` and `else` have incompatible types\n-  --> $DIR/if-then-neeing-semi.rs:50:9\n+  --> $DIR/if-then-neeing-semi.rs:41:9\n    |\n LL |       let _ = if true {\n    |  _____________-\n@@ -49,11 +44,6 @@ LL | |\n LL | |     };\n    | |_____- `if` and `else` have incompatible types\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/if-then-neeing-semi.rs:24:25\n-   |\n-LL | async fn async_dummy2() {}\n-   |                         ^ checked the `Output` of this `async fn`, found opaque type\n    = note: expected unit type `()`\n             found opaque type `impl Future<Output = ()>`\n help: consider `await`ing on the `Future`\n@@ -69,7 +59,7 @@ LL ~         Box::new(async_dummy2())\n    |\n \n error[E0308]: `if` and `else` have incompatible types\n-  --> $DIR/if-then-neeing-semi.rs:63:9\n+  --> $DIR/if-then-neeing-semi.rs:54:9\n    |\n LL |       let _ = if true {\n    |  _____________-\n@@ -85,18 +75,8 @@ LL | |\n LL | |     };\n    | |_____- `if` and `else` have incompatible types\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/if-then-neeing-semi.rs:18:24\n-   |\n-LL | async fn async_dummy() {}\n-   |                        ^ checked the `Output` of this `async fn`, expected opaque type\n-note: while checking the return type of the `async fn`\n-  --> $DIR/if-then-neeing-semi.rs:24:25\n-   |\n-LL | async fn async_dummy2() {}\n-   |                         ^ checked the `Output` of this `async fn`, found opaque type\n    = note: expected opaque type `impl Future<Output = ()>` (opaque type at <$DIR/if-then-neeing-semi.rs:18:24>)\n-              found opaque type `impl Future<Output = ()>` (opaque type at <$DIR/if-then-neeing-semi.rs:24:25>)\n+              found opaque type `impl Future<Output = ()>` (opaque type at <$DIR/if-then-neeing-semi.rs:20:25>)\n    = note: distinct uses of `impl Trait` result in different opaque types\n help: consider `await`ing on both `Future`s\n    |"}, {"sha": "4af7cc9f8ec800c7a2b8b6fb50648acecf633df9", "filename": "tests/ui/suggestions/issue-81839.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fsuggestions%2Fissue-81839.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fsuggestions%2Fissue-81839.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-81839.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -14,11 +14,6 @@ LL | |         _ => cx.answer_str(\"hi\"),\n LL | |     }\n    | |_____- `match` arms have incompatible types\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/auxiliary/issue-81839.rs:6:49\n-   |\n-LL |     pub async fn answer_str(&self, _s: &str) -> Test {\n-   |                                                 ^^^^ checked the `Output` of this `async fn`, found opaque type\n    = note: expected unit type `()`\n             found opaque type `impl Future<Output = Test>`\n "}, {"sha": "3f863cb104e0bfa48d99d5c63e4e49a60fdac892", "filename": "tests/ui/suggestions/match-prev-arm-needing-semi.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -13,18 +13,9 @@ fn extra_semicolon() {\n     };\n }\n \n-async fn async_dummy() {} //~ NOTE checked the `Output` of this `async fn`, found opaque type\n-//~| NOTE while checking the return type of the `async fn`\n-//~| NOTE in this expansion of desugaring of `async` block or function\n-//~| NOTE checked the `Output` of this `async fn`, expected opaque type\n-//~| NOTE while checking the return type of the `async fn`\n-//~| NOTE in this expansion of desugaring of `async` block or function\n-async fn async_dummy2() {} //~ NOTE checked the `Output` of this `async fn`, found opaque type\n-//~| NOTE checked the `Output` of this `async fn`, found opaque type\n-//~| NOTE while checking the return type of the `async fn`\n-//~| NOTE in this expansion of desugaring of `async` block or function\n-//~| NOTE while checking the return type of the `async fn`\n-//~| NOTE in this expansion of desugaring of `async` block or function\n+async fn async_dummy() {}\n+\n+async fn async_dummy2() {}\n \n async fn async_extra_semicolon_same() {\n     let _ = match true { //~ NOTE `match` arms have incompatible types"}, {"sha": "df18c7b0b23cceade1b2e6e8d4a47aeb0ff31ac4", "filename": "tests/ui/suggestions/match-prev-arm-needing-semi.stderr", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:35:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:26:18\n    |\n LL |       let _ = match true {\n    |  _____________-\n@@ -15,11 +15,6 @@ LL | |\n LL | |     };\n    | |_____- `match` arms have incompatible types\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/match-prev-arm-needing-semi.rs:16:24\n-   |\n-LL | async fn async_dummy() {}\n-   |                        ^ checked the `Output` of this `async fn`, found opaque type\n    = note: expected unit type `()`\n             found opaque type `impl Future<Output = ()>`\n help: consider `await`ing on the `Future`\n@@ -33,7 +28,7 @@ LL +             async_dummy()\n    |\n \n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:48:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:39:18\n    |\n LL |       let _ = match true {\n    |  _____________-\n@@ -49,11 +44,6 @@ LL | |\n LL | |     };\n    | |_____- `match` arms have incompatible types\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/match-prev-arm-needing-semi.rs:22:25\n-   |\n-LL | async fn async_dummy2() {}\n-   |                         ^ checked the `Output` of this `async fn`, found opaque type\n    = note: expected unit type `()`\n             found opaque type `impl Future<Output = ()>`\n help: consider `await`ing on the `Future`\n@@ -69,7 +59,7 @@ LL ~         false => Box::new(async_dummy2()),\n    |\n \n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:59:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:50:18\n    |\n LL |       let _ = match true {\n    |  _____________-\n@@ -83,18 +73,8 @@ LL | |\n LL | |     };\n    | |_____- `match` arms have incompatible types\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/match-prev-arm-needing-semi.rs:16:24\n-   |\n-LL | async fn async_dummy() {}\n-   |                        ^ checked the `Output` of this `async fn`, expected opaque type\n-note: while checking the return type of the `async fn`\n-  --> $DIR/match-prev-arm-needing-semi.rs:22:25\n-   |\n-LL | async fn async_dummy2() {}\n-   |                         ^ checked the `Output` of this `async fn`, found opaque type\n    = note: expected opaque type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:16:24>)\n-              found opaque type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:22:25>)\n+              found opaque type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:18:25>)\n    = note: distinct uses of `impl Trait` result in different opaque types\n help: consider `await`ing on both `Future`s\n    |"}, {"sha": "9ebf222ee342fe6f5607c182e9bb6055e3f88c37", "filename": "tests/ui/track-diagnostics/track4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Ftrack-diagnostics%2Ftrack4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Ftrack-diagnostics%2Ftrack4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrack-diagnostics%2Ftrack4.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -3,7 +3,7 @@ error: missing `struct` for struct definition\n    |\n LL | pub onion {\n    |    ^\n--Ztrack-diagnostics: created at compiler/rustc_parse/src/parser/diagnostics.rs:LL:CC\n+-Ztrack-diagnostics: created at compiler/rustc_parse/src/parser/item.rs:LL:CC\n    |\n help: add `struct` here to parse `onion` as a public struct\n    |"}, {"sha": "bb9dd2365ea0d5de834978e859d5006c4fb3cd4f", "filename": "tests/ui/type-alias-impl-trait/issue-98604.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-98604.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcf9c9de3b0a9482de76d8ce0a656957d24513e6/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-98604.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-98604.stderr?ref=dcf9c9de3b0a9482de76d8ce0a656957d24513e6", "patch": "@@ -4,11 +4,6 @@ error[E0271]: expected `test` to be a fn item that returns `Pin<Box<dyn Future<O\n LL |     Box::new(test) as AsyncFnPtr;\n    |     ^^^^^^^^^^^^^^ expected `Pin<Box<dyn Future<Output = ()>>>`, found opaque type\n    |\n-note: while checking the return type of the `async fn`\n-  --> $DIR/issue-98604.rs:5:17\n-   |\n-LL | async fn test() {}\n-   |                 ^ checked the `Output` of this `async fn`, found opaque type\n    = note:   expected struct `Pin<Box<(dyn Future<Output = ()> + 'static)>>`\n            found opaque type `impl Future<Output = ()>`\n    = note: required for the cast from `fn() -> impl Future<Output = ()> {test}` to the object type `dyn Fn() -> Pin<Box<(dyn Future<Output = ()> + 'static)>>`"}]}