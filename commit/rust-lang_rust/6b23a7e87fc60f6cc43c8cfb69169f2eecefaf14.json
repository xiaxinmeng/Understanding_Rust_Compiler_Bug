{"sha": "6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "node_id": "C_kwDOAAsO6NoAKDZiMjNhN2U4N2ZjNjBmNmNjNDNjOGNmYjY5MTY5ZjJlZWNlZmFmMTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-08T03:03:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-08T03:03:38Z"}, "message": "Auto merge of #104023 - Nilstrieb:cleanup-query, r=cjgillot\n\nSeveral query cleanups\n\nA few cleanups, mostly about naming in `rustc_query_system`.\n\nr? `@cjgillot`", "tree": {"sha": "c7035e4d6e220fc4ccd433e08e2956c50d9fe84a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7035e4d6e220fc4ccd433e08e2956c50d9fe84a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "html_url": "https://github.com/rust-lang/rust/commit/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6184a963f71f934f43fb75ca7effd656b23cd9f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6184a963f71f934f43fb75ca7effd656b23cd9f8", "html_url": "https://github.com/rust-lang/rust/commit/6184a963f71f934f43fb75ca7effd656b23cd9f8"}, {"sha": "6d26ea86dac0eb987b338bf3ba5f3900fd68f000", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d26ea86dac0eb987b338bf3ba5f3900fd68f000", "html_url": "https://github.com/rust-lang/rust/commit/6d26ea86dac0eb987b338bf3ba5f3900fd68f000"}], "stats": {"total": 499, "additions": 228, "deletions": 271}, "files": [{"sha": "81114f2cd82c326dbe9a98aefb7b402b986ded0f", "filename": "compiler/rustc_query_impl/src/profiling_support.rs", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs?ref=6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "patch": "@@ -19,18 +19,18 @@ impl QueryKeyStringCache {\n     }\n }\n \n-struct QueryKeyStringBuilder<'p, 'c, 'tcx> {\n+struct QueryKeyStringBuilder<'p, 'tcx> {\n     profiler: &'p SelfProfiler,\n     tcx: TyCtxt<'tcx>,\n-    string_cache: &'c mut QueryKeyStringCache,\n+    string_cache: &'p mut QueryKeyStringCache,\n }\n \n-impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n+impl<'p, 'tcx> QueryKeyStringBuilder<'p, 'tcx> {\n     fn new(\n         profiler: &'p SelfProfiler,\n         tcx: TyCtxt<'tcx>,\n-        string_cache: &'c mut QueryKeyStringCache,\n-    ) -> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n+        string_cache: &'p mut QueryKeyStringCache,\n+    ) -> QueryKeyStringBuilder<'p, 'tcx> {\n         QueryKeyStringBuilder { profiler, tcx, string_cache }\n     }\n \n@@ -99,7 +99,7 @@ impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n }\n \n trait IntoSelfProfilingString {\n-    fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_, '_>) -> StringId;\n+    fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId;\n }\n \n // The default implementation of `IntoSelfProfilingString` just uses `Debug`\n@@ -109,68 +109,50 @@ trait IntoSelfProfilingString {\n impl<T: Debug> IntoSelfProfilingString for T {\n     default fn to_self_profile_string(\n         &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n+        builder: &mut QueryKeyStringBuilder<'_, '_>,\n     ) -> StringId {\n         let s = format!(\"{:?}\", self);\n         builder.profiler.alloc_string(&s[..])\n     }\n }\n \n impl<T: SpecIntoSelfProfilingString> IntoSelfProfilingString for T {\n-    fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_, '_>) -> StringId {\n+    fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n         self.spec_to_self_profile_string(builder)\n     }\n }\n \n #[rustc_specialization_trait]\n trait SpecIntoSelfProfilingString: Debug {\n-    fn spec_to_self_profile_string(\n-        &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n-    ) -> StringId;\n+    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId;\n }\n \n impl SpecIntoSelfProfilingString for DefId {\n-    fn spec_to_self_profile_string(\n-        &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n-    ) -> StringId {\n+    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n         builder.def_id_to_string_id(*self)\n     }\n }\n \n impl SpecIntoSelfProfilingString for CrateNum {\n-    fn spec_to_self_profile_string(\n-        &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n-    ) -> StringId {\n+    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n         builder.def_id_to_string_id(self.as_def_id())\n     }\n }\n \n impl SpecIntoSelfProfilingString for DefIndex {\n-    fn spec_to_self_profile_string(\n-        &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n-    ) -> StringId {\n+    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n         builder.def_id_to_string_id(DefId { krate: LOCAL_CRATE, index: *self })\n     }\n }\n \n impl SpecIntoSelfProfilingString for LocalDefId {\n-    fn spec_to_self_profile_string(\n-        &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n-    ) -> StringId {\n+    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n         builder.def_id_to_string_id(DefId { krate: LOCAL_CRATE, index: self.local_def_index })\n     }\n }\n \n impl<T: SpecIntoSelfProfilingString> SpecIntoSelfProfilingString for WithOptConstParam<T> {\n-    fn spec_to_self_profile_string(\n-        &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n-    ) -> StringId {\n+    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n         // We print `WithOptConstParam` values as tuples to make them shorter\n         // and more readable, without losing information:\n         //\n@@ -205,10 +187,7 @@ where\n     T0: SpecIntoSelfProfilingString,\n     T1: SpecIntoSelfProfilingString,\n {\n-    fn spec_to_self_profile_string(\n-        &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n-    ) -> StringId {\n+    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n         let val0 = self.0.to_self_profile_string(builder);\n         let val1 = self.1.to_self_profile_string(builder);\n "}, {"sha": "7cc885be2ba6a6319b51e783e1d03efc97f344a1", "filename": "compiler/rustc_query_system/src/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs?ref=6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "patch": "@@ -26,7 +26,7 @@ impl<Key, Value> Cache<Key, Value> {\n }\n \n impl<Key: Eq + Hash, Value: Clone> Cache<Key, Value> {\n-    pub fn get<CTX: DepContext>(&self, key: &Key, tcx: CTX) -> Option<Value> {\n+    pub fn get<Tcx: DepContext>(&self, key: &Key, tcx: Tcx) -> Option<Value> {\n         Some(self.hashmap.borrow().get(key)?.get(tcx))\n     }\n \n@@ -46,7 +46,7 @@ impl<T: Clone> WithDepNode<T> {\n         WithDepNode { dep_node, cached_value }\n     }\n \n-    pub fn get<CTX: DepContext>(&self, tcx: CTX) -> T {\n+    pub fn get<Tcx: DepContext>(&self, tcx: Tcx) -> T {\n         tcx.dep_graph().read_index(self.dep_node);\n         self.cached_value.clone()\n     }"}, {"sha": "d79c5816a9c40bb1fc0d3aab18113ae01af46ea8", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "patch": "@@ -61,18 +61,18 @@ impl<K: DepKind> DepNode<K> {\n     /// Creates a new, parameterless DepNode. This method will assert\n     /// that the DepNode corresponding to the given DepKind actually\n     /// does not require any parameters.\n-    pub fn new_no_params<Ctxt>(tcx: Ctxt, kind: K) -> DepNode<K>\n+    pub fn new_no_params<Tcx>(tcx: Tcx, kind: K) -> DepNode<K>\n     where\n-        Ctxt: super::DepContext<DepKind = K>,\n+        Tcx: super::DepContext<DepKind = K>,\n     {\n         debug_assert_eq!(tcx.fingerprint_style(kind), FingerprintStyle::Unit);\n         DepNode { kind, hash: Fingerprint::ZERO.into() }\n     }\n \n-    pub fn construct<Ctxt, Key>(tcx: Ctxt, kind: K, arg: &Key) -> DepNode<K>\n+    pub fn construct<Tcx, Key>(tcx: Tcx, kind: K, arg: &Key) -> DepNode<K>\n     where\n-        Ctxt: super::DepContext<DepKind = K>,\n-        Key: DepNodeParams<Ctxt>,\n+        Tcx: super::DepContext<DepKind = K>,\n+        Key: DepNodeParams<Tcx>,\n     {\n         let hash = arg.to_fingerprint(tcx);\n         let dep_node = DepNode { kind, hash: hash.into() };\n@@ -93,9 +93,9 @@ impl<K: DepKind> DepNode<K> {\n     /// Construct a DepNode from the given DepKind and DefPathHash. This\n     /// method will assert that the given DepKind actually requires a\n     /// single DefId/DefPathHash parameter.\n-    pub fn from_def_path_hash<Ctxt>(tcx: Ctxt, def_path_hash: DefPathHash, kind: K) -> Self\n+    pub fn from_def_path_hash<Tcx>(tcx: Tcx, def_path_hash: DefPathHash, kind: K) -> Self\n     where\n-        Ctxt: super::DepContext<DepKind = K>,\n+        Tcx: super::DepContext<DepKind = K>,\n     {\n         debug_assert!(tcx.fingerprint_style(kind) == FingerprintStyle::DefPathHash);\n         DepNode { kind, hash: def_path_hash.0.into() }\n@@ -108,18 +108,18 @@ impl<K: DepKind> fmt::Debug for DepNode<K> {\n     }\n }\n \n-pub trait DepNodeParams<Ctxt: DepContext>: fmt::Debug + Sized {\n+pub trait DepNodeParams<Tcx: DepContext>: fmt::Debug + Sized {\n     fn fingerprint_style() -> FingerprintStyle;\n \n     /// This method turns the parameters of a DepNodeConstructor into an opaque\n     /// Fingerprint to be used in DepNode.\n     /// Not all DepNodeParams support being turned into a Fingerprint (they\n     /// don't need to if the corresponding DepNode is anonymous).\n-    fn to_fingerprint(&self, _: Ctxt) -> Fingerprint {\n+    fn to_fingerprint(&self, _: Tcx) -> Fingerprint {\n         panic!(\"Not implemented. Accidentally called on anonymous node?\")\n     }\n \n-    fn to_debug_str(&self, _: Ctxt) -> String {\n+    fn to_debug_str(&self, _: Tcx) -> String {\n         format!(\"{:?}\", self)\n     }\n \n@@ -129,10 +129,10 @@ pub trait DepNodeParams<Ctxt: DepContext>: fmt::Debug + Sized {\n     /// `fingerprint_style()` is not `FingerprintStyle::Opaque`.\n     /// It is always valid to return `None` here, in which case incremental\n     /// compilation will treat the query as having changed instead of forcing it.\n-    fn recover(tcx: Ctxt, dep_node: &DepNode<Ctxt::DepKind>) -> Option<Self>;\n+    fn recover(tcx: Tcx, dep_node: &DepNode<Tcx::DepKind>) -> Option<Self>;\n }\n \n-impl<Ctxt: DepContext, T> DepNodeParams<Ctxt> for T\n+impl<Tcx: DepContext, T> DepNodeParams<Tcx> for T\n where\n     T: for<'a> HashStable<StableHashingContext<'a>> + fmt::Debug,\n {\n@@ -142,7 +142,7 @@ where\n     }\n \n     #[inline(always)]\n-    default fn to_fingerprint(&self, tcx: Ctxt) -> Fingerprint {\n+    default fn to_fingerprint(&self, tcx: Tcx) -> Fingerprint {\n         tcx.with_stable_hashing_context(|mut hcx| {\n             let mut hasher = StableHasher::new();\n             self.hash_stable(&mut hcx, &mut hasher);\n@@ -151,12 +151,12 @@ where\n     }\n \n     #[inline(always)]\n-    default fn to_debug_str(&self, _: Ctxt) -> String {\n+    default fn to_debug_str(&self, _: Tcx) -> String {\n         format!(\"{:?}\", *self)\n     }\n \n     #[inline(always)]\n-    default fn recover(_: Ctxt, _: &DepNode<Ctxt::DepKind>) -> Option<Self> {\n+    default fn recover(_: Tcx, _: &DepNode<Tcx::DepKind>) -> Option<Self> {\n         None\n     }\n }\n@@ -166,7 +166,7 @@ where\n /// Information is retrieved by indexing the `DEP_KINDS` array using the integer value\n /// of the `DepKind`. Overall, this allows to implement `DepContext` using this manual\n /// jump table instead of large matches.\n-pub struct DepKindStruct<CTX: DepContext> {\n+pub struct DepKindStruct<Tcx: DepContext> {\n     /// Anonymous queries cannot be replayed from one compiler invocation to the next.\n     /// When their result is needed, it is recomputed. They are useful for fine-grained\n     /// dependency tracking, and caching within one compiler invocation.\n@@ -216,10 +216,10 @@ pub struct DepKindStruct<CTX: DepContext> {\n     /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n     /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n     /// `DefId` in `tcx.def_path_hash_to_def_id`.\n-    pub force_from_dep_node: Option<fn(tcx: CTX, dep_node: DepNode<CTX::DepKind>) -> bool>,\n+    pub force_from_dep_node: Option<fn(tcx: Tcx, dep_node: DepNode<Tcx::DepKind>) -> bool>,\n \n     /// Invoke a query to put the on-disk cached value in memory.\n-    pub try_load_from_on_disk_cache: Option<fn(CTX, DepNode<CTX::DepKind>)>,\n+    pub try_load_from_on_disk_cache: Option<fn(Tcx, DepNode<Tcx::DepKind>)>,\n }\n \n /// A \"work product\" corresponds to a `.o` (or other) file that we"}, {"sha": "d86c0bebdcdf4d2166cabe7918dca9dd925b5fba", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 38, "deletions": 63, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "patch": "@@ -377,9 +377,9 @@ impl<K: DepKind> DepGraph<K> {\n \n     /// Executes something within an \"anonymous\" task, that is, a task the\n     /// `DepNode` of which is determined by the list of inputs it read from.\n-    pub fn with_anon_task<Ctxt: DepContext<DepKind = K>, OP, R>(\n+    pub fn with_anon_task<Tcx: DepContext<DepKind = K>, OP, R>(\n         &self,\n-        cx: Ctxt,\n+        cx: Tcx,\n         dep_kind: K,\n         op: OP,\n     ) -> (R, DepNodeIndex)\n@@ -571,12 +571,12 @@ impl<K: DepKind> DepGraph<K> {\n     /// A node will have an index, when it's already been marked green, or when we can mark it\n     /// green. This function will mark the current task as a reader of the specified node, when\n     /// a node index can be found for that node.\n-    pub fn try_mark_green<Ctxt: QueryContext<DepKind = K>>(\n+    pub fn try_mark_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n-        tcx: Ctxt,\n+        qcx: Qcx,\n         dep_node: &DepNode<K>,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n-        debug_assert!(!tcx.dep_context().is_eval_always(dep_node.kind));\n+        debug_assert!(!qcx.dep_context().is_eval_always(dep_node.kind));\n \n         // Return None if the dep graph is disabled\n         let data = self.data.as_ref()?;\n@@ -592,15 +592,16 @@ impl<K: DepKind> DepGraph<K> {\n                 // in the previous compilation session too, so we can try to\n                 // mark it as green by recursively marking all of its\n                 // dependencies green.\n-                self.try_mark_previous_green(tcx, data, prev_index, &dep_node)\n+                self.try_mark_previous_green(qcx, data, prev_index, &dep_node)\n                     .map(|dep_node_index| (prev_index, dep_node_index))\n             }\n         }\n     }\n \n-    fn try_mark_parent_green<Ctxt: QueryContext<DepKind = K>>(\n+    #[instrument(skip(self, qcx, data, parent_dep_node_index), level = \"debug\")]\n+    fn try_mark_parent_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n-        tcx: Ctxt,\n+        qcx: Qcx,\n         data: &DepGraphData<K>,\n         parent_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode<K>,\n@@ -613,82 +614,60 @@ impl<K: DepKind> DepGraph<K> {\n                 // This dependency has been marked as green before, we are\n                 // still fine and can continue with checking the other\n                 // dependencies.\n-                debug!(\n-                    \"try_mark_previous_green({:?}) --- found dependency {:?} to \\\n-                            be immediately green\",\n-                    dep_node, dep_dep_node,\n-                );\n+                debug!(\"dependency {dep_dep_node:?} was immediately green\");\n                 return Some(());\n             }\n             Some(DepNodeColor::Red) => {\n                 // We found a dependency the value of which has changed\n                 // compared to the previous compilation session. We cannot\n                 // mark the DepNode as green and also don't need to bother\n                 // with checking any of the other dependencies.\n-                debug!(\n-                    \"try_mark_previous_green({:?}) - END - dependency {:?} was immediately red\",\n-                    dep_node, dep_dep_node,\n-                );\n+                debug!(\"dependency {dep_dep_node:?} was immediately red\");\n                 return None;\n             }\n             None => {}\n         }\n \n         // We don't know the state of this dependency. If it isn't\n         // an eval_always node, let's try to mark it green recursively.\n-        if !tcx.dep_context().is_eval_always(dep_dep_node.kind) {\n+        if !qcx.dep_context().is_eval_always(dep_dep_node.kind) {\n             debug!(\n-                \"try_mark_previous_green({:?}) --- state of dependency {:?} ({}) \\\n-                                 is unknown, trying to mark it green\",\n-                dep_node, dep_dep_node, dep_dep_node.hash,\n+                \"state of dependency {:?} ({}) is unknown, trying to mark it green\",\n+                dep_dep_node, dep_dep_node.hash,\n             );\n \n             let node_index =\n-                self.try_mark_previous_green(tcx, data, parent_dep_node_index, dep_dep_node);\n+                self.try_mark_previous_green(qcx, data, parent_dep_node_index, dep_dep_node);\n+\n             if node_index.is_some() {\n-                debug!(\n-                    \"try_mark_previous_green({:?}) --- managed to MARK dependency {:?} as green\",\n-                    dep_node, dep_dep_node\n-                );\n+                debug!(\"managed to MARK dependency {dep_dep_node:?} as green\",);\n                 return Some(());\n             }\n         }\n \n         // We failed to mark it green, so we try to force the query.\n-        debug!(\n-            \"try_mark_previous_green({:?}) --- trying to force dependency {:?}\",\n-            dep_node, dep_dep_node\n-        );\n-        if !tcx.dep_context().try_force_from_dep_node(*dep_dep_node) {\n+        debug!(\"trying to force dependency {dep_dep_node:?}\");\n+        if !qcx.dep_context().try_force_from_dep_node(*dep_dep_node) {\n             // The DepNode could not be forced.\n-            debug!(\n-                \"try_mark_previous_green({:?}) - END - dependency {:?} could not be forced\",\n-                dep_node, dep_dep_node\n-            );\n+            debug!(\"dependency {dep_dep_node:?} could not be forced\");\n             return None;\n         }\n \n         let dep_dep_node_color = data.colors.get(parent_dep_node_index);\n \n         match dep_dep_node_color {\n             Some(DepNodeColor::Green(_)) => {\n-                debug!(\n-                    \"try_mark_previous_green({:?}) --- managed to FORCE dependency {:?} to green\",\n-                    dep_node, dep_dep_node\n-                );\n+                debug!(\"managed to FORCE dependency {dep_dep_node:?} to green\");\n                 return Some(());\n             }\n             Some(DepNodeColor::Red) => {\n-                debug!(\n-                    \"try_mark_previous_green({:?}) - END - dependency {:?} was red after forcing\",\n-                    dep_node, dep_dep_node\n-                );\n+                debug!(\"dependency {dep_dep_node:?} was red after forcing\",);\n                 return None;\n             }\n             None => {}\n         }\n \n-        if !tcx.dep_context().sess().has_errors_or_delayed_span_bugs() {\n+        if !qcx.dep_context().sess().has_errors_or_delayed_span_bugs() {\n             panic!(\"try_mark_previous_green() - Forcing the DepNode should have set its color\")\n         }\n \n@@ -702,38 +681,34 @@ impl<K: DepKind> DepGraph<K> {\n         // invalid state will not be persisted to the\n         // incremental compilation cache because of\n         // compilation errors being present.\n-        debug!(\n-            \"try_mark_previous_green({:?}) - END - dependency {:?} resulted in compilation error\",\n-            dep_node, dep_dep_node\n-        );\n+        debug!(\"dependency {dep_dep_node:?} resulted in compilation error\",);\n         return None;\n     }\n \n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n-    fn try_mark_previous_green<Ctxt: QueryContext<DepKind = K>>(\n+    #[instrument(skip(self, qcx, data, prev_dep_node_index), level = \"debug\")]\n+    fn try_mark_previous_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n-        tcx: Ctxt,\n+        qcx: Qcx,\n         data: &DepGraphData<K>,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode<K>,\n     ) -> Option<DepNodeIndex> {\n-        debug!(\"try_mark_previous_green({:?}) - BEGIN\", dep_node);\n-\n         #[cfg(not(parallel_compiler))]\n         {\n             debug_assert!(!self.dep_node_exists(dep_node));\n             debug_assert!(data.colors.get(prev_dep_node_index).is_none());\n         }\n \n         // We never try to mark eval_always nodes as green\n-        debug_assert!(!tcx.dep_context().is_eval_always(dep_node.kind));\n+        debug_assert!(!qcx.dep_context().is_eval_always(dep_node.kind));\n \n         debug_assert_eq!(data.previous.index_to_node(prev_dep_node_index), *dep_node);\n \n         let prev_deps = data.previous.edge_targets_from(prev_dep_node_index);\n \n         for &dep_dep_node_index in prev_deps {\n-            self.try_mark_parent_green(tcx, data, dep_dep_node_index, dep_node)?\n+            self.try_mark_parent_green(qcx, data, dep_dep_node_index, dep_node)?\n         }\n \n         // If we got here without hitting a `return` that means that all\n@@ -745,7 +720,7 @@ impl<K: DepKind> DepGraph<K> {\n         // We allocating an entry for the node in the current dependency graph and\n         // adding all the appropriate edges imported from the previous graph\n         let dep_node_index = data.current.promote_node_and_deps_to_current(\n-            tcx.dep_context().profiler(),\n+            qcx.dep_context().profiler(),\n             &data.previous,\n             prev_dep_node_index,\n         );\n@@ -754,7 +729,7 @@ impl<K: DepKind> DepGraph<K> {\n \n         // FIXME: Store the fact that a node has diagnostics in a bit in the dep graph somewhere\n         // Maybe store a list on disk and encode this fact in the DepNodeState\n-        let side_effects = tcx.load_side_effects(prev_dep_node_index);\n+        let side_effects = qcx.load_side_effects(prev_dep_node_index);\n \n         #[cfg(not(parallel_compiler))]\n         debug_assert!(\n@@ -765,24 +740,24 @@ impl<K: DepKind> DepGraph<K> {\n         );\n \n         if !side_effects.is_empty() {\n-            self.emit_side_effects(tcx, data, dep_node_index, side_effects);\n+            self.emit_side_effects(qcx, data, dep_node_index, side_effects);\n         }\n \n         // ... and finally storing a \"Green\" entry in the color map.\n         // Multiple threads can all write the same color here\n         data.colors.insert(prev_dep_node_index, DepNodeColor::Green(dep_node_index));\n \n-        debug!(\"try_mark_previous_green({:?}) - END - successfully marked as green\", dep_node);\n+        debug!(\"successfully marked {dep_node:?} as green\");\n         Some(dep_node_index)\n     }\n \n     /// Atomically emits some loaded diagnostics.\n     /// This may be called concurrently on multiple threads for the same dep node.\n     #[cold]\n     #[inline(never)]\n-    fn emit_side_effects<Ctxt: QueryContext<DepKind = K>>(\n+    fn emit_side_effects<Qcx: QueryContext<DepKind = K>>(\n         &self,\n-        tcx: Ctxt,\n+        qcx: Qcx,\n         data: &DepGraphData<K>,\n         dep_node_index: DepNodeIndex,\n         side_effects: QuerySideEffects,\n@@ -794,9 +769,9 @@ impl<K: DepKind> DepGraph<K> {\n             // must process side effects\n \n             // Promote the previous diagnostics to the current session.\n-            tcx.store_side_effects(dep_node_index, side_effects.clone());\n+            qcx.store_side_effects(dep_node_index, side_effects.clone());\n \n-            let handle = tcx.dep_context().sess().diagnostic();\n+            let handle = qcx.dep_context().sess().diagnostic();\n \n             for mut diagnostic in side_effects.diagnostics {\n                 handle.emit_diagnostic(&mut diagnostic);\n@@ -824,7 +799,7 @@ impl<K: DepKind> DepGraph<K> {\n     //\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n-    pub fn exec_cache_promotions<Ctxt: DepContext<DepKind = K>>(&self, tcx: Ctxt) {\n+    pub fn exec_cache_promotions<Tcx: DepContext<DepKind = K>>(&self, tcx: Tcx) {\n         let _prof_timer = tcx.profiler().generic_activity(\"incr_comp_query_cache_promotion\");\n \n         let data = self.data.as_ref().unwrap();"}, {"sha": "e370c6990a41353d9accc9cf09a48f20595cf0b6", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "patch": "@@ -52,9 +52,8 @@ pub trait DepContext: Copy {\n     }\n \n     /// Try to force a dep node to execute and see if it's green.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn try_force_from_dep_node(self, dep_node: DepNode<Self::DepKind>) -> bool {\n-        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n-\n         let cb = self.dep_kind_info(dep_node.kind);\n         if let Some(f) = cb.force_from_dep_node {\n             f(self, dep_node);"}, {"sha": "f40e174b7e79bf3a885843cd7d462fc29fa8f368", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "patch": "@@ -11,7 +11,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use std::fmt::Debug;\n use std::hash::Hash;\n \n-pub trait QueryConfig<CTX: QueryContext> {\n+pub trait QueryConfig<Qcx: QueryContext> {\n     const NAME: &'static str;\n \n     type Key: Eq + Hash + Clone + Debug;\n@@ -21,47 +21,47 @@ pub trait QueryConfig<CTX: QueryContext> {\n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: CTX) -> &'a QueryState<Self::Key>\n+    fn query_state<'a>(tcx: Qcx) -> &'a QueryState<Self::Key>\n     where\n-        CTX: 'a;\n+        Qcx: 'a;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_cache<'a>(tcx: CTX) -> &'a Self::Cache\n+    fn query_cache<'a>(tcx: Qcx) -> &'a Self::Cache\n     where\n-        CTX: 'a;\n+        Qcx: 'a;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn make_vtable(tcx: CTX, key: &Self::Key) -> QueryVTable<CTX, Self::Key, Self::Value>;\n+    fn make_vtable(tcx: Qcx, key: &Self::Key) -> QueryVTable<Qcx, Self::Key, Self::Value>;\n \n-    fn cache_on_disk(tcx: CTX::DepContext, key: &Self::Key) -> bool;\n+    fn cache_on_disk(tcx: Qcx::DepContext, key: &Self::Key) -> bool;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn execute_query(tcx: CTX::DepContext, k: Self::Key) -> Self::Stored;\n+    fn execute_query(tcx: Qcx::DepContext, k: Self::Key) -> Self::Stored;\n }\n \n #[derive(Copy, Clone)]\n-pub struct QueryVTable<CTX: QueryContext, K, V> {\n+pub struct QueryVTable<Qcx: QueryContext, K, V> {\n     pub anon: bool,\n-    pub dep_kind: CTX::DepKind,\n+    pub dep_kind: Qcx::DepKind,\n     pub eval_always: bool,\n     pub depth_limit: bool,\n \n-    pub compute: fn(CTX::DepContext, K) -> V,\n+    pub compute: fn(Qcx::DepContext, K) -> V,\n     pub hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n     pub handle_cycle_error: HandleCycleError,\n     // NOTE: this is also `None` if `cache_on_disk()` returns false, not just if it's unsupported by the query\n-    pub try_load_from_disk: Option<fn(CTX, SerializedDepNodeIndex) -> Option<V>>,\n+    pub try_load_from_disk: Option<fn(Qcx, SerializedDepNodeIndex) -> Option<V>>,\n }\n \n-impl<CTX: QueryContext, K, V> QueryVTable<CTX, K, V> {\n-    pub(crate) fn to_dep_node(&self, tcx: CTX::DepContext, key: &K) -> DepNode<CTX::DepKind>\n+impl<Qcx: QueryContext, K, V> QueryVTable<Qcx, K, V> {\n+    pub(crate) fn to_dep_node(&self, tcx: Qcx::DepContext, key: &K) -> DepNode<Qcx::DepKind>\n     where\n-        K: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n+        K: crate::dep_graph::DepNodeParams<Qcx::DepContext>,\n     {\n         DepNode::construct(tcx, self.dep_kind, key)\n     }\n \n-    pub(crate) fn compute(&self, tcx: CTX::DepContext, key: K) -> V {\n+    pub(crate) fn compute(&self, tcx: Qcx::DepContext, key: K) -> V {\n         (self.compute)(tcx, key)\n     }\n }"}, {"sha": "49bbcf57804596623ed30642d0d837d5ba1ca8af", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "patch": "@@ -596,8 +596,8 @@ pub(crate) fn report_cycle<'a>(\n     cycle_diag.into_diagnostic(&sess.parse_sess.span_diagnostic)\n }\n \n-pub fn print_query_stack<CTX: QueryContext>(\n-    tcx: CTX,\n+pub fn print_query_stack<Qcx: QueryContext>(\n+    qcx: Qcx,\n     mut current_query: Option<QueryJobId>,\n     handler: &Handler,\n     num_frames: Option<usize>,\n@@ -606,7 +606,7 @@ pub fn print_query_stack<CTX: QueryContext>(\n     // a panic hook, which means that the global `Handler` may be in a weird\n     // state if it was responsible for triggering the panic.\n     let mut i = 0;\n-    let query_map = tcx.try_collect_active_jobs();\n+    let query_map = qcx.try_collect_active_jobs();\n \n     while let Some(query) = current_query {\n         if Some(i) == num_frames {"}, {"sha": "f8d93a27d1c2bbbb3ceff184ae2702235eef9387", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 131, "deletions": 127, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "patch": "@@ -62,10 +62,10 @@ where\n         }\n     }\n \n-    pub fn try_collect_active_jobs<CTX: Copy>(\n+    pub fn try_collect_active_jobs<Qcx: Copy>(\n         &self,\n-        tcx: CTX,\n-        make_query: fn(CTX, K) -> QueryStackFrame,\n+        qcx: Qcx,\n+        make_query: fn(Qcx, K) -> QueryStackFrame,\n         jobs: &mut QueryMap,\n     ) -> Option<()> {\n         #[cfg(parallel_compiler)]\n@@ -76,7 +76,7 @@ where\n             for shard in shards.iter() {\n                 for (k, v) in shard.iter() {\n                     if let QueryResult::Started(ref job) = *v {\n-                        let query = make_query(tcx, k.clone());\n+                        let query = make_query(qcx, k.clone());\n                         jobs.insert(job.id, QueryJobInfo { query, job: job.clone() });\n                     }\n                 }\n@@ -90,7 +90,7 @@ where\n             // really hurt much.)\n             for (k, v) in self.active.try_lock()?.iter() {\n                 if let QueryResult::Started(ref job) = *v {\n-                    let query = make_query(tcx, k.clone());\n+                    let query = make_query(qcx, k.clone());\n                     jobs.insert(job.id, QueryJobInfo { query, job: job.clone() });\n                 }\n             }\n@@ -119,31 +119,31 @@ where\n \n #[cold]\n #[inline(never)]\n-fn mk_cycle<CTX, V, R>(\n-    tcx: CTX,\n+fn mk_cycle<Qcx, V, R>(\n+    qcx: Qcx,\n     cycle_error: CycleError,\n     handler: HandleCycleError,\n     cache: &dyn crate::query::QueryStorage<Value = V, Stored = R>,\n ) -> R\n where\n-    CTX: QueryContext,\n-    V: std::fmt::Debug + Value<CTX::DepContext>,\n+    Qcx: QueryContext,\n+    V: std::fmt::Debug + Value<Qcx::DepContext>,\n     R: Clone,\n {\n-    let error = report_cycle(tcx.dep_context().sess(), &cycle_error);\n-    let value = handle_cycle_error(*tcx.dep_context(), &cycle_error, error, handler);\n+    let error = report_cycle(qcx.dep_context().sess(), &cycle_error);\n+    let value = handle_cycle_error(*qcx.dep_context(), &cycle_error, error, handler);\n     cache.store_nocache(value)\n }\n \n-fn handle_cycle_error<CTX, V>(\n-    tcx: CTX,\n+fn handle_cycle_error<Tcx, V>(\n+    tcx: Tcx,\n     cycle_error: &CycleError,\n     mut error: DiagnosticBuilder<'_, ErrorGuaranteed>,\n     handler: HandleCycleError,\n ) -> V\n where\n-    CTX: DepContext,\n-    V: Value<CTX>,\n+    Tcx: DepContext,\n+    V: Value<Tcx>,\n {\n     use HandleCycleError::*;\n     match handler {\n@@ -176,14 +176,14 @@ where\n     /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n-    fn try_start<'b, CTX>(\n-        tcx: &'b CTX,\n+    fn try_start<'b, Qcx>(\n+        qcx: &'b Qcx,\n         state: &'b QueryState<K>,\n         span: Span,\n         key: K,\n     ) -> TryGetJob<'b, K>\n     where\n-        CTX: QueryContext,\n+        Qcx: QueryContext,\n     {\n         #[cfg(parallel_compiler)]\n         let mut state_lock = state.active.get_shard_by_value(&key).lock();\n@@ -193,8 +193,8 @@ where\n \n         match lock.entry(key) {\n             Entry::Vacant(entry) => {\n-                let id = tcx.next_job_id();\n-                let job = tcx.current_query_job();\n+                let id = qcx.next_job_id();\n+                let job = qcx.current_query_job();\n                 let job = QueryJob::new(id, span, job);\n \n                 let key = entry.key().clone();\n@@ -213,8 +213,8 @@ where\n                         // If we are single-threaded we know that we have cycle error,\n                         // so we just return the error.\n                         return TryGetJob::Cycle(id.find_cycle_in_stack(\n-                            tcx.try_collect_active_jobs().unwrap(),\n-                            &tcx.current_query_job(),\n+                            qcx.try_collect_active_jobs().unwrap(),\n+                            &qcx.current_query_job(),\n                             span,\n                         ));\n                     }\n@@ -223,7 +223,7 @@ where\n                         // For parallel queries, we'll block and wait until the query running\n                         // in another thread has completed. Record how long we wait in the\n                         // self-profiler.\n-                        let query_blocked_prof_timer = tcx.dep_context().profiler().query_blocked();\n+                        let query_blocked_prof_timer = qcx.dep_context().profiler().query_blocked();\n \n                         // Get the latch out\n                         let latch = job.latch();\n@@ -232,7 +232,7 @@ where\n \n                         // With parallel queries we might just have to wait on some other\n                         // thread.\n-                        let result = latch.wait_on(tcx.current_query_job(), span);\n+                        let result = latch.wait_on(qcx.current_query_job(), span);\n \n                         match result {\n                             Ok(()) => TryGetJob::JobCompleted(query_blocked_prof_timer),\n@@ -335,16 +335,16 @@ where\n /// which will be used if the query is not in the cache and we need\n /// to compute it.\n #[inline]\n-pub fn try_get_cached<'a, CTX, C, R, OnHit>(\n-    tcx: CTX,\n+pub fn try_get_cached<'a, Tcx, C, R, OnHit>(\n+    tcx: Tcx,\n     cache: &'a C,\n     key: &C::Key,\n     // `on_hit` can be called while holding a lock to the query cache\n     on_hit: OnHit,\n ) -> Result<R, ()>\n where\n     C: QueryCache,\n-    CTX: DepContext,\n+    Tcx: DepContext,\n     OnHit: FnOnce(&C::Stored) -> R,\n {\n     cache.lookup(&key, |value, index| {\n@@ -356,29 +356,29 @@ where\n     })\n }\n \n-fn try_execute_query<CTX, C>(\n-    tcx: CTX,\n+fn try_execute_query<Qcx, C>(\n+    qcx: Qcx,\n     state: &QueryState<C::Key>,\n     cache: &C,\n     span: Span,\n     key: C::Key,\n-    dep_node: Option<DepNode<CTX::DepKind>>,\n-    query: &QueryVTable<CTX, C::Key, C::Value>,\n+    dep_node: Option<DepNode<Qcx::DepKind>>,\n+    query: &QueryVTable<Qcx, C::Key, C::Value>,\n ) -> (C::Stored, Option<DepNodeIndex>)\n where\n     C: QueryCache,\n-    C::Key: Clone + DepNodeParams<CTX::DepContext>,\n-    C::Value: Value<CTX::DepContext>,\n-    CTX: QueryContext,\n+    C::Key: Clone + DepNodeParams<Qcx::DepContext>,\n+    C::Value: Value<Qcx::DepContext>,\n+    Qcx: QueryContext,\n {\n-    match JobOwner::<'_, C::Key>::try_start(&tcx, state, span, key.clone()) {\n+    match JobOwner::<'_, C::Key>::try_start(&qcx, state, span, key.clone()) {\n         TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = execute_job(tcx, key, dep_node, query, job.id);\n+            let (result, dep_node_index) = execute_job(qcx, key, dep_node, query, job.id);\n             let result = job.complete(cache, result, dep_node_index);\n             (result, Some(dep_node_index))\n         }\n         TryGetJob::Cycle(error) => {\n-            let result = mk_cycle(tcx, error, query.handle_cycle_error, cache);\n+            let result = mk_cycle(qcx, error, query.handle_cycle_error, cache);\n             (result, None)\n         }\n         #[cfg(parallel_compiler)]\n@@ -387,8 +387,8 @@ where\n                 .lookup(&key, |value, index| (value.clone(), index))\n                 .unwrap_or_else(|_| panic!(\"value must be in cache after waiting\"));\n \n-            if std::intrinsics::unlikely(tcx.dep_context().profiler().enabled()) {\n-                tcx.dep_context().profiler().query_cache_hit(index.into());\n+            if std::intrinsics::unlikely(qcx.dep_context().profiler().enabled()) {\n+                qcx.dep_context().profiler().query_cache_hit(index.into());\n             }\n             query_blocked_prof_timer.finish_with_query_invocation_id(index.into());\n \n@@ -397,25 +397,25 @@ where\n     }\n }\n \n-fn execute_job<CTX, K, V>(\n-    tcx: CTX,\n+fn execute_job<Qcx, K, V>(\n+    qcx: Qcx,\n     key: K,\n-    mut dep_node_opt: Option<DepNode<CTX::DepKind>>,\n-    query: &QueryVTable<CTX, K, V>,\n+    mut dep_node_opt: Option<DepNode<Qcx::DepKind>>,\n+    query: &QueryVTable<Qcx, K, V>,\n     job_id: QueryJobId,\n ) -> (V, DepNodeIndex)\n where\n-    K: Clone + DepNodeParams<CTX::DepContext>,\n+    K: Clone + DepNodeParams<Qcx::DepContext>,\n     V: Debug,\n-    CTX: QueryContext,\n+    Qcx: QueryContext,\n {\n-    let dep_graph = tcx.dep_context().dep_graph();\n+    let dep_graph = qcx.dep_context().dep_graph();\n \n     // Fast path for when incr. comp. is off.\n     if !dep_graph.is_fully_enabled() {\n-        let prof_timer = tcx.dep_context().profiler().query_provider();\n-        let result = tcx.start_query(job_id, query.depth_limit, None, || {\n-            query.compute(*tcx.dep_context(), key)\n+        let prof_timer = qcx.dep_context().profiler().query_provider();\n+        let result = qcx.start_query(job_id, query.depth_limit, None, || {\n+            query.compute(*qcx.dep_context(), key)\n         });\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -425,33 +425,33 @@ where\n     if !query.anon && !query.eval_always {\n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node =\n-            dep_node_opt.get_or_insert_with(|| query.to_dep_node(*tcx.dep_context(), &key));\n+            dep_node_opt.get_or_insert_with(|| query.to_dep_node(*qcx.dep_context(), &key));\n \n         // The diagnostics for this query will be promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n-        if let Some(ret) = tcx.start_query(job_id, false, None, || {\n-            try_load_from_disk_and_cache_in_memory(tcx, &key, &dep_node, query)\n+        if let Some(ret) = qcx.start_query(job_id, false, None, || {\n+            try_load_from_disk_and_cache_in_memory(qcx, &key, &dep_node, query)\n         }) {\n             return ret;\n         }\n     }\n \n-    let prof_timer = tcx.dep_context().profiler().query_provider();\n+    let prof_timer = qcx.dep_context().profiler().query_provider();\n     let diagnostics = Lock::new(ThinVec::new());\n \n     let (result, dep_node_index) =\n-        tcx.start_query(job_id, query.depth_limit, Some(&diagnostics), || {\n+        qcx.start_query(job_id, query.depth_limit, Some(&diagnostics), || {\n             if query.anon {\n-                return dep_graph.with_anon_task(*tcx.dep_context(), query.dep_kind, || {\n-                    query.compute(*tcx.dep_context(), key)\n+                return dep_graph.with_anon_task(*qcx.dep_context(), query.dep_kind, || {\n+                    query.compute(*qcx.dep_context(), key)\n                 });\n             }\n \n             // `to_dep_node` is expensive for some `DepKind`s.\n             let dep_node =\n-                dep_node_opt.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n+                dep_node_opt.unwrap_or_else(|| query.to_dep_node(*qcx.dep_context(), &key));\n \n-            dep_graph.with_task(dep_node, *tcx.dep_context(), key, query.compute, query.hash_result)\n+            dep_graph.with_task(dep_node, *qcx.dep_context(), key, query.compute, query.hash_result)\n         });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -461,55 +461,55 @@ where\n \n     if std::intrinsics::unlikely(!side_effects.is_empty()) {\n         if query.anon {\n-            tcx.store_side_effects_for_anon_node(dep_node_index, side_effects);\n+            qcx.store_side_effects_for_anon_node(dep_node_index, side_effects);\n         } else {\n-            tcx.store_side_effects(dep_node_index, side_effects);\n+            qcx.store_side_effects(dep_node_index, side_effects);\n         }\n     }\n \n     (result, dep_node_index)\n }\n \n-fn try_load_from_disk_and_cache_in_memory<CTX, K, V>(\n-    tcx: CTX,\n+fn try_load_from_disk_and_cache_in_memory<Qcx, K, V>(\n+    qcx: Qcx,\n     key: &K,\n-    dep_node: &DepNode<CTX::DepKind>,\n-    query: &QueryVTable<CTX, K, V>,\n+    dep_node: &DepNode<Qcx::DepKind>,\n+    query: &QueryVTable<Qcx, K, V>,\n ) -> Option<(V, DepNodeIndex)>\n where\n     K: Clone,\n-    CTX: QueryContext,\n+    Qcx: QueryContext,\n     V: Debug,\n {\n     // Note this function can be called concurrently from the same query\n     // We must ensure that this is handled correctly.\n \n-    let dep_graph = tcx.dep_context().dep_graph();\n-    let (prev_dep_node_index, dep_node_index) = dep_graph.try_mark_green(tcx, &dep_node)?;\n+    let dep_graph = qcx.dep_context().dep_graph();\n+    let (prev_dep_node_index, dep_node_index) = dep_graph.try_mark_green(qcx, &dep_node)?;\n \n     debug_assert!(dep_graph.is_green(dep_node));\n \n     // First we try to load the result from the on-disk cache.\n     // Some things are never cached on disk.\n     if let Some(try_load_from_disk) = query.try_load_from_disk {\n-        let prof_timer = tcx.dep_context().profiler().incr_cache_loading();\n+        let prof_timer = qcx.dep_context().profiler().incr_cache_loading();\n \n         // The call to `with_query_deserialization` enforces that no new `DepNodes`\n         // are created during deserialization. See the docs of that method for more\n         // details.\n         let result =\n-            dep_graph.with_query_deserialization(|| try_load_from_disk(tcx, prev_dep_node_index));\n+            dep_graph.with_query_deserialization(|| try_load_from_disk(qcx, prev_dep_node_index));\n \n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n         if let Some(result) = result {\n             if std::intrinsics::unlikely(\n-                tcx.dep_context().sess().opts.unstable_opts.query_dep_graph,\n+                qcx.dep_context().sess().opts.unstable_opts.query_dep_graph,\n             ) {\n                 dep_graph.mark_debug_loaded_from_disk(*dep_node)\n             }\n \n-            let prev_fingerprint = tcx\n+            let prev_fingerprint = qcx\n                 .dep_context()\n                 .dep_graph()\n                 .prev_fingerprint_of(dep_node)\n@@ -523,9 +523,9 @@ where\n             // give us some coverage of potential bugs though.\n             let try_verify = prev_fingerprint.as_value().1 % 32 == 0;\n             if std::intrinsics::unlikely(\n-                try_verify || tcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n+                try_verify || qcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n             ) {\n-                incremental_verify_ich(*tcx.dep_context(), &result, dep_node, query);\n+                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query);\n             }\n \n             return Some((result, dep_node_index));\n@@ -534,18 +534,18 @@ where\n         // We always expect to find a cached result for things that\n         // can be forced from `DepNode`.\n         debug_assert!(\n-            !tcx.dep_context().fingerprint_style(dep_node.kind).reconstructible(),\n+            !qcx.dep_context().fingerprint_style(dep_node.kind).reconstructible(),\n             \"missing on-disk cache entry for {:?}\",\n             dep_node\n         );\n     }\n \n     // We could not load a result from the on-disk cache, so\n     // recompute.\n-    let prof_timer = tcx.dep_context().profiler().query_provider();\n+    let prof_timer = qcx.dep_context().profiler().query_provider();\n \n     // The dep-graph for this computation is already in-place.\n-    let result = dep_graph.with_ignore(|| query.compute(*tcx.dep_context(), key.clone()));\n+    let result = dep_graph.with_ignore(|| query.compute(*qcx.dep_context(), key.clone()));\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -558,34 +558,38 @@ where\n     //\n     // See issue #82920 for an example of a miscompilation that would get turned into\n     // an ICE by this check\n-    incremental_verify_ich(*tcx.dep_context(), &result, dep_node, query);\n+    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query);\n \n     Some((result, dep_node_index))\n }\n \n-fn incremental_verify_ich<CTX, K, V: Debug>(\n-    tcx: CTX::DepContext,\n+#[instrument(skip(qcx, result, query), level = \"debug\")]\n+fn incremental_verify_ich<Qcx, K, V: Debug>(\n+    qcx: Qcx::DepContext,\n     result: &V,\n-    dep_node: &DepNode<CTX::DepKind>,\n-    query: &QueryVTable<CTX, K, V>,\n+    dep_node: &DepNode<Qcx::DepKind>,\n+    query: &QueryVTable<Qcx, K, V>,\n ) where\n-    CTX: QueryContext,\n+    Qcx: QueryContext,\n {\n     assert!(\n-        tcx.dep_graph().is_green(dep_node),\n+        qcx.dep_graph().is_green(dep_node),\n         \"fingerprint for green query instance not loaded from cache: {:?}\",\n         dep_node,\n     );\n \n-    debug!(\"BEGIN verify_ich({:?})\", dep_node);\n     let new_hash = query.hash_result.map_or(Fingerprint::ZERO, |f| {\n-        tcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n+        qcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n     });\n-    let old_hash = tcx.dep_graph().prev_fingerprint_of(dep_node);\n-    debug!(\"END verify_ich({:?})\", dep_node);\n+\n+    let old_hash = qcx.dep_graph().prev_fingerprint_of(dep_node);\n \n     if Some(new_hash) != old_hash {\n-        incremental_verify_ich_cold(tcx.sess(), DebugArg::from(&dep_node), DebugArg::from(&result));\n+        incremental_verify_ich_failed(\n+            qcx.sess(),\n+            DebugArg::from(&dep_node),\n+            DebugArg::from(&result),\n+        );\n     }\n }\n \n@@ -631,13 +635,7 @@ impl std::fmt::Debug for DebugArg<'_> {\n // different implementations for LLVM to chew on (and filling up the final\n // binary, too).\n #[cold]\n-fn incremental_verify_ich_cold(sess: &Session, dep_node: DebugArg<'_>, result: DebugArg<'_>) {\n-    let run_cmd = if let Some(crate_name) = &sess.opts.crate_name {\n-        format!(\"`cargo clean -p {}` or `cargo clean`\", crate_name)\n-    } else {\n-        \"`cargo clean`\".to_string()\n-    };\n-\n+fn incremental_verify_ich_failed(sess: &Session, dep_node: DebugArg<'_>, result: DebugArg<'_>) {\n     // When we emit an error message and panic, we try to debug-print the `DepNode`\n     // and query result. Unfortunately, this can cause us to run additional queries,\n     // which may result in another fingerprint mismatch while we're in the middle\n@@ -653,6 +651,12 @@ fn incremental_verify_ich_cold(sess: &Session, dep_node: DebugArg<'_>, result: D\n     if old_in_panic {\n         sess.emit_err(crate::error::Reentrant);\n     } else {\n+        let run_cmd = if let Some(crate_name) = &sess.opts.crate_name {\n+            format!(\"`cargo clean -p {}` or `cargo clean`\", crate_name)\n+        } else {\n+            \"`cargo clean`\".to_string()\n+        };\n+\n         sess.emit_err(crate::error::IncrementCompilation {\n             run_cmd,\n             dep_node: format!(\"{:?}\", dep_node),\n@@ -672,14 +676,14 @@ fn incremental_verify_ich_cold(sess: &Session, dep_node: DebugArg<'_>, result: D\n ///\n /// Note: The optimization is only available during incr. comp.\n #[inline(never)]\n-fn ensure_must_run<CTX, K, V>(\n-    tcx: CTX,\n+fn ensure_must_run<Qcx, K, V>(\n+    qcx: Qcx,\n     key: &K,\n-    query: &QueryVTable<CTX, K, V>,\n-) -> (bool, Option<DepNode<CTX::DepKind>>)\n+    query: &QueryVTable<Qcx, K, V>,\n+) -> (bool, Option<DepNode<Qcx::DepKind>>)\n where\n-    K: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n-    CTX: QueryContext,\n+    K: crate::dep_graph::DepNodeParams<Qcx::DepContext>,\n+    Qcx: QueryContext,\n {\n     if query.eval_always {\n         return (true, None);\n@@ -688,10 +692,10 @@ where\n     // Ensuring an anonymous query makes no sense\n     assert!(!query.anon);\n \n-    let dep_node = query.to_dep_node(*tcx.dep_context(), key);\n+    let dep_node = query.to_dep_node(*qcx.dep_context(), key);\n \n-    let dep_graph = tcx.dep_context().dep_graph();\n-    match dep_graph.try_mark_green(tcx, &dep_node) {\n+    let dep_graph = qcx.dep_context().dep_graph();\n+    match dep_graph.try_mark_green(qcx, &dep_node) {\n         None => {\n             // A None return from `try_mark_green` means that this is either\n             // a new dep node or that the dep node has already been marked red.\n@@ -703,7 +707,7 @@ where\n         }\n         Some((_, dep_node_index)) => {\n             dep_graph.read_index(dep_node_index);\n-            tcx.dep_context().profiler().query_cache_hit(dep_node_index.into());\n+            qcx.dep_context().profiler().query_cache_hit(dep_node_index.into());\n             (false, None)\n         }\n     }\n@@ -715,16 +719,16 @@ pub enum QueryMode {\n     Ensure,\n }\n \n-pub fn get_query<Q, CTX>(tcx: CTX, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n+pub fn get_query<Q, Qcx>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n where\n-    Q: QueryConfig<CTX>,\n-    Q::Key: DepNodeParams<CTX::DepContext>,\n-    Q::Value: Value<CTX::DepContext>,\n-    CTX: QueryContext,\n+    Q: QueryConfig<Qcx>,\n+    Q::Key: DepNodeParams<Qcx::DepContext>,\n+    Q::Value: Value<Qcx::DepContext>,\n+    Qcx: QueryContext,\n {\n-    let query = Q::make_vtable(tcx, &key);\n+    let query = Q::make_vtable(qcx, &key);\n     let dep_node = if let QueryMode::Ensure = mode {\n-        let (must_run, dep_node) = ensure_must_run(tcx, &key, &query);\n+        let (must_run, dep_node) = ensure_must_run(qcx, &key, &query);\n         if !must_run {\n             return None;\n         }\n@@ -734,33 +738,33 @@ where\n     };\n \n     let (result, dep_node_index) = try_execute_query(\n-        tcx,\n-        Q::query_state(tcx),\n-        Q::query_cache(tcx),\n+        qcx,\n+        Q::query_state(qcx),\n+        Q::query_cache(qcx),\n         span,\n         key,\n         dep_node,\n         &query,\n     );\n     if let Some(dep_node_index) = dep_node_index {\n-        tcx.dep_context().dep_graph().read_index(dep_node_index)\n+        qcx.dep_context().dep_graph().read_index(dep_node_index)\n     }\n     Some(result)\n }\n \n-pub fn force_query<Q, CTX>(tcx: CTX, key: Q::Key, dep_node: DepNode<CTX::DepKind>)\n+pub fn force_query<Q, Qcx>(qcx: Qcx, key: Q::Key, dep_node: DepNode<Qcx::DepKind>)\n where\n-    Q: QueryConfig<CTX>,\n-    Q::Key: DepNodeParams<CTX::DepContext>,\n-    Q::Value: Value<CTX::DepContext>,\n-    CTX: QueryContext,\n+    Q: QueryConfig<Qcx>,\n+    Q::Key: DepNodeParams<Qcx::DepContext>,\n+    Q::Value: Value<Qcx::DepContext>,\n+    Qcx: QueryContext,\n {\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n-    let cache = Q::query_cache(tcx);\n+    let cache = Q::query_cache(qcx);\n     let cached = cache.lookup(&key, |_, index| {\n-        if std::intrinsics::unlikely(tcx.dep_context().profiler().enabled()) {\n-            tcx.dep_context().profiler().query_cache_hit(index.into());\n+        if std::intrinsics::unlikely(qcx.dep_context().profiler().enabled()) {\n+            qcx.dep_context().profiler().query_cache_hit(index.into());\n         }\n     });\n \n@@ -769,9 +773,9 @@ where\n         Err(()) => {}\n     }\n \n-    let query = Q::make_vtable(tcx, &key);\n-    let state = Q::query_state(tcx);\n+    let query = Q::make_vtable(qcx, &key);\n+    let state = Q::query_state(qcx);\n     debug_assert!(!query.anon);\n \n-    try_execute_query(tcx, state, cache, DUMMY_SP, key, Some(dep_node), &query);\n+    try_execute_query(qcx, state, cache, DUMMY_SP, key, Some(dep_node), &query);\n }"}, {"sha": "214656abed4dfeb3d13c858faeb67eec9db82830", "filename": "compiler/rustc_query_system/src/values.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs?ref=6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "patch": "@@ -1,12 +1,12 @@\n use crate::dep_graph::DepContext;\n use crate::query::QueryInfo;\n \n-pub trait Value<CTX: DepContext>: Sized {\n-    fn from_cycle_error(tcx: CTX, cycle: &[QueryInfo]) -> Self;\n+pub trait Value<Tcx: DepContext>: Sized {\n+    fn from_cycle_error(tcx: Tcx, cycle: &[QueryInfo]) -> Self;\n }\n \n-impl<CTX: DepContext, T> Value<CTX> for T {\n-    default fn from_cycle_error(tcx: CTX, _: &[QueryInfo]) -> T {\n+impl<Tcx: DepContext, T> Value<Tcx> for T {\n+    default fn from_cycle_error(tcx: Tcx, _: &[QueryInfo]) -> T {\n         tcx.sess().abort_if_errors();\n         // Ideally we would use `bug!` here. But bug! is only defined in rustc_middle, and it's\n         // non-trivial to define it earlier."}]}