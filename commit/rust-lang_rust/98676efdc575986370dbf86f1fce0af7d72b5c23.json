{"sha": "98676efdc575986370dbf86f1fce0af7d72b5c23", "node_id": "C_kwDOAAsO6NoAKDk4Njc2ZWZkYzU3NTk4NjM3MGRiZjg2ZjFmY2UwYWY3ZDcyYjVjMjM", "commit": {"author": {"name": "Andrzej G\u0142uszak", "email": "gluszak.andrzej@gmail.com", "date": "2021-09-29T12:04:32Z"}, "committer": {"name": "Andrzej G\u0142uszak", "email": "gluszak.andrzej@gmail.com", "date": "2021-10-17T14:33:14Z"}, "message": "Semantic getter", "tree": {"sha": "1a96ca5bf085b181c26ca9b3cbde4397ab392fc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a96ca5bf085b181c26ca9b3cbde4397ab392fc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98676efdc575986370dbf86f1fce0af7d72b5c23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98676efdc575986370dbf86f1fce0af7d72b5c23", "html_url": "https://github.com/rust-lang/rust/commit/98676efdc575986370dbf86f1fce0af7d72b5c23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98676efdc575986370dbf86f1fce0af7d72b5c23/comments", "author": {"login": "agluszak", "id": 1674445, "node_id": "MDQ6VXNlcjE2NzQ0NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1674445?v=4", "gravatar_id": "", "url": "https://api.github.com/users/agluszak", "html_url": "https://github.com/agluszak", "followers_url": "https://api.github.com/users/agluszak/followers", "following_url": "https://api.github.com/users/agluszak/following{/other_user}", "gists_url": "https://api.github.com/users/agluszak/gists{/gist_id}", "starred_url": "https://api.github.com/users/agluszak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/agluszak/subscriptions", "organizations_url": "https://api.github.com/users/agluszak/orgs", "repos_url": "https://api.github.com/users/agluszak/repos", "events_url": "https://api.github.com/users/agluszak/events{/privacy}", "received_events_url": "https://api.github.com/users/agluszak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "agluszak", "id": 1674445, "node_id": "MDQ6VXNlcjE2NzQ0NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1674445?v=4", "gravatar_id": "", "url": "https://api.github.com/users/agluszak", "html_url": "https://github.com/agluszak", "followers_url": "https://api.github.com/users/agluszak/followers", "following_url": "https://api.github.com/users/agluszak/following{/other_user}", "gists_url": "https://api.github.com/users/agluszak/gists{/gist_id}", "starred_url": "https://api.github.com/users/agluszak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/agluszak/subscriptions", "organizations_url": "https://api.github.com/users/agluszak/orgs", "repos_url": "https://api.github.com/users/agluszak/repos", "events_url": "https://api.github.com/users/agluszak/events{/privacy}", "received_events_url": "https://api.github.com/users/agluszak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c7526d308a8a9c04318c19c5df626723f69ec23", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c7526d308a8a9c04318c19c5df626723f69ec23", "html_url": "https://github.com/rust-lang/rust/commit/6c7526d308a8a9c04318c19c5df626723f69ec23"}], "stats": {"total": 458, "additions": 398, "deletions": 60}, "files": [{"sha": "b088b5df1dc7226156be944f60ac0b143b3d6934", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=98676efdc575986370dbf86f1fce0af7d72b5c23", "patch": "@@ -1574,6 +1574,11 @@ pub struct BuiltinType {\n }\n \n impl BuiltinType {\n+    // FIXME: I'm not sure if it's the best place to put it\n+    pub fn str() -> BuiltinType {\n+        BuiltinType { inner: hir_def::builtin_type::BuiltinType::Str }\n+    }\n+\n     pub fn ty(self, db: &dyn HirDatabase, module: Module) -> Type {\n         let resolver = module.id.resolver(db.upcast());\n         Type::new_with_resolver(db, &resolver, TyBuilder::builtin(self.inner))\n@@ -2263,6 +2268,11 @@ impl Type {\n         Type::new(db, krate, def, ty)\n     }\n \n+    // FIXME: No idea where to put it\n+    pub fn make_slice_of(self) -> Type {\n+        Type { krate: self.krate, env: self.env, ty: TyBuilder::slice(self.ty) }\n+    }\n+\n     pub fn is_unit(&self) -> bool {\n         matches!(self.ty.kind(&Interner), TyKind::Tuple(0, ..))\n     }"}, {"sha": "add0390c9477f4f9627a44e2063149fef7ac863c", "filename": "crates/hir_ty/src/builder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=98676efdc575986370dbf86f1fce0af7d72b5c23", "patch": "@@ -97,6 +97,10 @@ impl TyBuilder<()> {\n         }\n     }\n \n+    pub fn slice(argument: Ty) -> Ty {\n+        TyKind::Slice(argument).intern(&Interner)\n+    }\n+\n     pub fn type_params_subst(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> Substitution {\n         let params = generics(db.upcast(), def.into());\n         params.type_params_subst(db)"}, {"sha": "2690da65beca719beff094a3d196a17433d876ae", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=98676efdc575986370dbf86f1fce0af7d72b5c23", "patch": "@@ -2268,8 +2268,8 @@ fn foo() {\n                                     file_id: FileId(\n                                         1,\n                                     ),\n-                                    full_range: 254..436,\n-                                    focus_range: 293..299,\n+                                    full_range: 276..458,\n+                                    focus_range: 315..321,\n                                     name: \"Future\",\n                                     kind: Trait,\n                                     description: \"pub trait Future\","}, {"sha": "bc8cb2a337797bede780140204524cb6ed4a8b37", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=98676efdc575986370dbf86f1fce0af7d72b5c23", "patch": "@@ -1,11 +1,12 @@\n+use rustc_hash::{FxHashMap, FxHashSet};\n+\n use hir::{HasSource, HirDisplay, Module, ModuleDef, Semantics, TypeInfo};\n use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameRefClass},\n     helpers::SnippetCap,\n     RootDatabase,\n };\n-use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::to_lower_snake_case;\n use syntax::{\n     ast::{\n@@ -17,7 +18,7 @@ use syntax::{\n };\n \n use crate::{\n-    utils::useless_type_special_case,\n+    utils::convert_reference_type,\n     utils::{find_struct_impl, render_snippet, Cursor},\n     AssistContext, AssistId, AssistKind, Assists,\n };\n@@ -424,19 +425,7 @@ fn fn_args(\n     let mut arg_types = Vec::new();\n     for arg in call.arg_list()?.args() {\n         arg_names.push(fn_arg_name(&ctx.sema, &arg));\n-        arg_types.push(match fn_arg_type(ctx, target_module, &arg) {\n-            Some(ty) => {\n-                if !ty.is_empty() && ty.starts_with('&') {\n-                    match useless_type_special_case(\"\", &ty[1..].to_owned()) {\n-                        Some((new_ty, _)) => new_ty,\n-                        None => ty,\n-                    }\n-                } else {\n-                    ty\n-                }\n-            }\n-            None => String::from(\"_\"),\n-        });\n+        arg_types.push(fn_arg_type(ctx, target_module, &arg));\n     }\n     deduplicate_arg_names(&mut arg_names);\n     let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| {\n@@ -511,17 +500,31 @@ fn fn_arg_name(sema: &Semantics<RootDatabase>, arg_expr: &ast::Expr) -> String {\n     }\n }\n \n-fn fn_arg_type(\n-    ctx: &AssistContext,\n-    target_module: hir::Module,\n-    fn_arg: &ast::Expr,\n-) -> Option<String> {\n-    let ty = ctx.sema.type_of_expr(fn_arg)?.adjusted();\n-    if ty.is_unknown() {\n-        return None;\n+fn fn_arg_type(ctx: &AssistContext, target_module: hir::Module, fn_arg: &ast::Expr) -> String {\n+    fn maybe_displayed_type(\n+        ctx: &AssistContext,\n+        target_module: hir::Module,\n+        fn_arg: &ast::Expr,\n+    ) -> Option<String> {\n+        let ty = ctx.sema.type_of_expr(fn_arg)?.adjusted();\n+        if ty.is_unknown() {\n+            return None;\n+        }\n+\n+        if ty.is_reference() || ty.is_mutable_reference() {\n+            convert_reference_type(\n+                ty.strip_references(),\n+                ctx,\n+                ctx.sema.scope(fn_arg.syntax()).krate(),\n+            )\n+            .map(|conversion| conversion.convert_type(ctx.db()))\n+            .or_else(|| ty.display_source_code(ctx.db(), target_module.into()).ok())\n+        } else {\n+            ty.display_source_code(ctx.db(), target_module.into()).ok()\n+        }\n     }\n \n-    ty.display_source_code(ctx.db(), target_module.into()).ok()\n+    maybe_displayed_type(ctx, target_module, fn_arg).unwrap_or_else(|| String::from(\"_\"))\n }\n \n /// Returns the position inside the current mod or file"}, {"sha": "ba0bc7fdd943e516a414a83ded583b2096bcd497", "filename": "crates/ide_assists/src/handlers/generate_getter.rs", "status": "modified", "additions": 167, "deletions": 9, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs?ref=98676efdc575986370dbf86f1fce0af7d72b5c23", "patch": "@@ -2,8 +2,7 @@ use stdx::{format_to, to_lower_snake_case};\n use syntax::ast::{self, AstNode, HasName, HasVisibility};\n \n use crate::{\n-    utils::useless_type_special_case,\n-    utils::{find_impl_block_end, find_struct_impl, generate_impl_text},\n+    utils::{convert_reference_type, find_impl_block_end, find_struct_impl, generate_impl_text},\n     AssistContext, AssistId, AssistKind, Assists, GroupLabel,\n };\n \n@@ -12,20 +11,35 @@ use crate::{\n // Generate a getter method.\n //\n // ```\n+// # //- minicore: as_ref\n+// # pub struct String;\n+// # impl AsRef<str> for String {\n+// #     fn as_ref(&self) -> &str {\n+// #         \"\"\n+// #     }\n+// # }\n+// #\n // struct Person {\n //     nam$0e: String,\n // }\n // ```\n // ->\n // ```\n+// # pub struct String;\n+// # impl AsRef<str> for String {\n+// #     fn as_ref(&self) -> &str {\n+// #         \"\"\n+// #     }\n+// # }\n+// #\n // struct Person {\n //     name: String,\n // }\n //\n // impl Person {\n //     /// Get a reference to the person's name.\n //     fn $0name(&self) -> &str {\n-//         self.name.as_str()\n+//         self.name.as_ref()\n //     }\n // }\n // ```\n@@ -98,9 +112,23 @@ pub(crate) fn generate_getter_impl(\n \n             let vis = strukt.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n             let (ty, body) = if mutable {\n-                (format!(\"&mut {}\", field_ty), format!(\"&mut self.{}\", field_name))\n+                (\n+                    format!(\"&mut {}\", field_ty.to_string()),\n+                    format!(\"&mut self.{}\", field_name.to_string()),\n+                )\n             } else {\n-                useless_type_special_case(&field_name.to_string(), &field_ty.to_string())\n+                ctx.sema\n+                    .resolve_type(&field_ty)\n+                    .and_then(|ty| {\n+                        convert_reference_type(ty, ctx, ctx.sema.scope(field_ty.syntax()).krate())\n+                    })\n+                    .map(|conversion| {\n+                        cov_mark::hit!(convert_reference_type);\n+                        (\n+                            conversion.convert_type(ctx.db()),\n+                            conversion.getter(field_name.to_string()),\n+                        )\n+                    })\n                     .unwrap_or_else(|| (format!(\"&{}\", field_ty), format!(\"&self.{}\", field_name)))\n             };\n \n@@ -284,30 +312,113 @@ impl Context {\n     }\n \n     #[test]\n-    fn test_special_cases() {\n-        cov_mark::check!(useless_type_special_case);\n+    fn test_not_a_special_case() {\n+        cov_mark::check_count!(convert_reference_type, 0);\n+        // Fake string which doesn't implement AsRef<str>\n         check_assist(\n             generate_getter,\n             r#\"\n+pub struct String;\n+\n struct S { foo: $0String }\n \"#,\n             r#\"\n+pub struct String;\n+\n+struct S { foo: String }\n+\n+impl S {\n+    /// Get a reference to the s's foo.\n+    fn $0foo(&self) -> &String {\n+        &self.foo\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_convert_reference_type() {\n+        cov_mark::check_count!(convert_reference_type, 6);\n+\n+        // Copy\n+        check_assist(\n+            generate_getter,\n+            r#\"\n+//- minicore: copy\n+struct S { foo: $0bool }\n+\"#,\n+            r#\"\n+struct S { foo: bool }\n+\n+impl S {\n+    /// Get a reference to the s's foo.\n+    fn $0foo(&self) -> bool {\n+        self.foo\n+    }\n+}\n+\"#,\n+        );\n+\n+        // AsRef<str>\n+        check_assist(\n+            generate_getter,\n+            r#\"\n+//- minicore: as_ref\n+pub struct String;\n+impl AsRef<str> for String {\n+    fn as_ref(&self) -> &str {\n+        \"\"\n+    }\n+}\n+\n+struct S { foo: $0String }\n+\"#,\n+            r#\"\n+pub struct String;\n+impl AsRef<str> for String {\n+    fn as_ref(&self) -> &str {\n+        \"\"\n+    }\n+}\n+\n struct S { foo: String }\n \n impl S {\n     /// Get a reference to the s's foo.\n     fn $0foo(&self) -> &str {\n-        self.foo.as_str()\n+        self.foo.as_ref()\n     }\n }\n \"#,\n         );\n+\n+        // AsRef<T>\n         check_assist(\n             generate_getter,\n             r#\"\n+//- minicore: as_ref\n+struct Sweets;\n+\n+pub struct Box<T>(T);\n+impl<T> AsRef<T> for Box<T> {\n+    fn as_ref(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n struct S { foo: $0Box<Sweets> }\n \"#,\n             r#\"\n+struct Sweets;\n+\n+pub struct Box<T>(T);\n+impl<T> AsRef<T> for Box<T> {\n+    fn as_ref(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n struct S { foo: Box<Sweets> }\n \n impl S {\n@@ -318,28 +429,52 @@ impl S {\n }\n \"#,\n         );\n+\n+        // AsRef<[T]>\n         check_assist(\n             generate_getter,\n             r#\"\n+//- minicore: as_ref\n+pub struct Vec<T>;\n+impl<T> AsRef<[T]> for Vec<T> {\n+    fn as_ref(&self) -> &[T] {\n+        &[]\n+    }\n+}\n+\n struct S { foo: $0Vec<()> }\n \"#,\n             r#\"\n+pub struct Vec<T>;\n+impl<T> AsRef<[T]> for Vec<T> {\n+    fn as_ref(&self) -> &[T] {\n+        &[]\n+    }\n+}\n+\n struct S { foo: Vec<()> }\n \n impl S {\n     /// Get a reference to the s's foo.\n     fn $0foo(&self) -> &[()] {\n-        self.foo.as_slice()\n+        self.foo.as_ref()\n     }\n }\n \"#,\n         );\n+\n+        // Option\n         check_assist(\n             generate_getter,\n             r#\"\n+//- minicore: option\n+struct Failure;\n+\n struct S { foo: $0Option<Failure> }\n \"#,\n             r#\"\n+struct Failure;\n+\n struct S { foo: Option<Failure> }\n \n impl S {\n@@ -348,6 +483,29 @@ impl S {\n         self.foo.as_ref()\n     }\n }\n+\"#,\n+        );\n+\n+        // Result\n+        check_assist(\n+            generate_getter,\n+            r#\"\n+//- minicore: result\n+struct Context {\n+    dat$0a: Result<bool, i32>,\n+}\n+\"#,\n+            r#\"\n+struct Context {\n+    data: Result<bool, i32>,\n+}\n+\n+impl Context {\n+    /// Get a reference to the context's data.\n+    fn $0data(&self) -> Result<&bool, &i32> {\n+        self.data.as_ref()\n+    }\n+}\n \"#,\n         );\n     }"}, {"sha": "75586f62bbe9f0fc3e632bbb43feac2b074cc91d", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=98676efdc575986370dbf86f1fce0af7d72b5c23", "patch": "@@ -951,19 +951,34 @@ fn doctest_generate_getter() {\n     check_doc_test(\n         \"generate_getter\",\n         r#####\"\n+//- minicore: as_ref\n+pub struct String;\n+impl AsRef<str> for String {\n+    fn as_ref(&self) -> &str {\n+        \"\"\n+    }\n+}\n+\n struct Person {\n     nam$0e: String,\n }\n \"#####,\n         r#####\"\n+pub struct String;\n+impl AsRef<str> for String {\n+    fn as_ref(&self) -> &str {\n+        \"\"\n+    }\n+}\n+\n struct Person {\n     name: String,\n }\n \n impl Person {\n     /// Get a reference to the person's name.\n     fn $0name(&self) -> &str {\n-        self.name.as_str()\n+        self.name.as_ref()\n     }\n }\n \"#####,"}, {"sha": "e58f1fd50f50568d2b523c19eeeaadc5a5bf4d8b", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 153, "deletions": 22, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=98676efdc575986370dbf86f1fce0af7d72b5c23", "patch": "@@ -1,13 +1,14 @@\n //! Assorted functions shared by several assists.\n \n-pub(crate) mod suggest_name;\n-mod gen_trait_fn_body;\n-\n use std::ops;\n \n-use hir::HasSource;\n-use ide_db::{helpers::SnippetCap, path_transform::PathTransform, RootDatabase};\n use itertools::Itertools;\n+\n+pub(crate) use gen_trait_fn_body::gen_trait_fn_body;\n+use hir::db::HirDatabase;\n+use hir::{Crate, HasSource, HirDisplay};\n+use ide_db::helpers::FamousDefs;\n+use ide_db::{helpers::SnippetCap, path_transform::PathTransform, RootDatabase};\n use stdx::format_to;\n use syntax::{\n     ast::{\n@@ -23,7 +24,8 @@ use syntax::{\n \n use crate::assist_context::{AssistBuilder, AssistContext};\n \n-pub(crate) use gen_trait_fn_body::gen_trait_fn_body;\n+pub(crate) mod suggest_name;\n+mod gen_trait_fn_body;\n \n pub(crate) fn unwrap_trivial_block(block_expr: ast::BlockExpr) -> ast::Expr {\n     extract_trivial_expression(&block_expr)\n@@ -507,27 +509,156 @@ pub(crate) fn add_method_to_adt(\n     builder.insert(start_offset, buf);\n }\n \n-pub fn useless_type_special_case(field_name: &str, field_ty: &String) -> Option<(String, String)> {\n-    if field_ty == \"String\" {\n-        cov_mark::hit!(useless_type_special_case);\n-        return Some((\"&str\".to_string(), format!(\"self.{}.as_str()\", field_name)));\n-    }\n-    if let Some(arg) = ty_ctor(field_ty, \"Vec\") {\n-        return Some((format!(\"&[{}]\", arg), format!(\"self.{}.as_slice()\", field_name)));\n+#[derive(Debug)]\n+pub(crate) struct ReferenceConversion {\n+    conversion: ReferenceConversionType,\n+    ty: hir::Type,\n+}\n+\n+#[derive(Debug)]\n+enum ReferenceConversionType {\n+    // reference can be stripped if the type is Copy\n+    Copy,\n+    // &String -> &str\n+    AsRefStr,\n+    // &Vec<T> -> &[T]\n+    AsRefSlice,\n+    // &Box<T> -> &T\n+    Dereferenced,\n+    // &Option<T> -> Option<&T>\n+    Option,\n+    // &Result<T, E> -> Result<&T, &E>\n+    Result,\n+}\n+\n+impl ReferenceConversion {\n+    pub(crate) fn convert_type(&self, db: &dyn HirDatabase) -> String {\n+        match self.conversion {\n+            ReferenceConversionType::Copy => self.ty.display(db).to_string(),\n+            ReferenceConversionType::AsRefStr => \"&str\".to_string(),\n+            ReferenceConversionType::AsRefSlice => {\n+                let type_argument_name =\n+                    self.ty.type_arguments().next().unwrap().display(db).to_string();\n+                format!(\"&[{}]\", type_argument_name)\n+            }\n+            ReferenceConversionType::Dereferenced => {\n+                let type_argument_name =\n+                    self.ty.type_arguments().next().unwrap().display(db).to_string();\n+                format!(\"&{}\", type_argument_name)\n+            }\n+            ReferenceConversionType::Option => {\n+                let type_argument_name =\n+                    self.ty.type_arguments().next().unwrap().display(db).to_string();\n+                format!(\"Option<&{}>\", type_argument_name)\n+            }\n+            ReferenceConversionType::Result => {\n+                let mut type_arguments = self.ty.type_arguments();\n+                let first_type_argument_name =\n+                    type_arguments.next().unwrap().display(db).to_string();\n+                let second_type_argument_name =\n+                    type_arguments.next().unwrap().display(db).to_string();\n+                format!(\"Result<&{}, &{}>\", first_type_argument_name, second_type_argument_name)\n+            }\n+        }\n     }\n-    if let Some(arg) = ty_ctor(field_ty, \"Box\") {\n-        return Some((format!(\"&{}\", arg), format!(\"self.{}.as_ref()\", field_name)));\n+\n+    pub(crate) fn getter(&self, field_name: String) -> String {\n+        match self.conversion {\n+            ReferenceConversionType::Copy => format!(\"self.{}\", field_name),\n+            ReferenceConversionType::AsRefStr\n+            | ReferenceConversionType::AsRefSlice\n+            | ReferenceConversionType::Dereferenced\n+            | ReferenceConversionType::Option\n+            | ReferenceConversionType::Result => format!(\"self.{}.as_ref()\", field_name),\n+        }\n     }\n-    if let Some(arg) = ty_ctor(field_ty, \"Option\") {\n-        return Some((format!(\"Option<&{}>\", arg), format!(\"self.{}.as_ref()\", field_name)));\n+}\n+\n+// FIXME: It should return a new hir::Type, but currently constructing new types is too cumbersome\n+//        and all users of this function operate on string type names, so they can do the conversion\n+//        itself themselves.\n+//        Another problem is that it probably shouldn't take AssistContext as a parameter, as\n+//        it should be usable not only in assists.\n+pub(crate) fn convert_reference_type(\n+    ty: hir::Type,\n+    ctx: &AssistContext,\n+    krate: Option<Crate>,\n+) -> Option<ReferenceConversion> {\n+    let sema = &ctx.sema;\n+    let db = sema.db;\n+    let famous_defs = &FamousDefs(sema, krate);\n+\n+    handle_copy(&ty, db)\n+        .or_else(|| handle_as_ref_str(&ty, db, famous_defs, ctx))\n+        .or_else(|| handle_as_ref_slice(&ty, db, famous_defs))\n+        .or_else(|| handle_dereferenced(&ty, db, famous_defs))\n+        .or_else(|| handle_option_as_ref(&ty, db, famous_defs))\n+        .or_else(|| handle_result_as_ref(&ty, db, famous_defs))\n+        .map(|conversion| ReferenceConversion { ty, conversion })\n+}\n+\n+fn handle_copy(ty: &hir::Type, db: &dyn HirDatabase) -> Option<ReferenceConversionType> {\n+    ty.is_copy(db).then(|| ReferenceConversionType::Copy)\n+}\n+\n+fn handle_as_ref_str(\n+    ty: &hir::Type,\n+    db: &dyn HirDatabase,\n+    famous_defs: &FamousDefs,\n+    ctx: &AssistContext,\n+) -> Option<ReferenceConversionType> {\n+    let module = ctx.sema.to_module_def(ctx.file_id())?;\n+    let str_type = hir::BuiltinType::str().ty(db, module);\n+\n+    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, &[str_type])\n+        .then(|| ReferenceConversionType::AsRefStr)\n+}\n+\n+fn handle_as_ref_slice(\n+    ty: &hir::Type,\n+    db: &dyn HirDatabase,\n+    famous_defs: &FamousDefs,\n+) -> Option<ReferenceConversionType> {\n+    let type_argument = ty.type_arguments().next()?;\n+    let slice_type = type_argument.make_slice_of();\n+\n+    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, &[slice_type])\n+        .then(|| ReferenceConversionType::AsRefSlice)\n+}\n+\n+fn handle_dereferenced(\n+    ty: &hir::Type,\n+    db: &dyn HirDatabase,\n+    famous_defs: &FamousDefs,\n+) -> Option<ReferenceConversionType> {\n+    let type_argument = ty.type_arguments().next()?;\n+\n+    ty.impls_trait(db, famous_defs.core_convert_AsRef()?, &[type_argument])\n+        .then(|| ReferenceConversionType::Dereferenced)\n+}\n+\n+fn handle_option_as_ref(\n+    ty: &hir::Type,\n+    db: &dyn HirDatabase,\n+    famous_defs: &FamousDefs,\n+) -> Option<ReferenceConversionType> {\n+    if ty.as_adt() == famous_defs.core_option_Option()?.ty(db).as_adt() {\n+        Some(ReferenceConversionType::Option)\n+    } else {\n+        None\n     }\n-    None\n }\n \n-// FIXME: This should rely on semantic info.\n-fn ty_ctor(ty: &String, ctor: &str) -> Option<String> {\n-    let res = ty.to_string().strip_prefix(ctor)?.strip_prefix('<')?.strip_suffix('>')?.to_string();\n-    Some(res)\n+fn handle_result_as_ref(\n+    ty: &hir::Type,\n+    db: &dyn HirDatabase,\n+    famous_defs: &FamousDefs,\n+) -> Option<ReferenceConversionType> {\n+    if ty.as_adt() == famous_defs.core_result_Result()?.ty(db).as_adt() {\n+        Some(ReferenceConversionType::Result)\n+    } else {\n+        None\n+    }\n }\n \n pub(crate) fn get_methods(items: &ast::AssocItemList) -> Vec<ast::Fn> {"}, {"sha": "b5e3907cfa746e2bc6d402f699457f434d812b54", "filename": "crates/ide_db/src/helpers/famous_defs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Ffamous_defs.rs?ref=98676efdc575986370dbf86f1fce0af7d72b5c23", "patch": "@@ -68,10 +68,18 @@ impl FamousDefs<'_, '_> {\n         self.find_trait(\"core:ops:Deref\")\n     }\n \n+    pub fn core_convert_AsRef(&self) -> Option<Trait> {\n+        self.find_trait(\"core:convert:AsRef\")\n+    }\n+\n     pub fn core_ops_ControlFlow(&self) -> Option<Enum> {\n         self.find_enum(\"core:ops:ControlFlow\")\n     }\n \n+    pub fn core_marker_Copy(&self) -> Option<Trait> {\n+        self.find_trait(\"core:marker:Copy\")\n+    }\n+\n     pub fn alloc(&self) -> Option<Crate> {\n         self.find_crate(\"alloc\")\n     }"}, {"sha": "731b8b73a341a5b88090b37976f15ec68b0c9744", "filename": "crates/test_utils/src/minicore.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98676efdc575986370dbf86f1fce0af7d72b5c23/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fminicore.rs?ref=98676efdc575986370dbf86f1fce0af7d72b5c23", "patch": "@@ -35,6 +35,7 @@\n //!     fmt: result\n //!     bool_impl: option, fn\n //!     add:\n+//!     as_ref: sized\n \n pub mod marker {\n     // region:sized\n@@ -113,8 +114,9 @@ pub mod clone {\n }\n // endregion:clone\n \n-// region:from\n+\n pub mod convert {\n+    // region:from\n     pub trait From<T>: Sized {\n         fn from(_: T) -> Self;\n     }\n@@ -136,8 +138,14 @@ pub mod convert {\n             t\n         }\n     }\n+    // endregion:from\n+\n+    // region:as_ref\n+    pub trait AsRef<T: ?Sized> {\n+        fn as_ref(&self) -> &T;\n+    }\n+    // endregion:as_ref\n }\n-// endregion:from\n \n pub mod ops {\n     // region:coerce_unsized\n@@ -609,6 +617,7 @@ pub mod prelude {\n             cmp::{Eq, PartialEq},               // :eq\n             cmp::{Ord, PartialOrd},             // :ord\n             convert::{From, Into},              // :from\n+            convert::AsRef,                     // :as_ref\n             default::Default,                   // :default\n             iter::{IntoIterator, Iterator},     // :iterator\n             macros::builtin::derive,            // :derive"}]}