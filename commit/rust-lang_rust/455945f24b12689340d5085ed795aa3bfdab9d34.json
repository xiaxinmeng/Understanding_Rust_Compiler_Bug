{"sha": "455945f24b12689340d5085ed795aa3bfdab9d34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NTk0NWYyNGIxMjY4OTM0MGQ1MDg1ZWQ3OTVhYTNiZmRhYjlkMzQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-09-28T14:59:19Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-09-30T18:56:49Z"}, "message": "Remove HIR based const qualification", "tree": {"sha": "db42731c7660f1525e3fc86f5ba14ec7e8f1a02c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db42731c7660f1525e3fc86f5ba14ec7e8f1a02c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/455945f24b12689340d5085ed795aa3bfdab9d34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/455945f24b12689340d5085ed795aa3bfdab9d34", "html_url": "https://github.com/rust-lang/rust/commit/455945f24b12689340d5085ed795aa3bfdab9d34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/455945f24b12689340d5085ed795aa3bfdab9d34/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26", "url": "https://api.github.com/repos/rust-lang/rust/commits/22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26", "html_url": "https://github.com/rust-lang/rust/commit/22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26"}], "stats": {"total": 982, "additions": 66, "deletions": 916}, "files": [{"sha": "d8b84fd473744efaf8217529f1288c6771cd6102", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -20,7 +20,6 @@ use crate::ty::{self, DefIdTree, TyCtxt, adjustment};\n use crate::hir::{self, PatKind};\n use std::rc::Rc;\n use syntax_pos::Span;\n-use crate::util::nodemap::ItemLocalSet;\n \n ///////////////////////////////////////////////////////////////////////////\n // The Delegate trait\n@@ -261,9 +260,6 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// - `param_env` --- parameter environment for trait lookups (esp. pertaining to `Copy`)\n     /// - `region_scope_tree` --- region scope tree for the code being analyzed\n     /// - `tables` --- typeck results for the code being analyzed\n-    /// - `rvalue_promotable_map` --- if you care about rvalue promotion, then provide\n-    ///   the map here (it can be computed with `tcx.rvalue_promotable_map(def_id)`).\n-    ///   `None` means that rvalues will be given more conservative lifetimes.\n     ///\n     /// See also `with_infer`, which is used *during* typeck.\n     pub fn new(\n@@ -273,15 +269,13 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         region_scope_tree: &'a region::ScopeTree,\n         tables: &'a ty::TypeckTables<'tcx>,\n-        rvalue_promotable_map: Option<&'tcx ItemLocalSet>,\n     ) -> Self {\n         ExprUseVisitor {\n             mc: mc::MemCategorizationContext::new(tcx,\n                                                   param_env,\n                                                   body_owner,\n                                                   region_scope_tree,\n-                                                  tables,\n-                                                  rvalue_promotable_map),\n+                                                  tables),\n             delegate,\n             param_env,\n         }\n@@ -317,16 +311,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             let param_ty = return_if_err!(self.mc.pat_ty_adjusted(&param.pat));\n             debug!(\"consume_body: param_ty = {:?}\", param_ty);\n \n-            let fn_body_scope_r =\n-                self.tcx().mk_region(ty::ReScope(\n-                    region::Scope {\n-                        id: body.value.hir_id.local_id,\n-                        data: region::ScopeData::Node\n-                }));\n             let param_cmt = Rc::new(self.mc.cat_rvalue(\n                 param.hir_id,\n                 param.pat.span,\n-                fn_body_scope_r, // Parameters live only as long as the fn body.\n                 param_ty));\n \n             self.walk_irrefutable_pat(param_cmt, &param.pat);"}, {"sha": "edfcc30a749cf2a1e1e48c84c7b2e990e248c928", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 11, "deletions": 55, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -79,12 +79,11 @@ use std::fmt;\n use std::hash::{Hash, Hasher};\n use rustc_data_structures::fx::FxIndexMap;\n use std::rc::Rc;\n-use crate::util::nodemap::ItemLocalSet;\n \n #[derive(Clone, Debug, PartialEq)]\n pub enum Categorization<'tcx> {\n-    Rvalue(ty::Region<'tcx>),            // temporary val, argument is its scope\n-    ThreadLocal(ty::Region<'tcx>),       // value that cannot move, but still restricted in scope\n+    Rvalue,                              // temporary val\n+    ThreadLocal,                         // value that cannot move, but still restricted in scope\n     StaticItem,\n     Upvar(Upvar),                        // upvar referenced by closure env\n     Local(hir::HirId),                   // local variable\n@@ -219,7 +218,6 @@ pub struct MemCategorizationContext<'a, 'tcx> {\n     pub upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n     pub region_scope_tree: &'a region::ScopeTree,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n-    rvalue_promotable_map: Option<&'tcx ItemLocalSet>,\n     infcx: Option<&'a InferCtxt<'a, 'tcx>>,\n }\n \n@@ -335,15 +333,13 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         body_owner: DefId,\n         region_scope_tree: &'a region::ScopeTree,\n         tables: &'a ty::TypeckTables<'tcx>,\n-        rvalue_promotable_map: Option<&'tcx ItemLocalSet>,\n     ) -> MemCategorizationContext<'a, 'tcx> {\n         MemCategorizationContext {\n             tcx,\n             body_owner,\n             upvars: tcx.upvars(body_owner),\n             region_scope_tree,\n             tables,\n-            rvalue_promotable_map,\n             infcx: None,\n             param_env,\n         }\n@@ -369,19 +365,12 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ) -> MemCategorizationContext<'a, 'tcx> {\n         let tcx = infcx.tcx;\n \n-        // Subtle: we can't do rvalue promotion analysis until the\n-        // typeck phase is complete, which means that you can't trust\n-        // the rvalue lifetimes that result, but that's ok, since we\n-        // don't need to know those during type inference.\n-        let rvalue_promotable_map = None;\n-\n         MemCategorizationContext {\n             tcx,\n             body_owner,\n             upvars: tcx.upvars(body_owner),\n             region_scope_tree,\n             tables,\n-            rvalue_promotable_map,\n             infcx: Some(infcx),\n             param_env,\n         }\n@@ -664,8 +653,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                     .any(|attr| attr.check_name(sym::thread_local));\n \n                 let cat = if is_thread_local {\n-                    let re = self.temporary_scope(hir_id.local_id);\n-                    Categorization::ThreadLocal(re)\n+                    Categorization::ThreadLocal\n                 } else {\n                     Categorization::StaticItem\n                 };\n@@ -876,16 +864,6 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         ret\n     }\n \n-    /// Returns the lifetime of a temporary created by expr with id `id`.\n-    /// This could be `'static` if `id` is part of a constant expression.\n-    pub fn temporary_scope(&self, id: hir::ItemLocalId) -> ty::Region<'tcx> {\n-        let scope = self.region_scope_tree.temporary_scope(id);\n-        self.tcx.mk_region(match scope {\n-            Some(scope) => ty::ReScope(scope),\n-            None => ty::ReStatic\n-        })\n-    }\n-\n     pub fn cat_rvalue_node(&self,\n                            hir_id: hir::HirId,\n                            span: Span,\n@@ -894,41 +872,19 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         debug!(\"cat_rvalue_node(id={:?}, span={:?}, expr_ty={:?})\",\n                hir_id, span, expr_ty);\n \n-        let promotable = self.rvalue_promotable_map.as_ref().map(|m| m.contains(&hir_id.local_id))\n-                                                            .unwrap_or(false);\n-\n-        debug!(\"cat_rvalue_node: promotable = {:?}\", promotable);\n-\n-        // Always promote `[T; 0]` (even when e.g., borrowed mutably).\n-        let promotable = match expr_ty.kind {\n-            ty::Array(_, len) if len.try_eval_usize(self.tcx, self.param_env) == Some(0) => true,\n-            _ => promotable,\n-        };\n-\n-        debug!(\"cat_rvalue_node: promotable = {:?} (2)\", promotable);\n-\n-        // Compute maximum lifetime of this rvalue. This is 'static if\n-        // we can promote to a constant, otherwise equal to enclosing temp\n-        // lifetime.\n-        let re = if promotable {\n-            self.tcx.lifetimes.re_static\n-        } else {\n-            self.temporary_scope(hir_id.local_id)\n-        };\n-        let ret = self.cat_rvalue(hir_id, span, re, expr_ty);\n+        let ret = self.cat_rvalue(hir_id, span, expr_ty);\n         debug!(\"cat_rvalue_node ret {:?}\", ret);\n         ret\n     }\n \n     pub fn cat_rvalue(&self,\n                       cmt_hir_id: hir::HirId,\n                       span: Span,\n-                      temp_scope: ty::Region<'tcx>,\n                       expr_ty: Ty<'tcx>) -> cmt_<'tcx> {\n         let ret = cmt_ {\n             hir_id: cmt_hir_id,\n             span:span,\n-            cat:Categorization::Rvalue(temp_scope),\n+            cat:Categorization::Rvalue,\n             mutbl:McDeclared,\n             ty:expr_ty,\n             note: NoteNone\n@@ -1376,9 +1332,9 @@ impl<'tcx> cmt_<'tcx> {\n         //! determines how long the value in `self` remains live.\n \n         match self.cat {\n-            Categorization::Rvalue(..) |\n+            Categorization::Rvalue |\n             Categorization::StaticItem |\n-            Categorization::ThreadLocal(..) |\n+            Categorization::ThreadLocal |\n             Categorization::Local(..) |\n             Categorization::Deref(_, UnsafePtr(..)) |\n             Categorization::Deref(_, BorrowedPtr(..)) |\n@@ -1409,8 +1365,8 @@ impl<'tcx> cmt_<'tcx> {\n                 b.freely_aliasable()\n             }\n \n-            Categorization::Rvalue(..) |\n-            Categorization::ThreadLocal(..) |\n+            Categorization::Rvalue |\n+            Categorization::ThreadLocal |\n             Categorization::Local(..) |\n             Categorization::Upvar(..) |\n             Categorization::Deref(_, UnsafePtr(..)) => { // yes, it's aliasable, but...\n@@ -1457,10 +1413,10 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::StaticItem => {\n                 \"static item\".into()\n             }\n-            Categorization::ThreadLocal(..) => {\n+            Categorization::ThreadLocal => {\n                 \"thread-local static item\".into()\n             }\n-            Categorization::Rvalue(..) => {\n+            Categorization::Rvalue => {\n                 \"non-place\".into()\n             }\n             Categorization::Local(vid) => {"}, {"sha": "c95652f274e36540a24fd5f2f24fe04957588363", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -94,6 +94,7 @@ rustc_queries! {\n         /// of the MIR qualify_consts pass. The actual meaning of\n         /// the value isn't known except to the pass itself.\n         query mir_const_qualif(key: DefId) -> (u8, &'tcx BitSet<mir::Local>) {\n+            desc { |tcx| \"const checking `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }\n \n@@ -530,19 +531,6 @@ rustc_queries! {\n \n     TypeChecking {\n         query trait_of_item(_: DefId) -> Option<DefId> {}\n-        query const_is_rvalue_promotable_to_static(key: DefId) -> bool {\n-            desc { |tcx|\n-                \"const checking if rvalue is promotable to static `{}`\",\n-                tcx.def_path_str(key)\n-            }\n-            cache_on_disk_if { true }\n-        }\n-        query rvalue_promotable_map(key: DefId) -> &'tcx ItemLocalSet {\n-            desc { |tcx|\n-                \"checking which parts of `{}` are promotable to static\",\n-                tcx.def_path_str(key)\n-            }\n-        }\n     }\n \n     Codegen {"}, {"sha": "4279ca8c3daf65f5210be3d9f4cdf770c305b23d", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -37,7 +37,7 @@ use crate::ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt, AdtSizedConst\n use crate::ty::steal::Steal;\n use crate::ty::util::NeedsDrop;\n use crate::ty::subst::SubstsRef;\n-use crate::util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n+use crate::util::nodemap::{DefIdSet, DefIdMap};\n use crate::util::common::ErrorReported;\n use crate::util::profiling::ProfileCategory::*;\n "}, {"sha": "5f6c4629b090c5fd5e4c76c9debde5f4f9466106", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -916,9 +916,8 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n \n     time(sess, \"misc checking 2\", || {\n         parallel!({\n-            time(sess, \"rvalue promotion + match checking\", || {\n+            time(sess, \"match checking\", || {\n                 tcx.par_body_owners(|def_id| {\n-                    tcx.ensure().const_is_rvalue_promotable_to_static(def_id);\n                     tcx.ensure().check_match(def_id);\n                 });\n             });"}, {"sha": "0f80540b11ea3dbac019318bc286c0394b910631", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -154,9 +154,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     rendered_const => { cdata.get_rendered_const(def_id.index) }\n     impl_parent => { cdata.get_parent_impl(def_id.index) }\n     trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n-    const_is_rvalue_promotable_to_static => {\n-        cdata.const_is_rvalue_promotable_to_static(def_id.index)\n-    }\n     is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n \n     dylib_dependency_formats => { cdata.get_dylib_dependency_formats(tcx) }"}, {"sha": "da0c7493b5c68c12d1bb47f8477599ce1031c5a0", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -915,14 +915,6 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn const_is_rvalue_promotable_to_static(&self, id: DefIndex) -> bool {\n-        match self.entry(id).kind {\n-            EntryKind::AssocConst(_, data, _) |\n-            EntryKind::Const(data, _) => data.ast_promotable,\n-            _ => bug!(),\n-        }\n-    }\n-\n     pub fn is_item_mir_available(&self, id: DefIndex) -> bool {\n         !self.is_proc_macro(id) &&\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()"}, {"sha": "4ed6954d8fb3a9ba247477e9c9ef5e9270fea1e6", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -861,18 +861,11 @@ impl EncodeContext<'tcx> {\n \n         let kind = match trait_item.kind {\n             ty::AssocKind::Const => {\n-                let const_qualif =\n-                    if let hir::TraitItemKind::Const(_, Some(body)) = ast_item.kind {\n-                        self.const_qualif(0, body)\n-                    } else {\n-                        ConstQualif { mir: 0, ast_promotable: false }\n-                    };\n-\n                 let rendered =\n                     hir::print::to_string(self.tcx.hir(), |s| s.print_trait_item(ast_item));\n                 let rendered_const = self.lazy(RenderedConst(rendered));\n \n-                EntryKind::AssocConst(container, const_qualif, rendered_const)\n+                EntryKind::AssocConst(container, ConstQualif { mir: 0 }, rendered_const)\n             }\n             ty::AssocKind::Method => {\n                 let fn_data = if let hir::TraitItemKind::Method(method_sig, m) = &ast_item.kind {\n@@ -946,13 +939,6 @@ impl EncodeContext<'tcx> {\n         !self.tcx.sess.opts.output_types.should_codegen()\n     }\n \n-    fn const_qualif(&self, mir: u8, body_id: hir::BodyId) -> ConstQualif {\n-        let body_owner_def_id = self.tcx.hir().body_owner_def_id(body_id);\n-        let ast_promotable = self.tcx.const_is_rvalue_promotable_to_static(body_owner_def_id);\n-\n-        ConstQualif { mir, ast_promotable }\n-    }\n-\n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n         debug!(\"EncodeContext::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -974,7 +960,7 @@ impl EncodeContext<'tcx> {\n                     let mir = self.tcx.at(ast_item.span).mir_const_qualif(def_id).0;\n \n                     EntryKind::AssocConst(container,\n-                        self.const_qualif(mir, body_id),\n+                        ConstQualif { mir },\n                         self.encode_rendered_const_for_body(body_id))\n                 } else {\n                     bug!()\n@@ -1123,7 +1109,7 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Const(_, body_id) => {\n                 let mir = tcx.at(item.span).mir_const_qualif(def_id).0;\n                 EntryKind::Const(\n-                    self.const_qualif(mir, body_id),\n+                    ConstQualif { mir },\n                     self.encode_rendered_const_for_body(body_id)\n                 )\n             }\n@@ -1475,7 +1461,7 @@ impl EncodeContext<'tcx> {\n         let mir = tcx.mir_const_qualif(def_id).0;\n \n         Entry {\n-            kind: EntryKind::Const(self.const_qualif(mir, body_id), const_data),\n+            kind: EntryKind::Const(ConstQualif { mir }, const_data),\n             visibility: self.lazy(ty::Visibility::Public),\n             span: self.lazy(tcx.def_span(def_id)),\n             attributes: Lazy::empty(),"}, {"sha": "4fe9c466cb6dafa0dd568526de2edfe856a1c14f", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -274,7 +274,6 @@ pub enum EntryKind<'tcx> {\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable)]\n pub struct ConstQualif {\n     pub mir: u8,\n-    pub ast_promotable: bool,\n }\n \n /// Contains a constant which has been rendered to a String."}, {"sha": "6c7958fb365dd1ddac040a0b202583642a59a1e4", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -19,12 +19,10 @@ use rustc::ty::query::Providers;\n pub mod error_codes;\n \n pub mod ast_validation;\n-pub mod rvalue_promotion;\n pub mod hir_stats;\n pub mod layout_test;\n pub mod loops;\n \n pub fn provide(providers: &mut Providers<'_>) {\n-    rvalue_promotion::provide(providers);\n     loops::provide(providers);\n }"}, {"sha": "a93ca7847d68a9597366d1b657621429f557ce16", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "removed", "additions": 0, "deletions": 658, "changes": 658, "blob_url": "https://github.com/rust-lang/rust/blob/22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=22bc9e1d9ca49ee4f5cd953088ab09c238a6dd26", "patch": "@@ -1,658 +0,0 @@\n-// Verifies that the types and values of const and static items\n-// are safe. The rules enforced by this module are:\n-//\n-// - For each *mutable* static item, it checks that its **type**:\n-//     - doesn't have a destructor\n-//     - doesn't own a box\n-//\n-// - For each *immutable* static item, it checks that its **value**:\n-//       - doesn't own a box\n-//       - doesn't contain a struct literal or a call to an enum variant / struct constructor where\n-//           - the type of the struct/enum has a dtor\n-//\n-// Rules Enforced Elsewhere:\n-// - It's not possible to take the address of a static item with unsafe interior. This is enforced\n-// by borrowck::gather_loans\n-\n-use rustc::ty::cast::CastTy;\n-use rustc::hir::def::{Res, DefKind, CtorKind};\n-use rustc::hir::def_id::DefId;\n-use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::query::Providers;\n-use rustc::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc::util::nodemap::{ItemLocalSet, HirIdSet};\n-use rustc::hir;\n-use syntax::symbol::sym;\n-use syntax_pos::{Span, DUMMY_SP};\n-use log::debug;\n-use Promotability::*;\n-use std::ops::{BitAnd, BitAndAssign, BitOr};\n-\n-pub fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers {\n-        rvalue_promotable_map,\n-        const_is_rvalue_promotable_to_static,\n-        ..*providers\n-    };\n-}\n-\n-fn const_is_rvalue_promotable_to_static(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    assert!(def_id.is_local());\n-\n-    let hir_id = tcx.hir().as_local_hir_id(def_id)\n-        .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n-    let body_id = tcx.hir().body_owned_by(hir_id);\n-    tcx.rvalue_promotable_map(def_id).contains(&body_id.hir_id.local_id)\n-}\n-\n-fn rvalue_promotable_map(tcx: TyCtxt<'_>, def_id: DefId) -> &ItemLocalSet {\n-    let outer_def_id = tcx.closure_base_def_id(def_id);\n-    if outer_def_id != def_id {\n-        return tcx.rvalue_promotable_map(outer_def_id);\n-    }\n-\n-    let mut visitor = CheckCrateVisitor {\n-        tcx,\n-        tables: &ty::TypeckTables::empty(None),\n-        in_fn: false,\n-        in_static: false,\n-        mut_rvalue_borrows: Default::default(),\n-        param_env: ty::ParamEnv::empty(),\n-        identity_substs: InternalSubsts::empty(),\n-        result: ItemLocalSet::default(),\n-    };\n-\n-    // `def_id` should be a `Body` owner\n-    let hir_id = tcx.hir().as_local_hir_id(def_id)\n-        .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n-    let body_id = tcx.hir().body_owned_by(hir_id);\n-    let _ = visitor.check_nested_body(body_id);\n-\n-    tcx.arena.alloc(visitor.result)\n-}\n-\n-struct CheckCrateVisitor<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    in_fn: bool,\n-    in_static: bool,\n-    mut_rvalue_borrows: HirIdSet,\n-    param_env: ty::ParamEnv<'tcx>,\n-    identity_substs: SubstsRef<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n-    result: ItemLocalSet,\n-}\n-\n-#[must_use]\n-#[derive(Debug, Clone, Copy, PartialEq)]\n-enum Promotability {\n-    Promotable,\n-    NotPromotable\n-}\n-\n-impl BitAnd for Promotability {\n-    type Output = Self;\n-\n-    fn bitand(self, rhs: Self) -> Self {\n-        match (self, rhs) {\n-            (Promotable, Promotable) => Promotable,\n-            _ => NotPromotable,\n-        }\n-    }\n-}\n-\n-impl BitAndAssign for Promotability {\n-    fn bitand_assign(&mut self, rhs: Self) {\n-        *self = *self & rhs\n-    }\n-}\n-\n-impl BitOr for Promotability {\n-    type Output = Self;\n-\n-    fn bitor(self, rhs: Self) -> Self {\n-        match (self, rhs) {\n-            (NotPromotable, NotPromotable) => NotPromotable,\n-            _ => Promotable,\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n-    // Returns true iff all the values of the type are promotable.\n-    fn type_promotability(&mut self, ty: Ty<'tcx>) -> Promotability {\n-        debug!(\"type_promotability({})\", ty);\n-\n-        if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) &&\n-            !ty.needs_drop(self.tcx, self.param_env) {\n-            Promotable\n-        } else {\n-            NotPromotable\n-        }\n-    }\n-\n-    fn handle_const_fn_call(\n-        &mut self,\n-        def_id: DefId,\n-    ) -> Promotability {\n-        if self.tcx.is_promotable_const_fn(def_id) {\n-            Promotable\n-        } else {\n-            NotPromotable\n-        }\n-    }\n-\n-    /// While the `ExprUseVisitor` walks, we will identify which\n-    /// expressions are borrowed, and insert their IDs into this\n-    /// table. Actually, we insert the \"borrow-id\", which is normally\n-    /// the ID of the expression being borrowed: but in the case of\n-    /// `ref mut` borrows, the `id` of the pattern is\n-    /// inserted. Therefore, later we remove that entry from the table\n-    /// and transfer it over to the value being matched. This will\n-    /// then prevent said value from being promoted.\n-    fn remove_mut_rvalue_borrow(&mut self, pat: &hir::Pat) -> bool {\n-        let mut any_removed = false;\n-        pat.walk(|p| {\n-            any_removed |= self.mut_rvalue_borrows.remove(&p.hir_id);\n-            true\n-        });\n-        any_removed\n-    }\n-}\n-\n-impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n-    fn check_nested_body(&mut self, body_id: hir::BodyId) -> Promotability {\n-        let item_id = self.tcx.hir().body_owner(body_id);\n-        let item_def_id = self.tcx.hir().local_def_id(item_id);\n-\n-        let outer_in_fn = self.in_fn;\n-        let outer_tables = self.tables;\n-        let outer_param_env = self.param_env;\n-        let outer_identity_substs = self.identity_substs;\n-\n-        self.in_fn = false;\n-        self.in_static = false;\n-\n-        match self.tcx.hir().body_owner_kind(item_id) {\n-            hir::BodyOwnerKind::Closure |\n-            hir::BodyOwnerKind::Fn => self.in_fn = true,\n-            hir::BodyOwnerKind::Static(_) => self.in_static = true,\n-            _ => {}\n-        };\n-\n-\n-        self.tables = self.tcx.typeck_tables_of(item_def_id);\n-        self.param_env = self.tcx.param_env(item_def_id);\n-        self.identity_substs = InternalSubsts::identity_for_item(self.tcx, item_def_id);\n-\n-        let body = self.tcx.hir().body(body_id);\n-\n-        let tcx = self.tcx;\n-        let param_env = self.param_env;\n-        let region_scope_tree = self.tcx.region_scope_tree(item_def_id);\n-        let tables = self.tables;\n-        euv::ExprUseVisitor::new(\n-            self,\n-            tcx,\n-            item_def_id,\n-            param_env,\n-            &region_scope_tree,\n-            tables,\n-            None,\n-        ).consume_body(body);\n-\n-        let body_promotable = self.check_expr(&body.value);\n-        self.in_fn = outer_in_fn;\n-        self.tables = outer_tables;\n-        self.param_env = outer_param_env;\n-        self.identity_substs = outer_identity_substs;\n-        body_promotable\n-    }\n-\n-    fn check_stmt(&mut self, stmt: &'tcx hir::Stmt) -> Promotability {\n-        match stmt.kind {\n-            hir::StmtKind::Local(ref local) => {\n-                if self.remove_mut_rvalue_borrow(&local.pat) {\n-                    if let Some(init) = &local.init {\n-                        self.mut_rvalue_borrows.insert(init.hir_id);\n-                    }\n-                }\n-\n-                if let Some(ref expr) = local.init {\n-                    let _ = self.check_expr(&expr);\n-                }\n-                NotPromotable\n-            }\n-            // Item statements are allowed\n-            hir::StmtKind::Item(..) => Promotable,\n-            hir::StmtKind::Expr(ref box_expr) |\n-            hir::StmtKind::Semi(ref box_expr) => {\n-                let _ = self.check_expr(box_expr);\n-                NotPromotable\n-            }\n-        }\n-    }\n-\n-    fn check_expr(&mut self, ex: &'tcx hir::Expr) -> Promotability {\n-        let node_ty = self.tables.node_type(ex.hir_id);\n-        let mut outer = check_expr_kind(self, ex, node_ty);\n-        outer &= check_adjustments(self, ex);\n-\n-        // Handle borrows on (or inside the autorefs of) this expression.\n-        if self.mut_rvalue_borrows.remove(&ex.hir_id) {\n-            outer = NotPromotable\n-        }\n-\n-        if outer == Promotable {\n-            self.result.insert(ex.hir_id.local_id);\n-        }\n-        outer\n-    }\n-\n-    fn check_block(&mut self, block: &'tcx hir::Block) -> Promotability {\n-        let mut iter_result = Promotable;\n-        for index in block.stmts.iter() {\n-            iter_result &= self.check_stmt(index);\n-        }\n-        match block.expr {\n-            Some(ref box_expr) => iter_result & self.check_expr(&*box_expr),\n-            None => iter_result,\n-        }\n-    }\n-}\n-\n-/// This function is used to enforce the constraints on\n-/// const/static items. It walks through the *value*\n-/// of the item walking down the expression and evaluating\n-/// every nested expression. If the expression is not part\n-/// of a const/static item, it is qualified for promotion\n-/// instead of producing errors.\n-fn check_expr_kind<'a, 'tcx>(\n-    v: &mut CheckCrateVisitor<'a, 'tcx>,\n-    e: &'tcx hir::Expr, node_ty: Ty<'tcx>) -> Promotability {\n-\n-    let ty_result = match node_ty.kind {\n-        ty::Adt(def, _) if def.has_dtor(v.tcx) => {\n-            NotPromotable\n-        }\n-        _ => Promotable\n-    };\n-\n-    let kind_result = match e.kind {\n-        hir::ExprKind::Box(ref expr) => {\n-            let _ = v.check_expr(&expr);\n-            NotPromotable\n-        }\n-        hir::ExprKind::Unary(op, ref expr) => {\n-            let expr_promotability = v.check_expr(expr);\n-            if v.tables.is_method_call(e) || op == hir::UnDeref {\n-                return NotPromotable;\n-            }\n-            expr_promotability\n-        }\n-        hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-            let lefty = v.check_expr(lhs);\n-            let righty = v.check_expr(rhs);\n-            if v.tables.is_method_call(e) {\n-                return NotPromotable;\n-            }\n-            match v.tables.node_type(lhs.hir_id).kind {\n-                ty::RawPtr(_) | ty::FnPtr(..) => {\n-                    assert!(op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne ||\n-                            op.node == hir::BinOpKind::Le || op.node == hir::BinOpKind::Lt ||\n-                            op.node == hir::BinOpKind::Ge || op.node == hir::BinOpKind::Gt);\n-\n-                    NotPromotable\n-                }\n-                _ => lefty & righty\n-            }\n-        }\n-        hir::ExprKind::Cast(ref from, _) => {\n-            let expr_promotability = v.check_expr(from);\n-            debug!(\"checking const cast(id={})\", from.hir_id);\n-            let cast_in = CastTy::from_ty(v.tables.expr_ty(from));\n-            let cast_out = CastTy::from_ty(v.tables.expr_ty(e));\n-            match (cast_in, cast_out) {\n-                (Some(CastTy::FnPtr), Some(CastTy::Int(_))) |\n-                (Some(CastTy::Ptr(_)), Some(CastTy::Int(_))) => NotPromotable,\n-                (_, _) => expr_promotability\n-            }\n-        }\n-        hir::ExprKind::Path(ref qpath) => {\n-            let res = v.tables.qpath_res(qpath, e.hir_id);\n-            match res {\n-                Res::Def(DefKind::Ctor(..), _)\n-                | Res::Def(DefKind::Fn, _)\n-                | Res::Def(DefKind::Method, _)\n-                | Res::SelfCtor(..) =>\n-                    Promotable,\n-\n-                // References to a static that are themselves within a static\n-                // are inherently promotable with the exception\n-                //  of \"#[thread_local]\" statics, which may not\n-                // outlive the current function\n-                Res::Def(DefKind::Static, did) => {\n-\n-                    if v.in_static {\n-                        for attr in &v.tcx.get_attrs(did)[..] {\n-                            if attr.check_name(sym::thread_local) {\n-                                debug!(\"reference to `Static(id={:?})` is unpromotable \\\n-                                        due to a `#[thread_local]` attribute\", did);\n-                                return NotPromotable;\n-                            }\n-                        }\n-                        Promotable\n-                    } else {\n-                        debug!(\"reference to `Static(id={:?})` is unpromotable as it is not \\\n-                                referenced from a static\", did);\n-                        NotPromotable\n-                    }\n-                }\n-\n-                Res::Def(DefKind::Const, did) |\n-                Res::Def(DefKind::AssocConst, did) => {\n-                    let promotable = if v.tcx.trait_of_item(did).is_some() {\n-                        // Don't peek inside trait associated constants.\n-                        NotPromotable\n-                    } else if v.tcx.at(e.span).const_is_rvalue_promotable_to_static(did) {\n-                        Promotable\n-                    } else {\n-                        NotPromotable\n-                    };\n-                    // Just in case the type is more specific than the definition,\n-                    // e.g., impl associated const with type parameters, check it.\n-                    // Also, trait associated consts are relaxed by this.\n-                    promotable | v.type_promotability(node_ty)\n-                }\n-                _ => NotPromotable\n-            }\n-        }\n-        hir::ExprKind::Call(ref callee, ref hirvec) => {\n-            let mut call_result = v.check_expr(callee);\n-            for index in hirvec.iter() {\n-                call_result &= v.check_expr(index);\n-            }\n-            let mut callee = &**callee;\n-            loop {\n-                callee = match callee.kind {\n-                    hir::ExprKind::Block(ref block, _) => match block.expr {\n-                        Some(ref tail) => &tail,\n-                        None => break\n-                    },\n-                    _ => break\n-                };\n-            }\n-            // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n-            let def = if let hir::ExprKind::Path(ref qpath) = callee.kind {\n-                v.tables.qpath_res(qpath, callee.hir_id)\n-            } else {\n-                Res::Err\n-            };\n-            let def_result = match def {\n-                Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) |\n-                Res::SelfCtor(..) => Promotable,\n-                Res::Def(DefKind::Fn, did) => v.handle_const_fn_call(did),\n-                Res::Def(DefKind::Method, did) => {\n-                    match v.tcx.associated_item(did).container {\n-                        ty::ImplContainer(_) => v.handle_const_fn_call(did),\n-                        ty::TraitContainer(_) => NotPromotable,\n-                    }\n-                }\n-                _ => NotPromotable,\n-            };\n-            def_result & call_result\n-        }\n-        hir::ExprKind::MethodCall(ref _pathsegment, ref _span, ref hirvec) => {\n-            let mut method_call_result = Promotable;\n-            for index in hirvec.iter() {\n-                method_call_result &= v.check_expr(index);\n-            }\n-            if let Some(def_id) = v.tables.type_dependent_def_id(e.hir_id) {\n-                match v.tcx.associated_item(def_id).container {\n-                    ty::ImplContainer(_) => method_call_result & v.handle_const_fn_call(def_id),\n-                    ty::TraitContainer(_) => NotPromotable,\n-                }\n-            } else {\n-                v.tcx.sess.delay_span_bug(e.span, \"no type-dependent def for method call\");\n-                NotPromotable\n-            }\n-        }\n-        hir::ExprKind::Struct(ref _qpath, ref hirvec, ref option_expr) => {\n-            let mut struct_result = Promotable;\n-            for index in hirvec.iter() {\n-                struct_result &= v.check_expr(&index.expr);\n-            }\n-            if let Some(ref expr) = *option_expr {\n-                struct_result &= v.check_expr(&expr);\n-            }\n-            if let ty::Adt(adt, ..) = v.tables.expr_ty(e).kind {\n-                // unsafe_cell_type doesn't necessarily exist with no_core\n-                if Some(adt.did) == v.tcx.lang_items().unsafe_cell_type() {\n-                    return NotPromotable;\n-                }\n-            }\n-            struct_result\n-        }\n-\n-        hir::ExprKind::Lit(_) |\n-        hir::ExprKind::Err => Promotable,\n-\n-        hir::ExprKind::AddrOf(_, ref expr) |\n-        hir::ExprKind::Repeat(ref expr, _) |\n-        hir::ExprKind::Type(ref expr, _) |\n-        hir::ExprKind::DropTemps(ref expr) => {\n-            v.check_expr(&expr)\n-        }\n-\n-        hir::ExprKind::Closure(_capture_clause, ref _box_fn_decl,\n-                               body_id, _span, _option_generator_movability) => {\n-            let nested_body_promotable = v.check_nested_body(body_id);\n-            // Paths in constant contexts cannot refer to local variables,\n-            // as there are none, and thus closures can't have upvars there.\n-            let closure_def_id = v.tcx.hir().local_def_id(e.hir_id);\n-            if !v.tcx.upvars(closure_def_id).map_or(true, |v| v.is_empty()) {\n-                NotPromotable\n-            } else {\n-                nested_body_promotable\n-            }\n-        }\n-\n-        hir::ExprKind::Field(ref expr, _ident) => {\n-            let expr_promotability = v.check_expr(&expr);\n-            if let Some(def) = v.tables.expr_ty(expr).ty_adt_def() {\n-                if def.is_union() {\n-                    return NotPromotable;\n-                }\n-            }\n-            expr_promotability\n-        }\n-\n-        hir::ExprKind::Block(ref box_block, ref _option_label) => {\n-            v.check_block(box_block)\n-        }\n-\n-        hir::ExprKind::Index(ref lhs, ref rhs) => {\n-            let lefty = v.check_expr(lhs);\n-            let righty = v.check_expr(rhs);\n-            if v.tables.is_method_call(e) {\n-                return NotPromotable;\n-            }\n-            lefty & righty\n-        }\n-\n-        hir::ExprKind::Array(ref hirvec) => {\n-            let mut array_result = Promotable;\n-            for index in hirvec.iter() {\n-                array_result &= v.check_expr(index);\n-            }\n-            array_result\n-        }\n-\n-        hir::ExprKind::Tup(ref hirvec) => {\n-            let mut tup_result = Promotable;\n-            for index in hirvec.iter() {\n-                tup_result &= v.check_expr(index);\n-            }\n-            tup_result\n-        }\n-\n-        // Conditional control flow (possible to implement).\n-        hir::ExprKind::Match(ref expr, ref arms, ref _match_source) => {\n-            // Compute the most demanding borrow from all the arms'\n-            // patterns and set that on the discriminator.\n-            if arms.iter().fold(false, |_, arm| v.remove_mut_rvalue_borrow(&arm.pat)) {\n-                v.mut_rvalue_borrows.insert(expr.hir_id);\n-            }\n-\n-            let _ = v.check_expr(expr);\n-            for index in arms.iter() {\n-                let _ = v.check_expr(&*index.body);\n-                if let Some(hir::Guard::If(ref expr)) = index.guard {\n-                    let _ = v.check_expr(&expr);\n-                }\n-            }\n-            NotPromotable\n-        }\n-\n-        hir::ExprKind::Loop(ref box_block, ref _option_label, ref _loop_source) => {\n-            let _ = v.check_block(box_block);\n-            NotPromotable\n-        }\n-\n-        // More control flow (also not very meaningful).\n-        hir::ExprKind::Break(_, ref option_expr) | hir::ExprKind::Ret(ref option_expr) => {\n-            if let Some(ref expr) = *option_expr {\n-                 let _ = v.check_expr(&expr);\n-            }\n-            NotPromotable\n-        }\n-\n-        hir::ExprKind::Continue(_) => {\n-            NotPromotable\n-        }\n-\n-        // Generator expressions\n-        hir::ExprKind::Yield(ref expr, _) => {\n-            let _ = v.check_expr(&expr);\n-            NotPromotable\n-        }\n-\n-        // Expressions with side-effects.\n-        hir::ExprKind::AssignOp(_, ref lhs, ref rhs) | hir::ExprKind::Assign(ref lhs, ref rhs) => {\n-            let _ = v.check_expr(lhs);\n-            let _ = v.check_expr(rhs);\n-            NotPromotable\n-        }\n-\n-        hir::ExprKind::InlineAsm(ref _inline_asm, ref hirvec_lhs, ref hirvec_rhs) => {\n-            for index in hirvec_lhs.iter().chain(hirvec_rhs.iter()) {\n-                let _ = v.check_expr(index);\n-            }\n-            NotPromotable\n-        }\n-    };\n-    ty_result & kind_result\n-}\n-\n-/// Checks the adjustments of an expression.\n-fn check_adjustments<'a, 'tcx>(\n-    v: &mut CheckCrateVisitor<'a, 'tcx>,\n-    e: &hir::Expr) -> Promotability {\n-    use rustc::ty::adjustment::*;\n-\n-    let mut adjustments = v.tables.expr_adjustments(e).iter().peekable();\n-    while let Some(adjustment) = adjustments.next() {\n-        match adjustment.kind {\n-            Adjust::NeverToAny |\n-            Adjust::Pointer(_) |\n-            Adjust::Borrow(_) => {}\n-\n-            Adjust::Deref(_) => {\n-                if let Some(next_adjustment) = adjustments.peek() {\n-                    if let Adjust::Borrow(_) = next_adjustment.kind {\n-                        continue;\n-                    }\n-                }\n-                return NotPromotable;\n-            }\n-        }\n-    }\n-    Promotable\n-}\n-\n-impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n-    fn consume(&mut self,\n-               _consume_id: hir::HirId,\n-               _consume_span: Span,\n-               _cmt: &mc::cmt_<'_>,\n-               _mode: euv::ConsumeMode) {}\n-\n-    fn borrow(&mut self,\n-              borrow_id: hir::HirId,\n-              _borrow_span: Span,\n-              cmt: &mc::cmt_<'tcx>,\n-              _loan_region: ty::Region<'tcx>,\n-              bk: ty::BorrowKind,\n-              loan_cause: euv::LoanCause) {\n-        debug!(\n-            \"borrow(borrow_id={:?}, cmt={:?}, bk={:?}, loan_cause={:?})\",\n-            borrow_id,\n-            cmt,\n-            bk,\n-            loan_cause,\n-        );\n-\n-        // Kind of hacky, but we allow Unsafe coercions in constants.\n-        // These occur when we convert a &T or *T to a *U, as well as\n-        // when making a thin pointer (e.g., `*T`) into a fat pointer\n-        // (e.g., `*Trait`).\n-        if let euv::LoanCause::AutoUnsafe = loan_cause {\n-            return;\n-        }\n-\n-        let mut cur = cmt;\n-        loop {\n-            match cur.cat {\n-                Categorization::ThreadLocal(..) |\n-                Categorization::Rvalue(..) => {\n-                    if loan_cause == euv::MatchDiscriminant {\n-                        // Ignore the dummy immutable borrow created by EUV.\n-                        break;\n-                    }\n-                    if bk.to_mutbl_lossy() == hir::MutMutable {\n-                        self.mut_rvalue_borrows.insert(borrow_id);\n-                    }\n-                    break;\n-                }\n-                Categorization::StaticItem => {\n-                    break;\n-                }\n-                Categorization::Deref(ref cmt, _) |\n-                Categorization::Downcast(ref cmt, _) |\n-                Categorization::Interior(ref cmt, _) => {\n-                    cur = cmt;\n-                }\n-\n-                Categorization::Upvar(..) |\n-                Categorization::Local(..) => break,\n-            }\n-        }\n-    }\n-\n-    fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) {}\n-    fn mutate(&mut self,\n-              _assignment_id: hir::HirId,\n-              _assignment_span: Span,\n-              _assignee_cmt: &mc::cmt_<'_>,\n-              _mode: euv::MutateMode) {\n-    }\n-\n-    fn matched_pat(&mut self, _: &hir::Pat, _: &mc::cmt_<'_>, _: euv::MatchMode) {}\n-\n-    fn consume_pat(&mut self,\n-                   _consume_pat: &hir::Pat,\n-                   _cmt: &mc::cmt_<'_>,\n-                   _mode: euv::ConsumeMode) {}\n-}"}, {"sha": "d46ac4a39a33765866decdc23cf54e1016a7f5f3", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 9, "deletions": 75, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -3,10 +3,10 @@ use crate::check::regionck::RegionCtxt;\n use crate::hir;\n use crate::hir::def_id::DefId;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n-use rustc::infer::{self, InferOk, SuppressRegionErrors};\n+use rustc::infer::{InferOk, SuppressRegionErrors};\n use rustc::middle::region;\n use rustc::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n-use rustc::ty::subst::{Subst, SubstsRef, GenericArgKind};\n+use rustc::ty::subst::{Subst, SubstsRef};\n use rustc::ty::{self, Ty, TyCtxt};\n use crate::util::common::ErrorReported;\n \n@@ -233,87 +233,21 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     result\n }\n \n-/// This function confirms that the type\n-/// expression `typ` conforms to the \"Drop Check Rule\" from the Sound\n-/// Generic Drop RFC (#769).\n-///\n-/// ----\n-///\n-/// The simplified (*) Drop Check Rule is the following:\n-///\n-/// Let `v` be some value (either temporary or named) and 'a be some\n-/// lifetime (scope). If the type of `v` owns data of type `D`, where\n-///\n-/// * (1.) `D` has a lifetime- or type-parametric Drop implementation,\n-///        (where that `Drop` implementation does not opt-out of\n-///         this check via the `may_dangle`\n-///         attribute), and\n-/// * (2.) the structure of `D` can reach a reference of type `&'a _`,\n-///\n-/// then 'a must strictly outlive the scope of v.\n-///\n-/// ----\n-///\n-/// This function is meant to by applied to the type for every\n-/// expression in the program.\n-///\n-/// ----\n-///\n-/// (*) The qualifier \"simplified\" is attached to the above\n-/// definition of the Drop Check Rule, because it is a simplification\n-/// of the original Drop Check rule, which attempted to prove that\n-/// some `Drop` implementations could not possibly access data even if\n-/// it was technically reachable, due to parametricity.\n-///\n-/// However, (1.) parametricity on its own turned out to be a\n-/// necessary but insufficient condition, and (2.)  future changes to\n-/// the language are expected to make it impossible to ensure that a\n-/// `Drop` implementation is actually parametric with respect to any\n-/// particular type parameter. (In particular, impl specialization is\n-/// expected to break the needed parametricity property beyond\n-/// repair.)\n-///\n-/// Therefore, we have scaled back Drop-Check to a more conservative\n-/// rule that does not attempt to deduce whether a `Drop`\n-/// implementation could not possible access data of a given lifetime;\n-/// instead Drop-Check now simply assumes that if a destructor has\n-/// access (direct or indirect) to a lifetime parameter, then that\n-/// lifetime must be forced to outlive that destructor's dynamic\n-/// extent. We then provide the `may_dangle`\n-/// attribute as a way for destructor implementations to opt-out of\n-/// this conservative assumption (and thus assume the obligation of\n-/// ensuring that they do not access data nor invoke methods of\n-/// values that have been previously dropped).\n-pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(\n+/// This function is not only checking that the dropck obligations are met for\n+/// the given type, but it's also currently preventing non-regular recursion in\n+/// types from causing stack overflows (dropck_no_diverge_on_nonregular_*.rs).\n+crate fn check_drop_obligations<'a, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'tcx>,\n     ty: Ty<'tcx>,\n     span: Span,\n     body_id: hir::HirId,\n-    scope: region::Scope,\n ) -> Result<(), ErrorReported> {\n-    debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n-           ty, scope);\n+    debug!(\"check_drop_obligations typ: {:?}\", ty);\n \n-    let parent_scope = match rcx.region_scope_tree.opt_encl_scope(scope) {\n-        Some(parent_scope) => parent_scope,\n-        // If no enclosing scope, then it must be the root scope\n-        // which cannot be outlived.\n-        None => return Ok(()),\n-    };\n-    let parent_scope = rcx.tcx.mk_region(ty::ReScope(parent_scope));\n-    let origin = || infer::SubregionOrigin::SafeDestructor(span);\n     let cause = &ObligationCause::misc(span, body_id);\n     let infer_ok = rcx.infcx.at(cause, rcx.fcx.param_env).dropck_outlives(ty);\n     debug!(\"dropck_outlives = {:#?}\", infer_ok);\n-    let kinds = rcx.fcx.register_infer_ok_obligations(infer_ok);\n-    for kind in kinds {\n-        match kind.unpack() {\n-            GenericArgKind::Lifetime(r) => rcx.sub_regions(origin(), parent_scope, r),\n-            GenericArgKind::Type(ty) => rcx.type_must_outlive(origin(), ty, parent_scope),\n-            GenericArgKind::Const(_) => {\n-                // Generic consts don't add constraints.\n-            }\n-        }\n-    }\n+    rcx.fcx.register_infer_ok_obligations(infer_ok);\n+\n     Ok(())\n }"}, {"sha": "2f9091282b7075762501f2fa672878350e17dd0f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 16, "deletions": 38, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -347,13 +347,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         );\n         self.outlives_environment\n             .save_implied_bounds(body_id.hir_id);\n-        self.link_fn_params(\n-            region::Scope {\n-                id: body.value.hir_id.local_id,\n-                data: region::ScopeData::Node,\n-            },\n-            &body.params,\n-        );\n+        self.link_fn_params(&body.params);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.hir_id);\n \n@@ -430,8 +424,8 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n             let typ = self.resolve_node_type(hir_id);\n             let body_id = self.body_id;\n-            let _ = dropck::check_safety_of_destructor_if_necessary(\n-                self, typ, span, body_id, var_scope,\n+            let _ = dropck::check_drop_obligations(\n+                self, typ, span, body_id,\n             );\n         })\n     }\n@@ -928,29 +922,15 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     }\n \n     fn check_safety_of_rvalue_destructor_if_necessary(&mut self, cmt: &mc::cmt_<'tcx>, span: Span) {\n-        if let Categorization::Rvalue(region) = cmt.cat {\n-            match *region {\n-                ty::ReScope(rvalue_scope) => {\n-                    let typ = self.resolve_type(cmt.ty);\n-                    let body_id = self.body_id;\n-                    let _ = dropck::check_safety_of_destructor_if_necessary(\n-                        self,\n-                        typ,\n-                        span,\n-                        body_id,\n-                        rvalue_scope,\n-                    );\n-                }\n-                ty::ReStatic => {}\n-                _ => {\n-                    span_bug!(\n-                        span,\n-                        \"unexpected rvalue region in rvalue \\\n-                         destructor safety checking: `{:?}`\",\n-                        region\n-                    );\n-                }\n-            }\n+        if let Categorization::Rvalue = cmt.cat {\n+            let typ = self.resolve_type(cmt.ty);\n+            let body_id = self.body_id;\n+            let _ = dropck::check_drop_obligations(\n+                self,\n+                typ,\n+                span,\n+                body_id,\n+            );\n         }\n     }\n \n@@ -1074,13 +1054,11 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n-    fn link_fn_params(&self, body_scope: region::Scope, params: &[hir::Param]) {\n-        debug!(\"regionck::link_fn_params(body_scope={:?})\", body_scope);\n+    fn link_fn_params(&self, params: &[hir::Param]) {\n         for param in params {\n             let param_ty = self.node_ty(param.hir_id);\n-            let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n             let param_cmt = self.with_mc(|mc| {\n-                Rc::new(mc.cat_rvalue(param.hir_id, param.pat.span, re_scope, param_ty))\n+                Rc::new(mc.cat_rvalue(param.hir_id, param.pat.span, param_ty))\n             });\n             debug!(\"param_ty={:?} param_cmt={:?} param={:?}\", param_ty, param_cmt, param);\n             self.link_pattern(param_cmt, &param.pat);\n@@ -1222,8 +1200,8 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                 | Categorization::StaticItem\n                 | Categorization::Upvar(..)\n                 | Categorization::Local(..)\n-                | Categorization::ThreadLocal(..)\n-                | Categorization::Rvalue(..) => {\n+                | Categorization::ThreadLocal\n+                | Categorization::Rvalue => {\n                     // These are all \"base cases\" with independent lifetimes\n                     // that are not subject to inference\n                     return;"}, {"sha": "4156e8ae12afa9c909ee4537b453dded4407d367", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -408,8 +408,8 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n             Categorization::Deref(_, mc::UnsafePtr(..))\n             | Categorization::StaticItem\n-            | Categorization::ThreadLocal(..)\n-            | Categorization::Rvalue(..)\n+            | Categorization::ThreadLocal\n+            | Categorization::Rvalue\n             | Categorization::Local(_)\n             | Categorization::Upvar(..) => {\n                 return;\n@@ -439,8 +439,8 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n             Categorization::Deref(_, mc::UnsafePtr(..))\n             | Categorization::StaticItem\n-            | Categorization::ThreadLocal(..)\n-            | Categorization::Rvalue(..)\n+            | Categorization::ThreadLocal\n+            | Categorization::Rvalue\n             | Categorization::Local(_)\n             | Categorization::Upvar(..) => {}\n         }"}, {"sha": "8fd67b19d6a5a7d16ea805481b211714f3dc9332", "filename": "src/test/ui/issues/issue-17252.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -1,11 +1,11 @@\n-error[E0391]: cycle detected when processing `FOO`\n+error[E0391]: cycle detected when const checking `FOO`\n   --> $DIR/issue-17252.rs:1:20\n    |\n LL | const FOO: usize = FOO;\n    |                    ^^^\n    |\n-   = note: ...which again requires processing `FOO`, completing the cycle\n-note: cycle used when processing `main::{{constant}}#0`\n+   = note: ...which again requires const checking `FOO`, completing the cycle\n+note: cycle used when const checking `main::{{constant}}#0`\n   --> $DIR/issue-17252.rs:4:18\n    |\n LL |     let _x: [u8; FOO]; // caused stack overflow prior to fix"}, {"sha": "f2457774326ddb2a4d940e14b9430520e7ae52b2", "filename": "src/test/ui/issues/issue-23302-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -1,10 +1,10 @@\n-error[E0391]: cycle detected when processing `X::A::{{constant}}#0`\n+error[E0391]: cycle detected when const checking `X::A::{{constant}}#0`\n   --> $DIR/issue-23302-1.rs:4:9\n    |\n LL |     A = X::A as isize,\n    |         ^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires processing `X::A::{{constant}}#0`, completing the cycle\n+   = note: ...which again requires const checking `X::A::{{constant}}#0`, completing the cycle\n note: cycle used when processing `X::A::{{constant}}#0`\n   --> $DIR/issue-23302-1.rs:4:9\n    |"}, {"sha": "c121c17b904ea19191fa8df2cd878a771aa9a34f", "filename": "src/test/ui/issues/issue-23302-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -1,10 +1,10 @@\n-error[E0391]: cycle detected when processing `Y::A::{{constant}}#0`\n+error[E0391]: cycle detected when const checking `Y::A::{{constant}}#0`\n   --> $DIR/issue-23302-2.rs:4:9\n    |\n LL |     A = Y::B as isize,\n    |         ^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires processing `Y::A::{{constant}}#0`, completing the cycle\n+   = note: ...which again requires const checking `Y::A::{{constant}}#0`, completing the cycle\n note: cycle used when processing `Y::A::{{constant}}#0`\n   --> $DIR/issue-23302-2.rs:4:9\n    |"}, {"sha": "0229469f04140e670fe9a0ec689e03809b92a3d7", "filename": "src/test/ui/issues/issue-23302-3.stderr", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -1,26 +1,20 @@\n-error[E0391]: cycle detected when const checking if rvalue is promotable to static `A`\n-  --> $DIR/issue-23302-3.rs:1:1\n-   |\n-LL | const A: i32 = B;\n-   | ^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires checking which parts of `A` are promotable to static...\n+error[E0391]: cycle detected when const checking `A`\n   --> $DIR/issue-23302-3.rs:1:16\n    |\n LL | const A: i32 = B;\n    |                ^\n-note: ...which requires const checking if rvalue is promotable to static `B`...\n-  --> $DIR/issue-23302-3.rs:3:1\n    |\n-LL | const B: i32 = A;\n-   | ^^^^^^^^^^^^^^^^^\n-note: ...which requires checking which parts of `B` are promotable to static...\n+note: ...which requires const checking `B`...\n   --> $DIR/issue-23302-3.rs:3:16\n    |\n LL | const B: i32 = A;\n    |                ^\n-   = note: ...which again requires const checking if rvalue is promotable to static `A`, completing the cycle\n-   = note: cycle used when running analysis passes on this crate\n+   = note: ...which again requires const checking `A`, completing the cycle\n+note: cycle used when processing `A`\n+  --> $DIR/issue-23302-3.rs:1:1\n+   |\n+LL | const A: i32 = B;\n+   | ^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "3866243914b89ad5e15434cbf36fa37da0cab535", "filename": "src/test/ui/issues/issue-36163.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/455945f24b12689340d5085ed795aa3bfdab9d34/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr?ref=455945f24b12689340d5085ed795aa3bfdab9d34", "patch": "@@ -1,15 +1,15 @@\n-error[E0391]: cycle detected when processing `Foo::B::{{constant}}#0`\n+error[E0391]: cycle detected when const checking `Foo::B::{{constant}}#0`\n   --> $DIR/issue-36163.rs:4:9\n    |\n LL |     B = A,\n    |         ^\n    |\n-note: ...which requires processing `A`...\n+note: ...which requires const checking `A`...\n   --> $DIR/issue-36163.rs:1:18\n    |\n LL | const A: isize = Foo::B as isize;\n    |                  ^^^^^^^^^^^^^^^\n-   = note: ...which again requires processing `Foo::B::{{constant}}#0`, completing the cycle\n+   = note: ...which again requires const checking `Foo::B::{{constant}}#0`, completing the cycle\n note: cycle used when processing `Foo::B::{{constant}}#0`\n   --> $DIR/issue-36163.rs:4:9\n    |"}]}