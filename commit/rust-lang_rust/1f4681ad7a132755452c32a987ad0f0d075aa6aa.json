{"sha": "1f4681ad7a132755452c32a987ad0f0d075aa6aa", "node_id": "C_kwDOAAsO6NoAKDFmNDY4MWFkN2ExMzI3NTU0NTJjMzJhOTg3YWQwZjBkMDc1YWE2YWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-13T12:03:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-13T12:03:52Z"}, "message": "Auto merge of #91673 - ChrisDenton:path-absolute, r=Mark-Simulacrum\n\n`std::path::absolute`\n\nImplements #59117 by adding a `std::path::absolute` function that creates an absolute path without reading the filesystem. This is intended to be a drop-in replacement for [`std::fs::canonicalize`](https://doc.rust-lang.org/std/fs/fn.canonicalize.html) in cases where it isn't necessary to resolve symlinks. It can be used on paths that don't exist or where resolving symlinks is unwanted. It can also be used to avoid circumstances where `canonicalize` might otherwise fail.\n\nOn Windows this is a wrapper around [`GetFullPathNameW`](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfullpathnamew). On Unix it partially implements the POSIX [pathname resolution](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13) specification, stopping just short of actually resolving symlinks.", "tree": {"sha": "078e06add300f2bacb4b586e544f391bb9583f63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/078e06add300f2bacb4b586e544f391bb9583f63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f4681ad7a132755452c32a987ad0f0d075aa6aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f4681ad7a132755452c32a987ad0f0d075aa6aa", "html_url": "https://github.com/rust-lang/rust/commit/1f4681ad7a132755452c32a987ad0f0d075aa6aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f4681ad7a132755452c32a987ad0f0d075aa6aa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c26fbf857f82b2d0cb919c633ba0e3a90e5b9426", "url": "https://api.github.com/repos/rust-lang/rust/commits/c26fbf857f82b2d0cb919c633ba0e3a90e5b9426", "html_url": "https://github.com/rust-lang/rust/commit/c26fbf857f82b2d0cb919c633ba0e3a90e5b9426"}, {"sha": "81cc3afe20d994d9c7cba4e75c3eed92bf98a402", "url": "https://api.github.com/repos/rust-lang/rust/commits/81cc3afe20d994d9c7cba4e75c3eed92bf98a402", "html_url": "https://github.com/rust-lang/rust/commit/81cc3afe20d994d9c7cba4e75c3eed92bf98a402"}], "stats": {"total": 213, "additions": 209, "deletions": 4}, "files": [{"sha": "a03da0682a5cd534245e3df4ee647922271d7872", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f4681ad7a132755452c32a987ad0f0d075aa6aa/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4681ad7a132755452c32a987ad0f0d075aa6aa/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=1f4681ad7a132755452c32a987ad0f0d075aa6aa", "patch": "@@ -222,6 +222,7 @@\n // std is implemented with unstable features, many of which are internal\n // compiler details that will never be stable\n // NB: the following list is sorted to minimize merge conflicts.\n+#![feature(absolute_path)]\n #![feature(alloc_error_handler)]\n #![feature(alloc_layout_extra)]\n #![feature(allocator_api)]"}, {"sha": "3f7f0f888476a3654f4c715167d8de7a24c9142c", "filename": "library/std/src/path.rs", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1f4681ad7a132755452c32a987ad0f0d075aa6aa/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4681ad7a132755452c32a987ad0f0d075aa6aa/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=1f4681ad7a132755452c32a987ad0f0d075aa6aa", "patch": "@@ -85,7 +85,7 @@ use crate::str::FromStr;\n use crate::sync::Arc;\n \n use crate::ffi::{OsStr, OsString};\n-\n+use crate::sys;\n use crate::sys::path::{is_sep_byte, is_verbatim_sep, parse_prefix, MAIN_SEP_STR};\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -3172,3 +3172,79 @@ impl Error for StripPrefixError {\n         \"prefix not found\"\n     }\n }\n+\n+/// Makes the path absolute without accessing the filesystem.\n+///\n+/// If the path is relative, the current directory is used as the base directory.\n+/// All intermediate components will be resolved according to platforms-specific\n+/// rules but unlike [`canonicalize`][crate::fs::canonicalize] this does not\n+/// resolve symlinks and may succeed even if the path does not exist.\n+///\n+/// If the `path` is empty or getting the\n+/// [current directory][crate::env::current_dir] fails then an error will be\n+/// returned.\n+///\n+/// # Examples\n+///\n+/// ## Posix paths\n+///\n+/// ```\n+/// #![feature(absolute_path)]\n+/// # #[cfg(unix)]\n+/// fn main() -> std::io::Result<()> {\n+///   use std::path::{self, Path};\n+///\n+///   // Relative to absolute\n+///   let absolute = path::absolute(\"foo/./bar\")?;\n+///   assert!(absolute.ends_with(\"foo/bar\"));\n+///\n+///   // Absolute to absolute\n+///   let absolute = path::absolute(\"/foo//test/.././bar.rs\")?;\n+///   assert_eq!(absolute, Path::new(\"/foo/test/../bar.rs\"));\n+///   Ok(())\n+/// }\n+/// # #[cfg(not(unix))]\n+/// # fn main() {}\n+/// ```\n+///\n+/// The path is resolved using [POSIX semantics][posix-semantics] except that\n+/// it stops short of resolving symlinks. This means it will keep `..`\n+/// components and trailing slashes.\n+///\n+/// ## Windows paths\n+///\n+/// ```\n+/// #![feature(absolute_path)]\n+/// # #[cfg(windows)]\n+/// fn main() -> std::io::Result<()> {\n+///   use std::path::{self, Path};\n+///\n+///   // Relative to absolute\n+///   let absolute = path::absolute(\"foo/./bar\")?;\n+///   assert!(absolute.ends_with(r\"foo\\bar\"));\n+///\n+///   // Absolute to absolute\n+///   let absolute = path::absolute(r\"C:\\foo//test\\..\\./bar.rs\")?;\n+///\n+///   assert_eq!(absolute, Path::new(r\"C:\\foo\\bar.rs\"));\n+///   Ok(())\n+/// }\n+/// # #[cfg(not(windows))]\n+/// # fn main() {}\n+/// ```\n+///\n+/// For verbatim paths this will simply return the path as given. For other\n+/// paths this is currently equivalent to calling [`GetFullPathNameW`][windows-path]\n+/// This may change in the future.\n+///\n+/// [posix-semantics]: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13\n+/// [windows-path]: https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfullpathnamew\n+#[unstable(feature = \"absolute_path\", issue = \"92750\")]\n+pub fn absolute<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n+    let path = path.as_ref();\n+    if path.as_os_str().is_empty() {\n+        Err(io::const_io_error!(io::ErrorKind::InvalidInput, \"cannot make an empty path absolute\",))\n+    } else {\n+        sys::path::absolute(path)\n+    }\n+}"}, {"sha": "8e51433094a6962d40eb3b7b442119d19ba343bf", "filename": "library/std/src/path/tests.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1f4681ad7a132755452c32a987ad0f0d075aa6aa/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4681ad7a132755452c32a987ad0f0d075aa6aa/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs?ref=1f4681ad7a132755452c32a987ad0f0d075aa6aa", "patch": "@@ -1700,6 +1700,64 @@ fn test_ord() {\n     ord!(Equal, \"foo/bar\", \"foo/bar//\");\n }\n \n+#[test]\n+#[cfg(unix)]\n+fn test_unix_absolute() {\n+    use crate::path::absolute;\n+\n+    assert!(absolute(\"\").is_err());\n+\n+    let relative = \"a/b\";\n+    let mut expected = crate::env::current_dir().unwrap();\n+    expected.push(relative);\n+    assert_eq!(absolute(relative).unwrap(), expected);\n+\n+    // Test how components are collected.\n+    assert_eq!(absolute(\"/a/b/c\").unwrap(), Path::new(\"/a/b/c\"));\n+    assert_eq!(absolute(\"/a//b/c\").unwrap(), Path::new(\"/a/b/c\"));\n+    assert_eq!(absolute(\"//a/b/c\").unwrap(), Path::new(\"//a/b/c\"));\n+    assert_eq!(absolute(\"///a/b/c\").unwrap(), Path::new(\"/a/b/c\"));\n+    assert_eq!(absolute(\"/a/b/c/\").unwrap(), Path::new(\"/a/b/c/\"));\n+    assert_eq!(absolute(\"/a/./b/../c/.././..\").unwrap(), Path::new(\"/a/b/../c/../..\"));\n+}\n+\n+#[test]\n+#[cfg(windows)]\n+fn test_windows_absolute() {\n+    use crate::path::absolute;\n+    // An empty path is an error.\n+    assert!(absolute(\"\").is_err());\n+\n+    let relative = r\"a\\b\";\n+    let mut expected = crate::env::current_dir().unwrap();\n+    expected.push(relative);\n+    assert_eq!(absolute(relative).unwrap(), expected);\n+\n+    macro_rules! unchanged(\n+        ($path:expr) => {\n+            assert_eq!(absolute($path).unwrap(), Path::new($path));\n+        }\n+    );\n+\n+    unchanged!(r\"C:\\path\\to\\file\");\n+    unchanged!(r\"C:\\path\\to\\file\\\");\n+    unchanged!(r\"\\\\server\\share\\to\\file\");\n+    unchanged!(r\"\\\\server.\\share.\\to\\file\");\n+    unchanged!(r\"\\\\.\\PIPE\\name\");\n+    unchanged!(r\"\\\\.\\C:\\path\\to\\COM1\");\n+    unchanged!(r\"\\\\?\\C:\\path\\to\\file\");\n+    unchanged!(r\"\\\\?\\UNC\\server\\share\\to\\file\");\n+    unchanged!(r\"\\\\?\\PIPE\\name\");\n+    // Verbatim paths are always unchanged, no matter what.\n+    unchanged!(r\"\\\\?\\path.\\to/file..\");\n+\n+    assert_eq!(absolute(r\"C:\\path..\\to.\\file.\").unwrap(), Path::new(r\"C:\\path..\\to\\file\"));\n+    assert_eq!(absolute(r\"C:\\path\\to\\COM1\").unwrap(), Path::new(r\"\\\\.\\COM1\"));\n+    assert_eq!(absolute(r\"C:\\path\\to\\COM1.txt\").unwrap(), Path::new(r\"\\\\.\\COM1\"));\n+    assert_eq!(absolute(r\"C:\\path\\to\\COM1  .txt\").unwrap(), Path::new(r\"\\\\.\\COM1\"));\n+    assert_eq!(absolute(r\"C:\\path\\to\\cOnOuT$\").unwrap(), Path::new(r\"\\\\.\\cOnOuT$\"));\n+}\n+\n #[bench]\n fn bench_path_cmp_fast_path_buf_sort(b: &mut test::Bencher) {\n     let prefix = \"my/home\";"}, {"sha": "c805c15e70245115c81ed2693b22f06a0484ac5e", "filename": "library/std/src/sys/sgx/path.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f4681ad7a132755452c32a987ad0f0d075aa6aa/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4681ad7a132755452c32a987ad0f0d075aa6aa/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpath.rs?ref=1f4681ad7a132755452c32a987ad0f0d075aa6aa", "patch": "@@ -1,5 +1,7 @@\n use crate::ffi::OsStr;\n-use crate::path::Prefix;\n+use crate::io;\n+use crate::path::{Path, PathBuf, Prefix};\n+use crate::sys::unsupported;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {\n@@ -17,3 +19,7 @@ pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n \n pub const MAIN_SEP_STR: &str = \"/\";\n pub const MAIN_SEP: char = '/';\n+\n+pub(crate) fn absolute(_path: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}"}, {"sha": "7045c9be25b0809fb1a747a9d8879b2d7b7e692a", "filename": "library/std/src/sys/solid/path.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f4681ad7a132755452c32a987ad0f0d075aa6aa/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4681ad7a132755452c32a987ad0f0d075aa6aa/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fpath.rs?ref=1f4681ad7a132755452c32a987ad0f0d075aa6aa", "patch": "@@ -1,5 +1,7 @@\n use crate::ffi::OsStr;\n-use crate::path::Prefix;\n+use crate::io;\n+use crate::path::{Path, PathBuf, Prefix};\n+use crate::sys::unsupported;\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {\n@@ -17,3 +19,7 @@ pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n \n pub const MAIN_SEP_STR: &str = \"\\\\\";\n pub const MAIN_SEP: char = '\\\\';\n+\n+pub(crate) fn absolute(_path: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}"}, {"sha": "6d6f4c8b8dc63f4581f1823bf04adfe7cb953ecd", "filename": "library/std/src/sys/unix/path.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1f4681ad7a132755452c32a987ad0f0d075aa6aa/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4681ad7a132755452c32a987ad0f0d075aa6aa/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs?ref=1f4681ad7a132755452c32a987ad0f0d075aa6aa", "patch": "@@ -1,5 +1,7 @@\n+use crate::env;\n use crate::ffi::OsStr;\n-use crate::path::Prefix;\n+use crate::io;\n+use crate::path::{Path, PathBuf, Prefix};\n \n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {\n@@ -18,3 +20,43 @@ pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n \n pub const MAIN_SEP_STR: &str = \"/\";\n pub const MAIN_SEP: char = '/';\n+\n+/// Make a POSIX path absolute without changing its semantics.\n+pub(crate) fn absolute(path: &Path) -> io::Result<PathBuf> {\n+    // This is mostly a wrapper around collecting `Path::components`, with\n+    // exceptions made where this conflicts with the POSIX specification.\n+    // See 4.13 Pathname Resolution, IEEE Std 1003.1-2017\n+    // https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13\n+\n+    let mut components = path.components();\n+    let path_os = path.as_os_str().bytes();\n+\n+    let mut normalized = if path.is_absolute() {\n+        // \"If a pathname begins with two successive <slash> characters, the\n+        // first component following the leading <slash> characters may be\n+        // interpreted in an implementation-defined manner, although more than\n+        // two leading <slash> characters shall be treated as a single <slash>\n+        // character.\"\n+        if path_os.starts_with(b\"//\") && !path_os.starts_with(b\"///\") {\n+            components.next();\n+            PathBuf::from(\"//\")\n+        } else {\n+            PathBuf::new()\n+        }\n+    } else {\n+        env::current_dir()?\n+    };\n+    normalized.extend(components);\n+\n+    // \"Interfaces using pathname resolution may specify additional constraints\n+    // when a pathname that does not name an existing directory contains at\n+    // least one non- <slash> character and contains one or more trailing\n+    // <slash> characters\".\n+    // A trailing <slash> is also meaningful if \"a symbolic link is\n+    // encountered during pathname resolution\".\n+    if path_os.ends_with(b\"/\") {\n+        normalized.push(\"\");\n+    }\n+\n+    Ok(normalized)\n+}"}, {"sha": "e54fcaed4957d8ab38d440234ed36bd123991209", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1f4681ad7a132755452c32a987ad0f0d075aa6aa/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4681ad7a132755452c32a987ad0f0d075aa6aa/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=1f4681ad7a132755452c32a987ad0f0d075aa6aa", "patch": "@@ -260,3 +260,19 @@ pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n     )?;\n     Ok(path)\n }\n+\n+/// Make a Windows path absolute.\n+pub(crate) fn absolute(path: &Path) -> io::Result<PathBuf> {\n+    if path.as_os_str().bytes().starts_with(br\"\\\\?\\\") {\n+        return Ok(path.into());\n+    }\n+    let path = to_u16s(path)?;\n+    let lpfilename = path.as_ptr();\n+    fill_utf16_buf(\n+        // SAFETY: `fill_utf16_buf` ensures the `buffer` and `size` are valid.\n+        // `lpfilename` is a pointer to a null terminated string that is not\n+        // invalidated until after `GetFullPathNameW` returns successfully.\n+        |buffer, size| unsafe { c::GetFullPathNameW(lpfilename, size, buffer, ptr::null_mut()) },\n+        super::os2path,\n+    )\n+}"}]}