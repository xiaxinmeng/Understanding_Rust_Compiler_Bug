{"sha": "5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMzNlY2E2NWYxZGQ5NTg1YWFmYTljZGRkOWQ0YmZkNzFiODIwYzE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-18T04:01:57Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-19T00:01:55Z"}, "message": "Generalize and abstract `ThinAttributes`", "tree": {"sha": "a5490b012b6243d778e9f1ac4a3b3010b1447ca8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5490b012b6243d778e9f1ac4a3b3010b1447ca8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "html_url": "https://github.com/rust-lang/rust/commit/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "url": "https://api.github.com/repos/rust-lang/rust/commits/114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "html_url": "https://github.com/rust-lang/rust/commit/114be1e9f0db2c84e38b5ed96d4e4450771e8a44"}], "stats": {"total": 595, "additions": 278, "deletions": 317}, "files": [{"sha": "06275efc5f85a5b6809ba56572d0131176462d27", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -14,7 +14,6 @@\n use hir::*;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_, MetaItem};\n use syntax::ast::MetaItemKind;\n-use syntax::attr::ThinAttributesExt;\n use hir;\n use syntax::codemap::{respan, Span, Spanned};\n use syntax::ptr::P;\n@@ -292,8 +291,11 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n     })\n }\n \n-pub fn fold_attrs<T: Folder>(attrs: HirVec<Attribute>, fld: &mut T) -> HirVec<Attribute> {\n-    attrs.move_flat_map(|x| fld.fold_attribute(x))\n+pub fn fold_attrs<T, F>(attrs: T, fld: &mut F) -> T\n+    where T: Into<Vec<Attribute>> + From<Vec<Attribute>>,\n+          F: Folder,\n+{\n+    attrs.into().move_flat_map(|x| fld.fold_attribute(x)).into()\n }\n \n pub fn noop_fold_arm<T: Folder>(Arm { attrs, pats, guard, body }: Arm, fld: &mut T) -> Arm {\n@@ -461,7 +463,7 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n             pat: fld.fold_pat(pat),\n             init: init.map(|e| fld.fold_expr(e)),\n             span: fld.new_span(span),\n-            attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs.into(), fld).into()),\n+            attrs: fold_attrs(attrs, fld),\n         }\n     })\n }\n@@ -1078,7 +1080,7 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &\n             }\n         },\n         span: folder.new_span(span),\n-        attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs.into(), folder).into()),\n+        attrs: fold_attrs(attrs, folder),\n     }\n }\n "}, {"sha": "b677594d6f80de9652419e5d70ee95130a952caa", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -27,7 +27,6 @@\n \n use syntax::abi::Abi;\n use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n-use syntax::attr::ThinAttributesExt;\n use syntax::codemap::{Span, Spanned};\n use hir::*;\n \n@@ -756,7 +755,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             walk_list!(visitor, visit_arm, arms);\n         }\n         ExprClosure(_, ref function_declaration, ref body, _fn_decl_span) => {\n-            visitor.visit_fn(FnKind::Closure(expression.attrs.as_attr_slice()),\n+            visitor.visit_fn(FnKind::Closure(&expression.attrs),\n                              function_declaration,\n                              body,\n                              expression.span,"}, {"sha": "b7689a832fc265a81c4823f945f6de96a6529b98", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 72, "deletions": 84, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -50,7 +50,6 @@ use session::Session;\n use std::collections::BTreeMap;\n use std::iter;\n use syntax::ast::*;\n-use syntax::attr::{ThinAttributes, ThinAttributesExt};\n use syntax::ptr::P;\n use syntax::codemap::{respan, Spanned, Span};\n use syntax::parse::token;\n@@ -962,16 +961,16 @@ impl<'a> LoweringContext<'a> {\n \n                     let make_call = |this: &mut LoweringContext, p, args| {\n                         let path = this.core_path(e.span, p);\n-                        let path = this.expr_path(path, None);\n-                        this.expr_call(e.span, path, args, None)\n+                        let path = this.expr_path(path, ThinVec::new());\n+                        this.expr_call(e.span, path, args)\n                     };\n \n                     let mk_stmt_let = |this: &mut LoweringContext, bind, expr| {\n-                        this.stmt_let(e.span, false, bind, expr, None)\n+                        this.stmt_let(e.span, false, bind, expr)\n                     };\n \n                     let mk_stmt_let_mut = |this: &mut LoweringContext, bind, expr| {\n-                        this.stmt_let(e.span, true, bind, expr, None)\n+                        this.stmt_let(e.span, true, bind, expr)\n                     };\n \n                     // let placer = <placer_expr> ;\n@@ -980,21 +979,21 @@ impl<'a> LoweringContext<'a> {\n                                                                  placer_expr,\n                                                                  e.span,\n                                                                  hir::PopUnstableBlock,\n-                                                                 None);\n+                                                                 ThinVec::new());\n                         mk_stmt_let(self, placer_ident, placer_expr)\n                     };\n \n                     // let mut place = Placer::make_place(placer);\n                     let (s2, place_binding) = {\n-                        let placer = self.expr_ident(e.span, placer_ident, None, placer_binding);\n+                        let placer = self.expr_ident(e.span, placer_ident, placer_binding);\n                         let call = make_call(self, &make_place, hir_vec![placer]);\n                         mk_stmt_let_mut(self, place_ident, call)\n                     };\n \n                     // let p_ptr = Place::pointer(&mut place);\n                     let (s3, p_ptr_binding) = {\n-                        let agent = self.expr_ident(e.span, place_ident, None, place_binding);\n-                        let args = hir_vec![self.expr_mut_addr_of(e.span, agent, None)];\n+                        let agent = self.expr_ident(e.span, place_ident, place_binding);\n+                        let args = hir_vec![self.expr_mut_addr_of(e.span, agent)];\n                         let call = make_call(self, &place_pointer, args);\n                         mk_stmt_let(self, p_ptr_ident, call)\n                     };\n@@ -1005,31 +1004,33 @@ impl<'a> LoweringContext<'a> {\n                                                                 value_expr,\n                                                                 e.span,\n                                                                 hir::PopUnstableBlock,\n-                                                                None);\n+                                                                ThinVec::new());\n                         self.signal_block_expr(hir_vec![],\n                                                value_expr,\n                                                e.span,\n-                                               hir::PopUnsafeBlock(hir::CompilerGenerated), None)\n+                                               hir::PopUnsafeBlock(hir::CompilerGenerated),\n+                                               ThinVec::new())\n                     };\n \n                     // push_unsafe!({\n                     //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n                     //     InPlace::finalize(place)\n                     // })\n                     let expr = {\n-                        let ptr = self.expr_ident(e.span, p_ptr_ident, None, p_ptr_binding);\n+                        let ptr = self.expr_ident(e.span, p_ptr_ident, p_ptr_binding);\n                         let call_move_val_init =\n                             hir::StmtSemi(\n                                 make_call(self, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n                                 self.next_id());\n                         let call_move_val_init = respan(e.span, call_move_val_init);\n \n-                        let place = self.expr_ident(e.span, place_ident, None, place_binding);\n+                        let place = self.expr_ident(e.span, place_ident, place_binding);\n                         let call = make_call(self, &inplace_finalize, hir_vec![place]);\n                         self.signal_block_expr(hir_vec![call_move_val_init],\n                                                call,\n                                                e.span,\n-                                               hir::PushUnsafeBlock(hir::CompilerGenerated), None)\n+                                               hir::PushUnsafeBlock(hir::CompilerGenerated),\n+                                               ThinVec::new())\n                     };\n \n                     return self.signal_block_expr(hir_vec![s1, s2, s3],\n@@ -1101,7 +1102,7 @@ impl<'a> LoweringContext<'a> {\n                                     rules: hir::DefaultBlock,\n                                     span: span,\n                                 });\n-                                self.expr_block(blk, None)\n+                                self.expr_block(blk, ThinVec::new())\n                             }\n                             _ => self.lower_expr(els),\n                         }\n@@ -1168,7 +1169,7 @@ impl<'a> LoweringContext<'a> {\n                                                                           expr,\n                                                                           e.span,\n                                                                           hir::PopUnstableBlock,\n-                                                                          None);\n+                                                                          ThinVec::new());\n                                 this.field(token::intern(s), signal_block, ast_expr.span)\n                             }).collect();\n                             let attrs = ast_expr.attrs.clone();\n@@ -1180,7 +1181,7 @@ impl<'a> LoweringContext<'a> {\n                                                hir_expr,\n                                                ast_expr.span,\n                                                hir::PushUnstableBlock,\n-                                               None)\n+                                               ThinVec::new())\n                     }\n \n                     use syntax::ast::RangeLimits::*;\n@@ -1267,9 +1268,9 @@ impl<'a> LoweringContext<'a> {\n                             ex.span = e.span;\n                         }\n                         // merge attributes into the inner expression.\n-                        ex.attrs.update(|attrs| {\n-                            attrs.prepend(e.attrs.clone())\n-                        });\n+                        let mut attrs = e.attrs.clone();\n+                        attrs.extend::<Vec<_>>(ex.attrs.into());\n+                        ex.attrs = attrs;\n                         ex\n                     });\n                 }\n@@ -1288,7 +1289,7 @@ impl<'a> LoweringContext<'a> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = self.lower_block(body);\n-                        let body_expr = self.expr_block(body, None);\n+                        let body_expr = self.expr_block(body, ThinVec::new());\n                         let pat = self.lower_pat(pat);\n                         self.arm(hir_vec![pat], body_expr)\n                     };\n@@ -1308,7 +1309,7 @@ impl<'a> LoweringContext<'a> {\n                                                 attrs: hir_vec![],\n                                                 pats: hir_vec![pat_under],\n                                                 guard: Some(cond),\n-                                                body: self.expr_block(then, None),\n+                                                body: self.expr_block(then, ThinVec::new()),\n                                             });\n                                             else_opt.map(|else_opt| (else_opt, true))\n                                         }\n@@ -1339,7 +1340,7 @@ impl<'a> LoweringContext<'a> {\n                     let else_arm = {\n                         let pat_under = self.pat_wild(e.span);\n                         let else_expr =\n-                            else_opt.unwrap_or_else(|| self.expr_tuple(e.span, hir_vec![], None));\n+                            else_opt.unwrap_or_else(|| self.expr_tuple(e.span, hir_vec![]));\n                         self.arm(hir_vec![pat_under], else_expr)\n                     };\n \n@@ -1374,15 +1375,15 @@ impl<'a> LoweringContext<'a> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = self.lower_block(body);\n-                        let body_expr = self.expr_block(body, None);\n+                        let body_expr = self.expr_block(body, ThinVec::new());\n                         let pat = self.lower_pat(pat);\n                         self.arm(hir_vec![pat], body_expr)\n                     };\n \n                     // `_ => break`\n                     let break_arm = {\n                         let pat_under = self.pat_wild(e.span);\n-                        let break_expr = self.expr_break(e.span, None);\n+                        let break_expr = self.expr_break(e.span, ThinVec::new());\n                         self.arm(hir_vec![pat_under], break_expr)\n                     };\n \n@@ -1393,7 +1394,7 @@ impl<'a> LoweringContext<'a> {\n                                                hir::ExprMatch(sub_expr,\n                                                               arms,\n                                                               hir::MatchSource::WhileLetDesugar),\n-                                               None);\n+                                               ThinVec::new());\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = self.block_expr(match_expr);\n@@ -1435,7 +1436,7 @@ impl<'a> LoweringContext<'a> {\n                             id: self.next_id(),\n                             node: hir::ExprBlock(body_block),\n                             span: body_span,\n-                            attrs: None,\n+                            attrs: ThinVec::new(),\n                         });\n                         let pat = self.lower_pat(pat);\n                         let some_pat = self.pat_some(e.span, pat);\n@@ -1445,7 +1446,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // `::std::option::Option::None => break`\n                     let break_arm = {\n-                        let break_expr = self.expr_break(e.span, None);\n+                        let break_expr = self.expr_break(e.span, ThinVec::new());\n                         let pat = self.pat_none(e.span);\n                         self.arm(hir_vec![pat], break_expr)\n                     };\n@@ -1461,25 +1462,26 @@ impl<'a> LoweringContext<'a> {\n \n                             self.path_global(e.span, strs)\n                         };\n-                        let iter = self.expr_ident(e.span, iter, None, iter_pat.id);\n-                        let ref_mut_iter = self.expr_mut_addr_of(e.span, iter, None);\n-                        let next_path = self.expr_path(next_path, None);\n-                        let next_expr = self.expr_call(e.span,\n-                                                       next_path,\n-                                                       hir_vec![ref_mut_iter],\n-                                                       None);\n+                        let iter = self.expr_ident(e.span, iter, iter_pat.id);\n+                        let ref_mut_iter = self.expr_mut_addr_of(e.span, iter);\n+                        let next_path = self.expr_path(next_path, ThinVec::new());\n+                        let next_expr = self.expr_call(e.span, next_path, hir_vec![ref_mut_iter]);\n                         let arms = hir_vec![pat_arm, break_arm];\n \n                         self.expr(e.span,\n                                   hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n-                                  None)\n+                                  ThinVec::new())\n                     };\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = self.block_expr(match_expr);\n                     let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident));\n-                    let loop_expr =\n-                        P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: None });\n+                    let loop_expr = P(hir::Expr {\n+                        id: e.id,\n+                        node: loop_expr,\n+                        span: e.span,\n+                        attrs: ThinVec::new(),\n+                    });\n \n                     // `mut iter => { ... }`\n                     let iter_arm = self.arm(hir_vec![iter_pat], loop_expr);\n@@ -1492,23 +1494,22 @@ impl<'a> LoweringContext<'a> {\n                             self.path_global(e.span, strs)\n                         };\n \n-                        let into_iter = self.expr_path(into_iter_path, None);\n-                        self.expr_call(e.span, into_iter, hir_vec![head], None)\n+                        let into_iter = self.expr_path(into_iter_path, ThinVec::new());\n+                        self.expr_call(e.span, into_iter, hir_vec![head])\n                     };\n \n                     let match_expr = self.expr_match(e.span,\n                                                      into_iter_expr,\n                                                      hir_vec![iter_arm],\n-                                                     hir::MatchSource::ForLoopDesugar,\n-                                                     None);\n+                                                     hir::MatchSource::ForLoopDesugar);\n \n                     // `{ let _result = ...; _result }`\n                     // underscore prevents an unused_variables lint if the head diverges\n                     let result_ident = self.str_to_ident(\"_result\");\n                     let (let_stmt, let_stmt_binding) =\n-                        self.stmt_let(e.span, false, result_ident, match_expr, None);\n+                        self.stmt_let(e.span, false, result_ident, match_expr);\n \n-                    let result = self.expr_ident(e.span, result_ident, None, let_stmt_binding);\n+                    let result = self.expr_ident(e.span, result_ident, let_stmt_binding);\n                     let block = self.block_all(e.span, hir_vec![let_stmt], Some(result));\n                     // add the attributes to the outer returned expr node\n                     return self.expr_block(block, e.attrs.clone());\n@@ -1535,7 +1536,7 @@ impl<'a> LoweringContext<'a> {\n                     let ok_arm = {\n                         let val_ident = self.str_to_ident(\"val\");\n                         let val_pat = self.pat_ident(e.span, val_ident);\n-                        let val_expr = self.expr_ident(e.span, val_ident, None, val_pat.id);\n+                        let val_expr = self.expr_ident(e.span, val_ident, val_pat.id);\n                         let ok_pat = self.pat_ok(e.span, val_pat);\n \n                         self.arm(hir_vec![ok_pat], val_expr)\n@@ -1548,26 +1549,26 @@ impl<'a> LoweringContext<'a> {\n                         let from_expr = {\n                             let path = self.std_path(&[\"convert\", \"From\", \"from\"]);\n                             let path = self.path_global(e.span, path);\n-                            let from = self.expr_path(path, None);\n-                            let err_expr = self.expr_ident(e.span, err_ident, None, err_local.id);\n+                            let from = self.expr_path(path, ThinVec::new());\n+                            let err_expr = self.expr_ident(e.span, err_ident, err_local.id);\n \n-                            self.expr_call(e.span, from, hir_vec![err_expr], None)\n+                            self.expr_call(e.span, from, hir_vec![err_expr])\n                         };\n                         let err_expr = {\n                             let path = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n                             let path = self.path_global(e.span, path);\n-                            let err_ctor = self.expr_path(path, None);\n-                            self.expr_call(e.span, err_ctor, hir_vec![from_expr], None)\n+                            let err_ctor = self.expr_path(path, ThinVec::new());\n+                            self.expr_call(e.span, err_ctor, hir_vec![from_expr])\n                         };\n                         let err_pat = self.pat_err(e.span, err_local);\n                         let ret_expr = self.expr(e.span,\n-                                                 hir::Expr_::ExprRet(Some(err_expr)), None);\n-\n+                                                 hir::Expr_::ExprRet(Some(err_expr)),\n+                                                 ThinVec::new());\n                         self.arm(hir_vec![err_pat], ret_expr)\n                     };\n \n                     return self.expr_match(e.span, sub_expr, hir_vec![err_arm, ok_arm],\n-                                           hir::MatchSource::TryDesugar, None);\n+                                           hir::MatchSource::TryDesugar);\n                 }\n \n                 ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n@@ -1682,23 +1683,18 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn expr_break(&mut self, span: Span, attrs: ThinAttributes) -> P<hir::Expr> {\n+    fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         self.expr(span, hir::ExprBreak(None), attrs)\n     }\n \n-    fn expr_call(&mut self,\n-                 span: Span,\n-                 e: P<hir::Expr>,\n-                 args: hir::HirVec<P<hir::Expr>>,\n-                 attrs: ThinAttributes)\n+    fn expr_call(&mut self, span: Span, e: P<hir::Expr>, args: hir::HirVec<P<hir::Expr>>)\n                  -> P<hir::Expr> {\n-        self.expr(span, hir::ExprCall(e, args), attrs)\n+        self.expr(span, hir::ExprCall(e, args), ThinVec::new())\n     }\n \n-    fn expr_ident(&mut self, span: Span, id: Name, attrs: ThinAttributes, binding: NodeId)\n-                  -> P<hir::Expr> {\n+    fn expr_ident(&mut self, span: Span, id: Name, binding: NodeId) -> P<hir::Expr> {\n         let expr_path = hir::ExprPath(None, self.path_ident(span, id));\n-        let expr = self.expr(span, expr_path, attrs);\n+        let expr = self.expr(span, expr_path, ThinVec::new());\n \n         let def = self.resolver.definitions().map(|defs| {\n             Def::Local(defs.local_def_id(binding), binding)\n@@ -1708,12 +1704,11 @@ impl<'a> LoweringContext<'a> {\n         expr\n     }\n \n-    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>, attrs: ThinAttributes)\n-                        -> P<hir::Expr> {\n-        self.expr(span, hir::ExprAddrOf(hir::MutMutable, e), attrs)\n+    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> P<hir::Expr> {\n+        self.expr(span, hir::ExprAddrOf(hir::MutMutable, e), ThinVec::new())\n     }\n \n-    fn expr_path(&mut self, path: hir::Path, attrs: ThinAttributes) -> P<hir::Expr> {\n+    fn expr_path(&mut self, path: hir::Path, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         let def = self.resolver.resolve_generated_global_path(&path, true);\n         let expr = self.expr(path.span, hir::ExprPath(None, path), attrs);\n         self.resolver.record_resolution(expr.id, def);\n@@ -1724,34 +1719,32 @@ impl<'a> LoweringContext<'a> {\n                   span: Span,\n                   arg: P<hir::Expr>,\n                   arms: hir::HirVec<hir::Arm>,\n-                  source: hir::MatchSource,\n-                  attrs: ThinAttributes)\n+                  source: hir::MatchSource)\n                   -> P<hir::Expr> {\n-        self.expr(span, hir::ExprMatch(arg, arms, source), attrs)\n+        self.expr(span, hir::ExprMatch(arg, arms, source), ThinVec::new())\n     }\n \n-    fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinAttributes) -> P<hir::Expr> {\n+    fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         self.expr(b.span, hir::ExprBlock(b), attrs)\n     }\n \n-    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<P<hir::Expr>>, attrs: ThinAttributes)\n-                  -> P<hir::Expr> {\n-        self.expr(sp, hir::ExprTup(exprs), attrs)\n+    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<P<hir::Expr>>) -> P<hir::Expr> {\n+        self.expr(sp, hir::ExprTup(exprs), ThinVec::new())\n     }\n \n     fn expr_struct(&mut self,\n                    sp: Span,\n                    path: hir::Path,\n                    fields: hir::HirVec<hir::Field>,\n                    e: Option<P<hir::Expr>>,\n-                   attrs: ThinAttributes) -> P<hir::Expr> {\n+                   attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         let def = self.resolver.resolve_generated_global_path(&path, false);\n         let expr = self.expr(sp, hir::ExprStruct(path, fields, e), attrs);\n         self.resolver.record_resolution(expr.id, def);\n         expr\n     }\n \n-    fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinAttributes) -> P<hir::Expr> {\n+    fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         P(hir::Expr {\n             id: self.next_id(),\n             node: node,\n@@ -1760,12 +1753,7 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn stmt_let(&mut self,\n-                sp: Span,\n-                mutbl: bool,\n-                ident: Name,\n-                ex: P<hir::Expr>,\n-                attrs: ThinAttributes)\n+    fn stmt_let(&mut self, sp: Span, mutbl: bool, ident: Name, ex: P<hir::Expr>)\n                 -> (hir::Stmt, NodeId) {\n         let pat = if mutbl {\n             self.pat_ident_binding_mode(sp, ident, hir::BindByValue(hir::MutMutable))\n@@ -1779,7 +1767,7 @@ impl<'a> LoweringContext<'a> {\n             init: Some(ex),\n             id: self.next_id(),\n             span: sp,\n-            attrs: attrs,\n+            attrs: ThinVec::new(),\n         });\n         let decl = respan(sp, hir::DeclLocal(local));\n         (respan(sp, hir::StmtDecl(P(decl), self.next_id())), pat_id)\n@@ -1939,7 +1927,7 @@ impl<'a> LoweringContext<'a> {\n                          expr: P<hir::Expr>,\n                          span: Span,\n                          rule: hir::BlockCheckMode,\n-                         attrs: ThinAttributes)\n+                         attrs: ThinVec<Attribute>)\n                          -> P<hir::Expr> {\n         let id = self.next_id();\n         let block = P(hir::Block {"}, {"sha": "ec23020eecb6b7e00d50deeba72fc928352bae28", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -27,7 +27,6 @@ use hir::map::{self, Node};\n use syntax::abi;\n use hir::{Block, FnDecl};\n use syntax::ast::{Attribute, Name, NodeId};\n-use syntax::attr::ThinAttributesExt;\n use hir as ast;\n use syntax::codemap::Span;\n use hir::intravisit::FnKind;\n@@ -257,11 +256,7 @@ impl<'a> FnLikeNode<'a> {\n             }\n             map::NodeExpr(e) => match e.node {\n                 ast::ExprClosure(_, ref decl, ref block, _fn_decl_span) =>\n-                    closure(ClosureParts::new(&decl,\n-                                              &block,\n-                                              e.id,\n-                                              e.span,\n-                                              e.attrs.as_attr_slice())),\n+                    closure(ClosureParts::new(&decl, &block, e.id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => bug!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "cf54c89b354d4d23c368e6473b8452e252afe371", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -23,7 +23,6 @@ use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, };\n-use syntax::attr::ThinAttributesExt;\n use syntax::codemap::{Span, Spanned};\n use syntax::visit;\n \n@@ -577,7 +576,7 @@ impl<'ast> Map<'ast> {\n             Some(NodeTraitItem(ref ti)) => Some(&ti.attrs[..]),\n             Some(NodeImplItem(ref ii)) => Some(&ii.attrs[..]),\n             Some(NodeVariant(ref v)) => Some(&v.node.attrs[..]),\n-            Some(NodeExpr(ref e)) => Some(e.attrs.as_attr_slice()),\n+            Some(NodeExpr(ref e)) => Some(&*e.attrs),\n             Some(NodeStmt(ref s)) => Some(s.node.attrs()),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition."}, {"sha": "d3576588aef8f3f1c0cbd2c92f13bf515ea9beea", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -40,9 +40,9 @@ use syntax::codemap::{self, mk_sp, respan, Span, Spanned, ExpnId};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n-use syntax::attr::{ThinAttributes, ThinAttributesExt};\n use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n+use syntax::util::ThinVec;\n \n use std::collections::BTreeMap;\n use std::fmt;\n@@ -732,7 +732,7 @@ impl Stmt_ {\n         match *self {\n             StmtDecl(ref d, _) => d.node.attrs(),\n             StmtExpr(ref e, _) |\n-            StmtSemi(ref e, _) => e.attrs.as_attr_slice(),\n+            StmtSemi(ref e, _) => &e.attrs,\n         }\n     }\n \n@@ -756,7 +756,7 @@ pub struct Local {\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub attrs: ThinAttributes,\n+    pub attrs: ThinVec<Attribute>,\n }\n \n pub type Decl = Spanned<Decl_>;\n@@ -772,7 +772,7 @@ pub enum Decl_ {\n impl Decl_ {\n     pub fn attrs(&self) -> &[Attribute] {\n         match *self {\n-            DeclLocal(ref l) => l.attrs.as_attr_slice(),\n+            DeclLocal(ref l) => &l.attrs,\n             DeclItem(_) => &[]\n         }\n     }\n@@ -817,7 +817,7 @@ pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,\n     pub span: Span,\n-    pub attrs: ThinAttributes,\n+    pub attrs: ThinVec<Attribute>,\n }\n \n impl fmt::Debug for Expr {"}, {"sha": "7d8a3b45bdbda061ad371b5a49b9bf413f9a971d", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -44,7 +44,6 @@ use syntax::codemap::Span;\n use syntax::errors::DiagnosticBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ast;\n-use syntax::attr::ThinAttributesExt;\n use hir;\n use hir::intravisit as hir_visit;\n use hir::intravisit::{IdVisitor, IdVisitingOperation};\n@@ -767,7 +766,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, e: &hir::Expr) {\n-        self.with_lint_attrs(e.attrs.as_attr_slice(), |cx| {\n+        self.with_lint_attrs(&e.attrs, |cx| {\n             run_lints!(cx, check_expr, late_passes, e);\n             hir_visit::walk_expr(cx, e);\n         })\n@@ -832,7 +831,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_local(&mut self, l: &hir::Local) {\n-        self.with_lint_attrs(l.attrs.as_attr_slice(), |cx| {\n+        self.with_lint_attrs(&l.attrs, |cx| {\n             run_lints!(cx, check_local, late_passes, l);\n             hir_visit::walk_local(cx, l);\n         })\n@@ -928,7 +927,7 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n     }\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n-        self.with_lint_attrs(e.attrs.as_attr_slice(), |cx| {\n+        self.with_lint_attrs(&e.attrs, |cx| {\n             run_lints!(cx, check_expr, early_passes, e);\n             ast_visit::walk_expr(cx, e);\n         })\n@@ -988,7 +987,7 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n     }\n \n     fn visit_local(&mut self, l: &ast::Local) {\n-        self.with_lint_attrs(l.attrs.as_attr_slice(), |cx| {\n+        self.with_lint_attrs(&l.attrs, |cx| {\n             run_lints!(cx, check_local, early_passes, l);\n             ast_visit::walk_local(cx, l);\n         })"}, {"sha": "c486c282b2f4bcbf7c663eb67b8713ace4891f47", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -451,7 +451,7 @@ fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n         id: 0,\n         node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n         span: DUMMY_SP,\n-        attrs: None,\n+        attrs: ast::ThinVec::new(),\n     })\n }\n "}, {"sha": "4a7f38dd66be4ba0b75ef410885b221d8b290ccf", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -672,7 +672,7 @@ impl fold::Folder for ReplaceBodyWithLoop {\n                 node: ast::ExprKind::Loop(empty_block, None),\n                 id: ast::DUMMY_NODE_ID,\n                 span: codemap::DUMMY_SP,\n-                attrs: None,\n+                attrs: ast::ThinVec::new(),\n             });\n \n             expr_to_block(b.rules, Some(loop_expr))"}, {"sha": "7fe70217424837e478b896c2ad5f3f9068a0be4a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -14,8 +14,9 @@ pub use self::TyParamBound::*;\n pub use self::UnsafeSource::*;\n pub use self::ViewPath_::*;\n pub use self::PathParameters::*;\n+pub use util::ThinVec;\n \n-use attr::{ThinAttributes, HasAttrs};\n+use attr::HasAttrs;\n use codemap::{mk_sp, respan, Span, Spanned, DUMMY_SP, ExpnId};\n use abi::Abi;\n use errors;\n@@ -809,7 +810,7 @@ pub enum StmtKind {\n     /// Expr with trailing semi-colon (may have any type):\n     Semi(P<Expr>, NodeId),\n \n-    Mac(P<Mac>, MacStmtStyle, ThinAttributes),\n+    Mac(P<Mac>, MacStmtStyle, ThinVec<Attribute>),\n }\n \n impl StmtKind {\n@@ -851,7 +852,7 @@ pub struct Local {\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub attrs: ThinAttributes,\n+    pub attrs: ThinVec<Attribute>,\n }\n \n impl Local {\n@@ -912,7 +913,7 @@ pub struct Expr {\n     pub id: NodeId,\n     pub node: ExprKind,\n     pub span: Span,\n-    pub attrs: ThinAttributes\n+    pub attrs: ThinVec<Attribute>\n }\n \n impl Expr {"}, {"sha": "200df680ca67679060c77294dfd5092851274635", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 7, "deletions": 80, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -26,6 +26,7 @@ use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::InternedString;\n use parse::{ParseSess, token};\n use ptr::P;\n+use util::ThinVec;\n \n use std::cell::{RefCell, Cell};\n use std::collections::HashSet;\n@@ -803,80 +804,6 @@ impl IntType {\n     }\n }\n \n-/// A list of attributes, behind a optional box as\n-/// a space optimization.\n-pub type ThinAttributes = Option<Box<Vec<Attribute>>>;\n-\n-pub trait ThinAttributesExt {\n-    fn map_thin_attrs<F>(self, f: F) -> Self\n-        where F: FnOnce(Vec<Attribute>) -> Vec<Attribute>;\n-    fn prepend(mut self, attrs: Self) -> Self;\n-    fn append(mut self, attrs: Self) -> Self;\n-    fn update<F>(&mut self, f: F)\n-        where Self: Sized,\n-              F: FnOnce(Self) -> Self;\n-    fn as_attr_slice(&self) -> &[Attribute];\n-    fn into_attr_vec(self) -> Vec<Attribute>;\n-}\n-\n-impl ThinAttributesExt for ThinAttributes {\n-    fn map_thin_attrs<F>(self, f: F) -> Self\n-        where F: FnOnce(Vec<Attribute>) -> Vec<Attribute>\n-    {\n-        f(self.map(|b| *b).unwrap_or(Vec::new())).into_thin_attrs()\n-    }\n-\n-    fn prepend(self, attrs: ThinAttributes) -> Self {\n-        attrs.map_thin_attrs(|mut attrs| {\n-            attrs.extend(self.into_attr_vec());\n-            attrs\n-        })\n-    }\n-\n-    fn append(self, attrs: ThinAttributes) -> Self {\n-        self.map_thin_attrs(|mut self_| {\n-            self_.extend(attrs.into_attr_vec());\n-            self_\n-        })\n-    }\n-\n-    fn update<F>(&mut self, f: F)\n-        where Self: Sized,\n-              F: FnOnce(ThinAttributes) -> ThinAttributes\n-    {\n-        let self_ = f(self.take());\n-        *self = self_;\n-    }\n-\n-    fn as_attr_slice(&self) -> &[Attribute] {\n-        match *self {\n-            Some(ref b) => b,\n-            None => &[],\n-        }\n-    }\n-\n-    fn into_attr_vec(self) -> Vec<Attribute> {\n-        match self {\n-            Some(b) => *b,\n-            None => Vec::new(),\n-        }\n-    }\n-}\n-\n-pub trait AttributesExt {\n-    fn into_thin_attrs(self) -> ThinAttributes;\n-}\n-\n-impl AttributesExt for Vec<Attribute> {\n-    fn into_thin_attrs(self) -> ThinAttributes {\n-        if self.len() == 0 {\n-            None\n-        } else {\n-            Some(Box::new(self))\n-        }\n-    }\n-}\n-\n pub trait HasAttrs: Sized {\n     fn attrs(&self) -> &[ast::Attribute];\n     fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self;\n@@ -885,13 +812,13 @@ pub trait HasAttrs: Sized {\n /// A cheap way to add Attributes to an AST node.\n pub trait WithAttrs {\n     // FIXME: Could be extended to anything IntoIter<Item=Attribute>\n-    fn with_attrs(self, attrs: ThinAttributes) -> Self;\n+    fn with_attrs(self, attrs: ThinVec<Attribute>) -> Self;\n }\n \n impl<T: HasAttrs> WithAttrs for T {\n-    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n+    fn with_attrs(self, attrs: ThinVec<Attribute>) -> Self {\n         self.map_attrs(|mut orig_attrs| {\n-            orig_attrs.extend(attrs.into_attr_vec());\n+            orig_attrs.extend::<Vec<_>>(attrs.into());\n             orig_attrs\n         })\n     }\n@@ -906,12 +833,12 @@ impl HasAttrs for Vec<Attribute> {\n     }\n }\n \n-impl HasAttrs for ThinAttributes {\n+impl HasAttrs for ThinVec<Attribute> {\n     fn attrs(&self) -> &[Attribute] {\n-        self.as_attr_slice()\n+        &self\n     }\n     fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n-        self.map_thin_attrs(f)\n+        f(self.into()).into()\n     }\n }\n "}, {"sha": "bc9f0c1776a168f22f9db1331dd6de29a786b2a7", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -350,7 +350,7 @@ impl DummyResult {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::ExprKind::Lit(P(codemap::respan(sp, ast::LitKind::Bool(false)))),\n             span: sp,\n-            attrs: None,\n+            attrs: ast::ThinVec::new(),\n         })\n     }\n "}, {"sha": "8693b3b8684e137a9561d0da76b04826930a5887", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -525,7 +525,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n-            attrs: None,\n+            attrs: ast::ThinVec::new(),\n         });\n         let decl = respan(sp, ast::DeclKind::Local(local));\n         respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))\n@@ -550,7 +550,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n-            attrs: None,\n+            attrs: ast::ThinVec::new(),\n         });\n         let decl = respan(sp, ast::DeclKind::Local(local));\n         P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))\n@@ -587,7 +587,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: span,\n-            attrs: None,\n+            attrs: ast::ThinVec::new(),\n         })\n     }\n "}, {"sha": "20a5ff932b30834910cc61186f4c44f5581a4875", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -16,7 +16,7 @@ use ast;\n use ext::mtwt;\n use ext::build::AstBuilder;\n use attr;\n-use attr::{AttrMetaMethods, WithAttrs, ThinAttributesExt};\n+use attr::{AttrMetaMethods, WithAttrs};\n use codemap;\n use codemap::{Span, Spanned, ExpnInfo, ExpnId, NameAndSpan, MacroBang, MacroAttribute};\n use config::StripUnconfigured;\n@@ -104,7 +104,7 @@ pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprKind::Mac(mac) => {\n-            expand_mac_invoc(mac, None, expr.attrs.into_attr_vec(), expr.span, fld)\n+            expand_mac_invoc(mac, None, expr.attrs.into(), expr.span, fld)\n         }\n \n         ast::ExprKind::While(cond, body, opt_ident) => {\n@@ -449,7 +449,7 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     };\n \n     let mut fully_expanded: SmallVector<ast::Stmt> =\n-        expand_mac_invoc(mac.unwrap(), None, attrs.into_attr_vec(), stmt.span, fld);\n+        expand_mac_invoc(mac.unwrap(), None, attrs.into(), stmt.span, fld);\n \n     // If this is a macro invocation with a semicolon, then apply that\n     // semicolon to the final statement produced by expansion.\n@@ -1054,7 +1054,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         expr.and_then(|expr| match expr.node {\n             ast::ExprKind::Mac(mac) =>\n-                expand_mac_invoc(mac, None, expr.attrs.into_attr_vec(), expr.span, self),\n+                expand_mac_invoc(mac, None, expr.attrs.into(), expr.span, self),\n             _ => Some(expand_expr(expr, self)),\n         })\n     }"}, {"sha": "58143075e69afff6a55eaef3e2de02d32364fe53", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -250,7 +250,7 @@ pub mod rt {\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::ExprKind::Lit(P(self.clone())),\n                 span: DUMMY_SP,\n-                attrs: None,\n+                attrs: ast::ThinVec::new(),\n             }).to_tokens(cx)\n         }\n     }\n@@ -281,7 +281,7 @@ pub mod rt {\n                         id: ast::DUMMY_NODE_ID,\n                         node: ast::ExprKind::Lit(P(dummy_spanned(lit))),\n                         span: DUMMY_SP,\n-                        attrs: None,\n+                        attrs: ast::ThinVec::new(),\n                     });\n                     if *self >= 0 {\n                         return lit.to_tokens(cx);\n@@ -290,7 +290,7 @@ pub mod rt {\n                         id: ast::DUMMY_NODE_ID,\n                         node: ast::ExprKind::Unary(ast::UnOp::Neg, lit),\n                         span: DUMMY_SP,\n-                        attrs: None,\n+                        attrs: ast::ThinVec::new(),\n                     }).to_tokens(cx)\n                 }\n             }"}, {"sha": "11b835d9455fcc1533ee5463f209e3c18afc380d", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -20,7 +20,6 @@\n \n use ast::*;\n use ast;\n-use attr::{ThinAttributes, ThinAttributesExt};\n use codemap::{respan, Span, Spanned};\n use parse::token::{self, keywords};\n use ptr::P;\n@@ -336,8 +335,8 @@ pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribut\n     attrs.move_flat_map(|x| fld.fold_attribute(x))\n }\n \n-pub fn fold_thin_attrs<T: Folder>(attrs: ThinAttributes, fld: &mut T) -> ThinAttributes {\n-    attrs.map_thin_attrs(|v| fold_attrs(v, fld))\n+pub fn fold_thin_attrs<T: Folder>(attrs: ThinVec<Attribute>, fld: &mut T) -> ThinVec<Attribute> {\n+    fold_attrs(attrs.into(), fld).into()\n }\n \n pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T) -> Arm {\n@@ -498,7 +497,7 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n         pat: fld.fold_pat(pat),\n         init: init.map(|e| fld.fold_expr(e)),\n         span: fld.new_span(span),\n-        attrs: attrs.map_thin_attrs(|v| fold_attrs(v, fld)),\n+        attrs: fold_attrs(attrs.into(), fld).into(),\n     })\n }\n \n@@ -1300,7 +1299,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprKind::Try(ex) => ExprKind::Try(folder.fold_expr(ex)),\n         },\n         span: folder.new_span(span),\n-        attrs: attrs.map_thin_attrs(|v| fold_attrs(v, folder)),\n+        attrs: fold_attrs(attrs.into(), folder).into(),\n     }\n }\n \n@@ -1348,7 +1347,7 @@ pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n         StmtKind::Mac(mac, semi, attrs) => SmallVector::one(Spanned {\n             node: StmtKind::Mac(mac.map(|m| folder.fold_mac(m)),\n                                 semi,\n-                                attrs.map_thin_attrs(|v| fold_attrs(v, folder))),\n+                                fold_attrs(attrs.into(), folder).into()),\n             span: span\n         })\n     }"}, {"sha": "af13f922397457ba71c3412246428aa9dbd6b83b", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -73,6 +73,9 @@ pub mod util {\n     pub mod parser_testing;\n     pub mod small_vector;\n     pub mod move_map;\n+\n+    mod thin_vec;\n+    pub use self::thin_vec::ThinVec;\n }\n \n pub mod diagnostics {"}, {"sha": "f72fb0dedf86abc35aed21ed295d6aa001660f68", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -672,6 +672,7 @@ mod tests {\n     use ptr::P;\n     use util::parser_testing::{string_to_tts, string_to_parser};\n     use util::parser_testing::{string_to_expr, string_to_item, string_to_stmt};\n+    use util::ThinVec;\n \n     // produce a codemap::span\n     fn sp(a: u32, b: u32) -> Span {\n@@ -693,7 +694,7 @@ mod tests {\n                         ),\n                     }),\n                     span: sp(0, 1),\n-                    attrs: None,\n+                    attrs: ThinVec::new(),\n                    }))\n     }\n \n@@ -716,7 +717,7 @@ mod tests {\n                             )\n                         }),\n                     span: sp(0, 6),\n-                    attrs: None,\n+                    attrs: ThinVec::new(),\n                    }))\n     }\n \n@@ -832,10 +833,10 @@ mod tests {\n                             ),\n                         }),\n                         span:sp(7,8),\n-                        attrs: None,\n+                        attrs: ThinVec::new(),\n                     }))),\n                     span:sp(0,8),\n-                    attrs: None,\n+                    attrs: ThinVec::new(),\n                    }))\n     }\n \n@@ -855,7 +856,7 @@ mod tests {\n                                ),\n                             }),\n                            span: sp(0,1),\n-                           attrs: None}),\n+                           attrs: ThinVec::new()}),\n                                            ast::DUMMY_NODE_ID),\n                        span: sp(0,1)}))\n \n@@ -950,7 +951,7 @@ mod tests {\n                                                         ),\n                                                       }),\n                                                 span: sp(17,18),\n-                                                attrs: None,}),\n+                                                attrs: ThinVec::new(),}),\n                                                 ast::DUMMY_NODE_ID),\n                                             span: sp(17,19)}),\n                                         expr: None,"}, {"sha": "827d3f32c01fea4718820e478c2475c6f68e538c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 75, "deletions": 82, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -37,7 +37,6 @@ use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{Ty, TyKind, TypeBinding, TyParam, TyParamBounds};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n-use attr::{ThinAttributes, ThinAttributesExt, AttributesExt};\n use ast::{BinOpKind, UnOp};\n use ast;\n use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n@@ -55,6 +54,7 @@ use util::parser::{AssocOp, Fixity};\n use print::pprust;\n use ptr::P;\n use parse::PResult;\n+use util::ThinVec;\n \n use std::collections::HashSet;\n use std::mem;\n@@ -120,7 +120,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Path(None, pt), None))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Path(None, pt), ThinVec::new()))\n                 }\n                 token::Interpolated(token::NtBlock(_)) => {\n                     // FIXME: The following avoids an issue with lexical borrowck scopes,\n@@ -130,7 +130,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Block(b), None))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Block(b), ThinVec::new()))\n                 }\n                 _ => None\n             };\n@@ -316,12 +316,12 @@ pub struct ModulePathError {\n \n pub enum LhsExpr {\n     NotYetParsed,\n-    AttributesParsed(ThinAttributes),\n+    AttributesParsed(ThinVec<Attribute>),\n     AlreadyParsed(P<Expr>),\n }\n \n-impl From<Option<ThinAttributes>> for LhsExpr {\n-    fn from(o: Option<ThinAttributes>) -> Self {\n+impl From<Option<ThinVec<Attribute>>> for LhsExpr {\n+    fn from(o: Option<ThinVec<Attribute>>) -> Self {\n         if let Some(attrs) = o {\n             LhsExpr::AttributesParsed(attrs)\n         } else {\n@@ -1676,12 +1676,12 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let literal = P(self.parse_lit()?);\n         let hi = self.last_span.hi;\n-        let expr = self.mk_expr(lo, hi, ExprKind::Lit(literal), None);\n+        let expr = self.mk_expr(lo, hi, ExprKind::Lit(literal), ThinVec::new());\n \n         if minus_present {\n             let minus_hi = self.last_span.hi;\n             let unary = self.mk_unary(UnOp::Neg, expr);\n-            Ok(self.mk_expr(minus_lo, minus_hi, unary, None))\n+            Ok(self.mk_expr(minus_lo, minus_hi, unary, ThinVec::new()))\n         } else {\n             Ok(expr)\n         }\n@@ -2039,13 +2039,13 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos,\n-                   node: ExprKind, attrs: ThinAttributes) -> P<Expr> {\n+    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos, node: ExprKind, attrs: ThinVec<Attribute>)\n+                   -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: mk_sp(lo, hi),\n-            attrs: attrs,\n+            attrs: attrs.into(),\n         })\n     }\n \n@@ -2102,7 +2102,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos,\n-                       m: Mac_, attrs: ThinAttributes) -> P<Expr> {\n+                       m: Mac_, attrs: ThinVec<Attribute>) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprKind::Mac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n@@ -2111,7 +2111,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn mk_lit_u32(&mut self, i: u32, attrs: ThinAttributes) -> P<Expr> {\n+    pub fn mk_lit_u32(&mut self, i: u32, attrs: ThinVec<Attribute>) -> P<Expr> {\n         let span = &self.span;\n         let lv_lit = P(codemap::Spanned {\n             node: LitKind::Int(i as u64, ast::LitIntType::Unsigned(UintTy::U32)),\n@@ -2152,7 +2152,7 @@ impl<'a> Parser<'a> {\n         //\n         // Therefore, prevent sub-parser from parsing\n         // attributes by giving them a empty \"already parsed\" list.\n-        let mut attrs = None;\n+        let mut attrs = ThinVec::new();\n \n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n@@ -2164,9 +2164,7 @@ impl<'a> Parser<'a> {\n             token::OpenDelim(token::Paren) => {\n                 self.bump();\n \n-                let attrs = self.parse_inner_attributes()?\n-                    .into_thin_attrs()\n-                    .prepend(attrs);\n+                attrs.extend(self.parse_inner_attributes()?);\n \n                 // (e) is parenthesized e\n                 // (e,) is a tuple with only one field, e\n@@ -2204,9 +2202,7 @@ impl<'a> Parser<'a> {\n             token::OpenDelim(token::Bracket) => {\n                 self.bump();\n \n-                let inner_attrs = self.parse_inner_attributes()?\n-                    .into_thin_attrs();\n-                attrs.update(|attrs| attrs.append(inner_attrs));\n+                attrs.extend(self.parse_inner_attributes()?);\n \n                 if self.check(&token::CloseDelim(token::Bracket)) {\n                     // Empty vector.\n@@ -2363,9 +2359,7 @@ impl<'a> Parser<'a> {\n                             let mut fields = Vec::new();\n                             let mut base = None;\n \n-                            let attrs = attrs.append(\n-                                self.parse_inner_attributes()?\n-                                    .into_thin_attrs());\n+                            attrs.extend(self.parse_inner_attributes()?);\n \n                             while self.token != token::CloseDelim(token::Brace) {\n                                 if self.eat(&token::DotDot) {\n@@ -2432,33 +2426,32 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_or_use_outer_attributes(&mut self,\n-                                     already_parsed_attrs: Option<ThinAttributes>)\n-                                     -> PResult<'a, ThinAttributes> {\n+                                     already_parsed_attrs: Option<ThinVec<Attribute>>)\n+                                     -> PResult<'a, ThinVec<Attribute>> {\n         if let Some(attrs) = already_parsed_attrs {\n             Ok(attrs)\n         } else {\n-            self.parse_outer_attributes().map(|a| a.into_thin_attrs())\n+            self.parse_outer_attributes().map(|a| a.into())\n         }\n     }\n \n     /// Parse a block or unsafe block\n     pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode,\n-                            attrs: ThinAttributes)\n+                            outer_attrs: ThinVec<Attribute>)\n                             -> PResult<'a, P<Expr>> {\n \n-        let outer_attrs = attrs;\n         self.expect(&token::OpenDelim(token::Brace))?;\n \n-        let inner_attrs = self.parse_inner_attributes()?.into_thin_attrs();\n-        let attrs = outer_attrs.append(inner_attrs);\n+        let mut attrs = outer_attrs;\n+        attrs.extend(self.parse_inner_attributes()?);\n \n         let blk = self.parse_block_tail(lo, blk_mode)?;\n         return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), attrs));\n     }\n \n     /// parse a.b or a(13) or a[4] or just a\n     pub fn parse_dot_or_call_expr(&mut self,\n-                                  already_parsed_attrs: Option<ThinAttributes>)\n+                                  already_parsed_attrs: Option<ThinVec<Attribute>>)\n                                   -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n \n@@ -2470,20 +2463,21 @@ impl<'a> Parser<'a> {\n     pub fn parse_dot_or_call_expr_with(&mut self,\n                                        e0: P<Expr>,\n                                        lo: BytePos,\n-                                       attrs: ThinAttributes)\n+                                       mut attrs: ThinVec<Attribute>)\n                                        -> PResult<'a, P<Expr>> {\n         // Stitch the list of outer attributes onto the return value.\n         // A little bit ugly, but the best way given the current code\n         // structure\n         self.parse_dot_or_call_expr_with_(e0, lo)\n         .map(|expr|\n             expr.map(|mut expr| {\n-                expr.attrs.update(|a| a.prepend(attrs));\n+                attrs.extend::<Vec<_>>(expr.attrs.into());\n+                expr.attrs = attrs;\n                 match expr.node {\n                     ExprKind::If(..) | ExprKind::IfLet(..) => {\n-                        if !expr.attrs.as_attr_slice().is_empty() {\n+                        if !expr.attrs.is_empty() {\n                             // Just point to the first attribute in there...\n-                            let span = expr.attrs.as_attr_slice()[0].span;\n+                            let span = expr.attrs[0].span;\n \n                             self.span_err(span,\n                                 \"attributes are not yet allowed on `if` \\\n@@ -2531,7 +2525,7 @@ impl<'a> Parser<'a> {\n                 es.insert(0, self_value);\n                 let id = spanned(ident_span.lo, ident_span.hi, ident);\n                 let nd = self.mk_method_call(id, tys, es);\n-                self.mk_expr(lo, hi, nd, None)\n+                self.mk_expr(lo, hi, nd, ThinVec::new())\n             }\n             // Field access.\n             _ => {\n@@ -2544,7 +2538,7 @@ impl<'a> Parser<'a> {\n \n                 let id = spanned(ident_span.lo, ident_span.hi, ident);\n                 let field = self.mk_field(self_value, id);\n-                self.mk_expr(lo, ident_span.hi, field, None)\n+                self.mk_expr(lo, ident_span.hi, field, ThinVec::new())\n             }\n         })\n     }\n@@ -2556,7 +2550,7 @@ impl<'a> Parser<'a> {\n             // expr?\n             while self.eat(&token::Question) {\n                 let hi = self.last_span.hi;\n-                e = self.mk_expr(lo, hi, ExprKind::Try(e), None);\n+                e = self.mk_expr(lo, hi, ExprKind::Try(e), ThinVec::new());\n             }\n \n             // expr.f\n@@ -2584,7 +2578,7 @@ impl<'a> Parser<'a> {\n                         Some(n) => {\n                             let id = spanned(dot, hi, n);\n                             let field = self.mk_tup_field(e, id);\n-                            e = self.mk_expr(lo, hi, field, None);\n+                            e = self.mk_expr(lo, hi, field, ThinVec::new());\n                         }\n                         None => {\n                             let last_span = self.last_span;\n@@ -2636,7 +2630,7 @@ impl<'a> Parser<'a> {\n                 hi = self.last_span.hi;\n \n                 let nd = self.mk_call(e, es);\n-                e = self.mk_expr(lo, hi, nd, None);\n+                e = self.mk_expr(lo, hi, nd, ThinVec::new());\n               }\n \n               // expr[...]\n@@ -2647,7 +2641,7 @@ impl<'a> Parser<'a> {\n                 hi = self.span.hi;\n                 self.commit_expr_expecting(&ix, token::CloseDelim(token::Bracket))?;\n                 let index = self.mk_index(e, ix);\n-                e = self.mk_expr(lo, hi, index, None)\n+                e = self.mk_expr(lo, hi, index, ThinVec::new())\n               }\n               _ => return Ok(e)\n             }\n@@ -2878,7 +2872,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a prefix-unary-operator expr\n     pub fn parse_prefix_expr(&mut self,\n-                             already_parsed_attrs: Option<ThinAttributes>)\n+                             already_parsed_attrs: Option<ThinVec<Attribute>>)\n                              -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n         let lo = self.span.lo;\n@@ -2923,8 +2917,7 @@ impl<'a> Parser<'a> {\n                 let blk = self.parse_block()?;\n                 let span = blk.span;\n                 hi = span.hi;\n-                let blk_expr = self.mk_expr(span.lo, span.hi, ExprKind::Block(blk),\n-                                            None);\n+                let blk_expr = self.mk_expr(span.lo, hi, ExprKind::Block(blk), ThinVec::new());\n                 ExprKind::InPlace(place, blk_expr)\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n@@ -2944,7 +2937,7 @@ impl<'a> Parser<'a> {\n     /// This parses an expression accounting for associativity and precedence of the operators in\n     /// the expression.\n     pub fn parse_assoc_expr(&mut self,\n-                            already_parsed_attrs: Option<ThinAttributes>)\n+                            already_parsed_attrs: Option<ThinVec<Attribute>>)\n                             -> PResult<'a, P<Expr>> {\n         self.parse_assoc_expr_with(0, already_parsed_attrs.into())\n     }\n@@ -2997,13 +2990,13 @@ impl<'a> Parser<'a> {\n             // Special cases:\n             if op == AssocOp::As {\n                 let rhs = self.parse_ty()?;\n-                lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n-                                   ExprKind::Cast(lhs, rhs), None);\n+                let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n+                lhs = self.mk_expr(lo, hi, ExprKind::Cast(lhs, rhs), ThinVec::new());\n                 continue\n             } else if op == AssocOp::Colon {\n                 let rhs = self.parse_ty()?;\n-                lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n-                                   ExprKind::Type(lhs, rhs), None);\n+                let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n+                lhs = self.mk_expr(lo, hi, ExprKind::Type(lhs, rhs), ThinVec::new());\n                 continue\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotDot {\n                 // If we didn\u2019t have to handle `x..`/`x...`, it would be pretty easy to\n@@ -3029,7 +3022,7 @@ impl<'a> Parser<'a> {\n                 };\n \n                 let r = try!(self.mk_range(Some(lhs), rhs, limits));\n-                lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, None);\n+                lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, ThinVec::new());\n                 break\n             }\n \n@@ -3056,21 +3049,21 @@ impl<'a> Parser<'a> {\n                 }),\n             }?;\n \n+            let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n             lhs = match op {\n                 AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide |\n                 AssocOp::Modulus | AssocOp::LAnd | AssocOp::LOr | AssocOp::BitXor |\n                 AssocOp::BitAnd | AssocOp::BitOr | AssocOp::ShiftLeft | AssocOp::ShiftRight |\n                 AssocOp::Equal | AssocOp::Less | AssocOp::LessEqual | AssocOp::NotEqual |\n                 AssocOp::Greater | AssocOp::GreaterEqual => {\n                     let ast_op = op.to_ast_binop().unwrap();\n-                    let (lhs_span, rhs_span) = (lhs_span, rhs.span);\n                     let binary = self.mk_binary(codemap::respan(cur_op_span, ast_op), lhs, rhs);\n-                    self.mk_expr(lhs_span.lo, rhs_span.hi, binary, None)\n+                    self.mk_expr(lo, hi, binary, ThinVec::new())\n                 }\n                 AssocOp::Assign =>\n-                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprKind::Assign(lhs, rhs), None),\n+                    self.mk_expr(lo, hi, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n                 AssocOp::Inplace =>\n-                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprKind::InPlace(lhs, rhs), None),\n+                    self.mk_expr(lo, hi, ExprKind::InPlace(lhs, rhs), ThinVec::new()),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus =>    BinOpKind::Add,\n@@ -3084,9 +3077,8 @@ impl<'a> Parser<'a> {\n                         token::Shl =>     BinOpKind::Shl,\n                         token::Shr =>     BinOpKind::Shr,\n                     };\n-                    let (lhs_span, rhs_span) = (lhs_span, rhs.span);\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n-                    self.mk_expr(lhs_span.lo, rhs_span.hi, aopexpr, None)\n+                    self.mk_expr(lo, hi, aopexpr, ThinVec::new())\n                 }\n                 AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotDot => {\n                     self.bug(\"As, Colon, DotDot or DotDotDot branch reached\")\n@@ -3121,7 +3113,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse prefix-forms of range notation: `..expr`, `..`, `...expr`\n     fn parse_prefix_range_expr(&mut self,\n-                               already_parsed_attrs: Option<ThinAttributes>)\n+                               already_parsed_attrs: Option<ThinVec<Attribute>>)\n                                -> PResult<'a, P<Expr>> {\n         debug_assert!(self.token == token::DotDot || self.token == token::DotDotDot);\n         let tok = self.token.clone();\n@@ -3166,7 +3158,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an 'if' or 'if let' expression ('if' token already eaten)\n-    pub fn parse_if_expr(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+    pub fn parse_if_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         if self.check_keyword(keywords::Let) {\n             return self.parse_if_let_expr(attrs);\n         }\n@@ -3184,7 +3176,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an 'if let' expression ('if' token already eaten)\n-    pub fn parse_if_let_expr(&mut self, attrs: ThinAttributes)\n+    pub fn parse_if_let_expr(&mut self, attrs: ThinVec<Attribute>)\n                              -> PResult<'a, P<Expr>> {\n         let lo = self.last_span.lo;\n         self.expect_keyword(keywords::Let)?;\n@@ -3205,7 +3197,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_lambda_expr(&mut self,\n                              lo: BytePos,\n                              capture_clause: CaptureBy,\n-                             attrs: ThinAttributes)\n+                             attrs: ThinVec<Attribute>)\n                              -> PResult<'a, P<Expr>>\n     {\n         let decl = self.parse_fn_block_decl()?;\n@@ -3240,24 +3232,24 @@ impl<'a> Parser<'a> {\n     // `else` token already eaten\n     pub fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n         if self.eat_keyword(keywords::If) {\n-            return self.parse_if_expr(None);\n+            return self.parse_if_expr(ThinVec::new());\n         } else {\n             let blk = self.parse_block()?;\n-            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), None));\n+            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), ThinVec::new()));\n         }\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n     pub fn parse_for_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                           span_lo: BytePos,\n-                          attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+                          mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         let pat = self.parse_pat()?;\n         self.expect_keyword(keywords::In)?;\n         let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n-        let attrs = attrs.append(iattrs.into_thin_attrs());\n+        attrs.extend(iattrs);\n \n         let hi = self.last_span.hi;\n \n@@ -3269,13 +3261,13 @@ impl<'a> Parser<'a> {\n     /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n     pub fn parse_while_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                             span_lo: BytePos,\n-                            attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+                            mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         if self.token.is_keyword(keywords::Let) {\n             return self.parse_while_let_expr(opt_ident, span_lo, attrs);\n         }\n         let cond = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        let attrs = attrs.append(iattrs.into_thin_attrs());\n+        attrs.extend(iattrs);\n         let hi = body.span.hi;\n         return Ok(self.mk_expr(span_lo, hi, ExprKind::While(cond, body, opt_ident),\n                                attrs));\n@@ -3284,29 +3276,29 @@ impl<'a> Parser<'a> {\n     /// Parse a 'while let' expression ('while' token already eaten)\n     pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                                 span_lo: BytePos,\n-                                attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+                                mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n         let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        let attrs = attrs.append(iattrs.into_thin_attrs());\n+        attrs.extend(iattrs);\n         let hi = body.span.hi;\n         return Ok(self.mk_expr(span_lo, hi, ExprKind::WhileLet(pat, expr, body, opt_ident), attrs));\n     }\n \n     // parse `loop {...}`, `loop` token already eaten\n     pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                            span_lo: BytePos,\n-                           attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+                           mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        let attrs = attrs.append(iattrs.into_thin_attrs());\n+        attrs.extend(iattrs);\n         let hi = body.span.hi;\n         Ok(self.mk_expr(span_lo, hi, ExprKind::Loop(body, opt_ident), attrs))\n     }\n \n     // `match` token already eaten\n-    fn parse_match_expr(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n+    fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let match_span = self.last_span;\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n@@ -3318,8 +3310,8 @@ impl<'a> Parser<'a> {\n             }\n             return Err(e)\n         }\n-        let attrs = attrs.append(\n-            self.parse_inner_attributes()?.into_thin_attrs());\n+        attrs.extend(self.parse_inner_attributes()?);\n+\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::CloseDelim(token::Brace) {\n             match self.parse_arm() {\n@@ -3392,7 +3384,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse an expression, subject to the given restrictions\n     pub fn parse_expr_res(&mut self, r: Restrictions,\n-                          already_parsed_attrs: Option<ThinAttributes>)\n+                          already_parsed_attrs: Option<ThinVec<Attribute>>)\n                           -> PResult<'a, P<Expr>> {\n         self.with_res(r, |this| this.parse_assoc_expr(already_parsed_attrs))\n     }\n@@ -3590,7 +3582,7 @@ impl<'a> Parser<'a> {\n                 (None, self.parse_path(PathStyle::Expr)?)\n             };\n             let hi = self.last_span.hi;\n-            Ok(self.mk_expr(lo, hi, ExprKind::Path(qself, path), None))\n+            Ok(self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new()))\n         } else {\n             self.parse_pat_literal_maybe_minus()\n         }\n@@ -3685,7 +3677,8 @@ impl<'a> Parser<'a> {\n                       token::DotDotDot => {\n                         // Parse range\n                         let hi = self.last_span.hi;\n-                        let begin = self.mk_expr(lo, hi, ExprKind::Path(qself, path), None);\n+                        let begin =\n+                              self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new());\n                         self.bump();\n                         let end = self.parse_pat_range_end()?;\n                         pat = PatKind::Range(begin, end);\n@@ -3785,7 +3778,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a local variable declaration\n-    fn parse_local(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Local>> {\n+    fn parse_local(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Local>> {\n         let lo = self.span.lo;\n         let pat = self.parse_pat()?;\n \n@@ -3805,7 +3798,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a \"let\" stmt\n-    fn parse_let(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Decl>> {\n+    fn parse_let(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Decl>> {\n         let lo = self.span.lo;\n         let local = self.parse_local(attrs)?;\n         Ok(P(spanned(lo, self.last_span.hi, DeclKind::Local(local))))\n@@ -3925,7 +3918,7 @@ impl<'a> Parser<'a> {\n \n         Ok(Some(if self.check_keyword(keywords::Let) {\n             self.expect_keyword(keywords::Let)?;\n-            let decl = self.parse_let(attrs.into_thin_attrs())?;\n+            let decl = self.parse_let(attrs.into())?;\n             let hi = decl.span.hi;\n             let stmt = StmtKind::Decl(decl, ast::DUMMY_NODE_ID);\n             spanned(lo, hi, stmt)\n@@ -3980,7 +3973,7 @@ impl<'a> Parser<'a> {\n \n             if id.name == keywords::Invalid.name() {\n                 let mac = P(spanned(lo, hi, Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT }));\n-                let stmt = StmtKind::Mac(mac, style, attrs.into_thin_attrs());\n+                let stmt = StmtKind::Mac(mac, style, attrs.into());\n                 spanned(lo, hi, stmt)\n             } else {\n                 // if it has a special ident, it's definitely an item\n@@ -4036,7 +4029,7 @@ impl<'a> Parser<'a> {\n \n                     // Remainder are line-expr stmts.\n                     let e = self.parse_expr_res(\n-                        Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into_thin_attrs()))?;\n+                        Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into()))?;\n                     let hi = e.span.hi;\n                     let stmt = StmtKind::Expr(e, ast::DUMMY_NODE_ID);\n                     spanned(lo, hi, stmt)\n@@ -4111,7 +4104,7 @@ impl<'a> Parser<'a> {\n                         _ => {\n                             let e = self.mk_mac_expr(span.lo, span.hi,\n                                                      mac.and_then(|m| m.node),\n-                                                     None);\n+                                                     ThinVec::new());\n                             let lo = e.span.lo;\n                             let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n                             let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;"}, {"sha": "620295fce889b272cad0176f1daf950ff0945f53", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -14,7 +14,6 @@ use abi::{self, Abi};\n use ast::{self, TokenTree, BlockCheckMode, PatKind};\n use ast::{SelfKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Attribute;\n-use attr::ThinAttributesExt;\n use util::parser::AssocOp;\n use attr;\n use attr::{AttrMetaMethods, AttributeMethods};\n@@ -1606,7 +1605,7 @@ impl<'a> State<'a> {\n             }\n             ast::StmtKind::Mac(ref mac, style, ref attrs) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_outer_attributes(attrs.as_attr_slice()));\n+                try!(self.print_outer_attributes(&attrs));\n                 let delim = match style {\n                     ast::MacStmtStyle::Braces => token::Brace,\n                     _ => token::Paren\n@@ -1946,7 +1945,7 @@ impl<'a> State<'a> {\n                                   is_inline: bool) -> io::Result<()> {\n         try!(self.maybe_print_comment(expr.span.lo));\n \n-        let attrs = expr.attrs.as_attr_slice();\n+        let attrs = &expr.attrs;\n         if is_inline {\n             try!(self.print_outer_attributes_inline(attrs));\n         } else {\n@@ -2090,9 +2089,7 @@ impl<'a> State<'a> {\n                     let i_expr = body.expr.as_ref().unwrap();\n                     match i_expr.node {\n                         ast::ExprKind::Block(ref blk) => {\n-                            try!(self.print_block_unclosed_with_attrs(\n-                                &blk,\n-                                i_expr.attrs.as_attr_slice()));\n+                            try!(self.print_block_unclosed_with_attrs(&blk, &i_expr.attrs));\n                         }\n                         _ => {\n                             // this is a bare expression\n@@ -2281,7 +2278,7 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(decl.span.lo));\n         match decl.node {\n             ast::DeclKind::Local(ref loc) => {\n-                try!(self.print_outer_attributes(loc.attrs.as_attr_slice()));\n+                try!(self.print_outer_attributes(&loc.attrs));\n                 try!(self.space_if_not_bol());\n                 try!(self.ibox(INDENT_UNIT));\n                 try!(self.word_nbsp(\"let\"));"}, {"sha": "efeccc6acb6aaf7d308a4a603ec0bbc57d3a9a6e", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -604,10 +604,10 @@ fn mk_test_descs(cx: &TestCtxt) -> P<ast::Expr> {\n                     mk_test_desc_and_fn_rec(cx, test)\n                 }).collect()),\n                 span: DUMMY_SP,\n-                attrs: None,\n+                attrs: ast::ThinVec::new(),\n             })),\n         span: DUMMY_SP,\n-        attrs: None,\n+        attrs: ast::ThinVec::new(),\n     })\n }\n "}, {"sha": "546686b46b8db4c92f2474b4f64ee354938cbe5a", "filename": "src/libsyntax/util/thin_vec.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Futil%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Futil%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fthin_vec.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// A vector type optimized for cases where this size is usually 0 (c.f. `SmallVector`).\n+/// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n+/// which uses only a single (null) pointer.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ThinVec<T>(Option<Box<Vec<T>>>);\n+\n+impl<T> ThinVec<T> {\n+    pub fn new() -> Self {\n+        ThinVec(None)\n+    }\n+}\n+\n+impl<T> From<Vec<T>> for ThinVec<T> {\n+    fn from(vec: Vec<T>) -> Self {\n+        if vec.is_empty() {\n+            ThinVec(None)\n+        } else {\n+            ThinVec(Some(Box::new(vec)))\n+        }\n+    }\n+}\n+\n+impl<T> Into<Vec<T>> for ThinVec<T> {\n+    fn into(self) -> Vec<T> {\n+        match self {\n+            ThinVec(None) => Vec::new(),\n+            ThinVec(Some(vec)) => *vec,\n+        }\n+    }\n+}\n+\n+impl<T> ::std::ops::Deref for ThinVec<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        match *self {\n+            ThinVec(None) => &[],\n+            ThinVec(Some(ref vec)) => vec,\n+        }\n+    }\n+}\n+\n+impl<T> Extend<T> for ThinVec<T> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        match *self {\n+            ThinVec(Some(ref mut vec)) => vec.extend(iter),\n+            ThinVec(None) => *self = iter.into_iter().collect::<Vec<_>>().into(),\n+        }\n+    }\n+}"}, {"sha": "6588e3d60e1c23512441b2e75608d5bde761df0b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -25,7 +25,6 @@\n \n use abi::Abi;\n use ast::*;\n-use attr::ThinAttributesExt;\n use codemap::{Span, Spanned};\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n@@ -185,7 +184,7 @@ pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n }\n \n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n-    for attr in local.attrs.as_attr_slice() {\n+    for attr in local.attrs.iter() {\n         visitor.visit_attribute(attr);\n     }\n     visitor.visit_pat(&local.pat);\n@@ -619,7 +618,7 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n         }\n         StmtKind::Mac(ref mac, _, ref attrs) => {\n             visitor.visit_mac(mac);\n-            for attr in attrs.as_attr_slice() {\n+            for attr in attrs.iter() {\n                 visitor.visit_attribute(attr);\n             }\n         }\n@@ -638,7 +637,7 @@ pub fn walk_mac<'v, V: Visitor<'v>>(_: &mut V, _: &'v Mac) {\n }\n \n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n-    for attr in expression.attrs.as_attr_slice() {\n+    for attr in expression.attrs.iter() {\n         visitor.visit_attribute(attr);\n     }\n     match expression.node {"}, {"sha": "bae21841b5ad1bcde18ae7b7ca87108c40605625", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -260,6 +260,6 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             expn_id: expn_id,\n         }),\n         span: sp,\n-        attrs: None,\n+        attrs: ast::ThinVec::new(),\n     }))\n }"}, {"sha": "71c3251c1b18e8c7fdbd0cbd9fe5713f9a64c914", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -70,7 +70,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::ExprKind::Path(None, self.path()),\n                 span: self.span,\n-                attrs: None,\n+                attrs: ast::ThinVec::new(),\n             }))\n         }\n "}, {"sha": "3f695949b3949b253865d3bf9509ee5692e04548", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -149,7 +149,7 @@ fn stmt_let_undescore(cx: &mut ExtCtxt,\n         init: Some(expr),\n         id: ast::DUMMY_NODE_ID,\n         span: sp,\n-        attrs: None,\n+        attrs: ast::ThinVec::new(),\n     });\n     let decl = respan(sp, ast::DeclKind::Local(local));\n     respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))"}, {"sha": "64747002a65b03542eab3abc54bd4f4950be6a02", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033eca65f1dd9585aafa9cddd9d4bfd71b820c1/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=5033eca65f1dd9585aafa9cddd9d4bfd71b820c1", "patch": "@@ -86,7 +86,7 @@ fn check_expr_attrs(es: &str, expected: &[&str]) {\n     let actual = &e.attrs;\n     str_compare(es,\n                 &expected.iter().map(|r| attr(r, &ps).unwrap()).collect::<Vec<_>>(),\n-                actual.as_attr_slice(),\n+                &actual,\n                 pprust::attribute_to_string);\n }\n "}]}