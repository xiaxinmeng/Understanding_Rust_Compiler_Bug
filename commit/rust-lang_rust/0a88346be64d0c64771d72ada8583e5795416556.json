{"sha": "0a88346be64d0c64771d72ada8583e5795416556", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhODgzNDZiZTY0ZDBjNjQ3NzFkNzJhZGE4NTgzZTU3OTU0MTY1NTY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-08-02T10:17:20Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-08-03T21:34:11Z"}, "message": "rustc_ast: `(Nested)MetaItem::check_name` -> `has_name`\n\nFor consistency with `Attribute::has_name` which doesn't mark the attribute as used either.\n\nReplace all uses of `check_name` with `has_name` outside of rustc", "tree": {"sha": "b8f8e406c56e2847f0b0e0dbf83c9d2224d906c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8f8e406c56e2847f0b0e0dbf83c9d2224d906c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a88346be64d0c64771d72ada8583e5795416556", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a88346be64d0c64771d72ada8583e5795416556", "html_url": "https://github.com/rust-lang/rust/commit/0a88346be64d0c64771d72ada8583e5795416556", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a88346be64d0c64771d72ada8583e5795416556/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "829d69b9c6bfc535a92fc290ec9391a0d5af6c81", "url": "https://api.github.com/repos/rust-lang/rust/commits/829d69b9c6bfc535a92fc290ec9391a0d5af6c81", "html_url": "https://github.com/rust-lang/rust/commit/829d69b9c6bfc535a92fc290ec9391a0d5af6c81"}], "stats": {"total": 179, "additions": 90, "deletions": 89}, "files": [{"sha": "022e49a7ea4c2c7f5d1bd5bf673ac1f59ddc21f8", "filename": "src/librustc_ast/attr/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fattr%2Fmod.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -100,8 +100,8 @@ impl NestedMetaItem {\n     }\n \n     /// Returns `true` if this list item is a MetaItem with a name of `name`.\n-    pub fn check_name(&self, name: Symbol) -> bool {\n-        self.meta_item().map_or(false, |meta_item| meta_item.check_name(name))\n+    pub fn has_name(&self, name: Symbol) -> bool {\n+        self.meta_item().map_or(false, |meta_item| meta_item.has_name(name))\n     }\n \n     /// For a single-segment meta item, returns its name; otherwise, returns `None`.\n@@ -173,8 +173,9 @@ impl Attribute {\n         }\n     }\n \n-    /// Returns `true` if the attribute's path matches the argument. If it matches, then the\n-    /// attribute is marked as used.\n+    /// Returns `true` if the attribute's path matches the argument.\n+    /// If it matches, then the attribute is marked as used.\n+    /// Should only be used by rustc, other tools can use `has_name` instead.\n     pub fn check_name(&self, name: Symbol) -> bool {\n         let matches = self.has_name(name);\n         if matches {\n@@ -278,7 +279,7 @@ impl MetaItem {\n         }\n     }\n \n-    pub fn check_name(&self, name: Symbol) -> bool {\n+    pub fn has_name(&self, name: Symbol) -> bool {\n         self.path == name\n     }\n \n@@ -405,7 +406,7 @@ pub fn mk_doc_comment(style: AttrStyle, comment: Symbol, span: Span) -> Attribut\n }\n \n pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n-    items.iter().any(|item| item.check_name(name))\n+    items.iter().any(|item| item.has_name(name))\n }\n \n pub fn contains_name(attrs: &[Attribute], name: Symbol) -> bool {"}, {"sha": "22eaca4f071e21748c62d7d25d80e92883fa28ca", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -243,7 +243,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         if attr.check_name(sym::doc) {\n             for nested_meta in attr.meta_item_list().unwrap_or_default() {\n                 macro_rules! gate_doc { ($($name:ident => $feature:ident)*) => {\n-                    $(if nested_meta.check_name(sym::$name) {\n+                    $(if nested_meta.has_name(sym::$name) {\n                         let msg = concat!(\"`#[doc(\", stringify!($name), \")]` is experimental\");\n                         gate_feature_post!(self, $feature, attr.span, msg);\n                     })*\n@@ -314,7 +314,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ItemKind::Struct(..) => {\n                 for attr in attr::filter_by_name(&i.attrs[..], sym::repr) {\n                     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-                        if item.check_name(sym::simd) {\n+                        if item.has_name(sym::simd) {\n                             gate_feature_post!(\n                                 &self,\n                                 repr_simd,"}, {"sha": "983202aafabd58c4d12e8904d11c458e15af1487", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -92,9 +92,9 @@ pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Op\n             if let Some(meta) = attr.meta() {\n                 if let MetaItemKind::List(items) = meta.kind {\n                     if items.len() == 1 {\n-                        if items[0].check_name(sym::allowed) {\n+                        if items[0].has_name(sym::allowed) {\n                             return Some(UnwindAttr::Allowed);\n-                        } else if items[0].check_name(sym::aborts) {\n+                        } else if items[0].has_name(sym::aborts) {\n                             return Some(UnwindAttr::Aborts);\n                         }\n                     }\n@@ -168,7 +168,7 @@ pub fn contains_feature_attr(attrs: &[Attribute], feature_name: Symbol) -> bool\n         item.check_name(sym::feature)\n             && item\n                 .meta_item_list()\n-                .map(|list| list.iter().any(|mi| mi.is_word() && mi.check_name(feature_name)))\n+                .map(|list| list.iter().any(|mi| mi.is_word() && mi.has_name(feature_name)))\n                 .unwrap_or(false)\n     })\n }\n@@ -505,7 +505,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n }\n \n fn try_gate_cfg(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) {\n-    let gate = find_gated_cfg(|sym| cfg.check_name(sym));\n+    let gate = find_gated_cfg(|sym| cfg.has_name(sym));\n     if let (Some(feats), Some(gated_cfg)) = (features, gate) {\n         gate_cfg(&gated_cfg, cfg.span, sess, feats);\n     }\n@@ -898,7 +898,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                     }\n                 } else {\n                     if let Some(meta_item) = item.meta_item() {\n-                        if meta_item.check_name(sym::align) {\n+                        if meta_item.has_name(sym::align) {\n                             if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n                                 recognised = true;\n                                 let mut err = struct_span_err!("}, {"sha": "763bdca35ebe61c166aaf0dc70cc0a572c0b76fa", "filename": "src/librustc_builtin_macros/proc_macro_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -143,7 +143,7 @@ impl<'a> CollectProcMacros<'a> {\n \n         let attributes_attr = list.get(1);\n         let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n-            if !attr.check_name(sym::attributes) {\n+            if !attr.has_name(sym::attributes) {\n                 self.handler.span_err(attr.span(), \"second argument must be `attributes`\")\n             }\n             attr.meta_item_list()"}, {"sha": "29095034ba9f109205a7198f4f80986b11b4ecbe", "filename": "src/librustc_builtin_macros/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_builtin_macros%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_builtin_macros%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -336,7 +336,7 @@ fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n                 Some(list) => {\n                     let msg = list\n                         .iter()\n-                        .find(|mi| mi.check_name(sym::expected))\n+                        .find(|mi| mi.has_name(sym::expected))\n                         .and_then(|mi| mi.meta_item())\n                         .and_then(|mi| mi.value_str());\n                     if list.len() != 1 || msg.is_none() {"}, {"sha": "0cc340c205ac8db7daf5073f33b87712a7174f96", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -1644,14 +1644,14 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         }\n \n         if let Some(list) = at.meta_item_list() {\n-            if !list.iter().any(|it| it.check_name(sym::include)) {\n+            if !list.iter().any(|it| it.has_name(sym::include)) {\n                 return noop_visit_attribute(at, self);\n             }\n \n             let mut items = vec![];\n \n             for mut it in list {\n-                if !it.check_name(sym::include) {\n+                if !it.has_name(sym::include) {\n                     items.push({\n                         noop_visit_meta_list_item(&mut it, self);\n                         it"}, {"sha": "d451d9a22a48b359cf2ace4005e5f26e7551439b", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -149,7 +149,7 @@ impl AssertModuleSource<'tcx> {\n \n     fn field(&self, attr: &ast::Attribute, name: Symbol) -> Symbol {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-            if item.check_name(name) {\n+            if item.has_name(name) {\n                 if let Some(value) = item.value_str() {\n                     return value;\n                 } else {"}, {"sha": "02f37f82352a9b762ef180a2e19b3158281b860a", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -231,7 +231,7 @@ impl DirtyCleanVisitor<'tcx> {\n \n     fn labels(&self, attr: &Attribute) -> Option<Labels> {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-            if item.check_name(LABEL) {\n+            if item.has_name(LABEL) {\n                 let value = expect_associated_value(self.tcx, &item);\n                 return Some(self.resolve_labels(&item, value));\n             }\n@@ -242,7 +242,7 @@ impl DirtyCleanVisitor<'tcx> {\n     /// `except=` attribute value\n     fn except(&self, attr: &Attribute) -> Labels {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-            if item.check_name(EXCEPT) {\n+            if item.has_name(EXCEPT) {\n                 let value = expect_associated_value(self.tcx, &item);\n                 return self.resolve_labels(&item, value);\n             }\n@@ -474,15 +474,15 @@ fn check_config(tcx: TyCtxt<'_>, attr: &Attribute) -> bool {\n     debug!(\"check_config: config={:?}\", config);\n     let (mut cfg, mut except, mut label) = (None, false, false);\n     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-        if item.check_name(CFG) {\n+        if item.has_name(CFG) {\n             let value = expect_associated_value(tcx, &item);\n             debug!(\"check_config: searching for cfg {:?}\", value);\n             cfg = Some(config.contains(&(value, None)));\n         }\n-        if item.check_name(LABEL) {\n+        if item.has_name(LABEL) {\n             label = true;\n         }\n-        if item.check_name(EXCEPT) {\n+        if item.has_name(EXCEPT) {\n             except = true;\n         }\n     }"}, {"sha": "6515708e115a59101249b6a5951de08e6b123760", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -330,7 +330,7 @@ fn has_doc(attr: &ast::Attribute) -> bool {\n \n     if let Some(list) = attr.meta_item_list() {\n         for meta in list {\n-            if meta.check_name(sym::include) || meta.check_name(sym::hidden) {\n+            if meta.has_name(sym::include) || meta.has_name(sym::hidden) {\n                 return true;\n             }\n         }"}, {"sha": "d01c598d059c0a468e6b0ffd17f2aedb39bd84d4", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -58,7 +58,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n             let mut kind_specified = false;\n \n             for item in items.iter() {\n-                if item.check_name(sym::kind) {\n+                if item.has_name(sym::kind) {\n                     kind_specified = true;\n                     let kind = match item.value_str() {\n                         Some(name) => name,\n@@ -84,9 +84,9 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                             NativeLibKind::Unspecified\n                         }\n                     };\n-                } else if item.check_name(sym::name) {\n+                } else if item.has_name(sym::name) {\n                     lib.name = item.value_str();\n-                } else if item.check_name(sym::cfg) {\n+                } else if item.has_name(sym::cfg) {\n                     let cfg = match item.meta_item_list() {\n                         Some(list) => list,\n                         None => continue, // skip like historical compilers\n@@ -98,7 +98,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                     } else {\n                         self.tcx.sess.span_err(cfg[0].span(), \"invalid argument for `cfg(..)`\");\n                     }\n-                } else if item.check_name(sym::wasm_import_module) {\n+                } else if item.has_name(sym::wasm_import_module) {\n                     match item.value_str() {\n                         Some(s) => lib.wasm_import_module = Some(s),\n                         None => {"}, {"sha": "2113d40a594ebd3b237d7c79c155f847ae9491c7", "filename": "src/librustc_mir/dataflow/framework/engine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -339,7 +339,7 @@ impl RustcMirAttrs {\n             .flat_map(|attr| attr.meta_item_list().into_iter().flat_map(|v| v.into_iter()));\n \n         for attr in rustc_mir_attrs {\n-            let attr_result = if attr.check_name(sym::borrowck_graphviz_postflow) {\n+            let attr_result = if attr.has_name(sym::borrowck_graphviz_postflow) {\n                 Self::set_field(&mut ret.basename_and_suffix, tcx, &attr, |s| {\n                     let path = PathBuf::from(s.to_string());\n                     match path.file_name() {\n@@ -350,7 +350,7 @@ impl RustcMirAttrs {\n                         }\n                     }\n                 })\n-            } else if attr.check_name(sym::borrowck_graphviz_format) {\n+            } else if attr.has_name(sym::borrowck_graphviz_format) {\n                 Self::set_field(&mut ret.formatter, tcx, &attr, |s| match s {\n                     sym::gen_kill | sym::two_phase => Ok(s),\n                     _ => {"}, {"sha": "8a9edb23a10ef45b2ccaeca6d8cb0c645848540d", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -34,7 +34,7 @@ pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Opti\n             let items = attr.meta_item_list();\n             for item in items.iter().flat_map(|l| l.iter()) {\n                 match item.meta_item() {\n-                    Some(mi) if mi.check_name(name) => return Some(mi.clone()),\n+                    Some(mi) if mi.has_name(name) => return Some(mi.clone()),\n                     _ => continue,\n                 }\n             }"}, {"sha": "1ff47ee038d3bf9703f098431122dbc7d64dc93c", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -222,7 +222,7 @@ impl CheckAttrVisitor<'tcx> {\n         if let Some(mi) = attr.meta() {\n             if let Some(list) = mi.meta_item_list() {\n                 for meta in list {\n-                    if meta.check_name(sym::alias) {\n+                    if meta.has_name(sym::alias) {\n                         if !meta.is_value_str()\n                             || meta\n                                 .value_str()"}, {"sha": "8e379a3510038d916c88f34705ac5797fcb77710", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -832,10 +832,10 @@ impl<'tcx> SaveContext<'tcx> {\n                 if let Some(meta_list) = attr.meta_item_list() {\n                     meta_list\n                         .into_iter()\n-                        .filter(|it| it.check_name(sym::include))\n+                        .filter(|it| it.has_name(sym::include))\n                         .filter_map(|it| it.meta_item_list().map(|l| l.to_owned()))\n                         .flat_map(|it| it)\n-                        .filter(|meta| meta.check_name(sym::contents))\n+                        .filter(|meta| meta.has_name(sym::contents))\n                         .filter_map(|meta| meta.value_str())\n                         .for_each(|val| {\n                             result.push_str(&val.as_str());"}, {"sha": "446d5a489df48a6101c7547d638de1aabcea2dff", "filename": "src/librustc_trait_selection/traits/on_unimplemented.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -95,27 +95,27 @@ impl<'tcx> OnUnimplementedDirective {\n         };\n \n         for item in item_iter {\n-            if item.check_name(sym::message) && message.is_none() {\n+            if item.has_name(sym::message) && message.is_none() {\n                 if let Some(message_) = item.value_str() {\n                     message = parse_value(message_)?;\n                     continue;\n                 }\n-            } else if item.check_name(sym::label) && label.is_none() {\n+            } else if item.has_name(sym::label) && label.is_none() {\n                 if let Some(label_) = item.value_str() {\n                     label = parse_value(label_)?;\n                     continue;\n                 }\n-            } else if item.check_name(sym::note) && note.is_none() {\n+            } else if item.has_name(sym::note) && note.is_none() {\n                 if let Some(note_) = item.value_str() {\n                     note = parse_value(note_)?;\n                     continue;\n                 }\n-            } else if item.check_name(sym::enclosing_scope) && enclosing_scope.is_none() {\n+            } else if item.has_name(sym::enclosing_scope) && enclosing_scope.is_none() {\n                 if let Some(enclosing_scope_) = item.value_str() {\n                     enclosing_scope = parse_value(enclosing_scope_)?;\n                     continue;\n                 }\n-            } else if item.check_name(sym::on)\n+            } else if item.has_name(sym::on)\n                 && is_root\n                 && message.is_none()\n                 && label.is_none()"}, {"sha": "97df065500a1666885a4a0446705649ff9716893", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -2231,7 +2231,7 @@ fn from_target_feature(\n     let rust_features = tcx.features();\n     for item in list {\n         // Only `enable = ...` is accepted in the meta-item list.\n-        if !item.check_name(sym::enable) {\n+        if !item.has_name(sym::enable) {\n             bad_item(item.span());\n             continue;\n         }\n@@ -2483,11 +2483,11 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n             no_sanitize_span = Some(attr.span);\n             if let Some(list) = attr.meta_item_list() {\n                 for item in list.iter() {\n-                    if item.check_name(sym::address) {\n+                    if item.has_name(sym::address) {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::ADDRESS;\n-                    } else if item.check_name(sym::memory) {\n+                    } else if item.has_name(sym::memory) {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n-                    } else if item.check_name(sym::thread) {\n+                    } else if item.has_name(sym::thread) {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::THREAD;\n                     } else {\n                         tcx.sess"}, {"sha": "2a090d6efa5fd38a5bed05e08c4480e6d9bab3bb", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -113,7 +113,7 @@ impl Clean<ExternalCrate> for CrateNum {\n                 let mut prim = None;\n                 for attr in attrs.lists(sym::doc) {\n                     if let Some(v) = attr.value_str() {\n-                        if attr.check_name(sym::primitive) {\n+                        if attr.has_name(sym::primitive) {\n                             prim = PrimitiveType::from_symbol(v);\n                             if prim.is_some() {\n                                 break;\n@@ -168,7 +168,7 @@ impl Clean<ExternalCrate> for CrateNum {\n                 let mut keyword = None;\n                 for attr in attrs.lists(sym::doc) {\n                     if let Some(v) = attr.value_str() {\n-                        if attr.check_name(sym::keyword) {\n+                        if attr.has_name(sym::keyword) {\n                             if v.is_doc_keyword() {\n                                 keyword = Some(v.to_string());\n                                 break;\n@@ -2157,7 +2157,7 @@ impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n         let please_inline = self.vis.node.is_pub()\n             && self.attrs.iter().any(|a| {\n-                a.check_name(sym::doc)\n+                a.has_name(sym::doc)\n                     && match a.meta_item_list() {\n                         Some(l) => attr::list_contains_name(&l, sym::inline),\n                         None => false,\n@@ -2197,7 +2197,7 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let mut denied = !self.vis.node.is_pub()\n             || self.attrs.iter().any(|a| {\n-                a.check_name(sym::doc)\n+                a.has_name(sym::doc)\n                     && match a.meta_item_list() {\n                         Some(l) => {\n                             attr::list_contains_name(&l, sym::no_inline)"}, {"sha": "1bea41b658532f2d29e9e6d973713e7fef8e8cdb", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -210,7 +210,7 @@ impl Item {\n     }\n \n     pub fn is_non_exhaustive(&self) -> bool {\n-        self.attrs.other_attrs.iter().any(|a| a.check_name(sym::non_exhaustive))\n+        self.attrs.other_attrs.iter().any(|a| a.has_name(sym::non_exhaustive))\n     }\n \n     /// Returns a documentation-level item type from the item.\n@@ -309,7 +309,7 @@ impl<'a> Iterator for ListAttributesIter<'a> {\n \n         for attr in &mut self.attrs {\n             if let Some(list) = attr.meta_item_list() {\n-                if attr.check_name(self.name) {\n+                if attr.has_name(self.name) {\n                     self.current_list = list.into_iter();\n                     if let Some(nested) = self.current_list.next() {\n                         return Some(nested);\n@@ -345,7 +345,7 @@ pub trait NestedAttributesExt {\n \n impl<I: IntoIterator<Item = ast::NestedMetaItem>> NestedAttributesExt for I {\n     fn has_word(self, word: Symbol) -> bool {\n-        self.into_iter().any(|attr| attr.is_word() && attr.check_name(word))\n+        self.into_iter().any(|attr| attr.is_word() && attr.has_name(word))\n     }\n }\n \n@@ -425,7 +425,7 @@ impl Attributes {\n         if let ast::MetaItemKind::List(ref nmis) = mi.kind {\n             if nmis.len() == 1 {\n                 if let MetaItem(ref cfg_mi) = nmis[0] {\n-                    if cfg_mi.check_name(sym::cfg) {\n+                    if cfg_mi.has_name(sym::cfg) {\n                         if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.kind {\n                             if cfg_nmis.len() == 1 {\n                                 if let MetaItem(ref content_mi) = cfg_nmis[0] {\n@@ -447,7 +447,7 @@ impl Attributes {\n     pub fn extract_include(mi: &ast::MetaItem) -> Option<(String, String)> {\n         mi.meta_item_list().and_then(|list| {\n             for meta in list {\n-                if meta.check_name(sym::include) {\n+                if meta.has_name(sym::include) {\n                     // the actual compiled `#[doc(include=\"filename\")]` gets expanded to\n                     // `#[doc(include(file=\"filename\", contents=\"file contents\")]` so we need to\n                     // look for that instead\n@@ -456,11 +456,11 @@ impl Attributes {\n                         let mut contents: Option<String> = None;\n \n                         for it in list {\n-                            if it.check_name(sym::file) {\n+                            if it.has_name(sym::file) {\n                                 if let Some(name) = it.value_str() {\n                                     filename = Some(name.to_string());\n                                 }\n-                            } else if it.check_name(sym::contents) {\n+                            } else if it.has_name(sym::contents) {\n                                 if let Some(docs) = it.value_str() {\n                                     contents = Some(docs.to_string());\n                                 }\n@@ -482,12 +482,12 @@ impl Attributes {\n \n     pub fn has_doc_flag(&self, flag: Symbol) -> bool {\n         for attr in &self.other_attrs {\n-            if !attr.check_name(sym::doc) {\n+            if !attr.has_name(sym::doc) {\n                 continue;\n             }\n \n             if let Some(items) = attr.meta_item_list() {\n-                if items.iter().filter_map(|i| i.meta_item()).any(|it| it.check_name(flag)) {\n+                if items.iter().filter_map(|i| i.meta_item()).any(|it| it.has_name(flag)) {\n                     return true;\n                 }\n             }\n@@ -521,7 +521,7 @@ impl Attributes {\n                     }\n                     None\n                 } else {\n-                    if attr.check_name(sym::doc) {\n+                    if attr.has_name(sym::doc) {\n                         if let Some(mi) = attr.meta() {\n                             if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n                                 // Extracted #[doc(cfg(...))]\n@@ -548,7 +548,7 @@ impl Attributes {\n         // treat #[target_feature(enable = \"feat\")] attributes as if they were\n         // #[doc(cfg(target_feature = \"feat\"))] attributes as well\n         for attr in attrs.lists(sym::target_feature) {\n-            if attr.check_name(sym::enable) {\n+            if attr.has_name(sym::enable) {\n                 if let Some(feat) = attr.value_str() {\n                     let meta = attr::mk_name_value_item_str(\n                         Ident::with_dummy_span(sym::target_feature),\n@@ -648,7 +648,7 @@ impl Attributes {\n     pub fn get_doc_aliases(&self) -> FxHashSet<String> {\n         self.other_attrs\n             .lists(sym::doc)\n-            .filter(|a| a.check_name(sym::alias))\n+            .filter(|a| a.has_name(sym::alias))\n             .filter_map(|a| a.value_str().map(|s| s.to_string().replace(\"\\\"\", \"\")))\n             .filter(|v| !v.is_empty())\n             .collect::<FxHashSet<_>>()"}, {"sha": "5a9e9dda6771ecb7854a6346768bb3c841f0f6b0", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -48,7 +48,7 @@ pub fn extern_location(\n     // external crate\n     e.attrs\n         .lists(sym::doc)\n-        .filter(|a| a.check_name(sym::html_root_url))\n+        .filter(|a| a.has_name(sym::html_root_url))\n         .filter_map(|a| a.value_str())\n         .map(|url| {\n             let mut url = url.to_string();"}, {"sha": "ba1341e652c395cf7f289ffb43694daf9b7d07a7", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -175,17 +175,17 @@ fn scrape_test_config(krate: &::rustc_hir::Crate<'_>) -> TestOptions {\n         .item\n         .attrs\n         .iter()\n-        .filter(|a| a.check_name(sym::doc))\n+        .filter(|a| a.has_name(sym::doc))\n         .flat_map(|a| a.meta_item_list().unwrap_or_else(Vec::new))\n-        .filter(|a| a.check_name(sym::test))\n+        .filter(|a| a.has_name(sym::test))\n         .collect();\n     let attrs = test_attrs.iter().flat_map(|a| a.meta_item_list().unwrap_or(&[]));\n \n     for attr in attrs {\n-        if attr.check_name(sym::no_crate_inject) {\n+        if attr.has_name(sym::no_crate_inject) {\n             opts.no_crate_inject = true;\n         }\n-        if attr.check_name(sym::attr) {\n+        if attr.has_name(sym::attr) {\n             if let Some(l) = attr.meta_item_list() {\n                 for item in l {\n                     opts.attrs.push(pprust::meta_list_item_to_string(item));"}, {"sha": "cf57ffd0b4b305532d41bcda67bd6942a4ed0e9b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -165,11 +165,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     ) {\n         debug!(\"visiting fn\");\n         let macro_kind = item.attrs.iter().find_map(|a| {\n-            if a.check_name(sym::proc_macro) {\n+            if a.has_name(sym::proc_macro) {\n                 Some(MacroKind::Bang)\n-            } else if a.check_name(sym::proc_macro_derive) {\n+            } else if a.has_name(sym::proc_macro_derive) {\n                 Some(MacroKind::Derive)\n-            } else if a.check_name(sym::proc_macro_attribute) {\n+            } else if a.has_name(sym::proc_macro_attribute) {\n                 Some(MacroKind::Attr)\n             } else {\n                 None\n@@ -189,7 +189,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n                 let mut helpers = Vec::new();\n                 for mi in item.attrs.lists(sym::proc_macro_derive) {\n-                    if !mi.check_name(sym::attributes) {\n+                    if !mi.has_name(sym::attributes) {\n                         continue;\n                     }\n \n@@ -419,8 +419,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 // anything as it will probably be stripped anyway.\n                 if item.vis.node.is_pub() && self.inside_public_path {\n                     let please_inline = item.attrs.iter().any(|item| match item.meta_item_list() {\n-                        Some(ref list) if item.check_name(sym::doc) => {\n-                            list.iter().any(|i| i.check_name(sym::inline))\n+                        Some(ref list) if item.has_name(sym::doc) => {\n+                            list.iter().any(|i| i.has_name(sym::inline))\n                         }\n                         _ => false,\n                     });"}, {"sha": "40af6bb3d7bcff06c605c0bd4a04238a3fc583e2", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -286,14 +286,14 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                     },\n                     _ => {},\n                 }\n-                if items.is_empty() || !attr.check_name(sym!(deprecated)) {\n+                if items.is_empty() || !attr.has_name(sym!(deprecated)) {\n                     return;\n                 }\n                 for item in items {\n                     if_chain! {\n                         if let NestedMetaItem::MetaItem(mi) = &item;\n                         if let MetaItemKind::NameValue(lit) = &mi.kind;\n-                        if mi.check_name(sym!(since));\n+                        if mi.has_name(sym!(since));\n                         then {\n                             check_semver(cx, item.span(), lit);\n                         }\n@@ -309,7 +309,7 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n         }\n         match item.kind {\n             ItemKind::ExternCrate(..) | ItemKind::Use(..) => {\n-                let skip_unused_imports = item.attrs.iter().any(|attr| attr.check_name(sym!(macro_use)));\n+                let skip_unused_imports = item.attrs.iter().any(|attr| attr.has_name(sym!(macro_use)));\n \n                 for attr in item.attrs {\n                     if in_external_macro(cx.sess(), attr.span) {\n@@ -524,7 +524,7 @@ fn check_attrs(cx: &LateContext<'_>, span: Span, name: Name, attrs: &[Attribute]\n \n     for attr in attrs {\n         if let Some(values) = attr.meta_item_list() {\n-            if values.len() != 1 || !attr.check_name(sym!(inline)) {\n+            if values.len() != 1 || !attr.has_name(sym!(inline)) {\n                 continue;\n             }\n             if is_word(&values[0], sym!(always)) {\n@@ -558,7 +558,7 @@ fn check_semver(cx: &LateContext<'_>, span: Span, lit: &Lit) {\n \n fn is_word(nmi: &NestedMetaItem, expected: Symbol) -> bool {\n     if let NestedMetaItem::MetaItem(mi) = &nmi {\n-        mi.is_word() && mi.check_name(expected)\n+        mi.is_word() && mi.has_name(expected)\n     } else {\n         false\n     }\n@@ -618,15 +618,15 @@ fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::as\n fn check_deprecated_cfg_attr(cx: &EarlyContext<'_>, attr: &Attribute) {\n     if_chain! {\n         // check cfg_attr\n-        if attr.check_name(sym!(cfg_attr));\n+        if attr.has_name(sym!(cfg_attr));\n         if let Some(items) = attr.meta_item_list();\n         if items.len() == 2;\n         // check for `rustfmt`\n         if let Some(feature_item) = items[0].meta_item();\n-        if feature_item.check_name(sym!(rustfmt));\n+        if feature_item.has_name(sym!(rustfmt));\n         // check for `rustfmt_skip` and `rustfmt::skip`\n         if let Some(skip_item) = &items[1].meta_item();\n-        if skip_item.check_name(sym!(rustfmt_skip)) ||\n+        if skip_item.has_name(sym!(rustfmt_skip)) ||\n             skip_item.path.segments.last().expect(\"empty path in attribute\").ident.name == sym!(skip);\n         // Only lint outer attributes, because custom inner attributes are unstable\n         // Tracking issue: https://github.com/rust-lang/rust/issues/54726\n@@ -685,7 +685,7 @@ fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n     }\n \n     if_chain! {\n-        if attr.check_name(sym!(cfg));\n+        if attr.has_name(sym!(cfg));\n         if let Some(list) = attr.meta_item_list();\n         let mismatched = find_mismatched_target_os(&list);\n         if !mismatched.is_empty();"}, {"sha": "e87c33d1b09dd42d6e688b0e079a7760817b4a36", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -323,7 +323,7 @@ fn check_attrs<'a>(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs\n             let (comment, current_spans) = strip_doc_comment_decoration(&comment, attr.span);\n             spans.extend_from_slice(&current_spans);\n             doc.push_str(&comment);\n-        } else if attr.check_name(sym!(doc)) {\n+        } else if attr.has_name(sym!(doc)) {\n             // ignore mix of sugared and non-sugared doc\n             // don't trigger the safety or errors check\n             return DocHeaders {"}, {"sha": "4b605fdb366a91b0bdb5620ba81ee6c730f9bf83", "filename": "src/tools/clippy/clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -41,7 +41,7 @@ impl<'tcx> LateLintPass<'tcx> for InlineFnWithoutBody {\n \n fn check_attrs(cx: &LateContext<'_>, name: Symbol, attrs: &[Attribute]) {\n     for attr in attrs {\n-        if !attr.check_name(sym!(inline)) {\n+        if !attr.has_name(sym!(inline)) {\n             continue;\n         }\n "}, {"sha": "ca1381852daeead7d134f9edcebbc33d360c1e96", "filename": "src/tools/clippy/clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -83,7 +83,7 @@ fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants\n     }\n \n     fn is_doc_hidden(attr: &Attribute) -> bool {\n-        attr.check_name(sym!(doc))\n+        attr.has_name(sym!(doc))\n             && match attr.meta_item_list() {\n                 Some(l) => attr::list_contains_name(&l, sym!(hidden)),\n                 None => false,"}, {"sha": "813f9c4394819034ded9055b97499207ef272c60", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext<'tcx>, attrs: &'tcx [ast::Attribute]) {\n         let doc_hidden = self.doc_hidden()\n             || attrs.iter().any(|attr| {\n-                attr.check_name(sym!(doc))\n+                attr.has_name(sym!(doc))\n                     && match attr.meta_item_list() {\n                         None => false,\n                         Some(l) => attr::list_contains_name(&l[..], sym!(hidden)),"}, {"sha": "3eae45b2819d849510a5b47f3d1e8e2f7ef93f2b", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -57,7 +57,7 @@ declare_clippy_lint! {\n }\n \n fn check_missing_inline_attrs(cx: &LateContext<'_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n-    let has_inline = attrs.iter().any(|a| a.check_name(sym!(inline)));\n+    let has_inline = attrs.iter().any(|a| a.has_name(sym!(inline)));\n     if !has_inline {\n         span_lint(\n             cx,"}, {"sha": "9391049c6e8f95d6513b0c8444bdcd94b5d3224a", "filename": "src/tools/clippy/clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -112,7 +112,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n     }\n \n     fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if item.attrs.iter().any(|a| a.check_name(sym!(automatically_derived))) {\n+        if item.attrs.iter().any(|a| a.has_name(sym!(automatically_derived))) {\n             debug_assert!(self.derived_item.is_none());\n             self.derived_item = Some(item.hir_id);\n         }"}, {"sha": "a7f7c97fc487cf0e937a681c84c32662c3b37e5e", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -312,7 +312,7 @@ fn requires_exact_signature(attrs: &[Attribute]) -> bool {\n     attrs.iter().any(|attr| {\n         [sym!(proc_macro), sym!(proc_macro_attribute), sym!(proc_macro_derive)]\n             .iter()\n-            .any(|&allow| attr.check_name(allow))\n+            .any(|&allow| attr.has_name(allow))\n     })\n }\n "}, {"sha": "8ed20995a70af1257708ba3b8b278dc08adbec8d", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -235,7 +235,7 @@ impl EarlyLintPass for Return {\n }\n \n fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n-    attr.meta_item_list().is_some() && attr.check_name(sym!(cfg))\n+    attr.meta_item_list().is_some() && attr.has_name(sym!(cfg))\n }\n \n // get the def site"}, {"sha": "7948d99162b8116b91b6236a8f0a1d1945406b34", "filename": "src/tools/clippy/clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -155,7 +155,7 @@ impl<'tcx> LateLintPass<'tcx> for TriviallyCopyPassByRef {\n                     return;\n                 }\n                 for a in attrs {\n-                    if a.meta_item_list().is_some() && a.check_name(sym!(proc_macro_derive)) {\n+                    if a.meta_item_list().is_some() && a.has_name(sym!(proc_macro_derive)) {\n                         return;\n                     }\n                 }"}, {"sha": "ba3492a6fff1136dc1d70fcce17ef362da35292d", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a88346be64d0c64771d72ada8583e5795416556/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=0a88346be64d0c64771d72ada8583e5795416556", "patch": "@@ -13,7 +13,7 @@ use std::{env, fmt, fs, io};\n /// Gets the configuration file from arguments.\n pub fn file_from_args(args: &[NestedMetaItem]) -> Result<Option<PathBuf>, (&'static str, Span)> {\n     for arg in args.iter().filter_map(NestedMetaItem::meta_item) {\n-        if arg.check_name(sym!(conf_file)) {\n+        if arg.has_name(sym!(conf_file)) {\n             return match arg.kind {\n                 MetaItemKind::Word | MetaItemKind::List(_) => Err((\"`conf_file` must be a named value\", arg.span)),\n                 MetaItemKind::NameValue(ref value) => {"}]}