{"sha": "8878a4030acf5285a48e7e248e5f96e4d01060ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NzhhNDAzMGFjZjUyODVhNDhlN2UyNDhlNWY5NmU0ZDAxMDYwZWM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-28T11:35:00Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-28T11:35:00Z"}, "message": "rustup to rustc 1.17.0-nightly (60a0edc6c 2017-02-26)", "tree": {"sha": "1037a4ee5fcb19bc7afa58c55ed28e6b5249a831", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1037a4ee5fcb19bc7afa58c55ed28e6b5249a831"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8878a4030acf5285a48e7e248e5f96e4d01060ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8878a4030acf5285a48e7e248e5f96e4d01060ec", "html_url": "https://github.com/rust-lang/rust/commit/8878a4030acf5285a48e7e248e5f96e4d01060ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8878a4030acf5285a48e7e248e5f96e4d01060ec/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "feeb13c4b95a8291625a375df6d4d2122606e0aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/feeb13c4b95a8291625a375df6d4d2122606e0aa", "html_url": "https://github.com/rust-lang/rust/commit/feeb13c4b95a8291625a375df6d4d2122606e0aa"}], "stats": {"total": 317, "additions": 215, "deletions": 102}, "files": [{"sha": "1a1102c13a1c0d4b7f7f48303a1634ee504ebff4", "filename": "src/eval_context.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8878a4030acf5285a48e7e248e5f96e4d01060ec/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8878a4030acf5285a48e7e248e5f96e4d01060ec/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=8878a4030acf5285a48e7e248e5f96e4d01060ec", "patch": "@@ -649,16 +649,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     },\n \n                     UnsafeFnPointer => match dest_ty.sty {\n-                        ty::TyFnPtr(unsafe_fn_ty) => {\n+                        ty::TyFnPtr(_) => {\n                             let src = self.eval_operand(operand)?;\n-                            let ptr = src.read_ptr(&self.memory)?;\n-                            let fn_def = self.memory.get_fn(ptr.alloc_id)?.expect_concrete()?;\n-                            let unsafe_fn_ty = self.tcx.erase_regions(&unsafe_fn_ty);\n-                            let fn_ptr = self.memory.create_fn_ptr(self.tcx, fn_def.def_id, fn_def.substs, unsafe_fn_ty);\n-                            self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n+                            self.write_value(src, dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n                     },\n+\n+                    ClosureFnPointer => match self.operand_ty(operand).sty {\n+                        ty::TyClosure(def_id, substs) => {\n+                            let fn_ty = self.tcx.closure_type(def_id, substs);\n+                            let fn_ptr = self.memory.create_fn_ptr_from_noncapture_closure(self.tcx, def_id, substs, fn_ty);\n+                            self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n+                        },\n+                        ref other => bug!(\"reify fn pointer on {:?}\", other),\n+                    },\n                 }\n             }\n "}, {"sha": "fd035b7fcba691c98bb5698592aa76e20ce96483", "filename": "src/memory.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8878a4030acf5285a48e7e248e5f96e4d01060ec/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8878a4030acf5285a48e7e248e5f96e4d01060ec/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=8878a4030acf5285a48e7e248e5f96e4d01060ec", "patch": "@@ -130,15 +130,11 @@ pub enum Function<'tcx> {\n     FnPtrAsTraitObject(&'tcx ty::FnSig<'tcx>),\n     /// Glue for Closures\n     Closure(FunctionDefinition<'tcx>),\n+    /// Glue for noncapturing closures casted to function pointers\n+    NonCaptureClosureAsFnPtr(FunctionDefinition<'tcx>),\n }\n \n impl<'tcx> Function<'tcx> {\n-    pub fn expect_concrete(self) -> EvalResult<'tcx, FunctionDefinition<'tcx>> {\n-        match self {\n-            Function::Concrete(fn_def) => Ok(fn_def),\n-            other => Err(EvalError::ExpectedConcreteFunction(other)),\n-        }\n-    }\n     pub fn expect_drop_glue_real_ty(self) -> EvalResult<'tcx, ty::Ty<'tcx>> {\n         match self {\n             Function::DropGlue(real_ty) => Ok(real_ty),\n@@ -238,6 +234,23 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }))\n     }\n \n+    pub fn create_fn_ptr_from_noncapture_closure(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: ClosureSubsts<'tcx>, fn_ty: ClosureTy<'tcx>) -> Pointer {\n+        // FIXME: this is a hack\n+        let fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: fn_ty.unsafety,\n+            abi: fn_ty.abi,\n+            sig: fn_ty.sig,\n+        });\n+        self.create_fn_alloc(Function::NonCaptureClosureAsFnPtr(FunctionDefinition {\n+            def_id,\n+            substs: substs.substs,\n+            abi: Abi::Rust, // adjust abi\n+            // FIXME: why doesn't this compile?\n+            //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n+            sig: fn_ty.sig.skip_binder(),\n+        }))\n+    }\n+\n     pub fn create_fn_as_trait_glue(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n         self.create_fn_alloc(Function::FnDefAsTraitObject(FunctionDefinition {\n             def_id,\n@@ -535,6 +548,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                     trace!(\"{} closure glue for {}\", msg, dump_fn_def(fn_def));\n                     continue;\n                 },\n+                (None, Some(&Function::NonCaptureClosureAsFnPtr(fn_def))) => {\n+                    trace!(\"{} non-capture closure as fn ptr glue for {}\", msg, dump_fn_def(fn_def));\n+                    continue;\n+                },\n                 (None, None) => {\n                     trace!(\"{} (deallocated)\", msg);\n                     continue;"}, {"sha": "0befb5ba9fc1cda259aca3bf78f778a25c858b60", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 144, "deletions": 86, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/8878a4030acf5285a48e7e248e5f96e4d01060ec/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8878a4030acf5285a48e7e248e5f96e4d01060ec/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=8878a4030acf5285a48e7e248e5f96e4d01060ec", "patch": "@@ -2,14 +2,14 @@ use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::ty::layout::Layout;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, BareFnTy};\n+use rustc::ty::{self, Ty};\n use syntax::codemap::Span;\n use syntax::attr;\n \n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n use lvalue::Lvalue;\n-use memory::{Pointer, FunctionDefinition};\n+use memory::{Pointer, FunctionDefinition, Function};\n use value::PrimVal;\n use value::Value;\n \n@@ -61,35 +61,54 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n \n                 let func_ty = self.operand_ty(func);\n-                match func_ty.sty {\n+                let fn_def = match func_ty.sty {\n                     ty::TyFnPtr(bare_fn_ty) => {\n                         let fn_ptr = self.eval_operand_to_primval(func)?.to_ptr()?;\n-                        let FunctionDefinition {def_id, substs, abi, sig} = self.memory.get_fn(fn_ptr.alloc_id)?.expect_concrete()?;\n+                        let fn_def = self.memory.get_fn(fn_ptr.alloc_id)?;\n                         let bare_sig = self.tcx.erase_late_bound_regions_and_normalize(&bare_fn_ty.sig);\n                         let bare_sig = self.tcx.erase_regions(&bare_sig);\n-                        // transmuting function pointers in miri is fine as long as the number of\n-                        // arguments and the abi don't change.\n-                        // FIXME: also check the size of the arguments' type and the return type\n-                        // Didn't get it to work, since that triggers an assertion in rustc which\n-                        // checks whether the type has escaping regions\n-                        if abi != bare_fn_ty.abi ||\n-                           sig.variadic != bare_sig.variadic ||\n-                           sig.inputs().len() != bare_sig.inputs().len() {\n-                            return Err(EvalError::FunctionPointerTyMismatch(abi, sig, bare_fn_ty));\n+                        match fn_def {\n+                            Function::Concrete(fn_def) => {\n+                                // transmuting function pointers in miri is fine as long as the number of\n+                                // arguments and the abi don't change.\n+                                // FIXME: also check the size of the arguments' type and the return type\n+                                // Didn't get it to work, since that triggers an assertion in rustc which\n+                                // checks whether the type has escaping regions\n+                                if fn_def.abi != bare_fn_ty.abi ||\n+                                    fn_def.sig.variadic != bare_sig.variadic ||\n+                                    fn_def.sig.inputs().len() != bare_sig.inputs().len() {\n+                                    return Err(EvalError::FunctionPointerTyMismatch(fn_def.abi, fn_def.sig, bare_fn_ty));\n+                                }\n+                            },\n+                            Function::NonCaptureClosureAsFnPtr(fn_def) => {\n+                                if fn_def.abi != bare_fn_ty.abi ||\n+                                    fn_def.sig.variadic != bare_sig.variadic ||\n+                                    fn_def.sig.inputs().len() != 1 {\n+                                    return Err(EvalError::FunctionPointerTyMismatch(fn_def.abi, fn_def.sig, bare_fn_ty));\n+                                }\n+                                if let ty::TyTuple(fields, _) = fn_def.sig.inputs()[0].sty {\n+                                    if fields.len() != bare_sig.inputs().len() {\n+                                        return Err(EvalError::FunctionPointerTyMismatch(fn_def.abi, fn_def.sig, bare_fn_ty));\n+                                    }\n+                                }\n+                            },\n+                            other => return Err(EvalError::ExpectedConcreteFunction(other)),\n                         }\n-                        self.eval_fn_call(def_id, substs, bare_fn_ty, destination, args,\n-                                          terminator.source_info.span)?\n+                        self.memory.get_fn(fn_ptr.alloc_id)?\n                     },\n-                    ty::TyFnDef(def_id, substs, fn_ty) => {\n-                        self.eval_fn_call(def_id, substs, fn_ty, destination, args,\n-                                          terminator.source_info.span)?\n-                    }\n+                    ty::TyFnDef(def_id, substs, fn_ty) => Function::Concrete(FunctionDefinition {\n+                        def_id,\n+                        substs,\n+                        abi: fn_ty.abi,\n+                        sig: fn_ty.sig.skip_binder(),\n+                    }),\n \n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func_ty);\n                         return Err(EvalError::Unimplemented(msg));\n                     }\n-                }\n+                };\n+                self.eval_fn_call(fn_def, destination, args, terminator.source_info.span)?;\n             }\n \n             Drop { ref location, target, .. } => {\n@@ -138,17 +157,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn eval_fn_call(\n         &mut self,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n-        fn_ty: &'tcx BareFnTy,\n+        fn_def: Function<'tcx>,\n         destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n     ) -> EvalResult<'tcx> {\n         use syntax::abi::Abi;\n-        match fn_ty.abi {\n-            Abi::RustIntrinsic => {\n-                let ty = fn_ty.sig.0.output();\n+        match fn_def {\n+            // Intrinsics can only be addressed directly\n+            Function::Concrete(FunctionDefinition { def_id, substs, abi: Abi::RustIntrinsic, sig }) => {\n+                let ty = sig.output();\n                 let layout = self.type_layout(ty)?;\n                 let (ret, target) = match destination {\n                     Some(dest) if is_inhabited(self.tcx, ty) => dest,\n@@ -157,18 +175,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.call_intrinsic(def_id, substs, arg_operands, ret, ty, layout, target)?;\n                 self.dump_local(ret);\n                 Ok(())\n-            }\n-\n-            Abi::C => {\n-                let ty = fn_ty.sig.0.output();\n+            },\n+            // C functions can only be addressed directly\n+            Function::Concrete(FunctionDefinition { def_id, abi: Abi::C, sig, ..}) => {\n+                let ty = sig.output();\n                 let (ret, target) = destination.unwrap();\n                 self.call_c_abi(def_id, arg_operands, ret, ty)?;\n                 self.dump_local(ret);\n                 self.goto_block(target);\n                 Ok(())\n-            }\n-\n-            Abi::Rust | Abi::RustCall => {\n+            },\n+            Function::DropGlue(_) => Err(EvalError::ManuallyCalledDropGlue),\n+            Function::Concrete(FunctionDefinition { def_id, abi: Abi::RustCall, sig, substs }) |\n+            Function::Concrete(FunctionDefinition { def_id, abi: Abi::Rust, sig, substs }) => {\n                 let mut args = Vec::new();\n                 for arg in arg_operands {\n                     let arg_val = self.eval_operand(arg)?;\n@@ -185,7 +204,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     };\n \n                 // FIXME(eddyb) Detect ADT constructors more efficiently.\n-                if let Some(adt_def) = fn_ty.sig.skip_binder().output().ty_adt_def() {\n+                if let Some(adt_def) = sig.output().ty_adt_def() {\n                     if let Some(v) = adt_def.variants.iter().find(|v| resolved_def_id == v.did) {\n                         let (lvalue, target) = destination.expect(\"tuple struct constructors can't diverge\");\n                         let dest_ty = self.tcx.item_type(adt_def.did);\n@@ -240,66 +259,105 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         return Ok(());\n                     }\n                 }\n-\n-                let mir = match self.load_mir(resolved_def_id) {\n-                    Ok(mir) => mir,\n-                    Err(EvalError::NoMirFor(path)) => {\n-                        match &path[..] {\n-                            // let's just ignore all output for now\n-                            \"std::io::_print\" => {\n-                                self.goto_block(destination.unwrap().1);\n-                                return Ok(());\n-                            },\n-                            \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n-                            \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n-                            \"std::panicking::rust_panic_with_hook\" |\n-                            \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n-                            \"std::panicking::panicking\" |\n-                            \"std::rt::panicking\" => {\n-                                let (lval, block) = destination.expect(\"std::rt::panicking does not diverge\");\n-                                // we abort on panic -> `std::rt::panicking` always returns false\n-                                let bool = self.tcx.types.bool;\n-                                self.write_primval(lval, PrimVal::from_bool(false), bool)?;\n-                                self.goto_block(block);\n-                                return Ok(());\n-                            }\n-                            _ => {},\n-                        }\n-                        return Err(EvalError::NoMirFor(path));\n-                    },\n-                    Err(other) => return Err(other),\n-                };\n-                let (return_lvalue, return_to_block) = match destination {\n-                    Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n-                    None => {\n-                        // FIXME(solson)\n-                        let lvalue = Lvalue::from_ptr(Pointer::never_ptr());\n-                        (lvalue, StackPopCleanup::None)\n-                    }\n-                };\n-\n-                self.push_stack_frame(\n+                self.eval_fn_call_inner(\n                     resolved_def_id,\n-                    span,\n-                    mir,\n                     resolved_substs,\n-                    return_lvalue,\n-                    return_to_block,\n+                    destination,\n+                    args,\n                     temporaries,\n-                )?;\n-\n-                let arg_locals = self.frame().mir.args_iter();\n-                assert_eq!(self.frame().mir.arg_count, args.len());\n-                for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n-                    let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                    self.write_value(arg_val, dest, arg_ty)?;\n+                    span,\n+                )\n+            },\n+            Function::NonCaptureClosureAsFnPtr(FunctionDefinition { def_id, abi: Abi::Rust, substs, sig }) => {\n+                let mut args = Vec::new();\n+                for arg in arg_operands {\n+                    let arg_val = self.eval_operand(arg)?;\n+                    let arg_ty = self.operand_ty(arg);\n+                    args.push((arg_val, arg_ty));\n                 }\n+                args.insert(0, (\n+                    Value::ByVal(PrimVal::Undef),\n+                    sig.inputs()[0],\n+                ));\n+                self.eval_fn_call_inner(\n+                    def_id,\n+                    substs,\n+                    destination,\n+                    args,\n+                    Vec::new(),\n+                    span,\n+                )\n+            }\n+            other => Err(EvalError::Unimplemented(format!(\"can't call function kind {:?}\", other))),\n+        }\n+    }\n \n-                Ok(())\n+    fn eval_fn_call_inner(\n+        &mut self,\n+        resolved_def_id: DefId,\n+        resolved_substs: &'tcx Substs,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        args: Vec<(Value, Ty<'tcx>)>,\n+        temporaries: Vec<(Pointer, Ty<'tcx>)>,\n+        span: Span,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"eval_fn_call_inner: {:#?}, {:#?}, {:#?}\", args, temporaries, destination);\n+\n+        let mir = match self.load_mir(resolved_def_id) {\n+            Ok(mir) => mir,\n+            Err(EvalError::NoMirFor(path)) => {\n+                match &path[..] {\n+                    // let's just ignore all output for now\n+                    \"std::io::_print\" => {\n+                        self.goto_block(destination.unwrap().1);\n+                        return Ok(());\n+                    },\n+                    \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n+                    \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n+                    \"std::panicking::rust_panic_with_hook\" |\n+                    \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n+                    \"std::panicking::panicking\" |\n+                    \"std::rt::panicking\" => {\n+                        let (lval, block) = destination.expect(\"std::rt::panicking does not diverge\");\n+                        // we abort on panic -> `std::rt::panicking` always returns false\n+                        let bool = self.tcx.types.bool;\n+                        self.write_primval(lval, PrimVal::from_bool(false), bool)?;\n+                        self.goto_block(block);\n+                        return Ok(());\n+                    }\n+                    _ => {},\n+                }\n+                return Err(EvalError::NoMirFor(path));\n+            },\n+            Err(other) => return Err(other),\n+        };\n+        let (return_lvalue, return_to_block) = match destination {\n+            Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n+            None => {\n+                // FIXME(solson)\n+                let lvalue = Lvalue::from_ptr(Pointer::never_ptr());\n+                (lvalue, StackPopCleanup::None)\n             }\n+        };\n \n-            abi => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", abi))),\n+        self.push_stack_frame(\n+            resolved_def_id,\n+            span,\n+            mir,\n+            resolved_substs,\n+            return_lvalue,\n+            return_to_block,\n+            temporaries,\n+        )?;\n+\n+        let arg_locals = self.frame().mir.args_iter();\n+        assert_eq!(self.frame().mir.arg_count, args.len());\n+        for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n+            let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+            self.write_value(arg_val, dest, arg_ty)?;\n         }\n+\n+        Ok(())\n     }\n \n     pub fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {"}, {"sha": "36293dde5322f6452c0bf3a3f98460572fa5b8de", "filename": "src/traits.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8878a4030acf5285a48e7e248e5f96e4d01060ec/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8878a4030acf5285a48e7e248e5f96e4d01060ec/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=8878a4030acf5285a48e7e248e5f96e4d01060ec", "patch": "@@ -130,6 +130,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         );\n                         Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n                     },\n+                    Function::NonCaptureClosureAsFnPtr(fn_def) => {\n+                        args.insert(0, (\n+                            Value::ByVal(PrimVal::Undef),\n+                            fn_def.sig.inputs()[0],\n+                        ));\n+                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n+                    }\n                     Function::Closure(fn_def) => {\n                         self.unpack_fn_args(args)?;\n                         Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n@@ -140,8 +147,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         args.remove(0);\n                         self.unpack_fn_args(args)?;\n                         let fn_ptr = self.memory.read_ptr(self_ptr)?;\n-                        let fn_def = self.memory.get_fn(fn_ptr.alloc_id)?.expect_concrete()?;\n-                        assert_eq!(sig, fn_def.sig);\n+                        let fn_def = match self.memory.get_fn(fn_ptr.alloc_id)? {\n+                            Function::Concrete(fn_def) => {\n+                                assert_eq!(sig, fn_def.sig);\n+                                fn_def\n+                            },\n+                            Function::NonCaptureClosureAsFnPtr(fn_def) => {\n+                                args.insert(0, (\n+                                    Value::ByVal(PrimVal::Undef),\n+                                    fn_def.sig.inputs()[0],\n+                                ));\n+                                fn_def\n+                            },\n+                            other => bug!(\"FnPtrAsTraitObject for {:?}\", other),\n+                        };\n                         Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n                     }\n                 }"}, {"sha": "6f73a3d09dda7aa5b835a04f33c32c7db43faa97", "filename": "tests/run-pass/non_capture_closure_to_fn_ptr.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8878a4030acf5285a48e7e248e5f96e4d01060ec/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8878a4030acf5285a48e7e248e5f96e4d01060ec/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs?ref=8878a4030acf5285a48e7e248e5f96e4d01060ec", "patch": "@@ -0,0 +1,16 @@\n+#![feature(closure_to_fn_coercion)]\n+\n+// allow(const_err) to work around a bug in warnings\n+#[allow(const_err)]\n+static FOO: fn() = || { assert_ne!(42, 43) };\n+#[allow(const_err)]\n+static BAR: fn(i32, i32) = |a, b| { assert_ne!(a, b) };\n+\n+fn main() {\n+    FOO();\n+    BAR(44, 45);\n+    let bar: unsafe fn(i32, i32) = BAR;\n+    unsafe { bar(46, 47) };\n+    let boo: &Fn(i32, i32) = &BAR;\n+    boo(48, 49);\n+}"}, {"sha": "77f2902917a1c21e22be8376ce8c82a2e5950332", "filename": "tests/run-pass/recursive_static.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8878a4030acf5285a48e7e248e5f96e4d01060ec/tests%2Frun-pass%2Frecursive_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8878a4030acf5285a48e7e248e5f96e4d01060ec/tests%2Frun-pass%2Frecursive_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frecursive_static.rs?ref=8878a4030acf5285a48e7e248e5f96e4d01060ec", "patch": "@@ -1,5 +1,3 @@\n-#![feature(static_recursion)]\n-\n struct S(&'static S);\n static S1: S = S(&S2);\n static S2: S = S(&S1);"}]}