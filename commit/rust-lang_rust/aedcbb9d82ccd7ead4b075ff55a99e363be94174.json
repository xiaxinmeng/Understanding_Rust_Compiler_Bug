{"sha": "aedcbb9d82ccd7ead4b075ff55a99e363be94174", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZGNiYjlkODJjY2Q3ZWFkNGIwNzVmZjU1YTk5ZTM2M2JlOTQxNzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-23T09:26:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-23T09:26:34Z"}, "message": "Auto merge of #21382 - tshepang:improve-iter-docs, r=alexcrichton", "tree": {"sha": "e698f1da723c4e44f11670f5067da7e74cdcd47a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e698f1da723c4e44f11670f5067da7e74cdcd47a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aedcbb9d82ccd7ead4b075ff55a99e363be94174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aedcbb9d82ccd7ead4b075ff55a99e363be94174", "html_url": "https://github.com/rust-lang/rust/commit/aedcbb9d82ccd7ead4b075ff55a99e363be94174", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aedcbb9d82ccd7ead4b075ff55a99e363be94174/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9285f9e816af4332eaf59a2a349c830d8f68602", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9285f9e816af4332eaf59a2a349c830d8f68602", "html_url": "https://github.com/rust-lang/rust/commit/e9285f9e816af4332eaf59a2a349c830d8f68602"}, {"sha": "9091e047e3b3e56fee78d1ae2ba7284ee894fd37", "url": "https://api.github.com/repos/rust-lang/rust/commits/9091e047e3b3e56fee78d1ae2ba7284ee894fd37", "html_url": "https://github.com/rust-lang/rust/commit/9091e047e3b3e56fee78d1ae2ba7284ee894fd37"}], "stats": {"total": 499, "additions": 263, "deletions": 236}, "files": [{"sha": "fc3a8ae6590dea5a31c2751075533f174c922928", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 263, "deletions": 236, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/aedcbb9d82ccd7ead4b075ff55a99e363be94174/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aedcbb9d82ccd7ead4b075ff55a99e363be94174/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=aedcbb9d82ccd7ead4b075ff55a99e363be94174", "patch": "@@ -32,7 +32,7 @@\n //! into a `loop`, for example, the `for` loop in this example is essentially\n //! translated to the `loop` below.\n //!\n-//! ```rust\n+//! ```\n //! let values = vec![1i, 2, 3];\n //!\n //! // \"Syntactical sugar\" taking advantage of an iterator\n@@ -68,7 +68,7 @@ use ops::{Add, Deref, FnMut};\n use option::Option;\n use option::Option::{Some, None};\n use std::marker::Sized;\n-use uint;\n+use usize;\n \n /// An interface for dealing with \"external iterators\". These types of iterators\n /// can be resumed at any time as all state is stored internally as opposed to\n@@ -93,10 +93,10 @@ pub trait Iterator {\n     /// Returns a lower and upper bound on the remaining length of the iterator.\n     ///\n     /// An upper bound of `None` means either there is no known upper bound, or the upper bound\n-    /// does not fit within a `uint`.\n+    /// does not fit within a `usize`.\n     #[inline]\n     #[stable]\n-    fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n+    fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }\n }\n \n // FIXME(#21363) remove `old_impl_check` when bug is fixed\n@@ -135,26 +135,25 @@ pub trait Extend<A> {\n pub trait IteratorExt: Iterator + Sized {\n     /// Counts the number of elements in this iterator.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n-    /// let mut it = a.iter();\n-    /// assert!(it.count() == 5);\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// assert_eq!(a.iter().count(), 5);\n     /// ```\n     #[inline]\n     #[stable]\n-    fn count(self) -> uint {\n+    fn count(self) -> usize {\n         self.fold(0, |cnt, _x| cnt + 1)\n     }\n \n     /// Loops through the entire iterator, returning the last element of the\n     /// iterator.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().last().unwrap() == &5);\n     /// ```\n     #[inline]\n@@ -168,17 +167,17 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Loops through `n` iterations, returning the `n`th element of the\n     /// iterator.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.nth(2).unwrap() == &3);\n     /// assert!(it.nth(2) == None);\n     /// ```\n     #[inline]\n     #[stable]\n-    fn nth(&mut self, mut n: uint) -> Option<Self::Item> {\n+    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n         for x in *self {\n             if n == 0 { return Some(x) }\n             n -= 1;\n@@ -190,11 +189,11 @@ pub trait IteratorExt: Iterator + Sized {\n     /// finish iterating over the current iterator, and then iterate\n     /// over the other specified iterator.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [0i];\n-    /// let b = [1i];\n+    /// ```\n+    /// let a = [0];\n+    /// let b = [1];\n     /// let mut it = a.iter().chain(b.iter());\n     /// assert_eq!(it.next().unwrap(), &0);\n     /// assert_eq!(it.next().unwrap(), &1);\n@@ -213,14 +212,13 @@ pub trait IteratorExt: Iterator + Sized {\n     /// either iterator returns None, all further invocations of next() will\n     /// return None.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [0i];\n-    /// let b = [1i];\n+    /// ```\n+    /// let a = [0];\n+    /// let b = [1];\n     /// let mut it = a.iter().zip(b.iter());\n-    /// let (x0, x1) = (0i, 1i);\n-    /// assert_eq!(it.next().unwrap(), (&x0, &x1));\n+    /// assert_eq!(it.next().unwrap(), (&0, &1));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -234,10 +232,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Creates a new iterator that will apply the specified function to each\n     /// element returned by the first, yielding the mapped element instead.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2];\n+    /// ```\n+    /// let a = [1, 2];\n     /// let mut it = a.iter().map(|&x| 2 * x);\n     /// assert_eq!(it.next().unwrap(), 2);\n     /// assert_eq!(it.next().unwrap(), 4);\n@@ -252,13 +250,13 @@ pub trait IteratorExt: Iterator + Sized {\n     }\n \n     /// Creates an iterator that applies the predicate to each element returned\n-    /// by this iterator. Only elements that have the predicate evaluate to\n-    /// `true` will be yielded.\n+    /// by this iterator. The only elements that will be yieled are those that\n+    /// make the predicate evaluate to `true`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2];\n+    /// ```\n+    /// let a = [1, 2];\n     /// let mut it = a.iter().filter(|&x| *x > 1);\n     /// assert_eq!(it.next().unwrap(), &2);\n     /// assert!(it.next().is_none());\n@@ -275,10 +273,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// If the specified function returns None, the element is skipped.\n     /// Otherwise the option is unwrapped and the new value is yielded.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2];\n+    /// ```\n+    /// let a = [1, 2];\n     /// let mut it = a.iter().filter_map(|&x| if x > 1 {Some(2 * x)} else {None});\n     /// assert_eq!(it.next().unwrap(), 4);\n     /// assert!(it.next().is_none());\n@@ -294,14 +292,13 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Creates an iterator that yields a pair of the value returned by this\n     /// iterator plus the current index of iteration.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [100i, 200];\n+    /// ```\n+    /// let a = [100, 200];\n     /// let mut it = a.iter().enumerate();\n-    /// let (x100, x200) = (100i, 200i);\n-    /// assert_eq!(it.next().unwrap(), (0, &x100));\n-    /// assert_eq!(it.next().unwrap(), (1, &x200));\n+    /// assert_eq!(it.next().unwrap(), (0, &100));\n+    /// assert_eq!(it.next().unwrap(), (1, &200));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -313,10 +310,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Creates an iterator that has a `.peek()` method\n     /// that returns an optional reference to the next element.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let xs = [100i, 200, 300];\n+    /// ```\n+    /// let xs = [100, 200, 300];\n     /// let mut it = xs.iter().map(|x| *x).peekable();\n     /// assert_eq!(*it.peek().unwrap(), 100);\n     /// assert_eq!(it.next().unwrap(), 100);\n@@ -337,14 +334,14 @@ pub trait IteratorExt: Iterator + Sized {\n     /// until it returns false. Once the predicate returns false, that\n     /// element and all further elements are yielded.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 2, 1];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().skip_while(|&a| *a < 3);\n     /// assert_eq!(it.next().unwrap(), &3);\n-    /// assert_eq!(it.next().unwrap(), &2);\n-    /// assert_eq!(it.next().unwrap(), &1);\n+    /// assert_eq!(it.next().unwrap(), &4);\n+    /// assert_eq!(it.next().unwrap(), &5);\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -359,10 +356,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// returns true. After the predicate returns false for the first time, no\n     /// further elements will be yielded.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 2, 1];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().take_while(|&a| *a < 3);\n     /// assert_eq!(it.next().unwrap(), &1);\n     /// assert_eq!(it.next().unwrap(), &2);\n@@ -379,28 +376,28 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Creates an iterator that skips the first `n` elements of this iterator,\n     /// and then yields all further items.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().skip(3);\n     /// assert_eq!(it.next().unwrap(), &4);\n     /// assert_eq!(it.next().unwrap(), &5);\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n     #[stable]\n-    fn skip(self, n: uint) -> Skip<Self> {\n+    fn skip(self, n: usize) -> Skip<Self> {\n         Skip{iter: self, n: n}\n     }\n \n     /// Creates an iterator that yields the first `n` elements of this\n-    /// iterator, and then will always return None.\n+    /// iterator.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().take(3);\n     /// assert_eq!(it.next().unwrap(), &1);\n     /// assert_eq!(it.next().unwrap(), &2);\n@@ -409,7 +406,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn take(self, n: uint) -> Take<Self> {\n+    fn take(self, n: usize) -> Take<Self> {\n         Take{iter: self, n: n}\n     }\n \n@@ -418,10 +415,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// mutated as necessary. The yielded values from the closure are yielded\n     /// from the Scan instance when not None.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().scan(1, |fac, &x| {\n     ///   *fac = *fac * x;\n     ///   Some(*fac)\n@@ -446,21 +443,17 @@ pub trait IteratorExt: Iterator + Sized {\n     }\n \n     /// Creates an iterator that maps each element to an iterator,\n-    /// and yields the elements of the produced iterators\n+    /// and yields the elements of the produced iterators.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// use std::iter::count;\n-    ///\n-    /// let xs = [2u, 3];\n-    /// let ys = [0u, 1, 0, 1, 2];\n-    /// let mut it = xs.iter().flat_map(|&x| count(0u, 1).take(x));\n+    /// ```\n+    /// let xs = [2, 3];\n+    /// let ys = [0, 1, 0, 1, 2];\n+    /// let it = xs.iter().flat_map(|&x| std::iter::count(0, 1).take(x));\n     /// // Check that `it` has the same elements as `ys`\n-    /// let mut i = 0;\n-    /// for x in it {\n+    /// for (i, x) in it.enumerate() {\n     ///     assert_eq!(x, ys[i]);\n-    ///     i += 1;\n     /// }\n     /// ```\n     #[inline]\n@@ -476,10 +469,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// iterator yields `None`. Random-access iterator behavior is not\n     /// affected, only single and double-ended iterator behavior.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// fn process<U: Iterator<Item=int>>(it: U) -> int {\n+    /// ```\n+    /// fn process<U: Iterator<Item=isize>>(it: U) -> isize {\n     ///     let mut it = it.fuse();\n     ///     let mut sum = 0;\n     ///     for x in it {\n@@ -494,9 +487,9 @@ pub trait IteratorExt: Iterator + Sized {\n     ///     }\n     ///     sum\n     /// }\n-    /// let x = vec![1i,2,3,7,8,9];\n+    /// let x = vec![1, 2, 3, 7, 8, 9];\n     /// assert_eq!(process(x.into_iter()), 6);\n-    /// let x = vec![1i,2,3];\n+    /// let x = vec![1, 2, 3];\n     /// assert_eq!(process(x.into_iter()), 1006);\n     /// ```\n     #[inline]\n@@ -509,13 +502,13 @@ pub trait IteratorExt: Iterator + Sized {\n     /// element before yielding it. This is often useful for debugging an\n     /// iterator pipeline.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::iter::AdditiveIterator;\n     ///\n-    /// let xs = [1u, 4, 2, 3, 8, 9, 6];\n-    /// let sum = xs.iter()\n+    /// let a = [1, 4, 2, 3, 8, 9, 6];\n+    /// let sum = a.iter()\n     ///             .map(|&x| x)\n     ///             .inspect(|&x| println!(\"filtering {}\", x))\n     ///             .filter(|&x| x % 2 == 0)\n@@ -536,15 +529,14 @@ pub trait IteratorExt: Iterator + Sized {\n     /// This is useful to allow applying iterator adaptors while still\n     /// retaining ownership of the original iterator value.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let mut xs = range(0u, 10);\n+    /// ```\n+    /// let mut it = 0..10;\n     /// // sum the first five values\n-    /// let partial_sum = xs.by_ref().take(5).fold(0, |a, b| a + b);\n+    /// let partial_sum = it.by_ref().take(5).fold(0, |a, b| a + b);\n     /// assert!(partial_sum == 10);\n-    /// // xs.next() is now `5`\n-    /// assert!(xs.next() == Some(5));\n+    /// assert!(it.next() == Some(5));\n     /// ```\n     #[stable]\n     fn by_ref<'r>(&'r mut self) -> ByRef<'r, Self> {\n@@ -554,12 +546,12 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Loops through the entire iterator, collecting all of the elements into\n     /// a container implementing `FromIterator`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n-    /// let b: Vec<int> = a.iter().map(|&x| x).collect();\n-    /// assert!(a.as_slice() == b.as_slice());\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let b: Vec<_> = a.iter().map(|&x| x).collect();\n+    /// assert_eq!(a, b);\n     /// ```\n     #[inline]\n     #[stable]\n@@ -573,8 +565,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// do not.\n     ///\n     /// ```\n-    /// let vec = vec![1i, 2i, 3i, 4i];\n-    /// let (even, odd): (Vec<int>, Vec<int>) = vec.into_iter().partition(|&n| n % 2 == 0);\n+    /// let vec = vec![1, 2, 3, 4];\n+    /// let (even, odd): (Vec<_>, Vec<_>) = vec.into_iter().partition(|&n| n % 2 == 0);\n     /// assert_eq!(even, vec![2, 4]);\n     /// assert_eq!(odd, vec![1, 3]);\n     /// ```\n@@ -600,10 +592,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Performs a fold operation over the entire iterator, returning the\n     /// eventual state at the end of the iteration.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ```\n     #[inline]\n@@ -620,9 +612,9 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Tests whether the predicate holds true for all elements in the iterator.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let a = [1i, 2, 3, 4, 5];\n     /// assert!(a.iter().all(|x| *x > 0));\n     /// assert!(!a.iter().all(|x| *x > 2));\n@@ -634,16 +626,18 @@ pub trait IteratorExt: Iterator + Sized {\n         true\n     }\n \n-    /// Tests whether any element of an iterator satisfies the specified\n-    /// predicate.\n+    /// Tests whether any element of an iterator satisfies the specified predicate.\n     ///\n-    /// # Example\n+    /// Does not consume the iterator past the first found element.\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.any(|x| *x == 3));\n-    /// assert!(!it.any(|x| *x == 3));\n+    /// assert_eq!(it.as_slice(), [4, 5]);\n+    ///\n     /// ```\n     #[inline]\n     #[stable]\n@@ -655,6 +649,14 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Returns the first element satisfying the specified predicate.\n     ///\n     /// Does not consume the iterator past the first found element.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert_eq!(it.find(|&x| *x == 3).unwrap(), &3);\n+    /// assert_eq!(it.as_slice(), [4, 5]);\n     #[inline]\n     #[stable]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n@@ -667,9 +669,19 @@ pub trait IteratorExt: Iterator + Sized {\n     }\n \n     /// Return the index of the first element satisfying the specified predicate\n+    ///\n+    /// Does not consume the iterator past the first found element.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert_eq!(it.position(|x| *x == 3).unwrap(), 2);\n+    /// assert_eq!(it.as_slice(), [4, 5]);\n     #[inline]\n     #[stable]\n-    fn position<P>(&mut self, mut predicate: P) -> Option<uint> where\n+    fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n         P: FnMut(Self::Item) -> bool,\n     {\n         let mut i = 0;\n@@ -685,9 +697,19 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Return the index of the last element satisfying the specified predicate\n     ///\n     /// If no element matches, None is returned.\n+    ///\n+    /// Does not consume the iterator *before* the first found element.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 2, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert_eq!(it.rposition(|x| *x == 2).unwrap(), 2);\n+    /// assert_eq!(it.as_slice(), [1, 2]);\n     #[inline]\n     #[stable]\n-    fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where\n+    fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n         P: FnMut(Self::Item) -> bool,\n         Self: ExactSizeIterator + DoubleEndedIterator\n     {\n@@ -702,10 +724,10 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Consumes the entire iterator to return the maximum element.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().max().unwrap() == &5);\n     /// ```\n     #[inline]\n@@ -722,10 +744,10 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Consumes the entire iterator to return the minimum element.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().min().unwrap() == &1);\n     /// ```\n     #[inline]\n@@ -753,25 +775,22 @@ pub trait IteratorExt: Iterator + Sized {\n     /// On an iterator of length `n`, `min_max` does `1.5 * n` comparisons,\n     /// and so is faster than calling `min` and `max` separately which does `2 * n` comparisons.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::iter::MinMaxResult::{NoElements, OneElement, MinMax};\n     ///\n-    /// let v: [int; 0] = [];\n-    /// assert_eq!(v.iter().min_max(), NoElements);\n-    ///\n-    /// let v = [1i];\n-    /// assert!(v.iter().min_max() == OneElement(&1));\n+    /// let a: [isize; 0] = [];\n+    /// assert_eq!(a.iter().min_max(), NoElements);\n     ///\n-    /// let v = [1i, 2, 3, 4, 5];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &5));\n+    /// let a = [1];\n+    /// assert!(a.iter().min_max() == OneElement(&1));\n     ///\n-    /// let v = [1i, 2, 3, 4, 5, 6];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &6));\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// assert!(a.iter().min_max() == MinMax(&1, &5));\n     ///\n-    /// let v = [1i, 1, 1, 1];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &1));\n+    /// let a = [1, 1, 1, 1];\n+    /// assert!(a.iter().min_max() == MinMax(&1, &1));\n     /// ```\n     #[unstable = \"return type may change\"]\n     fn min_max(mut self) -> MinMaxResult<Self::Item> where Self::Item: Ord\n@@ -821,13 +840,13 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Return the element that gives the maximum value from the\n     /// specified function.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use core::num::SignedInt;\n     ///\n-    /// let xs = [-3i, 0, 1, 5, -10];\n-    /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n+    /// let a = [-3, 0, 1, 5, -10];\n+    /// assert_eq!(*a.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n     #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n@@ -850,13 +869,13 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Return the element that gives the minimum value from the\n     /// specified function.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use core::num::SignedInt;\n     ///\n-    /// let xs = [-3i, 0, 1, 5, -10];\n-    /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n+    /// let a = [-3, 0, 1, 5, -10];\n+    /// assert_eq!(*a.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n     #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n@@ -887,7 +906,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// of the original iterator.\n     ///\n     /// Note: Random access with flipped indices still only applies to the first\n-    /// `uint::MAX` elements of the original iterator.\n+    /// `std::usize::MAX` elements of the original iterator.\n     #[inline]\n     #[stable]\n     fn rev(self) -> Rev<Self> {\n@@ -898,18 +917,27 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// Loops through the entire iterator, collecting the first component of\n     /// each item into one new container, and the second component into another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [(1, 2), (3, 4)];\n+    /// let (left, right): (Vec<_>, Vec<_>) = a.iter().map(|&x| x).unzip();\n+    /// assert_eq!([1, 3], left);\n+    /// assert_eq!([2, 4], right);\n+    /// ```\n     #[unstable = \"recent addition\"]\n     fn unzip<A, B, FromA, FromB>(mut self) -> (FromA, FromB) where\n         FromA: Default + Extend<A>,\n         FromB: Default + Extend<B>,\n         Self: Iterator<Item=(A, B)>,\n     {\n-        struct SizeHint<A>(uint, Option<uint>);\n+        struct SizeHint<A>(usize, Option<usize>);\n         impl<A> Iterator for SizeHint<A> {\n             type Item = A;\n \n             fn next(&mut self) -> Option<A> { None }\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 (self.0, self.1)\n             }\n         }\n@@ -942,15 +970,14 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Repeats an iterator endlessly\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// use std::iter::count;\n-    ///\n-    /// let a = count(1i,1i).take(1);\n-    /// let mut cy = a.cycle();\n-    /// assert_eq!(cy.next(), Some(1));\n-    /// assert_eq!(cy.next(), Some(1));\n+    /// ```\n+    /// let a = [1, 2];\n+    /// let mut it = a.iter().cycle();\n+    /// assert_eq!(it.next().unwrap(), &1);\n+    /// assert_eq!(it.next().unwrap(), &2);\n+    /// assert_eq!(it.next().unwrap(), &1);\n     /// ```\n     #[stable]\n     #[inline]\n@@ -986,20 +1013,20 @@ pub trait DoubleEndedIterator: Iterator {\n     fn next_back(&mut self) -> Option<Self::Item>;\n }\n \n-/// An object implementing random access indexing by `uint`\n+/// An object implementing random access indexing by `usize`\n ///\n /// A `RandomAccessIterator` should be either infinite or a `DoubleEndedIterator`.\n /// Calling `next()` or `next_back()` on a `RandomAccessIterator`\n /// reduces the indexable range accordingly. That is, `it.idx(1)` will become `it.idx(0)`\n /// after `it.next()` is called.\n #[unstable = \"not widely used, may be better decomposed into Index and ExactSizeIterator\"]\n pub trait RandomAccessIterator: Iterator {\n-    /// Return the number of indexable elements. At most `std::uint::MAX`\n+    /// Return the number of indexable elements. At most `std::usize::MAX`\n     /// elements are indexable, even if the iterator represents a longer range.\n-    fn indexable(&self) -> uint;\n+    fn indexable(&self) -> usize;\n \n     /// Return an element at an index, or `None` if the index is out of bounds\n-    fn idx(&mut self, index: uint) -> Option<Self::Item>;\n+    fn idx(&mut self, index: usize) -> Option<Self::Item>;\n }\n \n /// An iterator that knows its exact length\n@@ -1008,12 +1035,12 @@ pub trait RandomAccessIterator: Iterator {\n /// it can support double-ended enumeration.\n ///\n /// `Iterator::size_hint` *must* return the exact size of the iterator.\n-/// Note that the size must fit in `uint`.\n+/// Note that the size must fit in `usize`.\n #[stable]\n pub trait ExactSizeIterator: Iterator {\n     #[inline]\n     /// Return the exact length of the iterator.\n-    fn len(&self) -> uint {\n+    fn len(&self) -> usize {\n         let (lower, upper) = self.size_hint();\n         // Note: This assertion is overly defensive, but it checks the invariant\n         // guaranteed by the trait. If this trait were rust-internal,\n@@ -1058,7 +1085,7 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n #[stable]\n@@ -1070,9 +1097,9 @@ impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n #[unstable = \"trait is experimental\"]\n impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAccessIterator {\n     #[inline]\n-    fn indexable(&self) -> uint { self.iter.indexable() }\n+    fn indexable(&self) -> usize { self.iter.indexable() }\n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n+    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n         let amt = self.indexable();\n         self.iter.idx(amt - index - 1)\n     }\n@@ -1092,7 +1119,7 @@ impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     #[inline]\n     fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n #[stable]\n@@ -1106,9 +1133,9 @@ impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterat\n pub trait AdditiveIterator<A> {\n     /// Iterates over the entire iterator, summing up all the elements\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::iter::AdditiveIterator;\n     ///\n     /// let a = [1i, 2, 3, 4, 5];\n@@ -1133,12 +1160,12 @@ impl_additive! { i8,   0 }\n impl_additive! { i16,  0 }\n impl_additive! { i32,  0 }\n impl_additive! { i64,  0 }\n-impl_additive! { int,  0 }\n+impl_additive! { isize,  0 }\n impl_additive! { u8,   0 }\n impl_additive! { u16,  0 }\n impl_additive! { u32,  0 }\n impl_additive! { u64,  0 }\n-impl_additive! { uint, 0 }\n+impl_additive! { usize, 0 }\n impl_additive! { f32,  0.0 }\n impl_additive! { f64,  0.0 }\n \n@@ -1147,12 +1174,12 @@ impl_additive! { f64,  0.0 }\n pub trait MultiplicativeIterator<A> {\n     /// Iterates over the entire iterator, multiplying all the elements\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::iter::{count, MultiplicativeIterator};\n     ///\n-    /// fn factorial(n: uint) -> uint {\n+    /// fn factorial(n: usize) -> usize {\n     ///     count(1u, 1).take_while(|&i| i <= n).product()\n     /// }\n     /// assert!(factorial(0) == 1);\n@@ -1177,12 +1204,12 @@ impl_multiplicative! { i8,   1 }\n impl_multiplicative! { i16,  1 }\n impl_multiplicative! { i32,  1 }\n impl_multiplicative! { i64,  1 }\n-impl_multiplicative! { int,  1 }\n+impl_multiplicative! { isize,  1 }\n impl_multiplicative! { u8,   1 }\n impl_multiplicative! { u16,  1 }\n impl_multiplicative! { u32,  1 }\n impl_multiplicative! { u64,  1 }\n-impl_multiplicative! { uint, 1 }\n+impl_multiplicative! { usize, 1 }\n impl_multiplicative! { f32,  1.0 }\n impl_multiplicative! { f64,  1.0 }\n \n@@ -1206,19 +1233,19 @@ impl<T: Clone> MinMaxResult<T> {\n     /// `Some(x,y)` is returned where `x <= y`. If `MinMaxResult` has variant `OneElement(x)`,\n     /// performing this operation will make one clone of `x`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::iter::MinMaxResult::{self, NoElements, OneElement, MinMax};\n     ///\n-    /// let r: MinMaxResult<int> = NoElements;\n+    /// let r: MinMaxResult<isize> = NoElements;\n     /// assert_eq!(r.into_option(), None);\n     ///\n-    /// let r = OneElement(1i);\n-    /// assert_eq!(r.into_option(), Some((1,1)));\n+    /// let r = OneElement(1);\n+    /// assert_eq!(r.into_option(), Some((1, 1)));\n     ///\n-    /// let r = MinMax(1i,2i);\n-    /// assert_eq!(r.into_option(), Some((1,2)));\n+    /// let r = MinMax(1, 2);\n+    /// assert_eq!(r.into_option(), Some((1, 2)));\n     /// ```\n     #[unstable = \"type is unstable\"]\n     pub fn into_option(self) -> Option<(T,T)> {\n@@ -1250,7 +1277,7 @@ impl<T, D, I> Iterator for Cloned<I> where\n         self.it.next().cloned()\n     }\n \n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.it.size_hint()\n     }\n }\n@@ -1295,12 +1322,12 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         // the cycle iterator is either empty or infinite\n         match self.orig.size_hint() {\n             sz @ (0, Some(0)) => sz,\n             (0, _) => (0, None),\n-            _ => (uint::MAX, None)\n+            _ => (usize::MAX, None)\n         }\n     }\n }\n@@ -1310,16 +1337,16 @@ impl<I> RandomAccessIterator for Cycle<I> where\n     I: Clone + RandomAccessIterator,\n {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         if self.orig.indexable() > 0 {\n-            uint::MAX\n+            usize::MAX\n         } else {\n             0\n         }\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n+    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n         let liter = self.iter.indexable();\n         let lorig = self.orig.indexable();\n         if lorig == 0 {\n@@ -1361,7 +1388,7 @@ impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<It\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (a_lower, a_upper) = self.a.size_hint();\n         let (b_lower, b_upper) = self.b.size_hint();\n \n@@ -1396,13 +1423,13 @@ impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n     B: RandomAccessIterator<Item=T>,\n {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         let (a, b) = (self.a.indexable(), self.b.indexable());\n         a.saturating_add(b)\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<T> {\n+    fn idx(&mut self, index: usize) -> Option<T> {\n         let len = self.a.indexable();\n         if index < len {\n             self.a.idx(index)\n@@ -1440,7 +1467,7 @@ impl<T, U, A, B> Iterator for Zip<A, B> where\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (a_lower, a_upper) = self.a.size_hint();\n         let (b_lower, b_upper) = self.b.size_hint();\n \n@@ -1488,12 +1515,12 @@ impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n     B: RandomAccessIterator<Item=U>,\n {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         cmp::min(self.a.indexable(), self.b.indexable())\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<(T, U)> {\n+    fn idx(&mut self, index: usize) -> Option<(T, U)> {\n         match self.a.idx(index) {\n             None => None,\n             Some(x) => match self.b.idx(index) {\n@@ -1547,7 +1574,7 @@ impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMu\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n }\n@@ -1570,12 +1597,12 @@ impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n     F: FnMut(A) -> B,\n {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.iter.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<B> {\n+    fn idx(&mut self, index: usize) -> Option<B> {\n         let elt = self.iter.idx(index);\n         self.do_map(elt)\n     }\n@@ -1620,7 +1647,7 @@ impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n@@ -1683,7 +1710,7 @@ impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n@@ -1712,15 +1739,15 @@ impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n #[stable]\n pub struct Enumerate<I> {\n     iter: I,\n-    count: uint\n+    count: usize\n }\n \n #[stable]\n impl<I> Iterator for Enumerate<I> where I: Iterator {\n-    type Item = (uint, <I as Iterator>::Item);\n+    type Item = (usize, <I as Iterator>::Item);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, <I as Iterator>::Item)> {\n+    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n         match self.iter.next() {\n             Some(a) => {\n                 let ret = Some((self.count, a));\n@@ -1732,7 +1759,7 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n }\n@@ -1742,7 +1769,7 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n     I: ExactSizeIterator + DoubleEndedIterator\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(uint, <I as Iterator>::Item)> {\n+    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n         match self.iter.next_back() {\n             Some(a) => {\n                 let len = self.iter.len();\n@@ -1756,12 +1783,12 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n #[unstable = \"trait is experimental\"]\n impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.iter.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<(uint, <I as Iterator>::Item)> {\n+    fn idx(&mut self, index: usize) -> Option<(usize, <I as Iterator>::Item)> {\n         match self.iter.idx(index) {\n             Some(a) => Some((self.count + index, a)),\n             _ => None,\n@@ -1789,7 +1816,7 @@ impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lo, hi) = self.iter.size_hint();\n         if self.peeked.is_some() {\n             let lo = lo.saturating_add(1);\n@@ -1866,7 +1893,7 @@ impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n@@ -1920,7 +1947,7 @@ impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n@@ -1932,7 +1959,7 @@ impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n #[stable]\n pub struct Skip<I> {\n     iter: I,\n-    n: uint\n+    n: usize\n }\n \n #[stable]\n@@ -1965,7 +1992,7 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lower, upper) = self.iter.size_hint();\n \n         let lower = lower.saturating_sub(self.n);\n@@ -1982,12 +2009,12 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n #[unstable = \"trait is experimental\"]\n impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.iter.indexable().saturating_sub(self.n)\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n+    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n         if index >= self.indexable() {\n             None\n         } else {\n@@ -2002,7 +2029,7 @@ impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n #[stable]\n pub struct Take<I> {\n     iter: I,\n-    n: uint\n+    n: usize\n }\n \n #[stable]\n@@ -2020,7 +2047,7 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lower, upper) = self.iter.size_hint();\n \n         let lower = cmp::min(lower, self.n);\n@@ -2037,12 +2064,12 @@ impl<I> Iterator for Take<I> where I: Iterator{\n #[unstable = \"trait is experimental\"]\n impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         cmp::min(self.iter.indexable(), self.n)\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n+    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n         if index >= self.n {\n             None\n         } else {\n@@ -2092,7 +2119,7 @@ impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the scan function\n     }\n@@ -2155,7 +2182,7 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n         let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n         let lo = flo.saturating_add(blo);\n@@ -2219,7 +2246,7 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.done {\n             (0, Some(0))\n         } else {\n@@ -2250,12 +2277,12 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n #[unstable = \"trait is experimental\"]\n impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.iter.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n+    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n         self.iter.idx(index)\n     }\n }\n@@ -2316,7 +2343,7 @@ impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n }\n@@ -2339,12 +2366,12 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n     F: FnMut(&A),\n {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.iter.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: usize) -> Option<A> {\n         let element = self.iter.idx(index);\n         self.do_inspect(element)\n     }\n@@ -2356,7 +2383,7 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n ///\n /// An iterator that yields sequential Fibonacci numbers, and stops on overflow.\n ///\n-/// ```rust\n+/// ```\n /// use std::iter::Unfold;\n /// use std::num::Int; // For `.checked_add()`\n ///\n@@ -2426,7 +2453,7 @@ impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         // no possible known bounds at this point\n         (0, None)\n     }\n@@ -2462,8 +2489,8 @@ impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (uint::MAX, None) // Too bad we can't specify an infinite lower bound\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None) // Too bad we can't specify an infinite lower bound\n     }\n }\n \n@@ -2479,9 +2506,9 @@ pub struct Range<A> {\n /// Returns an iterator over the given range [start, stop) (that is, starting\n /// at start (inclusive), and ending at stop (exclusive)).\n ///\n-/// # Example\n+/// # Examples\n ///\n-/// ```rust\n+/// ```\n /// let array = [0, 1, 2, 3, 4];\n ///\n /// for i in range(0, 5u) {\n@@ -2516,9 +2543,9 @@ impl<A: Int + ToPrimitive> Iterator for Range<A> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         // This first checks if the elements are representable as i64. If they aren't, try u64 (to\n-        // handle cases like range(huge, huger)). We don't use uint/int because the difference of\n+        // handle cases like range(huge, huger)). We don't use usize/isize because the difference of\n         // the i64/u64 might lie within their range.\n         let bound = match self.state.to_i64() {\n             Some(a) => {\n@@ -2601,7 +2628,7 @@ impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lo, hi) = self.range.size_hint();\n         if self.done {\n             (lo, hi)\n@@ -2733,9 +2760,9 @@ macro_rules! range_impl {\n             }\n \n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 debug_assert!(self.end >= self.start);\n-                let hint = (self.end - self.start) as uint;\n+                let hint = (self.end - self.start) as usize;\n                 (hint, Some(hint))\n             }\n         }\n@@ -2795,13 +2822,13 @@ macro_rules! range_other_impls {\n     )*)\n }\n \n-range_impl!(uint u8 u16 u32 int i8 i16 i32);\n+range_impl!(usize u8 u16 u32 isize i8 i16 i32);\n #[cfg(target_pointer_width = \"64\")]\n range_impl!(u64 i64);\n #[cfg(target_pointer_width = \"32\")]\n range_impl_no_hint!(u64 i64);\n \n-range_other_impls!(uint u8 u16 u32 u64 int i8 i16 i32 i64);\n+range_other_impls!(usize u8 u16 u32 u64 isize i8 i16 i32 i64);\n \n /// An iterator that repeats an element endlessly\n #[derive(Clone)]\n@@ -2817,7 +2844,7 @@ impl<A: Clone> Iterator for Repeat<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.idx(0) }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }\n+    fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n }\n \n #[stable]\n@@ -2829,9 +2856,9 @@ impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n #[unstable = \"trait is experimental\"]\n impl<A: Clone> RandomAccessIterator for Repeat<A> {\n     #[inline]\n-    fn indexable(&self) -> uint { uint::MAX }\n+    fn indexable(&self) -> usize { usize::MAX }\n     #[inline]\n-    fn idx(&mut self, _: uint) -> Option<A> { Some(self.element.clone()) }\n+    fn idx(&mut self, _: usize) -> Option<A> { Some(self.element.clone()) }\n }\n \n type IterateState<T, F> = (F, Option<T>, bool);"}]}