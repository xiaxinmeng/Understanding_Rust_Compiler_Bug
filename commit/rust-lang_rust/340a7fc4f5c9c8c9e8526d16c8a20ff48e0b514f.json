{"sha": "340a7fc4f5c9c8c9e8526d16c8a20ff48e0b514f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MGE3ZmM0ZjVjOWM4YzllODUyNmQxNmM4YTIwZmY0OGUwYjUxNGY=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-07-03T18:38:04Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T19:02:32Z"}, "message": "Refactor astconv.rs", "tree": {"sha": "a8fc698c3c6097bd1d8b3c87e1e8ceba9ba2496e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8fc698c3c6097bd1d8b3c87e1e8ceba9ba2496e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/340a7fc4f5c9c8c9e8526d16c8a20ff48e0b514f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/340a7fc4f5c9c8c9e8526d16c8a20ff48e0b514f", "html_url": "https://github.com/rust-lang/rust/commit/340a7fc4f5c9c8c9e8526d16c8a20ff48e0b514f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/340a7fc4f5c9c8c9e8526d16c8a20ff48e0b514f/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35ddd46a2d679b471b7c30bc4eb97de03396e838", "url": "https://api.github.com/repos/rust-lang/rust/commits/35ddd46a2d679b471b7c30bc4eb97de03396e838", "html_url": "https://github.com/rust-lang/rust/commit/35ddd46a2d679b471b7c30bc4eb97de03396e838"}], "stats": {"total": 80, "additions": 45, "deletions": 35}, "files": [{"sha": "18bd00d43d692bab606d922a1f26dd81ea31806f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/340a7fc4f5c9c8c9e8526d16c8a20ff48e0b514f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340a7fc4f5c9c8c9e8526d16c8a20ff48e0b514f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=340a7fc4f5c9c8c9e8526d16c8a20ff48e0b514f", "patch": "@@ -213,18 +213,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n-\n-        // FIXME(varkor): Separating out the parameters is messy.\n-        let lifetimes: Vec<_> = generic_args.args.iter().filter_map(|arg| match arg {\n-            GenericArg::Lifetime(lt) => Some(lt),\n-            _ => None,\n-        }).collect();\n-        let types: Vec<_> = generic_args.args.iter().filter_map(|arg| match arg {\n-            GenericArg::Type(ty) => Some(ty),\n-            _ => None,\n-        }).collect();\n-        let lt_provided = lifetimes.len();\n-        let ty_provided = types.len();\n+        let mut lt_provided = 0;\n+        let mut ty_provided = 0;\n+        for arg in &generic_args.args {\n+            match arg {\n+                GenericArg::Lifetime(_) => lt_provided += 1,\n+                GenericArg::Type(_) => ty_provided += 1,\n+            }\n+        }\n \n         let decl_generics = tcx.generics_of(def_id);\n         let mut lt_accepted = 0;\n@@ -274,30 +270,44 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             false\n         };\n \n-        let own_self = self_ty.is_some() as usize;\n+        let self_offset = self_ty.is_some() as usize;\n         let substs = Substs::for_item(tcx, def_id, |param, substs| {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => {\n-                    let i = param.index as usize - own_self;\n-                    if let Some(lt) = lifetimes.get(i) {\n-                        self.ast_region_to_region(lt, Some(param)).into()\n-                    } else {\n-                        tcx.types.re_static.into()\n+            if param.index == 0 {\n+                if let Some(ty) = self_ty {\n+                    if let GenericParamDefKind::Type { .. } = param.kind {\n+                        // Handle `Self` first.\n+                        return ty.into();\n                     }\n                 }\n-                GenericParamDefKind::Type { has_default, .. } => {\n-                    let i = param.index as usize;\n+            }\n \n-                    // Handle Self first, so we can adjust the index to match the AST.\n-                    if let (0, Some(ty)) = (i, self_ty) {\n-                        return ty.into();\n+            let inferred_lifetimes = if lt_provided == 0 {\n+                lt_accepted\n+            } else {\n+                0\n+            };\n+\n+            let param_idx = (param.index as usize - self_offset).saturating_sub(inferred_lifetimes);\n+\n+            if let Some(arg) = generic_args.args.get(param_idx) {\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => match arg {\n+                        GenericArg::Lifetime(lt) => {\n+                            return self.ast_region_to_region(lt, Some(param)).into();\n+                        }\n+                        _ => {}\n+                    }\n+                    GenericParamDefKind::Type { .. } => match arg {\n+                        GenericArg::Type(ty) => return self.ast_ty_to_ty(ty).into(),\n+                        _ => {}\n                     }\n+                }\n+            }\n \n-                    let i = i - (lt_accepted + own_self);\n-                    if i < ty_provided {\n-                        // A provided type parameter.\n-                        self.ast_ty_to_ty(&types[i]).into()\n-                    } else if infer_types {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => tcx.types.re_static.into(),\n+                GenericParamDefKind::Type { has_default, .. } => {\n+                    if infer_types {\n                         // No type parameters were provided, we can infer all.\n                         if !default_needs_object_self(param) {\n                             self.ty_infer_for_def(param, span).into()\n@@ -314,9 +324,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                         // careful!\n                         if default_needs_object_self(param) {\n                             struct_span_err!(tcx.sess, span, E0393,\n-                                             \"the type parameter `{}` must be explicitly \\\n-                                             specified\",\n-                                             param.name)\n+                                                \"the type parameter `{}` must be explicitly \\\n+                                                specified\",\n+                                                param.name)\n                                 .span_label(span,\n                                             format!(\"missing reference to `{}`\", param.name))\n                                 .note(&format!(\"because of the default `Self` reference, \\"}, {"sha": "66f5e57ef6d6edff256aeff1310326040e7716ae", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/340a7fc4f5c9c8c9e8526d16c8a20ff48e0b514f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340a7fc4f5c9c8c9e8526d16c8a20ff48e0b514f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=340a7fc4f5c9c8c9e8526d16c8a20ff48e0b514f", "patch": "@@ -4987,7 +4987,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Substs::fill_single(&mut substs, defs, &mut |param: &ty::GenericParamDef, substs| {\n                 if param.index == 0 && has_self {\n                     if let GenericParamDefKind::Type { .. } = param.kind {\n-                        // Handle Self first, so we can adjust the index to match the AST.\n+                        // Handle `Self` first, so we can adjust the index to match the AST.\n                         return opt_self_ty.map(|ty| ty.into()).unwrap_or_else(|| {\n                             self.var_for_def(span, param)\n                         });\n@@ -5004,7 +5004,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if let Some(ref data) = segments[index].args {\n                             let self_offset = (defs.parent_count == 0 && has_self) as usize;\n                             let param_idx =\n-                                (param.index as usize - defs.parent_count - self_offset as usize)\n+                                (param.index as usize - defs.parent_count - self_offset)\n                                 .saturating_sub(infer_lifetimes[&index]);\n                             if let Some(arg) = data.args.get(param_idx) {\n                                 match param.kind {"}]}