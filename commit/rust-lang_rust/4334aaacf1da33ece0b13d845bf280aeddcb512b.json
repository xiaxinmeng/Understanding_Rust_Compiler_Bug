{"sha": "4334aaacf1da33ece0b13d845bf280aeddcb512b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMzRhYWFjZjFkYTMzZWNlMGIxM2Q4NDViZjI4MGFlZGRjYjUxMmI=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-10-12T11:47:37Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-10-19T13:45:46Z"}, "message": "Only suggest paths that exist.\n\nIn order to output a path that could actually be imported (valid and\nvisible), we need to handle re-exports correctly.\n\nFor example, take `std::os::unix::process::CommandExt`, this trait is\nactually defined at `std::sys::unix::ext::process::CommandExt` (at time\nof writing).\n\n`std::os::unix` rexports the contents of `std::sys::unix::ext`.\n`std::sys` is private so the \"true\" path to `CommandExt` isn't accessible.\n\nIn this case, the visible parent map will look something like this:\n\n(child) -> (parent)\n`std::sys::unix::ext::process::CommandExt` -> `std::sys::unix::ext::process`\n`std::sys::unix::ext::process` -> `std::sys::unix::ext`\n`std::sys::unix::ext` -> `std::os`\n\nThis is correct, as the visible parent of `std::sys::unix::ext` is in fact\n`std::os`.\n\nWhen printing the path to `CommandExt` and looking at the current\nsegment that corresponds to `std::sys::unix::ext`, we would normally\nprint `ext` and then go to the parent - resulting in a mangled path like\n`std::os::ext::process::CommandExt`.\n\nInstead, we must detect that there was a re-export and instead print `unix`\n(which is the name `std::sys::unix::ext` was re-exported as in `std::os`).", "tree": {"sha": "5aea52e86426258c9e12d6562936e5f331c5c8bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5aea52e86426258c9e12d6562936e5f331c5c8bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4334aaacf1da33ece0b13d845bf280aeddcb512b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlvJ4AoACgkQAXYLT59T\n8VTUYQ//fwN/dShKvHiEmi9QkxOqwZOXjSnqRNGuHvmHKd5jZ0vqtIp+5ku9GfoF\n7/0e7qvCWeV1u7oVWqHhygFDX3sB+g5nfjq9qP1MaDR1UN/09NlUcANXSfkfWawo\nu5PdawhsPRjEgceGOQk8TuaCbvanPs617nn8icmcsy3X2WwJ8JbeU7UBCIFrK6LC\nC3UNmOpag/dLDe7V5xQj6htlW6b4YriSiJiQfx9rEYqwknScH6Yf01p5bdYb1CY3\n2EMSymzgYsFUkPlLjQU3NMh4abxbKuo5VoWUB+AzsH+tUPp4yMLbzROUVMP+rr+o\ngG2WYI04Skv33mmhZxR6uy3UVqvtRHFw/VdClvqW9P41FyR4xMPq5/k41puo+FLz\njXkGa0jEE+nOZ6czSaCNVk3cbmG3Np6hW3egkIhTmbofxmZFpgo1KxYWzKXDIdxu\nbRy+cTCJCX07HVg5V6bw5QB4iqHkLUEDAif/4yLWBq2rs9vWFX8s3ODU89GMm8dV\nKGfPmmFH03+DjLjpWoWdryKJ9IqAIx52ZxP1kFjabgDf8gNIsnuusyTLI8tFK+cL\nV19lIKdh2py+lKW8y3LjTJZgpW+DcQ0ayC7Bll4aJXHEFSAhZXyRgwzZN7BItTZu\n17HH9y44NtH02/lmfZTjO9moIBwyXFG7vjdLTfQ0PdLV3TGBP1U=\n=trc4\n-----END PGP SIGNATURE-----", "payload": "tree 5aea52e86426258c9e12d6562936e5f331c5c8bc\nparent b8b4150c042b06c46e29a9d12101f91fe13996e0\nauthor David Wood <david@davidtw.co> 1539344857 +0200\ncommitter David Wood <david@davidtw.co> 1539956746 +0200\n\nOnly suggest paths that exist.\n\nIn order to output a path that could actually be imported (valid and\nvisible), we need to handle re-exports correctly.\n\nFor example, take `std::os::unix::process::CommandExt`, this trait is\nactually defined at `std::sys::unix::ext::process::CommandExt` (at time\nof writing).\n\n`std::os::unix` rexports the contents of `std::sys::unix::ext`.\n`std::sys` is private so the \"true\" path to `CommandExt` isn't accessible.\n\nIn this case, the visible parent map will look something like this:\n\n(child) -> (parent)\n`std::sys::unix::ext::process::CommandExt` -> `std::sys::unix::ext::process`\n`std::sys::unix::ext::process` -> `std::sys::unix::ext`\n`std::sys::unix::ext` -> `std::os`\n\nThis is correct, as the visible parent of `std::sys::unix::ext` is in fact\n`std::os`.\n\nWhen printing the path to `CommandExt` and looking at the current\nsegment that corresponds to `std::sys::unix::ext`, we would normally\nprint `ext` and then go to the parent - resulting in a mangled path like\n`std::os::ext::process::CommandExt`.\n\nInstead, we must detect that there was a re-export and instead print `unix`\n(which is the name `std::sys::unix::ext` was re-exported as in `std::os`).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4334aaacf1da33ece0b13d845bf280aeddcb512b", "html_url": "https://github.com/rust-lang/rust/commit/4334aaacf1da33ece0b13d845bf280aeddcb512b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4334aaacf1da33ece0b13d845bf280aeddcb512b/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8b4150c042b06c46e29a9d12101f91fe13996e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8b4150c042b06c46e29a9d12101f91fe13996e0", "html_url": "https://github.com/rust-lang/rust/commit/b8b4150c042b06c46e29a9d12101f91fe13996e0"}], "stats": {"total": 114, "additions": 104, "deletions": 10}, "files": [{"sha": "472a2c6d9b7773879df1b00694728f0cb3e6be4c", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 64, "deletions": 10, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4334aaacf1da33ece0b13d845bf280aeddcb512b/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4334aaacf1da33ece0b13d845bf280aeddcb512b/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=4334aaacf1da33ece0b13d845bf280aeddcb512b", "patch": "@@ -10,7 +10,7 @@\n \n use hir::map::DefPathData;\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, DefIdTree, Ty, TyCtxt};\n use middle::cstore::{ExternCrate, ExternCrateSource};\n use syntax::ast;\n use syntax::symbol::{keywords, LocalInternedString, Symbol};\n@@ -219,19 +219,73 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 cur_def_key = self.def_key(parent);\n             }\n \n+            let visible_parent = visible_parent_map.get(&cur_def).cloned();\n+            let actual_parent = self.parent(cur_def);\n+            debug!(\n+                \"try_push_visible_item_path: visible_parent={:?} actual_parent={:?}\",\n+                visible_parent, actual_parent,\n+            );\n+\n             let data = cur_def_key.disambiguated_data.data;\n-            let symbol = data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n-                if let DefPathData::CrateRoot = data { // reexported `extern crate` (#43189)\n-                    self.original_crate_name(cur_def.krate).as_str()\n-                } else {\n-                    Symbol::intern(\"<unnamed>\").as_str()\n-                }\n-            });\n+            let symbol = match data {\n+                // In order to output a path that could actually be imported (valid and visible),\n+                // we need to handle re-exports correctly.\n+                //\n+                // For example, take `std::os::unix::process::CommandExt`, this trait is actually\n+                // defined at `std::sys::unix::ext::process::CommandExt` (at time of writing).\n+                //\n+                // `std::os::unix` rexports the contents of `std::sys::unix::ext`. `std::sys` is\n+                // private so the \"true\" path to `CommandExt` isn't accessible.\n+                //\n+                // In this case, the `visible_parent_map` will look something like this:\n+                //\n+                // (child) -> (parent)\n+                // `std::sys::unix::ext::process::CommandExt` -> `std::sys::unix::ext::process`\n+                // `std::sys::unix::ext::process` -> `std::sys::unix::ext`\n+                // `std::sys::unix::ext` -> `std::os`\n+                //\n+                // This is correct, as the visible parent of `std::sys::unix::ext` is in fact\n+                // `std::os`.\n+                //\n+                // When printing the path to `CommandExt` and looking at the `cur_def_key` that\n+                // corresponds to `std::sys::unix::ext`, we would normally print `ext` and then go\n+                // to the parent - resulting in a mangled path like\n+                // `std::os::ext::process::CommandExt`.\n+                //\n+                // Instead, we must detect that there was a re-export and instead print `unix`\n+                // (which is the name `std::sys::unix::ext` was re-exported as in `std::os`). To\n+                // do this, we compare the parent of `std::sys::unix::ext` (`std::sys::unix`) with\n+                // the visible parent (`std::os`). If these do not match, then we iterate over\n+                // the children of the visible parent (as was done when computing\n+                // `visible_parent_map`), looking for the specific child we currently have and then\n+                // have access to the re-exported name.\n+                DefPathData::Module(module_name) if visible_parent != actual_parent => {\n+                    let mut name: Option<ast::Ident> = None;\n+                    if let Some(visible_parent) = visible_parent {\n+                        for child in self.item_children(visible_parent).iter() {\n+                            if child.def.def_id() == cur_def {\n+                                name = Some(child.ident);\n+                            }\n+                        }\n+                    }\n+                    name.map(|n| n.as_str()).unwrap_or(module_name.as_str())\n+                },\n+                _ => {\n+                    data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {\n+                        // Re-exported `extern crate` (#43189).\n+                        if let DefPathData::CrateRoot = data {\n+                            self.original_crate_name(cur_def.krate).as_str()\n+                        } else {\n+                            Symbol::intern(\"<unnamed>\").as_str()\n+                        }\n+                    })\n+                },\n+            };\n             debug!(\"try_push_visible_item_path: symbol={:?}\", symbol);\n             cur_path.push(symbol);\n \n-            match visible_parent_map.get(&cur_def) {\n-                Some(&def) => cur_def = def,\n+            match visible_parent {\n+                Some(def) => cur_def = def,\n                 None => return false,\n             };\n         }"}, {"sha": "efe59c31263bcc69f15539d3ee22dd1ec4083bf1", "filename": "src/test/ui/issues/issue-39175.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4334aaacf1da33ece0b13d845bf280aeddcb512b/src%2Ftest%2Fui%2Fissues%2Fissue-39175.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4334aaacf1da33ece0b13d845bf280aeddcb512b/src%2Ftest%2Fui%2Fissues%2Fissue-39175.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39175.rs?ref=4334aaacf1da33ece0b13d845bf280aeddcb512b", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test ignores some platforms as the particular extension trait used\n+// to demonstrate the issue is only available on unix. This is fine as\n+// the fix to suggested paths is not platform-dependent and will apply on\n+// these platforms also.\n+\n+// ignore-windows\n+// ignore-cloudabi\n+// ignore-emscripten\n+\n+use std::process::Command;\n+// use std::os::unix::process::CommandExt;\n+\n+fn main() {\n+    Command::new(\"echo\").arg(\"hello\").exec();\n+}"}, {"sha": "f5611e2e97b3748dac661b43e11133eab9bc9f1d", "filename": "src/test/ui/issues/issue-39175.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4334aaacf1da33ece0b13d845bf280aeddcb512b/src%2Ftest%2Fui%2Fissues%2Fissue-39175.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4334aaacf1da33ece0b13d845bf280aeddcb512b/src%2Ftest%2Fui%2Fissues%2Fissue-39175.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39175.stderr?ref=4334aaacf1da33ece0b13d845bf280aeddcb512b", "patch": "@@ -0,0 +1,15 @@\n+error[E0599]: no method named `exec` found for type `&mut std::process::Command` in the current scope\n+  --> $DIR/issue-39175.rs:24:39\n+   |\n+LL |     Command::new(\"echo\").arg(\"hello\").exec();\n+   |                                       ^^^^\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+   |\n+LL | use std::os::unix::process::CommandExt;\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}]}