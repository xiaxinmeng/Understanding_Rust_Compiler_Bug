{"sha": "b2b2bbb62893b9655f65cb2813eaaba4f2e742dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYjJiYmI2Mjg5M2I5NjU1ZjY1Y2IyODEzZWFhYmE0ZjJlNzQyZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-05T20:31:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-05T20:31:33Z"}, "message": "auto merge of #13112 : ktt3ja/rust/issue-13058, r=pnkfelix\n\nPreviously, Rebuilder did not visit type parameters when rebuilding\r\ngenerics and path, so in some cases the suggestion turns out to be\r\nerroneous.", "tree": {"sha": "98a40b883f663fc26274c851d0e6989acd5e590a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98a40b883f663fc26274c851d0e6989acd5e590a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2b2bbb62893b9655f65cb2813eaaba4f2e742dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2b2bbb62893b9655f65cb2813eaaba4f2e742dd", "html_url": "https://github.com/rust-lang/rust/commit/b2b2bbb62893b9655f65cb2813eaaba4f2e742dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2b2bbb62893b9655f65cb2813eaaba4f2e742dd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9539be6d746bec6b7b43e358999a91e4d1f9a759", "url": "https://api.github.com/repos/rust-lang/rust/commits/9539be6d746bec6b7b43e358999a91e4d1f9a759", "html_url": "https://github.com/rust-lang/rust/commit/9539be6d746bec6b7b43e358999a91e4d1f9a759"}, {"sha": "1d99d37f87d4cc46d285e883c2fc28b3e4e5c405", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d99d37f87d4cc46d285e883c2fc28b3e4e5c405", "html_url": "https://github.com/rust-lang/rust/commit/1d99d37f87d4cc46d285e883c2fc28b3e4e5c405"}], "stats": {"total": 181, "additions": 157, "deletions": 24}, "files": [{"sha": "db66c93086afa4b1ecc1df5db7137ef8db4382b5", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 110, "deletions": 24, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b2b2bbb62893b9655f65cb2813eaaba4f2e742dd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b2bbb62893b9655f65cb2813eaaba4f2e742dd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=b2b2bbb62893b9655f65cb2813eaaba4f2e742dd", "patch": "@@ -80,6 +80,7 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n use syntax::ast_util::name_to_dummy_lifetime;\n+use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n use syntax::print::pprust;\n use util::ppaux::UserString;\n@@ -678,6 +679,17 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n     }\n }\n \n+struct RebuildPathInfo<'a> {\n+    path: &'a ast::Path,\n+    // indexes to insert lifetime on path.lifetimes\n+    indexes: Vec<uint>,\n+    // number of lifetimes we expect to see on the type referred by `path`\n+    // (e.g., expected=1 for struct Foo<'a>)\n+    expected: uint,\n+    anon_nums: &'a HashSet<uint>,\n+    region_names: &'a HashSet<ast::Name>\n+}\n+\n struct Rebuilder<'a> {\n     tcx: &'a ty::ctxt,\n     fn_decl: ast::P<ast::FnDecl>,\n@@ -708,6 +720,7 @@ impl<'a> Rebuilder<'a> {\n     fn rebuild(&self) -> (Vec<ast::Arg>, ast::P<ast::Ty>, ast::Generics) {\n         let mut inputs = self.fn_decl.inputs.clone();\n         let mut output = self.fn_decl.output;\n+        let mut ty_params = self.generics.ty_params.clone();\n         for sr in self.same_regions.iter() {\n             self.cur_anon.set(0);\n             self.offset_cur_anon();\n@@ -718,12 +731,14 @@ impl<'a> Rebuilder<'a> {\n                                           &anon_nums, &region_names);\n             output = self.rebuild_arg_ty_or_output(output, lifetime,\n                                                    &anon_nums, &region_names);\n+            ty_params = self.rebuild_ty_params(ty_params, lifetime,\n+                                               &region_names);\n         }\n         let generated_lifetimes = self.life_giver.get_generated_lifetimes();\n         let all_region_names = self.extract_all_region_names();\n         let generics = self.rebuild_generics(self.generics,\n                                              generated_lifetimes,\n-                                             &all_region_names);\n+                                             &all_region_names, ty_params);\n         (inputs, output, generics)\n     }\n \n@@ -782,10 +797,62 @@ impl<'a> Rebuilder<'a> {\n         self.inserted_anons.borrow_mut().insert(anon);\n     }\n \n+    fn rebuild_ty_params(&self,\n+                         ty_params: OwnedSlice<ast::TyParam>,\n+                         lifetime: ast::Lifetime,\n+                         region_names: &HashSet<ast::Name>)\n+                         -> OwnedSlice<ast::TyParam> {\n+        ty_params.map(|ty_param| {\n+            let bounds = self.rebuild_ty_param_bounds(ty_param.bounds.clone(),\n+                                                      lifetime,\n+                                                      region_names);\n+            ast::TyParam {\n+                ident: ty_param.ident,\n+                id: ty_param.id,\n+                bounds: bounds,\n+                default: ty_param.default,\n+            }\n+        })\n+    }\n+\n+    fn rebuild_ty_param_bounds(&self,\n+                               ty_param_bounds: OwnedSlice<ast::TyParamBound>,\n+                               lifetime: ast::Lifetime,\n+                               region_names: &HashSet<ast::Name>)\n+                               -> OwnedSlice<ast::TyParamBound> {\n+        ty_param_bounds.map(|tpb| {\n+            match tpb {\n+                &ast::RegionTyParamBound => ast::RegionTyParamBound,\n+                &ast::TraitTyParamBound(ref tr) => {\n+                    let last_seg = tr.path.segments.last().unwrap();\n+                    let mut insert = Vec::new();\n+                    for (i, lt) in last_seg.lifetimes.iter().enumerate() {\n+                        if region_names.contains(&lt.name) {\n+                            insert.push(i);\n+                        }\n+                    }\n+                    let rebuild_info = RebuildPathInfo {\n+                        path: &tr.path,\n+                        indexes: insert,\n+                        expected: last_seg.lifetimes.len(),\n+                        anon_nums: &HashSet::new(),\n+                        region_names: region_names\n+                    };\n+                    let new_path = self.rebuild_path(rebuild_info, lifetime);\n+                    ast::TraitTyParamBound(ast::TraitRef {\n+                        path: new_path,\n+                        ref_id: tr.ref_id,\n+                    })\n+                }\n+            }\n+        })\n+    }\n+\n     fn rebuild_generics(&self,\n                         generics: &ast::Generics,\n                         add: Vec<ast::Lifetime>,\n-                        remove: &HashSet<ast::Name>)\n+                        remove: &HashSet<ast::Name>,\n+                        ty_params: OwnedSlice<ast::TyParam>)\n                         -> ast::Generics {\n         let mut lifetimes = Vec::new();\n         for lt in add.iter() {\n@@ -798,7 +865,7 @@ impl<'a> Rebuilder<'a> {\n         }\n         ast::Generics {\n             lifetimes: lifetimes,\n-            ty_params: generics.ty_params.clone()\n+            ty_params: ty_params\n         }\n     }\n \n@@ -886,11 +953,16 @@ impl<'a> Rebuilder<'a> {\n                                     }\n                                 }\n                             }\n-                            for i in insert.iter() {\n-                                new_ty = self.rebuild_ty(new_ty, cur_ty,\n-                                                         lifetime,\n-                                                         Some((*i, expected)));\n-                            }\n+                            let rebuild_info = RebuildPathInfo {\n+                                path: path,\n+                                indexes: insert,\n+                                expected: expected,\n+                                anon_nums: anon_nums,\n+                                region_names: region_names\n+                            };\n+                            new_ty = self.rebuild_ty(new_ty, cur_ty,\n+                                                     lifetime,\n+                                                     Some(rebuild_info));\n                         }\n                         _ => ()\n                     }\n@@ -906,7 +978,7 @@ impl<'a> Rebuilder<'a> {\n                   from: ast::P<ast::Ty>,\n                   to: ast::P<ast::Ty>,\n                   lifetime: ast::Lifetime,\n-                  index_opt: Option<(uint, uint)>)\n+                  rebuild_path_info: Option<RebuildPathInfo>)\n                   -> ast::P<ast::Ty> {\n \n         fn build_to(from: ast::P<ast::Ty>,\n@@ -950,13 +1022,12 @@ impl<'a> Rebuilder<'a> {\n \n         let new_ty_node = match to.node {\n             ast::TyRptr(_, mut_ty) => ast::TyRptr(Some(lifetime), mut_ty),\n-            ast::TyPath(ref path, ref bounds, id) => {\n-                let (index, expected) = match index_opt {\n-                    Some((i, e)) => (i, e),\n+            ast::TyPath(_, ref bounds, id) => {\n+                let rebuild_info = match rebuild_path_info {\n+                    Some(ri) => ri,\n                     None => fail!(\"expect index_opt in rebuild_ty/ast::TyPath\")\n                 };\n-                let new_path = self.rebuild_path(path, index,\n-                                                 expected, lifetime);\n+                let new_path = self.rebuild_path(rebuild_info, lifetime);\n                 ast::TyPath(new_path, bounds.clone(), id)\n             }\n             _ => fail!(\"expect ast::TyRptr or ast::TyPath\")\n@@ -970,34 +1041,49 @@ impl<'a> Rebuilder<'a> {\n     }\n \n     fn rebuild_path(&self,\n-                    path: &ast::Path,\n-                    index: uint,\n-                    expected: uint,\n+                    rebuild_info: RebuildPathInfo,\n                     lifetime: ast::Lifetime)\n                     -> ast::Path {\n+        let RebuildPathInfo {\n+            path: path,\n+            indexes: indexes,\n+            expected: expected,\n+            anon_nums: anon_nums,\n+            region_names: region_names,\n+        } = rebuild_info;\n+\n         let last_seg = path.segments.last().unwrap();\n         let mut new_lts = Vec::new();\n         if last_seg.lifetimes.len() == 0 {\n-            for i in range(0, expected) {\n-                if i == index {\n-                    new_lts.push(lifetime);\n-                } else {\n-                    new_lts.push(self.life_giver.give_lifetime());\n+            // traverse once to see if there's a need to insert lifetime\n+            let need_insert = range(0, expected).any(|i| {\n+                indexes.contains(&i)\n+            });\n+            if need_insert {\n+                for i in range(0, expected) {\n+                    if indexes.contains(&i) {\n+                        new_lts.push(lifetime);\n+                    } else {\n+                        new_lts.push(self.life_giver.give_lifetime());\n+                    }\n                 }\n             }\n         } else {\n             for (i, lt) in last_seg.lifetimes.iter().enumerate() {\n-                if i == index {\n+                if indexes.contains(&i) {\n                     new_lts.push(lifetime);\n                 } else {\n                     new_lts.push(*lt);\n                 }\n             }\n         }\n+        let new_types = last_seg.types.map(|&t| {\n+            self.rebuild_arg_ty_or_output(t, lifetime, anon_nums, region_names)\n+        });\n         let new_seg = ast::PathSegment {\n             identifier: last_seg.identifier,\n             lifetimes: new_lts,\n-            types: last_seg.types.clone(),\n+            types: new_types,\n         };\n         let mut new_segs = Vec::new();\n         new_segs.push_all(path.segments.init());"}, {"sha": "a6bf5a4b653d509d48f5c0f830e27385e872d259", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param-2.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b2b2bbb62893b9655f65cb2813eaaba4f2e742dd/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b2bbb62893b9655f65cb2813eaaba4f2e742dd/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs?ref=b2b2bbb62893b9655f65cb2813eaaba4f2e742dd", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+use std::iter::{Range,range};\n+\n+trait Itble<'r, T, I: Iterator<T>> { fn iter(&'r self) -> I; }\n+\n+impl<'r> Itble<'r, uint, Range<uint>> for (uint, uint) {\n+    fn iter(&'r self) -> Range<uint> {\n+        let &(min, max) = self;\n+        range(min, max)\n+    }\n+}\n+\n+fn check<'r, I: Iterator<uint>, T: Itble<'r, uint, I>>(cont: &T) -> bool {\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn check<'a, I: Iterator<uint>, T: Itble<'a, uint, I>>(cont: &'a T) -> bool\n+    let cont_iter = cont.iter(); //~ ERROR: cannot infer\n+    let result = cont_iter.fold(Some(0u16), |state, val| {\n+        state.map_or(None, |mask| {\n+            let bit = 1 << val;\n+            if mask & bit == 0 {Some(mask|bit)} else {None}\n+        })\n+    });\n+    result.is_some()\n+}\n+\n+fn main() {}"}, {"sha": "33b849f346a057f72d6eb178f4672a934e983fff", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2b2bbb62893b9655f65cb2813eaaba4f2e742dd/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b2bbb62893b9655f65cb2813eaaba4f2e742dd/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs?ref=b2b2bbb62893b9655f65cb2813eaaba4f2e742dd", "patch": "@@ -54,5 +54,16 @@ fn bar2<'a, 'b, 'c>(x: &Bar<'a, 'b, 'c>) -> (&int, &int, &int) {\n     //~^^ ERROR: cannot infer\n }\n \n+struct Cat<'x, T> { cat: &'x int, t: T }\n+struct Dog<'y> { dog: &'y int }\n+fn cat<'x>(x: Cat<'x, Dog>) -> &int {\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn cat<'a, 'x>(x: Cat<'x, Dog<'a>>) -> &'a int\n+    x.t.dog //~ ERROR: mismatched types\n+}\n+\n+fn cat2<'x, 'y>(x: Cat<'x, Dog<'y>>) -> &int {\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn cat2<'a, 'x>(x: Cat<'x, Dog<'a>>) -> &'a int\n+    x.t.dog //~ ERROR: mismatched types\n+}\n \n fn main() {}"}]}