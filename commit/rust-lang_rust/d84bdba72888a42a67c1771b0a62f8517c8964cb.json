{"sha": "d84bdba72888a42a67c1771b0a62f8517c8964cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NGJkYmE3Mjg4OGE0MmE2N2MxNzcxYjBhNjJmODUxN2M4OTY0Y2I=", "commit": {"author": {"name": "Peter Todd", "email": "pete@petertodd.org", "date": "2018-12-08T00:54:16Z"}, "committer": {"name": "Emilio Cobos \u00c1lvarez", "email": "emilio@crisal.io", "date": "2018-12-16T19:36:25Z"}, "message": "Add test to check order of repr(int) enum fields\n\nRFC #2195 specifies that a repr(int) enum such as:\n\n    #[repr(u8)]\n    enum MyEnum {\n        B { x: u8, y: i16, z: u8 },\n    }\n\nhas a layout that is equivalent to:\n\n    #[repr(C)]\n    enum MyEnumVariantB { tag: u8, x: u8, y: i16, z: u8 },\n\nHowever this isn't actually implemented, with the actual layout being\nroughly equivalent to:\n\n    union MyEnumPayload {\n        B { x: u8, y: i16, z: u8 },\n    }\n\n    #[repr(packed)]\n    struct MyEnum {\n        tag: u8,\n        payload: MyEnumPayload,\n    }\n\nThus the variant payload is *not* subject to repr(C) ordering rules, and\ngets re-ordered as `{ x: u8, z: u8, z: i16 }`\n\nThe existing tests added in pull-req #45688 fail to catch this as the\nrepr(C) ordering just happens to match the current Rust ordering in this\ncase; adding a third field reveals the problem.", "tree": {"sha": "54c21cb914fb46e77324de1c7f8ce4247e1accc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54c21cb914fb46e77324de1c7f8ce4247e1accc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d84bdba72888a42a67c1771b0a62f8517c8964cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d84bdba72888a42a67c1771b0a62f8517c8964cb", "html_url": "https://github.com/rust-lang/rust/commit/d84bdba72888a42a67c1771b0a62f8517c8964cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d84bdba72888a42a67c1771b0a62f8517c8964cb/comments", "author": {"login": "petertodd", "id": 7042, "node_id": "MDQ6VXNlcjcwNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petertodd", "html_url": "https://github.com/petertodd", "followers_url": "https://api.github.com/users/petertodd/followers", "following_url": "https://api.github.com/users/petertodd/following{/other_user}", "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}", "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions", "organizations_url": "https://api.github.com/users/petertodd/orgs", "repos_url": "https://api.github.com/users/petertodd/repos", "events_url": "https://api.github.com/users/petertodd/events{/privacy}", "received_events_url": "https://api.github.com/users/petertodd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emilio", "id": 1323194, "node_id": "MDQ6VXNlcjEzMjMxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1323194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emilio", "html_url": "https://github.com/emilio", "followers_url": "https://api.github.com/users/emilio/followers", "following_url": "https://api.github.com/users/emilio/following{/other_user}", "gists_url": "https://api.github.com/users/emilio/gists{/gist_id}", "starred_url": "https://api.github.com/users/emilio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emilio/subscriptions", "organizations_url": "https://api.github.com/users/emilio/orgs", "repos_url": "https://api.github.com/users/emilio/repos", "events_url": "https://api.github.com/users/emilio/events{/privacy}", "received_events_url": "https://api.github.com/users/emilio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fba23d01d16db8b83b2415bc538d2a850fcf24da", "url": "https://api.github.com/repos/rust-lang/rust/commits/fba23d01d16db8b83b2415bc538d2a850fcf24da", "html_url": "https://github.com/rust-lang/rust/commit/fba23d01d16db8b83b2415bc538d2a850fcf24da"}], "stats": {"total": 54, "additions": 30, "deletions": 24}, "files": [{"sha": "f59f100653fbb31bcc5eba9fe11bf13a8bb6f02a", "filename": "src/test/run-pass/structs-enums/enum-non-c-like-repr-c-and-int.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d84bdba72888a42a67c1771b0a62f8517c8964cb/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-c-and-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84bdba72888a42a67c1771b0a62f8517c8964cb/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-c-and-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-c-and-int.rs?ref=d84bdba72888a42a67c1771b0a62f8517c8964cb", "patch": "@@ -20,11 +20,12 @@ use std::mem;\n #[repr(C, u8)]\n #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n enum MyEnum {\n-    A(u32),                 // Single primitive value\n-    B { x: u8, y: i16 },    // Composite, and the offset of `y` depends on tag being internal\n-    C,                      // Empty\n-    D(Option<u32>),         // Contains an enum\n-    E(Duration),            // Contains a struct\n+    A(u32),                     // Single primitive value\n+    B { x: u8, y: i16, z: u8 }, // Composite, and the offsets of `y` and `z`\n+                                // depend on tag being internal\n+    C,                          // Empty\n+    D(Option<u32>),             // Contains an enum\n+    E(Duration),                // Contains a struct\n }\n \n #[repr(C)]\n@@ -44,14 +45,14 @@ union MyEnumPayload {\n \n #[repr(u8)] #[derive(Copy, Clone)] enum MyEnumTag { A, B, C, D, E }\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantA(u32);\n-#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB {x: u8, y: i16 }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB {x: u8, y: i16, z: u8 }\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantD(Option<u32>);\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantE(Duration);\n \n fn main() {\n     let result: Vec<Result<MyEnum, ()>> = vec![\n         Ok(MyEnum::A(17)),\n-        Ok(MyEnum::B { x: 206, y: 1145 }),\n+        Ok(MyEnum::B { x: 206, y: 1145, z: 78 }),\n         Ok(MyEnum::C),\n         Err(()),\n         Ok(MyEnum::D(Some(407))),\n@@ -63,7 +64,7 @@ fn main() {\n     // Binary serialized version of the above (little-endian)\n     let input: Vec<u8> = vec![\n         0,  17, 0, 0, 0,\n-        1,  206,  121, 4,\n+        1,  206,  121, 4,  78,\n         2,\n         8,  /* invalid tag value */\n         3,  0,  151, 1, 0, 0,\n@@ -112,6 +113,7 @@ fn parse_my_enum<'a>(dest: &'a mut MyEnum, buf: &mut &[u8]) -> Result<(), ()> {\n             MyEnumTag::B => {\n                 dest.payload.B.x = read_u8(buf)?;\n                 dest.payload.B.y = read_u16_le(buf)? as i16;\n+                dest.payload.B.z = read_u8(buf)?;\n             }\n             MyEnumTag::C => {\n                 /* do nothing */"}, {"sha": "e88b91ab6c3f169837e8977567c951c37198797d", "filename": "src/test/run-pass/structs-enums/enum-non-c-like-repr-c.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d84bdba72888a42a67c1771b0a62f8517c8964cb/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84bdba72888a42a67c1771b0a62f8517c8964cb/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-c.rs?ref=d84bdba72888a42a67c1771b0a62f8517c8964cb", "patch": "@@ -20,11 +20,12 @@ use std::mem;\n #[repr(C)]\n #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n enum MyEnum {\n-    A(u32),                 // Single primitive value\n-    B { x: u8, y: i16 },    // Composite, and the offset of `y` depends on tag being internal\n-    C,                      // Empty\n-    D(Option<u32>),         // Contains an enum\n-    E(Duration),            // Contains a struct\n+    A(u32),                     // Single primitive value\n+    B { x: u8, y: i16, z: u8 }, // Composite, and the offset of `y` and `z`\n+                                // depend on tag being internal\n+    C,                          // Empty\n+    D(Option<u32>),             // Contains an enum\n+    E(Duration),                // Contains a struct\n }\n \n #[repr(C)]\n@@ -44,14 +45,14 @@ union MyEnumPayload {\n \n #[repr(C)] #[derive(Copy, Clone)] enum MyEnumTag { A, B, C, D, E }\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantA(u32);\n-#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB {x: u8, y: i16 }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB {x: u8, y: i16, z: u8 }\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantD(Option<u32>);\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantE(Duration);\n \n fn main() {\n     let result: Vec<Result<MyEnum, ()>> = vec![\n         Ok(MyEnum::A(17)),\n-        Ok(MyEnum::B { x: 206, y: 1145 }),\n+        Ok(MyEnum::B { x: 206, y: 1145, z: 78 }),\n         Ok(MyEnum::C),\n         Err(()),\n         Ok(MyEnum::D(Some(407))),\n@@ -63,7 +64,7 @@ fn main() {\n     // Binary serialized version of the above (little-endian)\n     let input: Vec<u8> = vec![\n         0,  17, 0, 0, 0,\n-        1,  206,  121, 4,\n+        1,  206,  121, 4,  78,\n         2,\n         8,  /* invalid tag value */\n         3,  0,  151, 1, 0, 0,\n@@ -112,6 +113,7 @@ fn parse_my_enum<'a>(dest: &'a mut MyEnum, buf: &mut &[u8]) -> Result<(), ()> {\n             MyEnumTag::B => {\n                 dest.payload.B.x = read_u8(buf)?;\n                 dest.payload.B.y = read_u16_le(buf)? as i16;\n+                dest.payload.B.z = read_u8(buf)?;\n             }\n             MyEnumTag::C => {\n                 /* do nothing */"}, {"sha": "d862c0c72c2d8dc995bf824001993a43413b2660", "filename": "src/test/run-pass/structs-enums/enum-non-c-like-repr-int.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d84bdba72888a42a67c1771b0a62f8517c8964cb/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84bdba72888a42a67c1771b0a62f8517c8964cb/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-int.rs?ref=d84bdba72888a42a67c1771b0a62f8517c8964cb", "patch": "@@ -20,11 +20,12 @@ use std::mem;\n #[repr(u8)]\n #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n enum MyEnum {\n-    A(u32),                 // Single primitive value\n-    B { x: u8, y: i16 },    // Composite, and the offset of `y` depends on tag being internal\n-    C,                      // Empty\n-    D(Option<u32>),         // Contains an enum\n-    E(Duration),            // Contains a struct\n+    A(u32),                     // Single primitive value\n+    B { x: u8, y: i16, z: u8 }, // Composite, and the offset of `y` and `z`\n+                                // depend on tag being internal\n+    C,                          // Empty\n+    D(Option<u32>),             // Contains an enum\n+    E(Duration),                // Contains a struct\n }\n \n #[allow(non_snake_case)]\n@@ -39,15 +40,15 @@ union MyEnumRepr {\n \n #[repr(u8)] #[derive(Copy, Clone)] enum MyEnumTag { A, B, C, D, E }\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantA(MyEnumTag, u32);\n-#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB { tag: MyEnumTag, x: u8, y: i16 }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB { tag: MyEnumTag, x: u8, y: i16, z: u8 }\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantC(MyEnumTag);\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantD(MyEnumTag, Option<u32>);\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantE(MyEnumTag, Duration);\n \n fn main() {\n     let result: Vec<Result<MyEnum, ()>> = vec![\n         Ok(MyEnum::A(17)),\n-        Ok(MyEnum::B { x: 206, y: 1145 }),\n+        Ok(MyEnum::B { x: 206, y: 1145, z: 78 }),\n         Ok(MyEnum::C),\n         Err(()),\n         Ok(MyEnum::D(Some(407))),\n@@ -59,7 +60,7 @@ fn main() {\n     // Binary serialized version of the above (little-endian)\n     let input: Vec<u8> = vec![\n         0,  17, 0, 0, 0,\n-        1,  206,  121, 4,\n+        1,  206,  121, 4,  78,\n         2,\n         8,  /* invalid tag value */\n         3,  0,  151, 1, 0, 0,\n@@ -108,6 +109,7 @@ fn parse_my_enum<'a>(dest: &'a mut MyEnum, buf: &mut &[u8]) -> Result<(), ()> {\n             MyEnumTag::B => {\n                 dest.B.x = read_u8(buf)?;\n                 dest.B.y = read_u16_le(buf)? as i16;\n+                dest.B.z = read_u8(buf)?;\n             }\n             MyEnumTag::C => {\n                 /* do nothing */"}]}