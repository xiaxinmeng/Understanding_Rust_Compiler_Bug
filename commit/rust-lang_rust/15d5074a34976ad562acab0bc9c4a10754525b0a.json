{"sha": "15d5074a34976ad562acab0bc9c4a10754525b0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZDUwNzRhMzQ5NzZhZDU2MmFjYWIwYmM5YzRhMTA3NTQ1MjViMGE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-26T23:56:25Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-27T00:01:04Z"}, "message": "Process `cfg_attr` attributes on non-optional expressions", "tree": {"sha": "6e8dc3cd66ad918f90e226867e2ed830f55f58c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e8dc3cd66ad918f90e226867e2ed830f55f58c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15d5074a34976ad562acab0bc9c4a10754525b0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15d5074a34976ad562acab0bc9c4a10754525b0a", "html_url": "https://github.com/rust-lang/rust/commit/15d5074a34976ad562acab0bc9c4a10754525b0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15d5074a34976ad562acab0bc9c4a10754525b0a/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3a0e1783c8e3ef336a684908fb08a0e8c0364d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3a0e1783c8e3ef336a684908fb08a0e8c0364d8", "html_url": "https://github.com/rust-lang/rust/commit/d3a0e1783c8e3ef336a684908fb08a0e8c0364d8"}], "stats": {"total": 75, "additions": 37, "deletions": 38}, "files": [{"sha": "e1c17ca43d3ab367e3f97a109297f7c89154e41d", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/15d5074a34976ad562acab0bc9c4a10754525b0a/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d5074a34976ad562acab0bc9c4a10754525b0a/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=15d5074a34976ad562acab0bc9c4a10754525b0a", "patch": "@@ -19,9 +19,15 @@ use ptr::P;\n use util::small_vector::SmallVector;\n \n pub trait CfgFolder: fold::Folder {\n-    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T>;\n+    fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool;\n+    fn process_attrs<T: HasAttrs>(&mut self, node: T) -> T { node }\n     fn visit_stmt_or_expr_attrs(&mut self, _attrs: &[ast::Attribute]) {}\n-    fn visit_unconfigurable_expr(&mut self, _expr: &ast::Expr) {}\n+    fn visit_unremovable_expr(&mut self, _expr: &ast::Expr) {}\n+\n+    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n+        let node = self.process_attrs(node);\n+        if self.in_cfg(node.attrs()) { Some(node) } else { None }\n+    }\n }\n \n /// A folder that strips out items that do not belong in the current\n@@ -32,30 +38,6 @@ pub struct StripUnconfigured<'a> {\n }\n \n impl<'a> StripUnconfigured<'a> {\n-    // Determine if an item should be translated in the current crate\n-    // configuration based on the item's attributes\n-    fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool {\n-        attrs.iter().all(|attr| {\n-            let mis = match attr.node.value.node {\n-                ast::MetaItemKind::List(_, ref mis) if is_cfg(&attr) => mis,\n-                _ => return true\n-            };\n-\n-            if mis.len() != 1 {\n-                self.diag.emit_error(|diagnostic| {\n-                    diagnostic.span_err(attr.span, \"expected 1 cfg-pattern\");\n-                });\n-                return true;\n-            }\n-\n-            attr::cfg_matches(self.config, &mis[0], &mut self.diag)\n-        })\n-    }\n-\n-    fn process_cfg_attrs(&mut self, attrs: Vec<ast::Attribute>) -> Vec<ast::Attribute> {\n-        attrs.into_iter().filter_map(|attr| self.process_cfg_attr(attr)).collect()\n-    }\n-\n     fn process_cfg_attr(&mut self, attr: ast::Attribute) -> Option<ast::Attribute> {\n         if !attr.check_name(\"cfg_attr\") {\n             return Some(attr);\n@@ -92,9 +74,30 @@ impl<'a> StripUnconfigured<'a> {\n }\n \n impl<'a> CfgFolder for StripUnconfigured<'a> {\n-    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n-        let node = node.map_attrs(|attrs| self.process_cfg_attrs(attrs));\n-        if self.in_cfg(node.attrs()) { Some(node) } else { None }\n+    // Determine if an item should be translated in the current crate\n+    // configuration based on the item's attributes\n+    fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool {\n+        attrs.iter().all(|attr| {\n+            let mis = match attr.node.value.node {\n+                ast::MetaItemKind::List(_, ref mis) if is_cfg(&attr) => mis,\n+                _ => return true\n+            };\n+\n+            if mis.len() != 1 {\n+                self.diag.emit_error(|diagnostic| {\n+                    diagnostic.span_err(attr.span, \"expected 1 cfg-pattern\");\n+                });\n+                return true;\n+            }\n+\n+            attr::cfg_matches(self.config, &mis[0], &mut self.diag)\n+        })\n+    }\n+\n+    fn process_attrs<T: HasAttrs>(&mut self, node: T) -> T {\n+        node.map_attrs(|attrs| {\n+            attrs.into_iter().filter_map(|attr| self.process_cfg_attr(attr)).collect()\n+        })\n     }\n \n     fn visit_stmt_or_expr_attrs(&mut self, attrs: &[ast::Attribute]) {\n@@ -104,7 +107,7 @@ impl<'a> CfgFolder for StripUnconfigured<'a> {\n         }\n     }\n \n-    fn visit_unconfigurable_expr(&mut self, expr: &ast::Expr) {\n+    fn visit_unremovable_expr(&mut self, expr: &ast::Expr) {\n         if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n             let msg = \"removing an expression is not supported in this position\";\n             self.diag.diag.span_err(attr.span, msg);\n@@ -195,7 +198,8 @@ impl<T: CfgFolder> fold::Folder for T {\n         //\n         // NB: This is intentionally not part of the fold_expr() function\n         //     in order for fold_opt_expr() to be able to avoid this check\n-        self.visit_unconfigurable_expr(&expr);\n+        self.visit_unremovable_expr(&expr);\n+        let expr = self.process_attrs(expr);\n         fold_expr(self, expr)\n     }\n "}, {"sha": "45f349eff31eabbda6a6708bea47575bef7d3ec3", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/15d5074a34976ad562acab0bc9c4a10754525b0a/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d5074a34976ad562acab0bc9c4a10754525b0a/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=15d5074a34976ad562acab0bc9c4a10754525b0a", "patch": "@@ -317,13 +317,8 @@ fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n     // #[test] functions\n     struct StripTests;\n     impl config::CfgFolder for StripTests {\n-        fn configure<T: attr::HasAttrs>(&mut self, node: T) -> Option<T> {\n-            let strip_node = {\n-                let attrs = node.attrs();\n-                attr::contains_name(attrs, \"test\") || attr::contains_name(attrs, \"bench\")\n-            };\n-\n-            if strip_node { None } else { Some(node) }\n+        fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool {\n+            !attr::contains_name(attrs, \"test\") && !attr::contains_name(attrs, \"bench\")\n         }\n     }\n "}]}