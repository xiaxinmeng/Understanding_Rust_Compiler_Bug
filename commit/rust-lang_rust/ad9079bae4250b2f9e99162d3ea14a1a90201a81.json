{"sha": "ad9079bae4250b2f9e99162d3ea14a1a90201a81", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkOTA3OWJhZTQyNTBiMmY5ZTk5MTYyZDNlYTE0YTFhOTAyMDFhODE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T12:13:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-25T12:13:16Z"}, "message": "Rollup merge of #39864 - cramertj:normalize-breaks, r=nikomatsakis\n\nNormalize labeled and unlabeled breaks\n\nPart of #39849.", "tree": {"sha": "d7d2ed53aa3e039be338db3fd9087c9dc835c2b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7d2ed53aa3e039be338db3fd9087c9dc835c2b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad9079bae4250b2f9e99162d3ea14a1a90201a81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad9079bae4250b2f9e99162d3ea14a1a90201a81", "html_url": "https://github.com/rust-lang/rust/commit/ad9079bae4250b2f9e99162d3ea14a1a90201a81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad9079bae4250b2f9e99162d3ea14a1a90201a81/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46fed6e6fa7a5dc2605eb1f0e2652e90e316e517", "url": "https://api.github.com/repos/rust-lang/rust/commits/46fed6e6fa7a5dc2605eb1f0e2652e90e316e517", "html_url": "https://github.com/rust-lang/rust/commit/46fed6e6fa7a5dc2605eb1f0e2652e90e316e517"}, {"sha": "6f0447b52bdbe1bc54902816078f3dbef4426515", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f0447b52bdbe1bc54902816078f3dbef4426515", "html_url": "https://github.com/rust-lang/rust/commit/6f0447b52bdbe1bc54902816078f3dbef4426515"}], "stats": {"total": 642, "additions": 443, "deletions": 199}, "files": [{"sha": "122543aee40eca45178cf1b84ab1cf77d0bb269c", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -220,15 +220,24 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // Note that `break` and `continue` statements\n                 // may cause additional edges.\n \n-                // Is the condition considered part of the loop?\n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n-                let cond_exit = self.expr(&cond, loopback);             // 2\n-                let expr_exit = self.add_ast_node(expr.id, &[cond_exit]); // 3\n+\n+                // Create expr_exit without pred (cond_exit)\n+                let expr_exit = self.add_ast_node(expr.id, &[]);         // 3\n+\n+                // The LoopScope needs to be on the loop_scopes stack while evaluating the\n+                // condition and the body of the loop (both can break out of the loop)\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n                     break_index: expr_exit\n                 });\n+\n+                let cond_exit = self.expr(&cond, loopback);             // 2\n+\n+                // Add pred (cond_exit) to expr_exit\n+                self.add_contained_edge(cond_exit, expr_exit);\n+\n                 let body_exit = self.block(&body, cond_exit);          // 4\n                 self.add_contained_edge(body_exit, loopback);            // 5\n                 self.loop_scopes.pop();\n@@ -294,17 +303,17 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_unreachable_node()\n             }\n \n-            hir::ExprBreak(label, ref opt_expr) => {\n+            hir::ExprBreak(destination, ref opt_expr) => {\n                 let v = self.opt_expr(opt_expr, pred);\n-                let loop_scope = self.find_scope(expr, label);\n+                let loop_scope = self.find_scope(expr, destination);\n                 let b = self.add_ast_node(expr.id, &[v]);\n                 self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n                 self.add_unreachable_node()\n             }\n \n-            hir::ExprAgain(label) => {\n-                let loop_scope = self.find_scope(expr, label);\n+            hir::ExprAgain(destination) => {\n+                let loop_scope = self.find_scope(expr, destination);\n                 let a = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, a,\n                                       loop_scope, loop_scope.continue_index);\n@@ -579,17 +588,18 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn find_scope(&self,\n                   expr: &hir::Expr,\n-                  label: Option<hir::Label>) -> LoopScope {\n-        match label {\n-            None => *self.loop_scopes.last().unwrap(),\n-            Some(label) => {\n+                  destination: hir::Destination) -> LoopScope {\n+\n+        match destination.loop_id.into() {\n+            Ok(loop_id) => {\n                 for l in &self.loop_scopes {\n-                    if l.loop_id == label.loop_id {\n+                    if l.loop_id == loop_id {\n                         return *l;\n                     }\n                 }\n-                span_bug!(expr.span, \"no loop scope for id {}\", label.loop_id);\n+                span_bug!(expr.span, \"no loop scope for id {}\", loop_id);\n             }\n+            Err(err) => span_bug!(expr.span, \"loop scope error: {}\",  err)\n         }\n     }\n }"}, {"sha": "fd6796ccc0bf2b0cd6b7957281a960c99322ff4c", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -1006,18 +1006,22 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprPath(ref qpath) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n         }\n-        ExprBreak(None, ref opt_expr) => {\n+        ExprBreak(label, ref opt_expr) => {\n+            label.ident.map(|ident| {\n+                if let Ok(loop_id) = label.loop_id.into() {\n+                    visitor.visit_def_mention(Def::Label(loop_id));\n+                }\n+                visitor.visit_name(ident.span, ident.node.name);\n+            });\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprBreak(Some(label), ref opt_expr) => {\n-            visitor.visit_def_mention(Def::Label(label.loop_id));\n-            visitor.visit_name(label.span, label.name);\n-            walk_list!(visitor, visit_expr, opt_expr);\n-        }\n-        ExprAgain(None) => {}\n-        ExprAgain(Some(label)) => {\n-            visitor.visit_def_mention(Def::Label(label.loop_id));\n-            visitor.visit_name(label.span, label.name);\n+        ExprAgain(label) => {\n+            label.ident.map(|ident| {\n+                if let Ok(loop_id) = label.loop_id.into() {\n+                    visitor.visit_def_mention(Def::Label(loop_id));\n+                }\n+                visitor.visit_name(ident.span, ident.node.name);\n+            });\n         }\n         ExprRet(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);"}, {"sha": "8572119e9891691d43220f4d57d5bd916bccada4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 134, "deletions": 38, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -50,6 +50,7 @@ use util::nodemap::{DefIdMap, NodeMap, FxHashMap};\n \n use std::collections::BTreeMap;\n use std::iter;\n+use std::mem;\n \n use syntax::attr;\n use syntax::ast::*;\n@@ -79,6 +80,9 @@ pub struct LoweringContext<'a> {\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n     bodies: FxHashMap<hir::BodyId, hir::Body>,\n \n+    loop_scopes: Vec<NodeId>,\n+    is_in_loop_condition: bool,\n+\n     type_def_lifetime_params: DefIdMap<usize>,\n }\n \n@@ -112,6 +116,8 @@ pub fn lower_crate(sess: &Session,\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n         bodies: FxHashMap(),\n+        loop_scopes: Vec::new(),\n+        is_in_loop_condition: false,\n         type_def_lifetime_params: DefIdMap(),\n     }.lower_crate(krate)\n }\n@@ -244,6 +250,55 @@ impl<'a> LoweringContext<'a> {\n         span\n     }\n \n+    fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n+        where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        // We're no longer in the base loop's condition; we're in another loop.\n+        let was_in_loop_condition = self.is_in_loop_condition;\n+        self.is_in_loop_condition = false;\n+\n+        let len = self.loop_scopes.len();\n+        self.loop_scopes.push(loop_id);\n+\n+        let result = f(self);\n+        assert_eq!(len + 1, self.loop_scopes.len(),\n+            \"Loop scopes should be added and removed in stack order\");\n+\n+        self.loop_scopes.pop().unwrap();\n+\n+        self.is_in_loop_condition = was_in_loop_condition;\n+\n+        result\n+    }\n+\n+    fn with_loop_condition_scope<T, F>(&mut self, f: F) -> T\n+        where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        let was_in_loop_condition = self.is_in_loop_condition;\n+        self.is_in_loop_condition = true;\n+\n+        let result = f(self);\n+\n+        self.is_in_loop_condition = was_in_loop_condition;\n+\n+        result\n+    }\n+\n+    fn with_new_loop_scopes<T, F>(&mut self, f: F) -> T\n+        where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        let was_in_loop_condition = self.is_in_loop_condition;\n+        self.is_in_loop_condition = false;\n+\n+        let loop_scopes = mem::replace(&mut self.loop_scopes, Vec::new());\n+        let result = f(self);\n+        mem::replace(&mut self.loop_scopes, loop_scopes);\n+\n+        self.is_in_loop_condition = was_in_loop_condition;\n+\n+        result\n+    }\n+\n     fn with_parent_def<T, F>(&mut self, parent_id: NodeId, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n@@ -271,17 +326,24 @@ impl<'a> LoweringContext<'a> {\n         o_id.map(|sp_ident| respan(sp_ident.span, sp_ident.node.name))\n     }\n \n-    fn lower_label(&mut self, id: NodeId, label: Option<Spanned<Ident>>) -> Option<hir::Label> {\n-        label.map(|sp_ident| {\n-            hir::Label {\n-                span: sp_ident.span,\n-                name: sp_ident.node.name,\n-                loop_id: match self.expect_full_def(id) {\n-                    Def::Label(loop_id) => loop_id,\n-                    _ => DUMMY_NODE_ID\n+    fn lower_destination(&mut self, destination: Option<(NodeId, Spanned<Ident>)>)\n+        -> hir::Destination\n+    {\n+        match destination {\n+            Some((id, label_ident)) => hir::Destination {\n+                ident: Some(label_ident),\n+                loop_id: if let Def::Label(loop_id) = self.expect_full_def(id) {\n+                    hir::LoopIdResult::Ok(loop_id)\n+                } else {\n+                    hir::LoopIdResult::Err(hir::LoopIdError::UnresolvedLabel)\n                 }\n+            },\n+            None => hir::Destination {\n+                ident: None,\n+                loop_id: self.loop_scopes.last().map(|innermost_loop_id| Ok(*innermost_loop_id))\n+                            .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope)).into()\n             }\n-        })\n+        }\n     }\n \n     fn lower_attrs(&mut self, attrs: &Vec<Attribute>) -> hir::HirVec<Attribute> {\n@@ -992,15 +1054,17 @@ impl<'a> LoweringContext<'a> {\n                                self.record_body(value, None))\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n-                let body = self.lower_block(body);\n-                let body = self.expr_block(body, ThinVec::new());\n-                let body_id = self.record_body(body, Some(decl));\n-                hir::ItemFn(self.lower_fn_decl(decl),\n-                            self.lower_unsafety(unsafety),\n-                            self.lower_constness(constness),\n-                            abi,\n-                            self.lower_generics(generics),\n-                            body_id)\n+                self.with_new_loop_scopes(|this| {\n+                    let body = this.lower_block(body);\n+                    let body = this.expr_block(body, ThinVec::new());\n+                    let body_id = this.record_body(body, Some(decl));\n+                    hir::ItemFn(this.lower_fn_decl(decl),\n+                                              this.lower_unsafety(unsafety),\n+                                              this.lower_constness(constness),\n+                                              abi,\n+                                              this.lower_generics(generics),\n+                                              body_id)\n+                })\n             }\n             ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n@@ -1562,26 +1626,32 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprIf(P(self.lower_expr(cond)), self.lower_block(blk), else_opt)\n                 }\n                 ExprKind::While(ref cond, ref body, opt_ident) => {\n-                    hir::ExprWhile(P(self.lower_expr(cond)), self.lower_block(body),\n-                                   self.lower_opt_sp_ident(opt_ident))\n+                    self.with_loop_scope(e.id, |this|\n+                        hir::ExprWhile(\n+                            this.with_loop_condition_scope(|this| P(this.lower_expr(cond))),\n+                            this.lower_block(body),\n+                            this.lower_opt_sp_ident(opt_ident)))\n                 }\n                 ExprKind::Loop(ref body, opt_ident) => {\n-                    hir::ExprLoop(self.lower_block(body),\n-                                  self.lower_opt_sp_ident(opt_ident),\n-                                  hir::LoopSource::Loop)\n+                    self.with_loop_scope(e.id, |this|\n+                        hir::ExprLoop(this.lower_block(body),\n+                                      this.lower_opt_sp_ident(opt_ident),\n+                                      hir::LoopSource::Loop))\n                 }\n                 ExprKind::Match(ref expr, ref arms) => {\n                     hir::ExprMatch(P(self.lower_expr(expr)),\n                                    arms.iter().map(|x| self.lower_arm(x)).collect(),\n                                    hir::MatchSource::Normal)\n                 }\n                 ExprKind::Closure(capture_clause, ref decl, ref body, fn_decl_span) => {\n-                    self.with_parent_def(e.id, |this| {\n-                        let expr = this.lower_expr(body);\n-                        hir::ExprClosure(this.lower_capture_clause(capture_clause),\n-                                         this.lower_fn_decl(decl),\n-                                         this.record_body(expr, Some(decl)),\n-                                         fn_decl_span)\n+                    self.with_new_loop_scopes(|this| {\n+                        this.with_parent_def(e.id, |this| {\n+                            let expr = this.lower_expr(body);\n+                            hir::ExprClosure(this.lower_capture_clause(capture_clause),\n+                                             this.lower_fn_decl(decl),\n+                                             this.record_body(expr, Some(decl)),\n+                                             fn_decl_span)\n+                        })\n                     })\n                 }\n                 ExprKind::Block(ref blk) => hir::ExprBlock(self.lower_block(blk)),\n@@ -1660,10 +1730,29 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprPath(self.lower_qpath(e.id, qself, path, ParamMode::Optional))\n                 }\n                 ExprKind::Break(opt_ident, ref opt_expr) => {\n-                    hir::ExprBreak(self.lower_label(e.id, opt_ident),\n-                                   opt_expr.as_ref().map(|x| P(self.lower_expr(x))))\n+                    let label_result = if self.is_in_loop_condition && opt_ident.is_none() {\n+                        hir::Destination {\n+                            ident: opt_ident,\n+                            loop_id: Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n+                        }\n+                    } else {\n+                        self.lower_destination(opt_ident.map(|ident| (e.id, ident)))\n+                    };\n+                    hir::ExprBreak(\n+                            label_result,\n+                            opt_expr.as_ref().map(|x| P(self.lower_expr(x))))\n                 }\n-                ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_label(e.id, opt_ident)),\n+                ExprKind::Continue(opt_ident) =>\n+                    hir::ExprAgain(\n+                        if self.is_in_loop_condition && opt_ident.is_none() {\n+                            hir::Destination {\n+                                ident: opt_ident,\n+                                loop_id: Err(\n+                                    hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n+                            }\n+                        } else {\n+                            self.lower_destination(opt_ident.map( |ident| (e.id, ident)))\n+                        }),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n                 ExprKind::InlineAsm(ref asm) => {\n                     let hir_asm = hir::InlineAsm {\n@@ -1804,9 +1893,16 @@ impl<'a> LoweringContext<'a> {\n                     //     }\n                     //   }\n \n+                    // Note that the block AND the condition are evaluated in the loop scope.\n+                    // This is done to allow `break` from inside the condition of the loop.\n+                    let (body, break_expr, sub_expr) = self.with_loop_scope(e.id, |this| (\n+                        this.lower_block(body),\n+                        this.expr_break(e.span, ThinVec::new()),\n+                        this.with_loop_condition_scope(|this| P(this.lower_expr(sub_expr))),\n+                    ));\n+\n                     // `<pat> => <body>`\n                     let pat_arm = {\n-                        let body = self.lower_block(body);\n                         let body_expr = P(self.expr_block(body, ThinVec::new()));\n                         let pat = self.lower_pat(pat);\n                         self.arm(hir_vec![pat], body_expr)\n@@ -1815,13 +1911,11 @@ impl<'a> LoweringContext<'a> {\n                     // `_ => break`\n                     let break_arm = {\n                         let pat_under = self.pat_wild(e.span);\n-                        let break_expr = self.expr_break(e.span, ThinVec::new());\n                         self.arm(hir_vec![pat_under], break_expr)\n                     };\n \n                     // `match <sub_expr> { ... }`\n                     let arms = hir_vec![pat_arm, break_arm];\n-                    let sub_expr = P(self.lower_expr(sub_expr));\n                     let match_expr = self.expr(e.span,\n                                                hir::ExprMatch(sub_expr,\n                                                               arms,\n@@ -1863,7 +1957,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // `::std::option::Option::Some(<pat>) => <body>`\n                     let pat_arm = {\n-                        let body_block = self.lower_block(body);\n+                        let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body));\n                         let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n                         let pat = self.lower_pat(pat);\n                         let some_pat = self.pat_some(e.span, pat);\n@@ -1873,7 +1967,8 @@ impl<'a> LoweringContext<'a> {\n \n                     // `::std::option::Option::None => break`\n                     let break_arm = {\n-                        let break_expr = self.expr_break(e.span, ThinVec::new());\n+                        let break_expr = self.with_loop_scope(e.id, |this|\n+                            this.expr_break(e.span, ThinVec::new()));\n                         let pat = self.pat_none(e.span);\n                         self.arm(hir_vec![pat], break_expr)\n                     };\n@@ -2151,7 +2246,8 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        P(self.expr(span, hir::ExprBreak(None, None), attrs))\n+        let expr_break = hir::ExprBreak(self.lower_destination(None), None);\n+        P(self.expr(span, expr_break, attrs))\n     }\n \n     fn expr_call(&mut self, span: Span, e: P<hir::Expr>, args: hir::HirVec<hir::Expr>)"}, {"sha": "e8c5f2447cd6f5a15ffd9e62b4a267f2b798e16a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -36,7 +36,7 @@ use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n use syntax_pos::{Span, ExpnId, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n-use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n+use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n@@ -959,9 +959,9 @@ pub enum Expr_ {\n     /// A referencing operation (`&a` or `&mut a`)\n     ExprAddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Option<Label>, Option<P<Expr>>),\n+    ExprBreak(Destination, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n-    ExprAgain(Option<Label>),\n+    ExprAgain(Destination),\n     /// A `return`, with an optional value to be returned\n     ExprRet(Option<P<Expr>>),\n \n@@ -1030,12 +1030,56 @@ pub enum LoopSource {\n     ForLoop,\n }\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum LoopIdError {\n+    OutsideLoopScope,\n+    UnlabeledCfInWhileCondition,\n+    UnresolvedLabel,\n+}\n+\n+impl fmt::Display for LoopIdError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(match *self {\n+            LoopIdError::OutsideLoopScope => \"not inside loop scope\",\n+            LoopIdError::UnlabeledCfInWhileCondition =>\n+                \"unlabeled control flow (break or continue) in while condition\",\n+            LoopIdError::UnresolvedLabel => \"label not found\",\n+        }, f)\n+    }\n+}\n \n+// FIXME(cramertj) this should use `Result` once master compiles w/ a vesion of Rust where\n+// `Result` implements `Encodable`/`Decodable`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub struct Label {\n-    pub span: Span,\n-    pub name: Name,\n-    pub loop_id: NodeId\n+pub enum LoopIdResult {\n+    Ok(NodeId),\n+    Err(LoopIdError),\n+}\n+impl Into<Result<NodeId, LoopIdError>> for LoopIdResult {\n+    fn into(self) -> Result<NodeId, LoopIdError> {\n+        match self {\n+            LoopIdResult::Ok(ok) => Ok(ok),\n+            LoopIdResult::Err(err) => Err(err),\n+        }\n+    }\n+}\n+impl From<Result<NodeId, LoopIdError>> for LoopIdResult {\n+    fn from(res: Result<NodeId, LoopIdError>) -> Self {\n+        match res {\n+            Ok(ok) => LoopIdResult::Ok(ok),\n+            Err(err) => LoopIdResult::Err(err),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub struct Destination {\n+    // This is `Some(_)` iff there is an explicit user-specified `label\n+    pub ident: Option<Spanned<Ident>>,\n+\n+    // These errors are caught and then reported during the diagnostics pass in\n+    // librustc_passes/loops.rs\n+    pub loop_id: LoopIdResult,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]"}, {"sha": "3411de9bb5df11356b753f08bb2c49c5946c74f4", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -1354,23 +1354,23 @@ impl<'a> State<'a> {\n             hir::ExprPath(ref qpath) => {\n                 self.print_qpath(qpath, true)?\n             }\n-            hir::ExprBreak(opt_label, ref opt_expr) => {\n+            hir::ExprBreak(label, ref opt_expr) => {\n                 word(&mut self.s, \"break\")?;\n                 space(&mut self.s)?;\n-                if let Some(label) = opt_label {\n-                    self.print_name(label.name)?;\n+                if let Some(label_ident) = label.ident {\n+                    self.print_name(label_ident.node.name)?;\n                     space(&mut self.s)?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr(expr)?;\n                     space(&mut self.s)?;\n                 }\n             }\n-            hir::ExprAgain(opt_label) => {\n+            hir::ExprAgain(label) => {\n                 word(&mut self.s, \"continue\")?;\n                 space(&mut self.s)?;\n-                if let Some(label) = opt_label {\n-                    self.print_name(label.name)?;\n+                if let Some(label_ident) = label.ident {\n+                    self.print_name(label_ident.node.name)?;\n                     space(&mut self.s)?\n                 }\n             }"}, {"sha": "b7f7c49d7b0e36bb2cc007b13103c927ab005d54", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -675,23 +675,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn find_loop_scope(&self,\n-                       opt_label: Option<hir::Label>,\n-                       sp: Span)\n-                       -> NodeId {\n-        match opt_label {\n-            Some(label) => label.loop_id,\n-            None => {\n-                // Vanilla 'break' or 'continue', so use the enclosing\n-                // loop scope\n-                if self.loop_scope.is_empty() {\n-                    span_bug!(sp, \"break outside loop\");\n-                } else {\n-                    *self.loop_scope.last().unwrap()\n-                }\n-            }\n-        }\n-    }\n \n     #[allow(unused_must_use)]\n     fn ln_str(&self, ln: LiveNode) -> String {\n@@ -1018,9 +1001,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n           }\n \n-          hir::ExprBreak(opt_label, ref opt_expr) => {\n+          hir::ExprBreak(label, ref opt_expr) => {\n               // Find which label this break jumps to\n-              let sc = self.find_loop_scope(opt_label, expr.span);\n+              let sc = match label.loop_id.into() {\n+                  Ok(loop_id) => loop_id,\n+                  Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n+              };\n \n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n@@ -1031,9 +1017,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               }\n           }\n \n-          hir::ExprAgain(opt_label) => {\n+          hir::ExprAgain(label) => {\n               // Find which label this expr continues to\n-              let sc = self.find_loop_scope(opt_label, expr.span);\n+              let sc = match label.loop_id.into() {\n+                  Ok(loop_id) => loop_id,\n+                  Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n+              };\n+\n \n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n@@ -1297,12 +1287,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n                expr.id, self.ir.tcx.hir.node_to_pretty_string(body.id));\n \n-        let cond_ln = match kind {\n-            LoopLoop => ln,\n-            WhileLoop(ref cond) => self.propagate_through_expr(&cond, ln),\n-        };\n-        let body_ln = self.with_loop_nodes(expr.id, succ, ln, |this| {\n-            this.propagate_through_block(body, cond_ln)\n+        let (cond_ln, body_ln) = self.with_loop_nodes(expr.id, succ, ln, |this| {\n+            let cond_ln = match kind {\n+                LoopLoop => ln,\n+                WhileLoop(ref cond) => this.propagate_through_expr(&cond, ln),\n+            };\n+            let body_ln = this.propagate_through_block(body, cond_ln);\n+            (cond_ln, body_ln)\n         });\n \n         // repeat until fixed point is reached:"}, {"sha": "62bbb86e7dad5be4e10b41dc72bee1da773487dd", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -338,8 +338,10 @@ fn saw_expr<'a>(node: &'a Expr_,\n         ExprIndex(..)            => (SawExprIndex, true),\n         ExprPath(_)              => (SawExprPath, false),\n         ExprAddrOf(m, _)         => (SawExprAddrOf(m), false),\n-        ExprBreak(label, _)      => (SawExprBreak(label.map(|l| l.name.as_str())), false),\n-        ExprAgain(label)         => (SawExprAgain(label.map(|l| l.name.as_str())), false),\n+        ExprBreak(label, _)      => (SawExprBreak(label.ident.map(|i|\n+                                                    i.node.name.as_str())), false),\n+        ExprAgain(label)         => (SawExprAgain(label.ident.map(|i|\n+                                                    i.node.name.as_str())), false),\n         ExprRet(..)              => (SawExprRet, false),\n         ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(StableInlineAsm(a)), false),\n         ExprStruct(..)           => (SawExprStruct, false),"}, {"sha": "282361fc13e27054f37a759ff1793de2004cead4", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -385,22 +385,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// resolving `break` and `continue`.\n     pub fn find_loop_scope(&mut self,\n                            span: Span,\n-                           label: Option<CodeExtent>)\n+                           label: CodeExtent)\n                            -> &mut LoopScope<'tcx> {\n-        let loop_scopes = &mut self.loop_scopes;\n-        match label {\n-            None => {\n-                // no label? return the innermost loop scope\n-                loop_scopes.iter_mut().rev().next()\n-            }\n-            Some(label) => {\n-                // otherwise, find the loop-scope with the correct id\n-                loop_scopes.iter_mut()\n-                           .rev()\n-                           .filter(|loop_scope| loop_scope.extent == label)\n-                           .next()\n-            }\n-        }.unwrap_or_else(|| span_bug!(span, \"no enclosing loop scope found?\"))\n+        // find the loop-scope with the correct id\n+        self.loop_scopes.iter_mut()\n+            .rev()\n+            .filter(|loop_scope| loop_scope.extent == label)\n+            .next()\n+            .unwrap_or_else(|| span_bug!(span, \"no enclosing loop scope found?\"))\n     }\n \n     /// Given a span and the current visibility scope, make a SourceInfo."}, {"sha": "3a9ac143f783be4ff91377b5a7e36960647977b3", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -605,14 +605,21 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n         hir::ExprRet(ref v) => ExprKind::Return { value: v.to_ref() },\n         hir::ExprBreak(label, ref value) => {\n-            ExprKind::Break {\n-                label: label.map(|label| cx.tcx.region_maps.node_extent(label.loop_id)),\n-                value: value.to_ref(),\n+            match label.loop_id.into() {\n+                Ok(loop_id) => ExprKind::Break {\n+                    label: cx.tcx.region_maps.node_extent(loop_id),\n+                    value: value.to_ref(),\n+                },\n+                Err(err) => bug!(\"invalid loop id for break: {}\", err)\n             }\n+\n         }\n         hir::ExprAgain(label) => {\n-            ExprKind::Continue {\n-                label: label.map(|label| cx.tcx.region_maps.node_extent(label.loop_id)),\n+            match label.loop_id.into() {\n+                Ok(loop_id) => ExprKind::Continue {\n+                    label: cx.tcx.region_maps.node_extent(loop_id),\n+                },\n+                Err(err) => bug!(\"invalid loop id for continue: {}\", err)\n             }\n         }\n         hir::ExprMatch(ref discr, ref arms, _) => {"}, {"sha": "3068258f6c24f185bb5cf09154de4d7e542a1a4a", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -205,11 +205,11 @@ pub enum ExprKind<'tcx> {\n         arg: ExprRef<'tcx>,\n     },\n     Break {\n-        label: Option<CodeExtent>,\n+        label: CodeExtent,\n         value: Option<ExprRef<'tcx>>,\n     },\n     Continue {\n-        label: Option<CodeExtent>,\n+        label: CodeExtent,\n     },\n     Return {\n         value: Option<ExprRef<'tcx>>,"}, {"sha": "5f06eadb84a9248f13e6bbf3592423f79b91f68f", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -241,6 +241,22 @@ match 5u32 {\n }\n ```\n \"##,\n+\n+E0590: r##\"\n+`break` or `continue` must include a label when used in the condition of a\n+`while` loop.\n+\n+Example of erroneous code:\n+\n+```compile_fail\n+while break {}\n+```\n+\n+To fix this, add a label specifying which loop is being broken out of:\n+```\n+`foo: while break `foo {}\n+```\n+\"##\n }\n \n register_diagnostics! {"}, {"sha": "b2d51be5bf72095bc3b4199dec8af37c285ae3e9", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -87,23 +87,26 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 self.with_context(Closure, |v| v.visit_nested_body(b));\n             }\n             hir::ExprBreak(label, ref opt_expr) => {\n+                let loop_id = match label.loop_id.into() {\n+                    Ok(loop_id) => loop_id,\n+                    Err(hir::LoopIdError::OutsideLoopScope) => ast::DUMMY_NODE_ID,\n+                    Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n+                        self.emit_unlabled_cf_in_while_condition(e.span, \"break\");\n+                        ast::DUMMY_NODE_ID\n+                    },\n+                    Err(hir::LoopIdError::UnresolvedLabel) => ast::DUMMY_NODE_ID,\n+                };\n+\n                 if opt_expr.is_some() {\n-                    let loop_kind = if let Some(label) = label {\n-                        if label.loop_id == ast::DUMMY_NODE_ID {\n-                            None\n-                        } else {\n-                            Some(match self.hir_map.expect_expr(label.loop_id).node {\n-                                hir::ExprWhile(..) => LoopKind::WhileLoop,\n-                                hir::ExprLoop(_, _, source) => LoopKind::Loop(source),\n-                                ref r => span_bug!(e.span,\n-                                                   \"break label resolved to a non-loop: {:?}\", r),\n-                            })\n-                        }\n-                    } else if let Loop(kind) = self.cx {\n-                        Some(kind)\n-                    } else {\n-                        // `break` outside a loop - caught below\n+                    let loop_kind = if loop_id == ast::DUMMY_NODE_ID {\n                         None\n+                    } else {\n+                        Some(match self.hir_map.expect_expr(loop_id).node {\n+                            hir::ExprWhile(..) => LoopKind::WhileLoop,\n+                            hir::ExprLoop(_, _, source) => LoopKind::Loop(source),\n+                            ref r => span_bug!(e.span,\n+                                               \"break label resolved to a non-loop: {:?}\", r),\n+                        })\n                     };\n                     match loop_kind {\n                         None | Some(LoopKind::Loop(hir::LoopSource::Loop)) => (),\n@@ -117,9 +120,15 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                         }\n                     }\n                 }\n+\n                 self.require_loop(\"break\", e.span);\n             }\n-            hir::ExprAgain(_) => self.require_loop(\"continue\", e.span),\n+            hir::ExprAgain(label) => {\n+                if let Err(hir::LoopIdError::UnlabeledCfInWhileCondition) = label.loop_id.into() {\n+                    self.emit_unlabled_cf_in_while_condition(e.span, \"continue\");\n+                }\n+                self.require_loop(\"continue\", e.span)\n+            },\n             _ => intravisit::walk_expr(self, e),\n         }\n     }\n@@ -150,4 +159,12 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n             }\n         }\n     }\n+\n+    fn emit_unlabled_cf_in_while_condition(&mut self, span: Span, cf_type: &str) {\n+        struct_span_err!(self.sess, span, E0590,\n+                         \"`break` or `continue` with no label in the condition of a `while` loop\")\n+            .span_label(span,\n+                        &format!(\"unlabeled `{}` in the condition of a `while` loop\", cf_type))\n+            .emit();\n+    }\n }"}, {"sha": "2c073d45bffbde890d7da1389ccec2c3d9a01c92", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -2768,18 +2768,24 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn resolve_labeled_block(&mut self, label: Option<SpannedIdent>, id: NodeId, block: &Block) {\n+    fn with_resolved_label<F>(&mut self, label: Option<SpannedIdent>, id: NodeId, f: F)\n+        where F: FnOnce(&mut Resolver)\n+    {\n         if let Some(label) = label {\n             let def = Def::Label(id);\n             self.with_label_rib(|this| {\n                 this.label_ribs.last_mut().unwrap().bindings.insert(label.node, def);\n-                this.visit_block(block);\n+                f(this);\n             });\n         } else {\n-            self.visit_block(block);\n+            f(self);\n         }\n     }\n \n+    fn resolve_labeled_block(&mut self, label: Option<SpannedIdent>, id: NodeId, block: &Block) {\n+        self.with_resolved_label(label, id, |this| this.visit_block(block));\n+    }\n+\n     fn resolve_expr(&mut self, expr: &Expr, parent: Option<&ExprKind>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n@@ -2833,18 +2839,18 @@ impl<'a> Resolver<'a> {\n             ExprKind::Loop(ref block, label) => self.resolve_labeled_block(label, expr.id, &block),\n \n             ExprKind::While(ref subexpression, ref block, label) => {\n-                self.visit_expr(subexpression);\n-                self.resolve_labeled_block(label, expr.id, &block);\n+                self.with_resolved_label(label, expr.id, |this| {\n+                    this.visit_expr(subexpression);\n+                    this.visit_block(block);\n+                });\n             }\n \n             ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n-                self.visit_expr(subexpression);\n-                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut FxHashMap());\n-\n-                self.resolve_labeled_block(label, expr.id, block);\n-\n-                self.ribs[ValueNS].pop();\n+                self.with_resolved_label(label, expr.id, |this| {\n+                    this.visit_expr(subexpression);\n+                    this.resolve_pattern(pattern, PatternSource::WhileLet, &mut FxHashMap());\n+                    this.visit_block(block);\n+                });\n             }\n \n             ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {"}, {"sha": "14dacb0ca97cb93f490fd262827be6cd0991264b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -425,15 +425,12 @@ pub struct EnclosingLoops<'gcx, 'tcx> {\n }\n \n impl<'gcx, 'tcx> EnclosingLoops<'gcx, 'tcx> {\n-    fn find_loop(&mut self, id: Option<ast::NodeId>) -> Option<&mut LoopCtxt<'gcx, 'tcx>> {\n-        if let Some(id) = id {\n-            if let Some(ix) = self.by_id.get(&id).cloned() {\n-                Some(&mut self.stack[ix])\n-            } else {\n-                None\n-            }\n+    fn find_loop(&mut self, id: hir::LoopIdResult) -> Option<&mut LoopCtxt<'gcx, 'tcx>> {\n+        let id_res: Result<_,_> = id.into();\n+        if let Some(ix) = id_res.ok().and_then(|id| self.by_id.get(&id).cloned()) {\n+            Some(&mut self.stack[ix])\n         } else {\n-            self.stack.last_mut()\n+            None\n         }\n     }\n }\n@@ -3596,10 +3593,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               tcx.mk_nil()\n           }\n           hir::ExprBreak(label, ref expr_opt) => {\n-            let loop_id = label.map(|l| l.loop_id);\n             let coerce_to = {\n                 let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n-                enclosing_loops.find_loop(loop_id).map(|ctxt| ctxt.coerce_to)\n+                enclosing_loops.find_loop(label.loop_id).map(|ctxt| ctxt.coerce_to)\n             };\n             if let Some(coerce_to) = coerce_to {\n                 let e_ty;\n@@ -3614,8 +3610,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     e_ty = tcx.mk_nil();\n                     cause = self.misc(expr.span);\n                 }\n+\n                 let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n-                let ctxt = enclosing_loops.find_loop(loop_id).unwrap();\n+                let ctxt = enclosing_loops.find_loop(label.loop_id).unwrap();\n \n                 let result = if let Some(ref e) = *expr_opt {\n                     // Special-case the first element, as it has no \"previous expressions\"."}, {"sha": "e3c1ada878df593d9e2367441b4c8cad61339a18", "filename": "src/test/compile-fail/issue-37576.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Ftest%2Fcompile-fail%2Fissue-37576.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Ftest%2Fcompile-fail%2Fissue-37576.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-37576.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    'test_1: while break 'test_1 {}\n+    while break {}\n+    //~^ ERROR `break` or `continue` with no label\n+\n+    'test_2: while let true = break 'test_2 {}\n+    while let true = break {}\n+    //~^ ERROR `break` or `continue` with no label\n+\n+    loop { 'test_3: while break 'test_3 {} }\n+    loop { while break {} }\n+    //~^ ERROR `break` or `continue` with no label\n+\n+    loop {\n+        'test_4: while break 'test_4 {}\n+        break;\n+    }\n+    loop {\n+        while break {}\n+        //~^ ERROR `break` or `continue` with no label\n+        break;\n+    }\n+\n+    'test_5: while continue 'test_5 {}\n+    while continue {}\n+    //~^ ERROR `break` or `continue` with no label\n+\n+    'test_6: while let true = continue 'test_6 {}\n+    while let true = continue {}\n+    //~^ ERROR `break` or `continue` with no label\n+\n+    loop { 'test_7: while continue 'test_7 {} }\n+    loop { while continue {} }\n+    //~^ ERROR `break` or `continue` with no label\n+\n+    loop {\n+        'test_8: while continue 'test_8 {}\n+        continue;\n+    }\n+    loop {\n+        while continue {}\n+        //~^ ERROR `break` or `continue` with no label\n+        continue;\n+    }\n+}"}, {"sha": "6695e972f333731caa591f8d2c27f4c08b458580", "filename": "src/test/compile-fail/resolve-label.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Ftest%2Fcompile-fail%2Fresolve-label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Ftest%2Fcompile-fail%2Fresolve-label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-label.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -17,8 +17,7 @@ fn f() {\n         }\n     }\n \n-    // issue #37353\n-    loop { 'w: while break 'w { } } //~ ERROR use of undeclared label\n+    loop { 'w: while break 'w { } }\n }\n \n fn main() {}"}, {"sha": "07b9c744a71711c33f87bad824fbdd4746dc8140", "filename": "src/test/run-make/graphviz-flowgraph/f10.dot-expected.dot", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -5,10 +5,10 @@ digraph block {\n     N3[label=\"local mut x\"];\n     N4[label=\"stmt let mut x = 10;\"];\n     N5[label=\"(dummy_node)\"];\n-    N6[label=\"expr x\"];\n-    N7[label=\"expr 0\"];\n-    N8[label=\"expr x > 0\"];\n-    N9[label=\"expr while x > 0 { x -= 1; }\"];\n+    N6[label=\"expr while x > 0 { x -= 1; }\"];\n+    N7[label=\"expr x\"];\n+    N8[label=\"expr 0\"];\n+    N9[label=\"expr x > 0\"];\n     N10[label=\"expr 1\"];\n     N11[label=\"expr x\"];\n     N12[label=\"expr x -= 1\"];\n@@ -20,17 +20,17 @@ digraph block {\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n+    N5 -> N7;\n     N7 -> N8;\n     N8 -> N9;\n-    N8 -> N10;\n+    N9 -> N6;\n+    N9 -> N10;\n     N10 -> N11;\n     N11 -> N12;\n     N12 -> N13;\n     N13 -> N14;\n     N14 -> N5;\n-    N9 -> N15;\n+    N6 -> N15;\n     N15 -> N16;\n     N16 -> N1;\n }"}, {"sha": "c8bfcd6510b30054fd02295cc34bd62e033d5e94", "filename": "src/test/run-make/graphviz-flowgraph/f23.dot-expected.dot", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -11,28 +11,28 @@ digraph block {\n     N9[label=\"local mut z\"];\n     N10[label=\"stmt let mut z = 23;\"];\n     N11[label=\"(dummy_node)\"];\n-    N12[label=\"expr x\"];\n-    N13[label=\"expr 0\"];\n-    N14[label=\"expr x > 0\"];\n-    N15[label=\"expr while x > 0 {\\l    x -= 1;\\l    while y > 0 {\\l        y -= 1;\\l        while z > 0 { z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N12[label=\"expr while x > 0 {\\l    x -= 1;\\l    while y > 0 {\\l        y -= 1;\\l        while z > 0 { z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N13[label=\"expr x\"];\n+    N14[label=\"expr 0\"];\n+    N15[label=\"expr x > 0\"];\n     N16[label=\"expr 1\"];\n     N17[label=\"expr x\"];\n     N18[label=\"expr x -= 1\"];\n     N19[label=\"stmt x -= 1;\"];\n     N20[label=\"(dummy_node)\"];\n-    N21[label=\"expr y\"];\n-    N22[label=\"expr 0\"];\n-    N23[label=\"expr y > 0\"];\n-    N24[label=\"expr while y > 0 {\\l    y -= 1;\\l    while z > 0 { z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N21[label=\"expr while y > 0 {\\l    y -= 1;\\l    while z > 0 { z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N22[label=\"expr y\"];\n+    N23[label=\"expr 0\"];\n+    N24[label=\"expr y > 0\"];\n     N25[label=\"expr 1\"];\n     N26[label=\"expr y\"];\n     N27[label=\"expr y -= 1\"];\n     N28[label=\"stmt y -= 1;\"];\n     N29[label=\"(dummy_node)\"];\n-    N30[label=\"expr z\"];\n-    N31[label=\"expr 0\"];\n-    N32[label=\"expr z > 0\"];\n-    N33[label=\"expr while z > 0 { z -= 1; }\"];\n+    N30[label=\"expr while z > 0 { z -= 1; }\"];\n+    N31[label=\"expr z\"];\n+    N32[label=\"expr 0\"];\n+    N33[label=\"expr z > 0\"];\n     N34[label=\"expr 1\"];\n     N35[label=\"expr z\"];\n     N36[label=\"expr z -= 1\"];\n@@ -63,35 +63,35 @@ digraph block {\n     N8 -> N9;\n     N9 -> N10;\n     N10 -> N11;\n-    N11 -> N12;\n-    N12 -> N13;\n+    N11 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n-    N14 -> N16;\n+    N15 -> N12;\n+    N15 -> N16;\n     N16 -> N17;\n     N17 -> N18;\n     N18 -> N19;\n     N19 -> N20;\n-    N20 -> N21;\n-    N21 -> N22;\n+    N20 -> N22;\n     N22 -> N23;\n     N23 -> N24;\n-    N23 -> N25;\n+    N24 -> N21;\n+    N24 -> N25;\n     N25 -> N26;\n     N26 -> N27;\n     N27 -> N28;\n     N28 -> N29;\n-    N29 -> N30;\n-    N30 -> N31;\n+    N29 -> N31;\n     N31 -> N32;\n     N32 -> N33;\n-    N32 -> N34;\n+    N33 -> N30;\n+    N33 -> N34;\n     N34 -> N35;\n     N35 -> N36;\n     N36 -> N37;\n     N37 -> N38;\n     N38 -> N29;\n-    N33 -> N39;\n+    N30 -> N39;\n     N39 -> N40;\n     N40 -> N41;\n     N41 -> N42;\n@@ -105,9 +105,9 @@ digraph block {\n     N48 -> N49;\n     N49 -> N50;\n     N50 -> N20;\n-    N24 -> N51;\n+    N21 -> N51;\n     N51 -> N11;\n-    N15 -> N52;\n+    N12 -> N52;\n     N52 -> N53;\n     N53 -> N1;\n }"}, {"sha": "4906a8e71d7a4fad61a4d5b57bbedb7e4d5f7500", "filename": "src/test/run-pass/loop-break-value.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Ftest%2Frun-pass%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9079bae4250b2f9e99162d3ea14a1a90201a81/src%2Ftest%2Frun-pass%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-break-value.rs?ref=ad9079bae4250b2f9e99162d3ea14a1a90201a81", "patch": "@@ -124,10 +124,18 @@ pub fn main() {\n     assert_eq!(nested_break_value, \"hello\");\n \n     let break_from_while_cond = loop {\n-        while break {\n+        'inner_loop: while break 'inner_loop {\n             panic!();\n         }\n         break 123;\n     };\n     assert_eq!(break_from_while_cond, 123);\n+\n+    let break_from_while_to_outer = 'outer_loop: loop {\n+        while break 'outer_loop 567 {\n+            panic!(\"from_inner\");\n+        }\n+        panic!(\"from outer\");\n+    };\n+    assert_eq!(break_from_while_to_outer, 567);\n }"}]}