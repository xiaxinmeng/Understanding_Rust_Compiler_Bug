{"sha": "70a665a005857a4a44922a4bc3eb29e80e2b941a", "node_id": "C_kwDOAAsO6NoAKDcwYTY2NWEwMDU4NTdhNGE0NDkyMmE0YmMzZWIyOWU4MGUyYjk0MWE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-26T14:02:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-26T14:02:20Z"}, "message": "Rollup merge of #107150 - Nilstrieb:thread-local-cleanups, r=cjgillot\n\n`ty::tls` cleanups\n\nPull it out into a separate file, make the conditional compilation more obvious and give the internal functions better names.\n\nPulled out of #106311\n\nr? cjgillot", "tree": {"sha": "88405592e52a9912c5c9420f8cb6b0c1b4e549f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88405592e52a9912c5c9420f8cb6b0c1b4e549f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70a665a005857a4a44922a4bc3eb29e80e2b941a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj0ofsCRBK7hj4Ov3rIwAA5s8IADeGOjJ2Dw064ZkFPH1QIHlQ\nMx7ae8ZxApYa0IE2XyzCLul0PMOamvY2tG8C/3w0DYxEiumGec53eWSSogv2QXa/\nfqcK+LVYIiCYDZojyeAi1ZdX1wBOZSqL2K7QvUBJK34mCndmimCT6MJ5TEhnzrqK\nyJ5v0TBtnW7s9+PwoOwesu46KAtWCrEi2i1PP/j48KCuT2L/9ggUF0gYPpwY6pZ4\nnT7rZ9xAgqT9z8+5pWXzAvgZpg6SAn3IM1i1hiJSU3Yfu2ppQhotz5poh+Tsuump\nlLQupSWyD5TqvvShehPf5IS+21RQi507a3Vcw6dZFhJTOcIyf+e0SDgjK4boJ5g=\n=4kqD\n-----END PGP SIGNATURE-----\n", "payload": "tree 88405592e52a9912c5c9420f8cb6b0c1b4e549f8\nparent e8c17de11d02eb25b768d6c8da342d50db864711\nparent db305d0ca8b03492877a467d061f0c65eb194b2a\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1674741740 +0100\ncommitter GitHub <noreply@github.com> 1674741740 +0100\n\nRollup merge of #107150 - Nilstrieb:thread-local-cleanups, r=cjgillot\n\n`ty::tls` cleanups\n\nPull it out into a separate file, make the conditional compilation more obvious and give the internal functions better names.\n\nPulled out of #106311\n\nr? cjgillot\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70a665a005857a4a44922a4bc3eb29e80e2b941a", "html_url": "https://github.com/rust-lang/rust/commit/70a665a005857a4a44922a4bc3eb29e80e2b941a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70a665a005857a4a44922a4bc3eb29e80e2b941a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8c17de11d02eb25b768d6c8da342d50db864711", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8c17de11d02eb25b768d6c8da342d50db864711", "html_url": "https://github.com/rust-lang/rust/commit/e8c17de11d02eb25b768d6c8da342d50db864711"}, {"sha": "db305d0ca8b03492877a467d061f0c65eb194b2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/db305d0ca8b03492877a467d061f0c65eb194b2a", "html_url": "https://github.com/rust-lang/rust/commit/db305d0ca8b03492877a467d061f0c65eb194b2a"}], "stats": {"total": 368, "additions": 190, "deletions": 178}, "files": [{"sha": "95148de251824ad0aceb5dbe48777fcbceaeddbc", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70a665a005857a4a44922a4bc3eb29e80e2b941a/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a665a005857a4a44922a4bc3eb29e80e2b941a/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=70a665a005857a4a44922a4bc3eb29e80e2b941a", "patch": "@@ -43,6 +43,7 @@\n #![feature(min_specialization)]\n #![feature(trusted_len)]\n #![feature(type_alias_impl_trait)]\n+#![feature(strict_provenance)]\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]\n #![feature(control_flow_enum)]"}, {"sha": "a60c55e8af4d2305571698677e720600568596a1", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 178, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/70a665a005857a4a44922a4bc3eb29e80e2b941a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a665a005857a4a44922a4bc3eb29e80e2b941a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=70a665a005857a4a44922a4bc3eb29e80e2b941a", "patch": "@@ -2,6 +2,8 @@\n \n #![allow(rustc::usage_of_ty_tykind)]\n \n+pub mod tls;\n+\n use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n@@ -1212,178 +1214,6 @@ CloneLiftImpls! { for<'tcx> {\n     Constness, traits::WellFormedLoc, ImplPolarity, crate::mir::ReturnConstraint,\n } }\n \n-pub mod tls {\n-    use super::{ptr_eq, GlobalCtxt, TyCtxt};\n-\n-    use crate::dep_graph::TaskDepsRef;\n-    use crate::ty::query;\n-    use rustc_data_structures::sync::{self, Lock};\n-    use rustc_errors::Diagnostic;\n-    use std::mem;\n-    use thin_vec::ThinVec;\n-\n-    #[cfg(not(parallel_compiler))]\n-    use std::cell::Cell;\n-\n-    #[cfg(parallel_compiler)]\n-    use rustc_rayon_core as rayon_core;\n-\n-    /// This is the implicit state of rustc. It contains the current\n-    /// `TyCtxt` and query. It is updated when creating a local interner or\n-    /// executing a new query. Whenever there's a `TyCtxt` value available\n-    /// you should also have access to an `ImplicitCtxt` through the functions\n-    /// in this module.\n-    #[derive(Clone)]\n-    pub struct ImplicitCtxt<'a, 'tcx> {\n-        /// The current `TyCtxt`.\n-        pub tcx: TyCtxt<'tcx>,\n-\n-        /// The current query job, if any. This is updated by `JobOwner::start` in\n-        /// `ty::query::plumbing` when executing a query.\n-        pub query: Option<query::QueryJobId>,\n-\n-        /// Where to store diagnostics for the current query job, if any.\n-        /// This is updated by `JobOwner::start` in `ty::query::plumbing` when executing a query.\n-        pub diagnostics: Option<&'a Lock<ThinVec<Diagnostic>>>,\n-\n-        /// Used to prevent queries from calling too deeply.\n-        pub query_depth: usize,\n-\n-        /// The current dep graph task. This is used to add dependencies to queries\n-        /// when executing them.\n-        pub task_deps: TaskDepsRef<'a>,\n-    }\n-\n-    impl<'a, 'tcx> ImplicitCtxt<'a, 'tcx> {\n-        pub fn new(gcx: &'tcx GlobalCtxt<'tcx>) -> Self {\n-            let tcx = TyCtxt { gcx };\n-            ImplicitCtxt {\n-                tcx,\n-                query: None,\n-                diagnostics: None,\n-                query_depth: 0,\n-                task_deps: TaskDepsRef::Ignore,\n-            }\n-        }\n-    }\n-\n-    /// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n-    /// to `value` during the call to `f`. It is restored to its previous value after.\n-    /// This is used to set the pointer to the new `ImplicitCtxt`.\n-    #[cfg(parallel_compiler)]\n-    #[inline]\n-    fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n-        rayon_core::tlv::with(value, f)\n-    }\n-\n-    /// Gets Rayon's thread-local variable, which is preserved for Rayon jobs.\n-    /// This is used to get the pointer to the current `ImplicitCtxt`.\n-    #[cfg(parallel_compiler)]\n-    #[inline]\n-    pub fn get_tlv() -> usize {\n-        rayon_core::tlv::get()\n-    }\n-\n-    #[cfg(not(parallel_compiler))]\n-    thread_local! {\n-        /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n-        static TLV: Cell<usize> = const { Cell::new(0) };\n-    }\n-\n-    /// Sets TLV to `value` during the call to `f`.\n-    /// It is restored to its previous value after.\n-    /// This is used to set the pointer to the new `ImplicitCtxt`.\n-    #[cfg(not(parallel_compiler))]\n-    #[inline]\n-    fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n-        let old = get_tlv();\n-        let _reset = rustc_data_structures::OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n-        TLV.with(|tlv| tlv.set(value));\n-        f()\n-    }\n-\n-    /// Gets the pointer to the current `ImplicitCtxt`.\n-    #[cfg(not(parallel_compiler))]\n-    #[inline]\n-    fn get_tlv() -> usize {\n-        TLV.with(|tlv| tlv.get())\n-    }\n-\n-    /// Sets `context` as the new current `ImplicitCtxt` for the duration of the function `f`.\n-    #[inline]\n-    pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) -> R\n-    where\n-        F: FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n-    {\n-        set_tlv(context as *const _ as usize, || f(&context))\n-    }\n-\n-    /// Allows access to the current `ImplicitCtxt` in a closure if one is available.\n-    #[inline]\n-    pub fn with_context_opt<F, R>(f: F) -> R\n-    where\n-        F: for<'a, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'tcx>>) -> R,\n-    {\n-        let context = get_tlv();\n-        if context == 0 {\n-            f(None)\n-        } else {\n-            // We could get an `ImplicitCtxt` pointer from another thread.\n-            // Ensure that `ImplicitCtxt` is `Sync`.\n-            sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n-\n-            unsafe { f(Some(&*(context as *const ImplicitCtxt<'_, '_>))) }\n-        }\n-    }\n-\n-    /// Allows access to the current `ImplicitCtxt`.\n-    /// Panics if there is no `ImplicitCtxt` available.\n-    #[inline]\n-    pub fn with_context<F, R>(f: F) -> R\n-    where\n-        F: for<'a, 'tcx> FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n-    {\n-        with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n-    }\n-\n-    /// Allows access to the current `ImplicitCtxt` whose tcx field is the same as the tcx argument\n-    /// passed in. This means the closure is given an `ImplicitCtxt` with the same `'tcx` lifetime\n-    /// as the `TyCtxt` passed in.\n-    /// This will panic if you pass it a `TyCtxt` which is different from the current\n-    /// `ImplicitCtxt`'s `tcx` field.\n-    #[inline]\n-    pub fn with_related_context<'tcx, F, R>(tcx: TyCtxt<'tcx>, f: F) -> R\n-    where\n-        F: FnOnce(&ImplicitCtxt<'_, 'tcx>) -> R,\n-    {\n-        with_context(|context| unsafe {\n-            assert!(ptr_eq(context.tcx.gcx, tcx.gcx));\n-            let context: &ImplicitCtxt<'_, '_> = mem::transmute(context);\n-            f(context)\n-        })\n-    }\n-\n-    /// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n-    /// Panics if there is no `ImplicitCtxt` available.\n-    #[inline]\n-    pub fn with<F, R>(f: F) -> R\n-    where\n-        F: for<'tcx> FnOnce(TyCtxt<'tcx>) -> R,\n-    {\n-        with_context(|context| f(context.tcx))\n-    }\n-\n-    /// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n-    /// The closure is passed None if there is no `ImplicitCtxt` available.\n-    #[inline]\n-    pub fn with_opt<F, R>(f: F) -> R\n-    where\n-        F: for<'tcx> FnOnce(Option<TyCtxt<'tcx>>) -> R,\n-    {\n-        with_context_opt(|opt_context| f(opt_context.map(|context| context.tcx)))\n-    }\n-}\n-\n macro_rules! sty_debug_print {\n     ($fmt: expr, $ctxt: expr, $($variant: ident),*) => {{\n         // Curious inner module to allow variant names to be used as\n@@ -2416,12 +2246,6 @@ pub struct DeducedParamAttrs {\n     pub read_only: bool,\n }\n \n-// We are comparing types with different invariant lifetimes, so `ptr::eq`\n-// won't work for us.\n-fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n-    t as *const () == u as *const ()\n-}\n-\n pub fn provide(providers: &mut ty::query::Providers) {\n     providers.module_reexports =\n         |tcx, id| tcx.resolutions(()).reexport_map.get(&id).map(|v| &v[..]);"}, {"sha": "71b025dc1be4b6523d343cdc3269508141a92560", "filename": "compiler/rustc_middle/src/ty/context/tls.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/70a665a005857a4a44922a4bc3eb29e80e2b941a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a665a005857a4a44922a4bc3eb29e80e2b941a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs?ref=70a665a005857a4a44922a4bc3eb29e80e2b941a", "patch": "@@ -0,0 +1,187 @@\n+use super::{GlobalCtxt, TyCtxt};\n+\n+use crate::dep_graph::TaskDepsRef;\n+use crate::ty::query;\n+use rustc_data_structures::sync::{self, Lock};\n+use rustc_errors::Diagnostic;\n+use std::mem;\n+use std::ptr;\n+use thin_vec::ThinVec;\n+\n+/// This is the implicit state of rustc. It contains the current\n+/// `TyCtxt` and query. It is updated when creating a local interner or\n+/// executing a new query. Whenever there's a `TyCtxt` value available\n+/// you should also have access to an `ImplicitCtxt` through the functions\n+/// in this module.\n+#[derive(Clone)]\n+pub struct ImplicitCtxt<'a, 'tcx> {\n+    /// The current `TyCtxt`.\n+    pub tcx: TyCtxt<'tcx>,\n+\n+    /// The current query job, if any. This is updated by `JobOwner::start` in\n+    /// `ty::query::plumbing` when executing a query.\n+    pub query: Option<query::QueryJobId>,\n+\n+    /// Where to store diagnostics for the current query job, if any.\n+    /// This is updated by `JobOwner::start` in `ty::query::plumbing` when executing a query.\n+    pub diagnostics: Option<&'a Lock<ThinVec<Diagnostic>>>,\n+\n+    /// Used to prevent queries from calling too deeply.\n+    pub query_depth: usize,\n+\n+    /// The current dep graph task. This is used to add dependencies to queries\n+    /// when executing them.\n+    pub task_deps: TaskDepsRef<'a>,\n+}\n+\n+impl<'a, 'tcx> ImplicitCtxt<'a, 'tcx> {\n+    pub fn new(gcx: &'tcx GlobalCtxt<'tcx>) -> Self {\n+        let tcx = TyCtxt { gcx };\n+        ImplicitCtxt {\n+            tcx,\n+            query: None,\n+            diagnostics: None,\n+            query_depth: 0,\n+            task_deps: TaskDepsRef::Ignore,\n+        }\n+    }\n+}\n+\n+#[cfg(parallel_compiler)]\n+mod tlv {\n+    use rustc_rayon_core as rayon_core;\n+    use std::ptr;\n+\n+    /// Gets Rayon's thread-local variable, which is preserved for Rayon jobs.\n+    /// This is used to get the pointer to the current `ImplicitCtxt`.\n+    #[inline]\n+    pub(super) fn get_tlv() -> *const () {\n+        ptr::from_exposed_addr(rayon_core::tlv::get())\n+    }\n+\n+    /// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n+    /// to `value` during the call to `f`. It is restored to its previous value after.\n+    /// This is used to set the pointer to the new `ImplicitCtxt`.\n+    #[inline]\n+    pub(super) fn with_tlv<F: FnOnce() -> R, R>(value: *const (), f: F) -> R {\n+        rayon_core::tlv::with(value.expose_addr(), f)\n+    }\n+}\n+\n+#[cfg(not(parallel_compiler))]\n+mod tlv {\n+    use std::cell::Cell;\n+    use std::ptr;\n+\n+    thread_local! {\n+        /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n+        static TLV: Cell<*const ()> = const { Cell::new(ptr::null()) };\n+    }\n+\n+    /// Gets the pointer to the current `ImplicitCtxt`.\n+    #[inline]\n+    pub(super) fn get_tlv() -> *const () {\n+        TLV.with(|tlv| tlv.get())\n+    }\n+\n+    /// Sets TLV to `value` during the call to `f`.\n+    /// It is restored to its previous value after.\n+    /// This is used to set the pointer to the new `ImplicitCtxt`.\n+    #[inline]\n+    pub(super) fn with_tlv<F: FnOnce() -> R, R>(value: *const (), f: F) -> R {\n+        let old = get_tlv();\n+        let _reset = rustc_data_structures::OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n+        TLV.with(|tlv| tlv.set(value));\n+        f()\n+    }\n+}\n+\n+#[inline]\n+fn erase(context: &ImplicitCtxt<'_, '_>) -> *const () {\n+    context as *const _ as *const ()\n+}\n+\n+#[inline]\n+unsafe fn downcast<'a, 'tcx>(context: *const ()) -> &'a ImplicitCtxt<'a, 'tcx> {\n+    &*(context as *const ImplicitCtxt<'a, 'tcx>)\n+}\n+\n+/// Sets `context` as the new current `ImplicitCtxt` for the duration of the function `f`.\n+#[inline]\n+pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) -> R\n+where\n+    F: FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n+{\n+    tlv::with_tlv(erase(context), || f(&context))\n+}\n+\n+/// Allows access to the current `ImplicitCtxt` in a closure if one is available.\n+#[inline]\n+pub fn with_context_opt<F, R>(f: F) -> R\n+where\n+    F: for<'a, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'tcx>>) -> R,\n+{\n+    let context = tlv::get_tlv();\n+    if context.is_null() {\n+        f(None)\n+    } else {\n+        // We could get an `ImplicitCtxt` pointer from another thread.\n+        // Ensure that `ImplicitCtxt` is `Sync`.\n+        sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n+\n+        unsafe { f(Some(downcast(context))) }\n+    }\n+}\n+\n+/// Allows access to the current `ImplicitCtxt`.\n+/// Panics if there is no `ImplicitCtxt` available.\n+#[inline]\n+pub fn with_context<F, R>(f: F) -> R\n+where\n+    F: for<'a, 'tcx> FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n+{\n+    with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n+}\n+\n+/// Allows access to the current `ImplicitCtxt` whose tcx field is the same as the tcx argument\n+/// passed in. This means the closure is given an `ImplicitCtxt` with the same `'tcx` lifetime\n+/// as the `TyCtxt` passed in.\n+/// This will panic if you pass it a `TyCtxt` which is different from the current\n+/// `ImplicitCtxt`'s `tcx` field.\n+#[inline]\n+pub fn with_related_context<'tcx, F, R>(tcx: TyCtxt<'tcx>, f: F) -> R\n+where\n+    F: FnOnce(&ImplicitCtxt<'_, 'tcx>) -> R,\n+{\n+    with_context(|context| {\n+        // The two gcx have different invariant lifetimes, so we need to erase them for the comparison.\n+        assert!(ptr::eq(\n+            context.tcx.gcx as *const _ as *const (),\n+            tcx.gcx as *const _ as *const ()\n+        ));\n+\n+        let context: &ImplicitCtxt<'_, '_> = unsafe { mem::transmute(context) };\n+\n+        f(context)\n+    })\n+}\n+\n+/// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n+/// Panics if there is no `ImplicitCtxt` available.\n+#[inline]\n+pub fn with<F, R>(f: F) -> R\n+where\n+    F: for<'tcx> FnOnce(TyCtxt<'tcx>) -> R,\n+{\n+    with_context(|context| f(context.tcx))\n+}\n+\n+/// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n+/// The closure is passed None if there is no `ImplicitCtxt` available.\n+#[inline]\n+pub fn with_opt<F, R>(f: F) -> R\n+where\n+    F: for<'tcx> FnOnce(Option<TyCtxt<'tcx>>) -> R,\n+{\n+    with_context_opt(|opt_context| f(opt_context.map(|context| context.tcx)))\n+}"}]}