{"sha": "b251a30819bcf97703cf98a7013aeafba1bf384a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNTFhMzA4MTliY2Y5NzcwM2NmOThhNzAxM2FlYWZiYTFiZjM4NGE=", "commit": {"author": {"name": "Anatol Ulrich", "email": "anatol.ulrich@ferrous-systems.com", "date": "2021-09-14T02:01:21Z"}, "committer": {"name": "Anatol Ulrich", "email": "anatol.ulrich@ferrous-systems.com", "date": "2021-09-15T16:04:45Z"}, "message": "# This is a combination of 3 commits.\n# This is the 1st commit message:\n\nadd multi-token mappings for hover\n\n# The commit message #2 will be skipped:\n\n# make fallback an Option instead of vec\n\n# The commit message #3 will be skipped:\n\n# fix indentation", "tree": {"sha": "92e8f0a0004e691c5aa8bfe28714b25a50616f71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92e8f0a0004e691c5aa8bfe28714b25a50616f71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b251a30819bcf97703cf98a7013aeafba1bf384a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b251a30819bcf97703cf98a7013aeafba1bf384a", "html_url": "https://github.com/rust-lang/rust/commit/b251a30819bcf97703cf98a7013aeafba1bf384a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b251a30819bcf97703cf98a7013aeafba1bf384a/comments", "author": null, "committer": null, "parents": [{"sha": "bcf0072bb4f6eb05371d4ce920415b4b0910de9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcf0072bb4f6eb05371d4ce920415b4b0910de9c", "html_url": "https://github.com/rust-lang/rust/commit/bcf0072bb4f6eb05371d4ce920415b4b0910de9c"}], "stats": {"total": 196, "additions": 177, "deletions": 19}, "files": [{"sha": "ae53677f76bedeceea1155e67eeb6426e5ee4b00", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 177, "deletions": 19, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/b251a30819bcf97703cf98a7013aeafba1bf384a/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b251a30819bcf97703cf98a7013aeafba1bf384a/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=b251a30819bcf97703cf98a7013aeafba1bf384a", "patch": "@@ -1,3 +1,5 @@\n+use std::{collections::HashSet, ops::ControlFlow};\n+\n use either::Either;\n use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo};\n use ide_db::{\n@@ -13,7 +15,7 @@ use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n     algo, ast, display::fn_as_proc_macro_label, match_ast, AstNode, Direction, SyntaxKind::*,\n-    SyntaxNode, SyntaxToken, T,\n+    SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n };\n \n use crate::{\n@@ -111,16 +113,68 @@ pub(crate) fn hover(\n         kind if kind.is_trivia() => 0,\n         _ => 1,\n     })?;\n-    let token = sema.descend_into_macros(token);\n-    let node = token.parent()?;\n+\n+    let mut seen = HashSet::default();\n+\n+    let mut fallback = None;\n+    sema.descend_into_macros_many(token.clone())\n+        .iter()\n+        .filter_map(|token| match token.parent() {\n+            Some(node) => {\n+                match find_hover_result(&sema, file_id, offset, config, token, &node, &mut seen) {\n+                    Some(res) => match res {\n+                        ControlFlow::Break(inner) => Some(inner),\n+                        ControlFlow::Continue(_) => {\n+                            if fallback.is_none() {\n+                                // FIXME we're only taking the first fallback into account that's not `None`\n+                                fallback = type_hover(&sema, config, &token);\n+                            }\n+                            None\n+                        }\n+                    },\n+                    None => None,\n+                }\n+            }\n+            None => None,\n+        })\n+        // reduce all descends into a single `RangeInfo`\n+        // that spans from the earliest start to the latest end (fishy/FIXME),\n+        // concatenates all `Markup`s with `\\n---\\n`,\n+        // and accumulates all actions into its `actions` vector.\n+        .reduce(|mut acc, RangeInfo { range, mut info }| {\n+            let start = acc.range.start().min(range.start());\n+            let end = acc.range.end().max(range.end());\n+\n+            acc.range = TextRange::new(start, end);\n+            acc.info.actions.append(&mut info.actions);\n+            acc.info.markup = Markup::from(format!(\"{}\\n---\\n{}\", acc.info.markup, info.markup));\n+            acc\n+        })\n+        .or(fallback)\n+}\n+\n+fn find_hover_result(\n+    sema: &Semantics<RootDatabase>,\n+    file_id: FileId,\n+    offset: TextSize,\n+    config: &HoverConfig,\n+    token: &SyntaxToken,\n+    node: &SyntaxNode,\n+    seen: &mut HashSet<Definition>,\n+) -> Option<ControlFlow<RangeInfo<HoverResult>>> {\n     let mut range_override = None;\n+\n+    // intra-doc links and attributes are special cased\n+    // so don't add them to the `seen` duplicate check\n+    let mut add_to_seen_definitions = true;\n+\n     let definition = match_ast! {\n         match node {\n-            ast::Name(name) => NameClass::classify(&sema, &name).map(|class| match class {\n+            ast::Name(name) => NameClass::classify(sema, &name).map(|class| match class {\n                 NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n                 NameClass::PatFieldShorthand { local_def, field_ref: _ } => Definition::Local(local_def),\n             }),\n-            ast::NameRef(name_ref) => NameRefClass::classify(&sema, &name_ref).map(|class| match class {\n+            ast::NameRef(name_ref) => NameRefClass::classify(sema, &name_ref).map(|class| match class {\n                 NameRefClass::Definition(def) => def,\n                 NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n                     Definition::Field(field_ref)\n@@ -137,25 +191,37 @@ pub(crate) fn hover(\n             ),\n             _ => {\n                 // intra-doc links\n+                // FIXME: move comment + attribute special cases somewhere else to simplify control flow,\n+                // hopefully simplifying the return type of this function in the process\n+                // (the `Break`/`Continue` distinction is needed to decide whether to use fallback hovers)\n+                //\n+                // FIXME: hovering the intra doc link to `Foo` not working:\n+                //\n+                // #[identity]\n+                // trait Foo {\n+                //    /// [`Foo`]\n+                // fn foo() {}\n                 if token.kind() == COMMENT {\n+                    add_to_seen_definitions = false;\n                     cov_mark::hit!(no_highlight_on_comment_hover);\n-                    let (attributes, def) = doc_attributes(&sema, &node)?;\n-                    let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n+                    let (attributes, def) = doc_attributes(sema, node)?;\n+                    let (docs, doc_mapping) = attributes.docs_with_rangemap(sema.db)?;\n                     let (idl_range, link, ns) =\n                         extract_definitions_from_docs(&docs).into_iter().find_map(|(range, link, ns)| {\n                             let mapped = doc_mapping.map(range)?;\n                             (mapped.file_id == file_id.into() && mapped.value.contains(offset)).then(||(mapped.value, link, ns))\n                         })?;\n                     range_override = Some(idl_range);\n-                    Some(match resolve_doc_path_for_def(db,def, &link,ns)? {\n+                    Some(match resolve_doc_path_for_def(sema.db,def, &link,ns)? {\n                         Either::Left(it) => Definition::ModuleDef(it),\n                         Either::Right(it) => Definition::Macro(it),\n                     })\n                 // attributes, require special machinery as they are mere ident tokens\n                 } else if let Some(attr) = token.ancestors().find_map(ast::Attr::cast) {\n+                    add_to_seen_definitions = false;\n                     // lints\n-                    if let res@Some(_) = try_hover_for_lint(&attr, &token) {\n-                        return res;\n+                    if let Some(res) = try_hover_for_lint(&attr, &token) {\n+                        return Some(ControlFlow::Break(res));\n                     // derives\n                     } else {\n                         range_override = Some(token.text_range());\n@@ -169,42 +235,57 @@ pub(crate) fn hover(\n     };\n \n     if let Some(definition) = definition {\n+        // skip duplicates\n+        if seen.contains(&definition) {\n+            return None;\n+        }\n+        if add_to_seen_definitions {\n+            seen.insert(definition);\n+        }\n         let famous_defs = match &definition {\n             Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n                 Some(FamousDefs(&sema, sema.scope(&node).krate()))\n             }\n             _ => None,\n         };\n-        if let Some(markup) = hover_for_definition(db, definition, famous_defs.as_ref(), config) {\n+        if let Some(markup) =\n+            hover_for_definition(sema.db, definition, famous_defs.as_ref(), config)\n+        {\n             let mut res = HoverResult::default();\n             res.markup = process_markup(sema.db, definition, &markup, config);\n-            if let Some(action) = show_implementations_action(db, definition) {\n+            if let Some(action) = show_implementations_action(sema.db, definition) {\n                 res.actions.push(action);\n             }\n \n-            if let Some(action) = show_fn_references_action(db, definition) {\n+            if let Some(action) = show_fn_references_action(sema.db, definition) {\n                 res.actions.push(action);\n             }\n \n             if let Some(action) = runnable_action(&sema, definition, file_id) {\n                 res.actions.push(action);\n             }\n \n-            if let Some(action) = goto_type_action_for_def(db, definition) {\n+            if let Some(action) = goto_type_action_for_def(sema.db, definition) {\n                 res.actions.push(action);\n             }\n \n             let range = range_override.unwrap_or_else(|| sema.original_range(&node).range);\n-            return Some(RangeInfo::new(range, res));\n+            return Some(ControlFlow::Break(RangeInfo::new(range, res)));\n         }\n     }\n \n-    if let res @ Some(_) = hover_for_keyword(&sema, config, &token) {\n-        return res;\n+    if let Some(res) = hover_for_keyword(&sema, config, &token) {\n+        return Some(ControlFlow::Break(res));\n     }\n \n-    // No definition below cursor, fall back to showing type hovers.\n+    Some(ControlFlow::Continue(()))\n+}\n \n+fn type_hover(\n+    sema: &Semantics<RootDatabase>,\n+    config: &HoverConfig,\n+    token: &SyntaxToken,\n+) -> Option<RangeInfo<HoverResult>> {\n     let node = token\n         .ancestors()\n         .take_while(|it| !ast::Item::can_cast(it.kind()))\n@@ -214,7 +295,7 @@ pub(crate) fn hover(\n         match node {\n             ast::Expr(it) => Either::Left(it),\n             ast::Pat(it) => Either::Right(it),\n-            // If this node is a MACRO_CALL, it means that `descend_into_macros` failed to resolve.\n+            // If this node is a MACRO_CALL, it means that `descend_into_macros_many` failed to resolve.\n             // (e.g expanding a builtin macro). So we give up here.\n             ast::MacroCall(_it) => return None,\n             _ => return None,\n@@ -223,6 +304,7 @@ pub(crate) fn hover(\n \n     let res = hover_type_info(&sema, config, &expr_or_pat)?;\n     let range = sema.original_range(&node).range;\n+\n     Some(RangeInfo::new(range, res))\n }\n \n@@ -845,6 +927,82 @@ mod tests {\n         assert!(hover.is_none());\n     }\n \n+    #[test]\n+    fn hover_descend_macros_avoids_duplicates() {\n+        check(\n+            r#\"\n+macro_rules! dupe_use {\n+    ($local:ident) => {\n+        {\n+            $local;\n+            $local;\n+        }\n+    }\n+}\n+fn foo() {\n+    let local = 0;\n+    dupe_use!(local$0);\n+}\n+\"#,\n+            expect![[r#\"\n+            *local*\n+\n+            ```rust\n+            let local: i32\n+            ```\n+        \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn hover_shows_all_macro_descends() {\n+        check(\n+            r#\"\n+macro_rules! m {\n+    ($name:ident) => {\n+        /// Outer\n+        fn $name() {}\n+\n+        mod module {\n+            /// Inner\n+            fn $name() {}\n+        }\n+    };\n+}\n+\n+m!(ab$0c);\n+            \"#,\n+            expect![[r#\"\n+            *abc*\n+\n+            ```rust\n+            test::module\n+            ```\n+\n+            ```rust\n+            fn abc()\n+            ```\n+\n+            ---\n+\n+            Inner\n+            ---\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            fn abc()\n+            ```\n+\n+            ---\n+\n+            Outer\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn hover_shows_type_of_an_expression() {\n         check("}]}