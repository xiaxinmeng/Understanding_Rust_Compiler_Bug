{"sha": "3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMDFjNzQxNmEwOTFkYzI5ZGQwZDM0OWZhZmI2Y2M1ZDNjNGQ5N2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-17T11:55:54Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-07-02T16:25:16Z"}, "message": "just create a binary search slice helper fn", "tree": {"sha": "d3c2027d4c37e5b4e6b41a36abd2e87badc027da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3c2027d4c37e5b4e6b41a36abd2e87badc027da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c", "html_url": "https://github.com/rust-lang/rust/commit/3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89a205bf4486115baeb3710ba8a4652c16666511", "url": "https://api.github.com/repos/rust-lang/rust/commits/89a205bf4486115baeb3710ba8a4652c16666511", "html_url": "https://github.com/rust-lang/rust/commit/89a205bf4486115baeb3710ba8a4652c16666511"}], "stats": {"total": 186, "additions": 72, "deletions": 114}, "files": [{"sha": "32aa1cb6b1d36575d77eed95d6999f57c7d10ab9", "filename": "src/librustc_data_structures/binary_search_util/mod.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs?ref=3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c", "patch": "@@ -0,0 +1,49 @@\n+#[cfg(test)]\n+mod test;\n+\n+/// Uses a sorted slice `data: &[E]` as a kind of \"multi-map\". The\n+/// `key_fn` extracts a key of type `K` from the data, and this\n+/// function finds the range of elements that match the key. `data`\n+/// must have been sorted as if by a call to `sort_by_key` for this to\n+/// work.\n+pub fn binary_search_slice<E, K>(data: &'d [E], key_fn: impl Fn(&E) -> K, key: &K) -> &'d [E]\n+where\n+    K: Ord,\n+{\n+    let mid = match data.binary_search_by_key(key, &key_fn) {\n+        Ok(mid) => mid,\n+        Err(_) => return &[],\n+    };\n+\n+    // We get back *some* element with the given key -- so\n+    // search backwards to find the *first* one.\n+    //\n+    // (It'd be more efficient to use a \"galloping\" search\n+    // here, but it's not really worth it for small-ish\n+    // amounts of data.)\n+    let mut start = mid;\n+    while start > 0 {\n+        if key_fn(&data[start - 1]) == *key {\n+            start -= 1;\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    // Now search forward to find the *last* one.\n+    //\n+    // (It'd be more efficient to use a \"galloping\" search\n+    // here, but it's not really worth it for small-ish\n+    // amounts of data.)\n+    let mut end = mid + 1;\n+    let max = data.len();\n+    while end < max {\n+        if key_fn(&data[end]) == *key {\n+            end += 1;\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    &data[start..end]\n+}"}, {"sha": "a6361d912656a3fc6fa92692e6ffce37f967174e", "filename": "src/librustc_data_structures/binary_search_util/test.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftest.rs?ref=3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c", "patch": "@@ -0,0 +1,22 @@\n+use super::*;\n+\n+type Element = (usize, &'static str);\n+\n+fn test_map() -> Vec<Element> {\n+    let mut data = vec![(3, \"three-a\"), (0, \"zero\"), (3, \"three-b\"), (22, \"twenty-two\")];\n+    data.sort_by_key(get_key)\n+}\n+\n+fn get_key(data: &Element) -> usize {\n+    data.0\n+}\n+\n+#[test]\n+fn binary_search_slice() {\n+    let map = test_map();\n+    assert_eq!(binary_search_slice(&map, get_key, &0), &[(0, \"zero\")]);\n+    assert_eq!(binary_search_slice(&map, get_key, &1), &[]);\n+    assert_eq!(binary_search_slice(&map, get_key, &3), &[(3, \"three-a\"), (3, \"three-b\")]);\n+    assert_eq!(binary_search_slice(&map, get_key, &22), &[(22, \"twenty-two\")]);\n+    assert_eq!(binary_search_slice(&map, get_key, &23), &[]);\n+}"}, {"sha": "98c809f7e25958d7ae98272bf52e0f44940766e6", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=3e01c7416a091dc29dd0d349fafb6cc5d3c4d97c", "patch": "@@ -72,6 +72,7 @@ macro_rules! unlikely {\n pub mod macros;\n pub mod svh;\n pub mod base_n;\n+pub mod binary_search_util;\n pub mod bit_set;\n pub mod box_region;\n pub mod const_cstr;\n@@ -95,7 +96,6 @@ pub mod tiny_list;\n pub mod thin_vec;\n pub mod transitive_relation;\n pub use ena::unify;\n-pub mod vec_map;\n pub mod vec_linked_list;\n pub mod work_queue;\n pub mod fingerprint;"}, {"sha": "9d9e54bfc7b1267886ad07a8f68f923f29efb39c", "filename": "src/librustc_data_structures/vec_map/mod.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/89a205bf4486115baeb3710ba8a4652c16666511/src%2Flibrustc_data_structures%2Fvec_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a205bf4486115baeb3710ba8a4652c16666511/src%2Flibrustc_data_structures%2Fvec_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fvec_map%2Fmod.rs?ref=89a205bf4486115baeb3710ba8a4652c16666511", "patch": "@@ -1,85 +0,0 @@\n-#[cfg(test)]\n-mod test;\n-\n-/// A (multi-)map based on a sorted vector. This uses binary search to\n-/// find the starting index for a given element and can be a fairly\n-/// efficient data structure, particularly for small-ish sets of data.\n-///\n-/// To use, you supply the starting vector along with a \"key fn\" that\n-/// extracts the key from each element.\n-pub struct VecMap<E, KeyFn> {\n-    data: Vec<E>,\n-    key_fn: KeyFn,\n-}\n-\n-impl<E, K, KeyFn> VecMap<E, KeyFn>\n-where\n-    KeyFn: Fn(&E) -> K,\n-    K: Ord + std::fmt::Debug,\n-{\n-    pub fn new(\n-        mut data: Vec<E>,\n-        key_fn: KeyFn,\n-    ) -> Self {\n-        data.sort_by_key(&key_fn);\n-        Self { data, key_fn }\n-    }\n-\n-    /// Extract the first index for the given key using binary search.\n-    /// Returns `None` if there is no such index.\n-    fn get_range(&self, key: &K) -> Option<(usize, usize)> {\n-        match self.data.binary_search_by_key(key, &self.key_fn) {\n-            Ok(mid) => {\n-                // We get back *some* element with the given key -- so\n-                // search backwards to find the *first* one.\n-                //\n-                // (It'd be more efficient to use a \"galloping\" search\n-                // here, but it's not really worth it for small-ish\n-                // amounts of data.)\n-                let mut start = mid;\n-                while start > 0 {\n-                    if (self.key_fn)(&self.data[start - 1]) == *key {\n-                        start -= 1;\n-                    } else {\n-                        break;\n-                    }\n-                }\n-\n-                // Now search forward to find the *last* one.\n-                //\n-                // (It'd be more efficient to use a \"galloping\" search\n-                // here, but it's not really worth it for small-ish\n-                // amounts of data.)\n-                let mut end = mid + 1;\n-                let max = self.data.len();\n-                while end < max {\n-                    if (self.key_fn)(&self.data[end]) == *key {\n-                        end += 1;\n-                    } else {\n-                        break;\n-                    }\n-                }\n-\n-                Some((start, end))\n-            }\n-            Err(_) => None,\n-        }\n-    }\n-\n-    /// Gets the (first) value associated with a given key.\n-    pub fn get_first(&self, key: &K) -> Option<&E> {\n-        let (start, _) = self.get_range(key)?;\n-        Some(&self.data[start])\n-    }\n-\n-    /// Gets a slice of values associated with the given key.\n-    pub fn get_all(&self, key: &K) -> &[E] {\n-        let (start, end) = self.get_range(key).unwrap_or((0, 0));\n-        &self.data[start..end]\n-    }\n-\n-    /// Gets a slice of values associated with the given key.\n-    pub fn get_iter<'k>(&'k self, key: &'k K) -> impl Iterator<Item = &'k E> {\n-        self.get_all(key).iter()\n-    }\n-}"}, {"sha": "9e4f581a8cf4a001ede5e7763ad5192002df411d", "filename": "src/librustc_data_structures/vec_map/test.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/89a205bf4486115baeb3710ba8a4652c16666511/src%2Flibrustc_data_structures%2Fvec_map%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a205bf4486115baeb3710ba8a4652c16666511/src%2Flibrustc_data_structures%2Fvec_map%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fvec_map%2Ftest.rs?ref=89a205bf4486115baeb3710ba8a4652c16666511", "patch": "@@ -1,28 +0,0 @@\n-use super::*;\n-\n-type Element = (usize, &'static str);\n-\n-fn test_map() -> VecMap<Element, impl Fn(&Element) -> usize> {\n-    let data = vec![(3, \"three-a\"), (0, \"zero\"), (3, \"three-b\"), (22, \"twenty-two\")];\n-    VecMap::new(data, |&(key, _)| key)\n-}\n-\n-#[test]\n-fn get_first() {\n-    let map = test_map();\n-    assert_eq!(map.get_first(&0), Some(&(0, \"zero\")));\n-    assert_eq!(map.get_first(&1), None);\n-    assert_eq!(map.get_first(&3), Some(&(3, \"three-a\")));\n-    assert_eq!(map.get_first(&22), Some(&(22, \"twenty-two\")));\n-    assert_eq!(map.get_first(&23), None);\n-}\n-\n-#[test]\n-fn get_all() {\n-    let map = test_map();\n-    assert_eq!(map.get_all(&0), &[(0, \"zero\")]);\n-    assert_eq!(map.get_all(&1), &[]);\n-    assert_eq!(map.get_all(&3), &[(3, \"three-a\"), (3, \"three-b\")]);\n-    assert_eq!(map.get_all(&22), &[(22, \"twenty-two\")]);\n-    assert_eq!(map.get_all(&23), &[]);\n-}"}]}