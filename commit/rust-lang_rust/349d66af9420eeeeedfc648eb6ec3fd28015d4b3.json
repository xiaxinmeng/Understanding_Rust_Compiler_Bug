{"sha": "349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0OWQ2NmFmOTQyMGVlZWVlZGZjNjQ4ZWI2ZWMzZmQyODAxNWQ0YjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-16T06:36:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-16T06:36:58Z"}, "message": "auto merge of #13532 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "9789ea9a2b13b61b570bd896fe203a36bc08103c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9789ea9a2b13b61b570bd896fe203a36bc08103c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "html_url": "https://github.com/rust-lang/rust/commit/349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74bd2338eb25d0d165458a09d7aab3d2ecb98c48", "url": "https://api.github.com/repos/rust-lang/rust/commits/74bd2338eb25d0d165458a09d7aab3d2ecb98c48", "html_url": "https://github.com/rust-lang/rust/commit/74bd2338eb25d0d165458a09d7aab3d2ecb98c48"}, {"sha": "c18c9284b352f3605553343cd78c7a8eb75b5cd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c18c9284b352f3605553343cd78c7a8eb75b5cd2", "html_url": "https://github.com/rust-lang/rust/commit/c18c9284b352f3605553343cd78c7a8eb75b5cd2"}], "stats": {"total": 1001, "additions": 567, "deletions": 434}, "files": [{"sha": "41ca56f2aba42bb77904627dbc04a27e9ba4cf88", "filename": "man/rustc.1", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -182,8 +182,7 @@ rustdoc\n See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues.\n \n .SH \"AUTHOR\"\n-See \\fBAUTHORS.txt\\fR in the rust source distribution. Graydon Hoare\n-<\\fIgraydon@mozilla.com\\fR> is the project leader.\n+See \\fBAUTHORS.txt\\fR in the Rust source distribution.\n \n .SH \"COPYRIGHT\"\n This work is dual-licensed under Apache 2.0 and MIT terms.  See \\fBCOPYRIGHT\\fR"}, {"sha": "04eab3e382cd4fc133e25ab6424bfc947c43e9e1", "filename": "man/rustdoc.1", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/man%2Frustdoc.1", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/man%2Frustdoc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustdoc.1?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -90,8 +90,7 @@ rustc\n See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues.\n \n .SH \"AUTHOR\"\n-See \\fBAUTHORS.txt\\fR in the rust source distribution. Graydon Hoare\n-<\\fIgraydon@mozilla.com\\fR> is the project leader.\n+See \\fBAUTHORS.txt\\fR in the Rust source distribution.\n \n .SH \"COPYRIGHT\"\n This work is dual-licensed under Apache 2.0 and MIT terms.  See \\fBCOPYRIGHT\\fR"}, {"sha": "b14c6f279efee07bf0b28748d4e9c46645e14434", "filename": "mk/dist.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -118,7 +118,7 @@ PKG_EXE = dist/$(PKG_NAME)-install.exe\n %.ico: $(S)src/etc/pkg/%.ico\n \tcp $< $@\n \n-$(PKG_EXE): rust.iss modpath.iss LICENSE.txt rust-logo.ico \\\n+$(PKG_EXE): rust.iss modpath.iss upgrade.iss LICENSE.txt rust-logo.ico \\\n             $(CSREQ3_T_$(CFG_BUILD)_H_$(CFG_BUILD)) \\\n             dist-prepare-win\n \t$(CFG_PYTHON) $(S)src/etc/copy-runtime-deps.py tmp/dist/win/bin"}, {"sha": "096887056bf2a31f38aa30b106b393ea5279bb0e", "filename": "mk/prepare.mk", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/mk%2Fprepare.mk", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/mk%2Fprepare.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fprepare.mk?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -20,13 +20,7 @@\n #   PREPARE_TARGETS - the target triples, space separated\n #   PREPARE_DEST_DIR - the directory to put the image\n \n-\n-# On windows we install from stage3, but on unix only stage2\n-ifdef CFG_WINDOWSY_$(CFG_BUILD)\n-PREPARE_STAGE=3\n-else\n PREPARE_STAGE=2\n-endif\n \n DEFAULT_PREPARE_DIR_CMD = umask 022 && mkdir -p\n DEFAULT_PREPARE_BIN_CMD = install -m755"}, {"sha": "6f3982d94df28194439a336736d406cf761f77aa", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -27,7 +27,7 @@ Some examples that demonstrate different aspects of the language:\n \n You may also be interested in browsing [GitHub's Rust][github-rust] page.\n \n-[github-rust]: https://github.com/languages/Rust\n+[github-rust]: https://github.com/trending?l=rust\n \n ## Does it run on Windows?\n \n@@ -141,8 +141,14 @@ export RUST_LOG=hello\n ./hello\n ```\n \n-**Long answer** RUST_LOG takes a 'logging spec' that consists of a comma-separated list of paths, where a path consists of the crate name and sequence of module names, each separated by double-colons. For standalone .rs files the crate is implicitly named after the source file, so in the above example we were setting RUST_LOG to the name of the hello crate. Multiple paths can be combined to control the exact logging you want to see. For example, when debugging linking in the compiler you might set `RUST_LOG=rustc::metadata::creader,rustc::util::filesearch,rustc::back::rpath`\n-\n-If you aren't sure which paths you need, try setting RUST_LOG to `::help` and running your program. This will print a list of paths available for logging. For a full description see [the language reference][1].\n+**Long answer** RUST_LOG takes a 'logging spec' that consists of a\n+comma-separated list of paths, where a path consists of the crate name and\n+sequence of module names, each separated by double-colons. For standalone .rs\n+files the crate is implicitly named after the source file, so in the above\n+example we were setting RUST_LOG to the name of the hello crate. Multiple paths\n+can be combined to control the exact logging you want to see. For example, when\n+debugging linking in the compiler you might set\n+`RUST_LOG=rustc::metadata::creader,rustc::util::filesearch,rustc::back::rpath`\n+For a full description see [the language reference][1].\n \n [1]:http://doc.rust-lang.org/doc/master/rust.html#logging-system"}, {"sha": "3ed76eeff98aa5f7704efa07dfbae01a9185e9bb", "filename": "src/doc/rust.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -4056,10 +4056,6 @@ crate name the crate is given a default name that matches the source file,\n with the extension removed. In that case, to turn on logging for a program\n compiled from, e.g. `helloworld.rs`, `RUST_LOG` should be set to `helloworld`.\n \n-As a convenience, the logging spec can also be set to a special pseudo-crate,\n-`::help`. In this case, when the application starts, the runtime will\n-simply output a list of loaded modules containing log expressions, then exit.\n-\n #### Logging Expressions\n \n Rust provides several macros to log information. Here's a simple Rust program"}, {"sha": "35cc0097035c3d4daf0c369aac981b2a55ff1cc9", "filename": "src/etc/pkg/modpath.iss", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Fetc%2Fpkg%2Fmodpath.iss", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Fetc%2Fpkg%2Fmodpath.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fpkg%2Fmodpath.iss?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -164,7 +164,7 @@ begin\n end;\n \n \n-procedure CurStepChanged(CurStep: TSetupStep);\n+procedure ModPathCurStepChanged(CurStep: TSetupStep);\n var\n \ttaskname:\tString;\n begin"}, {"sha": "053fe34952c954ae4163744c8e848694f8e388c3", "filename": "src/etc/pkg/rust.iss", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Fetc%2Fpkg%2Frust.iss", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Fetc%2Fpkg%2Frust.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fpkg%2Frust.iss?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -49,4 +49,15 @@ begin\n \tsetArrayLength(Result, 1)\n \tResult[0] := ExpandConstant('{app}\\bin');\n end;\n-#include \"modpath.iss\"\n\\ No newline at end of file\n+\n+#include \"modpath.iss\"\n+#include \"upgrade.iss\"\n+\n+// Both modpath.iss and upgrade.iss want to overload CurStepChanged.\n+// This version does the overload then delegates to each.\n+\n+procedure CurStepChanged(CurStep: TSetupStep);\n+begin\n+  UpgradeCurStepChanged(CurStep);\n+  ModPathCurStepChanged(CurStep);\n+end;"}, {"sha": "1d36be57649ff9edf79ff746fee470d244da60d9", "filename": "src/etc/pkg/upgrade.iss", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Fetc%2Fpkg%2Fupgrade.iss", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Fetc%2Fpkg%2Fupgrade.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fpkg%2Fupgrade.iss?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -0,0 +1,61 @@\n+// The following code taken from https://stackoverflow.com/questions/2000296/innosetup-how-to-automatically-uninstall-previous-installed-version\n+// It performs upgrades by running the uninstaller before the install\n+\n+/////////////////////////////////////////////////////////////////////\n+function GetUninstallString(): String;\n+var\n+  sUnInstPath: String;\n+  sUnInstallString: String;\n+begin\n+  sUnInstPath := ExpandConstant('Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Rust_is1');\n+  sUnInstallString := '';\n+  if not RegQueryStringValue(HKLM, sUnInstPath, 'UninstallString', sUnInstallString) then\n+    RegQueryStringValue(HKCU, sUnInstPath, 'UninstallString', sUnInstallString);\n+  Result := sUnInstallString;\n+end;\n+\n+\n+/////////////////////////////////////////////////////////////////////\n+function IsUpgrade(): Boolean;\n+begin\n+  Result := (GetUninstallString() <> '');\n+end;\n+\n+\n+/////////////////////////////////////////////////////////////////////\n+function UnInstallOldVersion(): Integer;\n+var\n+  sUnInstallString: String;\n+  iResultCode: Integer;\n+begin\n+// Return Values:\n+// 1 - uninstall string is empty\n+// 2 - error executing the UnInstallString\n+// 3 - successfully executed the UnInstallString\n+\n+  // default return value\n+  Result := 0;\n+\n+  // get the uninstall string of the old app\n+  sUnInstallString := GetUninstallString();\n+  if sUnInstallString <> '' then begin\n+    sUnInstallString := RemoveQuotes(sUnInstallString);\n+    if Exec(sUnInstallString, '/SILENT /NORESTART /SUPPRESSMSGBOXES','', SW_HIDE, ewWaitUntilTerminated, iResultCode) then\n+      Result := 3\n+    else\n+      Result := 2;\n+  end else\n+    Result := 1;\n+end;\n+\n+/////////////////////////////////////////////////////////////////////\n+procedure UpgradeCurStepChanged(CurStep: TSetupStep);\n+begin\n+  if (CurStep=ssInstall) then\n+  begin\n+    if (IsUpgrade()) then\n+    begin\n+      UnInstallOldVersion();\n+    end;\n+  end;\n+end;\n\\ No newline at end of file"}, {"sha": "46b93242685e4380c3006e08c7a2bff7eda6ecee", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -1424,43 +1424,28 @@ impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {\n }\n \n impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Container for HashSet<T, H> {\n-    /// Return the number of elements in the set\n     fn len(&self) -> uint { self.map.len() }\n }\n \n impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n-    /// Clear the set, removing all values.\n     fn clear(&mut self) { self.map.clear() }\n }\n \n impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n-    /// Return true if the set contains a value\n     fn contains(&self, value: &T) -> bool { self.map.search(value).is_some() }\n \n-    /// Return true if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n     fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n         self.iter().all(|v| !other.contains(v))\n     }\n \n-    /// Return true if the set is a subset of another\n     fn is_subset(&self, other: &HashSet<T, H>) -> bool {\n         self.iter().all(|v| other.contains(v))\n     }\n-\n-    /// Return true if the set is a superset of another\n-    fn is_superset(&self, other: &HashSet<T, H>) -> bool {\n-        other.is_subset(self)\n-    }\n }\n \n impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n-    /// Add a value to the set. Return true if the value was not already\n-    /// present in the set.\n     fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n \n-    /// Remove a value from the set. Return true if the value was\n-    /// present in the set.\n     fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n }\n "}, {"sha": "3db12b5a538cbbc5fdac07e62129cf6c2345e14a", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 8, "deletions": 55, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -64,32 +64,20 @@ fn lt<K: Ord + TotalOrd, V: Ord>(a: &TreeMap<K, V>,\n impl<K: Ord + TotalOrd, V: Ord> Ord for TreeMap<K, V> {\n     #[inline]\n     fn lt(&self, other: &TreeMap<K, V>) -> bool { lt(self, other) }\n-    #[inline]\n-    fn le(&self, other: &TreeMap<K, V>) -> bool { !lt(other, self) }\n-    #[inline]\n-    fn ge(&self, other: &TreeMap<K, V>) -> bool { !lt(self, other) }\n-    #[inline]\n-    fn gt(&self, other: &TreeMap<K, V>) -> bool { lt(other, self) }\n }\n \n impl<K: TotalOrd, V> Container for TreeMap<K, V> {\n-    /// Return the number of elements in the map\n     fn len(&self) -> uint { self.length }\n-\n-    /// Return true if the map contains no elements\n-    fn is_empty(&self) -> bool { self.root.is_none() }\n }\n \n impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n-    /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n         self.root = None;\n         self.length = 0\n     }\n }\n \n impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n-    /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n         let mut current: &'a Option<~TreeNode<K, V>> = &self.root;\n         loop {\n@@ -108,22 +96,17 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n }\n \n impl<K: TotalOrd, V> MutableMap<K, V> for TreeMap<K, V> {\n-    /// Return a mutable reference to the value corresponding to the key\n     #[inline]\n     fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n         find_mut(&mut self.root, key)\n     }\n \n-    /// Insert a key-value pair from the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise None is returned.\n     fn swap(&mut self, key: K, value: V) -> Option<V> {\n         let ret = insert(&mut self.root, key, value);\n         if ret.is_none() { self.length += 1 }\n         ret\n     }\n \n-    /// Removes a key from the map, returning the value at the key if the key\n-    /// was previously in the map.\n     fn pop(&mut self, key: &K) -> Option<V> {\n         let ret = remove(&mut self.root, key);\n         if ret.is_some() { self.length -= 1 }\n@@ -531,15 +514,13 @@ impl<K, V> Iterator<(K, V)> for MoveEntries<K,V> {\n }\n \n impl<'a, T> Iterator<&'a T> for SetItems<'a, T> {\n-    /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n         self.iter.next().map(|(value, _)| value)\n     }\n }\n \n impl<'a, T> Iterator<&'a T> for RevSetItems<'a, T> {\n-    /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n         self.iter.next().map(|(value, _)| value)\n@@ -557,90 +538,62 @@ pub struct TreeSet<T> {\n impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n     #[inline]\n     fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n-    #[inline]\n-    fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n }\n \n impl<T: Ord + TotalOrd> Ord for TreeSet<T> {\n     #[inline]\n     fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n-    #[inline]\n-    fn le(&self, other: &TreeSet<T>) -> bool { self.map <= other.map }\n-    #[inline]\n-    fn ge(&self, other: &TreeSet<T>) -> bool { self.map >= other.map }\n-    #[inline]\n-    fn gt(&self, other: &TreeSet<T>) -> bool { self.map > other.map }\n }\n \n impl<T: TotalOrd> Container for TreeSet<T> {\n-    /// Return the number of elements in the set\n     #[inline]\n     fn len(&self) -> uint { self.map.len() }\n-\n-    /// Return true if the set contains no elements\n-    #[inline]\n-    fn is_empty(&self) -> bool { self.map.is_empty() }\n }\n \n impl<T: TotalOrd> Mutable for TreeSet<T> {\n-    /// Clear the set, removing all values.\n     #[inline]\n     fn clear(&mut self) { self.map.clear() }\n }\n \n impl<T: TotalOrd> Set<T> for TreeSet<T> {\n-    /// Return true if the set contains a value\n     #[inline]\n     fn contains(&self, value: &T) -> bool {\n         self.map.contains_key(value)\n     }\n \n-    /// Return true if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n     fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n         self.intersection(other).next().is_none()\n     }\n \n-    /// Return true if the set is a subset of another\n-    #[inline]\n     fn is_subset(&self, other: &TreeSet<T>) -> bool {\n-        other.is_superset(self)\n-    }\n-\n-    /// Return true if the set is a superset of another\n-    fn is_superset(&self, other: &TreeSet<T>) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         let mut a = x.next();\n         let mut b = y.next();\n-        while b.is_some() {\n-            if a.is_none() {\n-                return false\n+        while a.is_some() {\n+            if b.is_none() {\n+                return false;\n             }\n \n             let a1 = a.unwrap();\n             let b1 = b.unwrap();\n \n-            match a1.cmp(b1) {\n-              Less => (),\n-              Greater => return false,\n-              Equal => b = y.next(),\n+            match b1.cmp(a1) {\n+                Less => (),\n+                Greater => return false,\n+                Equal => a = x.next(),\n             }\n \n-            a = x.next();\n+            b = y.next();\n         }\n         true\n     }\n }\n \n impl<T: TotalOrd> MutableSet<T> for TreeSet<T> {\n-    /// Add a value to the set. Return true if the value was not already\n-    /// present in the set.\n     #[inline]\n     fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n \n-    /// Remove a value from the set. Return true if the value was\n-    /// present in the set.\n     #[inline]\n     fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n }"}, {"sha": "dd897b9db4bafe8564a40f35044d4f0f2588541b", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -144,6 +144,19 @@\n //! }\n //! ```\n //!\n+//! The above code can also be shortened with a macro from libgreen.\n+//!\n+//! ```\n+//! #![feature(phase)]\n+//! #[phase(syntax)] extern crate green;\n+//!\n+//! green_start!(main)\n+//!\n+//! fn main() {\n+//!     // run inside of a green pool\n+//! }\n+//! ```\n+//!\n //! # Using a scheduler pool\n //!\n //! ```rust\n@@ -229,6 +242,33 @@ pub mod sleeper_list;\n pub mod stack;\n pub mod task;\n \n+/// A helper macro for booting a program with libgreen\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(phase)]\n+/// #[phase(syntax)] extern crate green;\n+///\n+/// green_start!(main)\n+///\n+/// fn main() {\n+///     // running with libgreen\n+/// }\n+/// ```\n+#[macro_export]\n+macro_rules! green_start( ($f:ident) => (\n+    mod __start {\n+        extern crate green;\n+        extern crate rustuv;\n+\n+        #[start]\n+        fn start(argc: int, argv: **u8) -> int {\n+            green::start(argc, argv, rustuv::event_loop, super::$f)\n+        }\n+    }\n+) )\n+\n /// Set up a default runtime configuration, given compiler-supplied arguments.\n ///\n /// This function will block until the entire pool of M:N schedulers have"}, {"sha": "922a5905fafd7f86bc584bb85a6181e2258f95f0", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -1035,10 +1035,10 @@ mod test {\n \n     fn sched_id() -> uint {\n         let mut task = Local::borrow(None::<Task>);\n-        match task.get().maybe_take_runtime::<GreenTask>() {\n+        match task.maybe_take_runtime::<GreenTask>() {\n             Some(green) => {\n                 let ret = green.sched.get_ref().sched_id();\n-                task.get().put_runtime(green);\n+                task.put_runtime(green);\n                 return ret;\n             }\n             None => fail!()"}, {"sha": "2e64b82a84a31d1e7e1fb4c319761878df134359", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -26,10 +26,10 @@ use super::{IoResult, retry, keep_going};\n #[cfg(unix)]    pub type sock_t = super::file::fd_t;\n \n pub fn htons(u: u16) -> u16 {\n-    mem::to_be16(u as i16) as u16\n+    mem::to_be16(u)\n }\n pub fn ntohs(u: u16) -> u16 {\n-    mem::from_be16(u as i16) as u16\n+    mem::from_be16(u)\n }\n \n enum InAddr {"}, {"sha": "0a38a6ff0be350e34d01ab6615026ac0604776f6", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -182,7 +182,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n                             let t = active.remove(i).unwrap();\n                             ack.send(t);\n                         }\n-                        _ => break\n+                        Err(..) => break\n                     }\n                 }\n "}, {"sha": "8a82ae55faa37554a127028d91377a3e6ac180ab", "filename": "src/libnative/task.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -201,19 +201,30 @@ impl rt::Runtime for Ops {\n                     Err(task) => { cast::forget(task.wake()); }\n                 }\n             } else {\n-                let mut iter = task.make_selectable(times);\n+                let iter = task.make_selectable(times);\n                 let guard = (*me).lock.lock();\n                 (*me).awoken = false;\n-                let success = iter.all(|task| {\n-                    match f(task) {\n-                        Ok(()) => true,\n-                        Err(task) => {\n-                            cast::forget(task.wake());\n-                            false\n+\n+                // Apply the given closure to all of the \"selectable tasks\",\n+                // bailing on the first one that produces an error. Note that\n+                // care must be taken such that when an error is occurred, we\n+                // may not own the task, so we may still have to wait for the\n+                // task to become available. In other words, if task.wake()\n+                // returns `None`, then someone else has ownership and we must\n+                // wait for their signal.\n+                match iter.map(f).filter_map(|a| a.err()).next() {\n+                    None => {}\n+                    Some(task) => {\n+                        match task.wake() {\n+                            Some(task) => {\n+                                cast::forget(task);\n+                                (*me).awoken = true;\n+                            }\n+                            None => {}\n                         }\n                     }\n-                });\n-                while success && !(*me).awoken {\n+                }\n+                while !(*me).awoken {\n                     guard.wait();\n                 }\n             }"}, {"sha": "cff8c149bb6ef8fbba88e229792bce95ef75ba0b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -4143,21 +4143,21 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"nearbyintf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n             \"roundf32\"     => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n             \"roundf64\"     => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"ctpop8\"       => (0, vec!( ty::mk_i8()  ), ty::mk_i8()),\n-            \"ctpop16\"      => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n-            \"ctpop32\"      => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n-            \"ctpop64\"      => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n-            \"ctlz8\"        => (0, vec!( ty::mk_i8()  ), ty::mk_i8()),\n-            \"ctlz16\"       => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n-            \"ctlz32\"       => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n-            \"ctlz64\"       => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n-            \"cttz8\"        => (0, vec!( ty::mk_i8()  ), ty::mk_i8()),\n-            \"cttz16\"       => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n-            \"cttz32\"       => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n-            \"cttz64\"       => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n-            \"bswap16\"      => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n-            \"bswap32\"      => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n-            \"bswap64\"      => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n+            \"ctpop8\"       => (0, vec!( ty::mk_u8()  ), ty::mk_u8()),\n+            \"ctpop16\"      => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n+            \"ctpop32\"      => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n+            \"ctpop64\"      => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n+            \"ctlz8\"        => (0, vec!( ty::mk_u8()  ), ty::mk_u8()),\n+            \"ctlz16\"       => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n+            \"ctlz32\"       => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n+            \"ctlz64\"       => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n+            \"cttz8\"        => (0, vec!( ty::mk_u8()  ), ty::mk_u8()),\n+            \"cttz16\"       => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n+            \"cttz32\"       => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n+            \"cttz64\"       => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n+            \"bswap16\"      => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n+            \"bswap32\"      => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n+            \"bswap64\"      => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n \n             \"volatile_load\" =>\n                 (1, vec!( ty::mk_imm_ptr(tcx, param(ccx, 0)) ), param(ccx, 0)),"}, {"sha": "4571e6328cf24e056a1739b221e74af8a1cd9da7", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -20,23 +20,21 @@ use serialize::hex::ToHex;\n /// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n /// format.\n fn write_u32_be(dst: &mut[u8], input: u32) {\n-    use std::cast::transmute;\n     use std::mem::to_be32;\n     assert!(dst.len() == 4);\n     unsafe {\n-        let x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n-        *x = to_be32(input as i32);\n+        let x = dst.unsafe_mut_ref(0) as *mut _ as *mut u32;\n+        *x = to_be32(input);\n     }\n }\n \n /// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n-    use std::cast::transmute;\n     use std::mem::to_be32;\n     assert!(dst.len() * 4 == input.len());\n     unsafe {\n-        let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n-        let mut y: *i32 = transmute(input.unsafe_ref(0));\n+        let mut x = dst.unsafe_mut_ref(0) as *mut _ as *mut u32;\n+        let mut y = input.unsafe_ref(0) as *_ as *u32;\n         for _ in range(0, dst.len()) {\n             *x = to_be32(*y);\n             x = x.offset(1);"}, {"sha": "e975fac6ed758a4b5f072530e14b94e02acc7c07", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -189,67 +189,68 @@\n             for (var i = 0; i < nresults; i += 1) {\n                 results[i].word = searchWords[results[i].id];\n                 results[i].item = searchIndex[results[i].id] || {};\n-                results[i].ty = results[i].item.ty;\n-                results[i].path = results[i].item.path;\n             }\n             // if there are no results then return to default and fail\n             if (results.length === 0) {\n                 return [];\n             }\n \n-            // sort by exact match\n-            results.sort(function search_complete_sort0(aaa, bbb) {\n-                if (aaa.word === valLower &&\n-                    bbb.word !== valLower) {\n-                    return 1;\n-                }\n-            });\n-            // first sorting attempt\n-            // sort by item name length\n-            results.sort(function search_complete_sort1(aaa, bbb) {\n-                if (aaa.word.length > bbb.word.length) {\n-                    return 1;\n-                }\n+            results.sort(function(aaa, bbb) {\n+                var a, b;\n+\n+                // sort by crate (non-current crate goes later)\n+                a = (aaa.item.crate !== window.currentCrate);\n+                b = (bbb.item.crate !== window.currentCrate);\n+                if (a !== b) return a - b;\n+\n+                // sort by exact match (mismatch goes later)\n+                a = (aaa.word !== valLower);\n+                b = (bbb.word !== valLower);\n+                if (a !== b) return a - b;\n+\n+                // sort by item name length (longer goes later)\n+                a = aaa.word.length;\n+                b = bbb.word.length;\n+                if (a !== b) return a - b;\n+\n+                // sort by item name (lexicographically larger goes later)\n+                a = aaa.word;\n+                b = bbb.word;\n+                if (a !== b) return (a > b ? +1 : -1);\n+\n+                // sort by index of keyword in item name (no literal occurrence goes later)\n+                a = (aaa.index < 0);\n+                b = (bbb.index < 0);\n+                if (a !== b) return a - b;\n+                // (later literal occurrence, if any, goes later)\n+                a = aaa.index;\n+                b = bbb.index;\n+                if (a !== b) return a - b;\n+\n+                // sort by description (no description goes later)\n+                a = (aaa.item.desc === '');\n+                b = (bbb.item.desc === '');\n+                if (a !== b) return a - b;\n+\n+                // sort by type (later occurrence in `itemTypes` goes later)\n+                a = aaa.item.ty;\n+                b = bbb.item.ty;\n+                if (a !== b) return a - b;\n+\n+                // sort by path (lexicographically larger goes later)\n+                a = aaa.item.path;\n+                b = bbb.item.path;\n+                if (a !== b) return (a > b ? +1 : -1);\n+\n+                // que sera, sera\n+                return 0;\n             });\n-            // second sorting attempt\n-            // sort by item name\n-            results.sort(function search_complete_sort1(aaa, bbb) {\n-                if (aaa.word.length === bbb.word.length &&\n-                    aaa.word > bbb.word) {\n-                    return 1;\n-                }\n-            });\n-            // third sorting attempt\n-            // sort by index of keyword in item name\n-            if (results[0].index !== -1) {\n-                results.sort(function search_complete_sort1(aaa, bbb) {\n-                    if (aaa.index > bbb.index && bbb.index === 0) {\n-                        return 1;\n-                    }\n-                });\n-            }\n-            // fourth sorting attempt\n-            // sort by type\n-            results.sort(function search_complete_sort3(aaa, bbb) {\n-                if (aaa.word === bbb.word &&\n-                    aaa.ty > bbb.ty) {\n-                    return 1;\n-                }\n-            });\n-            // fifth sorting attempt\n-            // sort by path\n-            results.sort(function search_complete_sort4(aaa, bbb) {\n-                if (aaa.word === bbb.word &&\n-                    aaa.ty === bbb.ty && aaa.path > bbb.path) {\n-                    return 1;\n-                }\n-            });\n-            // sixth sorting attempt\n+\n             // remove duplicates, according to the data provided\n             for (var i = results.length - 1; i > 0; i -= 1) {\n                 if (results[i].word === results[i - 1].word &&\n-                    results[i].ty === results[i - 1].ty &&\n-                    results[i].path === results[i - 1].path)\n+                    results[i].item.ty === results[i - 1].item.ty &&\n+                    results[i].item.path === results[i - 1].item.path)\n                 {\n                     results[i].id = -1;\n                 }"}, {"sha": "4f2b7103b793817ddbde77295c198f82330f857f", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -462,7 +462,7 @@ fn local_loop() -> &'static mut uvio::UvIoFactory {\n     unsafe {\n         cast::transmute({\n             let mut task = Local::borrow(None::<Task>);\n-            let mut io = task.get().local_io().unwrap();\n+            let mut io = task.local_io().unwrap();\n             let (_vtable, uvio): (uint, &'static mut uvio::UvIoFactory) =\n                 cast::transmute(io.get());\n             uvio"}, {"sha": "280cd4bd592eef8795e41ea831a1c58f121fc8e4", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -32,8 +32,8 @@ use uvll;\n /// Generic functions related to dealing with sockaddr things\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub fn htons(u: u16) -> u16 { mem::to_be16(u as i16) as u16 }\n-pub fn ntohs(u: u16) -> u16 { mem::from_be16(u as i16) as u16 }\n+pub fn htons(u: u16) -> u16 { mem::to_be16(u) }\n+pub fn ntohs(u: u16) -> u16 { mem::from_be16(u) }\n \n pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n                         len: uint) -> ip::SocketAddr {"}, {"sha": "0efa93011fc6687bf921986f636a46becd508613", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -179,8 +179,8 @@ pub mod reader {\n         ];\n \n         unsafe {\n-            let ptr = data.as_ptr().offset(start as int) as *i32;\n-            let val = from_be32(*ptr) as u32;\n+            let ptr = data.as_ptr().offset(start as int) as *u32;\n+            let val = from_be32(*ptr);\n \n             let i = (val >> 28u) as uint;\n             let (shift, mask) = SHIFT_MASK_TABLE[i];"}, {"sha": "e8ee3792dcf2cdf423398ec3606003b594d9b192", "filename": "src/libstd/container.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcontainer.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -88,7 +88,9 @@ pub trait Set<T>: Container {\n     fn is_subset(&self, other: &Self) -> bool;\n \n     /// Return true if the set is a superset of another\n-    fn is_superset(&self, other: &Self) -> bool;\n+    fn is_superset(&self, other: &Self) -> bool {\n+        other.is_subset(self)\n+    }\n \n     // FIXME #8154: Add difference, sym. difference, intersection and union iterators\n }"}, {"sha": "175c7fe57b319c9cd0e7fa43edf084fd7be0b8c9", "filename": "src/libstd/intrinsics.rs", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fintrinsics.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -394,26 +394,50 @@ extern \"rust-intrinsic\" {\n \n     pub fn roundf32(x: f32) -> f32;\n     pub fn roundf64(x: f64) -> f64;\n+}\n+#[cfg(not(stage0))]\n+extern \"rust-intrinsic\" {\n+    pub fn ctpop8(x: u8) -> u8;\n+    pub fn ctpop16(x: u16) -> u16;\n+    pub fn ctpop32(x: u32) -> u32;\n+    pub fn ctpop64(x: u64) -> u64;\n+\n+    pub fn ctlz8(x: u8) -> u8;\n+    pub fn ctlz16(x: u16) -> u16;\n+    pub fn ctlz32(x: u32) -> u32;\n+    pub fn ctlz64(x: u64) -> u64;\n+\n+    pub fn cttz8(x: u8) -> u8;\n+    pub fn cttz16(x: u16) -> u16;\n+    pub fn cttz32(x: u32) -> u32;\n+    pub fn cttz64(x: u64) -> u64;\n+\n+    pub fn bswap16(x: u16) -> u16;\n+    pub fn bswap32(x: u32) -> u32;\n+    pub fn bswap64(x: u64) -> u64;\n+}\n \n-    pub fn ctpop8(x: i8) -> i8;\n-    pub fn ctpop16(x: i16) -> i16;\n-    pub fn ctpop32(x: i32) -> i32;\n-    pub fn ctpop64(x: i64) -> i64;\n-\n-    pub fn ctlz8(x: i8) -> i8;\n-    pub fn ctlz16(x: i16) -> i16;\n-    pub fn ctlz32(x: i32) -> i32;\n-    pub fn ctlz64(x: i64) -> i64;\n-\n-    pub fn cttz8(x: i8) -> i8;\n-    pub fn cttz16(x: i16) -> i16;\n-    pub fn cttz32(x: i32) -> i32;\n-    pub fn cttz64(x: i64) -> i64;\n-\n-    pub fn bswap16(x: i16) -> i16;\n-    pub fn bswap32(x: i32) -> i32;\n-    pub fn bswap64(x: i64) -> i64;\n+// NOTE: remove this after a snap, and merge the extern block above\n+macro_rules! stage0_hack {\n+    ($( $u_ty:ty, $i_ty:ty => $($name:ident),*);*) => {\n+        $(\n+            $(\n+                #[cfg(stage0)]\n+                pub unsafe fn $name(x: $u_ty) -> $u_ty {\n+                    extern \"rust-intrinsic\" { fn $name(x: $i_ty) -> $i_ty; }\n+                    $name(x as $i_ty) as $u_ty\n+                }\n+            )*)*\n+    }\n+}\n+stage0_hack! {\n+    u8, i8 => ctpop8, ctlz8, cttz8;\n+    u16, i16 => ctpop16, ctlz16, cttz16, bswap16;\n+    u32, i32 => ctpop32, ctlz32, cttz32, bswap32;\n+    u64, i64 => ctpop64, ctlz64, cttz64, bswap64\n+}\n \n+extern \"rust-intrinsic\" {\n     pub fn i8_add_with_overflow(x: i8, y: i8) -> (i8, bool);\n     pub fn i16_add_with_overflow(x: i16, y: i16) -> (i16, bool);\n     pub fn i32_add_with_overflow(x: i32, y: i32) -> (i32, bool);"}, {"sha": "d8022b1e26c6d48df5040711d33d5d82ee8a77d6", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -83,9 +83,9 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n     assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n-      2u => f(unsafe { transmute::<i16, [u8, ..2]>(to_le16(n as i16)) }),\n-      4u => f(unsafe { transmute::<i32, [u8, ..4]>(to_le32(n as i32)) }),\n-      8u => f(unsafe { transmute::<i64, [u8, ..8]>(to_le64(n as i64)) }),\n+      2u => f(unsafe { transmute::<_, [u8, ..2]>(to_le16(n as u16)) }),\n+      4u => f(unsafe { transmute::<_, [u8, ..4]>(to_le32(n as u32)) }),\n+      8u => f(unsafe { transmute::<_, [u8, ..8]>(to_le64(n)) }),\n       _ => {\n \n         let mut bytes = vec!();\n@@ -123,9 +123,9 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n     assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n-      2u => f(unsafe { transmute::<i16, [u8, ..2]>(to_be16(n as i16)) }),\n-      4u => f(unsafe { transmute::<i32, [u8, ..4]>(to_be32(n as i32)) }),\n-      8u => f(unsafe { transmute::<i64, [u8, ..8]>(to_be64(n as i64)) }),\n+      2u => f(unsafe { transmute::<_, [u8, ..2]>(to_be16(n as u16)) }),\n+      4u => f(unsafe { transmute::<_, [u8, ..4]>(to_be32(n as u32)) }),\n+      8u => f(unsafe { transmute::<_, [u8, ..8]>(to_be64(n)) }),\n       _ => {\n         let mut bytes = vec!();\n         let mut i = size;\n@@ -166,7 +166,7 @@ pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n         let ptr = data.as_ptr().offset(start as int);\n         let out = buf.as_mut_ptr();\n         copy_nonoverlapping_memory(out.offset((8 - size) as int), ptr, size);\n-        from_be64(*(out as *i64)) as u64\n+        from_be64(*(out as *u64))\n     }\n }\n "}, {"sha": "34a5788439839c29431dd1ac3e27976890ab3acd", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -160,7 +160,7 @@ fn reset_helper(w: ~Writer:Send,\n {\n     let mut t = Local::borrow(None::<Task>);\n     // Be sure to flush any pending output from the writer\n-    match f(t.get(), w) {\n+    match f(&mut *t, w) {\n         Some(mut w) => {\n             drop(t);\n             // FIXME: is failing right here?\n@@ -230,9 +230,7 @@ fn with_task_stdout(f: |&mut Writer| -> IoResult<()> ) {\n             // To protect against this, we do a little dance in which we\n             // temporarily take the task, swap the handles, put the task in TLS,\n             // and only then drop the previous handle.\n-            let mut t = Local::borrow(None::<Task>);\n-            let prev = replace(&mut t.get().stdout, my_stdout);\n-            drop(t);\n+            let prev = replace(&mut Local::borrow(None::<Task>).stdout, my_stdout);\n             drop(prev);\n             ret\n         }"}, {"sha": "282cfe517823bd9e2077b3756b713836527bcf14", "filename": "src/libstd/mem.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmem.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -99,128 +99,128 @@ pub unsafe fn move_val_init<T>(dst: &mut T, src: T) {\n     intrinsics::move_val_init(dst, src)\n }\n \n-/// Convert an i16 to little endian from the target's endianness.\n+/// Convert an u16 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_le16(x: i16) -> i16 { x }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn to_le16(x: u16) -> u16 { x }\n \n-/// Convert an i16 to little endian from the target's endianness.\n+/// Convert an u16 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le16(x: i16) -> i16 { unsafe { bswap16(x) } }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le16(x: u16) -> u16 { unsafe { bswap16(x) } }\n \n-/// Convert an i32 to little endian from the target's endianness.\n+/// Convert an u32 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_le32(x: i32) -> i32 { x }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn to_le32(x: u32) -> u32 { x }\n \n-/// Convert an i32 to little endian from the target's endianness.\n+/// Convert an u32 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le32(x: i32) -> i32 { unsafe { bswap32(x) } }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le32(x: u32) -> u32 { unsafe { bswap32(x) } }\n \n-/// Convert an i64 to little endian from the target's endianness.\n+/// Convert an u64 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_le64(x: i64) -> i64 { x }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn to_le64(x: u64) -> u64 { x }\n \n-/// Convert an i64 to little endian from the target's endianness.\n+/// Convert an u64 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le64(x: i64) -> i64 { unsafe { bswap64(x) } }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn to_le64(x: u64) -> u64 { unsafe { bswap64(x) } }\n \n \n-/// Convert an i16 to big endian from the target's endianness.\n+/// Convert an u16 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_be16(x: i16) -> i16 { unsafe { bswap16(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn to_be16(x: u16) -> u16 { unsafe { bswap16(x) } }\n \n-/// Convert an i16 to big endian from the target's endianness.\n+/// Convert an u16 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be16(x: i16) -> i16 { x }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be16(x: u16) -> u16 { x }\n \n-/// Convert an i32 to big endian from the target's endianness.\n+/// Convert an u32 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_be32(x: i32) -> i32 { unsafe { bswap32(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn to_be32(x: u32) -> u32 { unsafe { bswap32(x) } }\n \n-/// Convert an i32 to big endian from the target's endianness.\n+/// Convert an u32 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be32(x: i32) -> i32 { x }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be32(x: u32) -> u32 { x }\n \n-/// Convert an i64 to big endian from the target's endianness.\n+/// Convert an u64 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_be64(x: i64) -> i64 { unsafe { bswap64(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn to_be64(x: u64) -> u64 { unsafe { bswap64(x) } }\n \n-/// Convert an i64 to big endian from the target's endianness.\n+/// Convert an u64 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be64(x: i64) -> i64 { x }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn to_be64(x: u64) -> u64 { x }\n \n \n-/// Convert an i16 from little endian to the target's endianness.\n+/// Convert an u16 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_le16(x: i16) -> i16 { x }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn from_le16(x: u16) -> u16 { x }\n \n-/// Convert an i16 from little endian to the target's endianness.\n+/// Convert an u16 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le16(x: i16) -> i16 { unsafe { bswap16(x) } }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le16(x: u16) -> u16 { unsafe { bswap16(x) } }\n \n-/// Convert an i32 from little endian to the target's endianness.\n+/// Convert an u32 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_le32(x: i32) -> i32 { x }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn from_le32(x: u32) -> u32 { x }\n \n-/// Convert an i32 from little endian to the target's endianness.\n+/// Convert an u32 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le32(x: i32) -> i32 { unsafe { bswap32(x) } }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le32(x: u32) -> u32 { unsafe { bswap32(x) } }\n \n-/// Convert an i64 from little endian to the target's endianness.\n+/// Convert an u64 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_le64(x: i64) -> i64 { x }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn from_le64(x: u64) -> u64 { x }\n \n-/// Convert an i64 from little endian to the target's endianness.\n+/// Convert an u64 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le64(x: i64) -> i64 { unsafe { bswap64(x) } }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn from_le64(x: u64) -> u64 { unsafe { bswap64(x) } }\n \n \n-/// Convert an i16 from big endian to the target's endianness.\n+/// Convert an u16 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_be16(x: i16) -> i16 { unsafe { bswap16(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn from_be16(x: u16) -> u16 { unsafe { bswap16(x) } }\n \n-/// Convert an i16 from big endian to the target's endianness.\n+/// Convert an u16 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be16(x: i16) -> i16 { x }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be16(x: u16) -> u16 { x }\n \n-/// Convert an i32 from big endian to the target's endianness.\n+/// Convert an u32 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_be32(x: i32) -> i32 { unsafe { bswap32(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn from_be32(x: u32) -> u32 { unsafe { bswap32(x) } }\n \n-/// Convert an i32 from big endian to the target's endianness.\n+/// Convert an u32 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be32(x: i32) -> i32 { x }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be32(x: u32) -> u32 { x }\n \n-/// Convert an i64 from big endian to the target's endianness.\n+/// Convert an u64 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn from_be64(x: i64) -> i64 { unsafe { bswap64(x) } }\n+#[cfg(target_endian = \"little\")] #[inline] pub fn from_be64(x: u64) -> u64 { unsafe { bswap64(x) } }\n \n-/// Convert an i64 from big endian to the target's endianness.\n+/// Convert an u64 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be64(x: i64) -> i64 { x }\n+#[cfg(target_endian = \"big\")]    #[inline] pub fn from_be64(x: u64) -> u64 { x }\n \n \n /**"}, {"sha": "7cd6aaa631086ce75bae41671d53b38396f1816b", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -1037,7 +1037,7 @@ mod tests {\n         assert_eq!(0f32.abs_sub(&INFINITY), 0f32);\n     }\n \n-    #[test] #[ignore(cfg(windows))] // FIXME #8663\n+    #[test]\n     fn test_abs_sub_nowin() {\n         assert!(NAN.abs_sub(&-1f32).is_nan());\n         assert!(1f32.abs_sub(&NAN).is_nan());"}, {"sha": "8b52a6747f47804e3706af872c0f1c3f15c2ba86", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -1041,7 +1041,7 @@ mod tests {\n         assert_eq!(0f64.abs_sub(&INFINITY), 0f64);\n     }\n \n-    #[test] #[ignore(cfg(windows))] // FIXME #8663\n+    #[test]\n     fn test_abs_sub_nowin() {\n         assert!(NAN.abs_sub(&-1f64).is_nan());\n         assert!(1f64.abs_sub(&NAN).is_nan());"}, {"sha": "79827421f9222c37c743c302752c26eb2d3264fc", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -28,17 +28,17 @@ int_module!(i16, 16)\n impl Bitwise for i16 {\n     /// Returns the number of ones in the binary representation of the number.\n     #[inline]\n-    fn count_ones(&self) -> i16 { unsafe { intrinsics::ctpop16(*self) } }\n+    fn count_ones(&self) -> i16 { unsafe { intrinsics::ctpop16(*self as u16) as i16 } }\n \n     /// Returns the number of leading zeros in the in the binary representation\n     /// of the number.\n     #[inline]\n-    fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self) } }\n+    fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self as u16) as i16 } }\n \n     /// Returns the number of trailing zeros in the in the binary representation\n     /// of the number.\n     #[inline]\n-    fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self) } }\n+    fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self as u16) as i16 } }\n }\n \n impl CheckedAdd for i16 {"}, {"sha": "97f03299b8765374016d878474c9e48bccc6228c", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -28,17 +28,17 @@ int_module!(i32, 32)\n impl Bitwise for i32 {\n     /// Returns the number of ones in the binary representation of the number.\n     #[inline]\n-    fn count_ones(&self) -> i32 { unsafe { intrinsics::ctpop32(*self) } }\n+    fn count_ones(&self) -> i32 { unsafe { intrinsics::ctpop32(*self as u32) as i32 } }\n \n     /// Returns the number of leading zeros in the in the binary representation\n     /// of the number.\n     #[inline]\n-    fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self) } }\n+    fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self as u32) as i32 } }\n \n     /// Returns the number of trailing zeros in the in the binary representation\n     /// of the number.\n     #[inline]\n-    fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self) } }\n+    fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self as u32) as i32 } }\n }\n \n impl CheckedAdd for i32 {"}, {"sha": "00823aa22c28ec8d6139609b2b585bc4d50cd376", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -30,16 +30,16 @@ int_module!(i64, 64)\n impl Bitwise for i64 {\n     /// Returns the number of ones in the binary representation of the number.\n     #[inline]\n-    fn count_ones(&self) -> i64 { unsafe { intrinsics::ctpop64(*self) } }\n+    fn count_ones(&self) -> i64 { unsafe { intrinsics::ctpop64(*self as u64) as i64 } }\n \n     /// Returns the number of leading zeros in the in the binary representation\n     /// of the number.\n     #[inline]\n-    fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self) } }\n+    fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self as u64) as i64 } }\n \n     /// Counts the number of trailing zeros.\n     #[inline]\n-    fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self) } }\n+    fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self as u64) as i64 } }\n }\n \n impl CheckedAdd for i64 {"}, {"sha": "2d349fa7f4f1da240fd750de8a1d96a8f93bddc1", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -28,17 +28,17 @@ int_module!(i8, 8)\n impl Bitwise for i8 {\n     /// Returns the number of ones in the binary representation of the number.\n     #[inline]\n-    fn count_ones(&self) -> i8 { unsafe { intrinsics::ctpop8(*self) } }\n+    fn count_ones(&self) -> i8 { unsafe { intrinsics::ctpop8(*self as u8) as i8 } }\n \n     /// Returns the number of leading zeros in the in the binary representation\n     /// of the number.\n     #[inline]\n-    fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self) } }\n+    fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self as u8) as i8 } }\n \n     /// Returns the number of trailing zeros in the in the binary representation\n     /// of the number.\n     #[inline]\n-    fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self) } }\n+    fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self as u8) as i8 } }\n }\n \n impl CheckedAdd for i8 {"}, {"sha": "25f503174bc9881a2ae9c5cfd7405ae8bd27595f", "filename": "src/libstd/os.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -1294,37 +1294,47 @@ impl Drop for MemoryMap {\n /// Various useful system-specific constants.\n pub mod consts {\n     #[cfg(unix)]\n-    pub use os::consts::unix::*;\n+    pub use os::consts::unix::FAMILY;\n \n     #[cfg(windows)]\n-    pub use os::consts::windows::*;\n+    pub use os::consts::windows::FAMILY;\n \n     #[cfg(target_os = \"macos\")]\n-    pub use os::consts::macos::*;\n+    pub use os::consts::macos::{SYSNAME, DLL_PREFIX, DLL_SUFFIX, DLL_EXTENSION};\n+    #[cfg(target_os = \"macos\")]\n+    pub use os::consts::macos::{EXE_SUFFIX, EXE_EXTENSION};\n \n     #[cfg(target_os = \"freebsd\")]\n-    pub use os::consts::freebsd::*;\n+    pub use os::consts::freebsd::{SYSNAME, DLL_PREFIX, DLL_SUFFIX, DLL_EXTENSION};\n+    #[cfg(target_os = \"freebsd\")]\n+    pub use os::consts::freebsd::{EXE_SUFFIX, EXE_EXTENSION};\n \n     #[cfg(target_os = \"linux\")]\n-    pub use os::consts::linux::*;\n+    pub use os::consts::linux::{SYSNAME, DLL_PREFIX, DLL_SUFFIX, DLL_EXTENSION};\n+    #[cfg(target_os = \"linux\")]\n+    pub use os::consts::linux::{EXE_SUFFIX, EXE_EXTENSION};\n \n     #[cfg(target_os = \"android\")]\n-    pub use os::consts::android::*;\n+    pub use os::consts::android::{SYSNAME, DLL_PREFIX, DLL_SUFFIX, DLL_EXTENSION};\n+    #[cfg(target_os = \"android\")]\n+    pub use os::consts::android::{EXE_SUFFIX, EXE_EXTENSION};\n \n     #[cfg(target_os = \"win32\")]\n-    pub use os::consts::win32::*;\n+    pub use os::consts::win32::{SYSNAME, DLL_PREFIX, DLL_SUFFIX, DLL_EXTENSION};\n+    #[cfg(target_os = \"win32\")]\n+    pub use os::consts::win32::{EXE_SUFFIX, EXE_EXTENSION};\n \n     #[cfg(target_arch = \"x86\")]\n-    pub use os::consts::x86::*;\n+    pub use os::consts::x86::{ARCH};\n \n     #[cfg(target_arch = \"x86_64\")]\n-    pub use os::consts::x86_64::*;\n+    pub use os::consts::x86_64::{ARCH};\n \n     #[cfg(target_arch = \"arm\")]\n-    pub use os::consts::arm::*;\n+    pub use os::consts::arm::{ARCH};\n \n     #[cfg(target_arch = \"mips\")]\n-    pub use os::consts::mips::*;\n+    pub use os::consts::mips::{ARCH};\n \n     /// Constants for Unix systems.\n     pub mod unix {"}, {"sha": "caf0d9028c5da1211db6b309ed101b54f82edafc", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -319,8 +319,7 @@ pub unsafe fn local_free(ptr: *u8) {\n }\n \n pub fn live_allocs() -> *mut Box {\n-    let mut task = Local::borrow(None::<Task>);\n-    task.get().heap.live_allocs\n+    Local::borrow(None::<Task>).heap.live_allocs\n }\n \n #[cfg(test)]"}, {"sha": "ff82be97489b5317311c9028bdcadc2d09f979e6", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -18,15 +18,17 @@\n #![allow(dead_code)]\n \n use cast;\n-use ops::Drop;\n+use ops::{Drop, Deref, DerefMut};\n use ptr::RawPtr;\n \n #[cfg(windows)]               // mingw-w32 doesn't like thread_local things\n #[cfg(target_os = \"android\")] // see #10686\n-pub use self::native::*;\n+pub use self::native::{init, cleanup, put, take, try_take, unsafe_take, exists,\n+                       unsafe_borrow, try_unsafe_borrow};\n \n #[cfg(not(windows), not(target_os = \"android\"))]\n-pub use self::compiled::*;\n+pub use self::compiled::{init, cleanup, put, take, try_take, unsafe_take, exists,\n+                         unsafe_borrow, try_unsafe_borrow};\n \n /// Encapsulates a borrowed value. When this value goes out of scope, the\n /// pointer is returned.\n@@ -48,13 +50,15 @@ impl<T> Drop for Borrowed<T> {\n     }\n }\n \n-impl<T> Borrowed<T> {\n-    pub fn get<'a>(&'a mut self) -> &'a mut T {\n-        unsafe {\n-            let val_ptr: &mut ~T = cast::transmute(&mut self.val);\n-            let val_ptr: &'a mut T = *val_ptr;\n-            val_ptr\n-        }\n+impl<T> Deref<T> for Borrowed<T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        unsafe { &*(self.val as *T) }\n+    }\n+}\n+\n+impl<T> DerefMut<T> for Borrowed<T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+        unsafe { &mut *(self.val as *mut T) }\n     }\n }\n "}, {"sha": "a3664b45a4178ab4465f9b8117b6ba494f26110c", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -127,8 +127,8 @@ impl Task {\n                 #[allow(unused_must_use)]\n                 fn close_outputs() {\n                     let mut task = Local::borrow(None::<Task>);\n-                    let stderr = task.get().stderr.take();\n-                    let stdout = task.get().stdout.take();\n+                    let stderr = task.stderr.take();\n+                    let stdout = task.stdout.take();\n                     drop(task);\n                     match stdout { Some(mut w) => { w.flush(); }, None => {} }\n                     match stderr { Some(mut w) => { w.flush(); }, None => {} }\n@@ -159,8 +159,7 @@ impl Task {\n                 // be intertwined, and miraculously work for now...\n                 let mut task = Local::borrow(None::<Task>);\n                 let storage_map = {\n-                    let task = task.get();\n-                    let LocalStorage(ref mut optmap) = task.storage;\n+                    let &LocalStorage(ref mut optmap) = &mut task.storage;\n                     optmap.take()\n                 };\n                 drop(task);\n@@ -332,8 +331,7 @@ impl BlockedTask {\n     }\n \n     /// Converts one blocked task handle to a list of many handles to the same.\n-    pub fn make_selectable(self, num_handles: uint) -> Take<BlockedTasks>\n-    {\n+    pub fn make_selectable(self, num_handles: uint) -> Take<BlockedTasks> {\n         let arc = match self {\n             Owned(task) => {\n                 let flag = unsafe { AtomicUint::new(cast::transmute(task)) };"}, {"sha": "df627809ea02919af555c5fd881c8489882bd6cb", "filename": "src/libstd/task.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -257,8 +257,8 @@ pub fn try<T:Send>(f: proc():Send -> T) -> Result<T, ~Any:Send> {\n pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n     use rt::task::Task;\n \n-    let mut task = Local::borrow(None::<Task>);\n-    match task.get().name {\n+    let task = Local::borrow(None::<Task>);\n+    match task.name {\n         Some(ref name) => blk(Some(name.as_slice())),\n         None => blk(None)\n     }\n@@ -276,11 +276,8 @@ pub fn deschedule() {\n \n pub fn failing() -> bool {\n     //! True if the running task has failed\n-\n     use rt::task::Task;\n-\n-    let mut local = Local::borrow(None::<Task>);\n-    local.get().unwinder.unwinding()\n+    Local::borrow(None::<Task>).unwinder.unwinding()\n }\n \n // The following 8 tests test the following 2^3 combinations:"}, {"sha": "0d9ee2512cc1a8ee1b344e1e106ee451fdeb0b0f", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -194,7 +194,7 @@ pub fn encode(s: &str) -> ~str {\n }\n \n /**\n- * Encodes a URI component by replacing reserved characters with percent\n+ * Encodes a URI component by replacing reserved characters with percent-\n  * encoded character sequences.\n  *\n  * This function is compliant with RFC 3986."}, {"sha": "559edd587fd7e0e18283fc350bc6e66b6f4063fc", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -220,9 +220,9 @@ impl Uuid {\n                 data4: [0, ..8]\n         };\n \n-        fields.data1 = to_be32(d1 as i32) as u32;\n-        fields.data2 = to_be16(d2 as i16) as u16;\n-        fields.data3 = to_be16(d3 as i16) as u16;\n+        fields.data1 = to_be32(d1);\n+        fields.data2 = to_be16(d2);\n+        fields.data3 = to_be16(d3);\n         slice::bytes::copy_memory(fields.data4, d4);\n \n         unsafe {\n@@ -343,9 +343,9 @@ impl Uuid {\n         unsafe {\n             uf = transmute_copy(&self.bytes);\n         }\n-        uf.data1 = to_be32(uf.data1 as i32) as u32;\n-        uf.data2 = to_be16(uf.data2 as i16) as u16;\n-        uf.data3 = to_be16(uf.data3 as i16) as u16;\n+        uf.data1 = to_be32(uf.data1);\n+        uf.data2 = to_be16(uf.data2);\n+        uf.data3 = to_be16(uf.data3);\n         let s = format!(\"{:08x}-{:04x}-{:04x}-{:02x}{:02x}-\\\n                          {:02x}{:02x}{:02x}{:02x}{:02x}{:02x}\",\n             uf.data1,"}, {"sha": "7dd2d945c26c736d2ca06fd349b2b33ee927ccdf", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -512,8 +512,9 @@ fn test() {\n         prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);\n         prep.exec(proc(_exe) {\n             let out = make_path(~\"foo.o\");\n+            let compiler = if cfg!(windows) {\"gcc\"} else {\"cc\"};\n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            Process::status(\"gcc\", [pth.as_str().unwrap().to_owned(),\n+            Process::status(compiler, [pth.as_str().unwrap().to_owned(),\n                                     ~\"-o\",\n                                     out.as_str().unwrap().to_owned()]).unwrap();\n "}, {"sha": "f5724fc1324d5725ea3e5653711c59e49eca35f2", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -16,7 +16,7 @@ use std::io;\n use std::io::stdio::StdReader;\n use std::io::BufferedReader;\n use std::os;\n-use std::intrinsics::cttz16;\n+use std::num::Bitwise;\n \n // Computes a single solution to a given 9x9 sudoku\n //\n@@ -187,9 +187,7 @@ impl Colors {\n         if (0u16 == val) {\n             return 0u8;\n         } else {\n-            unsafe {\n-                return cttz16(val as i16) as u8;\n-            }\n+            return val.trailing_zeros() as u8\n         }\n     }\n "}, {"sha": "e31b941f956eb6893f2a36fc06ab3235aad1531d", "filename": "src/test/run-pass/intrinsics-integer.rs", "status": "modified", "additions": 96, "deletions": 97, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -1,4 +1,3 @@\n-\n // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -13,108 +12,108 @@\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n-        pub fn ctpop8(x: i8) -> i8;\n-        pub fn ctpop16(x: i16) -> i16;\n-        pub fn ctpop32(x: i32) -> i32;\n-        pub fn ctpop64(x: i64) -> i64;\n-\n-        pub fn ctlz8(x: i8) -> i8;\n-        pub fn ctlz16(x: i16) -> i16;\n-        pub fn ctlz32(x: i32) -> i32;\n-        pub fn ctlz64(x: i64) -> i64;\n-\n-        pub fn cttz8(x: i8) -> i8;\n-        pub fn cttz16(x: i16) -> i16;\n-        pub fn cttz32(x: i32) -> i32;\n-        pub fn cttz64(x: i64) -> i64;\n-\n-        pub fn bswap16(x: i16) -> i16;\n-        pub fn bswap32(x: i32) -> i32;\n-        pub fn bswap64(x: i64) -> i64;\n+        pub fn ctpop8(x: u8) -> u8;\n+        pub fn ctpop16(x: u16) -> u16;\n+        pub fn ctpop32(x: u32) -> u32;\n+        pub fn ctpop64(x: u64) -> u64;\n+\n+        pub fn ctlz8(x: u8) -> u8;\n+        pub fn ctlz16(x: u16) -> u16;\n+        pub fn ctlz32(x: u32) -> u32;\n+        pub fn ctlz64(x: u64) -> u64;\n+\n+        pub fn cttz8(x: u8) -> u8;\n+        pub fn cttz16(x: u16) -> u16;\n+        pub fn cttz32(x: u32) -> u32;\n+        pub fn cttz64(x: u64) -> u64;\n+\n+        pub fn bswap16(x: u16) -> u16;\n+        pub fn bswap32(x: u32) -> u32;\n+        pub fn bswap64(x: u64) -> u64;\n     }\n }\n \n pub fn main() {\n     unsafe {\n         use rusti::*;\n \n-        assert_eq!(ctpop8(0i8), 0i8);\n-        assert_eq!(ctpop16(0i16), 0i16);\n-        assert_eq!(ctpop32(0i32), 0i32);\n-        assert_eq!(ctpop64(0i64), 0i64);\n-\n-        assert_eq!(ctpop8(1i8), 1i8);\n-        assert_eq!(ctpop16(1i16), 1i16);\n-        assert_eq!(ctpop32(1i32), 1i32);\n-        assert_eq!(ctpop64(1i64), 1i64);\n-\n-        assert_eq!(ctpop8(10i8), 2i8);\n-        assert_eq!(ctpop16(10i16), 2i16);\n-        assert_eq!(ctpop32(10i32), 2i32);\n-        assert_eq!(ctpop64(10i64), 2i64);\n-\n-        assert_eq!(ctpop8(100i8), 3i8);\n-        assert_eq!(ctpop16(100i16), 3i16);\n-        assert_eq!(ctpop32(100i32), 3i32);\n-        assert_eq!(ctpop64(100i64), 3i64);\n-\n-        assert_eq!(ctpop8(-1i8), 8i8);\n-        assert_eq!(ctpop16(-1i16), 16i16);\n-        assert_eq!(ctpop32(-1i32), 32i32);\n-        assert_eq!(ctpop64(-1i64), 64i64);\n-\n-        assert_eq!(ctlz8(0i8), 8i8);\n-        assert_eq!(ctlz16(0i16), 16i16);\n-        assert_eq!(ctlz32(0i32), 32i32);\n-        assert_eq!(ctlz64(0i64), 64i64);\n-\n-        assert_eq!(ctlz8(1i8), 7i8);\n-        assert_eq!(ctlz16(1i16), 15i16);\n-        assert_eq!(ctlz32(1i32), 31i32);\n-        assert_eq!(ctlz64(1i64), 63i64);\n-\n-        assert_eq!(ctlz8(10i8), 4i8);\n-        assert_eq!(ctlz16(10i16), 12i16);\n-        assert_eq!(ctlz32(10i32), 28i32);\n-        assert_eq!(ctlz64(10i64), 60i64);\n-\n-        assert_eq!(ctlz8(100i8), 1i8);\n-        assert_eq!(ctlz16(100i16), 9i16);\n-        assert_eq!(ctlz32(100i32), 25i32);\n-        assert_eq!(ctlz64(100i64), 57i64);\n-\n-        assert_eq!(cttz8(-1i8), 0i8);\n-        assert_eq!(cttz16(-1i16), 0i16);\n-        assert_eq!(cttz32(-1i32), 0i32);\n-        assert_eq!(cttz64(-1i64), 0i64);\n-\n-        assert_eq!(cttz8(0i8), 8i8);\n-        assert_eq!(cttz16(0i16), 16i16);\n-        assert_eq!(cttz32(0i32), 32i32);\n-        assert_eq!(cttz64(0i64), 64i64);\n-\n-        assert_eq!(cttz8(1i8), 0i8);\n-        assert_eq!(cttz16(1i16), 0i16);\n-        assert_eq!(cttz32(1i32), 0i32);\n-        assert_eq!(cttz64(1i64), 0i64);\n-\n-        assert_eq!(cttz8(10i8), 1i8);\n-        assert_eq!(cttz16(10i16), 1i16);\n-        assert_eq!(cttz32(10i32), 1i32);\n-        assert_eq!(cttz64(10i64), 1i64);\n-\n-        assert_eq!(cttz8(100i8), 2i8);\n-        assert_eq!(cttz16(100i16), 2i16);\n-        assert_eq!(cttz32(100i32), 2i32);\n-        assert_eq!(cttz64(100i64), 2i64);\n-\n-        assert_eq!(cttz8(-1i8), 0i8);\n-        assert_eq!(cttz16(-1i16), 0i16);\n-        assert_eq!(cttz32(-1i32), 0i32);\n-        assert_eq!(cttz64(-1i64), 0i64);\n-\n-        assert_eq!(bswap16(0x0A0Bi16), 0x0B0Ai16);\n-        assert_eq!(bswap32(0x0ABBCC0Di32), 0x0DCCBB0Ai32);\n-        assert_eq!(bswap64(0x0122334455667708i64), 0x0877665544332201i64);\n+        assert_eq!(ctpop8(0u8), 0u8);\n+        assert_eq!(ctpop16(0u16), 0u16);\n+        assert_eq!(ctpop32(0u32), 0u32);\n+        assert_eq!(ctpop64(0u64), 0u64);\n+\n+        assert_eq!(ctpop8(1u8), 1u8);\n+        assert_eq!(ctpop16(1u16), 1u16);\n+        assert_eq!(ctpop32(1u32), 1u32);\n+        assert_eq!(ctpop64(1u64), 1u64);\n+\n+        assert_eq!(ctpop8(10u8), 2u8);\n+        assert_eq!(ctpop16(10u16), 2u16);\n+        assert_eq!(ctpop32(10u32), 2u32);\n+        assert_eq!(ctpop64(10u64), 2u64);\n+\n+        assert_eq!(ctpop8(100u8), 3u8);\n+        assert_eq!(ctpop16(100u16), 3u16);\n+        assert_eq!(ctpop32(100u32), 3u32);\n+        assert_eq!(ctpop64(100u64), 3u64);\n+\n+        assert_eq!(ctpop8(-1u8), 8u8);\n+        assert_eq!(ctpop16(-1u16), 16u16);\n+        assert_eq!(ctpop32(-1u32), 32u32);\n+        assert_eq!(ctpop64(-1u64), 64u64);\n+\n+        assert_eq!(ctlz8(0u8), 8u8);\n+        assert_eq!(ctlz16(0u16), 16u16);\n+        assert_eq!(ctlz32(0u32), 32u32);\n+        assert_eq!(ctlz64(0u64), 64u64);\n+\n+        assert_eq!(ctlz8(1u8), 7u8);\n+        assert_eq!(ctlz16(1u16), 15u16);\n+        assert_eq!(ctlz32(1u32), 31u32);\n+        assert_eq!(ctlz64(1u64), 63u64);\n+\n+        assert_eq!(ctlz8(10u8), 4u8);\n+        assert_eq!(ctlz16(10u16), 12u16);\n+        assert_eq!(ctlz32(10u32), 28u32);\n+        assert_eq!(ctlz64(10u64), 60u64);\n+\n+        assert_eq!(ctlz8(100u8), 1u8);\n+        assert_eq!(ctlz16(100u16), 9u16);\n+        assert_eq!(ctlz32(100u32), 25u32);\n+        assert_eq!(ctlz64(100u64), 57u64);\n+\n+        assert_eq!(cttz8(-1u8), 0u8);\n+        assert_eq!(cttz16(-1u16), 0u16);\n+        assert_eq!(cttz32(-1u32), 0u32);\n+        assert_eq!(cttz64(-1u64), 0u64);\n+\n+        assert_eq!(cttz8(0u8), 8u8);\n+        assert_eq!(cttz16(0u16), 16u16);\n+        assert_eq!(cttz32(0u32), 32u32);\n+        assert_eq!(cttz64(0u64), 64u64);\n+\n+        assert_eq!(cttz8(1u8), 0u8);\n+        assert_eq!(cttz16(1u16), 0u16);\n+        assert_eq!(cttz32(1u32), 0u32);\n+        assert_eq!(cttz64(1u64), 0u64);\n+\n+        assert_eq!(cttz8(10u8), 1u8);\n+        assert_eq!(cttz16(10u16), 1u16);\n+        assert_eq!(cttz32(10u32), 1u32);\n+        assert_eq!(cttz64(10u64), 1u64);\n+\n+        assert_eq!(cttz8(100u8), 2u8);\n+        assert_eq!(cttz16(100u16), 2u16);\n+        assert_eq!(cttz32(100u32), 2u32);\n+        assert_eq!(cttz64(100u64), 2u64);\n+\n+        assert_eq!(cttz8(-1u8), 0u8);\n+        assert_eq!(cttz16(-1u16), 0u16);\n+        assert_eq!(cttz32(-1u32), 0u32);\n+        assert_eq!(cttz64(-1u64), 0u64);\n+\n+        assert_eq!(bswap16(0x0A0Bu16), 0x0B0Au16);\n+        assert_eq!(bswap32(0x0ABBCC0Du32), 0x0DCCBB0Au32);\n+        assert_eq!(bswap64(0x0122334455667708u64), 0x0877665544332201u64);\n     }\n }"}, {"sha": "84da2d814d946d0d15669a0c92ed7c30235b2152", "filename": "src/test/run-pass/issue-13494.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13494.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test may not always fail, but it can be flaky if the race it used to\n+// expose is still present.\n+\n+extern crate green;\n+extern crate rustuv;\n+extern crate native;\n+\n+#[start]\n+fn start(argc: int, argv: **u8) -> int {\n+    green::start(argc, argv, rustuv::event_loop, main)\n+}\n+\n+fn helper(rx: Receiver<Sender<()>>) {\n+    for tx in rx.iter() {\n+        let _ = tx.send_opt(());\n+    }\n+}\n+\n+fn test() {\n+    let (tx, rx) = channel();\n+    spawn(proc() { helper(rx) });\n+    let (snd, rcv) = channel();\n+    for _ in range(1, 100000) {\n+        snd.send(1);\n+        let (tx2, rx2) = channel();\n+        tx.send(tx2);\n+        select! {\n+            () = rx2.recv() => (),\n+            _ = rcv.recv() => ()\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let (tx, rx) = channel();\n+    spawn(proc() {\n+        tx.send(test());\n+    });\n+    rx.recv();\n+\n+    let (tx, rx) = channel();\n+    native::task::spawn(proc() {\n+        tx.send(test());\n+    });\n+    rx.recv();\n+}"}, {"sha": "65288cf0416faa8ff49fd6761fa60038fe361810", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/349d66af9420eeeeedfc648eb6ec3fd28015d4b3/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=349d66af9420eeeeedfc648eb6ec3fd28015d4b3", "patch": "@@ -8,30 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-test - FIXME(#8538) some kind of problem linking induced by extern \"C\" fns\n+// ignore-android\n \n-// Smallest hello world with no runtime\n+// Smallest \"hello world\" with a libc runtime\n \n #![no_std]\n \n-// This is an unfortunate thing to have to do on linux :(\n-#[cfg(target_os = \"linux\")]\n-#[doc(hidden)]\n-pub mod linkhack {\n-    #[link_args=\"-lrustrt -lrt\"]\n-    extern {}\n-}\n+extern crate libc;\n \n-extern {\n-    fn puts(s: *u8);\n-}\n+extern { fn puts(s: *u8); }\n+extern \"rust-intrinsic\" { fn transmute<T, U>(t: T) -> U; }\n \n-extern \"rust-intrinsic\" {\n-    fn transmute<T, U>(t: T) -> U;\n-}\n+#[no_mangle]\n+pub extern fn rust_stack_exhausted() {}\n \n #[start]\n-pub fn main(_: int, _: **u8, _: *u8) -> int {\n+#[no_split_stack]\n+fn main(_: int, _: **u8) -> int {\n     unsafe {\n         let (ptr, _): (*u8, uint) = transmute(\"Hello!\");\n         puts(ptr);"}]}